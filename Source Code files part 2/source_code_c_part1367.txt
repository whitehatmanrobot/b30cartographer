r from an arbitrary NT5 application
//			Class TSMapClient is available at runtime for mapping from the application's 
//			way of naming a problem to the Troubleshooter's way.
//			Only a single thread should operate on any one object of class TSMapClient.  The object is not
//			threadsafe.
//			In addition to the overtly noted returns, many methods can return a preexisting error.
//			However, if the calling program has wishes to ignore an error and continue, we 
//			recommend an explicit call to inherited method ClearStatus().
//			Note that the mapping file is always strictly SBCS (Single Byte Character Set), but the
//			calls into this code may use Unicode. This file consequently mixes char and TCHAR.
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 2-26-98
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			JM		Original
///////////////////////

#ifndef _TSMAPCLIENT_
#define _TSMAPCLIENT_ 1

// ----------------- TSMapClient ---------------
// Class providing mapping methods which will be available
//	at runtime when launching a troubleshooter.
class TSMapClient: public TSMapRuntimeAbstract {
public:
	TSMapClient(const TCHAR * const sztMapFile);
	~TSMapClient();
	DWORD Initialize();

private:
	// redefined inherited methods
	DWORD ClearAll ();
	DWORD SetApp (const TCHAR * const sztApp);
	DWORD SetVer (const TCHAR * const sztVer);
	DWORD SetProb (const TCHAR * const sztProb);
	DWORD SetDevID (const TCHAR * const sztDevID);
	DWORD SetDevClassGUID (const TCHAR * const sztDevClassGUID);
	DWORD FromProbToTS (TCHAR * const sztTSBN, TCHAR * const sztNode );
	DWORD FromDevToTS (TCHAR * const sztTSBN, TCHAR * const sztNode );
	DWORD FromDevClassToTS (TCHAR * const sztTSBN, TCHAR * const sztNode );
	DWORD ApplyDefaultVer();
	bool HardMappingError (DWORD dwStatus);

	UID GetGenericMapToUID (const TCHAR * const sztName, DWORD dwOffFirst, DWORD dwOffLast,
						bool bAlphaOrder);
	DWORD SetFilePointerAbsolute( DWORD dwMoveTo );
	bool Read(LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead);
	bool ReadUIDMap (UIDMAP &uidmap, DWORD &dwPosition, bool bSetPosition = false);
	bool ReadAppMap (APPMAP &appmap, DWORD &dwPosition, bool bSetPosition = false);
	bool ReadVerMap (VERMAP &vermap, DWORD &dwPosition, bool bSetPosition = false);
	bool ReadProbMap (PROBMAP &probmap, DWORD &dwPosition, bool bSetPosition = false);
	bool ReadDevMap (DEVMAP &devmap, DWORD &dwPosition, bool bSetPosition = false);
	bool ReadDevClassMap (DEVCLASSMAP &devclassmap, DWORD &dwPosition, bool bSetPosition = false);
	bool ReadString (char * sz, DWORD cbMax, DWORD &dwPosition, bool bSetPosition);

private:
	TCHAR m_sztMapFile[BUFSIZE];	// pathname of file from which to draw mappings
	HANDLE m_hMapFile;			// corresponding handle
	TSMAPFILEHEADER m_header;	// header portion of map file

	// If we satisf ourselves that the SQL Server database used in preparing the mapping file
	//	will produce the collating order we want, we could gain some runtime efficiency
	//	by setting the following true: when we are reading through a file for a match, we
	//	could bail if we got past it.
	bool m_bAppAlphaOrder;
	bool m_bVerAlphaOrder;
	bool m_bDevIDAlphaOrder;
	bool m_bDevClassGUIDAlphaOrder;
	bool m_bProbAlphaOrder;

	// NOTE: because the mapping file is strictly SBCS, so are the cache values.  Typically,
	//	this requires conversion between these values and Unicode arguments to methods.

	// Cache info about selected app.  This lets us know (for example) at what offset
	//	to start a search for relevant versions.
	char m_szApp[BUFSIZE];
	APPMAP m_appmap;

	// Cache info about selected version.  This lets us know (for example) at what offset
	//	to start a search for relevant mappings to troubleshooting belief networks.
	char m_szVer[BUFSIZE];
	VERMAP m_vermap;

	// Cache info about selected device (just name & UID)
	char m_szDevID[BUFSIZE];
	UID m_uidDev;

	// Cache info about selected device class (just name -- a string representing a GUID --
	//	& UID)
	char m_szDevClassGUID[BUFSIZE];
	UID m_uidDevClass;

	// Cache info about selected problem (just name & UID)
	char m_szProb[BUFSIZE];
	UID m_uidProb;

};

#endif // _TSMAPCLIENT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\category.cpp ===
//=============================================================================
// File:			category.cpp
// Author:		a-jammar
// Covers:		CDataCategory
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// For usage, see the header file.
//
// Most of these member functions just call the associated function in
// CDataGatherer using the m_pGatherer and m_dwID members.
//
// Note: most of these methods contain ASSERTs that the gatherer pointer is
// not null and that this is a valid category. Checking that this is a valid
// category is a costly check to do for a retail version, so it is only done
// in debug builds.
//=============================================================================

#include "stdafx.h"
#include "gather.h"
#include "gathint.h"

//-----------------------------------------------------------------------------
// The constructor and destructor are typical. Actual values are put into
// the member variables by CDataGatherer, which creates these objects.
//-----------------------------------------------------------------------------

CDataCategory::CDataCategory()
{
	m_pGatherer = NULL;
	m_dwID = 0;
}

CDataCategory::~CDataCategory()
{
}

//-----------------------------------------------------------------------------
// Return the pointer we keep to the CDataGatherer object.
//-----------------------------------------------------------------------------

CDataGatherer * CDataCategory::GetGatherer()
{
	ASSERT(m_pGatherer && m_pGatherer->IsValidDataCategory(m_dwID));
	if (m_pGatherer)
		m_pGatherer->SetLastError(GATH_ERR_NOERROR);
	return m_pGatherer;
}

//-----------------------------------------------------------------------------
// Return the name of this category (the text used for the tree node label).
//-----------------------------------------------------------------------------

BOOL CDataCategory::GetName(CString &strName)
{
	ASSERT(m_pGatherer && m_pGatherer->IsValidDataCategory(m_dwID));
	if (m_pGatherer)
	{
		m_pGatherer->SetLastError(GATH_ERR_NOERROR);
		return m_pGatherer->GetName(m_dwID, strName);
	}
	return FALSE;
}

//-----------------------------------------------------------------------------
// Find out if this category is still valid by calling the method in our
// CDataGatherer object.
//-----------------------------------------------------------------------------

BOOL CDataCategory::IsValid()
{
	if (m_pGatherer)
	{
		m_pGatherer->SetLastError(GATH_ERR_NOERROR);
		return m_pGatherer->IsValidDataCategory(m_dwID);
	}
	return FALSE;
}

//-----------------------------------------------------------------------------
// All of the following methods for navigating through the category tree simply
// call the appropriate method in the CDataGatherer object. Note that we don't
// need to check if we are a valid category, since the methods we call will.
//-----------------------------------------------------------------------------

CDataCategory * CDataCategory::GetParent()
{
	ASSERT(m_pGatherer);
	if (m_pGatherer)
	{
		m_pGatherer->SetLastError(GATH_ERR_NOERROR);
		return m_pGatherer->GetRelative(m_dwID, CDataGatherer::PARENT);
	}
	return NULL;
}

CDataCategory * CDataCategory::GetChild()
{
	ASSERT(m_pGatherer);
	if (m_pGatherer)
	{
		m_pGatherer->SetLastError(GATH_ERR_NOERROR);
		return m_pGatherer->GetRelative(m_dwID, CDataGatherer::CHILD);
	}
	return NULL;
}

CDataCategory * CDataCategory::GetNextSibling()
{
	ASSERT(m_pGatherer);
	if (m_pGatherer)
	{
		m_pGatherer->SetLastError(GATH_ERR_NOERROR);
		return m_pGatherer->GetRelative(m_dwID, CDataGatherer::NEXT_SIBLING);
	}
	return NULL;
}

CDataCategory * CDataCategory::GetPrevSibling()
{
	ASSERT(m_pGatherer);
	if (m_pGatherer)
	{
		m_pGatherer->SetLastError(GATH_ERR_NOERROR);
		return m_pGatherer->GetRelative(m_dwID, CDataGatherer::PREV_SIBLING);
	}
	return NULL;
}

//-----------------------------------------------------------------------------
// A refresh operation is performed by calling a method in the gatherer
// object. Note that this category might be invalid after this call.
//-----------------------------------------------------------------------------

BOOL CDataCategory::Refresh(BOOL fRecursive, volatile BOOL *pfCancel, BOOL fSoftRefresh)
{
	ASSERT(m_pGatherer);
	if (m_pGatherer)
	{
		// Note - this is done when the user clicks on a category, so call
		// RefreshCategory with the fSoftRefresh flag as TRUE.

		m_pGatherer->SetLastError(GATH_ERR_NOERROR);
		return m_pGatherer->RefreshCategory(m_dwID, fRecursive, pfCancel, fSoftRefresh);
	}
	return FALSE;
}

//-----------------------------------------------------------------------------
// Return whether or not this category has ever been completely refreshed
// (useful to determine if we need to refresh in a soft refresh situation).
//-----------------------------------------------------------------------------

BOOL CDataCategory::HasBeenRefreshed()
{
	ASSERT(m_pGatherer);
	if (m_pGatherer)
	{
		INTERNAL_CATEGORY *	pInternal = m_pGatherer->GetInternalRep(m_dwID);
		if (pInternal)
			return pInternal->m_fRefreshed;
	}
	return FALSE;
}

//-----------------------------------------------------------------------------
// Returns whether or not this category is dynamic (that is, whether or not
// this category might be invalid after a refresh).
//-----------------------------------------------------------------------------

BOOL CDataCategory::IsDynamic()
{
	ASSERT(m_pGatherer);
	if (m_pGatherer)
	{
		m_pGatherer->SetLastError(GATH_ERR_NOERROR);
		return m_pGatherer->IsCategoryDynamic(m_dwID);
	}
	return FALSE;
}

//-----------------------------------------------------------------------------
// This method returns whether or not this category has dynamic children.
// If fRecursive is TRUE, all descendents of this category are checked,
// otherwise only the first generation of children are checked. If 
// HasDynamicChildren(TRUE) returns FALSE, then this category and its children
// do not need to be checked for validity after a refresh.
//-----------------------------------------------------------------------------

BOOL CDataCategory::HasDynamicChildren(BOOL fRecursive)
{
	ASSERT(m_pGatherer);
	if (m_pGatherer)
	{
		m_pGatherer->SetLastError(GATH_ERR_NOERROR);
		return m_pGatherer->HasDynamicChildren(m_dwID, fRecursive);
	}
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\cabfunc.c ===
//===========================================================================
// The following code is based on an example of how to explode a CAB file
// to a directory. The sample was supplied by Mike Sliger. The function names
// have been left the same as those in the sample.
//
// Copyright (c) 1998-1999 Microsoft Corporation
//===========================================================================

#pragma warning(disable : 4514)
#pragma warning(disable : 4201 4214 4115)
#include <windows.h>
#pragma warning(default : 4201 4214 4115)

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <io.h>
#include <fcntl.h>
#include <dos.h>
#include <string.h>

#pragma warning(disable : 4201)
#include <fdi.h>
#pragma warning(default : 4201)

//---------------------------------------------------------------------------
// This is the actual entry point called by the C++ code.
//---------------------------------------------------------------------------

BOOL test_fdi(const char *cabinet_fullpath);
static char dest_dir[MAX_PATH];
BOOL explode_cab(const char *cabinet_fullpath, const char *destination)
{
	char	cab_path[MAX_PATH];

	strcpy(dest_dir, destination);
	strcpy(cab_path, cabinet_fullpath);

	return test_fdi(cabinet_fullpath);
}

//---------------------------------------------------------------------------
// The following definitions are pulled from stat.h and types.h. I was having
// trouble getting the build tree make to pull them in, so I just copied the
// relevant stuff. This may very well need to be changed if those include
// files change.
//---------------------------------------------------------------------------

#define _S_IREAD	0000400 	/* read permission, owner */
#define _S_IWRITE	0000200 	/* write permission, owner */

//---------------------------------------------------------------------------
// All of these functions may be called by the unCAB library.
//---------------------------------------------------------------------------

FNALLOC(mem_alloc)	{	return malloc(cb); }
FNFREE(mem_free)	{	free(pv); }
FNOPEN(file_open)	{	return _open(pszFile, oflag, pmode); }
FNREAD(file_read)	{	return _read((HFILE)hf, pv, cb); }
FNWRITE(file_write)	{	return _write((HFILE)hf, pv, cb); }
FNCLOSE(file_close)	{	return _close((HFILE)hf); }
FNSEEK(file_seek)	{	return _lseek((HFILE)hf, dist, seektype); }




BOOL DoesFileExist(const char *szFile)
{
	HANDLE  handle;
	handle = CreateFileA(szFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (handle != INVALID_HANDLE_VALUE)
	{
		CloseHandle(handle);
		return TRUE;
	}

	return FALSE;
}

//---------------------------------------------------------------------------
// This callback will be called by the unCAB library.
//---------------------------------------------------------------------------

FNFDINOTIFY(notification_function)
{
	switch (fdint)
	{
		case fdintCABINET_INFO: // general information about the cabinet
			return 0;

		case fdintPARTIAL_FILE: // first file in cabinet is continuation
			return 0;

		case fdintCOPY_FILE:	// file to be copied
			{
				int		handle = -1;
				char	destination[MAX_PATH];
				char	szBuffer[MAX_PATH], *szFile;

				// We no longer want to create a directory tree as we expand the files.
				// TSHOOT.EXE, which is used to open some of the files in the CAB, likes
				// to find the files in a nice flat directory. Now we will need to handle
				// name collisions (although there probably won't be many). If we are
				// asked to create a second file with the same name as an existing file,
				// we'll prefix the subdirectory name and an underscore to the new file.

				if (pfdin->psz1 == NULL)
					return 0;

				strcpy(szBuffer, pfdin->psz1);
				szFile = strrchr(szBuffer, '\\');
				while (handle == -1 && szFile != NULL)
				{
					sprintf(destination, "%s\\%s", dest_dir, szFile + 1);
					if (!DoesFileExist(destination))
						handle = (HFILE)file_open(destination, _O_BINARY | _O_CREAT | _O_WRONLY | _O_SEQUENTIAL, _S_IREAD | _S_IWRITE);
					else
					{
						*szFile = '_';
						szFile = strrchr(szBuffer, '\\');
					}
				}

				if (handle == -1)
				{
					sprintf(destination, "%s\\%s", dest_dir, szBuffer);
					handle = (HFILE)file_open(destination, _O_BINARY | _O_CREAT | _O_WRONLY | _O_SEQUENTIAL, _S_IREAD | _S_IWRITE);
				}

				return handle;

				// Old code which created the directory structure:

				#if FALSE
					// If the file we are supposed to create contains path information,
					// we may need to create the directories before create the file.

					char	szDir[MAX_PATH], szSubDir[MAX_PATH], *p;
					
					p = strrchr(pfdin->psz1, '\\');
					if (p)
					{
						strncpy(szSubDir, pfdin->psz1, MAX_PATH);

						p = strchr(szSubDir, '\\');
						while (p != NULL)
						{
							*p = '\0';
							sprintf(szDir, "%s\\%s", dest_dir, szSubDir);
							CreateDirectory(szDir, NULL);
							*p = '\\';
							p = strchr(p+1, '\\');
						}
					}

					sprintf(destination, "%s\\%s", dest_dir, pfdin->psz1);
				#endif
			}

		case fdintCLOSE_FILE_INFO:	// close the file, set relevant info
            {
				HANDLE  handle;
				DWORD   attrs;
				char    destination[MAX_PATH];

				sprintf(destination, "%s\\%s", dest_dir, pfdin->psz1);
				file_close(pfdin->hf);

				// Need to use Win32 type handle to set date/time

				handle = CreateFileA(destination, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

				if (handle != INVALID_HANDLE_VALUE)
				{
					FILETIME    datetime;

					if (TRUE == DosDateTimeToFileTime(pfdin->date, pfdin->time, &datetime))
					{
						FILETIME    local_filetime;

						if (TRUE == LocalFileTimeToFileTime(&datetime, &local_filetime))
						{
							(void) SetFileTime(handle, &local_filetime, NULL, &local_filetime);
						}
					}

					CloseHandle(handle);
				}

				// Mask out attribute bits other than readonly,
				// hidden, system, and archive, since the other
				// attribute bits are reserved for use by
				// the cabinet format.

				attrs = pfdin->attribs;

				// Actually, let's mask out hidden as well.
				// attrs &= (_A_RDONLY | _A_HIDDEN | _A_SYSTEM | _A_ARCH);
				attrs &= (_A_RDONLY | _A_SYSTEM | _A_ARCH);

				(void) SetFileAttributesA(destination, attrs);

				return TRUE;
			}

		case fdintNEXT_CABINET:	// file continued to next cabinet
			return 0;
		
		default:
			return 0;
	}
}

/*
 * isCabFile - Returns TRUE if the file descriptor in hf references a cab file,
 *		FALSE if not.
 *
 * History:	a-jsari		2/17/98		Initial version	
 */
BOOL isCabFile(int hf, void **phfdi)
{
	ERF				erf;
	FDICABINETINFO	fdici;
	BOOL			fReturn;
	HFDI			hfdi = FDICreate(mem_alloc, mem_free, file_open, file_read, file_write,
		file_close, file_seek, cpu80386, &erf);

	if (hfdi == NULL)
	{
		return FALSE;
	}

	fReturn = FDIIsCabinet(hfdi, hf, &fdici);

	if (phfdi == NULL)
	{
		(void) FDIDestroy(hfdi);
	}
	else
	{
		*phfdi = (void *)hfdi;
	}

	return fReturn;
}

//---------------------------------------------------------------------------
// This function is used to actually expand the files in a CAB.
//---------------------------------------------------------------------------

BOOL test_fdi(const char *cabinet_fullpath)
{
	HFDI			hfdi = NULL;
#if 0
	ERF				erf;
	FDICABINETINFO	fdici;
#endif
	int				hf;
	char			*p;
	char			cabinet_name[256];
	char			cabinet_path[256];

#if 0
	hfdi = FDICreate(mem_alloc, mem_free, file_open, file_read, file_write, file_close, file_seek, cpu80386, &erf);

	if (hfdi == NULL)
	{
		return FALSE;
	}
#endif

	hf = (HFILE)file_open((char *)cabinet_fullpath, _O_BINARY | _O_RDONLY | _O_SEQUENTIAL, 0);
	if (hf == -1)
	{
#if 0
		(void) FDIDestroy(hfdi);
#endif

		// printf("Unable to open '%s' for input\n", cabinet_fullpath);
		return FALSE;
	}

#if 0
	if (FALSE == FDIIsCabinet(hfdi, hf, &fdici))
	{
		_close(hf);
		(void) FDIDestroy(hfdi);
		return FALSE;
	}
	else
	{
		_close(hf);
	}
#else
	if (FALSE == isCabFile(hf, &hfdi))
	{
		_close(hf);
		if(hfdi)
		(void) FDIDestroy(hfdi);
		return FALSE;
	}
	else
	{
		_close(hf);
	}
#endif

	p = strrchr(cabinet_fullpath, '\\');

	if (p == NULL)
	{
		strcpy(cabinet_name, cabinet_fullpath);
		strcpy(cabinet_path, "");
	}
	else
	{
		strcpy(cabinet_name, p+1);

		strncpy(cabinet_path, cabinet_fullpath, (int) (p-cabinet_fullpath)+1);
		cabinet_path[ (int) (p-cabinet_fullpath)+1 ] = 0;
	}

	if (TRUE != FDICopy(hfdi, cabinet_name, cabinet_path, 0, notification_function, NULL, NULL))
	{
		(void) FDIDestroy(hfdi);
		return FALSE;
	}

	if (FDIDestroy(hfdi) != TRUE)
		return FALSE;

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\launcher\server\tsmapabstract.h ===
// 
// MODULE: TSMapAbstract.h
//
// PURPOSE: Part of launching a Local Troubleshooter from an arbitrary NT5 application
//			Data types and abstract classes for mapping from the application's way of naming 
//			a problem to the Troubleshooter's way.
//			Implements the few concrete methods of abstract base class TSMapRuntimeAbstract.
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 2-26-98
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			JM		Original
///////////////////////

#ifndef _TSMAPABSTRACT_
#define _TSMAPABSTRACT_ 1

typedef DWORD UID;
const UID uidNil = -1;

// Abstract Base Class providing a minimal set of mapping methods which will be available
//	at runtime when launching a troubleshooter.
class TSMapRuntimeAbstract {
public:
	TSMapRuntimeAbstract();
	virtual ~TSMapRuntimeAbstract() = 0;

private:
	// High level mappings to troubleshooting networks.
	DWORD FromAppVerProbToTS (
		const TCHAR * const szApp, const TCHAR * const szVer, 
		const TCHAR * const szProb, 
		TCHAR * const szTSBN, TCHAR * const szNode);
	DWORD FromAppVerDevIDToTS (
		const TCHAR * const szApp, const TCHAR * const szVer, 
		const TCHAR * const szDevID, const TCHAR * const szProb, 
		TCHAR * const szTSBN, TCHAR * const szNode);
	DWORD FromAppVerDevClassGUIDToTS (
		const TCHAR * const szApp, const TCHAR * const szVer, 
		const TCHAR * const szDevClassGUID, const TCHAR * const szProb, 
		TCHAR * const szTSBN, TCHAR * const szNode);
public:
	DWORD FromAppVerDevAndClassToTS (
		const TCHAR * const szApp, const TCHAR * const szVer, 
		const TCHAR * const szDevID, const TCHAR * const szDevClassGUID, 
		const TCHAR * const szProb, 
		TCHAR * const szTSBN, TCHAR * const szNode);

	// current status 
	DWORD GetStatus() {return m_dwStatus;};
	void ClearStatus() {m_dwStatus = 0;};

	// other statuses reported back by FromAppVerDevAndClassToTS()
	// Call this in a loop until it returns 0;
	inline DWORD MoreStatus()
	{
		if (m_stkStatus.Empty())
			return 0;
		else
			return (m_stkStatus.Pop());
	}
protected:
	// normally returns 0, but can theoretically return TSL_ERROR_OUT_OF_MEMORY
	DWORD AddMoreStatus(DWORD dwStatus);

private:
	bool DifferentMappingCouldWork(DWORD dwStatus);
protected:
	// "Part 1": call these to set query.  Notes here are for the benefit of implementor
	//	of inherited class. -------------------------

	// Any non-zero return of ClearAll is a hard error, means this object cannot be used.
	virtual DWORD ClearAll ();

	// SetApp may return only 
	//	0 (OK) 
	//	TSL_ERROR_UNKNOWN_APP.
	//	hard error specific to the implementation of the concrete class
	virtual DWORD SetApp (const TCHAR * const szApp)= 0;

	// SetVer may return only 
	//	0 (OK)
	//	TSM_STAT_NEED_APP_TO_SET_VER  - must have successful call to SetApp before calling SetVer
	//	TSL_ERROR_UNKNOWN_VER
	//	hard error specific to the implementation of the concrete class
	virtual DWORD SetVer (const TCHAR * const szVer)= 0;

	// SetProb may return only 
	//	0 (OK)
	//	TSM_STAT_UID_NOT_FOUND.  This is not necessarily bad, and results in setting
	//		problem to uidNil. Calling fn must know if that's acceptable.
	//	hard error specific to the implementation of the concrete class
	virtual DWORD SetProb (const TCHAR * const szProb)= 0;

	// SetDevID may return only 
	//	0 (OK)
	//	TSM_STAT_UID_NOT_FOUND.  This is not necessarily bad, and results in setting
	//		(P&P) device to uidNil. Calling fn must know if that's acceptable.
	//	hard error specific to the implementation of the concrete class
	virtual DWORD SetDevID (const TCHAR * const szDevID)= 0;

	// SetDevClassGUID may return only 
	//	0 (OK)
	//	TSM_STAT_UID_NOT_FOUND.  This is not necessarily bad, and results in setting
	//		device class to uidNil. Calling fn must know if that's acceptable.
	//	hard error specific to the implementation of the concrete class
	virtual DWORD SetDevClassGUID (const TCHAR * const szDevClassGUID)= 0;

	// "Part 2": Low level mappings to troubleshooting networks ------------

	// FromProbToTS may return only 
	//	0 (OK)
	//	TSM_STAT_NEED_PROB_TO_SET_TS - Nil problem, so we can't do this mapping.
	//	TSL_ERROR_NO_NETWORK - Mapping failed
	//	hard error specific to the implementation of the concrete class
	virtual DWORD FromProbToTS (TCHAR * const szTSBN, TCHAR * const szNode )= 0;

	// FromDevToTS may return only 
	//	0 (OK)
	//	TSM_STAT_NEED_DEV_TO_SET_TS - Nil device, so we can't do this mapping.
	//	TSL_ERROR_NO_NETWORK - Mapping failed
	//	hard error specific to the implementation of the concrete class
	virtual DWORD FromDevToTS (TCHAR * const szTSBN, TCHAR * const szNode )= 0;

	// FromDevClassToTS may return only 
	//	0 (OK)
	//	TSM_STAT_NEED_DEVCLASS_TO_SET_TS - Nil device class, so we can't do this mapping.
	//	TSL_ERROR_NO_NETWORK - Mapping failed
	//	hard error specific to the implementation of the concrete class
	virtual DWORD FromDevClassToTS (TCHAR * const szTSBN, TCHAR * const szNode )= 0;

	// other functions -----------------------

	// ApplyDefaultVer may return only 
	//	0 (OK)
	//	TSM_STAT_NEED_APP_TO_SET_VER - must have successful call to SetApp before calling 
	//									ApplyDefaultVer
	//	TSM_STAT_NEED_VER_TO_SET_VER - must have successful call to SetVer before calling 
	//									ApplyDefaultVer
	//	TSL_ERROR_UNKNOWN_VER - the version we are mapping _from_ is undefined.  This
	//									would mean a real coding mess someplace.
	//	hard error specific to the implementation of the concrete class
	virtual DWORD ApplyDefaultVer() = 0;

	// HardMappingError returns true on errors considered "hard" by the concrete class.
	virtual bool HardMappingError (DWORD dwStatus);

protected:
	DWORD m_dwStatus;
	RSStack<DWORD> m_stkStatus;	// Status and Error codes that happened during mapping.

};

#endif // _TSMAPABSTRACT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\choosert.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by chooser.rc
//
// Copyright (c) 1998-1999 Microsoft Corporation

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1002
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\chooserd.h ===
// chooserd.h - Contains default resource IDs for chooser.rc
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// HISTORY
// 26-May-1997	t-danm		Creation.
//

//
// The _CHOOSER_BASE_RESOURCE_ID is there to allow relocatable resource IDs
//
#ifndef _CHOOSER_BASE_RESOURCE_ID
	#define _CHOOSER_BASE_RESOURCE_ID	970	// Arbitrary chosen
#endif

// Dialog ID
#ifndef IDD_CHOOSER_CHOOSE_MACHINE
	#define IDD_CHOOSER_CHOOSE_MACHINE 		_CHOOSER_BASE_RESOURCE_ID
#endif

// Dialog Controls
#ifndef IDC_CHOOSER_STATIC
	#define IDC_CHOOSER_STATIC						(_CHOOSER_BASE_RESOURCE_ID+0)
	#define IDC_CHOOSER_GROUP_TARGET_MACHINE		(_CHOOSER_BASE_RESOURCE_ID+1)
	#define IDC_CHOOSER_RADIO_LOCAL_MACHINE			(_CHOOSER_BASE_RESOURCE_ID+2)
	#define IDC_CHOOSER_RADIO_SPECIFIC_MACHINE		(_CHOOSER_BASE_RESOURCE_ID+3)
	#define IDC_CHOOSER_EDIT_MACHINE_NAME			(_CHOOSER_BASE_RESOURCE_ID+4)
	#define IDC_CHOOSER_BUTTON_BROWSE_MACHINENAMES	(_CHOOSER_BASE_RESOURCE_ID+5)
	#define IDC_CHOOSER_CHECK_OVERRIDE_MACHINE_NAME (_CHOOSER_BASE_RESOURCE_ID+6)
#endif

// Strings
#ifndef IDS_CHOOSER_INVALID_COMPUTERNAME
	#define IDS_CHOOSER_INVALID_COMPUTERNAME		(_CHOOSER_BASE_RESOURCE_ID+0)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\consts.h ===
//	Consts.h	
//
//  Copyright (c) 1998-1999 Microsoft Corporation

#ifndef MSINFO_CONSTS_H
#define MSINFO_CONSTS_H

extern const CLSID		CLSID_MSInfo;		// In-Proc server GUID
extern const CLSID		CLSID_About;
extern const CLSID		CLSID_Extension;	// In-Proc server GUID
extern const CLSID		CLSID_SystemInfo;

extern LPCTSTR			cszClsidMSInfoSnapin;
extern LPCTSTR			cszClsidAboutMSInfo;
extern LPCTSTR			cszClsidMSInfoExtension;

extern LPCTSTR			cszWindowsCurrentKey;
extern LPCTSTR			cszCommonFilesValue;

// Static NodeType GUID in numeric & string formats.
extern const GUID		cNodeTypeStatic;
extern LPCTSTR			cszNodeTypeStatic;

// Dynamicaly created objects.
extern const GUID		cNodeTypeDynamic;
extern LPCTSTR			cszNodeTypeDynamic;

// Result items object type GUID in numeric & string formats.
extern const GUID		cObjectTypeResultItem;
extern LPCTSTR			cszObjectTypeResultItem;

//	Prototypes required so that the linker munges the names properly.
extern const IID IID_IComponentData;
extern const IID IID_IConsole;
extern const IID IID_IConsoleNameSpace;
extern const IID IID_IComponent;
extern const IID IID_IEnumTASK;
extern const IID IID_IExtendContextMenu;
extern const IID IID_IExtendControlbar;
extern const IID IID_IExtendPropertySheet;
extern const IID IID_IExtendTaskPad;
extern const IID IID_IHeaderCtrl;
extern const IID IID_IResultData;
extern const IID IID_IResultDataCompare;
extern const IID IID_IResultOwnerData;
extern const IID IID_ISnapinAbout;
extern const IID IID_ISystemInfo;

extern const IID LIBID_MSINFOSNAPINLib;

// Clipboard format strings.
#define	CF_MACHINE_NAME			_T("MMC_SNAPIN_MACHINE_NAME")
#define CF_INTERNAL_OBJECT		_T("MSINFO_DATA_OBJECT")

//		This is the saved console file which contains the directory to try to
//		find MSInfo in, if for some reason we can't find find our key in the
//		registry.
extern LPCTSTR		cszDefaultDirectory;
//		The root registry key where we should find our data.
extern LPCTSTR		cszRegistryRoot;
//		The key which stores the Directory where we can find our saved console.
extern LPCTSTR		cszDirectoryKey;
//		The root name for our internal data structure.
extern LPCTSTR		cszRootName;
//		Constants for the access function.
enum	AccessConstants { A_EXIST = 0x00, A_WRITE = 0x02, A_READ = 0x04 };

#endif	// MSINFO_CONSTS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\dataobj.cpp ===
// DataObj.cpp: Implementation of the Management Console interface
//		representation of a data object.
//
// Copyright (c) 1998-1999 Microsoft Corporation

#include "StdAfx.h"
#include "DataObj.h"

//	This hack is required because we may be building in an environment
//	which doesn't have a late enough version of rpcndr.h
#if		__RPCNDR_H_VERSION__ < 440
#define __RPCNDR_H_VERSION__ 440
#define MIDL_INTERFACE(x)	interface
#endif

#ifndef __mmc_h__
#include <mmc.h>
#endif // __mmc_h__
#ifndef IDS_NODENAME
#include "Resource.h"
#endif // IDS_NODENAME

//	Default initialization of the static members.
//	Note that snap-ins only work as unicode binaries, so no conversion is
//	required for these strings.
unsigned int CDataObject::m_cfMultiSel			= RegisterClipboardFormat(CCF_OBJECT_TYPES_IN_MULTI_SELECT);
unsigned int CDataObject::m_cfCoClass			= RegisterClipboardFormat(CCF_SNAPIN_CLASSID);
unsigned int CDataObject::m_cfDisplayName		= RegisterClipboardFormat(CCF_DISPLAY_NAME);
unsigned int CDataObject::m_cfNodeTypeString	= RegisterClipboardFormat(CCF_SZNODETYPE);
unsigned int CDataObject::m_cfNodeType			= RegisterClipboardFormat(CCF_NODETYPE);
unsigned int CDataObject::m_cfSnapinPreloads	= RegisterClipboardFormat(CCF_SNAPIN_PRELOADS);
unsigned int CDataObject::m_cfMachineName		= RegisterClipboardFormat(CF_MACHINE_NAME);
unsigned int CDataObject::m_cfInternalObject	= RegisterClipboardFormat(CF_INTERNAL_OBJECT);

/*
 * CDataObject() - The CDataObject constructor.  Register all of the
 *		appropriate clipboard formats potentially used by the object.
 *
 * History:	a-jsari		9/1/97		Initial version
 */
CDataObject::CDataObject()
:m_pbMultiSelData(0), m_cbMultiSelData(0), m_bMultiSelDobj(FALSE),
m_pComponentData(NULL)
{
	USES_CONVERSION;

	ASSERT(IsValidRegisteredClipboardFormat(m_cfNodeType));
	ASSERT(IsValidRegisteredClipboardFormat(m_cfNodeTypeString));
	ASSERT(IsValidRegisteredClipboardFormat(m_cfDisplayName));
	ASSERT(IsValidRegisteredClipboardFormat(m_cfCoClass));
	ASSERT(IsValidRegisteredClipboardFormat(m_cfMultiSel));
	ASSERT(IsValidRegisteredClipboardFormat(m_cfSnapinPreloads));
	ASSERT(IsValidRegisteredClipboardFormat(m_cfMachineName));
	ASSERT(IsValidRegisteredClipboardFormat(m_cfInternalObject));

	m_internal.m_cookie = 0;
	m_internal.m_type = CCT_UNINITIALIZED;
}

/*
 * ~CDataObject() - The Destructor (does nothing)
 *
 * History:	a-jsari		9/1/97		Initial version
 */
CDataObject::~CDataObject()
{
}

/*
 * GetData - Return in lpMedium the data for the data format in lpFormatetc.
 *
 * History:	a-jsari		9/1/97		Initial version
 */
STDMETHODIMP CDataObject::GetData(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium)
{
	TRACE(_T("CDataObject::GetData\n"));
	ASSERT(lpFormatetc != NULL);
	ASSERT(lpMedium != NULL);

	if (!(lpFormatetc && lpMedium))	return E_POINTER;

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT hr = DV_E_CLIPFORMAT;

	if (lpFormatetc->cfFormat == m_cfMultiSel) {
		ASSERT(Cookie() == MMC_MULTI_SELECT_COOKIE);

		if (Cookie() != MMC_MULTI_SELECT_COOKIE) return E_FAIL;

		ASSERT(m_pbMultiSelData != 0);
		ASSERT(m_cbMultiSelData != 0);

		lpMedium->tymed = TYMED_HGLOBAL;
		lpMedium->hGlobal = ::GlobalAlloc(GMEM_SHARE|GMEM_MOVEABLE,
					(m_cbMultiSelData + sizeof(DWORD)));

		if (lpMedium->hGlobal == NULL) return STG_E_MEDIUMFULL;

		BYTE	*pb = reinterpret_cast<BYTE *>(::GlobalLock(lpMedium->hGlobal));
		// Store count.
		*((DWORD*)pb) = m_cbMultiSelData / sizeof(GUID);
		pb += sizeof(DWORD);
		// Store the rest of it.
		CopyMemory(pb, m_pbMultiSelData, m_cbMultiSelData);

		::GlobalUnlock(lpMedium->hGlobal);

		hr = S_OK;
	}

	return hr;
}

/*
 * GetDataHere - Returns in pMedium, the data requested by the clipboard
 *		format in pFormatetc
 *
 * History:	a-jsari		9/2/97		Initial version
 *
 * Note: The HGLOBAL in pMedium will need to be released by the caller.
 */
STDMETHODIMP CDataObject::GetDataHere(LPFORMATETC pFormatetc, LPSTGMEDIUM pMedium)
{
	TRACE(_T("CDataObject::GetDataHere(%x)\n"), pFormatetc->cfFormat);
	ASSERT(pFormatetc != NULL);
	ASSERT(pMedium != NULL);
	ASSERT(pFormatetc->tymed == TYMED_HGLOBAL);

	if (pFormatetc == NULL || pMedium == NULL)	return E_POINTER;

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT hr = DV_E_CLIPFORMAT;

	const CLIPFORMAT cf = pFormatetc->cfFormat;

	if (cf == m_cfNodeType) {
		hr = CreateNodeTypeData(pMedium);
	} else if (cf == m_cfCoClass) {
		hr = CreateCoClassID(pMedium);
	} else if (cf == m_cfNodeTypeString) {
		hr = CreateNodeTypeStringData(pMedium);
	} else if (cf == m_cfDisplayName) {
		hr = CreateDisplayName(pMedium);
	} else if (cf == m_cfMachineName) {
		hr = CreateMachineName(pMedium);
	} else if (cf == m_cfInternalObject) {
		hr = CreateInternalObject(pMedium);
	} else if (cf == m_cfSnapinPreloads) {
		hr = CreateSnapinPreloads(pMedium);
	} else {
		//	Unknown clipboard format.
		ASSERT(FALSE);
	}

	return hr;
}

/*
 * EnumFormatEtc - We don't yet return an enumeration interface for our clipboard
 *		formats.
 *
 * History:	a-jsari		9/2/97		Stub version
 */
STDMETHODIMP CDataObject::EnumFormatEtc(DWORD, LPENUMFORMATETC *ppEnumFormatEtc)
{
	TRACE(_T("CDataObject::EnumFormatEtc\n"));
	ASSERT(ppEnumFormatEtc != NULL);

	if (ppEnumFormatEtc == NULL) return E_POINTER;

	return E_NOTIMPL;
}

/*
 * QueryGetData -
 *
 * History:	a-jsari		9/2/97		Stub version
 */
STDMETHODIMP CDataObject::QueryGetData(LPFORMATETC lpFormatetc)
{
	TRACE(_T("CDataObject::QueryGetData\n"));
	ASSERT(lpFormatetc != NULL);

	if (lpFormatetc == NULL) return E_POINTER;

	return E_NOTIMPL;
}

/*
 * GetCanonicalFormatEtc - Not implemented.
 *
 * History:	a-jsari		9/2/97		Stub version
 */
STDMETHODIMP CDataObject::GetCanonicalFormatEtc(LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut)
{
	TRACE(_T("CDataObject::GetCanonicalFormatEtc\n"));
	ASSERT(lpFormatetcIn != NULL);
	ASSERT(lpFormatetcOut != NULL);

	if (lpFormatetcIn == NULL || lpFormatetcOut == NULL) return E_POINTER;

	return E_NOTIMPL;
}

/*
 * SetData -
 *
 * History:	a-jsari		9/2/97		Stub version
 */
STDMETHODIMP CDataObject::SetData(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL)
{
	TRACE(_T("CDataObject::GetCanonicalFormatEtc\n"));
	ASSERT(lpFormatetc != NULL);
	ASSERT(lpMedium != NULL);

	if (lpFormatetc == NULL || lpMedium == NULL) return E_POINTER;

	return E_NOTIMPL;
}

/*
 * DAdvise -
 *
 * History:	a-jsari		9/2/97		Stub version
 */
STDMETHODIMP CDataObject::DAdvise(LPFORMATETC lpFormatetc, DWORD, LPADVISESINK pAdvSink, LPDWORD pdwConnection)
{
	TRACE(_T("CDataObject::DAdvise\n"));
	ASSERT(lpFormatetc != NULL);
	ASSERT(pAdvSink != NULL);
	ASSERT(pdwConnection != NULL);

	if (lpFormatetc == NULL || pAdvSink == NULL || pdwConnection == NULL) return E_POINTER;

	return E_NOTIMPL;
}

/*
 * DUnadvise -
 *
 * History: a-jsari		9/2/97		Stub version
 */
STDMETHODIMP CDataObject::DUnadvise(DWORD)
{
	TRACE(_T("CDataObject::DUnadvise\n"));
	return E_NOTIMPL;
}

/*
 * EnumDAdvise -
 *
 * History:	a-jsari		9/2/97		Stub version
 */
STDMETHODIMP CDataObject::EnumDAdvise(LPENUMSTATDATA *ppEnumAdvise)
{
	TRACE(_T("CDataObject::EnumDAdvise\n"));
	ASSERT(ppEnumAdvise != NULL);

	if (ppEnumAdvise == NULL) return E_POINTER;

	return E_NOTIMPL;
}

/*
 * Create - copy size bytes from pBuffer into a globally allocated
 *		segment into lpMedium.
 *
 * History:	a-jsari		9/1/97		Initial version
 */
HRESULT CDataObject::Create(const void *pBuffer, int size, LPSTGMEDIUM lpMedium)
{
	HRESULT hr = DV_E_TYMED;

	ASSERT(pBuffer != NULL);
	ASSERT(lpMedium != NULL);
	if (pBuffer == NULL || lpMedium == NULL) return E_POINTER;

	// Make sure the type medium is HGLOBAL
	if (lpMedium->tymed == TYMED_HGLOBAL) {
		LPSTREAM	lpStream;

		hr = CreateStreamOnHGlobal(lpMedium->hGlobal, FALSE, &lpStream);

		if (SUCCEEDED(hr)) {
			// Write size bytes to the stream.

			unsigned long cWritten;
			hr = lpStream->Write(pBuffer, size, &cWritten);

			//	Because we called CreateStreamOnHGlobal with
			//	fDeleteOnRelease == FALSE, lpMedium->hGlobal points to
			//	GlobalAlloc'd memory.
			//
			//	Note - the caller (i.e. snap-in, object) is responsible for
			//	freeing the HGLOBAL at the correct time, following the
			//	IDataObject specification.
			lpStream->Release();
		}
	}

	return hr;
}

/*
 * CreateCoClassID - Return an allocated copy of the CLSID in lpMedium.
 *
 * History:	a-jsari		9/1/97		Initial version
 *
 * Note: The hGlobal in lpMedium must be freed by the caller.  (See Create for
 *		details).
 */
HRESULT CDataObject::CreateCoClassID(LPSTGMEDIUM lpMedium)
{
	CLSID		clsidNew;

	clsidNew = ClassID();
	HRESULT hr = Create(reinterpret_cast<const void *>(&clsidNew), sizeof(CLSID), lpMedium);
	return hr;
}

/*
 * CreateSnapinPreloads - Return the preload status for the snapin, which is the
 *		flag reflecting whether the root node name can be set on load.  I think.
 *		We're not going to do any of that.  Implemented because we get asked about
 *		it when we save our MSC file.
 *
 * History:	a-jsari		3/10/98		Initial version
 */
HRESULT CDataObject::CreateSnapinPreloads(LPSTGMEDIUM lpMedium)
{
	BOOL	fPreload = FALSE;
	return Create(reinterpret_cast<const void *>(&fPreload), sizeof(BOOL), lpMedium);
}

/*
 * CreateMachineName - Put a wide character string containing the name
 *		of the system Information Machine into lpMedium
 *
 * History:	a-jsari		9/22/97		Initial version
 */
HRESULT CDataObject::CreateMachineName(LPSTGMEDIUM lpMedium)
{
	int		wMachineNameLength = 0;
	LPWSTR	szMachineName = NULL;

	USES_CONVERSION;

	//	TSTR to WSTR
	if (pComponentData())
	{
		szMachineName = WSTR_FROM_CSTRING(pComponentData()->MachineName());
		if (szMachineName)
			wMachineNameLength = wcslen(szMachineName);
	}

	return Create(szMachineName, ((wMachineNameLength + 1) * sizeof(WCHAR)), lpMedium);
}

/*
 * CreateMultiSelData - Return in lpMedium a copy of a pointer to the
 *		multiple selection.
 *
 * History:	a-jsari		9/1/97		Initial version
 */
HRESULT CDataObject::CreateMultiSelData(LPSTGMEDIUM lpMedium)
{
	ASSERT(Cookie() == MMC_MULTI_SELECT_COOKIE);

	ASSERT(m_pbMultiSelData != 0);
	ASSERT(m_cbMultiSelData != 0);

	return Create(reinterpret_cast<const void *>(m_pbMultiSelData), m_cbMultiSelData,
			lpMedium);
}

/*
 * CreateInternalObject - Return in lpMedium a copy of a pointer to the
 *		current object.
 *
 * History: a-jsari		9/25/97		Initial version
 */
HRESULT CDataObject::CreateInternalObject(LPSTGMEDIUM lpMedium)
{
	CDataObject *pCopyOfMe = this;
	return Create(reinterpret_cast<const void *>(&pCopyOfMe), sizeof(CDataObject *),
			lpMedium);
}

/*
 * InstantiateDataObject - Creates the appropriate CDataObject based on the
 *		type of the data object.
 *
 * History: a-jsari		9/28/97		Initial version
 */
static inline CDataObject *InstantiateDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type)
{
	CDataObject		*rDataObject	= NULL;

	if (cookie == 0) {
		CComObject<CManagerDataObject>*	pManagerObject;
		CComObject<CManagerDataObject>::CreateInstance(&pManagerObject);
		rDataObject = pManagerObject;
	} else
		switch (type) {
		case CCT_SCOPE:
			CComObject<CScopeDataObject>*	pScopeObject;
			CComObject<CScopeDataObject>::CreateInstance(&pScopeObject);
			rDataObject = pScopeObject;
			break;
		case CCT_RESULT:
			CComObject<CResultDataObject>*	pResultObject;
			CComObject<CResultDataObject>::CreateInstance(&pResultObject);
			rDataObject = pResultObject;
			break;
		default:
			ASSERT(FALSE);
			return NULL;
			break;
		}

	if(rDataObject)
	{
		rDataObject->SetCookie(cookie);
		rDataObject->SetContext(type);
	}
	return rDataObject;
}

/*
 * CreateDataObject - Queries an ATL instantiation of the CDataObject for
 *		the IDataObject interface pointer represented by cookie and type,
 *		returning it in ppDataObject.
 *
 * Return codes:
 *		S_OK - Successful completion
 *		E_POINTER - pImpl or ppDataObject is an invalid pointer
 *		E_FAIL - CComObject<CDataObject>::CreateInstance failed.
 *
 * History:	a-jsari		9/28/97		Initial version
 */
HRESULT CDataObject::CreateDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
			CSystemInfoScope *pScope, LPDATAOBJECT *ppDataObject)
{
	ASSERT(ppDataObject != NULL);
	ASSERT(pScope != NULL);

	if (ppDataObject == NULL || pScope == NULL) return E_POINTER;

	CDataObject		*pObject = InstantiateDataObject(cookie, type);
	ASSERT(pObject != NULL);

	if (pObject == NULL) return E_FAIL;

	pObject->SetComponentData(pScope);

	return pObject->QueryInterface(IID_IDataObject, reinterpret_cast<void **>(ppDataObject));
}

/*
 * CompareObjects - Returns S_OK if lpDataObjectA and lpDataObjectB are equivalent,
 *		S_FALSE otherwise.
 *
 * History:	a-jsari		10/2/97		Stub version
 */
HRESULT CDataObject::CompareObjects(LPDATAOBJECT, LPDATAOBJECT)
{
	//	FIX:	Write this.
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\compdata.h ===
// CompData.h : ComponentData Implementation classes.
//
// Copyright (c) 1998-1999 Microsoft Corporation

#pragma once
#define MSINFO_COMPDATA_H

#include "StdAfx.h"

#include <atlcom.h>

#ifndef IDS_DESCRIPTION
#include "Resource.h"
#endif // IDS_DESCRIPTION

//	This hack is required because we may be building in an environment
//	which doesn't have a late enough version of rpcndr.h
#if		__RPCNDR_H_VERSION__ < 440
#define __RPCNDR_H_VERSION__ 440
#define MIDL_INTERFACE(x)	interface
#endif

#ifndef __mmc_h__
#include <mmc.h>		//	..\..\..\public\sdk\inc
#endif // __mmc_h__

#include "DataObj.h"
#include "DataSrc.h"
#include "ScopeMap.h"
#include "SysInfo.h"
#include "chooser.h"
#include "Dialogs.h"

#ifndef IDS_SNAPIN_DESC
#define IDS_SNAPIN_DESC		IDS_DESCRIPTION
#endif	// IDS_SNAPIN_DESC

#ifndef IDS_EXTENSION_DESC
#define IDS_EXTENSION_DESC	IDS_DESCRIPTION
#endif	// IDS_EXTENSION_DESC

/*
 * CSystemInfoScope - the class interface to the Microsoft Management
 *		Console namespace items of the MSInfo Snap-in.
 */
class CSystemInfoScope:
	public IComponentData,
	public IExtendContextMenu,
	public IExtendPropertySheet,
	public IPersistStream,
	public ISnapinHelp,
	public CComObjectRoot
{
BEGIN_COM_MAP(CSystemInfoScope)
	COM_INTERFACE_ENTRY(IComponentData)
	COM_INTERFACE_ENTRY(IExtendContextMenu)
	COM_INTERFACE_ENTRY(IExtendPropertySheet)
	COM_INTERFACE_ENTRY(IPersistStream)
	COM_INTERFACE_ENTRY(ISnapinHelp)
END_COM_MAP()

friend class CDataObject;
friend class CCabTool;
friend HRESULT CSystemInfo::OnDoubleClick(LPDATAOBJECT);
friend HRESULT CSystemInfo::OnRefresh(LPDATAOBJECT);
friend STDMETHODIMP CSystemInfo::GetDisplayInfo(LPRESULTDATAITEM);
friend STDMETHODIMP CSystemInfo::Notify(LPDATAOBJECT pDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
friend void CSystemInfo::SetInitialVerbState(BOOL);
friend HRESULT CSystemInfo::OnPropertyChange(LPDATAOBJECT);
friend void CSystemInfo::SetRefreshing(LPARAM lparamMessage);

//	Constructors and destructors.
public:
	CSystemInfoScope();
	~CSystemInfoScope();

public:
	virtual const CLSID		&GetCoClassID() = 0;
	virtual const BOOL		IsPrimaryImpl() = 0;

//	IComponentData interface members
public:
	STDMETHOD(Initialize)(LPUNKNOWN pUnknown);
	STDMETHOD(CreateComponent)(LPCOMPONENT *ppComponent);
	STDMETHOD(Destroy)();
	STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
	STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT *ppDataObject);
	STDMETHOD(GetDisplayInfo)(SCOPEDATAITEM *pScopeDataItem);
	STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);

//	IExtendContextMenu interface members
public:
	STDMETHOD(AddMenuItems)(LPDATAOBJECT lpDataObject, LPCONTEXTMENUCALLBACK pCallback,
				long *pInsertionAllowed);
	STDMETHOD(Command)(long lCommandID, LPDATAOBJECT lpDataObject);

//	IExtendPropertySheet interface members
public:
	STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider, LONG_PTR handle,
				LPDATAOBJECT lpDataObject);
	STDMETHOD(QueryPagesFor)(LPDATAOBJECT lpDataObject);

//	IPersistStream interface members
public:
	STDMETHOD(GetClassID)(CLSID *pClassID);
	STDMETHOD(IsDirty)();
	STDMETHOD(Load)(IStream *pReadStream);
	STDMETHOD(Save)(IStream *pWriteStream, BOOL fClearDirty = TRUE);
	STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize);

// ISnapinHelp interface member
public:
	STDMETHOD(GetHelpTopic)(LPOLESTR __RPC_FAR *lpCompiledHelpFile);

public:
	void		SaveReport();
	void		SaveFile();
	void		PrintReport();
	void		DoFind();
	void		OpenFile();
	void		CloseFile();
	void		SetSelectedFolder(CFolder *pFolder);
	BOOL		SelectItem(const CString &szPath, int iLine = 0);
	void		SetView(enum DataComplexity, BOOL fViewInitialized = TRUE);
	MMC_COOKIE	RootCookie()	{ return m_RootCookie; }
	void		WaitForRefresh();
	BOOL		InRefresh();
	void		RefreshAsync(CFolder * pFolder, CSystemInfo * pSystemInfo, BOOL fSoftRefresh = TRUE);

//	Persistance debug instance variables
private:
	bool m_bInitializedCD;
#ifdef _DEBUG
	bool m_bLoadedCD;
	bool m_bDestroyedCD;
#endif	// _DEBUG

public:
	enum CommandID { IDM_SAVEREPORT, IDM_SAVEFILE, IDM_FIND, IDM_PRINT, IDM_TASK_OPENFILE, IDM_TASK_CLOSE,
		IDM_TASK_FIND, IDM_TASK_SAVEREPORT, IDM_TASK_SAVEFILE, IDM_TASK_PRINT, IDM_TASK_VIEWCAB, IDM_VIEW_ADVANCED, IDM_VIEW_BASIC };

//	Private helper functions
private:
	// AddToTopMenu is a convenience wrapper for AddToMenu
	HRESULT			AddToTopMenu(LPCONTEXTMENUCALLBACK lpCallback, long lNameResource, long lStatusResource, long lCommandID)
	{
		return AddToMenu(lpCallback, lNameResource, lStatusResource, lCommandID,
				CCM_INSERTIONPOINTID_PRIMARY_TOP, 0L);
	}
	// AddToTaskMenu is a convenience wrapper for AddToMenu
	HRESULT			AddToTaskMenu(LPCONTEXTMENUCALLBACK lpCallback, long lNameResource,
			long lStatusResource, long lCommandID)
	{
		return AddToMenu(lpCallback, lNameResource, lStatusResource, lCommandID,
				CCM_INSERTIONPOINTID_PRIMARY_TASK, 0L);
	}
	// AddToViewMenu is a convenience wrapper for AddToMenu
	HRESULT			AddToViewMenu(LPCONTEXTMENUCALLBACK lpCallback, long lNameResource,
			long lStatusResource, long lCommandID, long fFlags)
	{
		return AddToMenu(lpCallback, lNameResource, lStatusResource, lCommandID,
				CCM_INSERTIONPOINTID_PRIMARY_VIEW, fFlags);
	}
	HRESULT			AddToMenu(LPCONTEXTMENUCALLBACK lpCallback, long lNameResource,
			long lStatusResource, long lCommandID, long lInsertionPoint, long fFlags);

	HRESULT			AddToolbarButtons(LPTOOLBAR pToolbar);
	HRESULT			RefreshNameSpace();
	HRESULT			AddSubMenu(CMenu *pMenu, void *pContext);
	HRESULT			AddRoot(HSCOPEITEM hsiRoot, CFolder **ppFolder);
	HRESULT			AddExtensionRoot(HSCOPEITEM &hsiNode, CFolder **ppFolder);
	HRESULT			ScopeEnumerate(HSCOPEITEM hsiNode, CFolder *pFolder);
	HRESULT			InitializeDialogs();
	HRESULT			InitializeInternal();
	void			DestroyInternal();
	HRESULT			ProcessCommandLine();
	HRESULT			MessageBox( CString lpszText);

	//	We can't initialize in the Initialize function, so the real initialization
	//	happens here.
	HRESULT			InitializeSource();
	HRESULT			InitializeView();
	BOOL			SetMachine(const CString &strMachine);
	HRESULT			PreUIInit();
	void			PostUIInit();

//	Member access function
public:
	CFolder			*pRootCategory() const	{ return pSource() ? pSource()->GetRootNode() : NULL; }
	void			CloseFindWindow();
	void			ExecuteFind(long lFindState);
	void			Refresh(CFolder *pfSelected = NULL, CSystemInfo * pSystemInfo = NULL);
	void			StopFind();
	LPCTSTR			MachineName() const;
	void			DisplayGatherError(DWORD dwError, LPCTSTR szMachineName = NULL);

//	Member access functions.
private:
	LPCONSOLENAMESPACE	pScope() const			{ return m_pScope; }
	LPCONSOLE			pConsole() const		{ return m_pConsole; }
	CDataSource			*pSource() const		{ return m_pSource; }
	void				SetSource(CDataSource *pNewSource, BOOL fPreLaunch = FALSE);

//	Notify handler declarations
private:
	//	We will probably never implement these methods.
	HRESULT OnRemoveChildren(long arg);
	HRESULT OnExpand(LPDATAOBJECT lpDataObject, LPARAM fExpand, HSCOPEITEM hsiNode);
	HRESULT OnProperties(LPARAM param);

//	Member access functions
private:
	void		SetDirty(BOOL b = TRUE)	{ m_bIsDirty = b; }
	void		ClearDirty()			{ SetDirty(FALSE); }
	BOOL		ObjectIsDirty()			{ return m_bIsDirty; }

//	Internal data.
private:
	LPCONSOLENAMESPACE		m_pScope;
	LPCONSOLE				m_pConsole;
	BOOL					m_fViewUninitialized;
	CDataSource				*m_pSource;
	CMSInfoReportDialog		*m_prdReport;
	CMSInfoSaveDialog		*m_prdSave;
	CMSInfoOpenDialog		*m_prdOpen;
	long					m_BasicFlags;
	long					m_AdvancedFlags;
	CWnd					*m_pwConsole;
	CFindThread				*m_pthdFind;
	HWND					m_hwndFind;
	MMC_COOKIE				m_RootCookie;
	CFolder					*m_pfLast;
	CString					*m_pstrCategory;
	BOOL					m_fSelectCategory;
	CString					m_strDeferredLoad;
	CString					m_strDeferredCategories;
	CString					m_strDeferredMachine;
	BOOL					m_fInternalDelete;

	// Save a pointer to the last system info object created - this can be used
	// to update that status bar when a global refresh is happening.

	CSystemInfo *			m_pLastSystemInfo;

	// As a work around for the problem we're having when compmgmt redirects us,
	// we need a variable to save the IUnknown pointer to the console. When we
	// get an MMCN_REMOVE_CHILDREN notification, we will set this variable, then
	// uninitialize as if we were being unloaded. The next time we get an
	// MMCN_EXPAND message, we'll reinitialize as if we were starting up.

	LPUNKNOWN				m_pSaveUnknown;

	// These variables are used to avoid calling SetSource twice on
	// initialization with the same parameters.

	CDataSource *			m_pSetSourceSource;
	BOOL					m_fSetSourcePreLaunch;

	//	Memory leak problems associated with no call to CSystemInfoScope
	//	destructor require these to be pointers.
	CString					*m_pstrMachineName;
	CString					*m_pstrOverrideName;

	CString					m_strLastMachineName; // in case the new one is bad

private:
	//	Memory lead problems (see above)
	CScopeItemMap			*m_pmapCategories;
	BOOL					m_bIsDirty;
	CCabTool				*m_pViewCABTool; // tool for viewing CAB contents
};

/*
 * CComponentDataPrimaryImpl - The subclass of the main user interface used as
 *		the stand-alone portion of MSInfo.
 */
class CSystemInfoScopePrimary : public CSystemInfoScope,
	public CComCoClass<CSystemInfoScopePrimary, &CLSID_MSInfo>
{
public:
	CSystemInfoScopePrimary()		{ }
	~CSystemInfoScopePrimary()		{ }

	DECLARE_REGISTRY(CSnapin, _T("MSInfo.Snapin.1"), _T("MSInfo.Snapin"), IDS_SNAPIN_DESC, THREADFLAGS_APARTMENT)
	virtual const CLSID &GetCoClassID() { return CLSID_MSInfo; }
	virtual const BOOL IsPrimaryImpl() { return TRUE; }
};

/*
 * CComponentDataExtensionImpl - The subclass of the main user interface used as
 *		the extension portion of MSInfo.
 */
class CSystemInfoScopeExtension : public CSystemInfoScope,
	public CComCoClass<CSystemInfoScopeExtension, &CLSID_Extension>
{
public:
	CSystemInfoScopeExtension()		{ }
	~CSystemInfoScopeExtension()	{ }

	DECLARE_REGISTRY(CSnapin, _T("MSInfo.Extension.1"), _T("MSInfo.Extension"), IDS_EXTENSION_DESC, THREADFLAGS_APARTMENT)
	virtual const CLSID &GetCoClassID() { return CLSID_Extension; }
	virtual const BOOL IsPrimaryImpl() { return FALSE; }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\chooser.cpp ===
/////////////////////////////////////////////////////////////////////
//	Chooser.cpp
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//	Dialog to choose a machine name.
//
//	PURPOSE
//	(Important -- Please Read)
//	This code was written for you to save you time.
//	What you have to do is to copy all the files from the
//	snapin\chooser\ directory into your project (you may add
//	\nt\private\admin\snapin\chooser\ to your include directory if
//	you prefer not copying the code).
//	If you decide to copy the code to your project, please send mail
//	to Dan Morin (T-DanM) and cc to Jon Newman (JonN) so we can
//	mail you when we have updates available.  The next update will
//	be the "Browse" button to select a machine name.
//
//	LIBRARY REQUIRED
//		$(BASEDIR)\public\sdk\lib\*\netapi32.lib	// I_NetName*()
//		$(BASEDIR)\public\sdk\lib\*\shell32.lib		// CommandLineToArgvW()
//
//	EXTRA INFO
//	If you don't know how this works, take a look at the inheritance tree
//	in chooser.h.  Then, take a look at the existing code that inherit and/or
//	uses CChooseMachinePropPage.
//
//	HISTORY
//	13-May-1997		t-danm		Creation.
//	23-May-1997		t-danm		Checkin into public tree. Comments updates.
//	25-May-1997		t-danm		Added MMCPropPageCallback().
//
/////////////////////////////////////////////////////////////////////

#include "StdAfx.h"
//	This needs to be included before chooserd.h so that its definition of
//	IDS_CHOOSER_INVALID_COMPUTERNAME is used rahter than chooserd's
#include "Resource.h"
#include "chooser.h"
#include <lmcons.h>	  // NET_API_STATUS
#include <lmerr.h>	  // NERR_Success
//	Unknown error with lmcons.h?
#ifndef NET_API_STATUS
#define NET_API_STATUS DWORD
#define NET_API_FUNCTION __stdcall
#endif
#include <icanon.h>   // I_NetNameValidate(), I_NetNameCanonicalize(). Found in \nt\private\net\inc.

#ifdef _DEBUG
#undef THIS_FILE
#define THIS_FILE __FILE__
#endif

#ifndef INOUT		
	// The following defines are found in \nt\private\admin\snapin\filemgmt\stdafx.h

	#define INOUT
	#define	Endorse(f)		// Dummy macro
	#define LENGTH(x)		(sizeof(x)/sizeof(x[0]))
	#define Assert(f)		ASSERT(f)
#endif

/////////////////////////////////////////////////////////////////////
//	CanonicalizeComputername()
//
//	Function to validate the computer name and optionally 
//	add the \\ at beginning of machine name.
//
NET_API_STATUS
CanonicalizeComputername(
	INOUT CString& rstrMachineName,
	IN BOOL fAddWackWack = TRUE)	// TRUE => Add the \\ at beginning of name
	{
	rstrMachineName.TrimLeft();
	rstrMachineName.TrimRight();
	if ( rstrMachineName.IsEmpty() )
		return NERR_Success;

	if ( 2 <= rstrMachineName.GetLength() &&
		 _T('\\') == rstrMachineName[0] &&
		 _T('\\') == rstrMachineName[1] )
		{
		// Remove the \\ at the beginning of name
		CString strShorter = rstrMachineName.Right(
			rstrMachineName.GetLength() - 2 );
		rstrMachineName = strShorter;
		}

	NET_API_STATUS err = I_NetNameValidate(
		NULL,
        const_cast<LPTSTR>((LPCTSTR)rstrMachineName),
        NAMETYPE_COMPUTER,
        0L );
	if (NERR_Success != err)
		return err;

	ASSERT( MAX_PATH > rstrMachineName.GetLength() );
	LPTSTR pszTemp = (LPTSTR)alloca( MAX_PATH*sizeof(TCHAR) );
	ASSERT( NULL != pszTemp );
	err = I_NetNameCanonicalize(
		NULL,
        IN const_cast<LPTSTR>((LPCTSTR)rstrMachineName),
		OUT pszTemp,
		MAX_PATH*sizeof(TCHAR),
        NAMETYPE_COMPUTER,
        0L );
	if (NERR_Success != err)
		return err;
	if (fAddWackWack && pszTemp[0] != '\0')
		{
		// Add the \\ at beginning of name
		rstrMachineName = _T("\\\\");
		rstrMachineName += pszTemp;
		}
	else
		{
		rstrMachineName = pszTemp;
		}
	return NERR_Success;
	} // CanonicalizeComputername()


/////////////////////////////////////////////////
//	Machine name override
const TCHAR szOverrideCommandLine[] = _T("/Computer=");	// Not subject to localization
const TCHAR szLocalMachine[] = _T("LocalMachine");		// Not subject to localization
const int cchOverrideCommandLine = LENGTH(szOverrideCommandLine) - 1;

static CString g_strOverrideMachineName;
static LPCTSTR g_pszOverrideMachineName;	// NULL => No override provided, "" => LocalMachine

///////////////////////////////////////////////////////////////////////////////
//	PchGetMachineNameOverride()
//
//	Parse the command line arguments and return a pointer to the
//	machine name override if present.
//
//	INTERFACE NOTES
//	If the machine name is other than local machine, the machine name
//	will have the \\ at the beginning of its name.
//	
//	RETURN
//	- Return NULL if no override (ie, no command line override)
//	- Return pointer to empty string if override is "local machine"
//	- Otherwise return pointer to machine name override with \\ at beginning.
//
LPCTSTR
PchGetMachineNameOverride()
	{
	static BOOL fAlreadyInitialized = FALSE;
	if (fAlreadyInitialized)
		{
		// We already have parsed the command line
		return g_pszOverrideMachineName;
		}
	fAlreadyInitialized = TRUE;
	ASSERT(g_pszOverrideMachineName == NULL);

	LPCWSTR * lpServiceArgVectors;		// Array of pointers to string
	int cArgs = 0;						// Count of arguments

	lpServiceArgVectors = (LPCWSTR *)CommandLineToArgvW(GetCommandLineW(), OUT &cArgs);
	if (lpServiceArgVectors == NULL)
		return NULL;
	for (int i = 1; i < cArgs; i++)
		{
		Assert(lpServiceArgVectors[i] != NULL);
		CString str = lpServiceArgVectors[i];	// Copy the string
		str = str.Left(cchOverrideCommandLine);
		if (0 != str.CompareNoCase(szOverrideCommandLine))
			continue;
		str = lpServiceArgVectors[i] + cchOverrideCommandLine;
		if (0 == str.CompareNoCase(szLocalMachine))
			str.Empty();
		if (NERR_Success != CanonicalizeComputername(INOUT str))
			continue;
		g_strOverrideMachineName = str;	// Copy the argument into the global string
		g_pszOverrideMachineName = g_strOverrideMachineName;
		}
	LocalFree(lpServiceArgVectors);
	return g_pszOverrideMachineName;
	} // PchGetMachineNameOverride()


/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
BEGIN_MESSAGE_MAP(CAutoDeletePropPage, CPropertyPage)
	//{{AFX_MSG_MAP(CAutoDeletePropPage)
	ON_MESSAGE(WM_HELP, OnHelp)
	ON_MESSAGE(WM_CONTEXTMENU, OnContextHelp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////
//	Constructor
CAutoDeletePropPage::CAutoDeletePropPage(UINT uIDD) : CPropertyPage(uIDD)
	{
	m_prgzHelpIDs = NULL;
	m_autodeleteStuff.cWizPages = 1; // Number of pages in wizard
	m_autodeleteStuff.pfnOriginalPropSheetPageProc = m_psp.pfnCallback;
	m_psp.pfnCallback = S_PropSheetPageProc;
	m_psp.lParam = reinterpret_cast<LPARAM>(this);

	// The following line is to enable MFC property pages to run under MMC.
	MMCPropPageCallback(INOUT &m_psp);
	}

CAutoDeletePropPage::~CAutoDeletePropPage()
	{
	}


/////////////////////////////////////////////////////////////////////
void CAutoDeletePropPage::SetCaption(LPCTSTR pszCaption)
	{
	m_strCaption = pszCaption;		// Copy the caption
	m_psp.pszTitle = m_strCaption;	// Set the title
	m_psp.dwFlags |= PSP_USETITLE;
	}

/////////////////////////////////////////////////////////////////////
void CAutoDeletePropPage::SetCaption(UINT uStringID)
	{
	VERIFY(m_strCaption.LoadString(uStringID));
	SetCaption(m_strCaption);
	}

/////////////////////////////////////////////////////////////////////
void CAutoDeletePropPage::SetHelp(LPCTSTR szHelpFile, const DWORD rgzHelpIDs[])
	{
	Endorse(szHelpFile == NULL);	// TRUE => No help file supplied (meaning no help)
	Endorse(rgzHelpIDs == NULL);	// TRUE => No help at all
	m_strHelpFile = szHelpFile;
	m_prgzHelpIDs = rgzHelpIDs;
	}

/////////////////////////////////////////////////////////////////////
void CAutoDeletePropPage::EnableDlgItem(INT nIdDlgItem, BOOL fEnable)
	{
	Assert(IsWindow(::GetDlgItem(m_hWnd, nIdDlgItem)));
	::EnableWindow(::GetDlgItem(m_hWnd, nIdDlgItem), fEnable);
	}

/////////////////////////////////////////////////////////////////////
BOOL CAutoDeletePropPage::OnSetActive()
	{
	HWND hwndParent = ::GetParent(m_hWnd);
	HWND hwndBtn	= ::GetDlgItem(hwndParent, IDOK);
	Assert(IsWindow(hwndParent));

	// Only set focus to finish if we're in wizard mode - 
	// not when the okay and cancel buttons are present, otherwise 
	// the cancel button becomes the default.
	if (!::IsWindowEnabled(hwndBtn))
		::PropSheet_SetWizButtons(hwndParent, PSWIZB_FINISH);

	return CPropertyPage::OnSetActive();
	}

/////////////////////////////////////////////////////////////////////
BOOL CAutoDeletePropPage::OnHelp(WPARAM, LPARAM lParam)
	{
	if (m_prgzHelpIDs == NULL || m_strHelpFile.IsEmpty())
		return TRUE;
	const LPHELPINFO pHelpInfo = (LPHELPINFO)lParam;
	if (pHelpInfo != NULL && pHelpInfo->iContextType == HELPINFO_WINDOW)
		{
		// Display context help for a control
		::WinHelp((HWND)pHelpInfo->hItemHandle, m_strHelpFile,
			HELP_WM_HELP, (ULONG_PTR)m_prgzHelpIDs);
		}
	return TRUE;
	}

/////////////////////////////////////////////////////////////////////
BOOL CAutoDeletePropPage::OnContextHelp(WPARAM wParam, LPARAM)
	{
	if (m_prgzHelpIDs == NULL || m_strHelpFile.IsEmpty())
		return TRUE;
	Assert(IsWindow((HWND)wParam));
	::WinHelp((HWND)wParam, m_strHelpFile, HELP_CONTEXTMENU, (ULONG_PTR)m_prgzHelpIDs);
	return TRUE;
	}


/////////////////////////////////////////////////////////////////////
//	S_PropSheetPageProc()
//
//	Static member function used to delete the CAutoDeletePropPage object
//	when wizard terminates
//
UINT CALLBACK CAutoDeletePropPage::S_PropSheetPageProc(
	HWND hwnd,	
	UINT uMsg,	
	LPPROPSHEETPAGE ppsp)
	{
	Assert(ppsp != NULL);
	CChooseMachinePropPage * pThis;
	pThis = reinterpret_cast<CChooseMachinePropPage*>(ppsp->lParam);
	Assert(pThis != NULL);

	switch (uMsg)
		{
	case PSPCB_RELEASE:
		if (--(pThis->m_autodeleteStuff.cWizPages) <= 0)
			{
			// Remember callback on stack since "this" will be deleted
			LPFNPSPCALLBACK pfnOrig = pThis->m_autodeleteStuff.pfnOriginalPropSheetPageProc;
			delete pThis;
			return (pfnOrig)(hwnd, uMsg, ppsp);
			}
		break;
	case PSPCB_CREATE:
		// do not increase refcount, PSPCB_CREATE may or may not be called
		// depending on whether the page was created.  PSPCB_RELEASE can be
		// depended upon to be called exactly once per page however.
		break;

		} // switch
	return (pThis->m_autodeleteStuff.pfnOriginalPropSheetPageProc)(hwnd, uMsg, ppsp);
	} // CAutoDeletePropPage::S_PropSheetPageProc()





/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
BEGIN_MESSAGE_MAP(CChooseMachinePropPage, CAutoDeletePropPage)
	//{{AFX_MSG_MAP(CChooseMachinePropPage)
	ON_BN_CLICKED(IDC_CHOOSER_RADIO_LOCAL_MACHINE, OnRadioLocalMachine)
	ON_BN_CLICKED(IDC_CHOOSER_RADIO_SPECIFIC_MACHINE, OnRadioSpecificMachine)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

#ifdef _DEBUG
static void AssertValidDialogTemplate(HWND hwnd)
{
	ASSERT(::IsWindow(hwnd));
	// Mandatory controls for a valid dialog template
	static const UINT rgzidDialogControl[] =
		{
		IDC_CHOOSER_RADIO_LOCAL_MACHINE,
		IDC_CHOOSER_RADIO_SPECIFIC_MACHINE,
		IDC_CHOOSER_EDIT_MACHINE_NAME,
		0
		};

	for (int i = 0; rgzidDialogControl[i] != 0; i++)
		{
		ASSERT(NULL != GetDlgItem(hwnd, rgzidDialogControl[i]) &&
			"Control ID not found in dialog template.");
		}
} // AssertValidDialogTemplate()
#else
	#define AssertValidDialogTemplate(hwnd)
#endif	// ~_DEBUG

/////////////////////////////////////////////////////////////////////
//	Constructor
CChooseMachinePropPage::CChooseMachinePropPage(UINT uIDD)
: CAutoDeletePropPage(uIDD)
{
	m_fIsRadioLocalMachine = TRUE;
	m_fAllowOverrideMachineName = FALSE;
	
	m_pfAllowOverrideMachineNameOut = NULL;
	m_pstrMachineNameOut = NULL;
	m_pstrMachineNameEffectiveOut = NULL;
}

/////////////////////////////////////////////////////////////////////
CChooseMachinePropPage::~CChooseMachinePropPage()
{
	//	CHECK:	Is this the right place to free this?
	::MMCFreeNotifyHandle(m_hNotify);
}

/////////////////////////////////////////////////////////////////////
//	Load the initial state of CChooseMachinePropPage
void CChooseMachinePropPage::InitMachineName(LPCTSTR pszMachineName)
{
	Endorse(pszMachineName == NULL);
	m_strMachineName = pszMachineName;
	m_fIsRadioLocalMachine = m_strMachineName.IsEmpty();
}

/////////////////////////////////////////////////////////////////////
//	SetOutputBuffers()
//
//	- Set the pointer to the CString object to store the machine name.
//	- Set the pointer to the boolean flag for command line override.
//	- Set the pointer to store the overriden machine name.
//
void CChooseMachinePropPage::SetOutputBuffers(
	OUT CString * pstrMachineNamePersist,	// Machine name the user typed.  Empty string == local machine.
	OUT BOOL * pfAllowOverrideMachineName,
	OUT CString * pstrMachineNameEffective)
{
	Assert(pstrMachineNamePersist != NULL && "Invalid output buffer");
	Endorse(pfAllowOverrideMachineName == NULL); // TRUE => Do not want to support override from command line
	Endorse(pstrMachineNameEffective == NULL);		// TRUE => Don't care of override
	
	m_pstrMachineNameOut = pstrMachineNamePersist;
	m_pfAllowOverrideMachineNameOut = pfAllowOverrideMachineName;
	m_pstrMachineNameEffectiveOut = pstrMachineNameEffective;
}

/////////////////////////////////////////////////////////////////////
void CChooseMachinePropPage::DoDataExchange(CDataExchange* pDX)
{
	CAutoDeletePropPage::DoDataExchange(pDX);
	DDX_Text(pDX, IDC_CHOOSER_EDIT_MACHINE_NAME, m_strMachineName);
	DDV_MaxChars(pDX, m_strMachineName, MAX_PATH);
	if (NULL != m_hwndCheckboxOverride)
		{
		DDX_Check(pDX, IDC_CHOOSER_CHECK_OVERRIDE_MACHINE_NAME, m_fAllowOverrideMachineName);
		}
	if (pDX->m_bSaveAndValidate)
		{
		// User clicked on OK
		ASSERT(m_hNotify != NULL);
		if (m_hNotify != NULL)
			::MMCPropertyChangeNotify(m_hNotify, 0);
		if (NERR_Success != CanonicalizeComputername(INOUT m_strMachineName) )
			{
			AFX_MANAGE_STATE(AfxGetStaticModuleState());	// Required for AfxGetMainWnd()
			CString strMessage, strTitle;
			strMessage.LoadString(IDS_CHOOSER_INVALID_COMPUTERNAME);
			strTitle.LoadString( IDS_DESCRIPTION);
			::MessageBox( ::AfxGetMainWnd()->GetSafeHwnd(), strMessage, strTitle, MB_OK);

			pDX->Fail();
			Assert(FALSE && "Unreachable code");
			}
		} // if
	*m_pstrMachineNameOut = m_strMachineName;
} // DoDataExchange()


/////////////////////////////////////////////////////////////////////
BOOL CChooseMachinePropPage::OnInitDialog()
{
	AssertValidDialogTemplate(m_hWnd);
	CAutoDeletePropPage::OnInitDialog();
	InitRadioButtons();
	m_hwndCheckboxOverride = ::GetDlgItem(m_hWnd, IDC_CHOOSER_CHECK_OVERRIDE_MACHINE_NAME);
	if (m_pfAllowOverrideMachineNameOut == NULL && m_hwndCheckboxOverride != NULL)
		{
		// We are not interested with the command line override
		::EnableWindow(m_hwndCheckboxOverride, FALSE);	// Disable the window
		::ShowWindow(m_hwndCheckboxOverride, SW_HIDE);	// Hide the window
		}
	
	return TRUE;
}

/////////////////////////////////////////////////////////////////////
BOOL CChooseMachinePropPage::OnWizardFinish()
{
	if (!UpdateData()) return FALSE;		// Do the data exchange to collect data
	if (m_fIsRadioLocalMachine)
	{
		m_strMachineName.Empty();
	}
	if (m_pstrMachineNameOut != NULL)
	{
		// Store the machine name into its output buffer
		*m_pstrMachineNameOut = m_strMachineName;
		if (m_pfAllowOverrideMachineNameOut != NULL)
			*m_pfAllowOverrideMachineNameOut = m_fAllowOverrideMachineName;
		if (m_pstrMachineNameEffectiveOut != NULL)
		{
		if (m_fAllowOverrideMachineName && PchGetMachineNameOverride())
			{
				*m_pstrMachineNameEffectiveOut = PchGetMachineNameOverride();
			}
		else
			{
				*m_pstrMachineNameEffectiveOut = m_strMachineName;
			}
		} // if
	}
	else
	{
		Assert(FALSE && "FYI: You have not specified any output buffer to store the machine name.");
	}
	return CAutoDeletePropPage::OnWizardFinish();
}

void CChooseMachinePropPage::InitRadioButtons()
{
	SendDlgItemMessage(IDC_CHOOSER_RADIO_LOCAL_MACHINE, BM_SETCHECK, m_fIsRadioLocalMachine);
	SendDlgItemMessage(IDC_CHOOSER_RADIO_SPECIFIC_MACHINE, BM_SETCHECK, !m_fIsRadioLocalMachine);
	EnableDlgItem(IDC_CHOOSER_EDIT_MACHINE_NAME, !m_fIsRadioLocalMachine);
}

void CChooseMachinePropPage::OnRadioLocalMachine()
{
	m_fIsRadioLocalMachine = TRUE;
	EnableDlgItem(IDC_CHOOSER_EDIT_MACHINE_NAME, FALSE);
}

void CChooseMachinePropPage::OnRadioSpecificMachine()
{
	m_fIsRadioLocalMachine = FALSE;
	EnableDlgItem(IDC_CHOOSER_EDIT_MACHINE_NAME, TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\compdata.cpp ===
/* CompData.cpp : Implementation of the ComponentData (namespace items) for
 *		the MSInfo Snapin.
 *
 * Copyright (c) 1998-1999 Microsoft Corporation
 *
 * History: a-jsari		8/27/97		Initial version
 */

#include "StdAfx.h"
#include <Commdlg.h>
#include <iostream.h>
#include <atlbase.h>
#include <htmlhelp.h>

#ifndef IDB_16x16
#include "Resource.h"
#endif // IDB_16x16
#include "resrc1.h"

#include "DataObj.h"
#include "CompData.h"
#include "DataSrc.h"
#include "SysInfo.h"
#include "ViewObj.h"
#include "Dialogs.h"
#include "chooser.h"

static LPCTSTR cszViewKey = _T("Software\\Microsoft\\MSInfo");
static LPCTSTR cszViewValue = _T("View");
static LPCTSTR cszBasicValue = _T("basic");
static LPCTSTR cszAdvancedValue = _T("advanced");

/*
 * CSystemInfoScope - Trivial constructor.  Make sure all of our
 *		essential pointers start NULL.
 *
 * History:	a-jsari		8/27/97		Initial version
 */
CSystemInfoScope::CSystemInfoScope()
:m_pScope(NULL),
 m_pConsole(NULL),
 m_pSource(NULL),
 m_bIsDirty(FALSE),
 m_bInitializedCD(FALSE),
 m_fViewUninitialized(FALSE),
 m_prdSave(NULL),
 m_prdOpen(NULL),
 m_prdReport(NULL),
 m_pthdFind(NULL),
 m_BasicFlags(0L),
 m_AdvancedFlags(MF_CHECKED),
 m_pwConsole(NULL),
 m_pmapCategories(NULL), 
 m_pstrMachineName(new CString),
 m_pstrOverrideName(new CString),
 m_pstrCategory(NULL),
 m_RootCookie(0),
 m_fSelectCategory(FALSE),
 m_pSetSourceSource(NULL),
 m_fSetSourcePreLaunch(FALSE),
 m_pViewCABTool(NULL),
 m_pSaveUnknown(NULL),
 m_fInternalDelete(FALSE),
 m_pLastSystemInfo(NULL)
{
#ifdef _DEBUG
	m_bDestroyedCD = true;
#endif // _DEBUG
}

/*
 * ~CSystemInfoScope - Never called.  Don't use.
 *
 * History: a-jsari		8/27/97		Initial version
 */
CSystemInfoScope::~CSystemInfoScope()
{
#ifdef _DEBUG
	if (m_bInitializedCD)
		ASSERT(m_pScope == NULL);
	ASSERT(m_pConsole == NULL);
	ASSERT(m_bDestroyedCD);
#endif
}

/*
 * InitializeDialogs - Pre-create our Dialog pointers to speed their loading when
 *		they are needed.
 *
 * History:	a-jsari		11/28/97		Moved from Initialize
 */
inline HRESULT CSystemInfoScope::InitializeDialogs()
{
	HWND	hWindow;

	ASSERT(m_pConsole != NULL);
	HRESULT hr = m_pConsole->GetMainWindow(&hWindow);
	ASSERT(hr == S_OK);
	if (FAILED(hr))
		return hr;

	ASSERT(m_prdReport == NULL);
	m_prdReport = new CMSInfoReportDialog(hWindow);
	ASSERT(m_prdReport != NULL);
	if (m_prdReport == NULL) ::AfxThrowMemoryException();

	m_prdSave = new CMSInfoSaveDialog(hWindow);
	ASSERT(m_prdSave != NULL);
	if (m_prdSave == NULL) ::AfxThrowMemoryException();

	m_prdOpen = new CMSInfoOpenDialog(hWindow);
	ASSERT(m_prdOpen != NULL);
	if (m_prdOpen == NULL) ::AfxThrowMemoryException();

	return hr;
}

/*
 * FindWindowProc - The window proc for the hidden window that will allow us to
 *		call find from the Find Dialog Thread.
 *
 * History:	a-jsari		2/6/98		Initial version
 */
static LRESULT CALLBACK FindWindowProc(HWND, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
//	ASSERT(uMsg == CFindDialog::WM_MSINFO_FIND);
	//	Only process our specific message.
	if (uMsg == CFindDialog::WM_MSINFO_FIND)
		reinterpret_cast<CSystemInfoScope *>(wParam)->ExecuteFind((long)lParam);
	return 1;
}

/*
 * InitializeInternal - Because MMC never calls our destructor, we are leaking
 *		memory in our member classes.  To fix this, allocate them on the heap
 *		and delete them in our Destroy method.
 *
 * History:	a-jsari		12/30/97		Initial version
 */
inline HRESULT CSystemInfoScope::InitializeInternal()
{
	AFX_MANAGE_STATE(::AfxGetStaticModuleState());

	m_pmapCategories = new CScopeItemMap;
	ASSERT(m_pmapCategories != NULL);
	if (m_pmapCategories == NULL) ::AfxThrowMemoryException();

	CString			strClassName;
	CString			strWindowName;
	HWND			hwndParent;
	CREATESTRUCT	csFind;

	VERIFY(strClassName.LoadString(IDS_FINDCLASS));
	VERIFY(strWindowName.LoadString(IDS_FINDWINDOWNAME));

	WNDCLASSEX		wceFind;
	::memset(&wceFind, 0, sizeof(wceFind));
	wceFind.cbSize = sizeof(wceFind);
	wceFind.style = CS_CLASSDC;
	wceFind.lpfnWndProc = FindWindowProc;
	wceFind.hInstance = ::AfxGetInstanceHandle();
	wceFind.lpszClassName = (LPCTSTR)strClassName;

	::RegisterClassEx(&wceFind);
	pConsole()->GetMainWindow(&hwndParent);
	m_hwndFind = ::CreateWindow(strClassName, strWindowName, WS_CHILD,
		0, 0, 0, 0, hwndParent, NULL, wceFind.hInstance, &csFind);
	ASSERT(m_hwndFind != NULL);
	return S_OK;
}

/*
 * SkipSpaces - Advance the pointer passed in beyond all spaces.
 *
 * History:	a-jsari		11/28/97		Initial version
 */
inline void SkipSpaces(LPTSTR &pszString)
{
	while (_istspace(*pszString)) ++pszString;
}

/*
 * GetValue - Save the value (of the form '= Value' out of pszString into
 *		szValue.
 *
 * History:	a-jsari		11/28/97		Initial version
 */
static inline BOOL GetValue(LPTSTR &pszString, LPTSTR szValue)
{
	SkipSpaces(pszString);
	//if (*pszString++ != (TCHAR)'=')
	//	return FALSE;

	if (*pszString == (TCHAR)'=')
		pszString++;

	SkipSpaces(pszString);
	if (*pszString == (TCHAR)'"') {

		++pszString;
		do {
			*szValue = *pszString;
			if (*szValue++ == 0)
				return FALSE;
		} while ((*pszString++ != '"'));

		*--szValue = (TCHAR)0;
	} else {
		do {
			*szValue++ = *pszString;
			if (*pszString == 0)
				return TRUE;
		} while (!::_istspace(*pszString++));
		*--szValue = (TCHAR)0;
	}
	return TRUE;
}

/*
 * DisplayHelp - Show the help information for MSInfo
 *
 * History:	a-jsari		11/28/97		Initial version
 */
static inline void DisplayHelp(LPTSTR /* szHelp */)
{
	AFX_MANAGE_STATE(::AfxGetStaticModuleState());

	CString		strHelpFile;
	VERIFY(strHelpFile.LoadString(IDS_HELPFILE));
	::HtmlHelp(/* HWND */ NULL, strHelpFile, HH_DISPLAY_TOPIC, 0);
}

/*
 * ProcessCommandLine - Grab all of the essential values out of our command
 *		line.
 *
 * History:	a-jsari		11/28/97		Initial version
 */
HRESULT CSystemInfoScope::ProcessCommandLine()
{
	const int	VALUE_SIZE = 256;
	LPTSTR	szCommands = ::GetCommandLine();
	LPTSTR	pszCurrent = szCommands;
	TCHAR	szValueBuffer[VALUE_SIZE];
	int		iFirst;

	if (pszCurrent == NULL) return E_FAIL;
	while (TRUE) {
		iFirst = _tcscspn(pszCurrent, _T(" \t"));

		//	If our match is \0, we have reached the end of the string.
		if (pszCurrent[iFirst] == (TCHAR)'\0') break;

		pszCurrent += iFirst;
		++pszCurrent;
		SkipSpaces(pszCurrent);

		//	Not a command line switch, check the next parameter.
		if (!(*pszCurrent == (TCHAR)'/' || *pszCurrent == (TCHAR)'-'))
			continue;
		else
			++pszCurrent;

		//	We are processing the computer flag.
		if (_tcsnicmp(pszCurrent, _T("computer"), 8) == 0) 
		{
			pszCurrent += 8;
			if (GetValue(pszCurrent, szValueBuffer) == TRUE) 
				m_strDeferredMachine = szValueBuffer;
		}

		//	After this point, all flags are msinfo specific.
		if (_tcsnicmp(pszCurrent, _T("msinfo"), 6) != 0) continue;
		pszCurrent += 6;	//	pszCurrent += strlen("msinfo");

		if (*pszCurrent == (TCHAR)'?'
			|| _tcsnicmp(pszCurrent, _T("_help"), 5) == 0) {
			LPTSTR	pszValue;
			if (GetValue(pszCurrent, szValueBuffer) == TRUE) {
				pszValue = szValueBuffer;
			} else {
				//	No value for help switch, back up to the previous space, unless we're
				//	at the end of the string.
				if (*pszCurrent != 0)
					do --pszCurrent; while (!::_istspace(*pszCurrent));
				pszValue = NULL;
			}
			DisplayHelp(pszValue);
			continue;
		}

		if (_tcsnicmp(pszCurrent, _T("_category"), 9) == 0) {
			pszCurrent += 9;
			if (GetValue(pszCurrent, szValueBuffer) == TRUE) {
				//	-1 parameter means select no result pane item.
				m_pstrCategory = new CString(szValueBuffer);
				//	SelectItem(szValueBuffer, -1);
			}
			continue;
		}

		if (_tcsnicmp(pszCurrent, _T("_file"), 5) == 0) 
		{
			pszCurrent += 5;
			if (GetValue(pszCurrent, szValueBuffer) == TRUE) 
				m_strDeferredLoad = szValueBuffer;
			continue;
		}

		if (_tcsnicmp(pszCurrent, _T("_showcategories"), 15) == 0) 
		{
			pszCurrent += 15;
			if (GetValue(pszCurrent, szValueBuffer) == TRUE) 
				m_strDeferredCategories = szValueBuffer;
			continue;
		}
	}

    return S_OK;
}

/*
 * Initialize - Called from MMC; we Initialize all of our relevant pointers
 *		using QueryInterface and set the IConsole ImageList.
 *
 * History: a-jsari		8/27/97		Initial version
 */

STDMETHODIMP CSystemInfoScope::Initialize(LPUNKNOWN pUnknown)
{
	ASSERT(pUnknown != NULL);
	TRACE(_T("CSystemInfoScope::Initialize\n"));

	HRESULT		hr;

	do {
		AFX_MANAGE_STATE(AfxGetStaticModuleState());

		// MMC should only call ::Initialize once!
		ASSERT(m_pScope == NULL);

		hr = pUnknown->QueryInterface(IID_IConsoleNameSpace, reinterpret_cast<void **>(&m_pScope));

		ASSERT(hr == S_OK);
		if (FAILED(hr))
			break;

		ASSERT(m_pConsole == NULL);
		hr = pUnknown->QueryInterface(IID_IConsole, reinterpret_cast<void **>(&m_pConsole));
		ASSERT(hr == S_OK);
		if (FAILED(hr))
			break;

		if (m_pSaveUnknown == NULL) // check this out, reversed
		{
			// We are reinitializing, so don't do the image list code again.

			::CBitmap		bmp16x16;
			::CBitmap		bmp32x32;
			LPIMAGELIST		lpScopeImage;

			hr = m_pConsole->QueryScopeImageList(&lpScopeImage);
			ASSERT(hr == S_OK);
			if (FAILED(hr))
				break;

			VERIFY(bmp16x16.LoadBitmap(IDB_16x16));
			VERIFY(bmp32x32.LoadBitmap(IDB_32x32));

			hr = lpScopeImage->ImageListSetStrip(
					reinterpret_cast<LONG_PTR *>(static_cast<HBITMAP>(bmp16x16)),
					reinterpret_cast<LONG_PTR *>(static_cast<HBITMAP>(bmp32x32)),
					0, RGB(255,0,255));

			(void)lpScopeImage->Release();

			ASSERT(hr == S_OK);
			if (FAILED(hr))
				break;

			// This is also a fine place to add the log entry for starting MSInfo,
			// so it won't be repeated when we reinitialize.

			if (msiLog.IsLogging())
				msiLog.WriteLog(CMSInfoLog::BASIC, _T("START MSInfo\r\n"));
		}

		hr = InitializeDialogs();
		if (FAILED(hr)) break;

		hr = InitializeInternal();
		if (FAILED(hr)) break;

		hr = ProcessCommandLine();

	} while (FALSE);

	if (FAILED(hr)) {
		SAFE_RELEASE(m_pScope);
		SAFE_RELEASE(m_pConsole);
	}
	else {
		m_bInitializedCD = true;
	}

#ifdef _DEBUG
	m_bDestroyedCD = false;
#endif
	//	Note that MMC does not permit us to fail return from Initialize,
	//	so we always return S_OK, whether or not our Initialization is
	//	successful.
	return S_OK;
}

/*
 * InitializeView - Read the current user's view information from the registry
 *
 * History:	a-jsari		12/3/97		Initial version.
 */
HRESULT CSystemInfoScope::InitializeView()
{
	CRegKey		crkView;
	long		lResult;
	TCHAR		szBuffer[1024];
	DWORD		dwSize;

	lResult = crkView.Open(HKEY_CURRENT_USER, cszViewKey);
	if (lResult == ERROR_SUCCESS) {
		dwSize = sizeof(szBuffer);
		lResult = crkView.QueryValue(szBuffer, cszViewValue, &dwSize);
	}
	if (lResult != ERROR_SUCCESS)
		//	Default to basic view.
		SetView(BASIC, TRUE);
	else {
		if (::_tcscmp(szBuffer, cszBasicValue) == 0)
			SetView(BASIC, FALSE);
		else if (::_tcscmp(szBuffer, cszAdvancedValue) == 0)
			SetView(ADVANCED, FALSE);
		else {
			ASSERT(FALSE);
			return E_FAIL;
		}
	}
	return S_OK;
}

HRESULT CSystemInfoScope::MessageBox( CString strText)
{
	CString strTitle;
	strTitle.LoadString( IDS_DESCRIPTION); 
	int nRC;

	return pConsole()->MessageBox( strText, strTitle, MB_OK, &nRC);
}

/*
 * InitializeSource - Perform any initialization which may fail.
 *
 * History:	a-jsari		12/3/97		Initial version.
 */
HRESULT CSystemInfoScope::InitializeSource()
{
	AFX_MANAGE_STATE(::AfxGetStaticModuleState());
	CWaitCursor		DoWaitCursor;

	try {
		//	m_pSource will exist if we were loaded from a stream.
		if (m_pSource == NULL) {
			m_bInitializedCD = true;
			//	Initialize WBEM with the machine name.
			//	Deleted in either SetView or Destroy
			m_pSource = new CWBEMDataSource(MachineName());
		}
	}
	catch (CUserException *) {
		CString	strLocalConnect;

		VERIFY(strLocalConnect.LoadString(IDS_LOCAL_CONNECT));
		MessageBox((LPCTSTR)strLocalConnect);

		try {
			(*m_pstrMachineName) = _T("");
			m_pSource = new CWBEMDataSource(NULL);
		}
		catch (CUserException *) {
			m_bInitializedCD = false;
			return E_FAIL;
		}
	}
	m_fViewUninitialized = TRUE;
	InitializeView();
	return S_OK;
}

/*
 * DestroyInternal - Delete all of our internal pointers.  This method of dealing
 *		with pointers is required because MMC never calls our object's destructor.
 *
 * History:	a-jsari		12/30/97		Initial version
 */
void CSystemInfoScope::DestroyInternal()
{
//	AFX_MANAGE_STATE(::AfxGetStaticModuleState());

	if (pSource() && pSource()->GetType() == CDataSource::GATHERER)
	{
		CWBEMDataSource * pWBEMSource = reinterpret_cast<CWBEMDataSource *>(pSource());
		if (pWBEMSource && pWBEMSource->m_pThreadRefresh)
			pWBEMSource->m_pThreadRefresh->CancelRefresh(FALSE);
	}

	// If there is a find thread, it will take care of getting rid of the window.
	// Otherwise, we must destroy it here. Fixes bug 395091.

	if (m_pthdFind)
		dynamic_cast<CFindThread *>(m_pthdFind)->RemoteQuit();
	else
		::DestroyWindow(m_hwndFind);

	if (m_pSource) { delete m_pSource; m_pSource = NULL; }
	if (m_prdSave) { delete m_prdSave; m_prdSave = NULL; }
	if (m_prdOpen) { delete m_prdOpen; m_prdOpen = NULL; }
	if (m_prdReport) { delete m_prdReport; m_prdReport = NULL; }
	if (m_pstrMachineName) { delete m_pstrMachineName; m_pstrMachineName = NULL; }
	if (m_pstrOverrideName) { delete m_pstrOverrideName; m_pstrOverrideName = NULL; }
	if (m_pmapCategories) { delete m_pmapCategories; m_pmapCategories = NULL; }
	if (m_pViewCABTool) { delete m_pViewCABTool; m_pViewCABTool = NULL; }
}

/*
 * CreateComponent - Create the IComponent interface object (the CSystemInfo
 *		object in this framework) and attach myself (the IComponentData
 *		interface object) to it.  Return the QueryInterfaced IComponent
 *		pointer in ppComponent.
 *
 * History:	a-jsari		8/27/97		Initial version
 */
STDMETHODIMP CSystemInfoScope::CreateComponent(LPCOMPONENT *ppComponent)
{
	ASSERT(ppComponent != NULL);
	TRACE(_T("CSystemInfoScope::CreateComponent\n"));

#if 0
	if (m_bInitializedCD == false) {
		*ppComponent = NULL;
		return S_OK;
	}
#endif

	CComObject<CSystemInfo>		*pObject;

	CComObject<CSystemInfo>::CreateInstance(&pObject);
	ASSERT(pObject != NULL);

	if(NULL == pObject)
		return E_OUTOFMEMORY;

	m_pLastSystemInfo = pObject;

	//Store IComponentData
	HRESULT hr;
	hr = pObject->SetIComponentData(this);
	ASSERT(hr == S_OK);
	if (FAILED(hr)) {
		return hr;
	}

	return pObject->QueryInterface(IID_IComponent, reinterpret_cast<void **>(ppComponent));
}

/*
 * PreUIInit - Make any changes required just before the UI initializes.
 *
 * History:	a-jsari		3/6/98		Initial version
 */
HRESULT CSystemInfoScope::PreUIInit()
{
	HRESULT		hr = S_OK;

	if (m_pSource == NULL) {
		hr = InitializeSource();
	} else {
		hr = InitializeView();
	}
	return hr;
}

/*
 * PostUIInit - Do all initialization which can only occur after the result
 *		pane UI 
 *
 * History:	a-jsari		3/6/98		Initial version
 */
void CSystemInfoScope::PostUIInit()
{
	if (!m_strDeferredLoad.IsEmpty() || !m_strDeferredMachine.IsEmpty())
	{
		// Instead of doing a "SetSource(m_pSource, FALSE)", which deletes the
		// tree, all we need to do here is rename the root node to match the
		// opened file. A non-empty m_strDeferredLoad indicates this is necessary.
		// (Or a non empty deferred machine change.)

		m_strDeferredLoad.Empty();
		m_strDeferredMachine.Empty();

		SCOPEDATAITEM	sdiRoot;
		CString			strNodeName;
		HSCOPEITEM		hsiRoot;
		HRESULT			hr;

		if (m_pmapCategories->ScopeFromView(NULL, hsiRoot))
		{
			::memset(&sdiRoot, 0, sizeof(sdiRoot));
		
			sdiRoot.ID = hsiRoot;
			sdiRoot.mask = SDI_STR;
			hr = pScope()->GetItem(&sdiRoot);
			ASSERT(SUCCEEDED(hr));

			if (SUCCEEDED(hr))
			{
				m_pSource->GetNodeName(strNodeName);
				sdiRoot.displayname = T2OLE(const_cast<LPTSTR>((LPCTSTR)strNodeName));
				hr = pScope()->SetItem(&sdiRoot);
				ASSERT(SUCCEEDED(hr));
			}
		}
	}

	//	This is the first point at which we can set UI values.
	if (m_fViewUninitialized && m_fSelectCategory)	{
		m_fViewUninitialized = FALSE;

		SetSource(m_pSource, FALSE);
	}
	if (m_pstrCategory != NULL && m_fSelectCategory) {
		//	Before the SelectItem call to prevent recursion.
		m_fSelectCategory = FALSE;
		SelectItem(*m_pstrCategory);
		delete m_pstrCategory;
		m_pstrCategory = NULL;
	}
}

/*
 * Notify - Handle any MSInfo namespace node events posted by MMC.
 *
 * History:	a-jsari		8/27/97		Initial version
 */

STDMETHODIMP CSystemInfoScope::Notify(LPDATAOBJECT pDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
	TRACE(_T("CSystemInfoScope::Notify (DataObject, %lx, %p, %p)\n"), event, arg, param);
	HRESULT hr;

	if (m_bInitializedCD == false)
		return S_OK;

	switch(event) 
	{
	case MMCN_EXPAND:
		if (m_pSaveUnknown)
		{
			m_pstrMachineName = new CString;
			m_pstrOverrideName = new CString;
			Initialize(m_pSaveUnknown);
			m_pSaveUnknown = NULL;
		}

		hr = PreUIInit();
		if (FAILED(hr)) break;
		hr = OnExpand(pDataObject, arg, param);
		PostUIInit();
		break;

	case MMCN_REMOVE_CHILDREN:
		// Sometimes we make an internal call which causes this notification to be
		// sent, but we don't want to process it the same way.

		if (!m_fInternalDelete)
		{
			m_pSaveUnknown = m_pScope;

			DestroyInternal();
			SAFE_RELEASE(m_pScope);
			SAFE_RELEASE(m_pConsole);
			
			m_pScope = NULL;
			m_pConsole = NULL;
			m_pSource = NULL;
			m_prdSave = NULL;
			m_prdOpen = NULL;
			m_prdReport = NULL;
			m_pstrMachineName = NULL;
			m_pstrOverrideName = NULL;
			m_pmapCategories = NULL;
		}

		hr = S_OK;
		break;

	case MMCN_PROPERTY_CHANGE:
		hr = OnProperties(param);
		break;

	case MMCN_EXPANDSYNC:
		break;

	default:
		ASSERT(FALSE);
		break;
	}

	return hr;
}

/*
 * Destroy - Release all of our Initialized pointers.
 *
 * History: a-jsari		8/27/97		Initial version
 */
STDMETHODIMP CSystemInfoScope::Destroy()
{
	TRACE(L"CSystemInfoScope::Destroy\n");

	if (m_pwConsole != NULL) {
		m_pwConsole->Detach();
		delete m_pwConsole;
	}

#if FALSE
#ifdef _DEBUG
	m_bDestroyedCD = true;
#endif
#if 0
	if (m_bInitializedCD == FALSE) return S_OK;
#endif

	DestroyInternal();
	SAFE_RELEASE(m_pScope);
	SAFE_RELEASE(m_pConsole);
#endif

	return S_OK;
}

/*
 * QueryDataObject - Return the DataObject referred to by the cookie
 *		and type.
 *
 * History:	a-jsari		8/27/97		Initial version
 */
STDMETHODIMP CSystemInfoScope::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
			LPDATAOBJECT *ppDataObject)
{
	TRACE(_T("CSystemInfoScope::QueryDataObject (%lx, %x, DataObject)\n"), cookie, type);

	return CDataObject::CreateDataObject(cookie, type, this, ppDataObject);
}

/*
 * CompareObjects - Compare two objects to see if they are equivalent.
 *
 * History: a-jsari		8/27/97		Initial version
 */
STDMETHODIMP CSystemInfoScope::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
	TRACE(_T("CSystemInfoScope::CompareObjects\n"));
	return CDataObject::CompareObjects(lpDataObjectA, lpDataObjectB);
}

/*
 * GetDisplayInfo - Returns display information for this node in the scope pane.
 *
 * History: a-jsari		8/27/97		Initial version
 */
STDMETHODIMP CSystemInfoScope::GetDisplayInfo(SCOPEDATAITEM *pScopeDataItem)
{
	USES_CONVERSION;

#if 0
	TRACE(_T("CSystemInfoScope::GetDisplayInfo\n"));
#endif
	ASSERT(pScopeDataItem != NULL);
	if (pScopeDataItem == NULL) return E_POINTER;

	ASSERT(pScopeDataItem->mask & SDI_STR);
	if (pScopeDataItem->mask & SDI_STR) {
			CViewObject	*pDataCategory = reinterpret_cast<CViewObject *>(pScopeDataItem->lParam);
			pScopeDataItem->displayname = T2OLE(const_cast<LPTSTR>(pDataCategory->GetTextItem()));
	}

	return S_OK;
}

/*
 * AddToMenu - Add an item to a menu.	This method assumes that the calling
 *		function has called AFX_MANAGE_STATE(AfxGetStaticModuleState()) prior
 *		to calling this function.
 *
 * History:	a-jsari		9/15/97		Initial version
 */
HRESULT CSystemInfoScope::AddToMenu(LPCONTEXTMENUCALLBACK lpCallback, long lNameResource,
			long lStatusResource, long lCommandID, long lInsertionPoint, long fFlags)
{
	USES_CONVERSION;

	CONTEXTMENUITEM		cmiMenuItem = { NULL, NULL, lCommandID,
		lInsertionPoint, fFlags, 0L};
	CString				szResourceName;
	CString				szResourceStatus;

	//	FIX: Make these resources load only once.
	VERIFY(szResourceName.LoadString(lNameResource));
	VERIFY(szResourceStatus.LoadString(lStatusResource));
	cmiMenuItem.strName = WSTR_FROM_CSTRING(szResourceName);
	cmiMenuItem.strStatusBarText = WSTR_FROM_CSTRING(szResourceStatus);
	HRESULT		hr = lpCallback->AddItem(&cmiMenuItem);
	ASSERT(hr == S_OK);
	return hr;
}

/*
 * AddMenuItems - Add the "Save Report" and "Save System Information" items to
 *		the context menu.
 *
 * History:	a-jsari		9/15/97		Initial version
 */
extern BOOL fCABOpened;

STDMETHODIMP CSystemInfoScope::AddMenuItems(LPDATAOBJECT lpDataObject,
			LPCONTEXTMENUCALLBACK lpCallback, long *pInsertionAllowed)
{
	TRACE(_T("CSystemInfoScope::AddMenuItems\n"));
	ASSERT(lpDataObject != NULL);
	ASSERT(lpCallback != NULL);
	ASSERT(pInsertionAllowed != NULL);
	if (lpDataObject == NULL || lpCallback == NULL || pInsertionAllowed == NULL)
		return E_POINTER;

	HRESULT hr = S_OK;

//	Note - snap-ins need to look at the data object and determine in what
//	context menu items need to be added.  They must also observe the
//	insertion allowed flags to see what items can be added.

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

//		CHECK: Will this ever work differently for multiselect?

	do {
		//	Save Report and Save File are both task items and context items.
		if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP) {
			hr = AddToTopMenu(lpCallback, IDS_SAVEREPORTMENUNAME, IDS_SAVEREPORTSTATUS, IDM_SAVEREPORT);
			if (FAILED(hr)) break;
			hr = AddToTopMenu(lpCallback, IDS_SAVEFILEMENUNAME, IDS_SAVEFILESTATUS, IDM_SAVEFILE);
			if (FAILED(hr)) break;
			hr = AddToTopMenu(lpCallback, IDS_FINDMENUNAME, IDS_FINDSTATUS, IDM_FIND);
			if (FAILED(hr)) break;
		}

		if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TASK) {

			hr = AddToTaskMenu(lpCallback, IDS_FINDMENUNAME, IDS_FINDSTATUS, IDM_TASK_FIND);
			if (FAILED(hr)) break;

			//	Don't add the Open File menu item for Extension snap-ins.

			if (IsPrimaryImpl()) 
			{
				hr = AddToTaskMenu(lpCallback, IDS_OPENFILEMENUNAME, IDS_OPENFILESTATUS, IDM_TASK_OPENFILE);
				if (FAILED(hr)) 
					break;

				CDataSource * pCurrentSource = pSource();
				if (pCurrentSource && pCurrentSource->GetType() != CDataSource::GATHERER)
					hr = AddToTaskMenu(lpCallback, IDS_CLOSEFILEMENUNAME, IDS_CLOSEFILEMENUSTATUS, IDM_TASK_CLOSE);
				else
					hr = AddToMenu(lpCallback, IDS_CLOSEFILEMENUNAME, IDS_CLOSEFILEMENUSTATUS, IDM_TASK_CLOSE, CCM_INSERTIONPOINTID_PRIMARY_TASK, MF_GRAYED);

				if (FAILED(hr)) 
					break;
			}

			hr = AddToTaskMenu(lpCallback, IDS_SAVEFILEMENUNAME, IDS_SAVEFILESTATUS, IDM_TASK_SAVEFILE);
			if (FAILED(hr)) break;
			hr = AddToTaskMenu(lpCallback, IDS_SAVEREPORTMENUNAME, IDS_SAVEREPORTSTATUS, IDM_TASK_SAVEREPORT);
			if (FAILED(hr)) break;

			//	If a CAB file has been opened, add the view CAB contents menu item. Also
			// take this opportunity to create the tool to view the CAB contents, if it
			// has not already been created.

			if (fCABOpened)
			{
				if (m_pViewCABTool == NULL)
					m_pViewCABTool = new CCabTool(this);

				if (m_pViewCABTool != NULL)
				{
					hr = AddToTaskMenu(lpCallback, IDS_CAB_NAME, IDS_CAB_DESCRIPTION, IDM_TASK_VIEWCAB);
					if (FAILED(hr)) break;
				}
			}
		}

		if (*pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW) {
			hr = AddToViewMenu(lpCallback, IDS_ADVANCEDVIEWNAME, IDS_ADVANCEDSTATUS, IDM_VIEW_ADVANCED,
					m_AdvancedFlags);
			if (FAILED(hr)) break;
			hr = AddToViewMenu(lpCallback, IDS_BASICVIEWNAME, IDS_BASICSTATUS, IDM_VIEW_BASIC, m_BasicFlags);
			if (FAILED(hr)) break;
		}

	} while (FALSE);
	return hr;
}

/*
 * DisplayFileError - Show a message box with an error message taken from
 *		the exception thrown.
 *
 * History:	a-jsari		2/13/98		Initial version
 */
static inline void DisplayError(HRESULT hr, const CString &strFileName)
{
	AFX_MANAGE_STATE(::AfxGetStaticModuleState());

	USES_CONVERSION;
	CString		strFileError, strTitle;
	switch (hr) {
	case STG_E_PATHNOTFOUND:
		strFileError.Format(IDS_BAD_PATH, (LPCTSTR)strFileName);
		break;
	case STG_E_TOOMANYOPENFILES:
		VERIFY(strFileError.LoadString(IDS_TOOMANYOPENFILES));
		break;
	case STG_E_ACCESSDENIED:
		strFileError.Format(IDS_ACCESS_DENIED, (LPCTSTR)strFileName);
		break;
	case STG_E_SHAREVIOLATION:
		strFileError.Format(IDS_SHARING_VIOLATION, (LPCTSTR)strFileName);
		break;
	case STG_E_WRITEFAULT:
		VERIFY(strFileError.LoadString(IDS_HARDIO));
		break;
	case STG_E_MEDIUMFULL:
		strFileError.Format(IDS_DISK_FULL, (LPCTSTR)strFileName);
		break;
	default:
		VERIFY(strFileError.LoadString(IDS_UNKNOWN_FILE));
		break;
	}
	strTitle.LoadString(IDS_DESCRIPTION);
	::MessageBox( ::AfxGetMainWnd()->GetSafeHwnd(), strFileError, strTitle, MB_OK);
}

/*
 * SaveReport - Create the save report save file dialog and save the selected file.
 *
 * History:	a-jsari		12/8/97		Initial version
 */
void CSystemInfoScope::SaveReport()
{
	if (m_prdReport->DoModal() == IDOK) {
		CWaitCursor		DoWaitCursor;

		if (m_pLastSystemInfo)
			m_pLastSystemInfo->SetStatusText(IDS_REFRESHING_MSG);

		HRESULT hr = pSource()->ReportWrite(m_prdReport->GetPathName(), m_pfLast);

		if (m_pLastSystemInfo)
			m_pLastSystemInfo->SetStatusText(_T(""));

		if (FAILED(hr)) {
			::DisplayError(hr, m_prdReport->GetPathName());
		}
	}
}

/*
 * SaveFile - Create the save file dialog and save the selected file.
 *
 * History:	a-jsari		12/8/97		Initial version
 */
void CSystemInfoScope::SaveFile()
{
	if (m_prdSave->DoModal() == IDOK) 
	{
		CWaitCursor		DoWaitCursor;

		if (m_pLastSystemInfo)
			m_pLastSystemInfo->SetStatusText(IDS_REFRESHING_MSG);

		HRESULT hr = pSource()->SaveFile(m_prdSave->GetPathName());

		if (m_pLastSystemInfo)
			m_pLastSystemInfo->SetStatusText(_T(""));

		if (FAILED(hr))
			::DisplayError(hr, m_prdSave->GetPathName());
	}
}

/*
 * PrintReport - Create the print dialog and do the print.
 *
 * History:	a-jsari		12/8/97		Initial version
 */
void CSystemInfoScope::PrintReport()
{
	HWND hWindow;

	ASSERT(m_pConsole != NULL);
	HRESULT hr = m_pConsole->GetMainWindow(&hWindow);
	ASSERT(hr == S_OK);
	if (FAILED(hr))
		return;

	CMSInfoPrintDialog * prdPrint = new CMSInfoPrintDialog(hWindow);
	ASSERT(prdPrint != NULL);
	if (prdPrint == NULL)	
		::AfxThrowMemoryException();

	prdPrint->m_pd.nToPage = prdPrint->m_pd.nFromPage = prdPrint->m_pd.nMinPage = 1;
	prdPrint->m_pd.nMaxPage = 1000;

	if (prdPrint->DoModal() == IDOK) 
	{
		CWaitCursor DoWaitCursor;

		pSource()->RefreshPrintData(prdPrint, m_pfLast);
		pSource()->PrintReport(prdPrint, m_pfLast);
	} 

	delete prdPrint;
}

/*
 * DoFind - Display the Find dialog
 *
 * History:	a-jsari		12/8/97		Initial version.
 */
void CSystemInfoScope::DoFind()
{
	const UINT						STACK_SIZE_PARENT		= 0;
//	const DWORD						FLAGS_IMMEDIATE_START	= 0;
	const LPSECURITY_ATTRIBUTES		NO_ATTRIBUTES			= NULL;

	if (m_pthdFind == NULL) 
	{
		m_pthdFind = dynamic_cast<CFindThread *>(::AfxBeginThread(RUNTIME_CLASS(CFindThread),
			THREAD_PRIORITY_NORMAL,	STACK_SIZE_PARENT, CREATE_SUSPENDED, NO_ATTRIBUTES));
		m_pthdFind->SetScope(this);

		HWND hwndMMC;
		if (pConsole() == NULL || FAILED(pConsole()->GetMainWindow(&hwndMMC)))
			hwndMMC = NULL;

		m_pthdFind->SetParent(m_hwndFind, hwndMMC);
		m_pthdFind->ResumeThread();
	}
	else 
		m_pthdFind->Activate();
}

/*
 * ExecuteFind - This function is actually called via a hook into
 *		MMC's main window's WindowProc, by a message posted by
 *		CFindThread's Find button function..
 *
 * The Refresh and Find functions may be interrupted by the Find
 *		window's UI thread, and m_pthdFind may be deleted while this
 *		function is executing.
 *
 * Instead of taking parameters, this function calls back to our
 *		existing find thread to get its search string and last
 *		search string.  This simplifies the PostMessage call, but
 *		would need to change if we ever decide to have multiple 
 *		find windows per IComponentData...unlikely.
 *
 * History:	a-jsari		1/22/98		Initial version.
 */
void CSystemInfoScope::ExecuteFind(long lFindState)
{
	AFX_MANAGE_STATE(::AfxGetStaticModuleState());

	CWaitCursor		DoWaitCursor;		//	Display the hourglass

	CString			strFindData;	//	Our current search string.
	//	The restricted context within which our search occurs.
	static CFolder	*pfContext;

	//	Check m_pthdFind since there's a remote possibility of thread pointer
	//  invalidation (by the user closing the Find dialog while the
	//	find is running).
	if (m_pthdFind == NULL)
		return;
	strFindData = m_pthdFind->FindString();

	CDataSource		*pdsSearch = pSource();
	do {
		if ((lFindState & CDataSource::FIND_OPTION_REPEAT_SEARCH) == 0) 
		{
			// Only refresh the first time we search for a given string.
			// Also, only refresh if we are searching more than category names.

			BOOL fRefreshResult = TRUE;
			if ((lFindState & CDataSource::FIND_OPTION_CATEGORY_ONLY) == 0)
			{
				// If we are only searching in one category, only refresh that
				// category.

				if ((lFindState & CDataSource::FIND_OPTION_ONE_CATEGORY) != 0)
				{
					if (pdsSearch->GetType() == CDataSource::GATHERER)
					{
						CWBEMDataSource * pWBEMSource = reinterpret_cast<CWBEMDataSource *>(pSource());
						if (pWBEMSource && pWBEMSource->m_pThreadRefresh)
							pWBEMSource->m_pThreadRefresh->RefreshFolder(m_pfLast, TRUE, FALSE);
					}
				}
				else
					fRefreshResult = pdsSearch->Refresh(TRUE);
			}

			if (!fRefreshResult) 
			{
				if (m_pthdFind != NULL)
					m_pthdFind->ResetSearch();
				break;
			}

			//	Set our context the first time we start a restricted search.
			if ((lFindState & CDataSource::FIND_OPTION_ONE_CATEGORY) != 0)
				pfContext = m_pfLast;
			else
				pfContext = NULL;
		} 
		else if ((lFindState & CDataSource::FIND_OPTION_ONE_CATEGORY) != 0) 
		{
			//	If we set a restricted search inside an already started search
			//	restrict our context.
			//	CHECK: iDepth???
			if (pfContext == NULL)
				pfContext = m_pfLast;
		}
		if (pdsSearch->Find(strFindData, lFindState) == FALSE) {
			//	Failed find means no match or halted execution.

			//	If the user stoppped the find, no message necessary.
			if (!pdsSearch->FindStopped()) {

				CString			strError;		//	Error display
				CString			strTitle;		//	Error title.
				int				nReturn;

				//	Test the thread because the find window might vanish in the middle
				//	of our find operation.
				if (m_pthdFind != NULL)
					m_pthdFind->FindComplete();
				if (m_pthdFind != NULL)
					m_pthdFind->ResetSearch();

				//	If we're repeating a search, no more matches otherwise, not found.
				if ((lFindState & CDataSource::FIND_OPTION_REPEAT_SEARCH) == 0) {
					strError.Format(IDS_DATANOTFOUND, (LPCTSTR)strFindData);
				} else
					strError.Format(IDS_NOMOREMATCHES, (LPCTSTR)strFindData);
				VERIFY(strTitle.LoadString(IDS_FIND_TITLE));
				pConsole()->MessageBox((LPCTSTR)strError, (LPCTSTR)strTitle,
					MB_TOPMOST|MB_SETFOREGROUND, &nReturn);

				//	If we are restricting our search, reset the selected folder to the
				//	beginning of our restricted search.
				if ((lFindState & CDataSource::FIND_OPTION_ONE_CATEGORY) != 0)
					SetSelectedFolder(pfContext);
				//	We've already completed the find, don't drop out.
				return;
			}
		} else {
			SelectItem(pdsSearch->m_strPath, pdsSearch->m_iLine);
		}
	} while (FALSE);
	//	The find window might vanish in the middle of our find operation.
	if (m_pthdFind != NULL)
		m_pthdFind->FindComplete();
}

/*
 * MainThreadStopFind - Stops a find operation running in an alternate thread.
 *
 * History:	a-jsari		1/22/98		Initial version.
 */
void CSystemInfoScope::StopFind()
{
	//	This will be called by an alternate UI thread.
	pSource()->StopSearch();
}

/*
 * Refresh - Refresh the data, and redraw the current node if applicable.
 *
 * History:	a-jsari		2/25/98		Initial version
 */
void CSystemInfoScope::Refresh(CFolder * pfSelected, CSystemInfo * pSystemInfo)
{
	CWaitCursor	DoWaitCursor;

	if (pfSelected && pSource() && pSource()->GetType() == CDataSource::GATHERER)
	{
		CWBEMDataSource * pWBEMSource = reinterpret_cast<CWBEMDataSource *>(pSource());
		if (pWBEMSource && pWBEMSource->m_pThreadRefresh)
		{
			if (pSystemInfo)
				pWBEMSource->m_pThreadRefresh->RefreshFolderAsync(pfSelected, pSystemInfo, TRUE, FALSE);
			else
				pWBEMSource->m_pThreadRefresh->RefreshFolder(pfSelected, TRUE, FALSE);
		}
	}
	else
		pSource()->Refresh();

	if (pfSelected != NULL) 
	{
		CString	strName;
		int		nLine = 0;
		pfSelected->InternalName(strName);
		SelectItem(strName, nLine);
	}
}

/*
 * CloseFindWindow - Function to be called when the find window closes.
 *
 * History:	a-jsari		1/22/97		Initial version.
 */
void CSystemInfoScope::CloseFindWindow()
{
	//	Don't delete m_pthdFind; it will delete itself.
	m_pthdFind = NULL;
}

/*
 * OpenFile - Create the open file file dialog and open the resultant file
 *
 * History:	a-jsari		12/8/97		Initial version
 */
void CSystemInfoScope::OpenFile()
{
	const long DONT_USE_LAST_FOLDER = 1;

	if (m_prdOpen->DoModal() == IDOK) 
	{
		CWaitCursor		DoWaitCursor;
		CDataSource		*pSource = NULL;

		try 
		{
			 pSource = CBufferDataSource::CreateDataSourceFromFile(m_prdOpen->GetPathName());
		}
		catch (...) 
		{
			delete pSource;
			pSource = NULL;
		}
		
		if (pSource != NULL) 
		{
			SetSource(pSource);
			InitializeView();
		}

		pConsole()->UpdateAllViews(0, DONT_USE_LAST_FOLDER, 0L);

		// Reset the selected folder (it's no longer valid with the new tree).

		SetSelectedFolder(NULL);

		HSCOPEITEM hsiNode = NULL;
		if (m_pmapCategories && m_pmapCategories->ScopeFromView(NULL, hsiNode))
			pConsole()->SelectScopeItem(hsiNode);
	}
}

//-----------------------------------------------------------------------------
// Close the currently opened file.
//-----------------------------------------------------------------------------

void CSystemInfoScope::CloseFile()
{
	CDataSource * pDataSource = pSource();
	if (pDataSource && pDataSource->GetType() == CDataSource::GATHERER)
		return;

	try
	{
		(*m_pstrMachineName) = _T("");
		pDataSource = new CWBEMDataSource(NULL);
	}
	catch (CUserException *) 
	{
		m_bInitializedCD = false;
		return;
	}

	if (pDataSource != NULL) 
	{
		SetSource(pDataSource);
		InitializeView();
	}

	const long DONT_USE_LAST_FOLDER = 1;
	pConsole()->UpdateAllViews(0, DONT_USE_LAST_FOLDER, 0L);

	// Reset the selected folder (it's no longer valid with the new tree).

	SetSelectedFolder(NULL);
}

/*
 * Command - Call the function represented by nCommandID.
 *
 * History:	a-jsari		9/15/97		Initial version
 *
 * Note: This function currently takes no notice of the context represented
 *		by pdoContext.
 */
STDMETHODIMP CSystemInfoScope::Command(long nCommandID, LPDATAOBJECT)
{
	HRESULT				hr = S_OK;

	TRACE(_T("CSystemInfoScope::Command(%lx)\n"), nCommandID);
	AFX_MANAGE_STATE(::AfxGetStaticModuleState());

	// For any of these commands, we want to cancel an async category refresh
	// is there is one in progress.

	if (pSource() && pSource()->GetType() == CDataSource::GATHERER)
	{
		CWBEMDataSource * pWBEMSource = reinterpret_cast<CWBEMDataSource *>(pSource());
		if (pWBEMSource && pWBEMSource->m_pThreadRefresh)
		{
			CWaitCursor waitcursor;
			pWBEMSource->m_pThreadRefresh->WaitForRefresh();
		}
	}

	try {
		switch (nCommandID) {
		case IDM_SAVEREPORT:
		case IDM_TASK_SAVEREPORT:
			if (msiLog.IsLogging())
				msiLog.WriteLog(CMSInfoLog::MENU, _T("MENU \"Save As Text\"\r\n"));
			SaveReport();
			break;

		case IDM_SAVEFILE:
		case IDM_TASK_SAVEFILE:
			if (msiLog.IsLogging())
				msiLog.WriteLog(CMSInfoLog::MENU, _T("MENU \"Save NFO\"\r\n"));
			SaveFile();
			break;

		case IDM_TASK_FIND:
		case IDM_FIND:
			if (msiLog.IsLogging())
				msiLog.WriteLog(CMSInfoLog::MENU, _T("MENU \"Find\"\r\n"));
			DoFind();
			break;

		case IDM_TASK_OPENFILE:
			if (msiLog.IsLogging())
				msiLog.WriteLog(CMSInfoLog::MENU, _T("MENU \"Open NFO\"\r\n"));
			OpenFile();
			break;

		case IDM_TASK_VIEWCAB:
			if (msiLog.IsLogging())
				msiLog.WriteLog(CMSInfoLog::MENU, _T("MENU \"View CAB\"\r\n"));
			if (m_pViewCABTool)
				m_pViewCABTool->RunTool();
			break;

		case IDM_VIEW_ADVANCED:
			if (msiLog.IsLogging())
				msiLog.WriteLog(CMSInfoLog::MENU, _T("MENU \"Set View ADVANCED\"\r\n"));
			SetView(ADVANCED, TRUE);
			break;

		case IDM_VIEW_BASIC:
			if (msiLog.IsLogging())
				msiLog.WriteLog(CMSInfoLog::MENU, _T("MENU \"Set View BASIC\"\r\n"));
			SetView(BASIC, TRUE);
			break;

		case IDM_TASK_CLOSE:
			if (msiLog.IsLogging())
				msiLog.WriteLog(CMSInfoLog::MENU, _T("MENU \"Close NFO\"\r\n"));
			CloseFile();
			break;

		case ~0:
			//	We get this result when we back arrow on the taskpad.
			break;

		default:
			ASSERT(FALSE);
			break;
		}
	}
	catch (...) {
		ASSERT(FALSE);
		hr = HRESULT_FROM_WIN32(::GetLastError());
	}
	return hr;
}

/*
 * CreatePropertyPages - Create an instance of our property pages and attach them
 *		to MMC's property sheet.
 *
 * History: a-jsari		9/17/97		Initial version
 */
STDMETHODIMP CSystemInfoScope::CreatePropertyPages(LPPROPERTYSHEETCALLBACK pProvider,
			LONG_PTR handle, LPDATAOBJECT pDataObject)
{
	ASSERT(pProvider != NULL);
	ASSERT(pDataObject != NULL);

	TRACE(_T("CSystemInfoScope::CreatePropertyPages\n"));
	if (pProvider == NULL || pDataObject == NULL) return E_INVALIDARG;

	//	Special code goes here if we're used as an extension.
	HRESULT			hResult;

	do {
		CChooseMachinePropPage	*pPropChoose;
		HPROPSHEETPAGE			hGeneralPage;
		BOOL					fOverride;

		AFX_MANAGE_STATE(::AfxGetStaticModuleState());

		//	Deleted automatically.
		pPropChoose = new CChooseMachinePropPage(IDD_CHOOSER_CHOOSE_MACHINE);

		if (pPropChoose == NULL)	{
			::MMCFreeNotifyHandle(handle);
			::AfxThrowMemoryException();
		}

		// Save the current machine name, in case the one selected in the property
		// page is not any good.

		m_strLastMachineName = *m_pstrMachineName;

		pPropChoose->SetHandle(handle);
		pPropChoose->SetOutputBuffers(m_pstrMachineName, &fOverride, m_pstrOverrideName);

		hGeneralPage = ::CreatePropertySheetPage(&pPropChoose->m_psp);
		if (!hGeneralPage) {
			hResult = E_FAIL;
			break;
		}

		hResult = pProvider->AddPage(hGeneralPage);
		ASSERT(SUCCEEDED(hResult));

	} while (FALSE);

	if (FAILED(hResult)) return hResult;
	return S_OK;
}

/*
 * QueryPagesFor - Return S_OK, informing MMC that we have property sheets available.
 *
 * History:	a-jsari		9/17/97		Initial version
 */
STDMETHODIMP CSystemInfoScope::QueryPagesFor(LPDATAOBJECT pDataObject)
{
	TRACE(_T("CSystemInfoScope::QueryPagesFor\n"));
	ASSERT(pDataObject != NULL);

	if (pDataObject == NULL) return E_POINTER;

	//	If we are being loaded as an extension, don't display property pages.
	//	We do this because the base snap-in is responsible for the connected
	//	machine, not us.
	if (!IsPrimaryImpl()) return S_FALSE;

#if 0
	//	Not sure why I did this.
	//	If the machine name is already set, don't display the property page.
	if (m_pstrMachineName && m_pstrMachineName->GetLength() > 0) return S_FALSE;
#endif

	return S_OK;
}

/*
 * Load - Load our state from the stream provided.
 *
 * History:	a-jsari		11/5/97		Initial version
 */
STDMETHODIMP CSystemInfoScope::Load(IStream *pStm)
{
	CDataSource		*pSource;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

	TRACE(_T("CSystemInfoScope::Load\n"));
	ASSERT(pStm != NULL);
	if (pStm == NULL) return E_POINTER;
	ClearDirty();
	//	If our command-line parameters have specified a source, don't replace it.

	if (!m_fViewUninitialized) 
	{
		if (m_strDeferredLoad.IsEmpty())
			pSource = CDataSource::CreateFromIStream(pStm);
		else
		{
			pSource = CBufferDataSource::CreateDataSourceFromFile(m_strDeferredLoad);
			if (pSource)
			{
				const long DONT_USE_LAST_FOLDER = 1;
				SetSource(pSource, TRUE);
				pConsole()->UpdateAllViews(0, DONT_USE_LAST_FOLDER, 0L);
				SetSelectedFolder(NULL);
				return S_OK;
			}
			else
				m_strDeferredLoad.Empty();
		}

		if (pSource == NULL) 
			InitializeSource();
		else
		{
			if (!m_strDeferredCategories.IsEmpty())
				pSource->SetCategories(m_strDeferredCategories);

			SetSource(pSource, TRUE);

			if (!m_strDeferredMachine.IsEmpty())
				SetMachine(m_strDeferredMachine);
		}
	}
	return S_OK;
}

/*
 * Save - Save our state to the stream provided.
 *
 * History:	a-jsari		11/5/97		Initial version
 */
STDMETHODIMP CSystemInfoScope::Save(IStream *pStm, BOOL fClearDirty)
{
	TRACE(_T("CSystemInfoScope::Save\n"));
	ASSERT(pStm != NULL);
	if (pStm == NULL) return E_POINTER;

	if (fClearDirty)
		ClearDirty();

	HRESULT hResult = S_OK;

	// If there is a source, let it save its state to the stream. Otherwise,
	// save the state for the default source (GATHERER with no machine name).

	if (m_pSource) 
		hResult = m_pSource->Save(pStm);
	else
	{
		unsigned	wValue;
		ULONG		cWrite;

		wValue = CDataSource::GATHERER;
		hResult = pStm->Write(&wValue, sizeof(wValue), &cWrite);
		if (SUCCEEDED(hResult))
		{
			wValue = 0;
			hResult = pStm->Write(&wValue, sizeof(wValue), &cWrite);
		}
	}

	return hResult;
}

/*
 * IsDirty - Return our Dirty status, to see if a save would be beneficial.
 *
 * History:	a-jsari		11/5/97		Initial version
 */
STDMETHODIMP CSystemInfoScope::IsDirty()
{
	TRACE(_T("CSystemInfoScope::IsDirty\n"));
	return ObjectIsDirty() ? S_OK : S_FALSE;
}

/*
 * GetClassID - Return our Component Object Class ID.
 *
 * History:	a-jsari		11/5/97		Initial version
 */
STDMETHODIMP CSystemInfoScope::GetClassID(CLSID *pClassID)
{
	TRACE(_T("CSystemInfoScope::GetClassID\n"));
	ASSERT(pClassID != NULL);
	if (pClassID == NULL) return E_POINTER;
	*pClassID = GetCoClassID();
	return S_OK;
}

/*
 * GetSizeMax - Return the maximum size consumed in a stream by our
 *		persistance.
 *
 * History:	a-jsari		11/5/97		Initial version
 */
STDMETHODIMP CSystemInfoScope::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
	TRACE(_T("CSystemInfoScope::GetSizeMax\n"));
	ASSERT(pcbSize != NULL);
	if (pcbSize == NULL) return E_POINTER;
	pcbSize->LowPart	= 2 * sizeof(unsigned) + MAX_PATH;
	pcbSize->HighPart	= 0;
	return E_NOTIMPL;
}

//-----------------------------------------------------------------------------
// Implementation of GetHelpTopic, which supplies the location of our help
// file to MMC for merging into the combined help. Adapted from example in
// the MMC help file.
//-----------------------------------------------------------------------------

STDMETHODIMP CSystemInfoScope::GetHelpTopic(LPOLESTR* lpCompiledHelpFile)
{
    if (lpCompiledHelpFile == NULL)
        return E_POINTER;

	// Get the name of our help file, and prepend the help directory.
	// Actually, although the MMC documentation said that a full path is
	// required, we can just put the file name, since it is being stored in
	// the system help directory (HTMLHelp will find it there).

    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    CString strHelp;
	strHelp.LoadString(IDS_MSINFO_HELP_FILE);

	// NOTE: It looks like HTMLHelp has been changed, and will not locate
	// the help file in the standard help directory. So we'll need to get
	// the full path to the help file. (JCM, 7/1/98)

	TCHAR szFilePath[MAX_PATH];
    DWORD dwCnt = ExpandEnvironmentStrings(CString(_T("%WINDIR%\\help\\")) + strHelp, szFilePath, MAX_PATH);
    ASSERT(dwCnt != 0);
	if (dwCnt != 0) strHelp = szFilePath;
	
	// Allocate the string to hold the help file path. MMC will be responsible
	// for deallocating this buffer later.

    *lpCompiledHelpFile = reinterpret_cast<LPOLESTR>(CoTaskMemAlloc((strHelp.GetLength() + 1)* sizeof(wchar_t)));
    if (*lpCompiledHelpFile == NULL)
        return E_OUTOFMEMORY;

	// Copy from the path string to the buffer and return success.

    USES_CONVERSION;
    wcscpy(*lpCompiledHelpFile, T2OLE((LPTSTR)(LPCTSTR)strHelp));
    return S_OK;
}

/*
 * SetMachine - Set our internal machine name.
 *
 * History:	a-jsari		1/16/98		Initial version.
 */
BOOL CSystemInfoScope::SetMachine(const CString &strMachine)
{
	BOOL	fReturn = FALSE;

	*m_pstrMachineName = strMachine;
	ASSERT(pSource() != NULL);
	if (pSource() && pSource()->GetType() == CDataSource::GATHERER) 
	{
		// Changing the machine name is only meaningful if we are connected to a WBEM
		// data source.

		CWBEMDataSource * pWBEMSource = reinterpret_cast<CWBEMDataSource *>(pSource());

		fReturn = pWBEMSource->SetMachineName(*m_pstrMachineName);
		if (fReturn)
		{
			// If we succeeded, reset the root node text. Also, there's a hack in place
			// to keep SetSource from running twice during initialization. Which requires
			// another hack here to make it run - change the flag it uses to keep track
			// of the last call so that this call is different. I hate this.

			m_fSetSourcePreLaunch = TRUE;
			SetSource(pSource(), FALSE);
		}
		else {
		}
	}
	return fReturn;
}

/*
 * SetView - Set the view on the data.
 *
 * History:	a-jsari		12/3/97		Initial version.
 */
void CSystemInfoScope::SetView(enum DataComplexity Complexity, BOOL fViewInitialized)
{
	CDataSource		*pDataSource = pSource();
	switch (Complexity) {
	case BASIC:
		m_BasicFlags = MF_CHECKED;
		m_AdvancedFlags = 0L;
		break;
	case ADVANCED:
		m_BasicFlags = 0L;
		m_AdvancedFlags = MF_CHECKED;
		break;
	}
	if (pDataSource != NULL)
		VERIFY(pDataSource->SetDataComplexity(Complexity));
	if (fViewInitialized) {
		CRegKey		crkView;
		long		lResult;

		pConsole()->UpdateAllViews(NULL, 0, 0);
		lResult = crkView.Create(HKEY_CURRENT_USER, cszViewKey);
		if (lResult != ERROR_SUCCESS) return;
		switch (Complexity) {
		case ADVANCED:
			lResult = crkView.SetValue(cszAdvancedValue, cszViewValue);
			break;
		case BASIC:
			lResult = crkView.SetValue(cszBasicValue, cszViewValue);
			break;
		}
	}
}

/*
 * SetSource - Remove the old data source, and replace it with a new one.
 *
 * History:	a-jsari		9/25/97		Initial version.
 */

void CSystemInfoScope::SetSource(CDataSource *pNewSource, BOOL fPreLaunch)
{
	HSCOPEITEM	hsiRoot;
	HRESULT		hr;
	BOOL		fUIOK = FALSE;

	// We have some variables in this class to make sure that SetSource
	// isn't called twice during initialization with the same parameters.

	if (m_pSetSourceSource == pNewSource && m_fSetSourcePreLaunch == fPreLaunch)
		return;
	m_pSetSourceSource = pNewSource;
	m_fSetSourcePreLaunch = fPreLaunch;

	//	If fPreLaunch is TRUE, we have not yet created our UI items.
	if (fPreLaunch == FALSE) {
		if (m_pmapCategories == NULL)
			m_pmapCategories = new CScopeItemMap;

		//	Select the root node so we can remove all its children.
		if (m_pmapCategories && !m_pmapCategories->ScopeFromView(NULL, hsiRoot))
			return;
		hr = pConsole()->SelectScopeItem(hsiRoot);
		ASSERT(SUCCEEDED(hr));
		if (FAILED(hr)) return;

		// Before we delete the item, we want to make sure that it's actually
		// been added. Try a call to GetItem to make sure it's there.

		SCOPEDATAITEM item; item.mask = SDI_CHILDREN; item.ID = hsiRoot;
		fUIOK = SUCCEEDED(pScope()->GetItem(&item));

		if (fUIOK)
		{
			m_fInternalDelete = TRUE;
			hr = pScope()->DeleteItem(hsiRoot, FALSE);
			m_fInternalDelete = FALSE;

			if (pSource() && pSource()->GetType() == CDataSource::GATHERER)
				((CWBEMDataSource *) pSource())->ResetCategoryRefresh();

			ASSERT(SUCCEEDED(hr));
			if (FAILED(hr)) return;

			if (m_pSaveUnknown)
			{
				m_pstrMachineName = new CString;
				m_pstrOverrideName = new CString;
				Initialize(m_pSaveUnknown);
				m_pSaveUnknown = NULL;
			}
		}

		//	Remove our memory of data items.
	
		m_pmapCategories->Clear();
	}
	//	Don't delete our pointer if we are resetting the same pointer.
	if (m_pSource != pNewSource) {
		if (!m_pSource)
			m_pSource = pNewSource;
		else {
			DataComplexity	Complexity;
			Complexity = m_pSource->m_Complexity;

			delete m_pSource;
			m_pSource = pNewSource;
			m_pSource->SetDataComplexity(Complexity);
		}
	}
	if (fPreLaunch == FALSE) {
		CFolder			*pFolder;
		SCOPEDATAITEM	sdiRoot;
		CString			strNodeName;

		USES_CONVERSION;
		::memset(&sdiRoot, 0, sizeof(sdiRoot));
		//	Identify the node.
		sdiRoot.ID = hsiRoot;
		sdiRoot.mask = SDI_STR;
		m_pSource->GetNodeName(strNodeName);
		sdiRoot.displayname = T2OLE(const_cast<LPTSTR>((LPCTSTR)strNodeName));
		hr = pScope()->SetItem(&sdiRoot);
		ASSERT(SUCCEEDED(hr));
		hr = AddRoot(hsiRoot, &pFolder);
		ASSERT(SUCCEEDED(hr));
		if (FAILED(hr)) return;

		if (fUIOK)
		{
			hr = ScopeEnumerate(hsiRoot, pFolder);
			ASSERT(SUCCEEDED(hr));
			if (FAILED(hr)) return;
		}
	}
}

/*
 * AddRoot - Insert a CCategoryObject of the root folder into our Category map.
 *
 * History:	a-jsari		11/20/97		Initial version
 */
HRESULT CSystemInfoScope::AddRoot(HSCOPEITEM hsiRoot, CFolder **ppFolder)
{
	ASSERT(ppFolder != NULL);
	(*ppFolder) = pRootCategory();
	ASSERT(*ppFolder != NULL);
	if (*ppFolder == NULL) return E_FAIL;
	//	This object gets deleted in the mapCategories destructor
	CViewObject		*pvoData = new CCategoryObject(*ppFolder);
	if (pvoData == NULL) ::AfxThrowMemoryException();
	m_pmapCategories->InsertRoot(pvoData, hsiRoot);
	return S_OK;
}

/*
 * GetNamedChildFolder - Update strCategory to add the next backslash-
 *		delimited path element from strPath.
 *
 * History:	a-jsari		12/17/97		Initial version
 */
static inline void GetNamedChildFolder(
		CString &strCategory,
		const CString &strPath)
{
	int		iString;
	CString	strSubCategory;
	CString	strName;

	//	Remove the Category prefix from the path
	iString = strPath.Find(strCategory);
	ASSERT(iString == 0);
	strSubCategory = strPath.Mid(iString + strCategory.GetLength() + 1);

	//	Remove the trailing categories
	//	(We'll deal with your rebel friends soon enough).
	iString = strSubCategory.Find((TCHAR) '\\');
	if (iString != -1)
		strSubCategory = strSubCategory.Left(iString);

	//	Update the category to add the current category
	strCategory += _T("\\");
	strCategory += strSubCategory;

#if 0
	//	Turned out not to need this code.
	//	Find the Sub-folder with the name of the Sub-category.
	pfNext = pfNext->GetChildNode();
	do {
		pfNext->GetName(szName);
		if (szName == szSubCategory) break;
		pfNext = pfNext->GetNextNode();
	} while (pfNext != NULL);
	ASSERT(pfNext != NULL);
#endif
}

//-----------------------------------------------------------------------------
// If were are currently refreshing, hang here until it's done.
//-----------------------------------------------------------------------------

void CSystemInfoScope::WaitForRefresh()
{
	if (pSource() && pSource()->GetType() == CDataSource::GATHERER)
	{
		CWBEMDataSource * pWBEMSource = reinterpret_cast<CWBEMDataSource *>(pSource());
		if (pWBEMSource && pWBEMSource->m_pThreadRefresh)
			pWBEMSource->m_pThreadRefresh->WaitForRefresh();
	}
}

//-----------------------------------------------------------------------------
// Is an asynchronous refresh currently in progress?
//-----------------------------------------------------------------------------

BOOL CSystemInfoScope::InRefresh()
{
	if (pSource() && pSource()->GetType() == CDataSource::GATHERER)
	{
		CWBEMDataSource * pWBEMSource = reinterpret_cast<CWBEMDataSource *>(pSource());
		if (pWBEMSource && pWBEMSource->m_pThreadRefresh)
			return pWBEMSource->m_pThreadRefresh->IsRefreshing();
	}

	return FALSE;
}

/*
 * SelectItem - Select the item pointed to by szPath
 *
 * History:	a-jsari		12/11/97		Initial version
 */
BOOL CSystemInfoScope::SelectItem(const CString &strPath, int iLine)
{
	HSCOPEITEM		hsiNode;
	HRESULT			hr;

	//	Get the named node from our internal list.
	if (m_pmapCategories->ScopeFromName(strPath, hsiNode)) {
		CFolder		*pFolder = m_pmapCategories->CategoryFromScope(hsiNode);
		pFolder->SetSelectedItem(iLine);
		hr = pConsole()->SelectScopeItem(hsiNode);
		ASSERT(hr == S_OK);

		if (m_pLastSystemInfo)
			m_pLastSystemInfo->SelectLine(iLine);

		if (FAILED(hr)) return FALSE;
	} else {

		CString		strCategory = strPath;
		int			iEnumerations = 0;
		int			iString;

		//	If the category isn't in our list, we need to enumerate all nodes
		//	leading up to it.
		while (!m_pmapCategories->ScopeFromName(strCategory, hsiNode)) {
			++iEnumerations;
			//	Strip the last Category off the Path.
			iString = strCategory.ReverseFind((TCHAR) '\\');
			if (iString == -1) {
				//	If this fails, no nodes have been yet enumerated.
				if (!m_pmapCategories->ScopeFromName(_T(""), hsiNode)) {
					//	--iEnumerations;
					break;
				}
			} else {
				strCategory = strCategory.Left(iString);
			}
		}

		HRESULT		hr;
 		//	Enumerate all unenumerated nodes.
#if 0
		//	Commented out because InsertItem in ScopeEnumerate fails inexplicably.
		CFolder	*pfCurrent = pmapCategories->CategoryFromScope(hsiNode);
#endif
		while (iEnumerations--) {
#if 0
			hr = ScopeEnumerate(hsiNode, pfCurrent);
#else
			hr = pConsole()->SelectScopeItem(hsiNode);
#endif
			ASSERT(hr == S_OK);
			if (FAILED(hr)) return FALSE;
			GetNamedChildFolder(strCategory, strPath);
			if (!m_pmapCategories->ScopeFromName(strCategory, hsiNode))
				//	The scope item we are searching for cannot be enumerated  (The
				//	attempt to do so in SelectScopeItem has failed.)  This can happen
				//	when we are connected to a remote computer which can't be accessed.
				return FALSE;
		}
		CFolder		*pFolder = m_pmapCategories->CategoryFromScope(hsiNode);
		//	Using this method of selecting a line because MMC won't
		//	just allow me to call GetItem.
		pFolder->SetSelectedItem(iLine);
		hr = pConsole()->SelectScopeItem(hsiNode);

		if (m_pLastSystemInfo)
			m_pLastSystemInfo->SelectLine(iLine);

		ASSERT(hr == S_OK);
		if (FAILED(hr)) return FALSE;
	}
	return TRUE;
}

/*
 * ScopeEnumerate - Insert all categories of the given pFolder as namespace children
 *		of hsiNode.
 *
 * History:	a-jsari		11/20/97		Initial version
 */

HRESULT CSystemInfoScope::ScopeEnumerate(HSCOPEITEM hsiNode, CFolder *pFolder)
{
	HRESULT hr = S_OK;

	ASSERT(pFolder);
	if (pFolder == NULL)
		return hr;

	SCOPEDATAITEM sdiNode;
	sdiNode.mask		= SDI_STR | SDI_PARAM | SDI_PARENT;
	sdiNode.displayname = MMC_CALLBACK;
	sdiNode.relativeID	= hsiNode;

	// If GetChildNode returned a NULL pointer, and this is the root node,
	// then some sort of error must have occurred.

	CFolder * pfolIterator = pFolder->GetChildNode();
	if (pfolIterator == NULL && pFolder->GetParentNode() == NULL)
	{
		AFX_MANAGE_STATE(::AfxGetStaticModuleState());

		if (m_pSource && m_pSource->GetType() == CDataSource::GATHERER)
			if (((CWBEMDataSource *)m_pSource)->m_pGatherer)
			{
				DWORD dwError = ((CWBEMDataSource *)m_pSource)->m_pGatherer->GetLastError();
				if (dwError)
					DisplayGatherError(dwError, (LPCTSTR)((CWBEMDataSource *)m_pSource)->m_strMachineName);
			}
	}

	while (pfolIterator) 
	{
		// This object gets deleted inthe mapCategories destructor.

		CViewObject * pCategory = new CCategoryObject(pfolIterator);
		ASSERT(pCategory != NULL);
		if (pCategory == NULL) 
			return E_OUTOFMEMORY;

		// If there are no children, modify the node we're inserting so
		// we don't get a '+' sign next to the folder.

		if (pfolIterator->GetChildNode() == NULL)
		{
			sdiNode.cChildren = 0;
			sdiNode.mask |= SDI_CHILDREN;
		}
		else
		{
			sdiNode.cChildren = 1;
			sdiNode.mask &= ~SDI_CHILDREN;
		}

		sdiNode.lParam = reinterpret_cast<LPARAM>(pCategory);
		hr = pScope()->InsertItem(&sdiNode);
		ASSERT(hr == S_OK);
		if (FAILED(hr)) 
		{
			delete pCategory;
			break;
		}

		pfolIterator->m_hsi = sdiNode.ID;
		m_pmapCategories->Insert(pCategory, sdiNode.ID);
		pfolIterator = pfolIterator->GetNextNode();
	}

	return hr;
}

/*
 * AddExtensionRoot - If the snapin is loaded as an extension, create the root node.
 *
 * History:	a-jsari		1/6/97		Initial version
 */
HRESULT CSystemInfoScope::AddExtensionRoot(HSCOPEITEM &hsiNode, CFolder **pFolder)
{
	SCOPEDATAITEM	sdiNode;
	HRESULT			hrReturn;
	CViewObject		*pView;

	::memset(&sdiNode, 0, sizeof(sdiNode));
	sdiNode.mask = SDI_STR | SDI_PARAM | SDI_PARENT | SDI_IMAGE | SDI_OPENIMAGE;
	sdiNode.nImage = 0;
	sdiNode.nOpenImage = 0;
	sdiNode.displayname = MMC_CALLBACK;
	sdiNode.relativeID = hsiNode;

	pView = new CExtensionRootObject(pRootCategory());
	ASSERT(pView != NULL);
	if (pView == NULL) ::AfxThrowMemoryException();
	m_RootCookie = sdiNode.lParam = reinterpret_cast<LPARAM>(pView);
	hrReturn = pScope()->InsertItem(&sdiNode);
	hsiNode = sdiNode.ID;
	m_pmapCategories->InsertRoot(pView, hsiNode);
	*pFolder = pRootCategory();
	return hrReturn;
}

/*
 * OnExpand - If fExpand is TRUE, expand the item pointed to by pDataObject,
 *		otherwise contract it.  If expanding, enumerate children.
 *
 * History:	a-jsari		9/25/97		Initial version
 */

HRESULT CSystemInfoScope::OnExpand(LPDATAOBJECT pDataObject, LPARAM fExpand, HSCOPEITEM hsiNode)
{
	CFolder		*pfolSelection;
	HRESULT		hr;

	// Log the expand event, so we know that the user clicked on a node.

	if (msiLog.IsLogging(CMSInfoLog::CATEGORY))
	{
		CFolder * pFolder = m_pmapCategories->CategoryFromScope(hsiNode);
		if (pFolder)
		{
			CString strName;
			if (pFolder->GetName(strName))
				msiLog.WriteLog(CMSInfoLog::CATEGORY, _T("CATEGORY \"%s\"\r\n"), strName);
		}
	}

	//	We have nothing to do if we are contracting a node.
	//	This never happens.
	if (fExpand == 0) return S_OK;

	//	If our initialization failed, exit.
	if (!m_bInitializedCD) return S_OK;
	//	Look up the CViewObject in our internal table based on our hsiNode value,
	//	and 
	//	CHECK:	Consider the memory leak potential in this map.
	if ((pfolSelection = m_pmapCategories->CategoryFromScope(hsiNode)) == NULL) {
	//	If the expanded node isn't in our internal hash table, we should 
	//	be looking at the root node, so get it.
		if (IsPrimaryImpl() == FALSE) {
			//	If we are an extension . . .
			FORMATETC		fmtMachine = {
				(CLIPFORMAT) CDataObject::m_cfMachineName,
				NULL,
				DVASPECT_CONTENT,
				TYMED_HGLOBAL
			};
			STGMEDIUM		stgMachine;

			stgMachine.tymed = TYMED_HGLOBAL;
			stgMachine.hGlobal = ::GlobalAlloc(GMEM_MOVEABLE, (MAX_PATH + 1)* sizeof(WCHAR));
			stgMachine.pUnkForRelease = NULL;

			//	Only look externally for the machine when we are an extension.
			hr = pDataObject->GetDataHere(&fmtMachine, &stgMachine);
			if (hr == S_OK) {
				USES_CONVERSION;
				CString strMachine = W2T((LPWSTR)::GlobalLock(stgMachine.hGlobal));
				::GlobalUnlock(stgMachine.hGlobal);
				HGLOBAL		hGlobal = ::GlobalFree(stgMachine.hGlobal);
				ASSERT(hGlobal == NULL);
				SetMachine(strMachine);
			} else
				ASSERT(hr == DV_E_FORMATETC);
			hr = AddExtensionRoot(hsiNode, &pfolSelection);
			ASSERT(SUCCEEDED(hr));
			return hr;
		} else {
			hr = AddRoot(hsiNode, &pfolSelection);
			ASSERT(SUCCEEDED(hr));
			if (FAILED(hr)) return hr;
		}
	}
	return ScopeEnumerate(hsiNode, pfolSelection);
}

/*
 * OnProperties - Called when a property value changes.
 *
 * History: a-jsari		9/25/97		Initial version.
 */
HRESULT CSystemInfoScope::OnProperties(LPARAM)
{
	DWORD	dwError = 0;

	AFX_MANAGE_STATE(::AfxGetStaticModuleState());

	if (m_pSource && m_pSource->GetType() == CDataSource::GATHERER)
	{
		CWBEMDataSource * pWBEMSource = reinterpret_cast<CWBEMDataSource *>(pSource());
		if (pWBEMSource && pWBEMSource->m_pThreadRefresh)
			pWBEMSource->m_pThreadRefresh->CancelRefresh();

		if (m_strLastMachineName.CompareNoCase((LPCTSTR) *m_pstrMachineName) != 0)
		{
			// Try to connect to the new machine. If the connection fails, display
			// an appropriate error message and restore the machine name to the
			// original string.

			if (((CWBEMDataSource *)m_pSource)->m_pGatherer->SetConnect(*m_pstrMachineName))
			{
				if (NULL == ((CWBEMDataSource *)m_pSource)->m_pGatherer->GetProvider())
					dwError = ((CWBEMDataSource *)m_pSource)->m_pGatherer->GetLastError();
			}
			else
				dwError = ((CWBEMDataSource *)m_pSource)->m_pGatherer->GetLastError();

			if (dwError)
			{
				// Display the error, and reset the machine name and the data source
				// to the previous known good name.

				DisplayGatherError(dwError, (LPCTSTR) *m_pstrMachineName);
				*m_pstrMachineName = m_strLastMachineName;
				((CWBEMDataSource *)m_pSource)->m_pGatherer->SetConnect(*m_pstrMachineName);
				((CWBEMDataSource *)m_pSource)->m_pGatherer->GetProvider();
				RefreshAsync(m_pfLast, m_pLastSystemInfo, FALSE);
			}
			else
			{
				if (pSource() != NULL)
					SetMachine(*m_pstrMachineName);
			}
		}

		// This doesn't really seem necessary...
		//	if (m_pfLast && pConsole())
		//		pConsole()->SelectScopeItem(m_pfLast->m_hsi);
	}

	return S_OK;
}

//-----------------------------------------------------------------------------
// DisplayGatherError
//
// There are multiple places we need to display a connection error to the user,
// so the functionality is gathered here.
//-----------------------------------------------------------------------------

void CSystemInfoScope::DisplayGatherError(DWORD dwError, LPCTSTR szMachineName)
{
	CString strMachine, strErrorMessage;

	if (!dwError)
		return;

	if (szMachineName)
		strMachine = CString(szMachineName);

	AFX_MANAGE_STATE(::AfxGetStaticModuleState());

	if (strMachine.IsEmpty())
		strMachine.LoadString(IDS_LOCALCOMPLABEL);

	switch (dwError) 
	{
	case GATH_ERR_ALLOCATIONFAILED:
	case GATH_ERR_NOWBEMOUTOFMEM:
		strErrorMessage.LoadString(IDS_OUTOFMEMERROR);
		break;
	case GATH_ERR_NOWBEMLOCATOR:
		strErrorMessage.LoadString(IDS_NOLOCATOR);
		break;
	case GATH_ERR_NOWBEMCONNECT:
		strErrorMessage.Format(IDS_NOGATHERER, strMachine);
		break;
	case GATH_ERR_NOWBEMACCESSDENIED:
		strErrorMessage.Format(IDS_GATHERACCESS, strMachine);
		break;
	case GATH_ERR_NOWBEMBADSERVER:
		strErrorMessage.Format(IDS_BADSERVER, strMachine);
		break;
	case GATH_ERR_NOWBEMNETWORKFAILURE:
		strErrorMessage.Format(IDS_NETWORKERROR, strMachine);
		break;
	case GATH_ERR_BADCATEGORYID:
		strErrorMessage.LoadString(IDS_UNEXPECTED);
		break;
	default:
		ASSERT(FALSE);
		strErrorMessage.LoadString(IDS_UNEXPECTED);
		break;
	}

	MessageBox(strErrorMessage);
}

/*
 * MachineName - Return the current connected machine as a LPCSTR.
 *
 * History:	a-jsari		11/12/97		Initial version.
 */
LPCTSTR CSystemInfoScope::MachineName() const
{
	if (m_pstrMachineName == NULL || m_pstrMachineName->GetLength() == 0) return NULL;
	return (LPCTSTR)(*m_pstrMachineName)+2;	// +2 to skip over the initial "\\"
}

/*
 * SetSelectedFolder - Remember the last selected folder for context-
 *		sensitive operations (i.e. Print, Report, Find)
 *
 * History:	a-jsari		2/12/98		Initial version
 */
void CSystemInfoScope::SetSelectedFolder(CFolder *pFolder)
{
	m_pfLast = pFolder;
	if (pSource() != NULL)
		pSource()->SetLastFolder(pFolder);
}

//-----------------------------------------------------------------------------
// Start an async refresh of the specified folder.
//-----------------------------------------------------------------------------

void CSystemInfoScope::RefreshAsync(CFolder * pFolder, CSystemInfo * pSystemInfo, BOOL fSoftRefresh)
{
	if (pSource() && pSource()->GetType() == CDataSource::GATHERER)
	{
		CWBEMDataSource * pWBEMSource = reinterpret_cast<CWBEMDataSource *>(pSource());
		if (pWBEMSource && pWBEMSource->m_pThreadRefresh)
			pWBEMSource->m_pThreadRefresh->RefreshFolderAsync(pFolder, pSystemInfo, FALSE, fSoftRefresh);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\chooser.h ===
/////////////////////////////////////////////////////////////////////
//	Chooser.h
//
//  Copyright (c) 1997-1999 Microsoft Corporation
//
//	HISTORY
//	13-May-1997		t-danm		Creation.
//
/////////////////////////////////////////////////////////////////////

#ifndef __CHOOSER_H_INCLUDED__
#define __CHOOSER_H_INCLUDED__

LPCTSTR PchGetMachineNameOverride();

#include <afxdlgs.h>
#include <mmc.h>
#include "choosert.h"	// Temporary IDs
#include "chooserd.h"	// Default IDs

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
//	class CAutoDeletePropPage
//
//	This object is the backbone for property page
//	that will *destroy* itself when no longer needed.
//	The purpose of this object is to maximize code reuse
//	among the various pages in the snapin wizards.
//
//	INHERITANCE TREE (so far)
//	CAutoDeletePropPage - Base object
//		CChooseMachinePropPage - Dialog to select a machine name
//			CFileMgmtGeneral - Dialog to select "File Services" (snapin\filemgmt\snapmgr.h)
//			CMyComputerGeneral - Dialog for the "My Computer" (snapin\mycomput\snapmgr.h)
//		CChoosePrototyperPropPage - Dialog to select prototyper demo (NYI)
//	
//	HISTORY
//	15-May-1997		t-danm		Creation. Split of CChooseMachinePropPage
//					to allow property pages to have more flexible dialog
//					templates.
//
class CAutoDeletePropPage : public CPropertyPage
{
public:
// Construction
	CAutoDeletePropPage(UINT uIDD);
	virtual ~CAutoDeletePropPage();

protected:
// Dialog Data
	//{{AFX_DATA(CAutoDeletePropPage)
	//}}AFX_DATA

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CAutoDeletePropPage)
	virtual BOOL OnSetActive();
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CAutoDeletePropPage)
	afx_msg BOOL OnHelp(WPARAM wParam, LPARAM lParam);
	afx_msg BOOL OnContextHelp(WPARAM wParam, LPARAM lParam);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	// This mechanism deletes the CAutoDeletePropPage object
	// when the wizard is finished
	struct
		{
		INT cWizPages;	// Number of pages in wizard
		LPFNPSPCALLBACK pfnOriginalPropSheetPageProc;
		} m_autodeleteStuff;

	static UINT CALLBACK S_PropSheetPageProc(HWND hwnd,	UINT uMsg, LPPROPSHEETPAGE ppsp);

protected:
	CString m_strHelpFile;				// Name for the .hlp file
	const DWORD * m_prgzHelpIDs;		// Optional: Pointer to an array of help IDs
	
public:
	/////////////////////////////////////////////////////////////////////	
	void SetCaption(UINT uStringID);
	void SetCaption(LPCTSTR pszCaption);
	void SetHelp(LPCTSTR szHelpFile, const DWORD rgzHelpIDs[]);
	void EnableDlgItem(INT nIdDlgItem, BOOL fEnable);
}; // CAutoDeletePropPage


/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
//	class CChooseMachinePropPage
//
//	This object is a stand-alone property page used to
//	select a computer name.
//
//	The object CChooseMachinePropPage can have its dialog
//	template replaced to allow a new wizard without any new code.
//	The object can also be inherited, allowing easy extentionability.
//
//	RESTRICTIONS:
//	If the user wishes to provide its own dialog template, here
//	are the dialog IDs that must present:
//		IDC_CHOOSER_RADIO_LOCAL_MACHINE - Select local machine.
//		IDC_CHOOSER_RADIO_SPECIFIC_MACHINE - Select a specific machine.
//		IDC_CHOOSER_EDIT_MACHINE_NAME - Edit field to enter the machine name.
//	There are also optional IDs:
//		IDC_CHOOSER_BUTTON_BROWSE_MACHINENAMES - Browse to select a machine name.
//		IDC_CHOOSER_CHECK_OVERRIDE_MACHINE_NAME - Checkbox to allow the machine name to be overriden by command line.
//
class CChooseMachinePropPage : public CAutoDeletePropPage
{
public:
	enum { IID_DEFAULT = IDD_CHOOSER_CHOOSE_MACHINE };

public:
// Construction
	CChooseMachinePropPage(UINT uIDD = IID_DEFAULT);
	virtual ~CChooseMachinePropPage();

protected:
	void InitRadioButtons();

// Dialog Data
	//{{AFX_DATA(CChooseMachinePropPage)
	BOOL m_fIsRadioLocalMachine;		// TRUE => Local Machine is selected
	BOOL m_fAllowOverrideMachineName;	// TRUE => Machine name can be overriden from command line
	CString	m_strMachineName;
	//}}AFX_DATA

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CChooseMachinePropPage)
	public:
	virtual BOOL OnWizardFinish();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CChooseMachinePropPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnRadioLocalMachine();
	afx_msg void OnRadioSpecificMachine();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
	HWND m_hwndCheckboxOverride;

protected:
	BOOL * m_pfAllowOverrideMachineNameOut;	// OUT: Pointer to BOOL receiving flag wherever to override machine name
	CString * m_pstrMachineNameOut;	// OUT: Pointer to the CString object to store the machine name
	CString * m_pstrMachineNameEffectiveOut;	// OUT: Pointer to the CString object to store the effective machine name
	LONG_PTR m_hNotify;		//	Notify handle.

public:
	void InitMachineName(LPCTSTR pszMachineName);
	void SetOutputBuffers(
		OUT CString * pstrMachineNamePersist,
		OUT OPTIONAL BOOL * pfAllowOverrideMachineName,
		OUT OPTIONAL CString * pstrMachineNameEffective);
	void SetHandle(LONG_PTR hNotify) { m_hNotify = (LONG_PTR)hNotify; }

}; // CChooseMachinePropPage


#endif // ~__CHOOSER_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\dataobj.h ===
// DataObj.h : Internal data object structure for transfering clipboard formats.
//
// Copyright (c) 1998-1999 Microsoft Corporation

#pragma once		// MSINFO_DATAOBJ_H
#define MSINFO_DATAOBJ_H

#ifdef MSINFO_COMPDATA_H
#error "DataObj.h must be included _before_ CompData.h"
#endif // MSINFO_COMPDATA_H

//	This hack is required because we may be building in an environment
//	which doesn't have a late enough version of rpcndr.h
#if		__RPCNDR_H_VERSION__ < 440
#define __RPCNDR_H_VERSION__ 440
#define MIDL_INTERFACE(x)	interface
#endif

#ifndef __mmc_h__
#include <mmc.h>
#endif // __mmc_h__
#include "StdAfx.h"

//	Forward declaration.
class CDataObject;

#include "CompData.h"

/*
 * CDataObject - The public interface for a unit of data.
 */
class CDataObject : public IDataObject, public CComObjectRoot
{
DECLARE_NOT_AGGREGATABLE(CDataObject)
BEGIN_COM_MAP(CDataObject)
	COM_INTERFACE_ENTRY(IDataObject)
END_COM_MAP()

friend class CSystemInfoScope;
friend class CSystemInfo;

public:
	CDataObject();
	virtual ~CDataObject();

//	Clipboard formats required by IConsole.
public:
	static unsigned int		m_cfNodeType;
	static unsigned int		m_cfNodeTypeString;
	static unsigned int		m_cfDisplayName;
	static unsigned int		m_cfCoClass;
	static unsigned int		m_cfMultiSel;
	static unsigned int		m_cfMachineName;
	static unsigned int		m_cfInternalObject;
	static unsigned int		m_cfSnapinPreloads;

//	Internal clipboard formats?
//	static unsigned int		m_cfInternal;

//	IDataObject interface implentation
public:
	STDMETHOD(GetData)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium);
	STDMETHOD(GetDataHere)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium);
	STDMETHOD(EnumFormatEtc)(DWORD dwDirection, LPENUMFORMATETC *ppEnumFormatEtc);
	STDMETHOD(QueryGetData)(LPFORMATETC lpFormatetc);
	STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut);
	STDMETHOD(SetData)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease);
	STDMETHOD(DAdvise)(LPFORMATETC lpFormatetc, DWORD advf, LPADVISESINK pAdvSink, LPDWORD pdwConnection);
	STDMETHOD(DUnadvise)(DWORD dwConnection);
	STDMETHOD(EnumDAdvise)(LPENUMSTATDATA *ppEnumAdvise);

//	Data Member Access Functions
public:
	virtual CFolder		*Category() const		= 0;

	DATA_OBJECT_TYPES	Context() const			{ return m_internal.m_type; }
	LPTSTR				String() const			{ return m_internal.m_string; }
	MMC_COOKIE			Cookie() const			{ return m_internal.m_cookie; }
	CLSID				ClassID() const			{ return pComponentData()->GetCoClassID(); }
	CSystemInfoScope	*pComponentData() const { ASSERT(m_pComponentData); return m_pComponentData; }

	void				SetContext(DATA_OBJECT_TYPES type)
			{ ASSERT(m_internal.m_type == CCT_UNINITIALIZED); m_internal.m_type = type; }
	void				SetString(LPTSTR lpString)		{ m_internal.m_string = lpString; }
	void				SetCookie(MMC_COOKIE cookie)	{ m_internal.m_cookie = cookie; }
	void SetComponentData(CSystemInfoScope *pCCD)
	{
		ASSERT(m_pComponentData == NULL && pCCD != NULL); m_pComponentData = pCCD;
	}
	CSystemInfoScope	*m_pComponentData;

protected:
	struct { MMC_COOKIE m_cookie; LPTSTR m_string; DATA_OBJECT_TYPES m_type; } m_internal;

	CDataSource *pSource() { return pComponentData()->pSource(); }

//	Internal helper functions.
protected:
	static HRESULT		CompareObjects(LPDATAOBJECT	lpDataObjectA, LPDATAOBJECT lpDataObjectB);

	//	The function which returns a DataObject based on the context
	//	information
	static HRESULT		CreateDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
			CSystemInfoScope *pScope, LPDATAOBJECT *ppDataObject);

    //	The generic Create function which puts the appropriate amount of
	//	lpMedium data into the pBuffer
	static HRESULT		Create(const void *pBuffer, int size, LPSTGMEDIUM pMedium);

	//	The specific functions which take the named member out of the
	//	specified lpMedium.
	virtual HRESULT		CreateCoClassID(LPSTGMEDIUM lpMedium);
	virtual HRESULT		CreateDisplayName(LPSTGMEDIUM lpMedium) = 0;
	virtual HRESULT		CreateNodeTypeData(LPSTGMEDIUM lpMedium) = 0;
	virtual HRESULT		CreateNodeTypeStringData(LPSTGMEDIUM lpMedium) = 0;
	virtual HRESULT		CreateSnapinPreloads(LPSTGMEDIUM lpMedium);
	virtual HRESULT		CreateMachineName(LPSTGMEDIUM lpMedium);
	virtual HRESULT		CreateInternalObject(LPSTGMEDIUM lpMedium);

	HRESULT				CreateMultiSelData(LPSTGMEDIUM lpMedium);

//	Multiple selection data.
protected:
	BYTE		*m_pbMultiSelData;
	UINT		m_cbMultiSelData;
	BOOL		m_bMultiSelDobj;
};

/*
 * CScopeDataObject - The data object for scope items.
 *
 * History:	a-jsari		9/25/97
 */
class CScopeDataObject : public CDataObject {
public:
	virtual CFolder			*Category() const
		{ return reinterpret_cast<CViewObject *>(Cookie())->Category(); }
private:
	virtual HRESULT			CreateDisplayName(LPSTGMEDIUM lpMedium);
	virtual HRESULT			CreateNodeTypeData(LPSTGMEDIUM lpMedium);
	virtual HRESULT			CreateNodeTypeStringData(LPSTGMEDIUM lpMedium);
};

/*
 * CResultDataObject - The DataObject for result items.
 *
 * History:	a-jsari		9/25/97
 */
class CResultDataObject : public CDataObject {
public:
	virtual CFolder			*Category()	const { ASSERT(FALSE); return NULL; }
private:
	virtual HRESULT			CreateDisplayName(LPSTGMEDIUM lpMedium);
	virtual HRESULT			CreateNodeTypeData(LPSTGMEDIUM lpMedium);
	virtual HRESULT			CreateNodeTypeStringData(LPSTGMEDIUM lpMedium);
};

/*
 * CManagerDataObject - The DataObject for SNAPIN_MANAGER items.
 *
 * History: a-jsari		9/25/97
 */
class CManagerDataObject : public CDataObject {
public:
	virtual	CFolder			*Category() const
		{ ASSERT(pComponentData());	return pComponentData()->pRootCategory(); }
private:
	virtual HRESULT			CreateDisplayName(LPSTGMEDIUM lpMedium);
	virtual HRESULT			CreateNodeTypeData(LPSTGMEDIUM lpMedium);
	virtual HRESULT			CreateNodeTypeStringData(LPSTGMEDIUM lpMedium);
};

/*
 * GetInternalFromDataObject - Return the CDataObject pointer represented by
 *		the lpDataObject
 *
 * History:	a-jsari		9/25/97		Initial version
 *
 * Note: It is essential that this pointer not be freed by the calling
 *		function as it points to an existing DataObject.
 */
inline CDataObject *GetInternalFromDataObject(LPDATAOBJECT lpDataObject)
{
	ASSERT(lpDataObject != NULL);
	FORMATETC		fetcInternal = {
		(unsigned short)CDataObject::m_cfInternalObject,
		NULL,
		DVASPECT_CONTENT,
		-1, /* All Data */
		TYMED_HGLOBAL
	};
	STGMEDIUM		stgmInternal = { TYMED_HGLOBAL, NULL };

	CDataObject *cdoReturn = NULL;
	//	CHECK:	Make sure this gets propertly freed.
	stgmInternal.hGlobal = ::GlobalAlloc(GMEM_SHARE, sizeof(CDataObject **));
	do {
		HRESULT hr = lpDataObject->GetDataHere(&fetcInternal, &stgmInternal);

		ASSERT(stgmInternal.pUnkForRelease == NULL);
		if (hr != S_OK) break;
		cdoReturn = *(reinterpret_cast<CDataObject **>(::GlobalLock(stgmInternal.hGlobal)));
		::GlobalUnlock(stgmInternal.hGlobal);
//		cdoReturn = *(reinterpret_cast<CDataObject **>(stgmInternal.hGlobal));
	} while (0);
	::GlobalFree(stgmInternal.hGlobal);
	return cdoReturn;
}

/*
 * GetCookieFromDataObject - Returns the cookie contained by the object
 *		represented by the lpDataObject interface.
 *
 * History:	a-jsari		9/25/97
 */
inline MMC_COOKIE GetCookieFromDataObject(LPDATAOBJECT lpDataObject)
{
	CDataObject	*cdoTemp = GetInternalFromDataObject(lpDataObject);

	//	Root node for an extension snap-in.
	if (cdoTemp == NULL) return 0;

	return cdoTemp->Cookie();
}

/*
 * IsValidRegisteredClipboardFormat - Return a Boolean value telling whether
 *		uFormatID is a valid clipboard format or not.
 *
 * History:	a-jsari		9/25/97
 */
inline bool IsValidRegisteredClipboardFormat(UINT uFormatID)
{
	//	return (uFormatID >= 0xc000 && uFormatID <= 0xffff);
	return (uFormatID != 0);
}

#if 0
/*
 * IsMMCMultiSelectDataObject - Return a flag telling whether our data object refers
 *		to a multiple item selection.
 *
 * History:	a-jsari		9/25/97
 */
inline BOOL IsMMCMultiSelectDataObject(LPDATAOBJECT lpDataObject)
{
	static unsigned int		m_cfMultiSelData = 0;

	if (m_cfMultiSelData == 0) {
		USES_CONVERSION;
		m_cfMultiSelData	= RegisterClipboardFormat(W2T(CCF_MMC_MULTISELECT_DATAOBJECT));
		ASSERT(IsValidRegisteredClipboardFormat(m_cfMultiSelData));
	}
	/* const */ FORMATETC	fmt = { (unsigned short) m_cfMultiSelData,
			NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
	return lpDataObject->QueryGetData(&fmt) == S_OK;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\dispatch.cpp ===
/*	Dispatch.cpp
 *
 *	History:	a-jsari		3/18/98		Initial version.
 *
 *  Copyright (c) 1998-1999 Microsoft Corporation
 */

#include "StdAfx.h"
#include "Dispatch.h"
#include "DataSrc.h"

/*
 * CMSInfo - 
 *
 * History:	a-jsari		3/18/98		Initial version.
 */
CMSInfo::CMSInfo()
{
}

/*
 * ~CMSInfo - Vacuous destructor
 *
 * History:	a-jsari		3/18/98		Initial version.
 */
CMSInfo::~CMSInfo()
{
}

/*
 * make_nfo - Create an NFO file from a connection to the specified computer.
 *
 * History:	a-jsari		3/18/98		Initial version.
 */
STDMETHODIMP CMSInfo::make_nfo(BSTR lpszFilename, BSTR lpszComputername)
{
	AFX_MANAGE_STATE(::AfxGetStaticModuleState());
	ASSERT(lpszFilename != NULL);
	if (lpszFilename == NULL) return E_INVALIDARG;
	CDataSource		*pDataSource = new CWBEMDataSource(lpszComputername);
	if (pDataSource == NULL) return E_ACCESSDENIED;
	return pDataSource->SaveFile(lpszFilename);
}

/*
 * make_report - Create a text report from a connection to the specified computer.
 *
 * History:	a-jsari		3/18/98		Initial version.
 */
STDMETHODIMP CMSInfo::make_report(BSTR lpszFilename, BSTR lpszComputername, BSTR lpszCategory)
{
	AFX_MANAGE_STATE(::AfxGetStaticModuleState());
	ASSERT(lpszFilename != NULL);
	if (lpszFilename == NULL) return E_INVALIDARG;
	CDataSource		*pDataSource = new CWBEMDataSource(lpszComputername);
	if (pDataSource == NULL) return E_ACCESSDENIED;
	CFolder			*pFolder;
	if (lpszCategory == NULL) pFolder = NULL;
	else {
		ASSERT(FALSE);
	}
	return pDataSource->ReportWrite(lpszFilename, pFolder);
}

//-----------------------------------------------------------------------------
// This function is exposed through COM to create an NFO file, for the
// specified computer, with the specified categories. It should not be
// assumed that there will be any UI during this operation.
//-----------------------------------------------------------------------------

STDMETHODIMP CMSInfo::MakeNFO(BSTR lpszFilename, BSTR lpszComputername, BSTR lpszCategory)
{
	AFX_MANAGE_STATE(::AfxGetStaticModuleState());
	CString strFilename(lpszFilename);
	CString strComputer(lpszComputername);
	CString strCategory(lpszCategory);

	CDataSource * pDataSource = new CWBEMDataSource(strComputer);
	if (pDataSource == NULL) 
		return E_ACCESSDENIED;

	if (pDataSource->SetCategories(strCategory) == FALSE)
		return E_ACCESSDENIED;

	HRESULT hr = pDataSource->SaveFile(strFilename);
	delete pDataSource;
	return (hr);
}

//-----------------------------------------------------------------------------
// This function is exposed through COM to create a report file, for the
// specified computer, with the specified categories. It should not be
// assumed that there will be any UI during this operation.
//-----------------------------------------------------------------------------

STDMETHODIMP CMSInfo::MakeReport(BSTR lpszFilename, BSTR lpszComputername, BSTR lpszCategory)
{
	AFX_MANAGE_STATE(::AfxGetStaticModuleState());
	CString strFilename(lpszFilename);
	CString strComputer(lpszComputername);
	CString strCategory(lpszCategory);

	CDataSource * pDataSource = new CWBEMDataSource(strComputer);
	if (pDataSource == NULL) 
		return E_ACCESSDENIED;

	if (pDataSource->SetCategories(strCategory) == FALSE)
		return E_ACCESSDENIED;

	HRESULT hr = pDataSource->ReportWrite(strFilename, NULL);
	delete pDataSource;
	return (hr);
}

//-----------------------------------------------------------------------------
// This function is exposed through COM to return a list of categories with
// the UI labels matched to internal names (for use when specifying categories
// to display or save).
//-----------------------------------------------------------------------------

STDMETHODIMP CMSInfo::QueryCategories(BSTR lpszCategories)
{
	// Not implemented yet.

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\datasrc.h ===
//	DataSrc.h	Objects which provide the sources of data for the MMC
//		data display; One object exists for Gatherer (WBEM:Web-Based
//		Enterprise Management), one for version 5.0 save files, and
//		one for version 4.10 save files.
//
//	This module contains interface.  Implementation for these objects
//		live in GathSrc.cpp (Gatherer), V500File.cpp (Version 5.0 file),
//		and V410File.cpp (Version 4.1 file), DataSrc.cpp (shared functions)
//
//	History:	a-jsari		10/9/97		Initial version
//
//  Copyright (c) 1998-1999 Microsoft Corporation

#pragma once		//	MSINFO_DATASRC_H
#define MSINFO_DATASRC_H

#include <afxtempl.h>
#include "StdAfx.h"
#include "gather.h"
#include "FileIO.h"
#include "StrList.h"
#include "thread.h"
#include <mmc.h>

class CFolder;
class CBufferFolder;

/*
 * CDataSource - Abstract base for a source for display data.
 *
 * History:	a-jsari		10/9/97		Initial version
 */
class CDataSource {
public:
	//	Allow FindNext to access our internal path variable.
	friend class CSystemInfoScope;
	friend class CFolder;

	//	Enumerate the different types of sources we can use to 
	enum	SourceType	{
		GATHERER = 0x80, OCX = 0x40,		BUFFER = 0x08,
		V410FILE = 0x09, V500FILE = 0x0a,	TEXTFILE = 0x0c
	};

	enum FindOptions {
		FIND_OPTION_ONE_CATEGORY = 0x01,
		FIND_OPTION_CATEGORY_ONLY = 0x02,
		FIND_OPTION_REPEAT_SEARCH = 0x04
	};

	CDataSource(LPCTSTR szMachineName);
	virtual ~CDataSource();

	virtual BOOL		GetNodeName(CString &strName);
	virtual	BOOL		SetDataComplexity(enum DataComplexity Complexity);

	virtual SourceType	GetType() const = 0;
	virtual CFolder		*GetRootNode()	{ return m_RootFolder; }
	virtual BOOL		Refresh(BOOL fOptional = FALSE) = 0;
	virtual HRESULT		Save(IStream *pStm) = 0;
	virtual BOOL		Find(const CString & strSearch, long lFindOptions = 0) = 0;

	//	StopSearch is called asynchronously by the Find UI thread.
	//	No CriticalSection because the method is atomic and no race conditions
	//	can exist.
	BOOL				StartSearch()
	{ if (!m_fCanceled) return FALSE; m_fCanceled = FALSE; return TRUE; }
	virtual BOOL		StopSearch()
	{ if (m_fCanceled) return FALSE; m_fCanceled = TRUE; return TRUE; };
	BOOL				FindStopped()	{ return m_fCanceled; }
	void				SetLastFolder(CFolder *pFolder)	{ m_pfLast = pFolder; }

	HRESULT			SaveFile(LPCTSTR cszFilename, CFolder *pSaveRoot = NULL);
	HRESULT			ReportWrite(LPCTSTR szReportFile, CFolder *pRootNode = NULL);
	BOOL			PrintReport(CPrintDialog *pdlgPrint, CFolder *pfolSelection = NULL);
	BOOL			RefreshPrintData(CPrintDialog * pdlgPrint, CFolder * pfolSelection);
	const CString	&MachineName() { return m_strHeaderLeft; }
	virtual BOOL	SetCategories(const CString & strCategory) { return FALSE; };

	static CDataSource	*CreateFromIStream(IStream *pStm);
protected:
	//	Data save functions.
	HRESULT		WriteOutput(CMSInfoFile *pFile, CFolder *pRootNode);
	void		WriteChildMark(CMSInfoFile *pFile);
	void		WriteEndMark(CMSInfoFile *pFile);
	void		WriteNextMark(CMSInfoFile *pFile);
	void		WriteParentMark(CMSInfoFile *pFile, unsigned count);

	//	Print functions.
	int			BeginPrinting(CPrintDialog *pdlgPrint, CFolder *pfolSelection);
	void		GetLine(LPTSTR szLineBuffer, int cSize);
	void		GetTextSize(int &cLineLength, int &cCharHeight, CRect &rectOuter,
		CRect &rectText);
	void		PrintPage(CPrintDialog *pdlgPrint);
	void		EndPrinting();

protected:
	CFolder			*m_RootFolder;		//	The root folder of the data.
	CString			m_strPath;			//	Stored path to result of last find operation
	int				m_iLine;			//	Stored line of last find operation.
	DataComplexity	m_Complexity;		//	The complexity of the displayed data.
	volatile BOOL	m_fCanceled;		//	Flag to manage cancel of multi-threaded find
	CFolder			*m_pfLast;			//	The last node found.

//	For Printing.
private:
	CDC				*m_pDC;				//	Printer's device context.
	CFont			*m_pprinterFont;	//	The font the printer uses.
	CString			m_strHeaderLeft;	//	Header text displayed at the page's top left
	CString			m_strHeaderRight;	//	Header text displayed at the page's top right.
	CString			m_strFooterCenter;	//	Footer text at the center of the page.
	CPrintInfo		*m_pPrintInfo;		//	Information about the print job
	CMSInfoFile		*m_pPrintContent;	//	A memory file containing print data.
	BOOL			m_fEndOfFile;		//	Flag specifying whether the print job ends.
};

/*
 * CFolder - Abstract base for an individual folder item.
 *
 * History:	a-jsari		10/9/97		Initial version
 */
class CFolder {
public:
	friend class CScopeItemMap;
	friend class CWBEMDataSource;
	friend class CBufferV500DataSource;
	friend class CBufferV410DataSource;
	friend class COCXFolder;
	//	Really don't want this to be a friend, but required to make Refresh work.
	friend class CSystemInfoScope;

	CFolder(CDataSource *pDataSource, CFolder *pParentNode = NULL);
	virtual ~CFolder();

	virtual CDataSource::SourceType		GetType() const	{ return m_pDataSource->GetType(); }
	virtual CFolder		*GetChildNode()		{ return m_ChildFolder; }
	virtual CFolder		*GetNextNode()		{ return m_NextFolder; }
	virtual CFolder		*GetParentNode() 	{ return m_ParentFolder; }

	virtual BOOL		GetName(CString &szName) const = 0;
	virtual BOOL		HasDynamicChildren() const = 0;
	virtual BOOL		IsDynamic() const = 0;
	virtual	BOOL		Refresh(BOOL fRecursive = FALSE) = 0;
	virtual BOOL		FileSave(CMSInfoFile *pFile) = 0;
	CDataSource			*DataSource()				{ return m_pDataSource; }

	//	One-time only line selection interface for find implementation.
	//	Used instead of MMC
	void				SetSelectedItem(int nLine)	{ m_nLine = nLine; }
	int					GetSelectedItem()			{ int nLine = m_nLine; m_nLine = -1; return nLine; }

	// Save the HSCOPEITEM for this folder, so we can reselect it when
	// there is new data.

	HSCOPEITEM			m_hsi;

protected:
	DataComplexity		GetComplexity()	const		{ return m_pDataSource->m_Complexity; }
	void				InternalName(CString &szName) const;

protected:
	CDataSource	*m_pDataSource;		//	The data source we apply to.
	CFolder		*m_NextFolder;		//	Next folder at the same level in the tree.
	CFolder		*m_ParentFolder;	//	Back-pointer to parent for traversing
	CFolder		*m_ChildFolder;		//	Pointer to the first child folder.
	BOOL		fNextTested;		//	Optimization flag for getting sibling pointer
	BOOL		fChildTested;		//	Optimization flag for getting child pointer
	int			m_nLine;			//	This folder's selected line.
};

/*
 * CListViewFolder - Abstract base for folders which enumerate listview items
 *		(As opposed to the OCX folders which handle display of listview items
 *		themselves.)
 *
 * History:	a-jsari		10/28/97		Initial version
 */
class CListViewFolder : public CFolder {
public:
	CListViewFolder(CDataSource *pDataSource, CFolder *pParentNode = NULL)
		:CFolder(pDataSource, pParentNode) { }
	~CListViewFolder()		{ }
	virtual BOOL			GetSubElement(unsigned iRow, unsigned iColumn, CString &szName) const = 0;
	virtual DWORD			GetSortIndex(unsigned iRow, unsigned iColumn) const = 0;
	virtual unsigned		GetColumns() const = 0;
	virtual unsigned		GetRows() const = 0;
	virtual DataComplexity	GetColumnComplexity(unsigned iColumn) = 0;
	virtual DataComplexity	GetRowComplexity(unsigned iRow) = 0;
	virtual int				GetColumnTextAndWidth(unsigned iColumn, CString &szText, unsigned &uColWidth) const = 0;
	virtual BOOL			GetSortType(unsigned iColumn, MSIColumnSortType &stColumn) const = 0;

	BOOL					ReportWrite(CMSInfoFile *pFile);
	BOOL					FileSave(CMSInfoFile *pFile);

protected:
	void				SaveTitle(CMSInfoFile *pFile);
	void				SaveElements(CMSInfoFile *pFile);
	void				ReportWriteTitle(CMSInfoFile *pFile);
	void				ReportWriteElements(CMSInfoFile *pFile);
};

/*
 * CWBEMFolder - Folder that queries WBEM to provide data.
 *
 * History:	a-jsari		10/9/97		Initial version
 */

extern DWORD WINAPI ThreadRefresh(void * pArg);
class CThreadingRefresh;
class CWBEMFolder : public CListViewFolder {

	friend DWORD WINAPI ThreadRefresh(void * pArg);
	friend class CThreadingRefresh;

public:
	CWBEMFolder(CDataCategory *pdcNode, CDataSource *pDataSource, CFolder *pParentNode = NULL);
	~CWBEMFolder();

	CDataSource::SourceType		GetType() const	{ return CDataSource::GATHERER; }

	CFolder			*GetChildNode();
	CFolder			*GetNextNode();

	BOOL			GetName(CString &szName) const	{ return m_pCategory->GetName(szName); }
	BOOL			HasDynamicChildren() const;
	BOOL			IsDynamic() const;

	BOOL			GetSubElement(unsigned nRow, unsigned nCol, CString &szName) const;
	DWORD			GetSortIndex(unsigned nRow, unsigned nCol) const;
	unsigned		GetRows() const;
	unsigned		GetColumns() const;
	DataComplexity	GetColumnComplexity(unsigned iColumn);
	DataComplexity	GetRowComplexity(unsigned iRow);
	int				GetColumnTextAndWidth(unsigned iColumn, CString &szText, unsigned &uColWidth) const;
	BOOL			GetSortType(unsigned iColumn, MSIColumnSortType &stColumn) const;
	BOOL			Refresh(BOOL fRecursive = FALSE);

	// Recursively reset the refresh flag.

	void ResetRefreshFlag()
	{
		m_fBeenRefreshed = FALSE;

		CWBEMFolder * pWBEMFolder = reinterpret_cast<CWBEMFolder *>(m_NextFolder);
		if (pWBEMFolder)
			pWBEMFolder->ResetRefreshFlag();

		pWBEMFolder = reinterpret_cast<CWBEMFolder *>(m_ChildFolder);
		if (pWBEMFolder)
			pWBEMFolder->ResetRefreshFlag();
	}

private:
	CDataCategory	*m_pCategory;
	BOOL			m_fBeenRefreshed;
};

/*
 * CWBEMDataSource - Data source that queries WBEM to provide data.
 *
 * History:	a-jsari		10/9/97		Initial version
 */

class CWBEMDataSource : public CDataSource {
public:
	friend class CSystemInfoScope;

	CWBEMDataSource(LPCTSTR szMachineName = NULL);
	~CWBEMDataSource();

//	BOOL		StopSearch();
	BOOL		SetDataComplexity(enum DataComplexity Complexity);
	SourceType	GetType() const { return CDataSource::GATHERER; }
	CFolder		*GetRootNode();
	
	BOOL Refresh(BOOL fOptional = FALSE)
	{ 
		StartSearch();
		BOOL fReturn = TRUE;
		if (!m_fEverRefreshed || !fOptional)
		{
			if (m_pThreadRefresh && GetRootNode())
				m_pThreadRefresh->RefreshAll(GetRootNode(), &m_fCanceled);
			else
				fReturn = m_pGatherer->Refresh(&m_fCanceled); 
			m_fEverRefreshed = fReturn;
		}
		StopSearch(); 
		return fReturn;
	}

	void ResetCategoryRefresh() 
	{ 
		if (m_pGatherer) 
			m_pGatherer->ResetCategoryRefresh(); 

		CWBEMFolder * pWBEMFolder = reinterpret_cast<CWBEMFolder *>(m_RootFolder);
		if (pWBEMFolder)
			pWBEMFolder->ResetRefreshFlag();
	};

	BOOL		GetNodeName(CString &strName);
	BOOL		SetMachineName(const CString &strMachine);

	HRESULT		Save(IStream *pStm);
	BOOL		Find(const CString & strSearch, long lFindOptions);
	BOOL		SetCategories(const CString & strCategory) { if (m_pGatherer) return m_pGatherer->SetCategories(strCategory); return FALSE; };

private:
	CDataGatherer	*m_pGatherer;
	CString			m_strMachineName;
	CString			m_strParentPath;

	BOOL			m_fEverRefreshed;

public:
	CThreadingRefresh * m_pThreadRefresh;
};

/*
 * CBufferDataSource - Abstract Data Source that reads data from an
 *		unspecified buffer source. Comes in two flavors: Version 4.10
 *		data and V 5.00 data
 *
 * History:	a-jsari		10/9/97		Initial version
 */
class CBufferDataSource : public CDataSource {
public:
	CBufferDataSource(CMSInfoFile *pfileSink);
	virtual ~CBufferDataSource();

	virtual SourceType	GetType() const = 0;

	LPCTSTR				FileName();

	BOOL				SetDataComplexity(enum DataComplexity Complexity)
	{
		CDataSource::SetDataComplexity(Complexity);
		return TRUE;
	}
	//	BufferDataSources don't get refreshed.
	BOOL				Refresh(BOOL fOptional = FALSE)	{ return TRUE; }
	BOOL				HasCAB()	{ return !m_strCabDirectory.IsEmpty(); }
	const CString           &CABDirectory() { return m_strCabDirectory; }

	static CBufferDataSource	*CreateDataSourceFromFile(LPCTSTR szFilename);

//	Buffer read functions
public:
	virtual void		ReadFolder(CMSInfoFile *pFileSink, CFolder * & pFolder, CFolder *pParentFolder = NULL) = 0;
	virtual void		ReadHeader(CMSInfoFile *pFileSink) = 0;

protected:
	CString			m_strCabDirectory;	//	The name of a CAB file directory.
	CString			m_strFileName;	//	The name of the buffer's open file
	time_t			m_tsSaveTime;	//	The time at which the data source was saved.
	CString			m_strUserName;	//	The network username who saved the file.
	CString			m_strMachine;	//	The network machine which saved the file.
};

/*
 * CBufferV50DataSource - Code for parsing a version 5.00 data file
 *
 * History:	a-jsari		10/9/97		Initial version
 */
class CBufferV500DataSource : public CBufferDataSource {
public:
	CBufferV500DataSource(CMSInfoFile *pfileSink);
	~CBufferV500DataSource();

	SourceType		GetType() const { return V500FILE; }
	BOOL			GetNodeName(CString &strName);		

	HRESULT			Save(IStream *pStm);
	BOOL			Find(const CString &strSearch, long lFindOptions);

	static BOOL		VerifyFileVersion(CMSInfoFile *pFile);

	//	MASK is required so that we can or a count in with the parent value to
	//	store a number of iterations for a parent code.
	enum NodeType { CHILD = 0x8000, NEXT = 0x4000, END = 0x2000, PARENT = 0x1000,
			MASK = 0xf000 };
public:
	void			ReadFolder(CMSInfoFile *pFileSink, CFolder * & pFolder, CFolder *pParentFolder = NULL);
	void			ReadHeader(CMSInfoFile *pFileSink);

private:
	void			ReadElements(CMSInfoFile *pFileSink, CBufferFolder *pFolder);
	BOOL			FolderContains(const CListViewFolder *fCurrent,
							const CString &strSearch, int &wRow, long lFolderOptions);

	CString			m_szFileName;
	unsigned		m_iLastLine;	//	The last line found.
};

/*
 * CBufferV410DataSource - Code for parsing a version 4.10 data file
 *
 * History:	a-jsari		10/9/97		Initial version
 */

class CBufferV410DataSource : public CBufferDataSource 
{
	friend class COCXFolder;

public:
	CBufferV410DataSource(CMSInfoFile *pfileSink);
	CBufferV410DataSource(IStorage * pStorage, IStream * pStream);
	~CBufferV410DataSource();

	BOOL				GetNodeName(CString &strName);		
	SourceType			GetType() const { return V410FILE; }
	CFolder				*GetRootNode();

	HRESULT				Save(IStream *pStm);
	BOOL				Find(const CString &szSearch, long lFindOptions);

public:
	void ReadFolder(CMSInfoFile *pFileSink, CFolder * & pFolder, CFolder *pParentFolder = NULL);
	void ReadHeader(CMSInfoFile *pFileSink);

private:
	BOOL			ReadMSInfo410Stream(IStream *pStream);
	BOOL			RecurseLoad410Tree(IStream *pStream);
	COCXFolder *	ReadOCXFolder(IStream *pStream, COCXFolder * pParent, COCXFolder * pPrevious);

private:
	CMapStringToString	m_mapStreams;
	IStorage *			m_pStorage;
};

/*
 * CBufferTextDataSource - Code for parsing a text file.
 *
 * History:	a-jsari		10/24/97		Initial version
 */
class CBufferTextDataSource : public CBufferDataSource {
public:
	CBufferTextDataSource(CMSInfoFile *pfileSink);
	~CBufferTextDataSource();

	SourceType			GetType() const { return TEXTFILE; }
	CFolder				*GetRootNode();
};

/*
 * CBufferSortData - A class to manage sort data for a CBufferFolder
 *
 * History:	a-jsari		12/1/97		Initial version
 */
class CBufferSortData {
public:
	CBufferSortData();
	~CBufferSortData();

	BOOL	SetColumns(unsigned cColumns);
	BOOL	SetRows(unsigned cRows);
	BOOL	SetSortType(unsigned iColumn, unsigned stColumn);
	BOOL	GetSortType(unsigned iColumn, MSIColumnSortType &stColumn) const;
	BOOL	ReadSortValues(CMSInfoFile *pFile, unsigned iColumn);
	DWORD	GetSortValue(unsigned iRow, unsigned iColumn) const;

private:
	int		ValueIndexFromColumn(unsigned iColumn) const;

private:
	unsigned	m_cRows;
	unsigned	m_cColumns;

	CArray <MSIColumnSortType, MSIColumnSortType &>	m_SortTypes;
	CArray <CDwordValues, CDwordValues &>			m_dwSortIndices;
	CArray <unsigned, unsigned &>					m_ValueColumns;
};

/*
 * CBufferFolder - Folder that reads data from an unspecified buffer source.
 *
 * History:	a-jsari		10/9/97		Initial version
 */
class CBufferFolder : public CListViewFolder {
public:
	friend class CBufferV500DataSource;
//	friend class CBufferV410DataSource;

	CBufferFolder(CDataSource *pDataSource, CFolder *pParent = NULL);
	virtual ~CBufferFolder();

	CDataSource::SourceType		GetType() const { return CDataSource::BUFFER; }

	//		Currently there are no dynamic buffer nodes.
	BOOL			HasDynamicChildren() const	{ return FALSE; }
	BOOL			IsDynamic()	const			{ return FALSE; }
	BOOL			GetName(CString &szName) const;
	BOOL			Refresh(BOOL fRecursive = FALSE)	{ return TRUE; }

	BOOL			GetSubElement(unsigned nRow, unsigned nCol, CString &szName) const;
	unsigned		GetColumns() const;
	unsigned		GetRows() const;
	DataComplexity	GetColumnComplexity(unsigned iColumn);
	DataComplexity	GetRowComplexity(unsigned iRow);
	int				GetColumnTextAndWidth(unsigned iColumn, CString &szText, unsigned &uColWidth) const;
	BOOL			GetSortType(unsigned iColumn, MSIColumnSortType &stColumn) const;
	DWORD			GetSortIndex(unsigned iRow, unsigned iColumn) const;

private:
	CBufferDataSource	*GetDataSource()
		{ return dynamic_cast<CBufferDataSource *>(m_pDataSource); }
	void		SetName(CString szName);
	void		SetSubElement(DWORD nRow, DWORD nColumn, CString szName);
	void		SetColumns(unsigned cColumns);
	void		SetRows(unsigned cRows);
	unsigned	BasicColumn(unsigned iColumn) const;
	unsigned	BasicRow(unsigned iRow) const;

private:
	unsigned		m_cRows;
	unsigned		m_cColumns;
	CString			m_szName;
	CStringValues	m_szColumns;

	CBufferSortData							m_SortData;
	CArray <unsigned, unsigned &>			m_uWidths;
	CArray <CStringValues, CStringValues &>	m_szElements;
	CArray <DataComplexity, DataComplexity &>	m_dcColumns;
	CArray <DataComplexity, DataComplexity &>	m_dcRows;
};

/*
 * COCXFolder - A folder which contains data provided by an OCX.
 *		This is planned expansion, not currently implemented.
 *
 * History:	a-jsari		10/27/97		Initial version
 */

class COCXFolder : public CFolder 
{
public:
	COCXFolder(CDataSource *pDataSource) : CFolder(pDataSource) {}
	COCXFolder(CDataSource * pSource, CLSID clsid, CFolder * pParent, CFolder * pPrevious, DWORD dwView, LPOLESTR lpName) 
		: CFolder(pSource, pParent),
		  m_clsid(clsid),
		  m_dwView(dwView),
		  m_strName(lpName)
	{
		if (pParent && pParent->m_ChildFolder == NULL)
			pParent->m_ChildFolder = this;

		if (pPrevious)
			pPrevious->m_NextFolder = this;
	}
	
	~COCXFolder() {}

	CDataSource::SourceType GetType() const	{ return CDataSource::OCX; }
	CFolder	* GetChildNode() { return m_ChildFolder; };
	CFolder	* GetNextNode() { return m_NextFolder; };
	BOOL	Refresh(IUnknown * pUnknown = NULL);
	BOOL	Refresh(BOOL fRecursive = FALSE) { return (Refresh((IUnknown *)NULL)); };
	BOOL	ReportWrite(CMSInfoFile *pFile) { return FALSE; };
	BOOL	FileSave(CMSInfoFile *pFile) { return FALSE; };
	BOOL	GetName(CString &szName) const { szName = m_strName; return TRUE; };
	BOOL	HasDynamicChildren() const { return FALSE; };
	BOOL	IsDynamic() const { return FALSE; };
	BOOL	GetCLSID(LPOLESTR * ppCLSID) { return (SUCCEEDED(StringFromCLSID(m_clsid, ppCLSID))); };
	BOOL	GetCLSIDString(CString & strCLSID);
	void	SetOCXView(IUnknown * pUnknown, DWORD dwView);
	BOOL	GetDISPID(IDispatch * pDispatch, LPOLESTR szMember, DISPID *pID);

public:
	CLSID	m_clsid;
	DWORD	m_dwView;
	CString m_strName;
	CString m_strCLSID;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\dispatch.h ===
/* Dispatch.h
 *
 * History:	a-jsari		3/18/98		Initial version.
 *
 * Copyright (c) 1998-1999 Microsoft Corporation
 */

#pragma once
#include <atlbase.h>
#include <atlcom.h>
#include "Consts.h"
#include "MSInfo.h"

#ifndef IDS_DESCRIPTION
#include "Resource.h"
#endif

/*
 * CMSInfo - Class implementation of MSInfo's IDispatch interface.
 *
 * History:	a-jsari		3/18/98		Initial version.
 */
class CMSInfo :
	public IDispatchImpl <ISystemInfo, &IID_ISystemInfo, &LIBID_MSINFOSNAPINLib, 1, 0>,
	public CComObjectRoot,
	public CComCoClass <CMSInfo, &CLSID_SystemInfo>
{
public:
DECLARE_REGISTRY(CMSInfo, _T("MSInfo.Application.1"), _T("MSInfo.Application"), IDS_DESCRIPTION, THREADFLAGS_BOTH)

BEGIN_COM_MAP(CMSInfo)
	COM_INTERFACE_ENTRY(ISystemInfo)
END_COM_MAP()

	CMSInfo();
	~CMSInfo();

	STDMETHOD(make_nfo)(BSTR lpszFilename, BSTR lpszComputername);
	STDMETHOD(make_report)(BSTR lpszFilename, BSTR lpszComputername, BSTR lpszCategory);
	STDMETHOD(MakeNFO)(BSTR lpszFilename, BSTR lpszComputername, BSTR lpszCategory);
	STDMETHOD(MakeReport)(BSTR lpszFilename, BSTR lpszComputername, BSTR lpszCategory);
	STDMETHOD(QueryCategories)(BSTR lpszCategories);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\domanage.cpp ===
// DOManage.cpp		- The snap-in manager-specific version of
//		CDataObject
//
// Copyright (c) 1998-1999 Microsoft Corporation

#include "StdAfx.h"
#include "DataObj.h"

/*
 * CreateDisplayName - Return the text that displays as the root node
 *		for the snap-in.
 *
 * History:	a-jsari		9/28/97
 *
 * Note: The hGlobal in lpMedium must be freed by the caller.  (See Create for
 *		details).
 */
HRESULT CManagerDataObject::CreateDisplayName(LPSTGMEDIUM lpMedium)
{
	CString strDisplayName;

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	USES_CONVERSION;

	CDataSource		*pDataSource = pSource();
	if (pDataSource == NULL) 
	{
		FORMATETC fmtMachine = {(CLIPFORMAT) CDataObject::m_cfMachineName, NULL, DVASPECT_CONTENT, TYMED_HGLOBAL};
		STGMEDIUM stgMachine;

		stgMachine.tymed = TYMED_HGLOBAL;
		stgMachine.hGlobal = ::GlobalAlloc(GMEM_MOVEABLE, (MAX_PATH + 1)* sizeof(WCHAR));
		stgMachine.pUnkForRelease = NULL;

		HRESULT hr = GetDataHere(&fmtMachine, &stgMachine);
		
		if (hr == S_OK) 
		{
			CString strMachine = W2T((LPWSTR)::GlobalLock(stgMachine.hGlobal));
			::GlobalUnlock(stgMachine.hGlobal);
			HGLOBAL hGlobal = ::GlobalFree(stgMachine.hGlobal);
			ASSERT(hGlobal == NULL);

			if (strMachine.Left(2) != CString(_T("\\\\")))
				strMachine = CString(_T("\\\\")) + strMachine;
			strDisplayName.Format(IDS_NODENAME, strMachine);
		}
		else
			strDisplayName.LoadString(IDS_DESCRIPTION);
	} 
	else 
	{
		VERIFY(pSource()->GetNodeName(strDisplayName));
	}

	return Create(reinterpret_cast<const void *>(WSTR_FROM_CSTRING(strDisplayName)),
			((strDisplayName.GetLength() + 1) * sizeof(WCHAR)), lpMedium);
}

/*
 * CreateNodeTypeData - Return the NodeType for the root node in lpMedium's
 *		hGlobal pointer.
 *
 * History:	a-jsari		9/28/97		Initial version
 *
 * Note: The hGlobal in lpMedium must be freed by the caller.  (See Create for
 *		details).
 */
HRESULT CManagerDataObject::CreateNodeTypeData(LPSTGMEDIUM pMedium)
{
	//	Create the node type object in GUID format
	return Create(reinterpret_cast<const void *>(&cNodeTypeStatic), sizeof(GUID), pMedium);
}

/*
 * CreateNodeTypeStringData - Return the root node's NodeType in string form 
 *		in lpMedium's hGlobal pointer
 *
 * History:	a-jsari		9/28/97		Initial version
 *
 * Note: The hGlobal in lpMedium must be freed by the caller.  (See Create for
 *		details).
 */
HRESULT CManagerDataObject::CreateNodeTypeStringData(LPSTGMEDIUM pMedium)
{
	USES_CONVERSION;
	return Create(WSTR_FROM_CSTRING(cszNodeTypeStatic),
			((_tcslen(cszNodeTypeStatic) + 1) * sizeof(WCHAR)), pMedium);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\dialogs.cpp ===
//	Dialogs.cpp - Create all of our dialogs to get data from the user.
//
//  Copyright (c) 1998-1999 Microsoft Corporation

#include <afxdlgs.h>
#include <afxwin.h>
#include <shlobj.h>
#include "StdAfx.h"
#include "Dialogs.h"
#include "DataObj.h"
#include "CompData.h"
#include "Resource.h"
#include "resrc1.h"

//	These are the lists of file type for the Save/Open Common Control Dialogs.
CString strMSInfoSaveFileTypes;
CString strMSInfoOpenFileTypes;
CString strMSInfoReportTypes;

//	These are the default file types
CString strMSInfoSaveType;
CString strMSInfoReportType;

// This is to implement a change to load the strings for file types, etc.,
// from resources. This is called by the app init.

void LoadDialogResources()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	strMSInfoSaveFileTypes.LoadString(IDS_SAVE_FILE_TYPES);
	strMSInfoOpenFileTypes.LoadString(IDS_OPEN_FILE_TYPES);
	strMSInfoReportTypes.LoadString(IDS_REPORT_TYPES);
	strMSInfoSaveType.LoadString(IDS_SAVE_TYPE);
	strMSInfoReportType.LoadString(IDS_REPORT_TYPE);
}

//	The custom message number we use to
UINT CFindDialog::WM_MSINFO_FIND = WM_USER + 0x119;

// static data members must be initialized at file scope
TCHAR CMSInfoFileDialog::m_szCurrentDirectory[MAX_PATH] = _T("My Documents");

/*
 * GetPathFromIDList - Copy the path from the iilFolder to szPathBuffer.
 *
 * History:	a-jsari		10/31/97		Initial version
 */
inline void GetBasePath(HWND hOwner, LPTSTR szPathBuffer)
{
	LPITEMIDLIST	iilFolder;
	HRESULT			hResult;

	hResult = SHGetSpecialFolderLocation(hOwner, CSIDL_PERSONAL, &iilFolder);
	ASSERT(hResult == NOERROR);

	VERIFY(SHGetPathFromIDList(iilFolder, szPathBuffer));
}

/*
 * CMSInfoFileDialog - Brings up the CFileDialog window, with a few of our
 *		own specifications.
 *
 * History:	a-jsari		10/24/97		Initial version
 */
CMSInfoFileDialog::CMSInfoFileDialog(
		BOOL		bDialogIsOpen,
		HWND		hOwner,
		LPCTSTR		lpszDefaultExtension,
		LPCTSTR		lpszExtensionFilters)
:CFileDialog(bDialogIsOpen,			//	Open dialog or Save dialog?
			 lpszDefaultExtension,	//	Default file extension
			 NULL,					//	File name (don't specify)
			 OFN_EXPLORER,			//	OPN	Flags
			 lpszExtensionFilters)	//	Filetype filter string.
{
	m_ofn.hwndOwner = hOwner;
	m_ofn.nFilterIndex = 0;

	// default to "My Documents"
	GetBasePath(hOwner, m_szCurrentDirectory);
	m_ofn.lpstrInitialDir = m_szCurrentDirectory;
}

/*
 * we override DoModal so we can keep track of where the file was last opened from
 *
 *
 */
INT_PTR CMSInfoFileDialog::DoModal()
{
	INT_PTR	iRC;

	m_ofn.lpstrInitialDir =  m_szCurrentDirectory;
	iRC = CFileDialog::DoModal();

	// remember path user browsed to
	TCHAR	szDir[MAX_PATH];
	TCHAR	szDrive[10];
	int		iLen;

	_tsplitpath(GetPathName(), szDrive, szDir, NULL, NULL);
	_tmakepath( m_szCurrentDirectory, szDrive, szDir, NULL, NULL);
	iLen = _tcslen( CMSInfoFileDialog::m_szCurrentDirectory);
	if ( m_szCurrentDirectory[iLen-1] == '\\' )
		 m_szCurrentDirectory[iLen-1] = 0;

	return iRC;
}

/*
 * CMSInfoReportDialog - Apply settings specific to the report dialog
 *
 * History:	a-jsari		10/24/97		Initial version
 */
CMSInfoReportDialog::CMSInfoReportDialog(HWND hOwner)
:CMSInfoSaveDialog(hOwner, strMSInfoReportType, strMSInfoReportTypes)
{
	m_ofn.Flags |= OFN_OVERWRITEPROMPT | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY;
}

/*
 * CMSInfoSaveDialog - Apply settings specific to the save dialog
 *
 * History:	a-jsari		10/24/97		Initial version
 */
CMSInfoSaveDialog::CMSInfoSaveDialog(HWND hOwner, LPCTSTR lpszDefaultExtension,
		LPCTSTR lpszExtensionFilters)
:CMSInfoFileDialog(FALSE, hOwner, lpszDefaultExtension, lpszExtensionFilters)
{
	m_ofn.Flags |= OFN_OVERWRITEPROMPT | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY;
}

/*
 * CMSInfoOpenDialog - Apply settings specific to the open dialog.
 *
 * History:	a-jsari		10/24/97		Initial version
 */
CMSInfoOpenDialog::CMSInfoOpenDialog(HWND hOwner)
:CMSInfoFileDialog(TRUE, hOwner, strMSInfoSaveType, strMSInfoOpenFileTypes)
{
	m_ofn.Flags |= OFN_FILEMUSTEXIST | OFN_HIDEREADONLY;
}

/*
 * CMSInfoPrintDialog - Create the Print dialog
 *
 * History:	a-jsari		12/8/97		Initial version
 */
CMSInfoPrintDialog::CMSInfoPrintDialog(HWND hOwner)
:CPrintDialog(FALSE, PD_SELECTION | PD_USEDEVMODECOPIES | PD_HIDEPRINTTOFILE)
{
	m_pd.hwndOwner = hOwner;
}

/////////////////////////////////////////////////////////////////////////////
// CFindDialog dialog

/*
 * CFindDialog - Create the modal find dialog (which we will run in its own
 *		thread, to make it appear modeless.
 *
 * History:	a-jsari		11/28/97		Initial version.
 */
CFindDialog::CFindDialog(CSystemInfoScope *pScope, HWND hPostWindow, HWND hwndMMCWindow)
:CDialog(IDD, NULL),
 m_pScope(pScope),
 m_hPostWindow(hPostWindow),
 m_hMMCWindow(hwndMMCWindow),
 m_strSearch(_T("")),
 m_fRunning(FALSE)
{
}

/*
 * ~CFindDialog - Destroy the find dialog.
 *
 * History:	a-jsari		11/28/97		Initial version.
 */
CFindDialog::~CFindDialog()
{
	OnCancel();

	if (m_iTimer)
	{
		KillTimer(m_iTimer);
		m_iTimer = 0;
	}
}

/*
 * Create - Creates the dialog box.
 *
 * History:	a-jsari		1/21/98		Initial version.
 */
BOOL CFindDialog::Create()
{
	DoModal();
	return FALSE;
}

/*
 * SetFocus - Set focus to our Search window.
 *
 * History:	a-jsari		12/17/97		Initial version
 */
CWnd *CFindDialog::SetFocus()
{
	CWnd	*pwFind;

	pwFind = GetDlgItem(IDC_SEARCHTERM);
	ASSERT(pwFind != NULL);
	return pwFind->SetFocus();
}

/*
 * OnInitDialog - ClassWizard generated function
 *
 * History:	a-jsari		12/2/97
 */
BOOL CFindDialog::OnInitDialog()
{
	CDialog::OnInitDialog();
	::SetWindowPos(GetSafeHwnd(), m_hPostWindow, 0, 0, 0, 0, SWP_NOSIZE|SWP_NOMOVE);

	m_iTimer = SetTimer(1, 150, NULL);

	return TRUE;// return TRUE unless you set the focus to a control
				// EXCEPTION: OCX Property Pages should return FALSE
}


BEGIN_MESSAGE_MAP(CFindDialog, CDialog)
	//{{AFX_MSG_MAP(CFindDialog)
	ON_EN_CHANGE(IDC_SEARCHTERM, OnSearchTerm)
	ON_COMMAND(IDC_FINDNEXT, OnFindNext)
	ON_COMMAND(IDC_STOPFIND, OnStopFind)
	ON_COMMAND(IDC_NEWSEARCH, OnNewSearch)
	ON_WM_ACTIVATE()
	ON_WM_HELPINFO()
	ON_WM_TIMER() 
	ON_MESSAGE(WM_HELP, OnHelp)
	ON_MESSAGE(WM_CONTEXTMENU, OnContextMenu)
	ON_WM_SETCURSOR()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFindDialog message handlers

/*
 * OnActivate - Set our window position when we activate.
 *
 * History:	a-jsari		3/4/98		Initial version
 */
afx_msg void CFindDialog::OnActivate(UINT, CWnd *, BOOL bMinimized)
{
	//	If we aren't minimized

	if (bMinimized == FALSE) 
	{
		// Don't do this - it makes us stay on top of ALL the windows...
		//
		// SetWindowPos(&wndTopMost, 0, 0, 0, 0, SWP_NOACTIVATE|SWP_NOMOVE|SWP_NOSIZE);
	}
}

//-----------------------------------------------------------------------------
// Catch the WM_HELPINFO message, so we can show context sensitive help on
// the controls in the dialog box.
//-----------------------------------------------------------------------------

#include <afxpriv.h>

static DWORD helparray[] =
{
	IDC_SEARCHTERM,		1000001,
	IDC_FINDIN,			1000002,
	IDC_CATEGORYCHECK,	1000003,
	IDC_FINDNEXT,		1000004,
	IDC_STOPFIND,		1000005,
	IDC_NEWSEARCH,		1000006,
	IDCANCEL,			1000007,
	0, 0
};

afx_msg BOOL CFindDialog::OnHelpInfo(HELPINFO * pHelpInfo)
{
	if (pHelpInfo && (pHelpInfo->iContextType == HELPINFO_WINDOW))
		::WinHelp((HWND)pHelpInfo->hItemHandle, TEXT("msinfo32.hlp"), HELP_WM_HELP, (DWORD_PTR)helparray);

	return TRUE;
}

//-----------------------------------------------------------------------------
// Every time we get a timer message, check to see if the find window is
// behind the MMC window. If it is, bring it forward. What we really want
// is an application always on top effect, but this seems to be the way to
// get this (since we can't change MMC).
//
// I hate this.
//-----------------------------------------------------------------------------

afx_msg void CFindDialog::OnTimer(UINT)
{
	if (m_hMMCWindow == NULL)
		return;

	for (HWND hwndWalk = GetSafeHwnd(); hwndWalk != NULL; hwndWalk = ::GetNextWindow(hwndWalk, GW_HWNDPREV))
		if (hwndWalk == m_hMMCWindow)
		{
			// This is how we bring the find window to the top. Using wndTop with
			// SetWindowPos doesn't seem to do anything.

			SetWindowPos(&wndTopMost, 0, 0, 0, 0, SWP_NOACTIVATE|SWP_NOMOVE|SWP_NOSIZE);
			SetWindowPos(&wndNoTopMost, 0, 0, 0, 0, SWP_NOACTIVATE|SWP_NOMOVE|SWP_NOSIZE);
			break;
		}
}

LONG CFindDialog::OnHelp(WPARAM wParam, LPARAM lParam)
{
	LONG lResult = 0;
	if (lParam)
		::WinHelp((HWND)(((LPHELPINFO)lParam)->hItemHandle), TEXT("msinfo32.hlp"), HELP_WM_HELP, (DWORD_PTR)helparray);
	return lResult;
}

LONG CFindDialog::OnContextMenu(WPARAM wParam, LPARAM lParam)
{
	LONG lResult = 0;
	::WinHelp((HWND)wParam, TEXT("msinfo32.hlp"), HELP_CONTEXTMENU,(DWORD_PTR)helparray);
	return lResult;
}

/*
 * OnSetCursor - Set our cursor depending on whether we are executing the find.
 *
 * History:	a-jsari		3/21/98		Initial version
 */
afx_msg BOOL CFindDialog::OnSetCursor(CWnd *pWndOther, UINT nHitTest, UINT message)
{
	static HCURSOR hcPointerHourglass = NULL;

	//	Set the pointer & hourglass cursor.
	if (m_fRunning) {
		if (hcPointerHourglass == NULL) {
			hcPointerHourglass = ::LoadCursor(NULL, IDC_APPSTARTING);
#ifdef DEBUG
			DWORD dwError = ::GetLastError();
#endif
			ASSERT(hcPointerHourglass != NULL);
		}
		::SetCursor(hcPointerHourglass);
		return TRUE;
	} else return CDialog::OnSetCursor(pWndOther, nHitTest, message);
}

/*
 * OnCancel - Destroy the window when the cancel button is selected.
 *
 * History:	a-jsari		12/2/97
 */
afx_msg void CFindDialog::OnCancel()
{
	OnStopFind();
	::PostQuitMessage(0);
	//	Exit the containing UI thread.
	m_pScope->CloseFindWindow();
}

/*
 * OnFindNext - Execute the find next operation, when the "Find Next" button
 *		is clicked or when a return is hit in the "Find In".
 *
 * History:	a-jsari		12/11/97
 */
afx_msg void CFindDialog::OnFindNext()
{
	int		wCount;
	long	lFindState;	

	//	Save our last search.
	CString	strLast = m_strSearch;

	AFX_MANAGE_STATE(::AfxGetStaticModuleState());

	//	Save our current search
	wCount = GetDlgItemText(IDC_SEARCHTERM, m_strSearch);
	ASSERT(wCount != 0);

	//	Enable the Stop button (Disabled in FindComplete).
	CButton *pwStop = reinterpret_cast<CButton *>(GetDlgItem(IDC_STOPFIND));
	ASSERT(pwStop != NULL);
	pwStop->EnableWindow(TRUE);

	//	Disable our button so we can't activate it while we're running.
	//	(Enabled in FindComplete)
	CButton *pwFindNext = reinterpret_cast<CButton *>(GetDlgItem(IDC_FINDNEXT));
	ASSERT(pwFindNext != NULL);
	pwFindNext->EnableWindow(FALSE);

	//	Set the flag indicating whether we search only category names.
	CButton *pwCheck = reinterpret_cast<CButton *>(GetDlgItem(IDC_CATEGORYCHECK));
	ASSERT(pwCheck != NULL);
	lFindState = pwCheck->GetCheck() ? CDataSource::FIND_OPTION_CATEGORY_ONLY : 0;

	//	Set the flag indicating whether we search the selected category alone.
	pwCheck = reinterpret_cast<CButton *>(GetDlgItem(IDC_FINDIN));
	ASSERT(pwCheck != NULL);
	lFindState |= (pwCheck->GetCheck()) ? CDataSource::FIND_OPTION_ONE_CATEGORY : 0;

	//	Set the flag indicating whether we are repeating a previous search.
	if (::_tcsicmp((LPCTSTR)strLast, (LPCTSTR)m_strSearch) == 0)
		lFindState |= CDataSource::FIND_OPTION_REPEAT_SEARCH;

	m_fRunning = TRUE;
	//	In order to perform the find multi-threaded and allow a stop operation,
	//	we post a custom message to a hidden window attached to the main MMC window
	//	created in CSystemInfoScope::Initialize
	//	Our custom WindowProc processes this message, running Find in the main
	//	window's UI thread.
	::PostMessage(m_hPostWindow, WM_MSINFO_FIND, (WPARAM)m_pScope, (LPARAM) lFindState);
}

/*
 * OnNewSearch - Clear the controls
 *
 * History:	a-jsari		12/11/97
 */
afx_msg void CFindDialog::OnNewSearch()
{
	ResetSearch();
	//	Clear the text box.
	SetDlgItemText(IDC_SEARCHTERM, _T(""));
	//	Clear the category check box.
	CButton *pwCheck = (CButton *) GetDlgItem(IDC_CATEGORYCHECK);
	ASSERT(pwCheck != NULL);
	pwCheck->SetCheck(0);
	//	Clear the Restrict Search check box
	pwCheck = (CButton *) GetDlgItem(IDC_FINDIN);
	ASSERT(pwCheck != NULL);
	pwCheck->SetCheck(0);
	//	Refocus on the text box.
	SetFocus();
}

/*
 * OnSearchTerm - Callback for when the Search edit box is changed.
 *
 * History:	a-jsari		12/11/97		Initial version.
 */
afx_msg void CFindDialog::OnSearchTerm()
{
	CString		strSearch;
	CWnd		*wControl;
	int			wSearch;

	//	Get the length of the text box text.
	wSearch = GetDlgItemText(IDC_SEARCHTERM, strSearch);
	wControl = GetDlgItem(IDC_FINDNEXT);
	wControl->EnableWindow(wSearch > 0);
	wControl = GetDlgItem(IDC_SEARCHTERM);
	wControl->SetFocus();
}

/*
 * OnStopFind - MULTI-THREADED Callback for the "Stop Find" button, intended
 *		to be called while the find is running in the main window thread.
 *
 * History:	a-jsari		1/19/98		Initial version
 */
afx_msg void CFindDialog::OnStopFind()
{
	//	This will abort the find operation in the main thread which will
	//	then call FindComplete.
	m_pScope->StopFind();
}

/*
 * FindComplete - Reset the find dialog upon completion, either by abort or
 *		by normal completion.
 *
 * History:	a-jsari		2/4/98		Initial version.
 */
void CFindDialog::FindComplete()
{
	AFX_MANAGE_STATE(::AfxGetStaticModuleState());

	m_fRunning = FALSE;

	//	Enable our Find Button
	CButton *pwFindNext = reinterpret_cast<CButton *>(GetDlgItem(IDC_FINDNEXT));
	ASSERT(pwFindNext != NULL);
	CString	strSearch;
	int		wSearch = GetDlgItemText(IDC_SEARCHTERM, strSearch);
	pwFindNext->EnableWindow(wSearch > 0);

	//	Disable the Stop Button
	CButton *pwStop = reinterpret_cast<CButton *>(GetDlgItem(IDC_STOPFIND));
	ASSERT(pwStop != NULL);
	pwStop->EnableWindow(FALSE);
	OnActivate(0, NULL, FALSE);
}

/*
 * ResetSearch - Resets the search so that the next search will register as
 *		new.
 *
 * History:	a-jsari		2/20/98		Initial version.
 */
void CFindDialog::ResetSearch()
{
	m_strSearch = _T("");
}

IMPLEMENT_DYNCREATE(CFindThread, CWinThread)

/*
 * CFindThread - Default constructor
 *
 * History:	a-jsari		1/19/98		Initial version.
 */
CFindThread::CFindThread()
:m_pdlgFind(NULL), m_pScope(NULL), m_pDataSource(NULL)
{
}

/*
 * ~CFindThread - Our destructor.
 *
 * History:	a-jsari		1/19/98		Initial version.
 */
CFindThread::~CFindThread()
{
}

/*
 * SetScope - Sets the scope item for the Find Dialog.
 *
 * History:	a-jsari		1/21/98		Initial version.
 */
void CFindThread::SetScope(CSystemInfoScope *pScope)
{
	ASSERT(pScope != NULL);
	m_pScope = pScope;
}

/*
 * SetParent - Sets the parent window for the Find Dialog.
 *
 * History:	a-jsari		1/21/98		Initial version.
 */
void CFindThread::SetParent(HWND hParent, HWND hMMC)
{
	m_hParentWindow = hParent;
	m_hMMCWindow = hMMC;
}

/*
 * Activate - Reactivate the thread after it's been deselected.
 *
 * History:	a-jsari		1/22/98		Initial version.
 */
void CFindThread::Activate()
{
	ASSERT(m_pdlgFind != NULL);
	m_pdlgFind->OnActivate(0, NULL, FALSE);
}

/*
 * InitInstance - Starts the thread and the dialog object.
 *
 * History:	a-jsari		1/19/98		Initial version
 */
BOOL CFindThread::InitInstance()
{
	//	else increment some instance pointer?
	//	Create our new Modal find dialog.
	m_pdlgFind = new CFindDialog(m_pScope, m_hParentWindow, m_hMMCWindow);
	ASSERT(m_pdlgFind != NULL);
	if (m_pdlgFind == NULL) ::AfxThrowMemoryException();
	m_pdlgFind->Create();
	//	We won't get here until our dialog is exiting, since create calls
	//	DoModal(), which blocks.
	return TRUE;
}

/*
 * ExitInstance - Ends the thread, destroying the dialog object.
 *
 * History:	a-jsari		1/19/98		Inital version
 */
int CFindThread::ExitInstance()
{
	delete m_pdlgFind;
	m_pdlgFind = NULL;
	return CWinThread::ExitInstance();
}

/*
 * RemoteQuit - Ends the thread from an alternate thread, by sending the appropriate
 *		message to our dialog, waiting for its exit.
 *
 * History:	a-jsari		1/29/98		Initial version
 */
void CFindThread::RemoteQuit()
{
	const DWORD	dwWaitTimeout = 100000;	//	100 ms, Presumably long enough.
	DWORD		dwResult;

	m_pdlgFind->SendMessage(WM_COMMAND, IDCANCEL);
	//	Wait for the thread to exit, avoiding its using an object destroyed
	//	by our main thread in CSystemInfoScope.
	dwResult = ::WaitForSingleObject(m_hThread, dwWaitTimeout);
	ASSERT(dwResult == WAIT_OBJECT_0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\datasrc.cpp ===
//	DataSrc.cpp	- Implementation of DataSource and Folder shared base methods.
//
//  Copyright (c) 1998-1999 Microsoft Corporation

#include <afx.h>
#include "StdAfx.h"
#include "DataSrc.h"
#include "Resource.h"
#include "resrc1.h"
#include "FileIO.h"
#include "msicab.h"

LPCTSTR cszRootName = _T("");

/*
 * CDataSource - Default data source constructor.
 *
 * History:	a-jsari		10/15/97		Initial version
 */
CDataSource::CDataSource(LPCTSTR szMachineName)
:m_RootFolder(NULL),
 m_pPrintContent(NULL),
 m_pDC(NULL),
 m_pPrintInfo(NULL),
 m_pprinterFont(NULL),
 m_strPath(_T("")),
 m_iLine(0),
 m_fCanceled(FALSE),
 m_strHeaderLeft(szMachineName),
 m_pfLast(NULL)
{
}

/*
 * ~CDataSource - Default data source destructor.
 *
 * History:	a-jsari		10/15/97		Initial version.
 */
CDataSource::~CDataSource()
{
	delete m_RootFolder;
	delete m_pPrintContent;
	delete m_pDC;
	delete m_pprinterFont;
#pragma warning(disable:4150)
	//	C++ warns us that no destructor is called for m_pPrintInfo.
	//	This is intended behavior
	delete m_pPrintInfo;
#pragma warning(default:4150)
}

/*
 * GetNodeName - Return the default node name (if not overridden in subclasses.
 *
 * History:	a-jsari		1/16/98		Initial version.
 */
BOOL CDataSource::GetNodeName(CString &strNode)
{
	AFX_MANAGE_STATE(::AfxGetStaticModuleState());
	VERIFY(strNode.LoadString(IDS_EXTENSIONNODENAME));
	return TRUE;
}

/*
 * SetDataComplexity - Set the global complexity of this source.
 *
 * History:	a-jsari		12/22/97		Initial version.
 */
BOOL CDataSource::SetDataComplexity(enum DataComplexity Complexity)
{
	m_Complexity = Complexity;
	return TRUE;
}

/*
 * ResultFromFileException - Return the HRESULT which corresponds to the
 *
 * History:	a-jsari		3/26/98		Initial version.
 */
static inline HRESULT ResultFromFileException(CFileException *e)
{
	HRESULT	hrReturn;

	switch (e->m_cause) {
	case CFileException::badPath:
		hrReturn = STG_E_PATHNOTFOUND;
		break;
	case CFileException::accessDenied:
		hrReturn = STG_E_ACCESSDENIED;
		break;
	case CFileException::tooManyOpenFiles:
		hrReturn = STG_E_TOOMANYOPENFILES;
		break;
	case CFileException::sharingViolation:
		hrReturn = STG_E_SHAREVIOLATION;
		break;
	case CFileException::hardIO:
		hrReturn = STG_E_WRITEFAULT;
		break;
	case CFileException::directoryFull:
	case CFileException::diskFull:
		hrReturn = STG_E_MEDIUMFULL;
		break;
	default:
		//	Return the default error code.
		hrReturn = E_UNEXPECTED;
		break;
	}
	return hrReturn;
}

/*
 * SaveFile - Save, starting from the root passed in, as a binary file.
 *
 * History:	a-jsari		10/21/97		Initial version
 */
HRESULT CDataSource::SaveFile(LPCTSTR cszFilename, CFolder *pSaveRoot)
{
	HRESULT hrReturn;

	if (cszFilename == NULL) return E_INVALIDARG;
	try {
		CMSInfoFile		msfSave(cszFilename);

		hrReturn = WriteOutput(&msfSave, pSaveRoot);
	}
	catch (CFileException *e) {
		//	Remove the incomplete file.
		if (::_taccess(cszFilename, A_EXIST) == 0) {
			(void)_tunlink(cszFilename);
		}
		hrReturn = ::ResultFromFileException(e);
	}
	return hrReturn;
}

/*
 * ReportWrite - Create a text file and write output to it.  (Automatically
 *		writes data in the text file [report] format.)
 *
 * History:	a-jsari		10/21/97		Initial version
 */
HRESULT CDataSource::ReportWrite(LPCTSTR cszFilename, CFolder *pSaveRoot)
{
	HRESULT				hrReturn;

	if (cszFilename == NULL)
		return E_INVALIDARG;

	try
	{
		CMSInfoTextFile msfSave( cszFilename);

		hrReturn = WriteOutput(&msfSave, pSaveRoot);
	}
	catch (CFileException *e)
	{
		// Remove the incomplete file.
		if (::_taccess(cszFilename, A_EXIST) == 0)
			(void)_tunlink(cszFilename);

		hrReturn = ::ResultFromFileException(e);
	}

	return hrReturn;
}

/*
 * WriteOutput - Traverse a sub-tree of our internal storage, saving
 *		each node, ending when we return to the original CFolder.  If
 *		our parameter is NULL, start from the root (write the entire
 *		tree).
 *
 * Note: This function calls FileSave, which writes text data automatically
 *		when the CMSInfoFile passed in is a text file and binary data when
 *		it is a binary file.
 *
 * History:	a-jsari		11/5/97		Initial version
 */
HRESULT CDataSource::WriteOutput(CMSInfoFile * pFile, CFolder * pRootNode)
{
	CFolder				*pFolder;
	CFolder				*pNext;
	enum DataComplexity	Complexity;
	HRESULT				hrReturn = S_OK;

	ASSERT(pFile != NULL);
	try {
		// When we save, always save the advanced information. Note, even if the
		// complexity is currently ADVANCED, we should make the call to SetDataComplexity.
		// If WriteOutput is being called because of a COM call to MSInfo (e.g. when
		// WinRep creates an NFO using MSInfo without launching MSInfo), the data
		// gatherer object might not have had a complexity set yet.

		Complexity = m_Complexity;
		m_Complexity = ADVANCED;
		SetDataComplexity(m_Complexity);
		
		if (pRootNode)
			VERIFY(pRootNode->Refresh(TRUE));
		else
			VERIFY(Refresh());		//	Ensure that we have the most current data.

		pFile->WriteHeader(this);

		if (pRootNode == NULL)
			pFolder = GetRootNode();
		else
			pFolder = pRootNode;
		ASSERT(pFolder != NULL);

		//	Traverse the tree structure, writing the nodes in order.
		do {
			//	Write the data for each folder as it is encountered.
			pFolder->FileSave(pFile);

			//	Depth-first: If we have a child, traverse it next.
			pNext = pFolder->GetChildNode();
			if (pNext != NULL) {
				pFile->WriteChildMark();
				pFolder = pNext;
				continue;
			}

			//	If we are at our root folder, don't traverse to the next node..
			if (pFolder == pRootNode) break;

			//	If we have reached the bottom of our list, traverse
			//	our siblings.
			pNext = pFolder->GetNextNode();
			if (pNext != NULL) {
				pFile->WriteNextMark();
				pFolder = pNext;
				continue;
			}

			//	If we have no more siblings, find our nearest parent's
			//	sibling, traversing upwards until we find the node we
			//	started with.
			pNext = pFolder->GetParentNode();
			ASSERT(pNext != NULL);
			unsigned	uParentCount = 0;
			while (pNext != pRootNode) {
				++uParentCount;
				pFolder = pNext->GetNextNode();
				//	Our Parent has a sibling, continue with it.
				if (pFolder != NULL) {
					pFile->WriteParentMark(uParentCount);
					break;
				}
				//	No siblings; check the next parent..
				pNext = pNext->GetParentNode();
			}
			//	If we've returned to our root node, we're done.
			if (pNext == pRootNode) break;
		} while (pFolder);
		pFile->WriteEndMark();
	}
	catch (CFileException *e) {
		if (Complexity == BASIC)
			SetDataComplexity(Complexity);
		throw e;
	}
	catch (...) {
		ASSERT(FALSE);
		hrReturn = E_UNEXPECTED;
	}

	// Restore the original complexity.

	if (Complexity != m_Complexity)
	{
		m_Complexity = Complexity;
		SetDataComplexity(m_Complexity);
	}

	return hrReturn;
}

/*
 * CreateFromIStream - Return the appropriate CDataSource pointer the exists
 *		on the IStream.
 *
 * History:	a-jsari		11/13/97		Initial version
 */
CDataSource *CDataSource::CreateFromIStream(IStream *pStm)
{
	unsigned	wType;
	unsigned	wLength;
	ULONG		dwSize;
	HRESULT		hResult;
	CDataSource	*pSource = NULL;
	WCHAR		szBuffer[MAX_PATH];
	LPWSTR		pszBuffer;

	ASSERT(pStm != NULL);
	ASSERT(!IsBadReadPtr(pStm, sizeof(IStream)));
	if (pStm == NULL || IsBadReadPtr(pStm, sizeof(IStream)))
		return NULL;
	do {
		hResult = pStm->Read(&wType, sizeof(wType), &dwSize);
		ASSERT(SUCCEEDED(hResult));
		ASSERT(dwSize == sizeof(wType));
		if (FAILED(hResult) || dwSize != sizeof(wType))
			break;
		hResult = pStm->Read(&wLength, sizeof(wLength), &dwSize);
		ASSERT(SUCCEEDED(hResult));
		ASSERT(dwSize == sizeof(wLength));
		ASSERT(wLength <= MAX_PATH);
		if (FAILED(hResult) || (dwSize != sizeof(wLength)) || wLength > MAX_PATH)
			break;
		szBuffer[wLength] = (WCHAR)0;
		wLength *= sizeof(WCHAR);
		if (wLength != 0) {
			hResult = pStm->Read(szBuffer, wLength, &dwSize);
			ASSERT(SUCCEEDED(hResult));
			ASSERT(dwSize == wLength);
			if (FAILED(hResult) || dwSize != wLength)
				break;
			pszBuffer = szBuffer;
		} else {
			pszBuffer = NULL;
		}
		switch (wType) {
		case V500FILE:
			try {
				ASSERT(pszBuffer != NULL);
				CMSInfoFile		msiFile(pszBuffer, CFile::modeRead
						| CFile::shareDenyWrite | CFile::typeBinary);
				VERIFY(CBufferV500DataSource::VerifyFileVersion(&msiFile));
				pSource = new CBufferV500DataSource(&msiFile);
			}
			catch (...) {
				if (pSource != NULL)
					delete pSource;
				return NULL;
			}
			break;
		case GATHERER:
			try {
				pSource = new CWBEMDataSource(pszBuffer);
			}
			catch (...) {
				if (pSource != NULL)
					delete pSource;
				return NULL;
			}
			break;
		default:
			ASSERT(FALSE);
			break;
		}
	} while (FALSE);
	return pSource;
}

/*
 * CFolder - Default folder constructor.  Initializes the pointers
 *		to NULL.
 *
 * History:	a-jsari		10/15/97		Initial version
 */
CFolder::CFolder(CDataSource *pDataSource, CFolder *pParentNode)
:m_ChildFolder(NULL), m_NextFolder(NULL), m_ParentFolder(pParentNode),
 m_pDataSource(pDataSource), fChildTested(FALSE), fNextTested(FALSE),
 m_nLine(-1)
{
}

/*
 * ~CFolder - Default folder destructor.  Deletes the saved pointers.
 *
 * History:	a-jsari		10/15/97		Initial version
 */
CFolder::~CFolder()
{
	if (m_ChildFolder)
	{
		delete m_ChildFolder;
		m_ChildFolder = NULL;
	}

	if (m_NextFolder)
	{
		delete m_NextFolder;
		m_NextFolder = NULL;
	}

	//	Don't delete m_ParentFolder, since it won't necessarily go
	//	away when its child Folder goes away (and if it does, it's
	//	already in the process of going away).
}

/*
 * InternalName - Return our internal name, just the amalgam of all parent
 *		internal names and our name.
 *
 * History:	a-jsari		12/12/97		Initial version
 */
void CFolder::InternalName(CString &strName) const
{
	if (m_ParentFolder == NULL) {
		strName = cszRootName;
		return;
	}
	m_ParentFolder->InternalName(strName);
	strName += _T("\\");
	CString	strLocalName;
	GetName(strLocalName);
	strName += strLocalName;
}

/*
 * SaveTitle - Save the folder's title as a string to binary save file pFile
 *
 * History:	a-jsari		10/29/97		Initial version
 */
void CListViewFolder::SaveTitle(CMSInfoFile *pFile)
{
	CString		szName;

	GetName(szName);
	pFile->WriteString(szName);
}

/*
 * SaveElements - Write the list of elements to a binary save file
 *
 * History:	a-jsari		10/29/97		Initial version
 */
void CListViewFolder::SaveElements(CMSInfoFile *pFile)
{
	CString				szWriteString;
	MSIColumnSortType	stColumn;
	unsigned			iCol = GetColumns();
	DataComplexity		dcAdvanced;
	CArray <unsigned, unsigned &>	aColumnValues;

	pFile->WriteUnsignedInt(iCol);
	if (iCol == 0) return;
	while (iCol--) {
		unsigned	uWidth;

		GetColumnTextAndWidth(iCol, szWriteString, uWidth);
		GetSortType(iCol, stColumn);
		dcAdvanced = GetColumnComplexity(iCol);
		if (stColumn == BYVALUE) {
			aColumnValues.Add(iCol);
		}
		pFile->WriteUnsignedInt(uWidth);
		pFile->WriteString(szWriteString);
		pFile->WriteUnsignedInt((unsigned) stColumn);
		pFile->WriteByte((BYTE)dcAdvanced);
	}

	unsigned	cRow		= GetRows();
	int			wNextColumn = -1;
	unsigned	iArray		= 0;
	unsigned	iRow;

	//	Set wNextColumn to the next column which is sorted BYVALUE.
	//	BYVALUE columns require that each row
	if (aColumnValues.GetSize() != 0)
		wNextColumn = aColumnValues[iArray++];
	pFile->WriteUnsignedInt(cRow);
	iCol = GetColumns();
	iRow = cRow;
	while (iRow--) {
		dcAdvanced = GetRowComplexity(iRow);
		pFile->WriteByte((BYTE)dcAdvanced);
	}
	//	Iterate over columns, writing sort indices for BYVALUE columns.

	while (iCol--) {
		iRow = cRow;
		while (iRow--) {
			GetSubElement(iRow, iCol, szWriteString);
			pFile->WriteString(szWriteString);
		}
		if (wNextColumn == (int)iCol) {
			iRow = cRow;
			while (iRow--) {
				pFile->WriteUnsignedLong(GetSortIndex(iRow, iCol));
			}
			if (aColumnValues.GetSize() > (int)iArray)
				wNextColumn = aColumnValues[iArray++];
		}
	}
}

/*
 * FileSave - Save all elements associated with a CListViewFolder.
 *		Automatically writes the correct version of the file, based
 *		on the type of CMSInfoFile passed in.
 *
 * History: a-jsari		10/21/97		Initial version
 */
BOOL CListViewFolder::FileSave(CMSInfoFile *pFile)
{
#if 0
	try {
#endif
		//	If our file is a text file, we must be writing a report file.
		//	Call our report write functions.
		if (pFile->GetType() != CMSInfoFile::BINARY) {
			ReportWriteTitle(pFile);
			ReportWriteElements(pFile);
		} else {
		//	Binary file, write binary data.
			SaveTitle(pFile);
			SaveElements(pFile);
		}
#if 0
	}
	catch (...) {
		return FALSE;
	}
#endif
	return TRUE;
}

/*
 * ReportWriteTitle - Write the title of the folder
 *
 * History:	a-jsari		11/5/97		Initial version
 */
void CListViewFolder::ReportWriteTitle(CMSInfoFile *pFile)
{
	CString		szWriteValue = _T("[");
	CString		szName;

	GetName(szName);
	szWriteValue += szName + _T("]\r\n\r\n");
	pFile->WriteString(szWriteValue);
}

/*
 * ReportWriteElements - Write the Column headers and row and column data.
 *
 * History:	a-jsari		10/29/97		Initial version
 */
void CListViewFolder::ReportWriteElements(CMSInfoFile *pFile)
{
	CString				strWriteString;
	CString				strTab			= _T("\t");
	CString				strNewLine		= _T("\r\n");
	unsigned			cColumns		= GetColumns();
	CString				strTest;
	CString				strReplacement;

	AFX_MANAGE_STATE(::AfxGetStaticModuleState());
	VERIFY(strTest.LoadString(IDS_REPORT_CATEGORY));
	VERIFY(strReplacement.LoadString(IDS_REPORT_REPLACEMENT));
	for (unsigned iCol = 0 ; iCol < cColumns ; ++iCol) {
		unsigned	uWidth;
		GetColumnTextAndWidth(iCol, strWriteString, uWidth);
		//	Replace the category string with a more informative equivalent..
		if (!strTest.Compare(strWriteString))
			strWriteString = strReplacement;
		pFile->WriteString(strWriteString);
		if (iCol < cColumns - 1) {
			pFile->WriteString(strTab);
		}
	}
	pFile->WriteString(strNewLine);

	unsigned	cRows = GetRows();
	for (unsigned iRow = 0 ; iRow < cRows ; ++iRow) {
		for (iCol = 0 ; iCol < cColumns ; ++iCol) {
			GetSubElement(iRow, iCol, strWriteString);
			pFile->WriteString(strWriteString);
			if (iCol < cColumns - 1) {
				pFile->WriteString(strTab);
			}
		}
		pFile->WriteString(strNewLine);
	}
	pFile->WriteString(strNewLine);
}

/*
 * CBufferDataSource - pFileSink is assumed to be a new'd CMSInfoFile
 *		pointer.  (See CMSInfoFile::CreateCBufferDataSource function,
 *		the only constructor of CBufferDataSource.)
 *
 * History:	a-jsari		10/17/97		Initial version
 */
CBufferDataSource::CBufferDataSource(CMSInfoFile *pFileSink)
:m_strUserName(_T("")), m_strMachine(_T("")), m_strCabDirectory(_T("")), CDataSource(_T("LocalMachine"))
{
	if (pFileSink)
		m_strFileName = pFileSink->GetFileName();
}

/*
 * ~CBufferDataSource - Do nothing.
 *
 * History:	a-jsari		10/17/97		Initial version
 */
CBufferDataSource::~CBufferDataSource()
{
}

/*
 * CreateDataSourceFromFile - Based on the magic number and version number,
 *		return a new'd pointer to the appropriate CBufferDataSource.
 *
 * Note: The caller is responsible for deleting the pointer returned by
 *		this function.
 *
 * History:	a-jsari		10/20/97		Initial version
 */

BOOL fCABOpened = FALSE;

CBufferDataSource *CBufferDataSource::CreateDataSourceFromFile(LPCTSTR szFileName)
{
	CBufferDataSource * pSource = NULL;

	// Enclose this in a scope so that the file will close when we've checked it.

	unsigned uMagicNumber;
	{
		try
		{
			CMSInfoFile FileWrapper(szFileName, CFile::modeRead	| CFile::shareDenyWrite | CFile::typeBinary);

			// Check the first int in the file to see if it's the magic number
			// for a version 5 NFO file.

			FileWrapper.ReadUnsignedInt(uMagicNumber);
			if (uMagicNumber == CMSInfoFile::VERSION_500_MAGIC_NUMBER)
			{
				unsigned uVersion;
				FileWrapper.ReadUnsignedInt(uVersion);
				ASSERT(uVersion == 0x500);
				pSource = new CBufferV500DataSource(&FileWrapper);
				return pSource;
			}
		}
		catch (CFileException * e)
		{
			e->ReportError();
			e->Delete();
			return NULL;
		}
		catch (CFileFormatException * e)
		{
			CString strTitle, strError;

			strError.LoadString( IDS_CORRUPTEDFILE);
			strTitle.LoadString(IDS_DESCRIPTION);
			::MessageBox( ::AfxGetMainWnd()->GetSafeHwnd(), strError, strTitle, MB_OK | MB_APPLMODAL);

			return NULL;
		}
		catch (...)
		{
			return NULL;
		}
	}

	// Next, check to see if this is a version 4.10 file. If it is, it
	// will be an OLE compound file with specific streams.

	IStorage *	pStorage;
	DWORD       grfMode = STGM_DIRECT | STGM_READWRITE | STGM_SHARE_EXCLUSIVE;

	HRESULT hr = StgOpenStorage(szFileName, NULL, grfMode, NULL, 0, &pStorage);
	if (SUCCEEDED(hr))
	{
		OLECHAR FAR *	szMSIStream = _T("MSInfo");
		IStream *       pStream;

		if (SUCCEEDED(pStorage->OpenStream(szMSIStream, NULL, grfMode, 0, &pStream)))
		{
			// Things are looking good. This is a compound doc, and it has a
			// stream named MSInfo. Now we have to read the contents of the
			// MSInfo stream.

			pSource = new CBufferV410DataSource(pStorage, pStream);
			pStream->Release();
			pStorage->Release();
			return pSource;
		}
		pStorage->Release();
	}

	// It wasn't a 4.10 or a 5.0 NFO file. Check to see if it's a CAB file.
	//
	// Use of FileWrapper.FileHandle() is not recommended in case we have
	// a subclass of CFile which does not use file handles.  This function
	// always uses standard file-based CFile pointers.
	//
	// There's a problem with using an MFC derived file class. The handle
	// in the class isn't recognized by the CAB code as belonging to a CAB
	// file. We need to open the file using the CRT file routines, and pass
	// that file handle.

	FILE *pfile = _wfopen(szFileName, _T("r"));
	if (pfile != NULL && ::isCabFile(pfile->_file, NULL))
	{
		fclose(pfile);

 		// If our file is a cab file, explode it.

		CString strFile = szFileName;
		CString strCabDirectory;
		CString strDontDelete = _T("");

		USES_CONVERSION;
		::GetCABExplodeDir(strCabDirectory, TRUE, strDontDelete);
		fCABOpened = ::OpenCABFile(strFile, strCabDirectory);

		// Get our NFO file's name.

		if (::FindFileToOpen(strCabDirectory, strFile) != FALSE)
		{
			pSource = CreateDataSourceFromFile(strFile);
			pSource->m_strCabDirectory = strCabDirectory;
			return pSource;
		}
		return NULL;
	}
	else
	{
		// Unidentified format.

		AFX_MANAGE_STATE(::AfxGetStaticModuleState());
		CString strError, strTitle;

		strTitle.LoadString(IDS_DESCRIPTION);
		strError.Format(IDS_UNRECOGNIZED_FILE, szFileName);
		::MessageBox( ::AfxGetMainWnd()->GetSafeHwnd(), strError, strTitle, MB_OK);
		pSource = NULL;
	}
	
	return pSource;
}

/*
 * FileName -
 *
 * History:	a-jsari		11/17/97		Initial version
 */
LPCTSTR CBufferDataSource::FileName()
{
	return m_strFileName;
}

/*
 * CBufferSortData - Construct our sort object
 *
 * History:	a-jsari		12/1/97		Initial version
 */
CBufferSortData::CBufferSortData()
:m_cRows(0), m_cColumns(0)
{
}

/*
 * ~CBufferSortData - Do-nothing destructor
 *
 * History:	a-jsari		12/1/97		Initial version.
 */
CBufferSortData::~CBufferSortData()
{
}

/*
 * SetSortType - Set the sort type for an iColumn
 *
 * History:	a-jsari		12/1/97		Initial version.
 */
BOOL CBufferSortData::SetSortType(unsigned iColumn, unsigned stColumn)
{
	if (stColumn > BYVALUE) return FALSE;
	m_SortTypes[iColumn] = (MSIColumnSortType) stColumn;
	if (stColumn == BYVALUE) {
		m_ValueColumns.Add(iColumn);
	}
	return TRUE;
}

/*
 * GetSortType - Return the sort type for iColumn
 *
 * History:	a-jsari		12/1/97		Initial version
 */
BOOL CBufferSortData::GetSortType(unsigned iColumn, MSIColumnSortType &stColumn) const
{
	stColumn = m_SortTypes[iColumn];
	return TRUE;
}

/*
 * ValueIndexFromColumn - Return the sparse array index corresponding
 *		to the column index passed in.
 *
 * History:	a-jsari		12/1/97		Initial version
 */
int	CBufferSortData::ValueIndexFromColumn(unsigned iColumn) const
{
	int		iType	= (int)m_ValueColumns.GetSize();
	while (iType--) {
		if (m_ValueColumns[iType] == iColumn) break;
	}
	ASSERT(iType >= 0);
	return iType;
}

/*
 * ReadSortValues - Read SortValue values from the pFile for iColumn
 *
 * History:	a-jsari		12/1/97		Initial version
 */
BOOL CBufferSortData::ReadSortValues(CMSInfoFile *pFile, unsigned iColumn)
{
	//	There is only data to be read if the column is sorted by value.
	if (m_SortTypes[iColumn] == BYVALUE) {
		int			iType	= ValueIndexFromColumn(iColumn);
		unsigned	iRow	= m_cRows;
		while (iRow--) {
			pFile->ReadUnsignedLong(m_dwSortIndices[iType][iRow]);
		}
	}
	return TRUE;
}

/*
 * GetSortValue - Return the sort value corresponding with iRow and iColumn
 *
 * History:	a-jsari		12/1/97		Initial version
 */
DWORD CBufferSortData::GetSortValue(unsigned iRow, unsigned iColumn) const
{
	//	No value is necessary if we are not sorting based on Sort Values.
	if (m_SortTypes[iColumn] != BYVALUE) return 0;

	//	Every BYVALUE type should have data.
	int iType = ValueIndexFromColumn(iColumn);
	return m_dwSortIndices[iType][iRow];
}

/*
 * SetColumns - Set the number of columns of data we are sorting over.
 *
 * History:	a-jsari		12/1/97		Initial version.
 */
BOOL CBufferSortData::SetColumns(unsigned cColumns)
{
	m_SortTypes.SetSize(cColumns);
	m_cColumns = cColumns;
	return TRUE;
}

/*
 * SetRows - Set the number of rows we are sorting over.
 *
 * History:	a-jsari		12/1/97		Initial version.
 */
BOOL CBufferSortData::SetRows(unsigned cRows)
{
	m_cRows = cRows;

	unsigned	iColumn = (unsigned)m_ValueColumns.GetSize();
	m_dwSortIndices.SetSize(iColumn);
	while (iColumn--) {
		m_dwSortIndices[iColumn].SetSize(cRows);
	}
	return TRUE;
}

/*
 * CBufferFolder - Trivial constructor
 *
 * History:	a-jsari		10/17/97		Initial version
 */
CBufferFolder::CBufferFolder(CDataSource *pDataSource, CFolder *pParent)
:CListViewFolder(pDataSource, pParent), m_cRows(0), m_cColumns(0)
{
}

/*
 * ~CBufferFolder - Do-nothing destructor.
 *
 * History:	a-jsari		10/17/97		Initial version
 */
CBufferFolder::~CBufferFolder()
{
}

/*
 * GetColumnTextAndWidth - Return formatting information for the wCol'th column.
 *
 * History:	a-jsari		10/17/97		Initial version
 */
BOOL CBufferFolder::GetColumnTextAndWidth(unsigned wCol, CString &szName, unsigned &wWidth) const
{
	//	Adjust to the Basic-indexed column.
	if (GetComplexity() == BASIC)
		wCol = BasicColumn(wCol);
	szName = m_szColumns[(int)wCol];
	wWidth = m_uWidths[wCol];
	return TRUE;
}

/*
 * BasicColumn - Return the index into the advanced columns of the basic column
 *		index iBasicColumn
 *
 * History:	a-jsari		12/23/97		Initial version
 */
unsigned CBufferFolder::BasicColumn(unsigned iBasicColumn) const
{
	ASSERT(GetComplexity() == BASIC);
	for (unsigned iColumn = 0 ; iColumn < iBasicColumn ; ++iColumn) {
		//	If any of our columns are advanced, skip them.
		if (m_dcColumns[iColumn] == ADVANCED)
			++iBasicColumn;
	}
	ASSERT(iBasicColumn < m_cColumns);
	return iBasicColumn;
}

/*
 * BasicRow - Return the index into the advanced rows of the basic row index
 *		iBasicRow
 *
 * History:	a-jsari		12/23/97		Initial version
 */
unsigned CBufferFolder::BasicRow(unsigned iBasicRow) const
{
	ASSERT(GetComplexity() == BASIC);
	for (unsigned iRow = 0 ; iRow < iBasicRow ; ++iRow) {
		//	If any of our rows are advanced, skip them.
		if (m_dcRows[iRow] == ADVANCED)
			++iBasicRow;
	}
	ASSERT(iBasicRow < m_cRows);
	return iBasicRow;
}

/*
 * GetColumns - Read the columns value from the current file.
 *
 * History:	a-jsari		10/17/97		Initial version
 */
unsigned CBufferFolder::GetColumns() const
{
	//	If Complexity is advanced, the number of columns is equal to our stored value.
 	if (GetComplexity() == ADVANCED)
		return m_cColumns;
	//	We are in basic mode; remove all advanced columns.
	unsigned	cColumns = m_cColumns;
	unsigned	iColumn = m_cColumns;
	while (iColumn--) {
		if (m_dcColumns[iColumn] == ADVANCED) --cColumns;
	}
	return cColumns;
}

/*
 * GetRows - Read the rows value from the current file
 *
 * History:	a-jsari		10/17/97		Initial version
 */
unsigned CBufferFolder::GetRows() const
{
	//	If Complexity is advanced, the number of rows is equal to our stored value.
	if (GetComplexity() == ADVANCED)
		return m_cRows;
	//	Otherwise, we are basic; remove all Advanced rows.
	unsigned	cRows = m_cRows;
	unsigned	iRow = m_cRows;
	while (iRow--) {
		if (m_dcRows[iRow] == ADVANCED) --cRows;
	}
	return cRows;
}

/*
 * GetName - Return the category's name.
 *
 * History:	a-jsari		10/27/97		Initial version
 */
BOOL CBufferFolder::GetName(CString &szName) const
{
	szName = m_szName;
	return TRUE;
}

/*
 * GetSubElement - Return the Element stored at iRow and iCol.
 *
 * History: a-jsari		10/27/97		Initial version
 */
BOOL CBufferFolder::GetSubElement(unsigned iRow, unsigned iCol, CString &szName) const
{
	if (GetComplexity() == BASIC) {
		iRow = BasicRow(iRow);
		iCol = BasicColumn(iCol);
	}
	szName = m_szElements[iRow][iCol];
	return TRUE;
}

/*
 * GetSortType - Return the sort method for the column numbered iColumn
 *		in this folder.
 *
 * History:	a-jsari		12/1/97		Initial version
 */
BOOL CBufferFolder::GetSortType(unsigned iColumn, MSIColumnSortType &stColumn) const
{
	if (GetComplexity() == BASIC) {
		iColumn = BasicColumn(iColumn);
	}
	m_SortData.GetSortType(iColumn, stColumn);
	return TRUE;
}

/*
 * GetSortIndex - Return the iColumn numbered column's internal sort index
 *		for the element at row iRow compared to other rows in this column.
 *
 * History:	a-jsari		12/1/97		Initial version
 */
DWORD CBufferFolder::GetSortIndex(unsigned iRow, unsigned iColumn) const
{
	if (GetComplexity() == BASIC) {
		iColumn = BasicColumn(iColumn);
		iRow = BasicRow(iRow);
	}

	return m_SortData.GetSortValue( iRow, iColumn);
}

/*
 * GetColumnComplexity - Return the complexity of the iColumn'th column
 *
 * History:	a-jsari		12/23/97		Initial version
 */
DataComplexity CBufferFolder::GetColumnComplexity(unsigned iColumn)
{
	//	We are only concerned with Complexity when we are saving the data
	//	and we must be in Advanced mode to save.
	ASSERT(GetComplexity() == ADVANCED);
	return m_dcColumns[iColumn];
}

/*
 * GetRowComplexity - Return complexity of this folder's iRow'th row.
 *
 * History:	a-jsari		12/23/97		Initial version
 */
DataComplexity CBufferFolder::GetRowComplexity(unsigned iRow)
{
	//	We are only concerned with Complexity when we are saving the data
	//	and we must be in Advanced mode to do a save.
	ASSERT(GetComplexity() == ADVANCED);
	return m_dcRows[iRow];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\dialogs.h ===
//	Dialogs.h
//
//  Copyright (c) 1998-1999 Microsoft Corporation

#pragma once	//	MSINFO_DIALOGS_H

#include <afxdlgs.h>
#include "FileIO.h"
#include "Resource.h"

//	Default values for the save dialog (overridden by the report dialog when it
//	inherits the save dialog).
extern CString strMSInfoSaveFileTypes;
extern CString strMSInfoSaveType;

/*
 * CMSInfoFileDialog - Wrapper for the file dialog with our own default values.
 *
 * Note: This object should not be used directly.
 *
 * History:	a-jsari		10/24/97		Initial version
 */
class CMSInfoFileDialog : public CFileDialog {
	//	Protected so that no one uses this object directly.
public:
	INT_PTR DoModal();

protected:
	CMSInfoFileDialog(BOOL bDialogIsOpen = FALSE, HWND hOwner = NULL,
			LPCTSTR lpszDefaultExtension = NULL, LPCTSTR lpszExtensionFilters = NULL);
	~CMSInfoFileDialog() { };

private:
	static TCHAR	m_szCurrentDirectory[MAX_PATH];  // shared between file open and file save
};

/*
 * CMSInfoOpenDialog - Construct an open dialog.
 *
 * History:	a-jsari		10/27/97		Initial version
 */
class CMSInfoOpenDialog : public CMSInfoFileDialog {
public:
	CMSInfoOpenDialog(HWND hOwner = NULL);
	~CMSInfoOpenDialog()	{ }
};

/*
 * CMSInfoSaveDialog - Construct a save dialog.
 *
 * History:	a-jsari		10/27/97		Initial version
 */
class CMSInfoSaveDialog : public CMSInfoFileDialog {
public:
	CMSInfoSaveDialog(HWND hOwner = NULL,
			LPCTSTR lpszDefaultExtension = strMSInfoSaveType,
			LPCTSTR lpszExtensionFilters = strMSInfoSaveFileTypes);
	~CMSInfoSaveDialog()	{ }
};

/*
 * CMSInfoReportDialog - Construct a report dialog.
 *
 * History:	a-jsari		10/27/97		Initial version
 */
class CMSInfoReportDialog : public CMSInfoSaveDialog {
public:
	CMSInfoReportDialog(HWND hOwner = NULL);
	~CMSInfoReportDialog()	{ }
};

/*
 * CMSInfoPrintDialog - Construct a print dialog.
 *
 * History:	a-jsari		10/24/97		Initial version.
 */
class CMSInfoPrintDialog : public CPrintDialog {
public:
	CMSInfoPrintDialog(HWND hOwner = NULL);
	~CMSInfoPrintDialog()		{ }
};

class CSystemInfoScope;

/*
 * CFindDialog - A dialog to handle finding data in MSInfo.  The user
 *		interface for this class is stored in the Resources IDD_FIND.
 *
 * History:	a-jsari		10/29/97		Initial version.
 */
class CFindDialog : public CDialog
{
// Construction
public:
	friend class CFindThread;

	CFindDialog(CSystemInfoScope *pScope, HWND hPostWindow, HWND hwndMMCWindow);
	~CFindDialog();

	BOOL			Create();
	CWnd			*SetFocus();
	BOOL			OnInitDialog();
	void			FindComplete();
	void			ResetSearch();
	const CString	&FindString() const		{ return m_strSearch; }

	static UINT		WM_MSINFO_FIND;

// Dialog Data
	//{{AFX_DATA(CFindDialog)
	enum { IDD = IDD_FIND };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

// Implementation
protected:

	HWND					m_hPostWindow;
	HWND					m_hMMCWindow;
	CSystemInfoScope		*m_pScope;
	CString					m_strSearch;
	BOOL					m_fRunning;
	UINT_PTR				m_iTimer;

	LONG OnHelp(WPARAM wParam, LPARAM lParam);
	LONG OnContextMenu(WPARAM wParam, LPARAM lParam);

	// Generated message map functions
	//{{AFX_MSG(CFindDialog)

	virtual afx_msg void	OnCancel();
	virtual afx_msg void	OnFindNext();
	virtual afx_msg void	OnNewSearch();
	virtual afx_msg void	OnSearchTerm();
	virtual afx_msg void	OnStopFind();
	virtual afx_msg void	OnActivate(UINT, CWnd *, BOOL bMinimized);
	virtual afx_msg BOOL	OnSetCursor(CWnd *pWnd, UINT nHitTest, UINT message);
	virtual afx_msg BOOL	OnHelpInfo(HELPINFO * pHelpInfo);
	virtual afx_msg void	OnTimer(UINT);

	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/*
 * CFindThread - A thread in which to run a modal Find dialog, making it
 *		effectively modeless.  This is required because MMC runs its UI
 *		in a thread which is inaccessible to the snap-in DLL, which runs
 *		in a separate thread.
 *
 * History:	a-jsari		1/19/98		Initial version.
 */
class CFindThread : public CWinThread {
public:
	//	Nonspecific dynamic class initialization required for UI threads.
	DECLARE_DYNCREATE(CFindThread);

	CFindThread();
	~CFindThread();

	void	SetScope(CSystemInfoScope *pScope);
	void	SetParent(HWND hParent, HWND hMMC);
	void	Activate();

	void			SetDataSource(CDataSource * pDataSource) { m_pDataSource = pDataSource; }
	CDataSource *	GetDataSource() { return (m_pDataSource); }

	void			FindComplete()		{ m_pdlgFind->FindComplete(); }
	void			ResetSearch()		{ m_pdlgFind->ResetSearch(); }
	const CString	&FindString()		{ return m_pdlgFind->FindString(); }

	BOOL	InitInstance();
	int		ExitInstance();

	void	RemoteQuit();

private:
#if 0
	static LRESULT				(*m_pBaseWindowProc)(HWND, UINT, WPARAM, LPARAM);
	static LRESULT CALLBACK		FindWindowProc(HWND hMainWindow, UINT uMsg, WPARAM wParam, LPARAM lParam);
#endif
	CFindDialog			*m_pdlgFind;
	CSystemInfoScope	*m_pScope;
	CDataSource			*m_pDataSource;
	HWND				m_hParentWindow;
	HWND				m_hMMCWindow;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\doresult.cpp ===
//	DOResult.cpp - The polymorphic DataObject for result pane items.
//	
//  Copyright (c) 1998-1999 Microsoft Corporation

#include "StdAfx.h"
#include "DataObj.h"

/*
 * CreateDisplayName - Return the DisplayName string in lpMedium's
 *		hGlobal pointer.
 *
 * History:	a-jsari		9/28/97		Initial version
 */
HRESULT CResultDataObject::CreateDisplayName(LPSTGMEDIUM)
{
	return E_FAIL;
}

/*
 * CreateNodeTypeData - Return the NodeType for a result item in lpMedium's
 *		hGlobal pointer.
 *
 * History:	a-jsari		9/28/97		Initial version
 *
 * Note: The caller is responsible for freeing pMedium's hGlobal.
 */
HRESULT CResultDataObject::CreateNodeTypeData(LPSTGMEDIUM pMedium)
{
	return Create(reinterpret_cast<const void *>(&cObjectTypeResultItem),
			sizeof(GUID), pMedium);
}

/*
 * CreateNodeTypeStringData - Return the NodeType for a result item as
 *		an LPWSTR in lpMedium's hGlobal pointer.
 *
 * History: a-jsari		9/28/97		Initial version
 *
 * Note: The caller is responsible for freeing pMedium's hGlobal.
 */
HRESULT CResultDataObject::CreateNodeTypeStringData(LPSTGMEDIUM pMedium)
{
	USES_CONVERSION;
	return Create(WSTR_FROM_CSTRING(cszObjectTypeResultItem),
		((_tcslen(cszObjectTypeResultItem) + 1) * sizeof(WCHAR)), pMedium);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\doscope.cpp ===
//	DOScope.cpp - The polymorphic DataObject object for Dynamic
//	Scope items.
//
// Copyright (c) 1998-1999 Microsoft Corporation

#include "StdAfx.h"
#include "DataObj.h"
#include "DataSrc.h"

/*
 * CreateDisplayName - Return the DisplayName string in lpMedium's
 *		hGlobal pointer.
 *
 * History:	a-jsari		9/28/97		Initial version
 */
HRESULT CScopeDataObject::CreateDisplayName(LPSTGMEDIUM)
{
	return E_FAIL;
}

/*
 * CreateNodeTypeData - Return the NodeType for a dynamic scope item in
 *		lpMedium's hGlobal pointer.
 *
 * History:	a-jsari		9/28/97		Initial version
 *
 * Note: The caller is responsible for freeing pMedium's hGlobal.
 */
HRESULT CScopeDataObject::CreateNodeTypeData(LPSTGMEDIUM pMedium)
{
	return Create(reinterpret_cast<const void *>(&cNodeTypeDynamic), sizeof(GUID), pMedium);
}

/*
 * CreateNodeTypeStringData - Return the NodeType for a dynamic scope
 *		item as an LPWSTR in lpMedium's hGlobal pointer.
 *
 * History: a-jsari		9/28/97		Initial version
 *
 * Note: The caller is responsible for freeing pMedium's hGlobal.
 */
HRESULT CScopeDataObject::CreateNodeTypeStringData(LPSTGMEDIUM pMedium)
{
	USES_CONVERSION;
	return Create(WSTR_FROM_CSTRING(cszNodeTypeDynamic),
		((_tcslen(cszNodeTypeDynamic) + 1) * sizeof(WCHAR)), pMedium);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\fileio.cpp ===
//	FileIO.cpp	Implementation of MSInfoFile classes.
//
//  Copyright (c) 1998-1999 Microsoft Corporation

#include "FileIO.h"
#include "DataSrc.h"
#include "Resource.h"

CFileFormatException	CMSInfoFile::xptFileFormat;
const unsigned			CMSInfoFile::DefaultReadBufferSize = 512; // 256;

/*
 * CMSInfoFile - Construct an MSInfoFile, setting the CFile to the pointer passed
 *
 * History:	a-jsari		10/20/97		Initial version
 */
CMSInfoFile::CMSInfoFile(CFile *pFile)
{
	if (pFile != NULL)
		m_pFile = pFile;
}

/*
 * CMSInfoFile - Construct an MSInfoFile, opening the CFile
 *
 * History:	a-jsari		11/13/97		Initial version
 */
CMSInfoFile::CMSInfoFile(LPCTSTR szFileName, UINT nFlags)
:m_strFileName(szFileName)
{
	m_pFile = new CFile(szFileName, nFlags);
	if (m_pFile == NULL) ::AfxThrowMemoryException();
}

/*
 * ~CMSInfoFile - Destroy an MSInfoFile, closing the CFile pointer
 *
 * History:	a-jsari		10/20/97		Initial version
 */
CMSInfoFile::~CMSInfoFile()
{
	if (m_pFile)
	{
		m_pFile->Close();
		delete m_pFile;
	}
}

/*
 * ReadUnsignedInt - Read an int from a file with the same byte-order
 *		as our current implementation.
 *
 * History:	a-jsari		10/21/97		Initial version
 */
void CMSInfoFile::ReadUnsignedInt(unsigned &uValue)
{
	ReadUnsignedFromCFile(m_pFile, uValue);
}

/*
 * ReadUnsignedLong - Read a long from a file with the same byte-order
 *		as our current implementation.
 *
 * History:	a-jsari		12/1/97		Initial version
 */
void CMSInfoFile::ReadUnsignedLong(unsigned long &dwValue)
{
	long	lValue;

	ReadLongFromCFile(m_pFile, lValue);
	::memcpy(&dwValue, &lValue, sizeof(unsigned long));
}

/*
 * ReadLong - Read a long from a file written with our current byte-order
 *
 * History:	a-jsari		10/21/97		Initial version
 */
void CMSInfoFile::ReadLong(long &lValue)
{
	ReadLongFromCFile(m_pFile, lValue);
}

/*
 * ReadSignedInt - Read a signed integer value.
 *
 * History:	a-jsari		10/20/97		Initial version
 */
void CMSInfoFile::ReadSignedInt(int &wValue)
{
	unsigned	uValue;

	ReadUnsignedInt(uValue);
	::memcpy(&wValue, &uValue, sizeof(int));
}

/*
 * ReadTchar - Read a tchar.
 *
 * History:	a-jsari		12/26/97		Initial version.
 */
void CMSInfoFile::ReadTchar(TCHAR &tcValue)
{
	ReadTcharFromCFile(m_pFile, tcValue);
}

/*
 * ReadString - Read a string.
 *
 * History:	a-jsari		10/20/97		Initial version.
 */
void CMSInfoFile::ReadString(CString &szString)
{
	unsigned	wStringLength;
	WCHAR		szBuffer[DefaultReadBufferSize];	//	Maximum string length = sizeof(szBuffer)
	LPWSTR		pszBuffer		= szBuffer;

	ASSERT(m_pFile);
	ReadUnsignedInt(wStringLength);
	if (wStringLength > sizeof(szBuffer))
		ThrowFileFormatException();
	szBuffer[wStringLength] = (WCHAR)'\0';
	wStringLength *= sizeof(WCHAR);
	if (m_pFile->Read(reinterpret_cast<void *>(pszBuffer), wStringLength) != wStringLength)
		ThrowFileFormatException();
	szString = pszBuffer;
}

/*
 * WriteHeader - Write the header for the current version (currently
 *		Version 5.00).
 *
 * History:	a-jsari		10/31/97		Initial version
 */
void CMSInfoFile::WriteHeader(CDataSource *)
{
	time_t	tNow;
	WriteUnsignedInt(VERSION_500_MAGIC_NUMBER);	//	File magic number.
	WriteUnsignedInt(0x500);					//	Version number
	time(&tNow);
	WriteLong((LONG)tNow);							//	Current time.
#ifdef _WIN64
        WriteLong((LONG) (tNow>>32));
#endif
        WriteString("");							//	Network machine
	WriteString("");							//	Network user name.
}

/*
 * WriteChildMark - Write the special integer which specifies that the
 *		following folder will be the child of the previous folder.
 *
 * History:	a-jsari		11/5/97			Initial version.
 */
void CMSInfoFile::WriteChildMark()
{
	WriteUnsignedInt(CBufferV500DataSource::CHILD);
}

/*
 * WriteEndMark - Write the special integer which specifies that the
 *		end of data has been reached.
 *
 * History:	a-jsari		11/5/97		Initial version.
 */
void CMSInfoFile::WriteEndMark()
{
	WriteUnsignedInt(CBufferV500DataSource::END);
}

/*
 * WriteNextMark - Write the special integer which specifies that the
 *		following folder will be the next folder in the list.
 *
 * History:	a-jsari		11/5/97		Initial version.
 */
void CMSInfoFile::WriteNextMark()
{
	WriteUnsignedInt(CBufferV500DataSource::NEXT);
}

/*
 * WriteParentMark - Write the special mark specifying a parent node, with
 *		the number of times the reading function should go up.
 *
 * History:	a-jsari		11/5/97		Initial version.
 */
void CMSInfoFile::WriteParentMark(unsigned cIterations)
{
	WriteUnsignedInt(CBufferV500DataSource::PARENT | cIterations);
}

/*
 * WriteByte - Write a byte to our internal file.
 *
 * History:	a-jsari		10/22/97		Initial version
 */
void CMSInfoFile::WriteByte(BYTE bValue)
{
	m_pFile->Write(reinterpret_cast<void *>(&bValue), sizeof(bValue));
}

/*
 * WriteString - Write szValue as a string of wide characters, prefixed by
 *		the string length.
 *
 * History:	a-jsari		10/22/97		Initial version
 */
void CMSInfoFile::WriteString(CString szValue)
{
	LPWSTR		pszString;

	USES_CONVERSION;
	WriteUnsignedInt(szValue.GetLength());
	pszString = T2W(const_cast<LPTSTR>((LPCTSTR)szValue));
	m_pFile->Write(reinterpret_cast<void *>(pszString),
			szValue.GetLength() * sizeof(WCHAR));
}

/*
 * WriteLong - Write a long value to our internal file.
 *
 * History:	a-jsari		10/22/97		Initial version
 */
void CMSInfoFile::WriteLong(long lValue)
{
	m_pFile->Write(reinterpret_cast<void *>(&lValue), sizeof(lValue));
}

/*
 * WriteUnsignedInt - Write an unsigned integer value to our internal file.
 *
 * History:	a-jsari		10/22/97		Initial version
 */
void CMSInfoFile::WriteUnsignedInt(unsigned uValue)
{
	m_pFile->Write(reinterpret_cast<void *>(&uValue), sizeof(uValue));
}

/*
 * WriteUnsignedLong - Write an unsigned long value to our internal file.
 *
 * History:	a-jsari		12/1/97		Initial version
 */
void CMSInfoFile::WriteUnsignedLong(unsigned long dwValue)
{
	long	lValue;

	::memcpy(&lValue, &dwValue, sizeof(dwValue));
	WriteLong(lValue);
}

/*
 * ReadTcharFromCFile - Read a TCHAR value from the file specified.
 *
 * History:	a-jsari		12/26/97		Initial version
 */
void CMSInfoFile::ReadTcharFromCFile(CFile *pFile, TCHAR &tcValue)
{
	ASSERT(pFile != NULL);
	if (pFile->Read(reinterpret_cast<void *>(&tcValue), sizeof(tcValue)) != sizeof(tcValue))
		ThrowFileFormatException();
}

/*
 * ReadUnsignedFromCFile - Read an unsigned value from the file specified.
 *
 * History:	a-jsari		10/20/97		Initial version
 */
void CMSInfoFile::ReadUnsignedFromCFile(CFile *pFile, unsigned &uValue)
{
	ASSERT(pFile);
	if (pFile->Read(reinterpret_cast<void *>(&uValue), sizeof(uValue)) != sizeof(uValue))
		ThrowFileFormatException();
}

/*
 * ReadLongFromCFile - Read a long from the file specified.
 *
 * History:	a-jsari		10/20/97		Initial version.
 */
void CMSInfoFile::ReadLongFromCFile(CFile *pFile, long &lValue)
{
	ASSERT(pFile);
	if (pFile->Read(reinterpret_cast<void *>(&lValue), sizeof(lValue)) != sizeof(lValue))
		ThrowFileFormatException();
}

/*
 * CMSInfoTextFile - Constructor
 *
 * History:	a-jsari		11/13/97		Initial version
 */
CMSInfoTextFile::CMSInfoTextFile(LPCTSTR szFileName, UINT nFlags)
{
	try
	{
		m_pFile = new CFile(szFileName, nFlags);
	}
	catch (CFileException * e)
	{
		e->ReportError();
		throw;
	}
}

/*
 * CMSInfoTextFile - Constructor
 *
 * History:	a-jsari		12/26/97		Initial version
 */
CMSInfoTextFile::CMSInfoTextFile(CFile *pFile)
:CMSInfoFile(pFile)
{
}

/*
 * WriteHeader - Write the special header for the text file.
 *
 * History:	a-jsari		10/31/97		Initial version
 */
void CMSInfoTextFile::WriteHeader(CDataSource *pSource)
{
	AFX_MANAGE_STATE(::AfxGetStaticModuleState());

	// mark file as unicode
	WCHAR wHeader = 0xFEFF;
	m_pFile->Write( &wHeader, 2);

	//	FIX:	Make this point to the right time.
	CTime		tNow = CTime::GetCurrentTime();
	CString		strTimeFormat;
	strTimeFormat.LoadString(IDS_TIME_FORMAT);
	CString		strHeaderText = tNow.Format(strTimeFormat);
	WriteString(strHeaderText);
	WriteString(pSource->MachineName());
}

/*
 * WriteTitle - Write the title of a folder.
 *
 * History:	a-jsari		11/5/97			Initial version
 */
void CMSInfoTextFile::WriteTitle(CString szName)
{
	CString		szWriteString = _T("[");

	szWriteString += szName + _T("]\n\n");
	WriteString(szWriteString);
}

/*
 * WriteLong - Write a long value in the text file.
 *
 * History:	a-jsari		10/23/97		Initial version
 */
void CMSInfoTextFile::WriteLong(long lValue)
{
	CString		szTextValue;

	szTextValue.Format(_T("%ld"), lValue);
	WriteString(szTextValue);
}

/*
 * WriteUnsignedInt - Write an unsigned value in the text file.
 *
 * History:	a-jsari		10/23/97		Initial version
 */
void CMSInfoTextFile::WriteUnsignedInt(unsigned uValue)
{
	CString		szTextValue;

	szTextValue.Format(_T("%ud"), uValue);
	WriteString(szTextValue);
}

/*
 * WriteString - Write a string to a text file.
 *
 * History:	a-jsari		10/23/97		Initial version
 */
void CMSInfoTextFile::WriteString(CString szValue)
{
	if (szValue.GetLength() == 0)
		return;

	dynamic_cast<CFile *>(m_pFile)->Write((LPCTSTR)szValue, szValue.GetLength() * sizeof(TCHAR));
}

/*
 * WriteString - Write a string to a memory file.
 *
 * History:	a-jsari		1/5/98		Initial version
 */
void CMSInfoMemoryFile::WriteString(CString szValue)
{
	if (szValue.GetLength() == 0)
		return;
	m_pFile->Write((LPCTSTR)szValue, szValue.GetLength() * sizeof(TCHAR));
}

#if 0
/*
 * ReadUnsignedInt -
 *
 * History:	a-jsari		10/21/97		Initial version
 */
void CMSInfoReverseEndianFile::ReadUnsignedInt(unsigned &uValue)
{
	CMSInfoReverseEndianFile::ReadUnsignedFromCFile(m_pFile, uValue);
}


/*
 * ReadLong -
 *
 * History:	a-jsari		10/21/97		Initial version
 */
void CMSInfoReverseEndianFile::ReadLong(long &lValue)
{
	CMSInfoReverseEndianFile::ReadLongFromCFile(m_pFile, lValue);
}

/*
 * ReadString -
 *
 * History:	a-jsari		10/21/97		Initial version
 */
void CMSInfoReverseEndianFile::ReadString(CString &szValue)
{
	unsigned	uStringLength;
	WCHAR		szBuffer[DefaultReadBufferSize];
	LPWSTR		pszBuffer = szBuffer;

	ReadUnsignedInt(uStringLength);
	for (unsigned i = uStringLength ; i > 0 ; --i) {
		szBuffer[i] = 0;
		for (unsigned j = sizeof(WCHAR) ; j > 0 ; --j) {
			BYTE		bRead;

			ReadByte(bRead);
			szBuffer[i] >>= 8;
			szBuffer[i] |= bRead;
		}
	}
}

/*
 * ReadIntegerFromCFile - Template class to read an arbitrarily sized int
 *		from a CFile pointer.
 *
 * History:	a-jsari		10/21/97		Initial version
 */
template <class T> void ReadIntegerFromCFile(CFile *pFile, T &tValue)
{
	union ReverseBuffer { BYTE bytes[sizeof(T)]; T tVal; };

	union ReverseBuffer rbReverse;
	union ReverseBuffer rbSwap;

	if (pFile->Read(reinterpret_cast<void *>(&tValue), sizeof(T)) != sizeof(T))
		ThrowFileFormatException();
	unsigned j = 0;
	for (unsigned i = sizeof(union ReverseBuffer) ; i > 0 ; --i, ++j) {
		rbSwap.bytes[i] = rbReverse.bytes[j];
	}
	tValue = rbReverse.tVal;
}

/*
 * ReadUnsignedFromCFile -
 *
 * History:	a-jsari		10/21/97		Initial version
 */
void CMSInfoReverseEndianFile::ReadUnsignedFromCFile(CFile *pFile, unsigned &uValue)
{
	ReadIntegerFromCFile<unsigned>(pFile, uValue);
}

/*
 * ReadLongFromCFile -
 *
 * History:	a-jsari		10/21/97		Initial version
 */
void CMSInfoReverseEndianFile::ReadLongFromCFile(CFile *pFile, long &lValue)
{
	ReadIntegerFromCFile<long>(pFile, lValue);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\fileio.h ===
//	FileIO.h
//
//  Copyright (c) 1998-1999 Microsoft Corporation

#pragma once		// MSINFO_FILEIO_H

#include <afx.h>

//	Advanced declaration of this class so we can use the pointer.
class CDataSource;

/*
 * CFileFormatException - Home-brew exception to reflect an error in a
 *		data file.
 *
 * History:	a-jsari		10/20/97		Initial version.
 */
class CFileFormatException : public CException {
};

void ThrowFileFormatException();

/*
 * CMSInfoFile - A file class which provides extended functions for
 *		reading from a file.  Provides binary versions of the files.
 *
 * History: a-jsari		10/20/97		Initial version
 */
class CMSInfoFile {
	friend void			ThrowFileFormatException();
	friend class		CBufferDataSource;
	friend class		CBufferV500DataSource;
public:
	CMSInfoFile(LPCTSTR szFileName, UINT wFlags = CFile::shareDenyWrite
		| CFile::modeCreate | CFile::modeWrite | CFile::typeBinary);
	virtual ~CMSInfoFile();

	enum FileType { BINARY, REVERSE_ENDIAN, TEXT, MEMORY };

	virtual FileType	GetType() { return BINARY; }
	const CString		&GetFileName() { return m_strFileName; }
	virtual void		ReadLong(long &lValue);
	virtual void		ReadUnsignedInt(unsigned &uValue);
	virtual void		ReadString(CString &szValue);
	virtual void		ReadTchar(TCHAR &tcValue);
	void				ReadByte(BYTE &bValue)		{ ReadByteFromCFile(m_pFile, bValue); }
	void				ReadUnsignedLong(DWORD &dwValue);

	virtual void		WriteHeader(CDataSource *pDataSource);
	virtual void		WriteLong(long lValue);
	virtual void		WriteUnsignedInt(unsigned uValue);
	virtual void		WriteString(CString szValue);
	void				WriteByte(BYTE bValue);
	void				WriteUnsignedLong(DWORD dwValue);

	virtual void		WriteTitle(CString szName)	{ WriteString(szName); }
	virtual void		WriteChildMark();
	virtual void		WriteEndMark();
	virtual void		WriteNextMark();
	virtual void		WriteParentMark(unsigned cIterations);

	static void			ReadLongFromCFile(CFile *pFile, long &lValue);
	static void			ReadUnsignedFromCFile(CFile *pFile, unsigned &uValue);
	static void			ReadTcharFromCFile(CFile *pFile, TCHAR &tcValue);
	static void			ReadByteFromCFile(CFile *pFile, BYTE &bValue)	{ ASSERT(pFile);
		if (pFile->Read(&bValue, sizeof(bValue)) != sizeof(bValue)) ThrowFileFormatException(); }

	static void			GetDefaultMSInfoDirectory(LPTSTR szDefaultDirectory, DWORD dwSize);

	void				SeekToBegin()	{ m_pFile->SeekToBegin(); }
	int				    FileHandle()	{ return (int)m_pFile->m_hFile; }
	void				Close()			{ m_pFile->Close(); delete m_pFile; m_pFile = NULL; }

protected:
	enum MagicNumber {
		VERSION_500_MAGIC_NUMBER	= 0x00011970,
		VERSION_500_REVERSE_ENDIAN	= 0x70190100,
		VERSION_410_REVERSE_ENDIAN	= 0x20000000,	//	FIX: Place holders.
		VERSION_410_MAGIC_NUMBER	= 0x20
	};

	CMSInfoFile(CFile *pFile = NULL);

	static const unsigned		DefaultReadBufferSize;
	static CFileFormatException	xptFileFormat;

	void	ReadSignedInt(int &wValue);

	CFile		*m_pFile;
	CString		m_strFileName;
};

/*
 * CMSInfoTextFile - Write-methods version for text file.  No read methods
 *		are required.
 *
 * History:	a-jsari		10/23/97		Initial version.
 */
class CMSInfoTextFile : public CMSInfoFile {
public:
	CMSInfoTextFile(LPCTSTR szName, UINT nFlags = CFile::shareDenyWrite
		| CFile::modeWrite | CFile::modeCreate | CFile::typeText);
	~CMSInfoTextFile() { }

	FileType	GetType()	{ return TEXT; }

	void	WriteTitle(CString szString);
	void	WriteHeader(CDataSource *pDataSource);
	void	WriteLong(long lValue);
	void	WriteUnsignedInt(unsigned uValue);

	virtual void	WriteString(CString szValue);

	void	WriteChildMark()	{ }
	void	WriteEndMark()		{ }
	void	WriteNextMark()		{ }
	void	WriteParentMark(unsigned)	{ }

protected:
	CMSInfoTextFile(CFile *pFile = NULL);
};

/*
 * CMSInfoMemoryFile - Just like a text report, but saved to a memory file.
 *		Inherits the text write functions.
 *
 * History:	a-jsari		12/26/97		Initial version
 */
class CMSInfoMemoryFile : public CMSInfoTextFile {
public:
	CMSInfoMemoryFile() :CMSInfoTextFile(new CMemFile)	{ }
	~CMSInfoMemoryFile()	{ }

	FileType	GetType()	{ return MEMORY; }

	void		WriteTitle(CString szString)			{ CMSInfoTextFile::WriteTitle(szString); }
	void		WriteHeader(CDataSource *pDataSource)	{ CMSInfoTextFile::WriteHeader(pDataSource); }
	void		WriteLong(long lValue)					{ CMSInfoTextFile::WriteLong(lValue); }
	void		WriteUnsignedInt(unsigned uValue)		{ CMSInfoTextFile::WriteUnsignedInt(uValue); }

	void		WriteString(CString szString);
};

#if 0
/*
 * CMSInfoReverseEndianFile - Read-methods version for opposite endian binary file.
 *
 * History:	a-jsari		10/20/97		Initial version
 */
class CMSInfoReverseEndianFile : public CMSInfoFile {
public:
	CMSInfoReverseEndianFile(CFile *pFile);
	~CMSInfoReverseEndianFile() {}

	FileType	GetType()	{ return REVERSE_ENDIAN; }

	void		ReadLong(long &lValue);
	void		ReadUnsignedInt(unsigned &uValue);
	void		ReadString(CString &szValue);

	static void	ReadLongFromCFile(CFile *pFile, long &lValue);
	static void	ReadUnsignedFromCFile(CFile *pFile, unsigned &uValue);
};
#endif

/*
 * ThrowFileFormatException -
 *
 * History:	a-jsari		10/24/97
 */
inline void	ThrowFileFormatException()
{
	throw &CMSInfoFile::xptFileFormat;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\gather.cpp ===
//=============================================================================
// File:			gather.cpp
// Author:		a-jammar
// Covers:		CDataGatherer
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// For usage, see the header file.
//
// The data gathering object maintains a tree of categories. Category
// information is maintained internally, referenced by a ID. These IDs are
// used so that category objects, which will be created and passed outside
// of this object, can refer to the category information stored internally.
// If a category object held externally is no longer valid (possibly from
// a refresh operation), the ID will no longer be used within this object.
// IDs are DWORDS, will start at 1, and increase sequentially. Running out
// of IDs will not be a problem.
//=============================================================================

#include "stdafx.h"
#include "gather.h"
#include "gathint.h"
#pragma warning(disable : 4099)
#include "wbemcli.h"
#pragma warning(default : 4099)
#include "resource.h"
#include "resrc1.h"

//-----------------------------------------------------------------------------
// The constructor needs to note that the object isn't initialized.
// The destructor removes all the categories.
//-----------------------------------------------------------------------------

CDataGatherer::CDataGatherer()
{
	m_fInitialized		= FALSE;
	m_pProvider			= NULL;
	m_dwRootID			= 0;		// zero is used as a null category ID
	m_dwNextFreeID		= 1;		// so the first real ID should be one
	m_complexity		= BASIC;
	m_fDeferredPending	= FALSE;
	m_dwDeferredError	= GATH_ERR_NOERROR;
	m_fTemplatesLoaded	= FALSE;
	m_cInRefresh		= 0;

	ResetLastError();
}

CDataGatherer::~CDataGatherer()
{
	if (m_pProvider)
		delete m_pProvider;

	if (m_fInitialized)
		RemoveAllCategories();
}

//=============================================================================
// Functions called directly on CDataGatherer objects.
//=============================================================================

//-----------------------------------------------------------------------------
// This method is used to get more information about the last error in a 
// gatherer or category member function call. This will return an error code, 
// or zero for OK. Note that a successful method call will reset the value 
// returned by this method.
//-----------------------------------------------------------------------------

DWORD CDataGatherer::GetLastError()
{
	return m_dwLastError;
}

DWORD CDataGatherer::GetLastError(DWORD dwID)
{
	INTERNAL_CATEGORY * pInternal = GetInternalRep(dwID);
	ASSERT(pInternal);
	if (pInternal)
		return pInternal->m_dwLastError;
	return GATH_ERR_NOERROR;
}

//-----------------------------------------------------------------------------
// This Create method delegates the work to the methods for setting a 
// connection to another machine.
//-----------------------------------------------------------------------------

BOOL CDataGatherer::Create(LPCTSTR szMachine)
{
	ResetLastError();

	// Create can only be called once in the lifetime of the object.

	ASSERT(!m_fInitialized);
	if (m_fInitialized)
		return FALSE;

	m_fInitialized = TRUE; // set initialize flag so SetConnect will run
	m_fInitialized = SetConnect(szMachine);
	return m_fInitialized;
}

//-----------------------------------------------------------------------------
// LoadTemplates is used to load the template information from this DLL (the
// default info) and any other DLLs with registry entries.
//-----------------------------------------------------------------------------

void CDataGatherer::LoadTemplates()
{
	TCHAR szBaseKey[] = _T("SOFTWARE\\Microsoft\\Shared Tools\\MSInfo\\templates");
	HKEY	hkeyBase;

	if (!m_fTemplatesLoaded)
	{
		m_fTemplatesLoaded = TRUE;

		if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, szBaseKey, 0, KEY_READ, &hkeyBase))
		{
			CTemplateFileFunctions::LoadTemplateDLLs(hkeyBase, this);
			RegCloseKey(hkeyBase);
		}
		else
		{
			CTemplateFileFunctions::LoadTemplateDLLs(NULL, this);
		}

		if (!m_strCategory.IsEmpty())
			CTemplateFileFunctions::ApplyCategories(m_strCategory, this);
	}
}

//-----------------------------------------------------------------------------
// This method is used to create a WBEM connection to the specified machine.
// If the string parameter is null or empty, then we connect to this machine.
// Create the connection by creating a CDataProvider object.
//
// UPDATE: we're going to delay creating the provider until it is actually
// needed. This should speed up our creation process, and keep us being
// good citizens in computer management.
//-----------------------------------------------------------------------------

BOOL CDataGatherer::SetConnect(LPCTSTR szMachine)
{
	ASSERT(m_fInitialized);

	ResetLastError();
	if (!m_fInitialized)
	{
		SetLastError(GATH_ERR_NOTINITIALIZED);
		return FALSE;
	}

	// Delete an existing provider object (it isn't possible to redirect
	// an existing provider - we need to create a new one).

	if (m_pProvider)
	{
		delete m_pProvider;
		m_pProvider = NULL;
	}

	// Save the name of the machine for the deferred creation, and note that
	// there is deferred work to do.

	m_strDeferredProvider = szMachine;
	m_fDeferredPending = TRUE;
	return TRUE;
}

//-----------------------------------------------------------------------------
// Refresh all the information by refreshing the root category with a 
// recursive flag.
//-----------------------------------------------------------------------------

BOOL CDataGatherer::Refresh(volatile BOOL *pfCancel)
{
	ASSERT(m_fInitialized);

	ResetLastError();
	if (!m_fInitialized)
	{
		SetLastError(GATH_ERR_NOTINITIALIZED);
		return FALSE;
	}

	// Multiple calls to LoadTemplates don't matter - it will only load
	// the DLL template information once.

	LoadTemplates();

	if (m_dwRootID != 0)
		return RefreshCategory(m_dwRootID, TRUE, pfCancel);

	return TRUE;
}

//-----------------------------------------------------------------------------
// Set the complexity of the data shown to the user.
//-----------------------------------------------------------------------------

BOOL CDataGatherer::SetDataComplexity(DataComplexity complexity)
{
	ASSERT(m_fInitialized);

	SetLastError(GATH_ERR_NOERROR);
	if (!m_fInitialized)
	{
		SetLastError(GATH_ERR_NOTINITIALIZED);
		return FALSE;
	}

	ASSERT(complexity == BASIC || complexity == ADVANCED);
	m_complexity = complexity;
	return TRUE;
}

//-----------------------------------------------------------------------------
// This method is used to allocate a new CDataCategory object to represent
// the root category, and return a pointer to the new object. The caller is
// responsible for eventually deallocating the object. We use a helper function
// to construct an object for a given ID number.
//-----------------------------------------------------------------------------

CDataCategory * CDataGatherer::GetRootDataCategory()
{
	ASSERT(m_fInitialized);

	SetLastError(GATH_ERR_NOERROR);
	if (!m_fInitialized)
	{
		SetLastError(GATH_ERR_NOTINITIALIZED);
		return NULL;
	}

	LoadTemplates();

	if (m_dwRootID != 0)
		return BuildDataCategory(m_dwRootID);

	return NULL;
}

//-----------------------------------------------------------------------------
// This method is used to convert a category identifier (static, non-localized)
// to a path to a category (all the category names to the identified category,
// not including the root, delimited by backslashes).
//-----------------------------------------------------------------------------

BOOL CDataGatherer::GetCategoryPath(const CString & strIdentifier, CString & strPath)
{
	CString	strTempPath;
	DWORD		dwID = m_dwRootID;

	ASSERT(m_fInitialized);

	SetLastError(GATH_ERR_NOERROR);
	if (!m_fInitialized)
	{
		SetLastError(GATH_ERR_NOTINITIALIZED);
		return FALSE;
	}

	if (dwID && FindCategoryByIdentifer(strIdentifier, strTempPath, dwID))
	{
		// The path we have right now includes the root category name. This is
		// unnecessary, so we remove it.

		int iFirstDelimiter = strTempPath.Find(_T('\\'));
		if (iFirstDelimiter > 0)
			strPath = strTempPath.Right(strTempPath.GetLength() - iFirstDelimiter);
		else
			strPath = strTempPath;

		return TRUE;
	}

	SetLastError(GATH_ERR_BADCATIDENTIFIER);
	return FALSE;
}

//-----------------------------------------------------------------------------
// Find the strSearch string in the gathered data. Start at the strPath
// category on line iLine (if strPath is empty, start at the root). Return
// the first match in strPath & iLine. If iLine is -1, then search the
// category name as well.
//
// We want to search from top to bottom on a fully expanded tree view of the
// data categories - meaning we should use a depth first search.
//-----------------------------------------------------------------------------

BOOL CDataGatherer::Find(MSI_FIND_STRUCT *pFind)
{
	// Parameter checking.

	ASSERT(m_fInitialized);

	SetLastError(GATH_ERR_NOERROR);
	if (!m_fInitialized)
	{
		SetLastError(GATH_ERR_NOTINITIALIZED);
		return FALSE;
	}

	ASSERT(pFind);
	if (!pFind)
		return FALSE;

	if (m_dwRootID == 0)
		return FALSE;

	ASSERT(pFind->m_fSearchCategories || pFind->m_fSearchData);	// should search something
	ASSERT(!pFind->m_strSearch.IsEmpty());								// should search for something
	ASSERT(pFind->m_fSearchCategories || pFind->m_iLine != -1); // contradiction
	ASSERT(!pFind->m_strPath.IsEmpty() || pFind->m_iLine <= 0); // can't start in middle of non-category

	// The path passed in doesn't start with the root category, but internally
	// we want to deal with paths that include the root.

	CString strRootName;
	if (GetName(m_dwRootID, strRootName))
	{
		if (!pFind->m_strPath.IsEmpty() && pFind->m_strPath[0] == _T('\\'))
			pFind->m_strPath = strRootName + pFind->m_strPath;
		else
			pFind->m_strPath = strRootName + CString("\\") + pFind->m_strPath;

		if (pFind->m_strParentPath.Find(strRootName) != 0)
		{
			if (!pFind->m_strParentPath.IsEmpty() && pFind->m_strParentPath[0] == _T('\\'))
				pFind->m_strParentPath = strRootName + pFind->m_strParentPath;
			else
				pFind->m_strParentPath = strRootName + CString("\\") + pFind->m_strParentPath;
		}
	}

	// Find the ID of the category to start searching from.

	CString					strPath = pFind->m_strPath;
	int						iLine;
	DWORD						dwID = FindCategoryByPath(strPath);
	INTERNAL_CATEGORY *	pInternalCat;

	// A line number of -1 is used to identify a category name. If there
	// is a category path, use whatever line was passed in. Otherwise,
	// use 0 or -1 depending on whether we are supposed to search cat names.

	if (pFind->m_strPath.IsEmpty())
		iLine = (pFind->m_fSearchCategories) ? -1 : 0;
	else
		iLine = pFind->m_iLine;

	// If we couldn't find an ID (empty path or bad path), start from the root.

	if (dwID == 0)
		dwID = m_dwRootID;

	// If this search is case insensitive, convert the string we're looking
	// for to all uppercase (also done to strings we're scanning).

	if (!pFind->m_fCaseSensitive)
		pFind->m_strSearch.MakeUpper();

	// This loop is used to perform a recursive search of the current category,
	// and then continue with first the next sibling of the category, then the 
	// next sibling of the parent category. We traverse up the tree until
	// we reach a category which is not a child of m_strParentPath. In this way, 
	// we can search a the scope pane's tree control from top to bottom starting
	// at any arbitrary category.

	pFind->m_fNotFound	= FALSE;
	pFind->m_fFound		= FALSE;
	pFind->m_fCancelled	= FALSE;

	while (dwID)
	{
		// Get the internal category pointer for the ID we're searching.

		pInternalCat = GetInternalRep(dwID);

		// This should never happen, but it would be better to fail the find than crash.

		if (pInternalCat == NULL)
			return FALSE;

		// Search this ID and all of it's children using a recursive function.

		if (RecursiveFind(pInternalCat, pFind, iLine, strPath))
		{
			// Strip off the root category from the front of the path before we return it.

			int iFirstDelimiter = strPath.Find(_T('\\'));
			if (iFirstDelimiter > 0)
				strPath = strPath.Right(strPath.GetLength() - iFirstDelimiter);
			else
				strPath.Empty(); // There is no delimiter, the path is just the root.

			pFind->m_strPath = strPath;
			pFind->m_iLine	= iLine;
			pFind->m_fFound = TRUE;

			return TRUE;
		}

		// If the caller has cancelled the find, return.

		if (pFind->m_pfCancel && *pFind->m_pfCancel)
		{
			pFind->m_fCancelled = TRUE;
			return TRUE;
		}

		// If we didn't find it in the first category we were looking in, reset
		// the line variable so we search all of each of the next categories.

		iLine = ((pFind->m_fSearchCategories) ? -1 : 0);
		
		// If we didn't find a match, keep looking - first in the next siblings
		// of the current ID, then in the parent's next sibling, and so on.

		while (pInternalCat && pInternalCat->m_dwNextID == 0)
			pInternalCat = (pInternalCat->m_dwParentID) ? GetInternalRep(pInternalCat->m_dwParentID) : NULL;
		
		if (pInternalCat)
		{
			dwID = pInternalCat->m_dwNextID;

			if (!pFind->m_strParentPath.IsEmpty() && !IsChildPath(pInternalCat, pFind->m_strParentPath))
				break;
		}
		else
			break;
	}

	// If we reach here, the data wasn't found (and the find wasn't cancelled),
	// so set the struct members accordingly and return TRUE.

	pFind->m_fNotFound = TRUE;
	return TRUE;
}

//=============================================================================
// Functions implementing CDataCategory (and derived) object behavior.
//=============================================================================

//-----------------------------------------------------------------------------
// This method (usually called by a category object) returns a BOOL indicating
// is the supplied ID refers to a valid category. Note: this method should have
// no side effects, as it is used extensively within ASSERTs.
//-----------------------------------------------------------------------------

BOOL CDataGatherer::IsValidDataCategory(DWORD dwID)
{
	INTERNAL_CATEGORY * pCheck;

	if (dwID != 0 && m_mapCategories.Lookup((WORD) dwID, (void * &) pCheck))
	{
		ASSERT(pCheck && pCheck->m_dwID == dwID);
		return TRUE;
	}
	return FALSE;
}

//-----------------------------------------------------------------------------
// This method (called by a category object) is used to get the name 
// of the category.
//-----------------------------------------------------------------------------

BOOL CDataGatherer::GetName(DWORD dwID, CString & strName)
{
	INTERNAL_CATEGORY *	pInternalCat;

	ASSERT(m_fInitialized);

	SetLastError(GATH_ERR_NOERROR);
	if (!m_fInitialized)
	{
		SetLastError(GATH_ERR_NOTINITIALIZED);
		return FALSE;
	}

	// Look up the internal representation for the specified category.

	pInternalCat = GetInternalRep(dwID);

	if (pInternalCat)
	{
		strName = pInternalCat->m_categoryName.m_strText;
		return TRUE;
	}

	return FALSE;
}

//-----------------------------------------------------------------------------
// GetRelative is used by the CDataCategory (or derived) object to navigate
// through the category tree. The relative enumeration tells which direction
// in the tree to navigate.
//-----------------------------------------------------------------------------

CDataCategory * CDataGatherer::GetRelative(DWORD dwID, Relative relative)
{
	INTERNAL_CATEGORY *	pInternalCat;
	DWORD						dwRelativeID = 0;

	ASSERT(m_fInitialized);

	SetLastError(GATH_ERR_NOERROR);
	if (!m_fInitialized)
	{
		SetLastError(GATH_ERR_NOTINITIALIZED);
		return NULL;
	}

	// The first call to GetRelative will be using the root node, looking
	// for it's children. This is when we want to do all of the work we've
	// deferred, like creating the provider and loading the template files.

	if (m_fDeferredPending)
	{
		m_dwDeferredError = GATH_ERR_NOERROR;

		// Call GetProvider to connect to WBEM.

//		if (GetProvider() == NULL)
//			m_dwDeferredError = m_dwLastError;

		m_fDeferredPending = FALSE;
	}

	if (m_dwDeferredError != GATH_ERR_NOERROR)
		return NULL;

	// Look up the internal representation for the specified category.

	pInternalCat = GetInternalRep(dwID);
	if (pInternalCat == NULL)
	{
		SetLastError(GATH_ERR_BADCATEGORYID);
		return NULL;
	}

	// Then try to return the relative category, if there is one.

	switch (relative)
	{
	case PARENT:
		dwRelativeID = pInternalCat->m_dwParentID;
		break;
	case CHILD:
		dwRelativeID = pInternalCat->m_dwChildID;
		break;
	case NEXT_SIBLING:
		dwRelativeID = pInternalCat->m_dwNextID;
		break;
	case PREV_SIBLING:
		dwRelativeID = pInternalCat->m_dwPrevID;
		break;
	}

	if (pInternalCat && dwRelativeID)
		return BuildDataCategory(dwRelativeID);
	else
		return NULL;
}

//-----------------------------------------------------------------------------
// This method returns whether or not a specified category is dynamic. This
// can be determined by checking a flag.
//-----------------------------------------------------------------------------

BOOL CDataGatherer::IsCategoryDynamic(DWORD dwID)
{
	ASSERT(m_fInitialized);
	if (!m_fInitialized)
		return FALSE;

	INTERNAL_CATEGORY * pInternal = GetInternalRep(dwID);
	if (pInternal)
		return pInternal->m_fDynamic;
	return FALSE;
}

//-----------------------------------------------------------------------------
// This method returns whether or not a specified category has dynamic
// children. We need to use recursion to look at all the children, making
// this an expensive operation.
//
// TBD: compute this all in one pass and save it
// NOTE: currently we don't have dynamic categories
//-----------------------------------------------------------------------------

BOOL CDataGatherer::HasDynamicChildren(DWORD dwID, BOOL /* fRecursive */)
{
	if (dwID == 0)
		return FALSE;

	return FALSE;
}

//-----------------------------------------------------------------------------
// Get the count of columns from the internal representation - only count
// columns with the appropriate data complexity (BASIC or ADVANCED).
//-----------------------------------------------------------------------------

DWORD CDataGatherer::GetColumnCount(DWORD dwID)
{
	DWORD dwCount = 0;

	ASSERT(m_fInitialized);
	if (!m_fInitialized)
		return 0;

	if (GetLastError() || GetLastError(dwID))
		return 1;

	INTERNAL_CATEGORY * pInternal = GetInternalRep(dwID);
	ASSERT(pInternal && pInternal->m_fListView);
	if (pInternal && pInternal->m_fListView)
	{
		GATH_FIELD * pCol = pInternal->m_pColSpec;
		while (pCol)
		{
			if (m_complexity == ADVANCED || pCol->m_datacomplexity == BASIC)
				dwCount++;
			pCol = pCol->m_pNext;
		}
	}

	return dwCount;
}

//-----------------------------------------------------------------------------
// Get the count of rows from the internal representation - taking into
// account the data complexity.
//-----------------------------------------------------------------------------

DWORD CDataGatherer::GetRowCount(DWORD dwID)
{
	DWORD dwCount = 0;

	ASSERT(m_fInitialized);
	if (!m_fInitialized)
		return 0;

	if (GetLastError() || GetLastError(dwID))
		return 1;

	INTERNAL_CATEGORY * pInternal = GetInternalRep(dwID);
	ASSERT(pInternal && pInternal->m_fListView);

	if(NULL == pInternal)
		return 0;

	if (pInternal && pInternal->m_fListView)
	{
		for (int i = 0; i < (int)pInternal->m_dwLineCount; i++)
			if (m_complexity == ADVANCED || pInternal->m_apLines[i]->m_datacomplexity == BASIC)
				dwCount++;
	}

	// If the row count is zero, return a count of one instead. This allows us
	// to display a message for no data. This is not true if there are 
	// sub-categories for this category.

	if (dwCount == 0 && pInternal->m_dwChildID == 0)
		dwCount = 1;

	return dwCount;
}

//-----------------------------------------------------------------------------
// This method returns the data complexity (BASIC or ADVANCED) for a row.
//-----------------------------------------------------------------------------

BOOL CDataGatherer::GetRowDataComplexity(DWORD dwID, DWORD nRow, DataComplexity & complexity)
{
	DWORD dwCount = nRow;

	ASSERT(m_fInitialized);
	if (!m_fInitialized)
		return 0;

	INTERNAL_CATEGORY * pInternal = GetInternalRep(dwID);
	ASSERT(pInternal && pInternal->m_fListView);
	if (pInternal && pInternal->m_fListView)
	{
		// If there are no lines and we're be queried about the first line,
		// it means that information is being requested for the "no instances..."
		// message. Return as if it were BASIC information.

		if (nRow == 0 && pInternal->m_dwLineCount == 0)
		{
			complexity = BASIC;
			return TRUE;
		}

		for (int i = 0; i < (int)pInternal->m_dwLineCount; i++)
			if (m_complexity == ADVANCED || pInternal->m_apLines[i]->m_datacomplexity == BASIC)
			{
				if (dwCount == 0)
				{
					complexity = pInternal->m_apLines[i]->m_datacomplexity;
					return TRUE;
				}
				dwCount -= 1;
			}
	}

	return FALSE;
}

//-----------------------------------------------------------------------------
// Get the caption for the specified column. Stored in internal representation.
//-----------------------------------------------------------------------------

BOOL CDataGatherer::GetColumnCaption(DWORD dwID, DWORD nColumn, CString & strCaption)
{
	INTERNAL_CATEGORY *	pInternal = GetInternalRep(dwID);
	ASSERT(pInternal && pInternal->m_fListView);
	
	ASSERT(m_fInitialized);
	if (!m_fInitialized)
		return FALSE;

	if (GetLastError() || GetLastError(dwID))
	{
		AFX_MANAGE_STATE(AfxGetStaticModuleState());
		strCaption.LoadString(IDS_DESCRIPTION);
		return TRUE;
	}

	// The column caption is a refreshed value (not something read from the
	// template file). We need to look it up in the array of refreshed
	// column headers.

	if (pInternal && pInternal->m_fListView)
		if (nColumn < pInternal->m_dwColCount)
		{
			// Get the actual index for the column information. This may be
			// higher than the index parameter, if we are currently showing
			// BASIC information (we need to skip over advanced columns).

			DWORD nActualColumn = 0;

			if (m_complexity == BASIC)
			{
				GATH_FIELD *	pCol = pInternal->m_pColSpec;
				int				iCount = (int) nColumn;

				do
				{
					// Skip over any advanced categories.

					while (pCol && pCol->m_datacomplexity == ADVANCED)
					{
						pCol = pCol->m_pNext;
						nActualColumn++;
					}

					iCount--;
					nActualColumn++;
					pCol = pCol->m_pNext;
				} while (pCol && (iCount >= 0));

				if (iCount >= 0)
					return FALSE;
				else
					nActualColumn--; // we went one too far
			}
			else
				nActualColumn = nColumn;

			strCaption = pInternal->m_aCols[nActualColumn].m_strText;
			return TRUE;
		}

	return FALSE;
}

//-----------------------------------------------------------------------------
// Return the width of the specified column. Stored in internal representation.
//-----------------------------------------------------------------------------

BOOL CDataGatherer::GetColumnWidth(DWORD dwID, DWORD nColumn, DWORD &cxWidth)
{
	ASSERT(m_fInitialized);
	if (!m_fInitialized)
		return FALSE;

	if (GetLastError() || GetLastError(dwID))
	{
		cxWidth = 600;
		return TRUE;
	}

	GATH_FIELD * pField = GetColumnField(dwID, nColumn);
	if (pField)
	{
		cxWidth = pField->m_usWidth;
		return TRUE;
	}
	return FALSE;
}

//-----------------------------------------------------------------------------
// This method returns how a specified column should be sorted.
//-----------------------------------------------------------------------------

BOOL CDataGatherer::GetColumnSort(DWORD dwID, DWORD nColumn, MSIColumnSortType & sorttype)
{
	ASSERT(m_fInitialized);
	if (!m_fInitialized)
		return FALSE;

	if (GetLastError() || GetLastError(dwID))
	{
		sorttype = NOSORT;
		return TRUE;
	}

	GATH_FIELD * pField = GetColumnField(dwID, nColumn);
	if (pField)
	{
		sorttype = pField->m_sort;
		return TRUE;
	}
	return FALSE;
}

//-----------------------------------------------------------------------------
// This method returns the data complexity (BASIC or ADVANCED) for a column.
//-----------------------------------------------------------------------------

BOOL CDataGatherer::GetColumnDataComplexity(DWORD dwID, DWORD nColumn, DataComplexity & complexity)
{
	ASSERT(m_fInitialized);
	if (!m_fInitialized)
		return FALSE;

	if (GetLastError() || GetLastError(dwID))
	{
		complexity = BASIC;
		return TRUE;
	}

	GATH_FIELD * pField = GetColumnField(dwID, nColumn);
	if (pField)
	{
		complexity = pField->m_datacomplexity;
		return TRUE;
	}
	return FALSE;
}

//-----------------------------------------------------------------------------
// This (private) method is used to get the internal field representation
// of the specified column.
//-----------------------------------------------------------------------------

GATH_FIELD * CDataGatherer::GetColumnField(DWORD dwID, DWORD nColumn)
{
	INTERNAL_CATEGORY * pInternal = GetInternalRep(dwID);
	ASSERT(pInternal && pInternal->m_fListView);
	
	if (pInternal && pInternal->m_fListView)
	{
		// We need to scan the collection of column fields to find the requested one.

		GATH_FIELD *	pField = pInternal->m_pColSpec;
		DWORD				dwIndex = nColumn;

		while (pField)
		{
			if (m_complexity == ADVANCED || pField->m_datacomplexity == BASIC)
			{
				if (dwIndex <= 0)
					return pField;
				dwIndex--;
			}
			pField = pField->m_pNext;
		}
	}

	return NULL;
}

//-----------------------------------------------------------------------------
// This method returns the value for a specified row and column number,
// in both string and DWORD format.
//-----------------------------------------------------------------------------

BOOL CDataGatherer::GetValue(DWORD dwID, DWORD nRow, DWORD nColumn, CString &strValue, DWORD &dwValue)
{
	ASSERT(m_fInitialized);
	if (!m_fInitialized)
		return FALSE;

	if (GetLastError() || GetLastError(dwID))
	{
		if (nRow == 0 && nColumn == 0)
		{
			if (GetLastError())
				strValue = GetErrorText();
			else
				strValue = GetErrorText(dwID);
		}
		else
			strValue.Empty();
		return TRUE;
	}

	INTERNAL_CATEGORY * pInternal = GetInternalRep(dwID);
	ASSERT(pInternal && pInternal->m_fListView);
	
	if (pInternal && pInternal->m_fListView)
	{
		if (nRow == 0 && pInternal->m_dwLineCount == 0)
		{
			// Return the string from the template file for "no instances",
			// for the first column.

			if (nColumn == 0)
				strValue = pInternal->m_strNoInstances;
			else
				strValue.Empty();
			return TRUE;
		}

		// Otherwise, look up the cached value. First get the real row and
		// column indices, which might be different from the specified
		// indices (because of the BASIC/ADVANCED issue).

		int iActualRow = 0;
		int iActualCol = 0;

		// Get the actual row index.

		if (m_complexity == BASIC)
		{
			int iCount = (int) nRow;

			do
			{
				// Skip over any advanced rows.

				while (iActualRow < (int)pInternal->m_dwLineCount && pInternal->m_apLines[iActualRow]->m_datacomplexity == ADVANCED)
					iActualRow++;

				iCount -= 1;
				iActualRow += 1;
			} while ((iActualRow < (int)pInternal->m_dwLineCount) && (iCount >= 0));

			if (iCount >= 0)
				return FALSE;
			else
				iActualRow -= 1; // we went one too far
		}
		else
			iActualRow = nRow;

		// Get the actual column index.

		if (m_complexity == BASIC)
		{
			GATH_FIELD *	pCol = pInternal->m_pColSpec;
			int				iCount = (int) nColumn;

			do
			{
				// Skip over any advanced columns.

				while (pCol && pCol->m_datacomplexity == ADVANCED)
				{
					pCol = pCol->m_pNext;
					iActualCol++;
				}

				iCount--;
				iActualCol++;
				pCol = pCol->m_pNext;
			} while (pCol && (iCount >= 0));

			if (iCount >= 0)
				return FALSE;
			else
				iActualCol--; // we went one too far
		}
		else
			iActualCol = nColumn;

		// Retrieve the data using the actual indices.

		if (iActualRow >= 0 && iActualRow < (int)pInternal->m_dwLineCount)
			if (iActualCol >= 0 && iActualCol < (int)pInternal->m_dwColCount)
			{
				strValue = pInternal->m_apLines[iActualRow]->m_aValue[iActualCol].m_strText;
				dwValue  = pInternal->m_apLines[iActualRow]->m_aValue[iActualCol].m_dwValue;
				return TRUE;
			}
	}

	return FALSE;
}

//=============================================================================
// Functions used internally to CDataGatherer, or by other friend classes.
//=============================================================================

//-----------------------------------------------------------------------------
// This methods deletes all of the internal category representations
// and empties the map.
//-----------------------------------------------------------------------------

void CDataGatherer::RemoveAllCategories()
{
	INTERNAL_CATEGORY *	pInternalCat;
	WORD						key;

	ASSERT(m_fInitialized);
	if (!m_fInitialized)
		return;

	for (POSITION pos = m_mapCategories.GetStartPosition(); pos != NULL;)
	{
		m_mapCategories.GetNextAssoc(pos, key, (void * &) pInternalCat);
		ASSERT(pInternalCat);
		if (pInternalCat)
			delete pInternalCat;
	}
	m_mapCategories.RemoveAll();

	// Reset the root ID. Don't reset the next free ID, because we don't want
	// the IDs to overlap during the lifetime of the object (otherwise some
	// categories passed out might refer to the wrong internal category).

	m_dwRootID = 0;
}

//-----------------------------------------------------------------------------
// This method is used to return a pointer to the internal representation of
// the category.
//-----------------------------------------------------------------------------

INTERNAL_CATEGORY * CDataGatherer::GetInternalRep(DWORD dwID)
{
	INTERNAL_CATEGORY * pInternalCat;

	ASSERT(m_fInitialized);
	if (!m_fInitialized)
		return NULL;

	if (m_mapCategories.Lookup((WORD) dwID, (void * &) pInternalCat))
	{
		ASSERT(pInternalCat && pInternalCat->m_dwID == dwID);
		return pInternalCat;
	}
	else
	{
		ASSERT(FALSE);
		return NULL;
	}
}

//-----------------------------------------------------------------------------
// Return the CDataProvider object (well, a pointer to the object). If there
// isn't one yet, then create one.
//-----------------------------------------------------------------------------

CDataProvider * CDataGatherer::GetProvider()
{
	ASSERT(m_fInitialized);
	if (!m_fInitialized)
		return NULL;

	if (m_pProvider == NULL)
	{
		// If the m_pProvider member is NULL, then we need to create a new one.
		// Create the provider for the value stored in the deferred provider. If
		// it is set, then we are doing the deferred creation of a provider for
		// another machine. If it's empty, we're looking at the local machine.
		// If the Create fails, it will call SetLastError saying why.

		m_pProvider = new CDataProvider;
		if (m_pProvider == NULL)
			SetLastError(GATH_ERR_ALLOCATIONFAILED);

		if (!m_pProvider->Create(m_strDeferredProvider, this))
		{
			delete m_pProvider;
			m_pProvider = NULL;
		}
	}

	return m_pProvider;
}

//-----------------------------------------------------------------------------
// This method resets the internal refreshed flag. It's called if the provider
// is pointed to a different computer, for example, to make each category get
// fresh data to display.
//-----------------------------------------------------------------------------

void CDataGatherer::ResetCategoryRefresh()
{
	INTERNAL_CATEGORY *	pInternalCat;
	WORD				key;

	for (POSITION pos = m_mapCategories.GetStartPosition(); pos != NULL;)
	{
		m_mapCategories.GetNextAssoc(pos, key, (void * &) pInternalCat);
		ASSERT(pInternalCat);
		if (pInternalCat)
			pInternalCat->m_fRefreshed = FALSE;
	}
}

//-----------------------------------------------------------------------------
// This method is used to refresh the contents of the internal category struct.
// Doing this means refreshing the category name, its columns, and building
// a list of lines based on the list of line specifiers in the category.
//-----------------------------------------------------------------------------

BOOL CDataGatherer::RefreshCategory(DWORD dwID, BOOL fRecursive, volatile BOOL *pfCancel, BOOL fSoftRefresh)
{
	INTERNAL_CATEGORY *	pInternal = GetInternalRep(dwID);

	ASSERT(m_fInitialized);
	if (!m_fInitialized)
		return FALSE;

	if (pInternal == NULL)
		return FALSE;

	// Check to see if the refresh operation has been cancelled.

	if (pfCancel && *pfCancel == TRUE)
	{
		TRACE0("-- CDataGatherer::RefreshCategory() refresh cancelled by caller\n");
		return FALSE;
	}

	// If this is the first call to this recursive function, reset the
	// cache of WBEM enumerator pointers.

	if (m_cInRefresh == 0 && m_pProvider)
		m_pProvider->m_enumMap.Reset();
	m_cInRefresh++;

	if (m_pProvider)
		m_pProvider->m_dwRefreshingCategoryID = dwID;

	// Remove the cached items in the CDataProvider object.

	if (m_pProvider)
		m_pProvider->ClearCache();

	// If this is a soft refresh, and this category has been refreshed at least once,
	// skip the refresh operation. An example of a soft refresh would be the user
	// clicking on the category for the first time, where we would want to skip the
	// refresh if a global refresh had been done previously.

	if (!pInternal->m_fRefreshed || !fSoftRefresh)
	{
		if (!CRefreshFunctions::RefreshColumns(this, pInternal))
		{
			TRACE0("-- CDataGatherer::RefreshCategory() failed at RefreshColumns\n");
			m_cInRefresh--;
			if (m_pProvider)
				m_pProvider->m_dwRefreshingCategoryID = 0;
			return FALSE; // RefreshValue will set last error
		}

		// The RefreshLines function returns a CPtrList of pointers to line structures. These
		// pointers need to be copied to the pInternal->m_apLines array.

		CPtrList listLinePtrs;
		if (CRefreshFunctions::RefreshLines(this, pInternal->m_pLineSpec, pInternal->m_dwColCount, listLinePtrs, pfCancel))
		{
			if (pInternal->m_apLines && pInternal->m_dwLineCount)
			{
				for (DWORD dwIndex = 0; dwIndex < pInternal->m_dwLineCount; dwIndex++)
					delete pInternal->m_apLines[dwIndex];
				delete [] pInternal->m_apLines;
			}

			// Move the contents of listLinePtrs to the array of line pointers in the internal struct.

			pInternal->m_dwLineCount = (DWORD) listLinePtrs.GetCount();
			if (pInternal->m_dwLineCount)
			{
				pInternal->m_apLines = new GATH_LINE *[pInternal->m_dwLineCount];
				if (pInternal->m_apLines)
				{
					DWORD dwIndex = 0;
					for (POSITION pos = listLinePtrs.GetHeadPosition(); pos != NULL;)
					{
						ASSERT(dwIndex < (DWORD) listLinePtrs.GetCount());
						pInternal->m_apLines[dwIndex] = (GATH_LINE *) listLinePtrs.GetNext(pos);
						dwIndex++;
					}
				}
				else
				{
					// If there was an error, we need to deallocate the lines.

					GATH_LINE * pLine;
					for (POSITION pos = listLinePtrs.GetHeadPosition(); pos != NULL;)
					{
						pLine = (GATH_LINE *) listLinePtrs.GetNext(pos) ;
						if (pLine)
							delete pLine;
					}

					TRACE0("-- CDataGatherer::RefreshCategory() failed allocating m_apLines\n");
					SetLastError(GATH_ERR_ALLOCATIONFAILED);
					m_cInRefresh--;
					if (m_pProvider)
						m_pProvider->m_dwRefreshingCategoryID = 0;
					return FALSE;
				}
			}

			pInternal->m_fRefreshed = TRUE;
		}
		else
		{
			TRACE0("-- CDataGatherer::RefreshCategory() failed at RefreshLines\n");
			m_cInRefresh--;
			if (m_pProvider)
				m_pProvider->m_dwRefreshingCategoryID = 0;
			return FALSE; // RefreshLines will set last error
		}
	}

	if (fRecursive)
	{
		INTERNAL_CATEGORY *	pChild;
		DWORD				dwChildID = pInternal->m_dwChildID; 

		while (dwChildID)
		{
			if (!RefreshCategory(dwChildID, TRUE, pfCancel))
			{
				m_cInRefresh--;
				if (m_pProvider)
					m_pProvider->m_dwRefreshingCategoryID = 0;
				return FALSE;
			}
			pChild = GetInternalRep(dwChildID);
			if (pChild)
				dwChildID = pChild->m_dwNextID;
			else
				break;
		}
	}
	else
	{
		// Even if we aren't recursive, we should refresh the names of the sub
		// categories, since they might be enumerated before they are refreshed.

		INTERNAL_CATEGORY *	pChild;
		DWORD				dwChildID = pInternal->m_dwChildID; 

		while (dwChildID)
		{
			pChild = GetInternalRep(dwChildID);
			if (pChild)
			{
				if (!CRefreshFunctions::RefreshValue(this, &pChild->m_categoryName, &pChild->m_fieldName))
				{
					m_cInRefresh--;
					if (m_pProvider)
						m_pProvider->m_dwRefreshingCategoryID = 0;
					return FALSE;
				}
				dwChildID = pChild->m_dwNextID;
			}
			else
				break;
		}
	}

	m_cInRefresh--;
	if (m_pProvider)
		m_pProvider->m_dwRefreshingCategoryID = 0;
	return TRUE;
}

//-----------------------------------------------------------------------------
// Sets the last error (the value returned by GetLastError) to the specified
// DWORD value.
//-----------------------------------------------------------------------------

void CDataGatherer::SetLastError(DWORD dwError)
{
	// Making a change - disable all of the error reset calls (a few will
	// be done explicitly.

	if (dwError != GATH_ERR_NOERROR)
		m_dwLastError = dwError;

#ifdef _DEBUG
	if (dwError) 
		TRACE1("-- SetLastError(0x%08x)\n", dwError);
#endif
}

void CDataGatherer::SetLastError(DWORD dwError, DWORD dwID)
{
	if (dwError != GATH_ERR_NOERROR)
	{
		INTERNAL_CATEGORY * pInternal = GetInternalRep(dwID);
		ASSERT(pInternal);
		if (pInternal)
			pInternal->m_dwLastError = dwError;
	}

#ifdef _DEBUG
	if (dwError) 
		TRACE2("-- SetLastError(0x%08x, %d)\n", dwError, dwID);
#endif
}

//-----------------------------------------------------------------------------
// Sets the error flag based on an HRESULT returned value.
//-----------------------------------------------------------------------------

void CDataGatherer::SetLastErrorHR(HRESULT hrError)
{
	DWORD dwError;

	switch (hrError)
	{
	case WBEM_E_OUT_OF_MEMORY:
		dwError = GATH_ERR_NOWBEMOUTOFMEM;
		break;

	case WBEM_E_ACCESS_DENIED:
		dwError = GATH_ERR_NOWBEMACCESSDENIED;
		break;

	case WBEM_E_INVALID_NAMESPACE:
		dwError = GATH_ERR_NOWBEMBADSERVER;
		break;

	case WBEM_E_TRANSPORT_FAILURE:
		dwError = GATH_ERR_NOWBEMNETWORKFAILURE;
		break;

	case WBEM_E_FAILED:
	case WBEM_E_INVALID_PARAMETER:
	default:
		dwError = GATH_ERR_NOWBEMCONNECT;
	}

	SetLastError(dwError);
}

void CDataGatherer::SetLastErrorHR(HRESULT hrError, DWORD dwID)
{
	DWORD dwError;

	switch (hrError)
	{
	case WBEM_E_OUT_OF_MEMORY:
		dwError = GATH_ERR_NOWBEMOUTOFMEM;
		break;

	case WBEM_E_ACCESS_DENIED:
		dwError = GATH_ERR_NOWBEMACCESSDENIED;
		break;

	case WBEM_E_INVALID_NAMESPACE:
		dwError = GATH_ERR_NOWBEMBADSERVER;
		break;

	case WBEM_E_TRANSPORT_FAILURE:
		dwError = GATH_ERR_NOWBEMNETWORKFAILURE;
		break;

	case WBEM_E_FAILED:
	case WBEM_E_INVALID_PARAMETER:
	default:
		dwError = GATH_ERR_NOWBEMCONNECT;
	}

	SetLastError(dwError, dwID);
}

//-----------------------------------------------------------------------------
// Resets the error flag to a no error state (added because SetLastError no
// longer allows this).
//-----------------------------------------------------------------------------

void CDataGatherer::ResetLastError()
{
	m_dwLastError = GATH_ERR_NOERROR;
}

//-----------------------------------------------------------------------------
// Return a text representation of the error for display.
//-----------------------------------------------------------------------------

CString CDataGatherer::GetErrorText()
{
	CString strErrorText(_T(""));
	CString strMachine(m_strDeferredProvider);

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	switch (m_dwLastError) 
	{
	case GATH_ERR_ALLOCATIONFAILED:
	case GATH_ERR_NOWBEMOUTOFMEM:
		strErrorText.LoadString(IDS_OUTOFMEMERROR);
		break;
	case GATH_ERR_NOWBEMLOCATOR:
		strErrorText.LoadString(IDS_NOLOCATOR);
		break;
	case GATH_ERR_NOWBEMCONNECT:
		strErrorText.Format(IDS_NOGATHERER, strMachine);
		break;
	case GATH_ERR_NOWBEMACCESSDENIED:
		strErrorText.Format(IDS_GATHERACCESS, strMachine);
		break;
	case GATH_ERR_NOWBEMBADSERVER:
		strErrorText.Format(IDS_BADSERVER, strMachine);
		break;
	case GATH_ERR_NOWBEMNETWORKFAILURE:
		strErrorText.Format(IDS_NETWORKERROR, strMachine);
		break;
	default:
	case GATH_ERR_BADCATEGORYID:
		strErrorText.LoadString(IDS_UNEXPECTED);
		break;
	}

	return strErrorText;
}

CString CDataGatherer::GetErrorText(DWORD dwID)
{
	CString strErrorText(_T(""));
	CString strMachine(m_strDeferredProvider);

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	INTERNAL_CATEGORY * pInternal = GetInternalRep(dwID);
	ASSERT(pInternal);
	if (pInternal)
	{
		switch (pInternal->m_dwLastError) 
		{
		case GATH_ERR_ALLOCATIONFAILED:
		case GATH_ERR_NOWBEMOUTOFMEM:
			strErrorText.LoadString(IDS_OUTOFMEMERROR);
			break;
		case GATH_ERR_NOWBEMLOCATOR:
			strErrorText.LoadString(IDS_NOLOCATOR);
			break;
		case GATH_ERR_NOWBEMCONNECT:
			strErrorText.Format(IDS_NOGATHERER, strMachine);
			break;
		case GATH_ERR_NOWBEMACCESSDENIED:
			strErrorText.Format(IDS_GATHERACCESS, strMachine);
			break;
		case GATH_ERR_NOWBEMBADSERVER:
			strErrorText.Format(IDS_BADSERVER, strMachine);
			break;
		case GATH_ERR_NOWBEMNETWORKFAILURE:
			strErrorText.Format(IDS_NETWORKERROR, strMachine);
			break;
		default:
		case GATH_ERR_BADCATEGORYID:
			strErrorText.LoadString(IDS_UNEXPECTED);
			break;
		}
	}

	return strErrorText;
}

//-----------------------------------------------------------------------------
// This method is used to construct a CDataCategory object for the passed ID.
// The caller is responsible for ultimately deallocating the object. We use
// the m_mapCategories to retrieve an internal representation of the category,
// construct a CDataCategory object and set it up to refer the this category.
//-----------------------------------------------------------------------------

CDataCategory * CDataGatherer::BuildDataCategory(DWORD dwID)
{
	CDataCategory *		pReturnCategory;
	INTERNAL_CATEGORY *	pInternalCat;

	ASSERT(m_fInitialized);
	ASSERT(dwID != 0);

	SetLastError(GATH_ERR_NOERROR);
	if (!m_fInitialized)
	{
		SetLastError(GATH_ERR_NOTINITIALIZED);
		return FALSE;
	}

	// First, try to look up an internal category representation of the category.

	if (!m_mapCategories.Lookup((WORD) dwID, (void * &) pInternalCat))
	{
		SetLastError(GATH_ERR_BADCATEGORYID);
		return NULL;
	}
	
	ASSERT(pInternalCat);
	if (pInternalCat == NULL)
		return NULL; // might be that this category was hidden

	// Create the object to return (either a CDataCategory or CDataListCategory,
	// depending on the information in pInternalCat).

	if (pInternalCat->m_fListView)
		pReturnCategory = (CDataCategory *) new CDataListCategory;
	else
		pReturnCategory = new CDataCategory;

	if (pReturnCategory == NULL)
	{
		SetLastError(GATH_ERR_ALLOCATIONFAILED);
		return NULL;
	}

	// All the external category theoretically needs is a pointer to this object
	// and its ID number.

	pReturnCategory->m_pGatherer = this;
	pReturnCategory->m_dwID = dwID;

	return pReturnCategory;
}

//-----------------------------------------------------------------------------
// Recursive method used internally to find a category path based on a
// category identifier.
//-----------------------------------------------------------------------------

BOOL CDataGatherer::FindCategoryByIdentifer(const CString & strIdentifier, CString & strPath, DWORD dwID)
{
	INTERNAL_CATEGORY *	pInternalCat;

	// Look up the internal representation for the specified category.

	pInternalCat = GetInternalRep(dwID);

	// If this category is the one we're looking for, add the name to the
	// path variable and return true.

	if (strIdentifier.CompareNoCase(pInternalCat->m_strIdentifier) == 0)
	{
		if (!strPath.IsEmpty())
			strPath += CString(_T("\\"));
		strPath += pInternalCat->m_categoryName.m_strText;
		return TRUE;
	}
	
	// Otherwise, look through the children.

	DWORD dwChildID = pInternalCat->m_dwChildID;
	while (dwChildID)
	{
		if (FindCategoryByIdentifer(strIdentifier, strPath, dwChildID))
			return TRUE;
		dwChildID = pInternalCat->m_dwNextID;
	}

	return FALSE;
}

//-----------------------------------------------------------------------------
// This method is used to convert a string path (category names, starting at
// the root category, delimited by backslashes) into the ID for the category.
//-----------------------------------------------------------------------------

DWORD CDataGatherer::FindCategoryByPath(const CString & strPath)
{
	INTERNAL_CATEGORY *	pInternalCat;
	CString					strWorkingPath(strPath), strNextCategory;
	DWORD						dwID = 0, dwSearchID, dwCurrentID = 0;

	while (!strWorkingPath.IsEmpty())
	{
		GetToken(strNextCategory, strWorkingPath, _T('\\'));

		// Look for the child of the current category to match the name. If the
		// current category ID is zero, make sure the root category name matches.

		if (dwCurrentID == 0)
		{
			pInternalCat = GetInternalRep(m_dwRootID);
			if (pInternalCat == NULL || pInternalCat->m_categoryName.m_strText.CompareNoCase(strNextCategory))
				return 0;
			dwCurrentID = m_dwRootID;
		}
		else
		{
			// Start looking through the children of the current node. 

			ASSERT(pInternalCat && pInternalCat->m_dwID == dwCurrentID);
			dwSearchID = pInternalCat->m_dwChildID;
			while (dwSearchID)
			{
				pInternalCat = GetInternalRep(dwSearchID);
				if (pInternalCat == NULL)
					return 0;

				if (pInternalCat->m_categoryName.m_strText.CompareNoCase(strNextCategory) == 0)
					break;

				dwSearchID = pInternalCat->m_dwNextID;
			}

			if (dwSearchID == 0)
				return 0;
			else
				dwCurrentID = dwSearchID;
		}
	}
		
	return dwCurrentID;
}

//-----------------------------------------------------------------------------
// This method searches the specified category and all of it's children
// for a string. It starts from the iLineth line. If a match is found, the
// line number and path to the category where the match was made are set,
// and we return TRUE.
//-----------------------------------------------------------------------------

BOOL CDataGatherer::RecursiveFind(INTERNAL_CATEGORY * pCat, MSI_FIND_STRUCT *pFind, int & iLine, CString & strPath)
{
	ASSERT(pCat);
	ASSERT(pFind);

	// Look through the lines in the current category for a match with strSearch.
	// Note: only look through lines and columns with the appropriate complexity
	// (BASIC or ADVANCED). The line number should take this into account as well.

	int		iResultLine = 0, iCurrentLine = 0;
	CString	strValue;

	// A line number of -1 indicates that we should check the category name.

	if (iLine == -1)
	{
		strValue = pCat->m_categoryName.m_strText;
		if (!pFind->m_fCaseSensitive)
			strValue.MakeUpper();

		if (strValue.Find(pFind->m_strSearch) != -1)
		{
			GetCategoryPath(pCat, strPath);
			return TRUE;
		}

		iLine = 0;
	}

	// Otherwise, look through lines for this category.

	if (pFind->m_fSearchData && pCat->m_fListView)
	{
		// We need to search the message which is displayed when there is no
		// data as well (searching a saved file does this).
		
		if (pCat->m_dwLineCount == 0)
		{
			if (iLine == 0)
			{
				strValue = pCat->m_strNoInstances;
				if (!pFind->m_fCaseSensitive)
					strValue.MakeUpper();

				if (strValue.Find(pFind->m_strSearch) != -1)
				{
					iLine = 0;
					GetCategoryPath(pCat, strPath);
					return TRUE;
				}
			}
		}
		else
		{
			// This category does have data - search through it.

			while (iCurrentLine < (int)pCat->m_dwLineCount)
			{
				// Check to see if the Find has been cancelled.

				if (pFind->m_pfCancel && *pFind->m_pfCancel)
					return FALSE;

				if (m_complexity == ADVANCED || pCat->m_apLines[iCurrentLine]->m_datacomplexity == BASIC)
				{
					// Search through the columns of data for a match. Start looking only after
					// we've skipped any lines indicated by the iLine parameter.

					if (iResultLine >= iLine)
					{
						GATH_FIELD *	pCol = pCat->m_pColSpec;
						int				iCurrentCol = 0;

						while (pCol)
						{
							if (m_complexity == ADVANCED || pCol->m_datacomplexity == BASIC)
							{
								strValue = pCat->m_apLines[iCurrentLine]->m_aValue[iCurrentCol].m_strText;
								if (!pFind->m_fCaseSensitive)
									strValue.MakeUpper();

								if (strValue.Find(pFind->m_strSearch) != -1)
								{
									iLine = iResultLine;
									GetCategoryPath(pCat, strPath);
									return TRUE;
								}
							}

							pCol = pCol->m_pNext;
							iCurrentCol++;
						}
					}
					iResultLine++;
				}
				iCurrentLine++;
			}
		}
	}

	// No matches were found. Search through the children of this category for a 
	// match. Create a temporary path and line variable to pass to the children.

	CString					strTempPath;
	int						iTempLine;
	INTERNAL_CATEGORY *	pChildCat;

	DWORD dwChildID = pCat->m_dwChildID;
	while (dwChildID)
	{
		pChildCat = GetInternalRep(dwChildID);
		if (pChildCat)
		{
			iTempLine = (pFind->m_fSearchCategories) ? -1 : 0;
			if (RecursiveFind(pChildCat, pFind, iTempLine, strTempPath))
			{
				strPath = strTempPath;
				iLine = iTempLine;
				return TRUE;
			}

			dwChildID = pChildCat->m_dwNextID;
		}
		else
			dwChildID = 0;
	}

	return FALSE;
}

//-----------------------------------------------------------------------------
// Return the path of category names to get from the root category to this
// category, separated by backslashes.
//-----------------------------------------------------------------------------

void CDataGatherer::GetCategoryPath(INTERNAL_CATEGORY * pCat, CString & strPath)
{
	INTERNAL_CATEGORY *	pParent;
	CString					strWorking;

	pParent = pCat;
	while (pParent)
	{
		if (!strWorking.IsEmpty())
			strWorking = CString(_T("\\")) + strWorking;
		strWorking = pParent->m_categoryName.m_strText + strWorking;

		if (pParent->m_dwParentID)
			pParent = GetInternalRep(pParent->m_dwParentID);
		else
			break;
	}
	
	ASSERT(pParent); // if not set we tried to get a ptr for a bad ID, or bad param
	strPath = strWorking;
}

//-----------------------------------------------------------------------------
// Determine is the passed category pointer is a child category of the passed
// category path. Do this by using the pointer to get a category path, and
// doing a string search for the parent (the parent path will be in any child's
// path).
//-----------------------------------------------------------------------------

BOOL CDataGatherer::IsChildPath(INTERNAL_CATEGORY * pInternalCat, const CString & strParentPath)
{
	CString	strParent, strChild;

	GetCategoryPath(pInternalCat, strChild);
	strParent = strParentPath;

	strParent.MakeUpper();
	strChild.MakeUpper();

	return (strChild.Find(strParent) != -1 && strChild.Compare(strParent) != 0);
}

//-----------------------------------------------------------------------------
// Dump out the contents of the CDataGatherer object (DEBUG only).
//-----------------------------------------------------------------------------

#ifdef _DEBUG
void CDataGatherer::Dump()
{
	ASSERT(m_fInitialized);
	if (!m_fInitialized)
		return;

	TRACE0("Dumping CDataGatherer object...\n");
	TRACE1("  m_fInitialized = %s\n", (m_fInitialized ? "TRUE" : "FALSE"));
	TRACE1("  m_dwNextFreeID = %ld\n", m_dwNextFreeID);
	TRACE1("  m_dwRootID = %ld\n", m_dwRootID);

	INTERNAL_CATEGORY * pCat = GetInternalRep(m_dwRootID);
	if (pCat)
		pCat->DumpCategoryRecursive(4, this);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\gather.h ===
//=============================================================================
// File:			gather.h
// Author:		a-jammar
// Covers:		CDataGatherer, CDataCategory, CDataListCategory
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// This header file defines the interface between the data gathering portion
// of MSInfo and the code which implements the user interface and MMC snap-in
// code. The data gathering functionality is broken up into three classes.
// The CDataGatherer object is created first and given a template file
// describing the categories and a string indicating the computer from which
// information should be gathered. A member function (GetRootDataCategory) is
// called to return a pointer to a CDataCategory or CDataListCategory object.
// The CDataCategory class implements basic category behavior like getting
// the category name, refreshing the category, and find child or sibling
// categories. CDataListCategory is derived from CDataCategory, and implement
// behavior specific to a category showing a list view, such as getting a row
// count and returning text for a specific column and row.
//
// This header file also defines error codes returned by the classes.
//=============================================================================

#pragma once
#include <afxcmn.h>

// This enumeration is used to indicate how a column in a CDataListCategory
// should be sorted. NOSORT indicates that sorting by that column should not
// be allowed. LEXICAL means to use a standard string sorting (built into
// the list view). BYVALUE means to sort by the DWORD value returned by
// the CDataListCategory::GetValue member function. Note: this type is
// defined here rather than inside the CDataListCategory class because the
// type is used by multiple classes.

enum MSIColumnSortType { NOSORT, LEXICAL, BYVALUE };

// Another enumeration used by multiple classes, this one specified the
// complexity of data (the level of complexity can be controlled by the user).

enum DataComplexity { BASIC, ADVANCED };

// The following structure is used as a parameter in CDataGatherer::Find().
// The m_strPath parameter identifies a node in the namespace using a 
// backslash delimited path (starting at the root node) of category 
// names to the specific node.

struct MSI_FIND_STRUCT
{
	CString	m_strSearch;			// [IN] string to search for, Find() may change
	CString	m_strParentPath;		// [IN] if not empty, don't search above this in tree
	BOOL		m_fCaseSensitive;		// [IN] if TRUE, do case sensitive search
	BOOL		m_fSearchData;			// [IN] if TRUE, search data items
	BOOL		m_fSearchCategories;	// [IN] if TRUE, search category names
	volatile BOOL *m_pfCancel;		// [IN] if not NULL, monitor for TRUE value and cancel

	CString	m_strPath;				// [IN/OUT] path to category to start search
	int		m_iLine;					// [IN/OUT] line # to start search, -1 for cat name

	BOOL		m_fFound;				// [OUT] m_strPath & m_iLine tell where
	BOOL		m_fNotFound;			// [OUT] couldn't find the string
	BOOL		m_fCancelled;			// [OUT] *m_pCancel set to TRUE, find cancelled
};

// Forward declarations.

class  CDataCategory;
class  CTemplateFile;
class  CRefreshFunctions;
class  CDataProvider;
struct INTERNAL_CATEGORY;
struct GATH_FIELD;

//-----------------------------------------------------------------------------
// CDataGatherer
//
// This class encapsulates the data gathering used in the MSInfo snap-in.
// Typically one object of this type would be created and passed a template
// file. The template file would specify what information is to be shown,
// This object could then be used to get the root data category.
//-----------------------------------------------------------------------------

extern DWORD WINAPI ThreadRefresh(void * pArg);
class CDataGatherer
{
friend class CDataCategory;
friend class CDataListCategory;
friend class CTemplateFileFunctions;
friend class CRefreshFunctions;
friend class CDataProvider;
friend struct INTERNAL_CATEGORY;
friend DWORD WINAPI ThreadRefresh(void * pArg);
public:
	CDataGatherer();
	~CDataGatherer();

	// Creation functions, allowing various combinations of specifying a
	// template file and a machine on the network to gather info for. 
	// No machine name means that the local machine is used. No template
	// file results in no categories.

	BOOL Create(LPCTSTR szMachine = NULL);

	// Set a different network machine.

	BOOL SetConnect(LPCTSTR szMachine = NULL);

	// Method to refresh the gathered information. Also, a method to set the
	// complexity of the information displayed to the user.

	BOOL Refresh(volatile BOOL *pfCancel = NULL);
	BOOL SetDataComplexity(DataComplexity complexity = BASIC);
	void ResetCategoryRefresh();

	// This function is used to control what data categories are actually
	// shown or saved by this gatherer.

	BOOL SetCategories(const CString & strCategory) { m_strCategory = strCategory; return TRUE; };
	
	// The following method is used to retrieve the root category. It will
	// allocate a new category and return a pointer to it. The caller is
	// responsible for deallocating the category.

	CDataCategory * GetRootDataCategory();

	// The following methods are used to find specific nodes in the
	// category tree. GetCategoryPath returns a backslash delimited path
	// (starting at the root node) of category names to the node identified
	// by strIdentifier. IsChildPath is used to determine if the passed
	// category pointer is a child category of the passed category path.

	BOOL	GetCategoryPath(const CString & strIdentifier, CString & strPath);
	BOOL	IsChildPath(INTERNAL_CATEGORY * pInternalCat, const CString & strParentPath);

	// Find is used to search for a specific string in the category names
	// or data. The MSI_FIND_STRUCT contains information about the find,
	// including where to start the search. Find may be used as a find
	// next by using the last matched location and incrementing the line number.
	// If Find returns TRUE, information about the search can be read from the
	// struct. If it returns FALSE, and error occurred and the struct is invalid.

	BOOL	Find(MSI_FIND_STRUCT *pFind);

	// This method is used to get more information about the last error
	// in a gatherer or category member function call. This will return
	// an error code, or zero for OK. Note that a successful method
	// call will reset the value returned by this method.

	DWORD GetLastError();
	DWORD GetLastError(DWORD dwID);

	// This is made a public member so that other classes can call it to force
	// the connection to another computer.

	CDataProvider * GetProvider();

	// Include a debug only method to dump the contents of this category.

#ifdef _DEBUG
	void Dump();
#endif

private:
	BOOL			m_fInitialized;
	DWORD			m_dwNextFreeID;
	DWORD			m_dwRootID;
	DWORD			m_dwLastError;
	DataComplexity	m_complexity;
	CMapWordToPtr	m_mapCategories;		// map of IDs to internal category representations
	CDataProvider *	m_pProvider;			// pointer to class encapsulating WBEM functionality
	CString			m_strDeferredProvider; // name of machine for deferred provider creation
	CStringList		m_strlistDeferredTemplates;
	BOOL			m_fDeferredPending;
	DWORD			m_dwDeferredError;
	BOOL			m_fTemplatesLoaded;
	CString			m_strCategory;

	// The relative enumeration is used in conjunction with the GetRelative
	// member function to retrieve a category pointer to a relative.

	enum Relative	{ PARENT, CHILD, NEXT_SIBLING, PREV_SIBLING };
	CDataCategory *	GetRelative(DWORD dwID, Relative relative);

	// These private methods are called by CDataCategory (and derived) objects.
	// Since the CDataGatherer object stores all of the category information,
	// all but the first of these are simply called by similarly named member
	// functions of the category classes - see definitions there.

	BOOL	RefreshCategory(DWORD dwID, BOOL fRecursive, volatile BOOL *pfCancel, BOOL fSoftRefresh = FALSE);
	int		m_cInRefresh;	// used to track how deep in recursion we are

	BOOL	IsValidDataCategory(DWORD dwID);
	BOOL	IsCategoryDynamic(DWORD dwID);
	BOOL	HasDynamicChildren(DWORD dwID, BOOL fRecursive);
	BOOL	GetName(DWORD dwID, CString & strName);

	// These methods return information about columns.

	DWORD	GetColumnCount(DWORD dwID);
	BOOL	GetColumnCaption(DWORD dwID, DWORD nColumn, CString &strCaption);
	BOOL	GetColumnWidth(DWORD dwID, DWORD nColumn, DWORD &cxWidth);
	BOOL	GetColumnSort(DWORD dwID, DWORD nColumn, MSIColumnSortType &sorttype);
	BOOL	GetColumnDataComplexity(DWORD dwID, DWORD nColumn, DataComplexity & complexity);
	
	// These methods return information about rows.

	DWORD	GetRowCount(DWORD dwID);
	BOOL	GetRowDataComplexity(DWORD dwID, DWORD nRow, DataComplexity & complexity);

	// GetValue returns the string and DWORD value for the specified row and column.

	BOOL	GetValue(DWORD dwID, DWORD nRow, DWORD nColumn, CString &strValue, DWORD &dwValue);

	// These private methods are used internally within this class and by the
	// CTemplateFile friend class or the CRefreshFunctions friend class.

	CDataCategory *		BuildDataCategory(DWORD dwID);
	INTERNAL_CATEGORY *	GetInternalRep(DWORD dwID);
	void				SetLastError(DWORD dwError);
	void				SetLastError(DWORD dwError, DWORD dwID);
	void				SetLastErrorHR(HRESULT hrError);
	void				SetLastErrorHR(HRESULT hrError, DWORD dwID);
	void				ResetLastError();
	CString				GetErrorText();
	CString				GetErrorText(DWORD dwID);
	void				RemoveAllCategories();
	GATH_FIELD *		GetColumnField(DWORD dwID, DWORD nColumn);
	BOOL				FindCategoryByIdentifer(const CString & strIdentifier, CString & strPath, DWORD dwID);
	DWORD				FindCategoryByPath(const CString & strPath);
	BOOL				RecursiveFind(INTERNAL_CATEGORY * pCat, MSI_FIND_STRUCT *pFind, int & iLine, CString & strPath);
	void				GetCategoryPath(INTERNAL_CATEGORY * pCat, CString & strPath);
	void				LoadTemplates();
};

//-----------------------------------------------------------------------------
// CDataCategory
//
// This class encapsulates the concept of a category. A category has a one-to-
// one correspondence with a node in the MMC namespace. The root CDataCategory
// object is found through a CDataGatherer object, and can be used to navigate
// though the tree of categories. The CDataCategory object can also be used
// to refresh data and a derived class can be used to return results.
//-----------------------------------------------------------------------------

class CDataCategory
{
friend class CDataGatherer;
public:
	CDataCategory();
	virtual ~CDataCategory();

	// This member function is used to retrieve the CDataGatherer object which
	// created this CDataCategory (or derived class) object.

	CDataGatherer * GetGatherer();

	// Methods to retrieve basic information about this category.

	BOOL GetName(CString &strName);
	BOOL IsValid();

	// The following methods are used to determine if this category is a
	// dynamic category or if it has children which are dynamic. A dynamic
	// category is one which has been generated during the refresh, and which
	// may disappear after another refresh. For instance, there might be a
	// category with is repeated for each user attached to a share. Note: the
	// bRecursive parameter to HasDynamicChildren is used to search down through
	// the tree if it is TRUE. Otherwise only the immediate children are examined.

	BOOL IsDynamic();
	BOOL HasDynamicChildren(BOOL fRecursive = FALSE);
	
	// Category types. Note: later on we might end up adding { HTML, OCX }.

	enum CatType { NONE, LISTVIEW };

	// Methods to navigate through the tree of categories. The category
	// object is allocated and a pointer to it returned. The caller is
	// responsible for deallocating the object.

	CDataCategory *	GetParent();
	CDataCategory *	GetChild();
	CDataCategory *	GetNextSibling();
	CDataCategory *	GetPrevSibling();

	// Refresh the information in this category.

	BOOL Refresh(BOOL fRecursive = FALSE, volatile BOOL *pfCancel = NULL, BOOL fSoftRefresh = TRUE);
	BOOL HasBeenRefreshed();

	// Get information about the results pane for this category.

	virtual CatType GetResultType() { return NONE; };

protected:
	CDataGatherer *	m_pGatherer;	// CDataGatherer which created this object
	DWORD			m_dwID;			// internal object ID (passed to CDataGatherer methods)
};

//-----------------------------------------------------------------------------
// CDataListCategory
//
// This class extends CDataCategory for categories which show results in
// a list view.
//-----------------------------------------------------------------------------

class CDataListCategory : private CDataCategory
{
public:
	CDataListCategory();
	virtual ~CDataListCategory();

	// We'll override GetResultType to return CDataCategory::LISTVIEW.

	virtual CatType GetResultType() { return LISTVIEW; };

	// Here are the methods specific to retrieving data from this category
	// for the list view.

	DWORD	GetColumnCount();
	DWORD	GetRowCount();
	BOOL	GetColumnCaption(DWORD nColumn, CString &strCaption);
	BOOL	GetColumnWidth(DWORD nColumn, DWORD &cxWidth);
	BOOL	GetColumnDataComplexity(DWORD nColumn, DataComplexity & complexity);
	BOOL	GetRowDataComplexity(DWORD nRow, DataComplexity & complexity);

	// This method returns the sorting type for the column. See comment
	// for MSIColumnSortType at the beginning of this file.

	BOOL	GetColumnSort(DWORD nColumn, MSIColumnSortType & sorttype);

	// This method returns the value for the requested row and column. Both
	// the string value to display and a DWORD value possibly used for sorting
	// are returned.

	BOOL	GetValue(DWORD nRow, DWORD nColumn, CString &strValue, DWORD &dwValue);
};

//-----------------------------------------------------------------------------
// These error codes are returned by CDataGatherer::GetLastError().
//-----------------------------------------------------------------------------

#define GATH_ERR_NOERROR					0x00000000L
#define GATH_ERR_ALLOCATIONFAILED		0x80000002L
#define GATH_ERR_BADCATEGORYID			0x80000003L
#define GATH_ERR_NOWBEMCONNECT			0x80000004L
#define GATH_ERR_NOWBEMLOCATOR			0x80000005L
#define GATH_ERR_NOTINITIALIZED			0x80000008L
#define GATH_ERR_BADCATIDENTIFIER		0x80000009L
#define GATH_ERR_FINDDATANOTFOUND		0x8000000AL
#define GATH_ERR_NOWBEMOUTOFMEM			0x8000000BL
#define GATH_ERR_NOWBEMACCESSDENIED		0x8000000CL
#define GATH_ERR_NOWBEMBADSERVER			0x8000000DL
#define GATH_ERR_NOWBEMNETWORKFAILURE	0x8000000EL

// Obsolete error messages (template information moved to DLLs).
//
// #define GATH_ERR_BADTEMPLATENAME			0x80000001L
// #define GATH_ERR_TEMPLATEVERSION			0x80000006L
// #define GATH_ERR_TEMPLATEFORMAT			0x80000007L
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\gathsrc.cpp ===
//	GathSrc.cpp	- Implementation of the WBEM Data Source and Folder Objects
//
//  Copyright (c) 1998-1999 Microsoft Corporation

#include <io.h>
#include "StdAfx.h"
#include "DataSrc.h"
#include "gather.h"
#include "Resource.h"
#include "resrc1.h"
#include <atlbase.h>	// Last to prevent a #error statement about <windows.h>

LPCTSTR cszDefaultNFT			= _T("default.nft");
LPCTSTR cszClsid				= _T("Clsid");
LPCTSTR cszInprocServerKey		= _T("InprocServer32");
LPCTSTR cszDefaultDirectory		= _T("Microsoft Shared\\MSInfo");
LPCTSTR	cszProgramFiles			= _T("C:\\Program Files");
LPCTSTR	cszRegistryRoot			= _T("Software\\Microsoft\\Shared Tools\\MSInfo");
LPCTSTR	cszDirectoryKey			= _T("Path");

/*
 * GetInprocServerDirectory - Return the directory portion of the InprocServer32
 *		Subkey of HKEY_CLASSES_ROOT\Clsid\<cszClassID>
 *
 * History:	a-jsari		10/24/97		Initial version
 */
static inline BOOL GetInprocServerDirectory(LPCTSTR cszClassID, LPTSTR szDirectoryBuffer, DWORD &dwSize)
{
	CRegKey		rkDirectory;
	CRegKey		rkSubdirectory;

	long lResult = rkDirectory.Open(HKEY_CLASSES_ROOT, _T("Clsid"), KEY_QUERY_VALUE);
	ASSERT(lResult == ERROR_SUCCESS);
	if (lResult != ERROR_SUCCESS) return FALSE;
	lResult = rkSubdirectory.Open(rkDirectory, cszClassID, KEY_QUERY_VALUE);
	ASSERT(lResult == ERROR_SUCCESS);
	if (lResult != ERROR_SUCCESS) return FALSE;
	lResult = rkDirectory.Open(rkSubdirectory, cszInprocServerKey, KEY_QUERY_VALUE);
	ASSERT(lResult == ERROR_SUCCESS);
	if (lResult != ERROR_SUCCESS) return FALSE;
	//	Pointer == NULL: Get the default value
	lResult = rkDirectory.QueryValue(szDirectoryBuffer, NULL, &dwSize);
	ASSERT(lResult == ERROR_SUCCESS);
	if (lResult != ERROR_SUCCESS) return FALSE;
	unsigned short	ch	= '\\';
	LPTSTR szEnd = ::_tcsrchr(szDirectoryBuffer, ch);
	ASSERT(szEnd != NULL);
	if (szEnd == NULL) return FALSE;
	*szEnd = 0;
	return TRUE;
}

/*
 * GetDefaultMSInfoDirectory - Get the location of the Program Files directory from the
 *		Registry and append our known path to it.
 *
 * History:	a-jsari		11/21/97		Initial version
 */
void CMSInfoFile::GetDefaultMSInfoDirectory(LPTSTR szDefaultDirectory, DWORD dwSize)
{
	CRegKey		keyProgramFiles;
	long		lResult;

	do {
		lResult = keyProgramFiles.Open(HKEY_LOCAL_MACHINE, cszWindowsCurrentKey);
		ASSERT(lResult == ERROR_SUCCESS);
		if (lResult != ERROR_SUCCESS) break;
		lResult = keyProgramFiles.QueryValue(szDefaultDirectory, cszCommonFilesValue, &dwSize);
		ASSERT(lResult == ERROR_SUCCESS);
	} while (FALSE);
	if (lResult != ERROR_SUCCESS) {
		_tcscpy(szDefaultDirectory, cszProgramFiles);
	}
	_tcsncat(szDefaultDirectory, cszDefaultDirectory, dwSize);
}

/*
 * CWBEMDataSource - Constructor.  Defaults to loading all .nft files in the
 *		DLL file's directory.  Alternately, loads the szTemplateFile as a
 *		template file.
 *
 * History:	a-jsari		10/15/97		Initial version.
 */
CWBEMDataSource::CWBEMDataSource(LPCTSTR szMachineName)
: m_pGatherer(new CDataGatherer), 
  m_strMachineName(_T("")), 
  CDataSource(szMachineName), 
  m_fEverRefreshed(FALSE), 
  m_pThreadRefresh(NULL)
{
	BOOL	fGathererResult;

	//	m_pGatherer is deleted in the CWBEMDataSource destructor.
	ASSERT(m_pGatherer);
	if (m_pGatherer == NULL)
		::AfxThrowMemoryException();

	if (szMachineName != NULL) 
	{
		if ((*szMachineName == (TCHAR)'\\' || *szMachineName == (TCHAR)'/')
			&& (szMachineName[1] == (TCHAR)'\\' || szMachineName[1] == (TCHAR)'/'))
			szMachineName += 2;
	}
	m_strMachineName = szMachineName;

	fGathererResult = m_pGatherer->Create(szMachineName);

	if (fGathererResult == FALSE) 
	{
		CString		strErrorMessage, strTitle;
		DWORD			dwError = m_pGatherer->GetLastError();

		AFX_MANAGE_STATE(::AfxGetStaticModuleState());	//	Needed for AfxGetMainWnd()
		switch (dwError) 
		{
		case GATH_ERR_ALLOCATIONFAILED:
		case GATH_ERR_NOWBEMOUTOFMEM:
			::AfxThrowMemoryException();
			break;
		case GATH_ERR_NOWBEMCONNECT:
			strErrorMessage.Format(IDS_NOGATHERER, szMachineName);
			break;
		case GATH_ERR_NOWBEMLOCATOR:
			strErrorMessage.Format(IDS_NOLOCATOR, szMachineName);
			break;
		case GATH_ERR_NOWBEMACCESSDENIED:
			strErrorMessage.Format(IDS_GATHERACCESS, szMachineName);
			break;
		case GATH_ERR_NOWBEMBADSERVER:
			strErrorMessage.Format(IDS_BADSERVER, szMachineName);
			break;
		case GATH_ERR_NOWBEMNETWORKFAILURE:
			strErrorMessage.Format(IDS_NETWORKERROR, szMachineName);
			break;
		case GATH_ERR_BADCATEGORYID:
			strErrorMessage.LoadString(IDS_UNEXPECTED);
			break;
		}
		
		strTitle.LoadString( IDS_DESCRIPTION);
		::MessageBox( ::AfxGetMainWnd()->GetSafeHwnd(), strErrorMessage, strTitle, MB_OK);

		delete m_pGatherer;
		::AfxThrowUserException();
	}

	m_pThreadRefresh = new CThreadingRefresh(m_pGatherer);
}

#if FALSE



	BOOL		fGathererResult;
	CString		strFile;
	TCHAR		szTemplateBuffer[MAX_PATH];

	//	m_pGatherer is deleted in the CWBEMDataSource destructor.
	ASSERT(m_pGatherer);
	if (m_pGatherer == NULL)
		::AfxThrowMemoryException();

	int	wBufferSize = sizeof(szTemplateBuffer) / sizeof(TCHAR);
	//	Change directory to the directory where our snap-in DLL lives.
	ChangeToTemplateDirectory(szTemplateBuffer, wBufferSize);
	do {
		//	Load the default file and all .nft files in the current directory.

		//	Remove a leading \\ or a leading // from the machine name.
		if (szMachineName != NULL) {
			if ((*szMachineName == (TCHAR)'\\' || *szMachineName == (TCHAR)'/')
				&& (szMachineName[1] == (TCHAR)'\\' || szMachineName[1] == (TCHAR)'/'))
				szMachineName += 2;
		}
		m_strMachineName = szMachineName;
		strFile = szTemplateBuffer;
		fGathererResult = m_pGatherer->Create(strFile, szMachineName);
		if (fGathererResult == FALSE)
			break;

		//	Read all subsidiary template files.
		CFileFind	ffTemplate;
		if (ffTemplate.FindFile(_T("*.nft"))) {
			BOOL fResult;
			do {
				fResult = ffTemplate.FindNextFile();
				if (!fResult) {
					DWORD dwError = ::GetLastError();
					ASSERT(dwError == ERROR_NO_MORE_FILES);
				}
				strFile = ffTemplate.GetFileName();
				//	Don't reload the default template file.
				if (strFile.CompareNoCase(cszDefaultNFT) == 0) continue;
//				fGathererResult = m_pGatherer->AddTemplateFile(ffTemplate.GetFilePath());
				if (fGathererResult == FALSE)
					break;
			} while (fResult);
		} else {
			fGathererResult = FALSE;
			break;
		}
	} while (FALSE);

	if (fGathererResult == FALSE) {
		CString		strErrorMessage, strTitle;
		DWORD		dwError = m_pGatherer->GetLastError();

		AFX_MANAGE_STATE(::AfxGetStaticModuleState());	//	Needed for AfxGetMainWnd
		switch (dwError) {
		case GATH_ERR_ALLOCATIONFAILED:
		case GATH_ERR_NOWBEMOUTOFMEM:
			::AfxThrowMemoryException();
			break;
		case GATH_ERR_NOWBEMCONNECT:
			strErrorMessage.Format(IDS_NOGATHERER, szMachineName);
			break;
		case GATH_ERR_NOWBEMLOCATOR:
			strErrorMessage.Format(IDS_NOLOCATOR, szMachineName);
			break;
		case GATH_ERR_NOWBEMACCESSDENIED:
			strErrorMessage.Format(IDS_GATHERACCESS, szMachineName);
			break;
		case GATH_ERR_NOWBEMBADSERVER:
			strErrorMessage.Format(IDS_BADSERVER, szMachineName);
			break;
		case GATH_ERR_NOWBEMNETWORKFAILURE:
			strErrorMessage.Format(IDS_NETWORKERROR, szMachineName);
			break;
		case GATH_ERR_BADCATEGORYID:
			strErrorMessage.LoadString(IDS_UNEXPECTED);
			break;
		}
		strTitle.LoadString(IDS_DESCRIPTION);
		::MessageBox( ::AfxGetMainWnd()->GetSafeHwnd(), strErrorMessage, strTitle, MB_OK);
		delete m_pGatherer;
		::AfxThrowUserException();
	}
}
#endif



/*
 * ~CWBEMDataSource - Destructor - Delete the gatherer pointer.
 *
 * History:	a-jsari		10/15/97		Initial version
 */
CWBEMDataSource::~CWBEMDataSource()
{
	delete m_pGatherer;

	if (m_pThreadRefresh)
	{
		delete m_pThreadRefresh;
		m_pThreadRefresh = NULL;
	}
}

/*
 * GetNodeName - Return the node name for the root node.
 *
 * History:	a-jsari		1/16/98		Initial version.
 */
BOOL CWBEMDataSource::GetNodeName(CString &strName)
{
	AFX_MANAGE_STATE(::AfxGetStaticModuleState());

	if (m_strMachineName.GetLength() > 0)
		strName.Format(IDS_NODENAME, (LPCTSTR)m_strMachineName);
	else {
		CString		strLocal;

		VERIFY(strLocal.LoadString(IDS_LOCALMACHINE));
		strName.Format(IDS_NODENAME, (LPCTSTR)strLocal);
	}
	return TRUE;
}

/*
 * SetMachineName - Sets the name of the connected machine.
 *
 * History:	a-jsari		1/16/98		Initial version.
 */
BOOL CWBEMDataSource::SetMachineName(const CString &strMachine)
{
	BOOL	fReturn;

	m_strMachineName = strMachine;
	fReturn = m_pGatherer->SetConnect(strMachine);
	if (fReturn == FALSE) {
		CString		strErrorMessage, strTitle;
		DWORD		dwError = m_pGatherer->GetLastError();

		//	Needed for AfxGetMainWnd and LoadString/Format
		AFX_MANAGE_STATE(::AfxGetStaticModuleState());
		switch (dwError) {
			case GATH_ERR_NOWBEMCONNECT:
				strErrorMessage.Format(IDS_NOGATHERER, (LPCTSTR)strMachine);
				break;
			case GATH_ERR_NOWBEMLOCATOR:
				strErrorMessage.Format(IDS_NOLOCATOR, (LPCTSTR)strMachine);
				break;
			case GATH_ERR_NOWBEMACCESSDENIED:
				strErrorMessage.Format(IDS_GATHERACCESS, (LPCTSTR)strMachine);
				break;
			case GATH_ERR_NOWBEMBADSERVER:
				strErrorMessage.Format(IDS_BADSERVER, (LPCTSTR)strMachine);
				break;
			case GATH_ERR_NOWBEMNETWORKFAILURE:
				strErrorMessage.Format(IDS_NETWORKERROR, (LPCTSTR)strMachine);
				break;
			default:
				VERIFY(strErrorMessage.LoadString(IDS_UNEXPECTED));
				ASSERT(FALSE);
				break;
		}

		strTitle.LoadString(IDS_DESCRIPTION);
		::MessageBox( ::AfxGetMainWnd()->GetSafeHwnd(), strErrorMessage, strTitle, MB_OK);
	}
	return fReturn;
}

/*
 * Find - Locate in the tree, by path and line number, the string contained
 *		in strSearch.
 *
 * History:	a-jsari		12/11/97		Initial version
 */
BOOL CWBEMDataSource::Find(const CString &strSearch, long lFindOptions)
{
	BOOL			fReturn;
	MSI_FIND_STRUCT	mfsFind;

	StartSearch();
	mfsFind.m_fSearchData = (lFindOptions & FIND_OPTION_CATEGORY_ONLY) == 0;

	if ((lFindOptions & FIND_OPTION_REPEAT_SEARCH) == 0) {
		if ((lFindOptions & FIND_OPTION_ONE_CATEGORY) != 0) {
			//	Set our path to the selected node.
			ASSERT(m_pfLast != NULL);
			m_pfLast->InternalName(m_strPath);
			m_iLine = -1;
		} else {
			m_strPath = _T("");
		}
		m_strParentPath = m_strPath;
		m_iLine = -1;
	} else {
		//	The root path does not have specific lines.  (This if statement will
		//	fail if we cancel a find and then repeat it, when we don't want to
		//	increment the initial line to search.)

		// We do want to increment the line, even when the path is empty. Otherwise,
		// we can't get past a match on the root category when we do a find next.
		// [old code] if (!m_strPath.IsEmpty()) ++m_iLine;

		++m_iLine;
	}
	mfsFind.m_strSearch = strSearch;
	mfsFind.m_fCaseSensitive = FALSE;
	mfsFind.m_fSearchCategories = TRUE;
	mfsFind.m_strParentPath = m_strParentPath;
	mfsFind.m_strPath = m_strPath;
	mfsFind.m_iLine = m_iLine;
	mfsFind.m_pfCancel = &m_fCanceled;

	fReturn = m_pGatherer->Find(&mfsFind);
	if (mfsFind.m_fFound) {
		m_strPath = mfsFind.m_strPath;
		m_iLine = mfsFind.m_iLine;
		return TRUE;
	}
	return FALSE;
}

#if 0
/*
 * StopSearch - Ends the current search
 *
 * History:	a-jsari		1/19/98		Initial version
 */
BOOL CWBEMDataSource::StopSearch()
{
	return FALSE;
}
#endif

/*
 * GetRootNode - Return the root CFolder pointer.
 *
 * History: a-jsari		10/15/97		Initial version
 */
CFolder *CWBEMDataSource::GetRootNode()
{
	if (!m_RootFolder) {
		//	Deleted in the CWBEMDataSource destructor
		m_RootFolder = new CWBEMFolder(m_pGatherer->GetRootDataCategory(), this);
		if (m_RootFolder == NULL) AfxThrowMemoryException();
	}
	return CDataSource::GetRootNode();
}

/*
 * SetDataComplexity - Set the gatherer's data complexity.
 *
 * History:	a-jsari		12/3/97		Initial version.
 */
BOOL CWBEMDataSource::SetDataComplexity(enum DataComplexity Complexity)
{
	CDataSource::SetDataComplexity(Complexity);
	return m_pGatherer->SetDataComplexity(Complexity);
}

/*
 * Save - Save information about the data source to a stream.
 *
 * History:	a-jsari		11/13/97		Initial version
 */
HRESULT CWBEMDataSource::Save(IStream *pStm)
{
	unsigned	wValue;
	ULONG		cWrite;
	HRESULT		hResult;

	USES_CONVERSION;
	wValue = GetType();
	hResult = pStm->Write(&wValue, sizeof(wValue), &cWrite);
	ASSERT(SUCCEEDED(hResult) && (cWrite == sizeof(wValue)));
	wValue = m_strMachineName.GetLength();
	hResult = pStm->Write(&wValue, sizeof(wValue), &cWrite);
	wValue *= sizeof(WCHAR);
	ASSERT(SUCCEEDED(hResult) && (cWrite == sizeof(wValue)));
	if (wValue != 0) {
		//	Write the machine name as a wide character string to avoid
		//	conversion issues.
		LPWSTR	pszMachine = T2W(const_cast<LPTSTR>((LPCTSTR)m_strMachineName));
		hResult = pStm->Write(pszMachine, wValue, &cWrite);
		ASSERT(SUCCEEDED(hResult) && (cWrite == wValue));
	}
	return hResult;
}

/*
 * CWBEMFolder - Construct a folder.
 *
 * History: a-jsari		10/15/97		Initial version
 */
CWBEMFolder::CWBEMFolder(CDataCategory *pCategory, CDataSource *pDataSource, CFolder *pParentNode)
:CListViewFolder(pDataSource, pParentNode), m_pCategory(pCategory), m_fBeenRefreshed(FALSE)
{
	ASSERT(pDataSource != NULL);
	ASSERT(pDataSource->GetType() == CDataSource::GATHERER);
	if (pParentNode)
		ASSERT(pParentNode->GetType() == CDataSource::GATHERER);
}

/*
 * ~CWBEMFolder - Destruct the folder.
 *
 * History:	a-jsari		10/15/97		Initial version
 */
CWBEMFolder::~CWBEMFolder()
{
	delete m_pCategory;
}

/*
 * GetColumns - Return the number of columns.
 *
 * History:	a-jsari		10/15/97		Initial version
 */
unsigned CWBEMFolder::GetColumns() const
{
	ASSERT(m_pCategory != NULL);
	if (m_pCategory == NULL)
		return 0;

	if (m_pCategory->GetResultType() != CDataCategory::LISTVIEW) return 0;
	return (int) dynamic_cast<CDataListCategory *>(m_pCategory)->GetColumnCount();
}

/*
 * GetColumnTextAndWidth - Return the column width and text of the specified column.
 *
 * History:	a-jsari		10/15/97		Initial version
 */
BOOL CWBEMFolder::GetColumnTextAndWidth(unsigned iColumn, CString &strName, unsigned &uWidth) const
{
	if (m_pCategory->GetResultType() != CDataCategory::LISTVIEW) {
		ASSERT(FALSE);
		return FALSE;
	}
	BOOL	fResult;
	fResult = dynamic_cast<CDataListCategory *>(m_pCategory)->
			GetColumnCaption((DWORD)iColumn, strName);
	ASSERT(fResult);
	if (!fResult) return FALSE;
	fResult = dynamic_cast<CDataListCategory *>(m_pCategory)->
			GetColumnWidth((DWORD)iColumn, (DWORD &)uWidth);
	ASSERT(fResult);
	return fResult;
}

/*
 * GetSubElement - Return the name of the sub-element indexed by iRow, iColumn
 *
 * History:	a-jsari		10/15/97		Initial version
 */
BOOL CWBEMFolder::GetSubElement(unsigned iRow, unsigned iColumn, CString &szName) const
{
	DWORD	dwSortIndex;
	if (m_pCategory->GetResultType() != CDataCategory::LISTVIEW) {
		ASSERT(FALSE);
		return FALSE;
	}

	// dwSortIndex ignored - should be stored in sort array

	return dynamic_cast<CDataListCategory *>(m_pCategory)->GetValue(iRow, iColumn, szName, dwSortIndex);
}

/*
 * GetSortType - Return the type of sorting which goes on for each column.
 *
 * History:	a-jsari		12/1/97		Initial version
 */
BOOL CWBEMFolder::GetSortType(unsigned iColumn, MSIColumnSortType &stColumn) const
{
	if (m_pCategory->GetResultType() != CDataCategory::LISTVIEW) {
		ASSERT(FALSE);
		return 0;
	}
	if (!dynamic_cast<CDataListCategory *>(m_pCategory)->GetColumnSort((DWORD)iColumn, stColumn))
		stColumn = NOSORT;
	return TRUE;
}

/*
 * GetSortIndex - Returns the index of a specific Row/Column indexed element.
 *
 * History: a-jsari		12/1/97		Initial version.
 */
DWORD CWBEMFolder::GetSortIndex(unsigned iRow, unsigned iColumn) const
{
	DWORD	dwSortIndex;
	CString	szName;

	if (m_pCategory->GetResultType() != CDataCategory::LISTVIEW) {
		ASSERT(FALSE);
		return 0;
	}
	VERIFY(dynamic_cast<CDataListCategory *>(m_pCategory)->GetValue(iRow, iColumn, szName, dwSortIndex));
	return dwSortIndex;
}

/*
 * GetRows - returns the number of rows in the folder.
 *
 * History:	a-jsari		10/15/97		Initial version
 */
unsigned CWBEMFolder::GetRows() const
{
	// Add NULL check to fix 277774.

	if (m_pCategory == NULL || m_pCategory->GetResultType() != CDataCategory::LISTVIEW) return 0;
	return (int) dynamic_cast<CDataListCategory *>(m_pCategory)->GetRowCount();
}

/*
 * GetNextNode - Return the folder's next sibling pointer, creating a CFolder
 *		from the CDataCategory pointer if necessary.
 *
 * History:	a-jsari		10/15/97		Initial version
 */
CFolder *CWBEMFolder::GetNextNode()
{
	//	If we haven't tested this next pointer before, create the next CFolder.
	if (fNextTested == FALSE) {
		fNextTested = TRUE;
		ASSERT(m_pCategory != NULL);
		if (m_pCategory == NULL)
			return NULL;

		CDataCategory	*NextCategory = m_pCategory->GetNextSibling();
		if (NextCategory) {
			m_NextFolder = new CWBEMFolder(NextCategory, m_pDataSource, GetParentNode());
			if (m_NextFolder == NULL)
				AfxThrowMemoryException();
		}
	}
	return m_NextFolder;
}

/*
 * GetChildNode - Return the CFolder which represents the child's category.
 *
 * History:	a-jsari		10/15/97		Initial version
 */
CFolder *CWBEMFolder::GetChildNode()
{
	//	If we haven't tested this child pointer, create the child CFolder.
	if (fChildTested == FALSE) {
		fChildTested = TRUE;
		ASSERT(m_pCategory != NULL);
		if (m_pCategory == NULL)
			return FALSE;

		CDataCategory	*ChildCategory = m_pCategory->GetChild();
		if (ChildCategory) {
			m_ChildFolder = new CWBEMFolder(ChildCategory, m_pDataSource, this);
			if (m_ChildFolder == NULL)
				AfxThrowMemoryException();
		}
	}
	return m_ChildFolder;
}

/*
 * HasDynamicChildren - Return a flag describing whether any of the children of
 *		the folder have any dynamic data items.
 *
 * History: a-jsari		10/15/97		Initial version
 */
BOOL CWBEMFolder::HasDynamicChildren() const
{
	return m_pCategory->HasDynamicChildren(TRUE);
}

/*
 * IsDynamic - Determine whether the category has any dynamic data items.
 *
 * History:	a-jsari		10/15/97		Initial version
 */
BOOL CWBEMFolder::IsDynamic() const
{
	return m_pCategory->IsDynamic();
}

/*
 * Refresh - Refresh this node in the tree.
 *
 * History:	a-jsari		10/15/97		Initial version
 */

BOOL CWBEMFolder::Refresh(BOOL fRecursive)
{
	ASSERT(m_pCategory != NULL);
	if (m_pCategory == NULL)
		return FALSE;

	if (DataSource() && CDataSource::GATHERER == DataSource()->GetType())
	{
		CWBEMDataSource * pSource = reinterpret_cast<CWBEMDataSource *>(DataSource());
		if (pSource && pSource->m_pThreadRefresh)
		{
			pSource->m_pThreadRefresh->RefreshAll(this, NULL);
			return TRUE;
		}
	}

	return m_pCategory->Refresh(fRecursive);
}

/*
 * GetColumnComplexity - Return the Complexity for the given column.
 *
 * History:	a-jsari		12/23/97		Initial version
 */
DataComplexity CWBEMFolder::GetColumnComplexity(unsigned iColumn)
{
	DataComplexity		dcCurrent	= BASIC;//ASSUMPTION :To avoid uninitialized memory warning by Prefix.

	ASSERT(iColumn < GetColumns());
	VERIFY(reinterpret_cast<CDataListCategory *>(m_pCategory)->GetColumnDataComplexity(iColumn, dcCurrent));
	return dcCurrent;
}

/*
 * GetRowComplexity - Return the Complexity for the given row.
 *
 * History:	a-jsari		12/23/97		Initial version
 */
DataComplexity CWBEMFolder::GetRowComplexity(unsigned iRow)
{
	DataComplexity		dcCurrent	= BASIC;//ASSUMPTION :To avoid uninitialized memory warning by Prefix.

	ASSERT(iRow < GetRows());
	VERIFY(reinterpret_cast<CDataListCategory *>(m_pCategory)->GetRowDataComplexity(iRow, dcCurrent));
	return dcCurrent;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\gathint.h ===
//=============================================================================
// File:		gathint.h
// Author:		a-jammar
// Covers:		GATH_VALUE, GATH_FIELD, GATH_LINESPEC, GATH_LINE, 
//				INTERNAL_CATEGORY, CDataProvider, CTemplateFileFunctions,
//				CRefreshFunctions
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// This header file is used for internal structures and constants which 
// don't need to be exposed to the rest of the world in gather.h.
//
// CDataProvider encapsulates WBEM functionality. This object is created
// and maintained by the CDataGatherer object.
//
// CTemplateFileFunctions and CRefreshFunctions consist of static member
// functions which implement template file reading and information refreshing
// functionality. These are split out of the other classes to hide the
// unnecessary clutter from gather.h. They are in classes simply to make
// it easier for them to be "friend's" of CDataGatherer.
//
// OVERVIEW OF INTERNAL DATA STRUCTURES
//
// The INTERNAL_CATEGORY structure represents a category, and is stored by
// the CDataGatherer object in a map between IDs and internal categories. It
// contains general category information (name, relatives) plus the column and
// line specifiers and data. The specifiers indicate where data should be
// gotten, and how it should be presented. When a refresh is done, the actual
// data is produced and saved.
//
// A GATH_VALUE contains a string value, and a pointer (for making a linked
// list). A GATH_FIELD contains information to produce a data GATH_VALUE (data
// source, format string and a list of values representing data points).
//
// The GATH_LINESPEC object contains the specification for a line of data.
// It has a list of fields (one for each column), a next pointer (to allow for
// a list of linespecs). It also has an enumerated class - if this lists a
// WBEM class to enumerate, then a different sub-list of linespecs will be
// repeated for each instance of the WBEM class. GATH_LINE stores the results
// of a refresh on a line - a list of values (one for each column).
//=============================================================================

//-----------------------------------------------------------------------------
// Constants used in the data gathering files.
//-----------------------------------------------------------------------------

#define NODE_KEYWORD			"node"
#define COLUMN_KEYWORD			"columns"
#define LINE_KEYWORD			"line"
#define ENUMLINE_KEYWORD		"enumlines"
#define FIELD_KEYWORD			"field"
#define STATIC_SOURCE			"static"
#define TEMPLATE_FILE_TAG		"MSINFO,0000"
#define SORT_VALUE				"VALUE"
#define SORT_LEXICAL			"LEXICAL"
#define COMPLEXITY_ADVANCED		"ADVANCED"
#define COMPLEXITY_BASIC		"BASIC"
#define DEPENDENCY_JOIN			"dependency"
#define SQL_FILTER				"WQL:"

//-----------------------------------------------------------------------------
// These structures are used by the INTERNAL_CATEGORY structure to store both
// the specification for what information is shown as well as the actually 
// data to be shown (refreshed on command).
//-----------------------------------------------------------------------------
// GATH_VALUE is used to store a list of strings. A list of column names or a 
// list of arguments would use the GATH_VALUE struct. Note, a next pointer is
// not needed because these structures will be allocated contiguously (in
// an array).

struct GATH_VALUE
{
	GATH_VALUE();
	~GATH_VALUE();
	CString			m_strText;
	DWORD			m_dwValue;
	GATH_VALUE *	m_pNext;
};

// A GATH_FIELD is used to store the specification for a text string. It contains
// a format string (a printf style string) and a GATH_VALUE pointer to a list of
// arguments for the format string.

struct GATH_FIELD
{
	GATH_FIELD();
	~GATH_FIELD();
	CString				m_strSource;		// WBEM class containing information
	CString				m_strFormat;		// printf-type format string
	unsigned short		m_usWidth;			// width (if this field is for a column)
	MSIColumnSortType	m_sort;				// how to sort this column
	DataComplexity		m_datacomplexity;	// is this column BASIC or ADVANCED
	GATH_VALUE *		m_pArgs;			// arguments for m_strFormat
	GATH_FIELD *		m_pNext;			// next field in the list
};

// A GATH_LINESPEC is used to specify what is shown on a line in the listview. It
// contains a string for a class to enumerate. If this string is empty, then
// the struct merely represents a single line in the display. The GATH_FIELD pointer
// is to a list of the fields (one for each column), and the m_pNext pointer is
// to the next line to be displayed. If m_strEnumerateClass is not empty, then
// the class specified is enumerated, and the lines pointed to by m_pEnumeratedGroup
// are repeated for each instance of the class. Note, if a class is to be enumerated,
// the m_pFields pointer must be null (since this line won't display anything
// itself, but enumerate a class for another group of lines).
//
// m_pConstraintFields is a pointer to a linked list of fields which serve as
// constraints for the enumeration. These can be used to filter the enumerated
// instances or to perform joins to related classes so they are enumerated as
// well is the primary class. m_pConstraintFields should only be non-NULL when
// m_pEnumeratedGroup is non-NULL.

struct GATH_LINESPEC
{
	GATH_LINESPEC();
	~GATH_LINESPEC();
	CString			m_strEnumerateClass;
	DataComplexity	m_datacomplexity;
	GATH_FIELD *	m_pFields;
	GATH_LINESPEC *	m_pEnumeratedGroup;
	GATH_FIELD *	m_pConstraintFields;
	GATH_LINESPEC *	m_pNext;
};

// The GATH_LINE struct contains the actual data to be displayed on a line. The 
// refresh operation will take list of GATH_LINESPEC structs and create a list 
// of GATH_LINE structs. The m_aValue pointer is to a list of values to be 
// displayed (one per column).

struct GATH_LINE
{
	GATH_LINE();
	~GATH_LINE();
	GATH_VALUE *	m_aValue;
	DataComplexity	m_datacomplexity;
};

//-----------------------------------------------------------------------------
// The following structure is used within this object to store information
// about the categories. Specifically, this structure will be allocated for
// each category, and a pointer stored in m_mapCategories. This representation
// will not be used outside this object, rather, a CDataCategory object will
// be used.
//-----------------------------------------------------------------------------

struct INTERNAL_CATEGORY
{
	INTERNAL_CATEGORY();
	~INTERNAL_CATEGORY();

	GATH_VALUE		m_categoryName;			// realized name of category
	GATH_FIELD		m_fieldName;			// field used to get name
	CString			m_strEnumerateClass;	// if !(empty or "static"), this category repeated
	CString			m_strIdentifier;		// non-localized internal name
	CString			m_strNoInstances;		// message to use if there are no instances
	BOOL			m_fListView;			// is this cat a list view
	BOOL			m_fDynamic;				// was this cat enumerated
	BOOL			m_fIncluded;			// should this cat be included
	DWORD			m_dwID;					// the ID for this cat

	DWORD			m_dwParentID;			// my parent
	DWORD			m_dwChildID;			// my first child
	DWORD			m_dwDynamicChildID;		// my first dynamically created child
	DWORD			m_dwNextID;				// my next sibling
	DWORD			m_dwPrevID;				// my previous sibling

	DWORD			m_dwColCount;			// number of columns
	GATH_FIELD *	m_pColSpec;				// list of fields to make col names
	GATH_VALUE *	m_aCols;				// realized list of columns

	GATH_LINESPEC*	m_pLineSpec;			// list of line specifiers
	DWORD			m_dwLineCount;			// number of lines (NOT number of line specs)
	GATH_LINE *	*	m_apLines;				// realized list of lines

	BOOL			m_fRefreshed;			// has the category ever been refreshed

	DWORD			m_dwLastError;			// last error specific to this category

	// DEBUG dump functions to sanity check the internal structure.

#if _DEBUG
	void	DumpCategoryRecursive(int iIndent, CDataGatherer * pGatherer);
	CString	DumpField(GATH_FIELD * pField);
	CString	DumpLineSpec(GATH_LINESPEC * pLineSpec, CString strIndent);
	CString	DumpLine(GATH_LINE * pLine, DWORD nColumns);
#endif
};

//-----------------------------------------------------------------------------
// The CEnumMap is a utility class to cache IEnumWbemClassObject pointers.
// There will be one instance of this class used to improve performance
// by avoiding the high overhead associated with creating enumerators for
// certain classes.
//-----------------------------------------------------------------------------

class IEnumWbemClassObject;
class CEnumMap
{
public:
	CEnumMap() { };
	~CEnumMap() { Reset(); };

	IEnumWbemClassObject * GetEnumerator(const CString & strClass);
	void SetEnumerator(const CString & strClass, IEnumWbemClassObject * pEnum);
	void Reset();

private:
	CMapStringToPtr m_mapEnum;
};

//-----------------------------------------------------------------------------
// The CDataProvider class implements the object which actually goes and
// retrieves the information. Currently, it uses WBEM to accomplish this.
// At this time there will only be one CDataProvider object, and the
// CDataGatherer object will be used to retrieve a pointer to it.
//-----------------------------------------------------------------------------

class IWbemClassObject;
class IEnumWbemClassObject;
class IWbemServices;
class CMSIObject;
class CMSIEnumerator;
class CDataProvider
{
	friend class CMSIEnumerator;
public:
	typedef enum { MOS_NO_INSTANCES, MOS_MSG_INSTANCE, MOS_INSTANCE } MSIObjectState;

public:
	CDataProvider();
	~CDataProvider();

	// Create the provider for the specifier computer. If there are problems
	// connecting to WBEM pGatherer->SetLastError will be called to explain.

	BOOL Create(const CString & strComputer, CDataGatherer * pGatherer);
	
	// Query a value from the provider. Currently supports string, date/time and DWORD values.

	BOOL QueryValue(const CString & strClass, const CString & strProperty, CString & strResult);
	BOOL QueryValueDWORD(const CString & strClass, const CString & strProperty, DWORD & dwResult, CString & strMessage);
	BOOL QueryValueDateTime(const CString & strClass, const CString & strProperty, COleDateTime & datetime, CString & strMessage);
	BOOL QueryValueDoubleFloat(const CString & strClass, const CString & strProperty, double & dblResult, CString & strMessage);

	// ResetClass causes the enumeration of a WBEM class to reset to the first instance.
	// EnumClass advances the class to the next instance. ClearCache empties out the
	// internal class to interface pointer cache.

	BOOL ResetClass(const CString & strClass, const GATH_FIELD * pConstraints);
	BOOL EnumClass(const CString & strClass, const GATH_FIELD * pConstraints);
	void ClearCache();

	CString	m_strTrue;					// cached string value for "TRUE"
	CString	m_strFalse;					// cached string value for "FALSE"
	CString	m_strBadProperty;			// shown if Get fails
	CString	m_strPropertyUnavail;		// shown if VariantChange failes
	CString m_strComputer;				// computer name for this provider
	CString	m_strAccessDeniedLabel;		// shown for WBEM access denied
	CString	m_strTransportFailureLabel;	// shown for WBEM transport failure

	CEnumMap m_enumMap;					// caches WBEM interface pointers for enumerators

	DWORD	m_dwRefreshingCategoryID;	// the CDataGatherer ID for the refreshing category - used to set errors

private:
	BOOL			m_fInitialized;		// has Create been called and succeeded
	IWbemServices *	m_pIWbemServices;	// saved WBEM services pointer
	CMapStringToPtr	m_mapNamespaceToService;	// has WBEM services pointers for other namespaces
	CDataGatherer * m_pGatherer;

	// We keep two caches around - one is from class name to enumerator interface,
	// the other from class name to object interface. 

	CMapStringToPtr	m_mapClassToInterface;
	CMapStringToPtr	m_mapClassToEnumInterface;

	// The third cache serves a rather kludgy purpose - if a class name is 
	// contained in it, then that class must have at least one instance
	// enumerated for it, even if it is an artificially generated empty instance.
	// This is useful for nested enumlines with SQL statements.
	
	CMapStringToPtr	m_mapEnumClassMinOfOne;

	// Get or remove the object or enumerator object from the cache. Note that
	// GetObject will enumerate the next instance of the associated enumerator.

	IWbemServices *		GetWBEMService(CString * pstrNamespace = NULL);
	CMSIEnumerator *	GetEnumObject(const CString & strClass, const GATH_FIELD * pConstraints = NULL);
	CMSIObject *		GetObject(const CString & strClass, const GATH_FIELD * pConstraints, CString * pstrLabel = NULL);
	void				RemoveEnumObject(const CString & strClass);
	void				RemoveObject(const CString & strClass);

	// This function is used to look up a string in a value map (to get localized enumerated strings.

	HRESULT CheckValueMap(const CString& strClass, const CString& strProperty, const CString& strVal, CString &strResult);

	// Evaluate whether the current object satisfies a filter (a static constraint).

	BOOL IsDependencyJoin(const GATH_FIELD * pConstraints);
	void EvaluateDependencyJoin(IWbemClassObject * pObject);
	BOOL EvaluateFilter(IWbemClassObject * pObject, const GATH_FIELD * pConstraints);
	void EvaluateJoin(const CString & strClass, IWbemClassObject * pObject, const GATH_FIELD * pConstraints);
};


//-----------------------------------------------------------------------------
// The CMSIObject class is a thin wrapper for the IWbemClassObject interface.
// We use this so we can return a custom label for a null object (if there
// are no instances, we sometimes want to show some caption).
//-----------------------------------------------------------------------------

class IWbemClassObject;
class CMSIObject
{
public:
	CMSIObject(IWbemClassObject * pObject, const CString & strLabel, HRESULT hres, CDataProvider * pProvider, CDataProvider::MSIObjectState objState);
	~CMSIObject();

	HRESULT Get(BSTR property, LONG lFlags, VARIANT *pVal, VARTYPE *pvtType, LONG *plFlavor);
	HRESULT	GetErrorLabel(CString & strError);
	CDataProvider::MSIObjectState IsValid();

private:
	IWbemClassObject *				m_pObject;
	CString							m_strLabel;
	HRESULT							m_hresCreation;
	CDataProvider *					m_pProvider;
	CDataProvider::MSIObjectState	m_objState;
};

//-----------------------------------------------------------------------------
// The CMSIEnumerator class encapsulates the WBEM enumerator interface, or
// implements our own form of enumerator (such as for the LNK command in the
// template file).
//-----------------------------------------------------------------------------

class IEnumWbemClassObject;
class CMSIEnumerator
{
public:
	CMSIEnumerator();
	~CMSIEnumerator();

	HRESULT Create(const CString & strClass, const GATH_FIELD * pConstraints, CDataProvider * pProvider);
	HRESULT Next(CMSIObject ** ppObject);
	HRESULT Reset(const GATH_FIELD * pConstraints);

private:
	typedef enum { CLASS, WQL, LNK, INTERNAL } EnumType;

private:
	EnumType				m_enumtype;
	BOOL					m_fOnlyDups;
	BOOL					m_fGotDuplicate;
	BOOL					m_fMinOfOne;
	int						m_iMinOfOneCount;
	CString					m_strClass;
	CString					m_strObjPath;
	CString					m_strAssocClass;
	CString					m_strResultClass;
	CString					m_strLNKObject;
	CString					m_strNoInstanceLabel;
	IEnumWbemClassObject *	m_pEnum;
	CDataProvider *			m_pProvider;
	const GATH_FIELD *		m_pConstraints;
	HRESULT					m_hresCreation;
	IWbemClassObject * 		m_pSavedDup;
	CString					m_strSavedDup;
	CStringList	*			m_pstrList;

private:
	BOOL	AssocObjectOK(IWbemClassObject * pObject, CString & strAssociatedObject);
	HRESULT ParseLNKCommand(const CString & strStatement, CString & strObjPath, CString & strAssocClass, CString & strResultClass);
	void	ProcessEnumString(CString & strStatement, BOOL & fMinOfOne, BOOL & fOnlyDups, CDataProvider * pProvider, CString & strNoInstanceLabel, BOOL fMakeDoubleBackslashes = FALSE);
	HRESULT CreateInternalEnum(const CString & strInternal, CDataProvider * pProvider);
	HRESULT InternalNext(IWbemClassObject ** ppWBEMObject);
};

//-----------------------------------------------------------------------------
// Privately used functions. Encapsulated into classes so they will be easy
// to make friends of the CDataGatherer class. Documentation for these
// functions can be found with their implementations.
//-----------------------------------------------------------------------------

class CTemplateFileFunctions
{
public:
	static BOOL		ReadTemplateFile(CFile *pFile, CDataGatherer *pGatherer);
	static BOOL		ReadHeaderInfo(CFile *pFile, CDataGatherer *pGatherer);
	static DWORD	ReadNodeRecursive(CFile *pFile, CDataGatherer *pGatherer, DWORD dwParentID, DWORD dwPrevID);
	static BOOL		VerifyAndAdvanceFile(CFile * pFile, const CString &strVerify);
	static BOOL		VerifyUNICODEFile(CFile *pFile);
	static DWORD	CreateCategory(CDataGatherer * pGatherer, DWORD dwParentID, DWORD dwPrevID);
	static BOOL		GetKeyword(CFile * pFile, CString & strKeyword);
	static BOOL		ReadColumnInfo(CFile * pFile, CDataGatherer * pGatherer, DWORD dwID);
	static GATH_LINESPEC * ReadLineInfo(CFile * pFile, CDataGatherer * pGatherer);
	static GATH_LINESPEC * ReadLineEnumRecursive(CFile * pFile, CDataGatherer * pGatherer);
	static BOOL		ReadArgument(CFile * pFile, CString & strSource);
	static BOOL		ReadField(CFile * pFile, GATH_FIELD & field);
	static BOOL		LoadTemplateDLLs(HKEY hkeyBase, CDataGatherer * pGatherer);
	static BOOL		ApplyCategories(const CString & strCategories, CDataGatherer * pGatherer);
	static BOOL		RecurseTreeCategories(BOOL fParentOK, DWORD dwID, const CString & strCategories, CDataGatherer * pGatherer);
	static void		RemoveExtraCategories(DWORD dwID, CDataGatherer * pGatherer);
};

class CRefreshFunctions
{
public:
	static BOOL	RefreshValue(CDataGatherer * pGatherer, GATH_VALUE * pVal, GATH_FIELD * pField);
	static BOOL	RefreshColumns(CDataGatherer * pGatherer, INTERNAL_CATEGORY * pInternal);
	static BOOL	RefreshLines(CDataGatherer * pGatherer, GATH_LINESPEC * pLineSpec, DWORD dwColumns, CPtrList & listLinePtrs, volatile BOOL * pfCancel = NULL);
	static BOOL	RefreshOneLine(CDataGatherer * pGatherer, GATH_LINE * pLine, GATH_LINESPEC * pLineSpec, DWORD dwColCount);
	static BOOL GetValue(CDataGatherer *pGatherer, TCHAR cFormat, TCHAR *szFormatFragment, CString &strResult, DWORD &dwResult, GATH_FIELD *pField, int iArgNumber);
};

//-----------------------------------------------------------------------------
// Utility functions.
//-----------------------------------------------------------------------------

void GetToken(CString & strToken, CString & strString, TCHAR cDelimiter);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\lviewcat.cpp ===
//=============================================================================
// File:			lviewcat.cpp
// Author:		a-jammar
// Covers:		CDataListCategory
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// This sublass of CDataCategory is use specifically when the data to be
// displayed in a list view. Only data specific to the list view categories
// is implemented here - for general category implementation, see the code for
// CDataCategory in category.cpp. For usage details, see gather.h.
//=============================================================================

#include "stdafx.h"
#include "gather.h"

//-----------------------------------------------------------------------------
// The constructor and destructor are typical. Actual values are put into
// the member variables by CDataGatherer, which creates these objects.
//-----------------------------------------------------------------------------

CDataListCategory::CDataListCategory()
{
}

CDataListCategory::~CDataListCategory()
{
}

//-----------------------------------------------------------------------------
// These methods are specific to the list view version of the category. We
// implement all of these methods by simply calling through to the gatherer.
//-----------------------------------------------------------------------------

DWORD CDataListCategory::GetColumnCount()
{
	ASSERT(m_pGatherer);
	if (m_pGatherer)
	{
		m_pGatherer->SetLastError(GATH_ERR_NOERROR);
		return m_pGatherer->GetColumnCount(m_dwID);
	}
	return 0;
}

DWORD CDataListCategory::GetRowCount()
{
	ASSERT(m_pGatherer);
	if (m_pGatherer)
	{
		m_pGatherer->SetLastError(GATH_ERR_NOERROR);
		return m_pGatherer->GetRowCount(m_dwID);
	}
	return 0;
}

BOOL CDataListCategory::GetColumnCaption(DWORD nColumn, CString &strCaption)
{
	ASSERT(m_pGatherer);
	if (m_pGatherer)
	{	
		m_pGatherer->SetLastError(GATH_ERR_NOERROR);
		return m_pGatherer->GetColumnCaption(m_dwID, nColumn, strCaption);
	}
	return FALSE;
}

BOOL CDataListCategory::GetColumnWidth(DWORD nColumn, DWORD &cxWidth)
{
	ASSERT(m_pGatherer);
	if (m_pGatherer)
	{
		m_pGatherer->SetLastError(GATH_ERR_NOERROR);
		return m_pGatherer->GetColumnWidth(m_dwID, nColumn, cxWidth);
	}
	return FALSE;
}

BOOL CDataListCategory::GetColumnSort(DWORD nColumn, MSIColumnSortType & sorttype)
{
	ASSERT(m_pGatherer);
	if (m_pGatherer)
	{
		m_pGatherer->SetLastError(GATH_ERR_NOERROR);
		return m_pGatherer->GetColumnSort(m_dwID, nColumn, sorttype);
	}
	return FALSE;
}

BOOL CDataListCategory::GetValue(DWORD nRow, DWORD nColumn, CString &strValue, DWORD &dwValue)
{
	ASSERT(m_pGatherer);
	if (m_pGatherer)
	{
		m_pGatherer->SetLastError(GATH_ERR_NOERROR);
		return m_pGatherer->GetValue(m_dwID, nRow, nColumn, strValue, dwValue);
	}
	return FALSE;
}

BOOL CDataListCategory::GetColumnDataComplexity(DWORD nColumn, DataComplexity & complexity)
{
	ASSERT(m_pGatherer);
	if (m_pGatherer)
	{
		m_pGatherer->SetLastError(GATH_ERR_NOERROR);
		return m_pGatherer->GetColumnDataComplexity(m_dwID, nColumn, complexity);
	}
	return FALSE;
}

BOOL CDataListCategory::GetRowDataComplexity(DWORD nRow, DataComplexity & complexity)
{
	ASSERT(m_pGatherer);
	if (m_pGatherer)
	{
		m_pGatherer->SetLastError(GATH_ERR_NOERROR);
		return m_pGatherer->GetRowDataComplexity(m_dwID, nRow, complexity);
	}
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\msicab.h ===
//===========================================================================
// This header file contains the function prototypes to allow MSInfo to
// open a CAB file into a temporary directory.
//
// Copyright (c) 1998-1999 Microsoft Corporation
//===========================================================================

BOOL GetCABExplodeDir(CString &destination, BOOL fDeleteFiles = TRUE, const CString & strDontDelete = CString(""));
BOOL OpenCABFile(const CString &filename, const CString &destination);
BOOL FindFileToOpen(const CString & destination, CString & filename);
void KillDirectory(const CString & strDir, const CString & strDontDelete = CString(""));

extern "C" {
	BOOL explode_cab(char *cabinet_fullpath, char *destination);
	BOOL isCabFile(int fh, void **phfdi);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\ndmgr_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 3.03.0110 */
/* at Wed Feb 25 22:40:46 1998
 */
/* Compiler settings for d:\nt\private\admin\MMCPriv\types\idl\ndmgr.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none

  Copyright (c) 1998-1999 Microsoft Corporation
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_IComponentData = {0x955AB28A,0x5218,0x11D0,{0xA9,0x85,0x00,0xC0,0x4F,0xD8,0xD5,0x65}};


const IID IID_IComponent = {0x43136EB2,0xD36C,0x11CF,{0xAD,0xBC,0x00,0xAA,0x00,0xA8,0x00,0x33}};


const IID IID_IResultDataCompare = {0xE8315A52,0x7A1A,0x11D0,{0xA2,0xD2,0x00,0xC0,0x4F,0xD9,0x09,0xDD}};


const IID IID_IResultOwnerData = {0x9CB396D8,0xEA83,0x11d0,{0xAE,0xF1,0x00,0xC0,0x4F,0xB6,0xDD,0x2C}};


const IID IID_IConsole = {0x43136EB1,0xD36C,0x11CF,{0xAD,0xBC,0x00,0xAA,0x00,0xA8,0x00,0x33}};


const IID IID_IHeaderCtrl = {0x43136EB3,0xD36C,0x11CF,{0xAD,0xBC,0x00,0xAA,0x00,0xA8,0x00,0x33}};


const IID IID_IContextMenuCallback = {0x43136EB7,0xD36C,0x11CF,{0xAD,0xBC,0x00,0xAA,0x00,0xA8,0x00,0x33}};


const IID IID_IContextMenuProvider = {0x43136EB6,0xD36C,0x11CF,{0xAD,0xBC,0x00,0xAA,0x00,0xA8,0x00,0x33}};


const IID IID_IExtendContextMenu = {0x4F3B7A4F,0xCFAC,0x11CF,{0xB8,0xE3,0x00,0xC0,0x4F,0xD8,0xD5,0xB0}};


const IID IID_IImageList = {0x43136EB8,0xD36C,0x11CF,{0xAD,0xBC,0x00,0xAA,0x00,0xA8,0x00,0x33}};


const IID IID_IResultData = {0x31DA5FA0,0xE0EB,0x11cf,{0x9F,0x21,0x00,0xAA,0x00,0x3C,0xA9,0xF6}};


const IID IID_IConsoleNameSpace = {0xBEDEB620,0xF24D,0x11cf,{0x8A,0xFC,0x00,0xAA,0x00,0x3C,0xA9,0xF6}};


const IID IID_IConsoleNameSpace2 = {0x255F18CC,0x65DB,0x11D1,{0xA7,0xDC,0x00,0xC0,0x4F,0xD8,0xD5,0x65}};


const IID IID_IPropertySheetCallback = {0x85DE64DD,0xEF21,0x11cf,{0xA2,0x85,0x00,0xC0,0x4F,0xD8,0xDB,0xE6}};


const IID IID_IPropertySheetProvider = {0x85DE64DE,0xEF21,0x11cf,{0xA2,0x85,0x00,0xC0,0x4F,0xD8,0xDB,0xE6}};


const IID IID_IExtendPropertySheet = {0x85DE64DC,0xEF21,0x11cf,{0xA2,0x85,0x00,0xC0,0x4F,0xD8,0xDB,0xE6}};


const IID IID_IControlbar = {0x69FB811E,0x6C1C,0x11D0,{0xA2,0xCB,0x00,0xC0,0x4F,0xD9,0x09,0xDD}};


const IID IID_IExtendControlbar = {0x49506520,0x6F40,0x11D0,{0xA9,0x8B,0x00,0xC0,0x4F,0xD8,0xD5,0x65}};


const IID IID_IToolbar = {0x43136EB9,0xD36C,0x11CF,{0xAD,0xBC,0x00,0xAA,0x00,0xA8,0x00,0x33}};


const IID IID_IConsoleVerb = {0xE49F7A60,0x74AF,0x11D0,{0xA2,0x86,0x00,0xC0,0x4F,0xD8,0xFE,0x93}};


const IID IID_ISnapinAbout = {0x1245208C,0xA151,0x11D0,{0xA7,0xD7,0x00,0xC0,0x4F,0xD9,0x09,0xDD}};


const IID IID_IMenuButton = {0x951ED750,0xD080,0x11d0,{0xB1,0x97,0x00,0x00,0x00,0x00,0x00,0x00}};


const IID IID_ISnapinHelp = {0xA6B15ACE,0xDF59,0x11D0,{0xA7,0xDD,0x00,0xC0,0x4F,0xD9,0x09,0xDD}};


const IID IID_IExtendPropertySheet2 = {0xB7A87232,0x4A51,0x11D1,{0xA7,0xEA,0x00,0xC0,0x4F,0xD9,0x09,0xDD}};


const IID IID_IHeaderCtrl2 = {0x9757abb8,0x1b32,0x11d1,{0xa7,0xce,0x00,0xc0,0x4f,0xd8,0xd5,0x65}};


const IID IID_IEnumTASK = {0x338698b1,0x5a02,0x11d1,{0x9f,0xec,0x00,0x60,0x08,0x32,0xdb,0x4a}};


const IID IID_IExtendTaskPad = {0x8dee6511,0x554d,0x11d1,{0x9f,0xea,0x00,0x60,0x08,0x32,0xdb,0x4a}};


const IID IID_IConsole2 = {0x103D842A,0xAA63,0x11D1,{0xA7,0xE1,0x00,0xC0,0x4F,0xD8,0xD5,0x65}};


const IID IID_IPropertySheetChange = {0xd700dd8e,0x2646,0x11d0,{0xa2,0xa7,0x00,0xc0,0x4f,0xd9,0x09,0xdd}};


const IID IID_IFramePrivate = {0xd71d1f2a,0x1ba2,0x11d0,{0xa2,0x9b,0x00,0xc0,0x4f,0xd9,0x09,0xdd}};


const IID IID_IScopeDataPrivate = {0x60BD2FE0,0xF7C5,0x11cf,{0x8A,0xFD,0x00,0xAA,0x00,0x3C,0xA9,0xF6}};


const IID IID_IImageListPrivate = {0x7538C620,0x0083,0x11d0,{0x8B,0x00,0x00,0xAA,0x00,0x3C,0xA9,0xF6}};


const IID IID_IResultDataPrivate = {0x1EBA2300,0x0854,0x11d0,{0x8B,0x03,0x00,0xAA,0x00,0x3C,0xA9,0xF6}};


const IID IID_IScopeTree = {0xd8dbf067,0x5fb2,0x11d0,{0xa9,0x86,0x00,0xc0,0x4f,0xd8,0xd5,0x65}};


const IID IID_IScopeTreeIter = {0xd779f8d1,0x6057,0x11d0,{0xa9,0x86,0x00,0xc0,0x4f,0xd8,0xd5,0x65}};


const IID IID_INodeCallback = {0xb241fced,0x5fb3,0x11d0,{0xa9,0x86,0x00,0xc0,0x4f,0xd8,0xd5,0x65}};


const IID IID_IControlbarsCache = {0x2e9fcd38,0xb9a0,0x11d0,{0xa7,0x9d,0x00,0xc0,0x4f,0xd8,0xd5,0x65}};


const IID IID_IContextMenuProviderPrivate = {0x9275b092,0xfe48,0x11d0,{0xa7,0xc9,0x00,0xc0,0x4f,0xd8,0xd5,0x65}};


const IID IID_INodeType = {0xB08A8368,0x967F,0x11D0,{0xA7,0x99,0x00,0xC0,0x4F,0xD8,0xD5,0x65}};


const IID IID_INodeTypesCache = {0xDE40436E,0x9671,0x11D0,{0xA7,0x99,0x00,0xC0,0x4F,0xD8,0xD5,0x65}};


const IID IID_IEnumGUID = {0x0002E000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};


const IID IID_IEnumNodeTypes = {0xABBD61E6,0x9686,0x11D0,{0xA7,0x99,0x00,0xC0,0x4F,0xD8,0xD5,0x65}};


const IID IID_IDocConfig = {0xF1E752C2,0xFD72,0x11D0,{0xAE,0xF6,0x00,0xC0,0x4F,0xB6,0xDD,0x2C}};


const IID LIBID_NODEMGRLib = {0x43136EB0,0xD36C,0x11CF,{0xAD,0xBC,0x00,0xAA,0x00,0xA8,0x00,0x33}};


const CLSID CLSID_NodeInit = {0x43136EB5,0xD36C,0x11CF,{0xAD,0xBC,0x00,0xAA,0x00,0xA8,0x00,0x33}};


const CLSID CLSID_ScopeTree = {0x7F1899DA,0x62A6,0x11d0,{0xA2,0xC6,0x00,0xC0,0x4F,0xD9,0x09,0xDD}};


const CLSID CLSID_MMCDocConfig = {0xF1E752C3,0xFD72,0x11D0,{0xAE,0xF6,0x00,0xC0,0x4F,0xB6,0xDD,0x2C}};


const IID IID_IPropertySheetProviderPrivate = {0xFEF554F8,0xA55A,0x11D0,{0xA7,0xD7,0x00,0xC0,0x4F,0xD9,0x09,0xDD}};


const IID IID_IMMCListView = {0x1B3C1392,0xD68B,0x11CF,{0x8C,0x2B,0x00,0xAA,0x00,0x3C,0xA9,0xF6}};


const IID IID_ITaskPadHost = {0x4f7606d0,0x5568,0x11d1,{0x9f,0xea,0x00,0x60,0x08,0x32,0xdb,0x4a}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\msicab.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation

#include "stdafx.h"
#include "MSICAB.h"
extern "C" {
#include "uni2utf.h"
};
#ifndef IDS_CAB_DIR_NAME
#include "resource.h"
#endif

LPCTSTR cszDirSeparator = _T("\\");

//---------------------------------------------------------------------------
// DirectorySearch is used to locate all of the files in a directory or
// one of its subdirectories which match a file spec.
//---------------------------------------------------------------------------

void DirectorySearch(const CString & strSpec, const CString & strDir, CStringList &results)
{
	// Look for all of the files which match the file spec in the directory
	// specified by strDir.

	WIN32_FIND_DATA	finddata;
	CString			strSearch, strDirectory;

	strDirectory = strDir;
	if (strDirectory.Right(1) != CString(cszDirSeparator)) strDirectory += CString(cszDirSeparator);

	strSearch = strDirectory + strSpec;
	HANDLE hFind = FindFirstFile(strSearch, &finddata);
	if (hFind != INVALID_HANDLE_VALUE)
	{
		do
		{
			results.AddHead(strDirectory + CString(finddata.cFileName));
		} while (FindNextFile(hFind, &finddata));
		FindClose(hFind);
	}

	// Now call this function recursively, with each of the subdirectories.

	strSearch = strDirectory + CString(_T("*"));
	hFind = FindFirstFile(strSearch, &finddata);
	if (hFind != INVALID_HANDLE_VALUE)
	{
		do
		{
			if (finddata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
				if (::_tcscmp(finddata.cFileName, _T(".")) != 0 && ::_tcscmp(finddata.cFileName, _T("..")) != 0)
					DirectorySearch(strSpec, strDirectory + CString(finddata.cFileName), results);
		} while (FindNextFile(hFind, &finddata));
		FindClose(hFind);
	}
}

//---------------------------------------------------------------------------
// This function gets the directory in which to put exploded CAB files.
// This will be the same directory each time, so this function will create
// the directory (if necessary) and delete any files in the directory.
//---------------------------------------------------------------------------

BOOL GetCABExplodeDir(CString &destination, BOOL fDeleteFiles, const CString & strDontDelete)
{
	CString strMSInfoDir, strExplodeTo, strSubDirName;

	// Determine the temporary path and add on a subdir name.

	TCHAR szTempDir[_MAX_PATH];
	if (GetTempPath(_MAX_PATH, szTempDir) > _MAX_PATH)
	{
//		MSIError(IDS_GENERAL_ERROR, "couldn't get temporary path");
		destination = _T("");
		return FALSE;
	}

	strSubDirName.LoadString(IDS_CAB_DIR_NAME);

	strExplodeTo = szTempDir;
	if (strExplodeTo.Right(1) == CString(cszDirSeparator))
		strExplodeTo = strExplodeTo + strSubDirName;
	else
		strExplodeTo = strExplodeTo + CString(cszDirSeparator) + strSubDirName;

	// Kill the directory if it already exists.

	if (fDeleteFiles)
		KillDirectory(strExplodeTo, strDontDelete);

	// Create the subdirectory.

	if (!CreateDirectoryEx(szTempDir, strExplodeTo, NULL))
	{
		if (GetLastError() != ERROR_ALREADY_EXISTS)
		{
//			MSIError(IDS_GENERAL_ERROR, "couldn't create the target directory");
			destination = "";
			return FALSE;
		}
	}

	destination = strExplodeTo;
	return TRUE;
}

//---------------------------------------------------------------------------
// This functions kills a directory by recursively deleting files and
// subdirectories.
//---------------------------------------------------------------------------

void KillDirectory(const CString & strDir, const CString & strDontDelete)
{
	CString				strDirectory = strDir;

	if (strDirectory.Right(1) == CString(cszDirSeparator))
		strDirectory = strDirectory.Left(strDirectory.GetLength() - 1);

	// Delete any files in directory.

	CString				strFilesToDelete = strDirectory + CString(_T("\\*.*"));
	CString				strDeleteFile;
	WIN32_FIND_DATA		filedata;
	BOOL				bFound = TRUE;

	HANDLE hFindFile = FindFirstFile(strFilesToDelete, &filedata);
	while (hFindFile != INVALID_HANDLE_VALUE && bFound)
	{
		if ((filedata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0L)
		{
			strDeleteFile = strDirectory + CString(cszDirSeparator) + filedata.cFileName;
			
			if (strDontDelete.CompareNoCase(strDeleteFile) != 0)
			{
				::SetFileAttributes(strDeleteFile, FILE_ATTRIBUTE_NORMAL);
				::DeleteFile(strDeleteFile);
			}
		}
		
		bFound = FindNextFile(hFindFile, &filedata);
	}
	FindClose(hFindFile);

	// Now call this function on any subdirectories in this directory.

	CString strSearch = strDirectory + CString(_T("\\*"));
	hFindFile = FindFirstFile(strSearch, &filedata);
	if (hFindFile != INVALID_HANDLE_VALUE)
	{
		do
		{
			if (filedata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
				if (::_tcscmp(filedata.cFileName, _T(".")) != 0 && ::_tcscmp(filedata.cFileName, _T("..")) != 0)
					KillDirectory(strDirectory + CString(cszDirSeparator) + CString(filedata.cFileName));
		} while (FindNextFile(hFindFile, &filedata));
		FindClose(hFindFile);
	}

	// Finally, remove this directory.

	::RemoveDirectory(strDirectory);
}

//---------------------------------------------------------------------------
// This function will expand the specified CAB file, putting all of the
// files in the specified destination directory.
//---------------------------------------------------------------------------

BOOL OpenCABFile(const CString & filename, const CString & destination)
{
	char	szFilebuffer[MAX_UTF_LENGTH];
	char	szDestination[MAX_UTF_LENGTH];

	// If the filename has Unicode characters which can't be represented
	// directly by ANSI characters, we need to make a copy of it to the
	// temp directory, and give it an ANSI name. The code we've borrowed
	// for expanding CAB files can't open Unicode named files.

	BOOL fNonANSICharacter = FALSE;
	const TCHAR * pChar = (LPCTSTR) filename;
	while (pChar && *pChar)
		if (*pChar++ >= (TCHAR)0x0080)
		{
			fNonANSICharacter = TRUE;
			break;
		}

	CString strFilename(filename);
	BOOL	fMadeCopy = FALSE;
	if (fNonANSICharacter)
	{
		TCHAR szNewFile[MAX_PATH + 10];
		DWORD dwLength = 0;

		dwLength = ::GetTempPath(MAX_PATH, szNewFile);
		if (dwLength != 0 && dwLength < MAX_PATH)
		{
			_tcscat(szNewFile, _T("msitemp.cab"));
			fMadeCopy = ::CopyFile((LPCTSTR) strFilename, szNewFile, FALSE);
			strFilename = szNewFile;
		}
	}

	char * szFilename = Unicode2UTF((LPCTSTR)strFilename);
	::strcpy(szFilebuffer, szFilename);
	szFilename = Unicode2UTF((LPCTSTR)destination);
	::strcpy(szDestination, szFilename);
	BOOL fResult = explode_cab(szFilebuffer, szDestination);

	// If we made a copy of the CAB file, we should delete it now.

	if (fMadeCopy)
		::DeleteFile((LPCTSTR)strFilename);

	return fResult;
}

//---------------------------------------------------------------------------
// This function looks in the specified directory for an NFO file. If it
// finds one, it assigns it to filename and returns TRUE. This function 
// will only find the first NFO file in a directory.
//
// If an NFO file cannot be found, then we'll look for another file type
// to open. Grab the string entry in the registry = "cabdefaultopen". An
// example value would be "*.nfo|hwinfo.dat|*.dat|*.txt" which would be 
// interpreted as follows:
//
//		1. First look for any NFO file to open.
//		2. Then try to open a file called "hwinfo.dat".
//		3. Then try to open any file with a DAT extension.
//		4. Then try for any TXT file.
//		5. Finally, if none of these can be found, present an open dialog
//		   to the user.
//---------------------------------------------------------------------------

LPCTSTR VAL_CABDEFAULTOPEN = _T("cabdefaultopen");

BOOL FindFileToOpen(const CString & destination, CString & filename)
{
	CString strCABDefaultOpen, strRegBase, strDirectory;
	HKEY	hkey;

	filename.Empty();
	strDirectory = destination;
	if (strDirectory.Right(1) != CString(cszDirSeparator))
		strDirectory += CString(cszDirSeparator);

	// Set up a fallback string of the NFO file type, in case we can't
	// find the registry entry.

	strCABDefaultOpen.LoadString(IDS_MSI_FILE_EXTENSION);
	strCABDefaultOpen = CString("*.") + strCABDefaultOpen;

	// Load the string of files and file types to open from the registry.

	strRegBase.LoadString(IDS_MSI_REG_BASE);
	if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, strRegBase, 0, KEY_READ, &hkey) == ERROR_SUCCESS)
	{
		char	szData[MAX_PATH];
		DWORD	dwType, dwSize = MAX_PATH;

		if (RegQueryValueEx(hkey, VAL_CABDEFAULTOPEN, NULL, &dwType, (LPBYTE) szData, &dwSize) == ERROR_SUCCESS)
			if (dwType == REG_SZ)
				strCABDefaultOpen = szData;
		RegCloseKey(hkey);
	}

	// Look through each of the potential files and file types. If we find
	// a match, return TRUE after setting filename appropriately. Note that
	// we need to recurse down through directories.

	CString				strFileSpec;
	CStringList			filesfound;
	POSITION			pos;

	while (!strCABDefaultOpen.IsEmpty())
	{
		if (strCABDefaultOpen.Find('|') == -1)
			strFileSpec = strCABDefaultOpen;
		else
			strFileSpec = strCABDefaultOpen.Left(strCABDefaultOpen.Find('|'));

		filesfound.RemoveAll();
		DirectorySearch(strFileSpec, strDirectory, filesfound);
		pos = filesfound.GetHeadPosition();

		if (pos != NULL)
		{
			filename = filesfound.GetNext(pos);
			return TRUE;
		}

		strCABDefaultOpen = strCABDefaultOpen.Right(strCABDefaultOpen.GetLength() - strFileSpec.GetLength());
		if (strCABDefaultOpen.Find('|') == 0)
			strCABDefaultOpen = strCABDefaultOpen.Right(strCABDefaultOpen.GetLength() - 1);
	}
	
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\print.cpp ===
// Print.cpp - Functions to handle MSInfo printing of the text report.
//
// Copyright (c) 1998-1999 Microsoft Corporation

#include "stdafx.h"
#include "DataSrc.h"
#include "Resource.h"
#include "DataObj.h"
#include "CompData.h"
#include <afxext.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/*
 * PreparePrintDialog - Do all initialization required before the print
 *		dialog is displayed, most notably calculating the page count.
 *
 * History:	a-jsari		3/17/98		Initial version
 */

BOOL CDataSource::RefreshPrintData(CPrintDialog * pdlgPrint, CFolder * pfolSelection)
{
	//	FIX: Make calculation of line length device independent.

	LPTSTR			szLine;
	int				cLength		= 84;
	int				cLineCount	= 57;
	unsigned short	cPage		= 0;
	CFolder *		pPrintRoot	= NULL;
	
	if (pdlgPrint->PrintSelection() && pfolSelection)
		pPrintRoot = pfolSelection;
	else
		pPrintRoot = GetRootNode();

	if (m_pPrintContent != NULL)
		delete m_pPrintContent;
	m_pPrintContent = new CMSInfoMemoryFile();
	ASSERT(m_pPrintContent != NULL);
	if (m_pPrintContent == NULL)
		::AfxThrowMemoryException();

	if (m_pPrintInfo != NULL) {
		//	Set this pointer to NULL so it doesn't delete the
		//	pointer we're storing internally.
		m_pPrintInfo->m_pPD = NULL;
		//	This prevents the delete below from asserting.
		m_pPrintInfo->m_strPageDesc = _T("");
		delete m_pPrintInfo;
		m_pPrintInfo = NULL;
	}

	m_pPrintInfo = new CPrintInfo;
	ASSERT(m_pPrintInfo != NULL);
	if (m_pPrintInfo == NULL) {
		delete m_pPrintContent;
		m_pPrintContent = NULL;
		::AfxThrowMemoryException();
	}

	m_pPrintInfo->m_nCurPage = 0;
	m_pPrintInfo->m_pPD = pdlgPrint;
	if (FAILED(WriteOutput(m_pPrintContent, pPrintRoot)))
		return FALSE;
	m_pPrintContent->SeekToBegin();
	szLine = new TCHAR[cLength + 1];
	m_fEndOfFile = FALSE;
	while (!m_fEndOfFile) {
		int iLine = cLineCount;
		++cPage;
		while (iLine--) {
			GetLine(szLine, cLength);
			if (m_fEndOfFile)
				goto WhileEnd;
		}
	}
WhileEnd:
	delete [] szLine;

	pdlgPrint->m_pd.nMaxPage = cPage;
	if (pdlgPrint->m_pd.nToPage > pdlgPrint->m_pd.nMaxPage)
		pdlgPrint->m_pd.nToPage = pdlgPrint->m_pd.nMaxPage;

	return TRUE;
}

/*
 * PrintReport - Send the report data to the printer.
 *
 * History:	a-jsari		12/9/97		Initial version.
 */
BOOL CDataSource::PrintReport(CPrintDialog *pdlgPrint, CFolder *pfolSelection)
{
	BOOL	fReturn;

	do {
		int nResult = BeginPrinting(pdlgPrint, pfolSelection);
		if (nResult < 0)
			break;
		m_pPrintContent->SeekToBegin();
		while (m_pPrintInfo->m_bContinuePrinting)
			PrintPage(pdlgPrint);
		EndPrinting();
		fReturn = TRUE;
	} while (FALSE);
	delete m_pPrintContent;
	m_pPrintContent = NULL;
	delete m_pPrintInfo;
	m_pPrintInfo = NULL;
	return fReturn;
}

/*
 * BeginPrinting - Do the initialization required to print the file.
 *
 * History:	a-jsari		12/30/97		Thieved from msishell's msiview.cpp,
 *		modified to allow page ranges.
 */
int CDataSource::BeginPrinting(CPrintDialog *pdlgPrint, CFolder *pfolSelection)
{
	ASSERT(m_pPrintContent != NULL);
	if (m_pPrintContent == NULL) {
		m_fEndOfFile = TRUE;
		m_pPrintInfo->m_bContinuePrinting = FALSE;
		::AfxThrowMemoryException();
	}

	if (m_pDC != NULL) {
		delete m_pDC;
		m_pDC = NULL;
	}

	m_pDC = new CDC;
	ASSERT(m_pDC != NULL);
	if (m_pDC == NULL) ::AfxThrowMemoryException();

	if (m_pprinterFont != NULL) {
		delete m_pprinterFont;
		m_pprinterFont = NULL;
	}

	m_pprinterFont = new CFont;
	ASSERT(m_pprinterFont != NULL);
	if (m_pprinterFont == NULL) ::AfxThrowMemoryException();

#if 0
	m_strHeaderLeft = pScope->MachineName();
#endif

	CString strFormat;
	COleDateTime datetime;

	strFormat.LoadString(IDS_PRINT_HDR_RIGHT_CURRENT);
	datetime = COleDateTime::GetCurrentTime();
	m_strHeaderRight = datetime.Format(strFormat);

	m_strFooterCenter.LoadString(IDS_PRINT_FTR_CTR);

	// Reset the end of file member.

	m_fEndOfFile = FALSE;

	// Create the font for printing. Read font information from string
	// resources, to allow the localizers to control what font is
	// used for printing. Set the variables for the default font to use.

	int		nHeight				= 10;
	int		nWeight				= FW_NORMAL;
	BYTE	nCharSet			= DEFAULT_CHARSET;
	BYTE	nPitchAndFamily		= DEFAULT_PITCH | FF_DONTCARE;
	CString	strFace				= "Courier New";

	// Load string resources to see if we should use other values
	// than the defaults.

	CString	strHeight, strWeight, strCharSet, strPitchAndFamily, strFaceName;
	strHeight.LoadString(IDS_PRINT_FONT_HEIGHT);
	strWeight.LoadString(IDS_PRINT_FONT_WEIGHT);
	strCharSet.LoadString(IDS_PRINT_FONT_CHARSET);
	strPitchAndFamily.LoadString(IDS_PRINT_FONT_PITCHANDFAMILY);
	strFaceName.LoadString(IDS_PRINT_FONT_FACENAME);

	if (!strHeight.IsEmpty() && ::_ttol(strHeight))
		nHeight = ::_ttoi(strHeight);

	if (!strWeight.IsEmpty())
		nWeight = ::_ttoi(strWeight);

	if (!strCharSet.IsEmpty())
		nCharSet = (BYTE) ::_ttoi(strCharSet);

	if (!strPitchAndFamily.IsEmpty())
		nPitchAndFamily = (BYTE) ::_ttoi(strPitchAndFamily);

	strFaceName.TrimLeft();
	if (!strFaceName.IsEmpty() && strFaceName != CString("facename"))
		strFace = strFaceName;

	CString		strDriver	= pdlgPrint->GetDriverName();
	CString		strDevice	= pdlgPrint->GetDeviceName();
	CString		strPort		= pdlgPrint->GetPortName();
	LPDEVMODE	pdevMode	= pdlgPrint->GetDevMode();
	VERIFY(m_pDC->CreateDC(strDriver, strDevice, strPort, pdevMode));

	// Convert the height from points to a value specific to the printer.

    nHeight = -((m_pDC->GetDeviceCaps (LOGPIXELSY) * nHeight) / 72);

	// Create the font object.

    VERIFY(m_pprinterFont->CreateFont(nHeight, 0, 0, 0, nWeight, 0, 0, 0,
        nCharSet, OUT_CHARACTER_PRECIS, CLIP_CHARACTER_PRECIS,
        DEFAULT_QUALITY, nPitchAndFamily, strFace));

	m_pPrintInfo->m_rectDraw.SetRect(0, 0, m_pDC->GetDeviceCaps(HORZRES),
		m_pDC->GetDeviceCaps(VERTRES));
	m_pDC->DPtoLP(&m_pPrintInfo->m_rectDraw);

	m_pPrintInfo->m_bContinuePrinting = TRUE;

	CString		strDocName;
	CString		strOutput;
	DOCINFO		diJob;
	diJob.cbSize = sizeof(DOCINFO);
	diJob.lpszDocName = strDocName;
	diJob.lpszOutput = strOutput;
	return m_pDC->StartDoc(&diJob);
}

/*
 * OnEndPrinting - Clean up anything we allocated for the print job.  Specifically,
 *		delete the CMemFile holding the content.
 *
 * History:	a-jsari		12/30/97		Thieved from MSIShell's msiview.cpp
 */
void CDataSource::EndPrinting()
{
	AFX_MANAGE_STATE(::AfxGetStaticModuleState());
	if (m_pPrintContent != NULL)
	{
		delete m_pPrintContent;
		m_pPrintContent = NULL;
	}

	int nResult = m_pDC->EndDoc();
	ASSERT(nResult >= 0);

	if (nResult < 0) {
		AFX_MANAGE_STATE(::AfxGetStaticModuleState());
		CString		strError, strTitle;

		switch(nResult) {
		case SP_OUTOFDISK:
			VERIFY(strError.LoadString(IDS_PRINT_NODISK));
			break;
		case SP_OUTOFMEMORY:
			VERIFY(strError.LoadString(IDS_PRINT_NOMEMORY));
			break;
		case SP_USERABORT:
			VERIFY(strError.LoadString(IDS_PRINT_USERABORTED));
			break;
		case SP_ERROR:
		default:
			VERIFY(strError.LoadString(IDS_PRINT_GENERIC));
			break;
		}
		strTitle.LoadString(IDS_DESCRIPTION);
		::MessageBox( ::AfxGetMainWnd()->GetSafeHwnd(), strError, strTitle, MB_OK);
	}

    VERIFY(m_pprinterFont->DeleteObject());
	VERIFY(m_pDC->DeleteDC());
}

//---------------------------------------------------------------------------
// In this function, we use two rectangles: rectOuter is what we consider
// the printable area of the page, and includes headers and footers.
// rectInner is the rectange we actually print the content in (doesn't
// include headers or footers).
//
// TBD: add header and footer
// TBD: add error checking
// TBD: fix intelegence issues and speed this up
// TBD: insure that 80 columns will always fit
//---------------------------------------------------------------------------
 
#define TOP_MARGIN		2540/2	// HIMETRIC for 1/2 inch
#define BOTTOM_MARGIN	2540/2	// HIMETRIC for 1/2 inch
#define LEFT_MARGIN		2540/2	// HIMETRIC for 1/2 inch
#define RIGHT_MARGIN	2540/2	// HIMETRIC for 1/2 inch

/*
 * GetLine - Copy a line of data from m_pPrintContent into szLineBuffer.
 *
 * History:	a-jsari		3/16/98		Initial version.
 */
void CDataSource::GetLine(LPTSTR szLineBuffer, int cSize)
{
	for (int i = 0; i < cSize; i++)
	{
		try {
			m_pPrintContent->ReadTchar(szLineBuffer[i]);
		} catch (...)
		{
			m_pPrintInfo->m_bContinuePrinting = FALSE;
			m_fEndOfFile = TRUE;
			szLineBuffer[i] = '\0';
			break;
		}
		if (szLineBuffer[i] == '\t')
		{
			// Convert tabs into spaces for printing.

			szLineBuffer[i] = ' ';
		}
		else if (szLineBuffer[i] == '\r')
		{
			i--;
		}
		else if (szLineBuffer[i] == '\n')
		{
			szLineBuffer[i] = '\0';
			break;
		}
	}
}

/*
 * GetTextSize - Get the sizes of the text.
 *
 * History:	a-jsari		3/16/98		Initial version.
 */
void CDataSource::GetTextSize(int &cLineLength, int &cCharHeight, CRect &rectOuter, CRect &rectText)
{
	TEXTMETRIC	tm;

	m_pDC->GetTextMetrics(&tm);
	cCharHeight = tm.tmHeight + tm.tmExternalLeading;

	// Take the actual print area (in pInfo) and adjust it for the
	// header and footer.

	rectOuter = m_pPrintInfo->m_rectDraw;

	CSize sizeLeftTop(LEFT_MARGIN, TOP_MARGIN);
	CSize sizeRightBottom(RIGHT_MARGIN, BOTTOM_MARGIN);
	m_pDC->HIMETRICtoDP(&sizeLeftTop);
	m_pDC->HIMETRICtoDP(&sizeRightBottom);
	rectOuter.DeflateRect(sizeLeftTop.cx, sizeLeftTop.cy, sizeRightBottom.cx, sizeRightBottom.cy);

	rectText = rectOuter;
	rectText.DeflateRect(0, cCharHeight * 4);

	// Get the number of characters which will fit on a line (use the average, because this
	// might not be a monospaced font). Note: it's possible that text could be cut off
	// if a line consisted of very wide characters. This is unlikely because the font
	// used SHOULD be monospace (for alignment of text, etc.).

	cLineLength = rectText.Width() / tm.tmAveCharWidth;
}

/*
 * PrintPage - Write one page to the printer Device Context.
 *
 * History:	a-jsari	12/30/97		Thieved from msishell's msiview.cpp.
 */
void CDataSource::PrintPage(CPrintDialog *pdlgPrint) 
{
	int			cLineLength;
	int			cy = 0, cyCharHeight;
	LPTSTR		szLineBuffer;
	CRect		rectOuter, rectInner;

	ASSERT(m_pPrintContent != NULL);
	if (m_pPrintContent == NULL)
	{
		m_fEndOfFile = TRUE;
		m_pPrintInfo->m_bContinuePrinting = FALSE;
		return;
	}

	// Select the font used for printing.

    CGdiObject* pOldFont = m_pDC->SelectObject(m_pprinterFont);

	// this makes a small font: CGdiObject *pOldFont = pDC->SelectStockObject(ANSI_FIXED_FONT);

	// Compute the height of each character (we'll need the text metric).
	GetTextSize(cLineLength, cyCharHeight, rectOuter, rectInner);

	++m_pPrintInfo->m_nCurPage;
	if (!(pdlgPrint->PrintAll() || pdlgPrint->PrintSelection())
		&& m_pPrintInfo->m_nCurPage > m_pPrintInfo->GetToPage()) {
		m_pPrintInfo->m_bContinuePrinting = FALSE;
		m_pDC->SelectObject(pOldFont);
		return;
	}

	// Allocate the buffer of character to hold a single line of the print out.
	szLineBuffer = new TCHAR[cLineLength + 1];
	szLineBuffer[cLineLength] = (TCHAR)'\0';

	if (pdlgPrint->PrintAll() || pdlgPrint->PrintSelection()
		|| m_pPrintInfo->m_nCurPage >= m_pPrintInfo->GetFromPage()) {
		m_pDC->StartPage();

		// Draw the header.

		m_pDC->TextOut(rectOuter.left, rectOuter.top, m_strHeaderLeft);

		int cxHeaderRight = rectOuter.right - m_pDC->GetTextExtent(m_strHeaderRight).cx;
		m_pDC->TextOut(cxHeaderRight, rectOuter.top, m_strHeaderRight);
	}

	// Process the output a line at a time, until either we have emptied out
	// the memfile, or we have gotten to the bottom of this page.

	while (!m_fEndOfFile)
	{
		if (cy + cyCharHeight > rectInner.Height())
			break;

		GetLine(szLineBuffer, cLineLength);

		if (pdlgPrint->PrintAll() || pdlgPrint->PrintSelection()
			|| m_pPrintInfo->m_nCurPage >= m_pPrintInfo->GetFromPage())
			m_pDC->TextOut(rectInner.left, rectInner.top + cy, szLineBuffer, ::_tcslen(szLineBuffer));
		cy += cyCharHeight;
	}

	if (pdlgPrint->PrintAll() || pdlgPrint->PrintSelection()
		|| m_pPrintInfo->m_nCurPage >= m_pPrintInfo->GetFromPage()) {
		// Draw the footer.
		CString strActualFooter;
		strActualFooter.Format(m_strFooterCenter, m_pPrintInfo->m_nCurPage);
		int cxFooterCenter = (rectOuter.Width() - m_pDC->GetTextExtent(strActualFooter).cx) / 2;
		m_pDC->TextOut(rectOuter.left + cxFooterCenter, rectOuter.bottom - cyCharHeight, strActualFooter);

		int nResult = m_pDC->EndPage();
		ASSERT(nResult >= 0);
	}

#if 0
	if (nResult < 0) {
		AFX_MANAGE_STATE(::AfxGetStaticModuleState());
		CString		strError;

		switch (nResult) {
		case SP_APPABORT:
			VERIFY(strError.LoadString(IDS_PRINT_APPABORTED));
			break;
		case SP_USERABORT:
			VERIFY(strError.LoadString(IDS_PRINT_USERABORTED));
			break;
		case SP_OUTOFDISK:
			VERIFY(strError.LoadString(IDS_PRINT_NODISK));
			break;
		case SP_OUTOFMEMORY:
			VERIFY(strError.LoadString(IDS_PRINT_NOMEMORY));
			break;
		case SP_ERROR:
		default:
			VERIFY(strError.LoadString(IDS_PRINT_GENERIC));
			break;
		}
		strTitle.LoadString(IDS_DESCRIPTION)
		::MessageBox( ::AfxGetMainWnd()->GetSafeHwnd(), strError, strTitle, MB_OK);
	}
	// Clean up.
#endif

	delete [] szLineBuffer;
	m_pDC->SelectObject(pOldFont);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\intcat.cpp ===
//=============================================================================
// File:			intcat.cpp
// Author:		a-jammar
// Covers:		GATH_VALUE, GATH_FIELD, GATH_LINESPEC, GATH_LINE, 
//					INTERNAL_CATEGORY
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// This file contains the support methods for the INTERNAL_CATERORY struct
// and its related structs, including some constructors and destructors, and
// dump routines to output the contents of the structs. The gathint.h include
// file describes how these structures interrelate.
//
// Also contains some utility functions.
//=============================================================================

#include "stdafx.h"
#include "gather.h"
#include "gathint.h"

//-----------------------------------------------------------------------------
// Here are the constructor and destructor for the internal category struct,
// and some of the structures used within it.
//-----------------------------------------------------------------------------
// INTERNAL_CATEGORY constructor and destructor.
//-----------------------------------------------------------------------------

INTERNAL_CATEGORY::INTERNAL_CATEGORY()
{
	m_categoryName.m_strText	= CString(" ");
	m_fieldName.m_strFormat		= CString(" ");
	m_strEnumerateClass			= CString("");
	m_strIdentifier				= CString("");
	m_strNoInstances			= CString("");
	m_fListView					= FALSE;
	m_fDynamic					= FALSE;
	m_dwID						= 0;
	m_dwParentID				= 0;
	m_dwChildID					= 0;
	m_dwPrevID					= 0;
	m_dwNextID					= 0;
	m_dwDynamicChildID			= 0;
	m_dwColCount				= 0;
	m_pColSpec					= NULL;
	m_aCols						= NULL;
	m_pLineSpec					= NULL;
	m_dwLineCount				= 0;
	m_apLines					= NULL;
	m_fIncluded					= TRUE;
	m_fRefreshed				= FALSE;
	m_dwLastError				= GATH_ERR_NOERROR;
}

INTERNAL_CATEGORY::~INTERNAL_CATEGORY()
{
	if (m_pColSpec)
		delete m_pColSpec;

	if (m_aCols)
		delete [] m_aCols;

	if (m_pLineSpec)
		delete m_pLineSpec;

	if (m_apLines)
	{
		for (DWORD dwIndex = 0; dwIndex < m_dwLineCount; dwIndex++)
			delete m_apLines[dwIndex];
		delete [] m_apLines;
	}
}

//-----------------------------------------------------------------------------
// GATH_FIELD constructor and destructor.
//-----------------------------------------------------------------------------

GATH_FIELD::GATH_FIELD()
{
	m_pArgs				= NULL;
	m_pNext				= NULL;
	m_usWidth			= 0;
	m_sort				= NOSORT;
	m_datacomplexity	= BASIC;
}

GATH_FIELD::~GATH_FIELD()
{
	if (m_pArgs) delete m_pArgs;
	if (m_pNext) delete m_pNext;
}

//-----------------------------------------------------------------------------
// GATH_VALUE constructor and destructor.
//-----------------------------------------------------------------------------

GATH_VALUE::GATH_VALUE()
{
	m_pNext	 = NULL;
	m_dwValue = 0L;
}

GATH_VALUE::~GATH_VALUE()
{
	if (m_pNext) delete m_pNext;
}

//-----------------------------------------------------------------------------
// GATH_LINESPEC constructor and destructor.
//-----------------------------------------------------------------------------

GATH_LINESPEC::GATH_LINESPEC()
{
	m_pFields				= NULL;
	m_pEnumeratedGroup	= NULL;
	m_pConstraintFields	= NULL;
	m_pNext					= NULL;
	m_datacomplexity		= BASIC;
}

GATH_LINESPEC::~GATH_LINESPEC()
{
	if (m_pFields)
		delete m_pFields;

	if (m_pEnumeratedGroup)
		delete m_pEnumeratedGroup;

	if (m_pConstraintFields)
		delete m_pConstraintFields;

	if (m_pNext)
		delete m_pNext;
}

//-----------------------------------------------------------------------------
// GATH_LINE constructor and destructor.
//-----------------------------------------------------------------------------

GATH_LINE::GATH_LINE()
{
	m_datacomplexity = BASIC;
	m_aValue = NULL;
}

GATH_LINE::~GATH_LINE()
{
	if (m_aValue)
		delete [] m_aValue;
}

//-----------------------------------------------------------------------------
// Dump a category and all its children. Indent by the current iIndent level.
//-----------------------------------------------------------------------------

#if _DEBUG

void INTERNAL_CATEGORY::DumpCategoryRecursive(int iIndent, CDataGatherer * pGatherer)
{
	TCHAR						szIndent[100];
	INTERNAL_CATEGORY *	pNextCat;
	int						i;

	for (i = 0; i < iIndent; i++)
		szIndent[i] = _T(' ');
	szIndent[iIndent] = 0;

	// Dump the contents of this category.

	TRACE1("%sCATEGORY(", szIndent);
	TRACE1("m_categoryName = %s", this->m_categoryName.m_strText);
	TRACE0(")-----------------------------\n");
	TRACE2("%sm_fieldName = %s\n", szIndent, DumpField(&this->m_fieldName));
	TRACE2("%sm_strIdentifier = %s\n", szIndent, this->m_strIdentifier);
	TRACE2("%sm_strEnumerateClass = %s\n", szIndent, this->m_strEnumerateClass);
	TRACE2("%sm_strNoInstances = %s\n", szIndent, this->m_strNoInstances);
	TRACE2("%sm_fListView = %s\n", szIndent, (this->m_fListView ? "TRUE" : "FALSE"));
	TRACE2("%sm_fDynamic = %s\n", szIndent, (this->m_fDynamic ? "TRUE" : "FALSE"));
	TRACE2("%sm_dwID = %ld\n", szIndent, this->m_dwID);
	TRACE2("%sm_dwParentID = %ld\n", szIndent, this->m_dwParentID);
	TRACE2("%sm_dwChildID = %ld\n", szIndent, this->m_dwChildID);
	TRACE2("%sm_dwDynamicChildID = %ld\n", szIndent, this->m_dwDynamicChildID);
	TRACE2("%sm_dwNextID = %ld\n", szIndent, this->m_dwNextID);
	TRACE2("%sm_dwPrevID = %ld\n", szIndent, this->m_dwPrevID);

	TRACE1("%sm_pColSpec = ", szIndent);
	for (GATH_FIELD * pField = this->m_pColSpec; pField; pField = pField->m_pNext)
		TRACE1("%s ", DumpField(pField));
	TRACE0("\n");

	TRACE2("%sm_dwColCount = %ld\n", szIndent, this->m_dwColCount);
	TRACE1("%sm_aCols = ", szIndent);
	for (i = 0; i < (int)this->m_dwColCount; i++)
		TRACE1("(%s) ", this->m_aCols[i].m_strText);
	TRACE0("\n");

	TRACE1("%sm_pLineSpec =\n", szIndent);
	for (GATH_LINESPEC * pLine = this->m_pLineSpec; pLine; pLine = pLine->m_pNext)
		TRACE2("%s  %s\n", szIndent, DumpLineSpec(pLine, szIndent));

	TRACE2("%sm_dwLineCount = %ld\n", szIndent, this->m_dwLineCount);
	TRACE1("%sm_apLines = \n", szIndent);
	for (i = 0; i < (int)this->m_dwLineCount; i++)
		TRACE2("%s  %s\n", szIndent, DumpLine(this->m_apLines[i], this->m_dwColCount));

	// Dump the children of this category.

	if (this->m_dwChildID)
	{
		pNextCat = pGatherer->GetInternalRep(this->m_dwChildID);
		if (pNextCat)
			pNextCat->DumpCategoryRecursive(iIndent + 2, pGatherer);
	}

	// Dump the siblings of this category.

	if (this->m_dwNextID)
	{
		pNextCat = pGatherer->GetInternalRep(this->m_dwNextID);
		if (pNextCat)
			pNextCat->DumpCategoryRecursive(iIndent, pGatherer);
	}
}

//-----------------------------------------------------------------------------
// Return a string containing the text dump of a field variable.
//-----------------------------------------------------------------------------

CString INTERNAL_CATEGORY::DumpField(GATH_FIELD * pField)
{
	CString strDump;

	strDump.Format(_T("(%s, %s, %d"), pField->m_strSource, pField->m_strFormat, pField->m_usWidth);
	for (GATH_VALUE * pArg = pField->m_pArgs; pArg; pArg = pArg->m_pNext)
		strDump += CString(", ") + pArg->m_strText;
	strDump += CString(")");

	return strDump;
}

//-----------------------------------------------------------------------------
// Return a string containing the text dump of a line specifier variable.
//-----------------------------------------------------------------------------

CString INTERNAL_CATEGORY::DumpLineSpec(GATH_LINESPEC * pLineSpec, CString strIndent)
{
	CString strDump;
	
	if (pLineSpec->m_strEnumerateClass.IsEmpty() || pLineSpec->m_strEnumerateClass.CompareNoCase(CString(STATIC_SOURCE)) == 0)
	{
		strDump = CString("LineSpec = ");
		for (GATH_FIELD * pField = pLineSpec->m_pFields; pField; pField = pField->m_pNext)
			strDump += DumpField(pField) + CString(" ");
	}
	else
	{
		strDump.Format(_T("EnumLines(%s) = "), pLineSpec->m_strEnumerateClass);

		GATH_LINESPEC * pEnumLine = pLineSpec->m_pEnumeratedGroup;
		if /* while TBD */ (pEnumLine)
		{
			strDump += CString("\n    ") + strIndent + DumpLineSpec(pEnumLine, strIndent);
			pEnumLine = pEnumLine->m_pNext;
		}
	}

	return strDump;
}

//-----------------------------------------------------------------------------
// Return a string containing the text dump of a line variable.
//-----------------------------------------------------------------------------

CString INTERNAL_CATEGORY::DumpLine(GATH_LINE * pLine, DWORD nColumns)
{
	CString strDump("Line = ");
	for (DWORD dwIndex = 0; dwIndex < nColumns; dwIndex++)
		strDump += pLine->m_aValue[dwIndex].m_strText + CString(" ");
	return strDump;
}

#endif

//-----------------------------------------------------------------------------
// This utility function is used to get a token from the front of a string.
// It searches through strString for cDelimiter, returning the token found
// in strToken. strString is modified to remove the token returned, and
// the delimiter character. TBD: inefficient.
//-----------------------------------------------------------------------------

void GetToken(CString & strToken, CString & strString, TCHAR cDelimiter)
{
	int iDelimiter = strString.Find(cDelimiter);

	if (iDelimiter == -1)
		strToken = strString;
	else
		strToken = strString.Left(iDelimiter);

	// Remove the token we found from strString.

	if (!strToken.IsEmpty())
	{
		if (strString.GetLength() >= strToken.GetLength())
			strString = strString.Right(strString.GetLength() - strToken.GetLength());
		else
			strString.Empty();
	}

	// Remove any leading delimiter characters from strString.

	while (!strString.IsEmpty() && strString[0] == cDelimiter)
		strString = strString.Right(strString.GetLength() - 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\print.h ===
// MSIView.h : interface of the CMSIShellView class
//
// Copyright (c) 1998-1999 Microsoft Corporation
/////////////////////////////////////////////////////////////////////////////
#pragma once	// MSINFO_PRINT_H

#include "FileIO.h"

class CPrintView : public CView
{
protected: // create from serialization only
	CPrintView();
	DECLARE_DYNCREATE(CPrintView)

// Attributes
public:
//	CMSIShellDoc*	GetDocument();

#if 0
	CMemFile *		m_pPrintContent;
#else
	CMSInfoFile		*m_pPrintContent;
#endif
	BOOL			m_fEndOfFile;
	CString			m_strHeaderLeft;
	CString			m_strHeaderRight;
	CString			m_strFooterCenter;
	CFont			m_printerFont;

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMSIShellView)
	public:
	virtual void OnDraw(CDC* pDC);  // overridden to draw this view
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo);
	protected:
	virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
	virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnPrint(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnPrepareDC( CDC* pDC, CPrintInfo* pInfo = NULL );
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CPrintView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CPrintView)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnUpdateFilePrint(CCmdUI* pCmdUI);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\msinfo.cpp ===
// MSInfo.cpp : Implementation of DLL Exports, main application object
//		and Registry Object Map.  All registry information (apart from
//		MIDL) lives here.
//
// Copyright (c) 1998-1999 Microsoft Corporation

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"

//	This hack is required because we may be building in an environment
//	which doesn't have a late enough version of rpcndr.h
#if		__RPCNDR_H_VERSION__ < 440
#define __RPCNDR_H_VERSION__ 440
#define MIDL_INTERFACE(x)	interface
#endif

#include "MSInfo.h"
#include "DataObj.h"
#include "CompData.h"
#include "About.h"
#include "Toolset.h"
#include "Dispatch.h"

#include "MSInfo_i.c"

static LPCTSTR		cszBasePath			= _T("Software\\Microsoft\\MMC");
static LPCTSTR		cszBaseSnapinPath	= _T("Software\\Microsoft\\MMC\\Snapins");
static LPCTSTR		cszBaseNodeTypePath = _T("Software\\Microsoft\\MMC\\NodeTypes");
static LPCTSTR		cszNameString		= _T("NameString");
static LPCTSTR		cszProvider			= _T("Provider");
static LPCTSTR		cszVersion			= _T("Version");
static LPCTSTR		cszAbout			= _T("About");
static LPCTSTR		cszStandAlone		= _T("StandAlone");
static LPCTSTR		cszNodeTypes		= _T("NodeTypes");
static LPCTSTR		cszExtensions		= _T("Extensions");
static LPCTSTR		cszNameSpace		= _T("NameSpace");
static LPCTSTR		cszTask				= _T("Task");

static LPCTSTR		cszMSInfoBaseKey	= _T("Software\\Microsoft\\Shared Tools");
static LPCTSTR		cszMSInfoSubKey		= _T("MSInfo");
static LPCTSTR		cszMSInfoKey		= _T("Software\\Microsoft\\Shared Tools\\MSInfo");
static LPCTSTR		cszPathValue		= _T("Path");
static LPCTSTR		cszRunKey			= _T("Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\msinfo32.exe");
static LPCTSTR		cszRunRootKey		= _T("Software\\Microsoft\\Windows\\CurrentVersion\\App Paths");
static LPCTSTR		cszRunSubKey		= _T("msinfo32.exe");

static LPCTSTR		cszNFOExtension		= _T(".nfo");
static LPCTSTR		cszOLERegistration	= _T("MSInfo.Document");
static LPCTSTR		cszDefaultIconKey	= _T("DefaultIcon");

static LPCTSTR		cszCLSIDKey			= _T("CLSID");
static LPCTSTR		cszShellKey			= _T("shell");
static LPCTSTR		cszOpenCommandKey	= _T("open\\command");
static LPCTSTR		cszPrintCommandKey	= _T("print\\command");
static LPCTSTR		cszPrintToKey		= _T("printto\\command");

// note trailing quotes on file path
static LPCTSTR		cszMSInfoPath		= _T("Microsoft Shared\\MSInfo\\MSInfo32.exe\"");	
static LPCTSTR		cszDefaultIconValue	= _T("Microsoft Shared\\MSInfo\\MSInfo32.exe\",0"); 
static LPCTSTR		cszOpenCommand		= _T("Microsoft Shared\\MSInfo\\MSInfo32.exe\" /msinfo_file \"%1\"");

// these are never referenced 
static LPCTSTR		cszMSInfoDir	    = _T("Common Files\\Microsoft Shared\\MSInfo\\");
static LPCTSTR		cszPrintToCommand	= _T("Common Files\\Microsoft Shared\\MSInfo\\MSInfo32.exe /pt \"%1\" \"%2\" \"%3\" \"%4\"");
//static LPCTSTR		cszPrintCommand		= _T("Common Files\\Microsoft Shared\\MSInfo\\MSInfo32.exe /p \"%1\"");
//a-kjaw
static LPCTSTR		cszPrintCommand		= _T("Microsoft Shared\\MSInfo\\MSInfo32.exe\" /p \"%1\"");
//a-kjaw

//	Nodes we extend
static LPCTSTR		cszCompMgrNode		= _T("{476E6448-AAFF-11D0-B944-00C04FD8D5B0}");

CComModule _Module;

/*
 * Object Map of Registered objects, allowing the Active Template Library to
 *		register our CLSIDs.
 */
BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_MSInfo, CSystemInfoScopePrimary)
	OBJECT_ENTRY(CLSID_Extension, CSystemInfoScopeExtension)
	OBJECT_ENTRY(CLSID_About, CAboutImpl)
	OBJECT_ENTRY(CLSID_SystemInfo, CMSInfo)
END_OBJECT_MAP()

/*
 * The MSInfo application object.
 *
 * History:	a-jsari		10/1/97		Initial version.
 */
class CMSInfoApp : public CWinApp
{
public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
};

CMSInfoApp theApp;

/*
 * InitInstance - Initialize an instance of the application.
 *
 * History:	a-jsari		10/1/97		Initial version.
 */

extern void LoadDialogResources();
BOOL CMSInfoApp::InitInstance()
{
	_Module.Init(ObjectMap, m_hInstance);
	LoadDialogResources(); // loads dialog strings from resources
	return CWinApp::InitInstance();
}

/*
 * ExitInstance - Deconstruct an instance of the application.
 *
 * History:	a-jsari		10/1/97		Initial version.
 */
int CMSInfoApp::ExitInstance()
{
	_Module.Term();
	return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/*
 * RegOpenMMCRoot - Open CRegKey
 *
 * History:	a-jsari		9/9/97		Initial version
 */
static inline long RegOpenMMCRoot(CRegKey *pcrkMMCRoot)
{
	return pcrkMMCRoot->Open(HKEY_LOCAL_MACHINE, cszBasePath);
}

/*
 * RegOpenMMCSnapinRoot - Return MMC's registry Snapin root
 *
 * History:	a-jsari		9/9/97		Initial version
 */
static inline long RegOpenMMCSnapinRoot(CRegKey *pcrkSnapinRoot)
{
	return pcrkSnapinRoot->Open(HKEY_LOCAL_MACHINE, cszBaseSnapinPath);
}

/*
 * RegOpenMMCNodeTypeRoot - Return MMC's registry NodeType root
 *
 * History:	a-jsari		9/9/97		Initial version
 */
static inline long RegOpenMMCNodeTypeRoot(CRegKey *pcrkNodeTypesRoot)
{
	return pcrkNodeTypesRoot->Open(HKEY_LOCAL_MACHINE, cszBaseNodeTypePath);
}

/*
 * RegisterStandaloneSnapin() - Do all registration for the Standalone
 *		portion of the snapin.
 *
 * History:	a-jsari		9/9/97		Initial version
 *
 * Note: Would require AFX_MANAGE_STATE, except that the calling function
 *		handles it.
 */
static inline HRESULT RegisterStandaloneSnapin()
{
	CRegKey			crkRoot;
	CRegKey			crkClsid;
	CRegKey			crkIterator;
	CString			szResourceLoader;

	HRESULT			hr = E_FAIL;

	do {
		//	HKEY_CLASSES_ROOT\.nfo
		long	lRegOpenResult = crkRoot.Create(HKEY_CLASSES_ROOT, cszNFOExtension);
		if (lRegOpenResult != ERROR_SUCCESS) break;
		lRegOpenResult = crkRoot.SetValue(cszOLERegistration);
		if (lRegOpenResult != ERROR_SUCCESS) break;
		crkRoot.Close();

		//	HKEY_CLASSES_ROOT\MSInfo.Document
		lRegOpenResult = crkRoot.Create(HKEY_CLASSES_ROOT, cszOLERegistration);
		if (lRegOpenResult != ERROR_SUCCESS) break;
		
		// This originally set the default value for the key to "msinfo.document", which
		// is what would show up in the UI for a description of the NFO filetype. Fixing
		// this to load the string from a resource (bug 10442).
		//
		//	lRegOpenResult = crkRoot.SetValue(cszOLERegistration);
		//	if (lRegOpenResult != ERROR_SUCCESS) break;

		CString strDescription;
		strDescription.LoadString(IDS_NFODESCRIPTION);
		crkRoot.SetValue((LPCTSTR)strDescription);
		
		lRegOpenResult = crkIterator.Create(crkRoot, cszCLSIDKey);
		if (lRegOpenResult != ERROR_SUCCESS) break;
		lRegOpenResult = crkIterator.SetValue(cszClsidMSInfoSnapin);
		if (lRegOpenResult != ERROR_SUCCESS) break;
		crkIterator.Close();

		TCHAR	szWindowsPath[MAX_PATH];
		DWORD	dwSize;
		CString	szPathValue;
		dwSize = sizeof(szWindowsPath);
		lRegOpenResult = crkIterator.Open(HKEY_LOCAL_MACHINE, cszWindowsCurrentKey);
		if (lRegOpenResult != ERROR_SUCCESS) break;
		lRegOpenResult = crkIterator.QueryValue(szWindowsPath, cszCommonFilesValue, &dwSize);
		if (lRegOpenResult != ERROR_SUCCESS) break;
		lRegOpenResult = crkIterator.Create(crkRoot, cszDefaultIconKey);
		if (lRegOpenResult != ERROR_SUCCESS) break;
		szPathValue  = _T("\"");
		szPathValue += szWindowsPath;
		szPathValue += _T("\\");
		szPathValue += cszDefaultIconValue;
		lRegOpenResult = crkIterator.SetValue(szPathValue);
		if (lRegOpenResult != ERROR_SUCCESS) break;
		crkIterator.Close();
		lRegOpenResult = crkRoot.Create(crkRoot, cszShellKey);
		if (lRegOpenResult != ERROR_SUCCESS) break;
		lRegOpenResult = crkIterator.Create(crkRoot, cszOpenCommandKey);
		if (lRegOpenResult != ERROR_SUCCESS) break;

		szPathValue  = _T("\"");
		szPathValue += szWindowsPath;
		szPathValue += _T("\\");
		szPathValue += cszOpenCommand;

		lRegOpenResult = crkIterator.SetValue(szPathValue);
		if (lRegOpenResult != ERROR_SUCCESS) break;
		crkIterator.Close();
		//crkRoot.Close();
//a-kjaw

		lRegOpenResult = crkIterator.Create(crkRoot, cszPrintCommandKey);
		if (lRegOpenResult != ERROR_SUCCESS) break;
		
		szPathValue  = _T("\"");
		szPathValue += szWindowsPath;
		szPathValue += _T("\\");
		szPathValue += cszPrintCommand;		

		lRegOpenResult = crkIterator.SetValue(szPathValue);
		if (lRegOpenResult != ERROR_SUCCESS) break;
		crkIterator.Close();
		crkRoot.Close();
//a-kjaw

		//	HKEY_LOCAL_MACHINE\Software\Microsoft\MMC\Snapins
		lRegOpenResult =	RegOpenMMCSnapinRoot(&crkRoot);

		//	FIX: This fail should behave differently (registering the DLL
		//		w/o MMC registered).
		if (lRegOpenResult != ERROR_SUCCESS) break;
		//		{45ac8c63-23e2-11e1-a696-00c04fd58bc3}
		lRegOpenResult =			crkClsid.Create(crkRoot, cszClsidMSInfoSnapin);
		if (lRegOpenResult != ERROR_SUCCESS) break;
		//			NameString = REG_SZ "Microsoft System Information"
		VERIFY(szResourceLoader.LoadString(IDS_DESCRIPTION));
		lRegOpenResult =			crkClsid.SetValue(szResourceLoader, cszNameString);
		if (lRegOpenResult != ERROR_SUCCESS) break;
		//			About = REG_SZ "{45ac8c65-23e2-11e1-a696-00c04fd58bc3}"
		lRegOpenResult =			crkClsid.SetValue(cszClsidAboutMSInfo, cszAbout);
		if (lRegOpenResult != ERROR_SUCCESS) break;
		//			Provider = REG_SZ "Microsoft Corporation"
		VERIFY(szResourceLoader.LoadString(IDS_COMPANY));
		lRegOpenResult =			crkClsid.SetValue(szResourceLoader, cszProvider);
		if (lRegOpenResult != ERROR_SUCCESS) break;
		//			Version = REG_SZ "5.0"
		VERIFY(szResourceLoader.LoadString(IDS_VERSION));
		lRegOpenResult =			crkClsid.SetValue(szResourceLoader, cszVersion);
		if (lRegOpenResult != ERROR_SUCCESS) break;
		//			StandAlone
		lRegOpenResult =			crkIterator.Create(crkClsid, cszStandAlone);
		if (lRegOpenResult != ERROR_SUCCESS) break;
		//			NodeTypes
		lRegOpenResult =			crkIterator.Create(crkClsid, cszNodeTypes);
		if (lRegOpenResult != ERROR_SUCCESS) break;
		//				{45ac8c66-23e2-11e1-a696-00c04fd58bc3}
		CRegKey		crkNodeType;
		lRegOpenResult =			crkNodeType.Create(crkIterator, cszNodeTypeStatic);
		if (lRegOpenResult != ERROR_SUCCESS) break;

		//	Replace the SnapinRoot with the NodeType root;
		//	work from the new base.
		//	HKEY_LOCAL_MACHINE\Software\Microsoft\MMC\NodeTypes
		lRegOpenResult = RegOpenMMCNodeTypeRoot(&crkRoot);
		if (lRegOpenResult != ERROR_SUCCESS) break;
		//		{45ac8c66-23e2-11e1-a696-00c04fd58bc3}
		//			= REG_SZ "Microsoft System Information Root"
		VERIFY(szResourceLoader.LoadString(IDS_NODEDESCRIPTION));
		lRegOpenResult = crkRoot.SetKeyValue(cszNodeTypeStatic, szResourceLoader);
		if (lRegOpenResult != ERROR_SUCCESS) break;
		hr = S_OK;
	} while (0);
	return hr;
}

/*
 * HRESULT UnregisterStandaloneSnapin - Remove all registry entries for
 *		the standalone portion of the snapin.
 *
 * History:	a-jsari		9/9/97		Initial version.
 */
static inline HRESULT UnregisterStandaloneSnapin()
{
	CRegKey			crkSnapinRoot;

	//	Remove HKEY_CLASSES_ROOT\.nfo
	long lRegOpenResult = crkSnapinRoot.Open(HKEY_CLASSES_ROOT, NULL);
	if (lRegOpenResult != ERROR_SUCCESS) {
		if (lRegOpenResult != ERROR_FILE_NOT_FOUND) return E_FAIL;
	} else {
		lRegOpenResult = crkSnapinRoot.RecurseDeleteKey(cszNFOExtension);
		//	It's not really an error to not find a key we were deleting anyhow.
		if (lRegOpenResult != ERROR_SUCCESS
			&& lRegOpenResult != ERROR_FILE_NOT_FOUND) {
			return E_FAIL;
		}
		crkSnapinRoot.Close();
	}

	//	Remove HKEY_CLASSES_ROOT\MSInfo.Document
	lRegOpenResult = crkSnapinRoot.Open(HKEY_CLASSES_ROOT, NULL);
	if (lRegOpenResult != ERROR_SUCCESS) {
		if (lRegOpenResult != ERROR_FILE_NOT_FOUND) return E_FAIL;
	} else {
		lRegOpenResult = crkSnapinRoot.RecurseDeleteKey(cszOLERegistration);
		//	It's not really an error to not find a key we were deleting anyhow.
		if (lRegOpenResult != ERROR_SUCCESS
			&& lRegOpenResult != ERROR_FILE_NOT_FOUND) {
			return E_FAIL;
		}
		crkSnapinRoot.Close();
	}

	lRegOpenResult = RegOpenMMCSnapinRoot(&crkSnapinRoot);
	if (lRegOpenResult != ERROR_SUCCESS) {
		if (lRegOpenResult != ERROR_FILE_NOT_FOUND) return E_FAIL;
	} else {
		//	Just recursively delete our root.  Extensions will be automatically
		//	deleted as well.
		lRegOpenResult = crkSnapinRoot.RecurseDeleteKey(cszClsidMSInfoSnapin);
		//	It's not really an error to not find a key we were deleting anyhow.
		if (lRegOpenResult != ERROR_SUCCESS
			&& lRegOpenResult != ERROR_FILE_NOT_FOUND) {
			return E_FAIL;
		}
	}

	lRegOpenResult = RegOpenMMCNodeTypeRoot(&crkSnapinRoot);
	if (lRegOpenResult != ERROR_SUCCESS) {
		if (lRegOpenResult != ERROR_FILE_NOT_FOUND) return E_FAIL;
	} else {
		lRegOpenResult = crkSnapinRoot.RecurseDeleteKey(cszNodeTypeStatic);

		ASSERT(lRegOpenResult == ERROR_SUCCESS);
		//	It's not really an error to not find a key we were deleting anyhow.
		if (lRegOpenResult != ERROR_SUCCESS
			&& lRegOpenResult != ERROR_FILE_NOT_FOUND) {
			return E_FAIL;
		}
	}
	return S_OK;
}

/*
 * OpenExtendKeyForNodeType - Return in pcrkExtension the Registry Key for
 *		HKEY_LOCAL_MACHINE\Software\Microsoft\MMC\NodeTypes\
 *		cszNodeTypeGuid (GUID string) \Extensions
 * If fCreateIfNonextistent is TRUE, the Extensions key (only) is created
 *		if it doesn't exist.
 *
 * Return Codes:
 *		S_OK - All operations succeeded.
 *		E_FAIL - A critical registry operation failed.
 *		E_ABORT - The GUID string could not be opened, or
 *			the Extensions key could not be opened (and
 *			fCreateIfNonexistent is FALSE).
 *
 * History:	a-jsari		9/18/97		Initial version
 */
static inline HRESULT OpenExtendKeyForNodeType(LPCTSTR cszNodeTypeGuid,
			CRegKey *pcrkExtension, BOOL fCreateIfNonexistent = TRUE)
{	
	CRegKey			crkRoot;
	CRegKey			crkNodeToExtend;

	ASSERT(pcrkExtension != NULL);
	long lRegOpenResult = RegOpenMMCNodeTypeRoot(&crkRoot);
	if (lRegOpenResult != ERROR_SUCCESS) return E_FAIL;
	//	Not finding the proper nodetype is a different kind of error
	//		than not finding MMC, or not creating a new one.
	if (fCreateIfNonexistent) {
		lRegOpenResult = crkNodeToExtend.Create(crkRoot, cszNodeTypeGuid);
		if (lRegOpenResult != ERROR_SUCCESS) return E_FAIL;
		lRegOpenResult = pcrkExtension->Create(crkNodeToExtend, cszExtensions);
	} else {
		lRegOpenResult = crkNodeToExtend.Open(crkRoot, cszNodeTypeGuid);
		if (lRegOpenResult != ERROR_SUCCESS) return E_ABORT;
		lRegOpenResult = pcrkExtension->Open(crkNodeToExtend, cszExtensions);
		if (lRegOpenResult == ERROR_FILE_NOT_FOUND) return E_ABORT;
	}
	if (lRegOpenResult != ERROR_SUCCESS) return E_FAIL;
	return S_OK;
}

/*
 * ExtendNode - Does all registry extension required for the NodeType
 *		cszNodeTypeGuid.
 *
 * Return Codes:
 *		S_OK - Upon successful completion, or if cszNodeTypeGuid can't
 *				be found.
 *		E_FAIL - If MMC cannot be found or NodeTypeGuid can't be opened.
 *
 * History:	a-jsari		9/9/97	Initial version
 */
static HRESULT ExtendNode(LPCTSTR cszNodeTypeGuid)
{
	CRegKey			crkExtension;
	CRegKey			crkIterator;
	CString			szResourceLoader;

	HRESULT			hrOpenExtension = OpenExtendKeyForNodeType(cszNodeTypeGuid,
				&crkExtension, TRUE);
	// Don't return an error if we can't open the cszNodeTypeGuid
	if (hrOpenExtension != S_OK)
		return hrOpenExtension == E_ABORT ? S_OK : hrOpenExtension;

	//	NameSpace
	//		{GUID} = "System Information Extension"
	long lRegOpenResult = crkIterator.Create(crkExtension, cszNameSpace);
	if (lRegOpenResult != ERROR_SUCCESS) return E_FAIL;
	VERIFY(szResourceLoader.LoadString(IDS_EXTENSIONDESCRIPTION));
	lRegOpenResult = crkIterator.SetValue(szResourceLoader, cszClsidMSInfoExtension);
	if (lRegOpenResult != ERROR_SUCCESS) return E_FAIL;
	//	Task
	//		{GUID} = "System Information Extension"
	lRegOpenResult = crkIterator.Create(crkExtension, cszTask);
	if (lRegOpenResult != ERROR_SUCCESS) return E_FAIL;
	lRegOpenResult = crkIterator.SetValue(szResourceLoader, cszClsidMSInfoExtension);
	return S_OK;
}

/*
 * HRESULT UnregisterNode - Remove all registry entries for a specific
 *		Nodetype.
 *
 * Return Codes:
 *		S_OK - If all of the essential nodes are found.
 *		E_FAIL - If any of the path to the keys to remove fail to be found.
 *
 * History:	a-jsari		9/9/97		Initial version.
 */
static HRESULT UnregisterNode(LPCTSTR cszNodeTypeGuid)
{
		CRegKey		crkExtension;
		CRegKey		crkIterator;

		HRESULT		hrOpenExtension = OpenExtendKeyForNodeType(cszNodeTypeGuid,
					&crkExtension);
		ASSERT(hrOpenExtension == S_OK);
		//	Don't return an error if we can't open the cszNodeTypeGuid
		if (hrOpenExtension != S_OK)
			return (hrOpenExtension == E_ABORT) ? S_OK : hrOpenExtension;
		long lRegOpenResult = crkIterator.Open(crkExtension, cszNameSpace);
		if (lRegOpenResult != ERROR_SUCCESS)
			return (lRegOpenResult == ERROR_FILE_NOT_FOUND) ? S_OK : E_FAIL;
		lRegOpenResult = crkIterator.DeleteValue(cszClsidMSInfoExtension);

		//	It's not really an error to not find a key we were deleting anyhow.
		if (lRegOpenResult != ERROR_SUCCESS
			&& lRegOpenResult != ERROR_FILE_NOT_FOUND) {
			return E_FAIL;
		}
	return S_OK;
}

/*
 * RegisterExtensionSnapin - Do all registration required for the extension side
 *		of the snapin.
 *
 * History:	a-jsari		9/9/97		Initial version
 */
static inline HRESULT RegisterExtensionSnapin()
{
	const HRESULT	hrErrorReturn = E_FAIL;

	CRegKey			crkRoot;
	CRegKey			crkClsid;
	CRegKey			crkIterator;
	CString			szResourceLoader;

	//	HKEY_LOCAL_MACHINE\Software\Microsoft\MMC\Snapins
	long	lRegOpenResult =	RegOpenMMCSnapinRoot(&crkRoot);

	//	FIX: This fail should behave differently (registering the DLL
	//		w/o MMC registered).
	if (lRegOpenResult != ERROR_SUCCESS) return hrErrorReturn;
	//		{45ac8c63-23e2-11e1-a696-00c04fd58bc3}
	lRegOpenResult =			crkClsid.Create(crkRoot, cszClsidMSInfoExtension);
	if (lRegOpenResult != ERROR_SUCCESS) return hrErrorReturn;
	//			NameString = REG_SZ "System Information Extension"
	VERIFY(szResourceLoader.LoadString(IDS_EXTENSIONDESCRIPTION));
	lRegOpenResult =			crkClsid.SetValue(szResourceLoader, cszNameString);
	if (lRegOpenResult != ERROR_SUCCESS) return hrErrorReturn;
	//			Provider = REG_SZ "Microsoft Corporation"
	VERIFY(szResourceLoader.LoadString(IDS_COMPANY));
	lRegOpenResult =			crkClsid.SetValue(szResourceLoader, cszProvider);
	if (lRegOpenResult != ERROR_SUCCESS) return hrErrorReturn;
	//			Version = REG_SZ "5.0"
	VERIFY(szResourceLoader.LoadString(IDS_VERSION));
	lRegOpenResult =			crkClsid.SetValue(szResourceLoader, cszVersion);
	if (lRegOpenResult != ERROR_SUCCESS) return hrErrorReturn;

	// Register our about interface CLSID under the "About" value, so when
	// we're being added as an extension, our information shows up.

	lRegOpenResult = crkClsid.SetValue(cszClsidAboutMSInfo, cszAbout);
	if (lRegOpenResult != ERROR_SUCCESS) 
		return hrErrorReturn;

	//			NodeTypes
	lRegOpenResult =			crkIterator.Create(crkClsid, cszNodeTypes);
	if (lRegOpenResult != ERROR_SUCCESS) return hrErrorReturn;
	//				{45ac8c66-23e2-11e1-a696-00c04fd58bc3}
	CRegKey		crkNodeType;
	lRegOpenResult =			crkNodeType.Create(crkIterator, cszNodeTypeStatic);
	if (lRegOpenResult != ERROR_SUCCESS) return hrErrorReturn;

	// We no longer want to extend the computer management node (138503).
	// So we won't make this call to create the extension key. Also, we'll
	// delete it if it exists.
	//
	//	HRESULT		hrExtend = ExtendNode(cszCompMgrNode);
	//	ASSERT(hrExtend == S_OK);
	//	return hrExtend;

	CRegKey crkCompmgmtExtension;
	if (SUCCEEDED(OpenExtendKeyForNodeType(cszCompMgrNode, &crkCompmgmtExtension, TRUE)))
	{
		CRegKey crkNameSpace, crkTaskPad;

		if (ERROR_SUCCESS == crkNameSpace.Open((HKEY)crkCompmgmtExtension, cszNameSpace))
			crkNameSpace.DeleteValue(cszClsidMSInfoExtension);

		if (ERROR_SUCCESS == crkTaskPad.Open((HKEY)crkCompmgmtExtension, cszTask))
			crkTaskPad.DeleteValue(cszClsidMSInfoExtension);
	}

	return S_OK;
}

/*
 * UnregisterExtensionSnapin - Unregister the extension part of the snapin.
 *
 * History:	a-jsari		9/9/97		Initial version
 */
static inline HRESULT UnregisterExtensionSnapin()
{
	CRegKey			crkSnapinRoot;

	long lRegOpenResult = RegOpenMMCSnapinRoot(&crkSnapinRoot);
	if (lRegOpenResult != ERROR_SUCCESS) {
		if (lRegOpenResult != ERROR_FILE_NOT_FOUND) return E_FAIL;
	} else {
		// CHECK: Is this appropriate for potential extensions (probably)
		lRegOpenResult = crkSnapinRoot.RecurseDeleteKey(cszClsidMSInfoExtension);

		ASSERT(lRegOpenResult == ERROR_SUCCESS);
		//	It's not really an error to not find a key we were deleting anyhow.
		if (lRegOpenResult != ERROR_SUCCESS
			&& lRegOpenResult != ERROR_FILE_NOT_FOUND) {
			return E_FAIL;
		}
	}

	HRESULT		hrUnregister = UnregisterNode(cszCompMgrNode);
	return hrUnregister;
}

/*
 * RegisterPaths - Perform registration for path items
 *
 * History:	a-jsari		12/4/97		Initial version.
 */
static inline HRESULT RegisterPaths()
{
	CRegKey		crkSnapinRoot;
	CRegKey		crkProgramFilesKey;
	TCHAR		szBuffer[MAX_PATH];
	CString		strPath;
	DWORD		dwSize;
	long		lResult;

	do {
		//	Register MSInfo's Windows App Path.
		lResult = crkSnapinRoot.Open(HKEY_LOCAL_MACHINE, cszMSInfoKey);
		ASSERT(lResult == ERROR_SUCCESS);
		if (lResult != ERROR_SUCCESS) break;
		dwSize = sizeof(szBuffer);
		//	Get the Path registry value into szBuffer
		lResult = crkSnapinRoot.QueryValue(szBuffer, cszPathValue, &dwSize);
		if (lResult != ERROR_SUCCESS) {
			//	The path can't be read from the registry; register it.
			lResult = crkProgramFilesKey.Open(HKEY_LOCAL_MACHINE, cszWindowsCurrentKey);
			ASSERT(lResult == ERROR_SUCCESS);
			if (lResult != ERROR_SUCCESS) break;
			dwSize = sizeof(szBuffer);
			lResult = crkProgramFilesKey.QueryValue(szBuffer, cszCommonFilesValue, &dwSize);
			ASSERT(lResult == ERROR_SUCCESS);
			if (lResult != ERROR_SUCCESS) break;

			// Remove the quotes from around the path. Bug #363834.
			// strPath  = "\"";
			strPath = CString(_T(""));
			strPath += szBuffer;
			strPath += _T("\\");
			strPath += cszMSInfoPath;

			// Remove the quotes from around the path to mimic the behaviour of MSInfo 4.10 
			// (so that apps which used this key to launch MSInfo will continue to work). Bug #363834.

			if (strPath.Right(1) == CString(_T("\"")))
				strPath = strPath.Left(strPath.GetLength() - 1);

			//	Set the path value: Path = <Path to MSInfo32.exe>
			lResult = crkSnapinRoot.SetValue(strPath, cszPathValue);
			ASSERT(lResult == ERROR_SUCCESS);
			if (lResult != ERROR_SUCCESS) break;
		} else {
			//	Read the path from the previously registered location and set the variable
			//	equal to it.
			strPath = szBuffer;

			// Remove the quotes from around the path. Bug #363834.

			if (strPath.Left(1) == CString(_T("\"")))
			{
				strPath = strPath.Right(strPath.GetLength() - 1);
				if (strPath.Right(1) == CString(_T("\"")))
					strPath = strPath.Left(strPath.GetLength() - 1);

				lResult = crkSnapinRoot.SetValue(strPath, cszPathValue);
			}
		}

		// Bug #363834 - we still want quotes around the string when it's written elsewhere in the registry.

		if (strPath.Left(1) != CString(_T("\"")))
			strPath = _T("\"") + strPath;

		if (strPath.Right(1) != CString(_T("\"")))
			strPath += _T("\"");

		lResult = crkSnapinRoot.Create(HKEY_LOCAL_MACHINE, cszRunKey);
		ASSERT(lResult == ERROR_SUCCESS);
		if (lResult != ERROR_SUCCESS) break;
		lResult = crkSnapinRoot.SetValue(strPath);
		ASSERT(lResult == ERROR_SUCCESS);
		if (lResult != ERROR_SUCCESS) break;
		int		iValue = strPath.ReverseFind((TCHAR)'\\');
		strPath = strPath.Left(iValue);
		strPath += "\"";

		lResult = crkSnapinRoot.SetValue(strPath, cszPathValue);
		ASSERT(lResult == ERROR_SUCCESS);
		if (lResult != ERROR_SUCCESS) break;

#if 0
		//	We are now assuming that the path to MSInfo will be registered by some
		//	outside agent, presumably setup.
		//	Register the Path in the MSInfo directory
		lResult = crkSnapinRoot.Open(HKEY_LOCAL_MACHINE, cszMSInfoKey);
		ASSERT(lResult == ERROR_SUCCESS);
		if (lResult != ERROR_SUCCESS) break;
		//	Reuse the saved szPath value.
		lResult = crkSnapinRoot.SetValue(szPath, cszPathValue);
		ASSERT(lResult == ERROR_SUCCESS);
#endif
	} while (FALSE);
	return HRESULT_FROM_WIN32(lResult);
}

/*
 * UnregisterPaths - Remove registry entries for path items.
 *
 * History:	a-jsari		12/4/97		Initial version
 */
static inline HRESULT UnregisterPaths()
{
	CRegKey		crkRootKey;
	long		lResult;

	do {
		//	Remove the App Path
		lResult = crkRootKey.Open(HKEY_LOCAL_MACHINE, cszRunRootKey);
		if (lResult != ERROR_SUCCESS) break;
		lResult = crkRootKey.DeleteSubKey(cszRunSubKey);
		ASSERT(lResult == ERROR_SUCCESS);
		if (lResult != ERROR_SUCCESS) break;

		//	Unregister the MSInfo Key
		lResult = crkRootKey.Open(HKEY_LOCAL_MACHINE, cszMSInfoBaseKey);
		ASSERT(lResult == ERROR_SUCCESS);
		if (lResult != ERROR_SUCCESS) break;
		lResult = crkRootKey.DeleteSubKey(cszMSInfoSubKey);
		ASSERT(lResult == ERROR_SUCCESS);
	} while (FALSE);
	return HRESULT_FROM_WIN32(lResult);
}

/*
 * DllRegisterServer - Registers the snapin in
 *		HKEY_LOCAL_MACHINE\Software\Microsoft\MMC
 *		HKEY_LOCAL_MACHINE\Software\Classes\MSInfo.*
 *		HKEY_CLASSES_ROOT\CLSID\{45AC8C6...}
 *
 * History:	a-jsari		9/9/97		Initial version.
 */
STDAPI DllRegisterServer(void)
{
	long	lToolResult;
	if ((lToolResult = CToolList::Register(TRUE)) != ERROR_SUCCESS)
		return HRESULT_FROM_WIN32(lToolResult);
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	HRESULT		hrRegister = RegisterStandaloneSnapin();
	if (hrRegister != S_OK) return hrRegister;
	hrRegister = RegisterExtensionSnapin();
	if (hrRegister != S_OK) return hrRegister;
	hrRegister = RegisterPaths();
	if (hrRegister != S_OK) return hrRegister;
	// Registers object and all interfaces in typelib
#if 0
	//	This version has been failing
	return _Module.RegisterServer(TRUE);
#else
	//	So use this method.
	return _Module.RegisterServer(FALSE);
#endif
}

/*
 * DllUnregisterServer - Removes entries from the system registry
 *
 * History:	a-jsari		9/9/97		Initial version.
 */
STDAPI DllUnregisterServer(void)
{
	HRESULT		hrReturn = S_OK;
	long		lToolResult;

	if ((lToolResult = CToolList::Register(FALSE)) != ERROR_SUCCESS)
		hrReturn = HRESULT_FROM_WIN32(lToolResult);
	HRESULT		hrUnregister = UnregisterStandaloneSnapin();
	if (hrUnregister != S_OK) hrReturn = hrUnregister;
	hrUnregister = UnregisterExtensionSnapin();
	if (hrUnregister != S_OK) hrReturn = hrUnregister;
	hrUnregister = UnregisterPaths();
	if (hrUnregister != S_OK) hrReturn = hrUnregister;
	_Module.UnregisterServer();
	return hrReturn;
}

//-----------------------------------------------------------------------------
// Implementation for the CMSInfoLog class, used to keep a log of MSInfo
// activities.
//
// This global variable can be used elsewhere in the snap-in to write log
// entries. Only one should be created.
//-----------------------------------------------------------------------------

CMSInfoLog msiLog;

//-----------------------------------------------------------------------------
// The constructor needs to read the logging state information from the
// registry.
//-----------------------------------------------------------------------------

CMSInfoLog::CMSInfoLog()
{
	m_pLogFile = NULL;
	m_strEndMarker = _T("###"); // see note in OpenLogFile
	ReadLoggingStatus();
}

//-----------------------------------------------------------------------------
// The destructor needs to close the file (if it was ever created and opened).
// Also, this is a good place to put the exit MSInfo log entry.
//-----------------------------------------------------------------------------

CMSInfoLog::~CMSInfoLog()
{
	if (this->IsLogging())
		this->WriteLog(CMSInfoLog::BASIC, _T("EXIT MSInfo\r\n"));

	try
	{
		if (m_pLogFile)
		{
			// Advance past the marker we wrote.

			m_pLogFile->Seek(m_strEndMarker.GetLength() * sizeof(TCHAR), CFile::current);

			// If we aren't at the end of the file, then we've at some point wrapped
			// to the beginning and are overwriting entries. To make it so there are
			// no incomplete entries, write spaces until the end of the file or until
			// we find a '\r' character.

			DWORD dwLength = m_pLogFile->GetLength();
			DWORD dwPosition = m_pLogFile->GetPosition();
			if (dwPosition < dwLength)
			{
				DWORD dwBytesRead = 0;
				TCHAR cRead;

				do
				{
					if (m_pLogFile->Read((void *) &cRead, sizeof(TCHAR)) < sizeof(TCHAR))
						break;
					dwBytesRead += sizeof(TCHAR);
				} while (cRead && cRead != _T('\r') && (dwPosition + dwBytesRead) < dwLength);

				if (dwBytesRead)
				{
					m_pLogFile->Seek(dwBytesRead * -1, CFile::current);

					// Write the spaces (but don't overwrite the '\r' character).

					if (cRead == _T('\0') || cRead == _T('\r'))
						dwBytesRead -= sizeof(TCHAR);
					WriteSpaces(dwBytesRead / sizeof(TCHAR));
				}
			}

			m_pLogFile->Close();
			delete m_pLogFile;
			m_pLogFile = NULL;
		}
	}
	catch (CFileException *e)
	{
		// Some sort of file error - turn off logging.

		m_fLoggingEnabled = FALSE;
		m_iLoggingMask = 0;
	}
}

//-----------------------------------------------------------------------------
// These two WriteLog functions are for writing a log entry directly to the
// file. The second (with two string parameters) assumes that the first
// string is a format with a '%s' and the second is the replacement string.
//
// The iType parameter is used to indicate what sort of log entry this is.
// The const int values from the class definition should be used.
//
// If fContinuation is TRUE, then this write is to terminate a log entry which
// spans an operation, and should not have a timestamp added.
//-----------------------------------------------------------------------------

BOOL CMSInfoLog::WriteLog(int iType, const CString & strMessage, BOOL fContinuation)
{
	if (!OpenLogFile())
		return FALSE;

	if ((m_iLoggingMask & iType) == 0)
		return FALSE;

	CString strWorking(strMessage);

	// If this isn't the continuation of a previous log entry, then 
	// possibly add a timestamp.

	if (!fContinuation && m_fTimestamp)
	{
		CTime time = CTime::GetCurrentTime();
		strWorking = time.Format(_T("%Y-%m-%d %H:%M:%S ")) + strWorking;
	}

	return WriteLogInternal(strWorking);
}

BOOL CMSInfoLog::WriteLog(int iType, const CString & strFormat, const CString & strReplace1)
{
	CString strCombined;

	strCombined.Format(strFormat, strReplace1);
	return WriteLog(iType, strCombined);
}
	
//-----------------------------------------------------------------------------
// This function is called each time a log entry is written, to insure that
// the log file is open. If we can't open the file, or shouldn't be logging in
// the first place, this function should return FALSE.
//-----------------------------------------------------------------------------

BOOL CMSInfoLog::OpenLogFile()
{
	if (!m_fLoggingEnabled)
		return FALSE;

	if (m_pLogFile == NULL)
	{
		m_pLogFile = new CFile;
		if (m_pLogFile == NULL)
			return FALSE;

		try
		{
			if (!m_pLogFile->Open(m_strFilename, CFile::modeCreate | CFile::modeNoTruncate | CFile::modeReadWrite))
			{
				delete m_pLogFile;
				m_pLogFile = NULL;
				m_fLoggingEnabled = FALSE;
				m_iLoggingMask = 0;
				return FALSE;
			}

			// Move to the right place in the file. If the file is empty, we're
			// already there. If not, look for the end marker (from the last time
			// we added log entries). If there is one, we should be positioned over
			// its first character. Otherwise, just move to the end of the file.

			if (m_pLogFile->GetLength() != 0)
			{
				// IMPORTANT NOTE: We assume here (for efficiency) that the end
				// marker is structured so that we don't need to back up when
				// searching the file. For example, no markers of the form "aaab".

				TCHAR	cRead;
				int		iMarker = 0;

				while (iMarker != m_strEndMarker.GetLength())
				{
					if (m_pLogFile->Read((void *) &cRead, sizeof(TCHAR)) < sizeof(TCHAR))
						break;

					if (cRead != m_strEndMarker[iMarker])
						iMarker = 0;

					if (cRead == m_strEndMarker[iMarker])
						iMarker++;
				}

				if (iMarker == m_strEndMarker.GetLength())
					m_pLogFile->Seek(m_strEndMarker.GetLength() * sizeof(TCHAR) * -1, CFile::current);
				else
					m_pLogFile->SeekToEnd();
			}
		}
		catch (CFileException *e)
		{
			// Some sort of file error - turn off logging.

			m_fLoggingEnabled = FALSE;
			m_iLoggingMask = 0;
			return FALSE;
		}
	}

	return TRUE;
}

//-----------------------------------------------------------------------------
// This function reads information about logging (what to log, where to log,
// etc.) out of the registry.
//-----------------------------------------------------------------------------

void CMSInfoLog::ReadLoggingStatus()
{
	m_fLoggingEnabled	= FALSE;
	m_fTimestamp		= TRUE;
	m_strFilename		= _T("");
	m_iLoggingMask		= 0;
	m_dwMaxFileSize		= 32 * 1024;

	CString	strRegkey = CString(cszMSInfoKey) + CString(_T("\\Logging"));
	CRegKey regkey;

	if (ERROR_SUCCESS == regkey.Open(HKEY_LOCAL_MACHINE, strRegkey, KEY_READ))
	{
		DWORD dwTemp;

		dwTemp = 0;
		if (ERROR_SUCCESS == regkey.QueryValue(dwTemp, _T("LogMask")))
			m_iLoggingMask = (int) dwTemp;

		dwTemp = 0;
		if (ERROR_SUCCESS == regkey.QueryValue(dwTemp, _T("LogFileMaxSize")))
			m_dwMaxFileSize = dwTemp;

		dwTemp = 0;
		if (ERROR_SUCCESS == regkey.QueryValue(dwTemp, _T("LogTimestamp")))
			m_fTimestamp = (dwTemp) ? TRUE : FALSE;

		TCHAR szFilename[MAX_PATH];
		dwTemp = MAX_PATH;
		if (ERROR_SUCCESS == regkey.QueryValue(szFilename, _T("LogFilename"), &dwTemp))
			m_strFilename = szFilename;

		regkey.Close();
	}

	m_fLoggingEnabled = ((m_iLoggingMask != 0) && !m_strFilename.IsEmpty());
}

//-----------------------------------------------------------------------------
// Write a string to the log file. We should be positioned before the end
// marker in the file. Overwrite this, and add the end marker onto the end
// of the string we are writing.
//
// If we are too close to the maximum file size, then fill the rest of the
// file (to that point) with spaces, and wrap to the start of the file.
//
// After we've written the output, back up so that we are positioned over the
// start of the end marker.
//-----------------------------------------------------------------------------

BOOL CMSInfoLog::WriteLogInternal(const CString & strMessage)
{
	CString strTerminated = strMessage + m_strEndMarker;
	DWORD	dwLength = strTerminated.GetLength() * sizeof(TCHAR);

	if (m_pLogFile == NULL)
		return FALSE;

	try
	{
		// If we are too close to the max size of the file, write spaces to that
		// size and start from the beginning.

		DWORD dwPosition = m_pLogFile->GetPosition();
		if (m_dwMaxFileSize && ((dwPosition + dwLength) > m_dwMaxFileSize))
		{
			WriteSpaces((m_dwMaxFileSize - dwPosition) / sizeof(TCHAR));
			m_pLogFile->SeekToBegin();
		}

		// Write the string to the file.

		m_pLogFile->Write((const void *) (LPCTSTR) strTerminated, strTerminated.GetLength() * sizeof(TCHAR));

		// Finally, back up over the terminating characters.

		m_pLogFile->Seek(m_strEndMarker.GetLength() * sizeof(TCHAR) * -1, CFile::current);
	}
	catch (CFileException *e)
	{
		// Some sort of file error - turn off logging.

		m_fLoggingEnabled = FALSE;
		m_iLoggingMask = 0;
	}

	return TRUE;
}

//-----------------------------------------------------------------------------
// Write the specified number of spaces to the file. (Note, this will already
// be inside an exeption handling block from the caller.)
//-----------------------------------------------------------------------------

void CMSInfoLog::WriteSpaces(DWORD dwCount)
{
	TCHAR * szSpaceBuffer = NULL;
	szSpaceBuffer = new TCHAR[dwCount];
	if (szSpaceBuffer)
	{
		_tcsnset(szSpaceBuffer, _T(' '), dwCount);
		m_pLogFile->Write((const void *) (LPCTSTR) szSpaceBuffer, dwCount * sizeof(TCHAR));
		delete [] szSpaceBuffer;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\resrc1.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by MSInfo.rc
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
#define IDS_TASK_TITLE                  209
#define IDS_BACKGROUND_RESPATH          210
#define IDS_BITMAP_RESPATH              211
#define IDS_MOUSEOVER_RESPATH           212
#define IDS_MOUSEOFF_RESPATH            213
#define IDS_ORDERED_TASKTEXT0           214
#define IDS_ORDERED_TASKTEXT1           215
#define IDS_ORDERED_TASKTEXT2           216
#define IDS_ORDERED_TASKTEXT3           217
#define IDS_ORDERED_TASKTEXT4           218
#define IDB_TASK_MOUSEOVER              218
#define IDS_ORDERED_TASKTEXT5           219
#define IDS_ORDERED_TASKTEXT6           220
#define IDS_ORDERED_TASKTEXT7           221
#define IDS_ORDERED_TASKTEXT8           222
#define IDS_ORDERED_TASKTEXT9           223
#define IDS_ORDERED_TASKHELP0           224
#define IDS_ORDERED_TASKHELP1           225
#define IDS_ORDERED_TASKHELP2           226
#define IDS_ORDERED_TASKHELP3           227
#define IDS_ORDERED_TASKHELP4           228
#define IDS_ORDERED_TASKHELP5           229
#define IDS_ORDERED_TASKHELP6           230
#define IDS_ORDERED_TASKHELP7           231
#define IDS_ORDERED_TASKHELP8           232
#define IDS_ORDERED_TASKHELP9           233
#define IDS_NAVIGATION_TASKTEXT         234
#define IDS_NAVIGATION_TASKHELP         235
#define IDS_TASKPAD_DHTML               236
#define IDS_ROOT_TASKPAD                237
#define IDS_PROBLEM_DEVICES_PATH        238
#define IDS_INITIAL_PATH                239
#define IDS_SUMMARY_PATH                240
#define IDS_MMCEXE                      241
#define IDS_ORDERED_TASKBUTTON0         242
#define IDS_ORDERED_TASKBUTTON1         243
#define IDS_ORDERED_TASKBUTTON2         244
#define IDS_ORDERED_TASKBUTTON3         245
#define IDS_ORDERED_TASKBUTTON4         246
#define IDS_ORDERED_TASKBUTTON5         247
#define IDS_ORDERED_TASKBUTTON6         248
#define IDS_ORDERED_TASKBUTTON7         249
#define IDS_ORDERED_TASKBUTTON9         250
#define IDS_NAVIGATION_TASKBUTTON       251
#define IDS_NOLOCATOR                   252
#define IDS_GATHERACCESS                253
#define IDS_BADSERVER                   254
#define IDS_NETWORKERROR                255
#define IDS_BAD_PROPERTY                256
#define IDS_PROPERTY_UNAVAILABLE        257
#define IDS_LOCAL_CONNECT               258
#define IDS_LISTPAD_BUTTON              259
#define IDS_FIND_TITLE                  260
#define IDS_REPORT_CATEGORY             261
#define IDS_REPORT_REPLACEMENT          262
#define IDS_CAB_NAME                    263
#define IDS_CAB_DESCRIPTION             264
#define IDS_TOOMANYOPENFILES            265
#define IDS_LOCALCOMPLABEL      	266
#define IDS_OUTOFMEMERROR               267
#define IDS_SAVE_FILE_TYPES             268
#define IDS_OPEN_FILE_TYPES             269
#define IDS_REPORT_TYPES                270
#define IDS_SAVE_TYPE                   271
#define IDS_REPORT_TYPE                 272
#define IDS_MSINFO_HELP_FILE		273
#define IDS_ROOT_NODE_TYPE		274
#define IDS_ROOT_NODE_DESCRIPTION	275
#define IDS_WBEM_ACCESS_DENIED		276
#define IDS_WBEM_TRANSPORT_FAILURE	277
#define IDS_DEFAULT_TOOLS		278
#define IDS_CLOSEFILEMENUNAME		279
#define IDS_CLOSEFILEMENUSTATUS		280
#define IDS_MSINFO_HELP_TOPIC   	281
#define IDS_REFRESHING_MSG		282
#define IDS_410SUMMARY_NODE		283
#define IDS_SIZEBYTES 			284
#define IDS_SIZEKB_BYTES		285
#define IDS_SIZEMB_BYTES		286
#define IDS_SIZEGB_BYTES		287
#define IDS_SIZEKB			288
#define IDS_NFODESCRIPTION		289

#define IDS_MSITEMPLATEBASE		300

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        219
#define _APS_NEXT_COMMAND_VALUE         32776
#define _APS_NEXT_CONTROL_VALUE         213
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\resrtmpl.cpp ===
//=============================================================================
// File:			rsrctmpl.cpp
// Author:		a-jammar
// Covers:		reading template from resources
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// This file contains the functions necessary to read the template information
// from the resources of this DLL. The template information is reconstructed
// from the resources so we can use the existing template parsing functions.
//=============================================================================

#include "stdafx.h"
#include "gather.h"
#include "gathint.h"
#include "resrc1.h"

static BOOL					fTemplateLoaded = FALSE;
static DWORD				dwTemplateInfoLen = 0;
static unsigned char *	pTemplateInfo = NULL;

// This table contains the keywords found in the template stream.

#define KEYWORD_COUNT 19
char * KEYWORD_STRING[KEYWORD_COUNT] = 
{
	"node", "columns", "line", "field", "enumlines", "(", ")", "{", "}",
	",", "\"basic\"", "\"advanced\"", "\"BASIC\"", "\"ADVANCED\"",
	"\"static\"", "\"LEXICAL\"", "\"VALUE\"", "\"NONE\"", "\"\""
};

//-----------------------------------------------------------------------------
// To support the way template information is loaded from resources now, we
// need to have an external entry point into this DLL (so we can get the
// default information like we template info from other DLLs).
//
// A pointer to the reconstructed template file is returned to the caller,
// as well as the length of the file. If a NULL pointer is passed as the
// parameter, the buffer containing the template file is deleted (to
// reclaim space).
//-----------------------------------------------------------------------------

void LoadTemplate();
extern "C" __declspec(dllexport) 
DWORD __cdecl GetTemplate(void ** ppBuffer)
{
	TRY
	{
		if (!fTemplateLoaded)
		{
			LoadTemplate();
			fTemplateLoaded = TRUE;
		}

		if (ppBuffer == NULL)
		{
			if (pTemplateInfo)
				delete pTemplateInfo;

			fTemplateLoaded = FALSE;
			dwTemplateInfoLen = 0;
			pTemplateInfo = NULL;
			return 0;
		}
		
		*ppBuffer = (void *)pTemplateInfo;
		return dwTemplateInfoLen;
	}
	CATCH_ALL(e)
	{
#ifdef _DEBUG
		e->ReportError();
#endif
	}
	END_CATCH_ALL

	return 0;
}

//-----------------------------------------------------------------------------
// The LoadTemplate function needs to load the template information out of
// our resources, and create a buffer which contains the restored template
// file to return to our caller (through GetTemplate).
//-----------------------------------------------------------------------------

void LoadTemplate()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	CMapWordToPtr	mapNonLocalized;
	HRSRC				hrsrcNFN;
	HGLOBAL			hglbNFN;
	unsigned char	*pData;
	WORD				wID;
	CString			strToken, *pstrToken;

	// Load the non-localized strings from the custom resource type and create
	// a map of ID to strings. Because these are non-localized strings, they
	// will not be stored as UNICODE.

	hrsrcNFN		= FindResource(AfxGetResourceHandle(), _T("#1"), _T("MSINonLocalizedTokens"));

	if(hrsrcNFN)
		hglbNFN		= LoadResource(AfxGetResourceHandle(), hrsrcNFN);

	if(hglbNFN)
		pData		= (unsigned char *)LockResource(hglbNFN);

	while (pData && *((WORD UNALIGNED *)pData))
	{
		wID  = (WORD)(((WORD)*pData++) << 8);	// deal with the byte order explicitly to avoid
		wID |= (WORD)*pData++;						// endian problems.

		pstrToken = new CString((char *)pData);
		pData += strlen((char *)pData) + 1;

		if (pstrToken)
			mapNonLocalized.SetAt(wID, (void *)pstrToken);
	}

	// Load the binary stream of token identifiers into memory.

	HRSRC				hrsrcNFB = FindResource(AfxGetResourceHandle(), _T("#1"), _T("MSITemplateStream"));
	HGLOBAL				hglbNFB;
	unsigned char		*pStream = NULL;

	if(hrsrcNFB)
		hglbNFB = LoadResource(AfxGetResourceHandle(), hrsrcNFB);
	
	if(hglbNFB)
		pStream = (unsigned char *) LockResource(hglbNFB);

	if (pStream != NULL)
	{
		// The first DWORD in the stream is the size of the original text file. We'll
		// use this to allocate our buffer to store the reconstituted file.

		DWORD dwSize;
		dwSize  = ((DWORD)*pStream++) << 24;
		dwSize |= ((DWORD)*pStream++) << 16;
		dwSize |= ((DWORD)*pStream++) << 8;
		dwSize |= ((DWORD)*pStream++);

		// The size stored with for an Ansi text file. We need to adjust for the
		// fact that our reconstituted file will be UNICODE. We also want to add
		// a word to the front of the stream to hold the UNICODE file marker (so
		// we can use the same functions to read a file or this stream).

		dwSize *= sizeof(TCHAR);
		dwSize += sizeof(WORD);
		pTemplateInfo = new unsigned char[dwSize];
		dwTemplateInfoLen = 0;
		if (pTemplateInfo == NULL)
			return;

		// Write the UNICODE file marker.

		wID = 0xFEFF;
		memcpy(&pTemplateInfo[dwTemplateInfoLen], (void *)&wID, sizeof(WORD));
		dwTemplateInfoLen += sizeof(WORD);

		// Process the stream a token at a time.

		while (pStream && *pStream)
		{
			if ((*pStream & 0x80) == 0x00)
			{
				// A byte with the high bit clear refers to a keyword. Look up the keyword
				// from the table, and add it to the restored file.

				wID = (WORD)(((WORD)*pStream++) - 1); ASSERT(wID <= KEYWORD_COUNT);
				if (wID <= KEYWORD_COUNT)
					strToken = KEYWORD_STRING[wID];
			}
			else
			{
				wID  = (WORD)(((WORD)*pStream++) << 8);	// deal with the byte order explicitly to avoid
				wID |= (WORD)*pStream++;						// endian problems.

				if ((wID & 0xC000) == 0x8000)
				{
					// A byte with the high bit set, but the next to high bit clear indicates
					// the ID is actually a word, and should be used to get a non-localized
					// string. Get the string out of the map we created and add it to the file.

					if (mapNonLocalized.Lookup((WORD)(wID & 0x7FFF), (void *&)pstrToken))
						strToken = *pstrToken;
					else
						ASSERT(FALSE);
				}
				else
				{
					// A byte with the two MSB set indicates that the ID is a word, and should
					// be used to reference a localized string out of the string table in this
					// module's resources. This string will be UNICODE.

					VERIFY(strToken.LoadString((wID & 0x3FFF) + IDS_MSITEMPLATEBASE));
					strToken = _T("\"") + strToken + _T("\"");
				}
			}

			// Store the token on the end of our buffer. The data in this buffer must
			// be UNICODE, so we'll need to convert the string if necessary.

			if (dwTemplateInfoLen + strToken.GetLength() * sizeof(TCHAR) < dwSize)
			{
				memcpy(&pTemplateInfo[dwTemplateInfoLen], (void *)(LPCTSTR)strToken, strToken.GetLength() * sizeof(TCHAR));
				dwTemplateInfoLen += strToken.GetLength() * sizeof(TCHAR);
			}
			else
				ASSERT(FALSE);
		}
	}

	// Delete the contents of the lookup table.

	for (POSITION pos = mapNonLocalized.GetStartPosition(); pos != NULL;)
	{
		mapNonLocalized.GetNextAssoc(pos, wID, (void *&)pstrToken);
		if (pstrToken)
			delete pstrToken;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\provider.cpp ===
//=============================================================================
// File:                provider.cpp
// Author:              a-jammar
// Covers:              CDataProvider
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// This file contains functions implementing the class which uses WBEM to
// retrieve information, including handling enumeration of class instances.
// For usage, see gathint.h.
//
// NOTE: define GATH_STANDALONE if this class is being used in an application
// which doesn't call CoInitialize().
//=============================================================================

#include "stdafx.h"
#include "gather.h"
#include "gathint.h"
#pragma warning(disable : 4099)
#include "wbemcli.h"
#pragma warning(default : 4099)
#include "resource.h"
#include "resrc1.h"

#ifndef WBEM_FLAG_USE_AMENDED_QUALIFIERS
#define WBEM_FLAG_USE_AMENDED_QUALIFIERS 0x20000
#endif

#ifdef PROFILE_MSINFO
	CFile fileProfile(_T("c:\\msinfo32.txt"), CFile::modeCreate | CFile::modeWrite);
	static DWORD dwProfileTime;

	inline void START_TIMER()
	{
		dwProfileTime = ::GetTickCount();
	}

	inline void END_TIMER(const CString & strOperation)
	{
		USES_CONVERSION;

		DWORD	dwDelta = ::GetTickCount() - dwProfileTime;
		CString	strMessage;

		strMessage.Format(_T("%ld.%03d\t%s\r\n"), dwDelta / 1000, dwDelta % 100, strOperation);
		fileProfile.Write((const void *) (LPCTSTR) strMessage, strMessage.GetLength()*sizeof(TCHAR));
	}

	inline void END_TIMER(const CString & strOperation, const CString & strArg)
	{
		USES_CONVERSION;

		DWORD	dwDelta = ::GetTickCount() - dwProfileTime;
		CString strTemp;
		CString	strMessage;

		strTemp.Format(strOperation, strArg);
		strMessage.Format(_T("%ld.%03d\t%s\r\n"), dwDelta / 1000, dwDelta % 100, strTemp);
		fileProfile.Write((const void *) (LPCTSTR) strMessage, strMessage.GetLength()*sizeof(TCHAR));
	}

	inline void WRITE(const CString & strMessage)
	{
		fileProfile.Write((const void *) (LPCTSTR) strMessage, strMessage.GetLength()*sizeof(TCHAR));
	}

	inline void WRITE(const CString & strMessage, const CString & strArg)
	{
		CString strTemp;
		strTemp.Format(strMessage, strArg);
		fileProfile.Write((const void *) (LPCTSTR) strTemp, strTemp.GetLength()*sizeof(TCHAR));
	}
#else
	#define START_TIMER()
	#define END_TIMER(X, Y)
	inline void WRITE(const CString & strMessage) {};
	inline void WRITE(const CString & strMessage, const CString & strArg) {};
#endif

// TIMEOUT is used when enumerating classes.

#define TIMEOUT -1

//-----------------------------------------------------------------------------
// This function is used to change the impersonation of certain WBEM interface
// pointers.
//-----------------------------------------------------------------------------

inline HRESULT ChangeWBEMSecurity(IUnknown * pUnknown)
{
	IClientSecurity * pCliSec = NULL;

	HRESULT hr = pUnknown->QueryInterface(IID_IClientSecurity, (void **) &pCliSec);
	if (FAILED(hr))
		return hr;

	hr = pCliSec->SetBlanket(pUnknown, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL, RPC_C_AUTHN_LEVEL_CONNECT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE);
	pCliSec->Release();
	return hr;
}

//-----------------------------------------------------------------------------
// The constructor just initializes some member variables.
//-----------------------------------------------------------------------------

CDataProvider::CDataProvider()
{
	m_fInitialized		= FALSE;
	m_pIWbemServices	= NULL;
	m_pGatherer			= NULL;
	m_dwRefreshingCategoryID = 0;
}

//-----------------------------------------------------------------------------
// The destructor releases the IWbemServices pointer, if we have one, and
// empties the interface pointer caches.
//-----------------------------------------------------------------------------

CDataProvider::~CDataProvider()
{
	if (m_fInitialized)
		ClearCache();

	if (m_pIWbemServices)
	{
		m_pIWbemServices->Release();
		m_pIWbemServices = NULL;
	}

	// Remove all of the WBEM service pointers for different namespaces

	IWbemServices * pServices;
	CString			strNamespace;
	for (POSITION pos = m_mapNamespaceToService.GetStartPosition(); pos != NULL;)
	{
		m_mapNamespaceToService.GetNextAssoc(pos, strNamespace, (void * &) pServices);
		if (pServices)
			pServices->Release();
	}
	m_mapNamespaceToService.RemoveAll();

	m_fInitialized = FALSE;

#ifdef GATH_STANDALONE
	CoUninitialize();
#endif
}

//-----------------------------------------------------------------------------
// The create method actually attempts to get a WBEM interface pointer for the
// specified machine. If no machine is specified, the local computer is used.
//-----------------------------------------------------------------------------

BOOL CDataProvider::Create(const CString & strComputer, CDataGatherer * pGatherer)
{
	IWbemLocator *  pIWbemLocator = NULL;
	CString         strNamespace;

	AFX_MANAGE_STATE(::AfxGetStaticModuleState());

	// The create method should never be called twice.

	ASSERT(!m_fInitialized);
	if (m_fInitialized)
		return FALSE;
	
	m_strComputer = strComputer;
	m_pGatherer = pGatherer;

	// The namespace string either uses the computer name, or a '.' for the local computer.

	if (strComputer.IsEmpty())
		strNamespace = CString(_T("\\\\.\\root\\cimv2"));
	else
	{
		strNamespace = strComputer + CString(_T("\\root\\cimv2"));
		if (strNamespace.Left(2).Compare(CString(_T("\\\\"))) != 0)
			strNamespace = CString(_T("\\\\")) + strNamespace;
	}

#ifdef GATH_STANDALONE
	CoInitialize(NULL);
#endif

	// Initialize security.

	CoInitializeSecurity(NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_CONNECT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE, 0);

	// TBD: make sure WBEM is started.

	// We get a WBEM interface pointer by first creating a WBEM locator interface, then
	// using it to connect to a server to get an IWbemServices pointer.

	ASSERT(m_pIWbemServices == NULL);
	if (CoCreateInstance(CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER, IID_IWbemLocator, (LPVOID *) &pIWbemLocator) == S_OK)
	{
		BSTR	pNamespace = strNamespace.AllocSysString();

		if (msiLog.IsLogging(CMSInfoLog::WMI))
			msiLog.WriteLog(CMSInfoLog::WMI, _T("WMI Connect \"%s\" - "), strNamespace);

		HRESULT	hrServer = pIWbemLocator->ConnectServer(pNamespace, NULL, NULL, 0L, 0L, NULL, NULL, &m_pIWbemServices);

		if (msiLog.IsLogging(CMSInfoLog::WMI))
			msiLog.WriteLog(CMSInfoLog::WMI, _T("OK\r\n"), TRUE);

		if (hrServer != S_OK)
		{
			m_pIWbemServices = NULL;
			switch (hrServer)
			{
			case WBEM_E_OUT_OF_MEMORY:
				pGatherer->SetLastError(GATH_ERR_NOWBEMOUTOFMEM);
				break;

			case WBEM_E_ACCESS_DENIED:
				pGatherer->SetLastError(GATH_ERR_NOWBEMACCESSDENIED);
				break;

			case WBEM_E_INVALID_NAMESPACE:
				pGatherer->SetLastError(GATH_ERR_NOWBEMBADSERVER);
				break;

			case WBEM_E_TRANSPORT_FAILURE:
				pGatherer->SetLastError(GATH_ERR_NOWBEMNETWORKFAILURE);
				break;

			case WBEM_E_FAILED:
			case WBEM_E_INVALID_PARAMETER:
			default:
				pGatherer->SetLastError(GATH_ERR_NOWBEMCONNECT);
			}
		}
		else if (m_pIWbemServices)
			ChangeWBEMSecurity(m_pIWbemServices);

		if (pNamespace)
			SysFreeString(pNamespace);

		if (pIWbemLocator)
		{
			pIWbemLocator->Release();
			pIWbemLocator = NULL;
		}
	}
	else
		pGatherer->SetLastError(GATH_ERR_NOWBEMLOCATOR);

	// Load in the strings for TRUE and FALSE. (When we query for a boolean value,
	// we want to return a string representing the results).

	m_strTrue.LoadString(IDS_TRUE);
	ASSERT(!m_strTrue.IsEmpty());
	if (m_strTrue.IsEmpty())
		m_strTrue = CString("1");

	m_strFalse.LoadString(IDS_FALSE);
	ASSERT(!m_strFalse.IsEmpty());
	if (m_strFalse.IsEmpty())
		m_strFalse = CString("0");

	m_strBadProperty.LoadString(IDS_BAD_PROPERTY);
	ASSERT(!m_strBadProperty.IsEmpty());

	m_strPropertyUnavail.LoadString(IDS_PROPERTY_UNAVAILABLE);
	ASSERT(!m_strPropertyUnavail.IsEmpty());

	m_strAccessDeniedLabel.LoadString(IDS_WBEM_ACCESS_DENIED);
	ASSERT(!m_strAccessDeniedLabel.IsEmpty());

	m_strTransportFailureLabel.LoadString(IDS_WBEM_TRANSPORT_FAILURE);
	ASSERT(!m_strTransportFailureLabel.IsEmpty());

	m_dwRefreshingCategoryID = 0;

	m_fInitialized = (m_pIWbemServices != NULL);
	return (m_fInitialized);
}

//-----------------------------------------------------------------------------
// This function is used to retrieve a pointer to IWbemServices for a
// particular namespace. The default namespace is cimv2.
//-----------------------------------------------------------------------------

IWbemServices * CDataProvider::GetWBEMService(CString * pstrNamespace)
{
	if (pstrNamespace == NULL || pstrNamespace->IsEmpty())
		return m_pIWbemServices;

	// Something like the following is useful for forcing a provider error when
	// testing the error containment:
	//
	// if (*pstrNamespace == _T("MSAPPS")) *pstrNamespace += _T("X");

	IWbemServices * pServices;
	if (m_mapNamespaceToService.Lookup(*pstrNamespace, (void * &) pServices) && pServices)
		return pServices;

	// There is no WBEM services pointer for that namespace, we need to create one.

	CString strNamespace(_T(""));
	if (m_strComputer.IsEmpty())
		strNamespace = CString(_T("\\\\.\\root\\")) + *pstrNamespace;
	else
	{
		if (m_strComputer.Right(1) == CString(_T("\\")))
			strNamespace = m_strComputer + CString(_T("root\\")) + *pstrNamespace;
		else
			strNamespace = m_strComputer + CString(_T("\\root\\")) + *pstrNamespace;
		if (strNamespace.Left(2).Compare(CString(_T("\\\\"))) != 0)
			strNamespace = CString(_T("\\\\")) + strNamespace;
	}

	IWbemLocator * pIWbemLocator = NULL;
	if (CoCreateInstance(CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER, IID_IWbemLocator, (LPVOID *) &pIWbemLocator) == S_OK)
	{
		BSTR	pNamespace = strNamespace.AllocSysString();

		if (msiLog.IsLogging(CMSInfoLog::WMI))
			msiLog.WriteLog(CMSInfoLog::WMI, _T("WMI Connect \"%s\" - "), strNamespace);

		HRESULT	hrServer = pIWbemLocator->ConnectServer(pNamespace, NULL, NULL, 0L, 0L, NULL, NULL, &pServices);

		if (msiLog.IsLogging(CMSInfoLog::WMI))
			msiLog.WriteLog(CMSInfoLog::WMI, _T("OK\r\n"), TRUE);

		if (pNamespace)
			SysFreeString(pNamespace);

		if (pIWbemLocator)
		{
			pIWbemLocator->Release();
			pIWbemLocator = NULL;
		}

		if (SUCCEEDED(hrServer) && pServices)
		{
			ChangeWBEMSecurity(pServices);
			m_mapNamespaceToService.SetAt(*pstrNamespace, (void *) pServices);
			return pServices;
		}
	}

	return NULL;
}

//-----------------------------------------------------------------------------
// This method is used to get the current value for a given class and property
// string. Starting with the IWbemServices interface, it gets an interface
// for the requested class enums the first instance. Performance is improved
// by caching the instance interfaces in m_mapClassToInterface.
//-----------------------------------------------------------------------------

BOOL CDataProvider::QueryValue(const CString & strClass, const CString & strProperty, CString & strResult)
{
	strResult.Empty();

	ASSERT(m_fInitialized && m_pIWbemServices);
	if (!m_fInitialized || m_pIWbemServices == NULL)
		return FALSE;

	CMSIObject * pObject = GetObject(strClass, NULL);
	ASSERT(pObject);
	if (!pObject)
		return FALSE;

	switch (pObject->IsValid())
	{
	case MOS_INSTANCE:
		{
			BOOL fUseValueMap = FALSE;
			CString strProp(strProperty);

			if (strProp.Left(8) == CString(_T("ValueMap")))
			{
				strProp = strProp.Right(strProp.GetLength() - 8);
				fUseValueMap = TRUE;
			}

			VARIANT variant;
			BSTR	propName = strProp.AllocSysString();

			VariantInit(&variant);
			VariantClear(&variant);
			if (pObject->Get(propName, 0L, &variant, NULL, NULL) == S_OK)
			{
				// If the property we just got is an array, we should convert it to string
				// containing a list of the items in the array.

				if ((variant.vt & VT_ARRAY) && (variant.vt & VT_BSTR) && variant.parray)
				{
					if (SafeArrayGetDim(variant.parray) == 1)
					{
						long lLower = 0, lUpper = 0;

						SafeArrayGetLBound(variant.parray, 0, &lLower);
						SafeArrayGetUBound(variant.parray, 0, &lUpper);

						CString	strWorking;
						BSTR	bstr = NULL;
						for (long i = lLower; i <= lUpper; i++)
							if (SUCCEEDED(SafeArrayGetElement(variant.parray, &i, (wchar_t*)&bstr)))
							{
								if (i != lLower)
									strWorking += _T(", ");
								strWorking += bstr;
							}
						strResult = strWorking;
						return TRUE;
					}
				}
				else if (VariantChangeType(&variant, &variant, 0, VT_BSTR) == S_OK)
				{
					strResult = V_BSTR(&variant);

					CString strFound;
					if (fUseValueMap && SUCCEEDED(CheckValueMap(strClass, strProp, strResult, strFound)))
						strResult = strFound;

					return TRUE;
				}
				else
					strResult = m_strPropertyUnavail;
			}
			else
				strResult = m_strBadProperty;
		}
		break;

	case MOS_MSG_INSTANCE:
		pObject->GetErrorLabel(strResult);
		break;

	case MOS_NO_INSTANCES:
	default:
		ASSERT(FALSE);
		break;
	}

	return FALSE;
}

//-----------------------------------------------------------------------------
// This method is equivalent to QueryValue, except it returns a DWORD value.
// If FALSE is returned, then the string in strMessage should be displayed.
//-----------------------------------------------------------------------------

BOOL CDataProvider::QueryValueDWORD(const CString & strClass, const CString & strProperty, DWORD & dwResult, CString & strMessage)
{
	dwResult = 0L;
	strMessage.Empty();

	ASSERT(m_fInitialized && m_pIWbemServices);
	if (!m_fInitialized || m_pIWbemServices == NULL)
		return FALSE;

	CMSIObject * pObject = GetObject(strClass, NULL);
	ASSERT(pObject);
	if (!pObject)
		return FALSE;

	switch (pObject->IsValid())
	{
	case MOS_INSTANCE:
		{
			VARIANT variant;
			BSTR	propName = strProperty.AllocSysString();

			VariantInit(&variant);
			VariantClear(&variant);
			if (pObject->Get(propName, 0L, &variant, NULL, NULL) == S_OK)
			{
				if (VariantChangeType(&variant, &variant, 0, VT_I4) == S_OK)
				{
					dwResult = V_I4(&variant);
					return TRUE;
				}
				else
					strMessage = m_strPropertyUnavail;
			}
			else
				strMessage = m_strBadProperty;
		}
		break;

	case MOS_MSG_INSTANCE:
		pObject->GetErrorLabel(strMessage);
		break;

	case MOS_NO_INSTANCES:
	default:
		ASSERT(FALSE);
		break;
	}

	return FALSE;
}

//-----------------------------------------------------------------------------
// This method is equivalent to QueryValue, except it returns a double float
// value. If FALSE is returned, then the string in strMessage should
// be displayed.
//-----------------------------------------------------------------------------

BOOL CDataProvider::QueryValueDoubleFloat(const CString & strClass, const CString & strProperty, double & dblResult, CString & strMessage)
{
	dblResult = 0L;
	strMessage.Empty();

	ASSERT(m_fInitialized && m_pIWbemServices);
	if (!m_fInitialized || m_pIWbemServices == NULL)
		return FALSE;

	CMSIObject * pObject = GetObject(strClass, NULL);
	ASSERT(pObject);
	if (!pObject)
		return FALSE;

	switch (pObject->IsValid())
	{
	case MOS_INSTANCE:
		{
			VARIANT variant;
			BSTR	propName = strProperty.AllocSysString();

			VariantInit(&variant);
			VariantClear(&variant);
			if (pObject->Get(propName, 0L, &variant, NULL, NULL) == S_OK)
			{
				if (VariantChangeType(&variant, &variant, 0, VT_R8) == S_OK)
				{
					dblResult = V_R8(&variant);
					return TRUE;
				}
				else
					strMessage = m_strPropertyUnavail;
			}
			else
				strMessage = m_strBadProperty;
		}
		break;

	case MOS_MSG_INSTANCE:
		pObject->GetErrorLabel(strMessage);
		break;

	case MOS_NO_INSTANCES:
	default:
		ASSERT(FALSE);
		break;
	}

	return FALSE;
}

//-----------------------------------------------------------------------------
// This method is equivalent to QueryValue, except it returns an OLE date
// & time object. If FALSE is returned, then the string in strMessage should
// be displayed.
//-----------------------------------------------------------------------------

BOOL CDataProvider::QueryValueDateTime(const CString & strClass, const CString & strProperty, COleDateTime & datetime, CString & strMessage)
{
	datetime.SetDateTime(0, 1, 1, 0, 0, 0);
	strMessage.Empty();

	ASSERT(m_fInitialized && m_pIWbemServices);
	if (!m_fInitialized || m_pIWbemServices == NULL)
		return FALSE;

	CMSIObject * pObject = GetObject(strClass, NULL);
	ASSERT(pObject);
	if (!pObject)
		return FALSE;

	switch (pObject->IsValid())
	{
	case MOS_INSTANCE:
		{
			VARIANT variant;
			BSTR	propName = strProperty.AllocSysString();

			VariantInit(&variant);
			VariantClear(&variant);
			if (pObject->Get(propName, 0L, &variant, NULL, NULL) == S_OK)
			{
				if (VariantChangeType(&variant, &variant, 0, VT_BSTR) == S_OK)
				{
					// Parse the date and time into an COleDateTime object. Note: we should
					// be able to get an OLE date from WBEM, but for now we need to just
					// deal with the string returned.

					int     nYear, nMonth, nDay, nHour, nMin, nSec;
					CString strTemp = V_BSTR(&variant);

					nYear   = atoi(strTemp.Mid(0,  4));
					nMonth  = atoi(strTemp.Mid(4,  2));
					nDay    = atoi(strTemp.Mid(6,  2));
					nHour   = atoi(strTemp.Mid(8,  2));
					nMin    = atoi(strTemp.Mid(10, 2));
					nSec    = atoi(strTemp.Mid(12, 2));

					datetime.SetDateTime(nYear, nMonth, nDay, nHour, nMin, nSec);
					return TRUE;
				}
				else
					strMessage = m_strPropertyUnavail;
			}
			else
				strMessage = m_strBadProperty;
		}
		break;

	case MOS_MSG_INSTANCE:
		pObject->GetErrorLabel(strMessage);
		break;

	case MOS_NO_INSTANCES:
	default:
		ASSERT(FALSE);
		break;
	}

	return FALSE;
}

//-----------------------------------------------------------------------------
// Reset the CMSIEnumerator pointer to the start of the enumeration (and
// make sure there is one). Remove the object pointer, so the first call
// to GetObject will return the first item in the enumerator.
//-----------------------------------------------------------------------------

BOOL CDataProvider::ResetClass(const CString & strClass, const GATH_FIELD * pConstraints)
{
	CMSIEnumerator * pMSIEnumerator = GetEnumObject(strClass, pConstraints);
	if (pMSIEnumerator == NULL)
		return FALSE;

	// Reset the enumerator, and remove the cached object pointer if there is one.

	pMSIEnumerator->Reset(pConstraints);
	RemoveObject(strClass);

	CMSIObject * pObject = GetObject(strClass, pConstraints);
	if (pObject == NULL || pObject->IsValid() == CDataProvider::MOS_NO_INSTANCES)
		return FALSE;
		
	return TRUE;
}

//-----------------------------------------------------------------------------
// Move the cached IWbemClassObject pointer to the next instance.
//-----------------------------------------------------------------------------

BOOL CDataProvider::EnumClass(const CString & strClass, const GATH_FIELD * pConstraints)
{
	ASSERT(m_pIWbemServices);
	ASSERT(m_fInitialized);
	if (!m_fInitialized)
		return FALSE;

	// Verify that there is an object enumerator in place.

	if (GetEnumObject(strClass, pConstraints) == NULL)
		return FALSE;

	// If there is an object interface, remove it, then make a new one.
	// Then retrieve the object pointer (this will do the Next on the
	// enumerator to get the next instance).

	RemoveObject(strClass);
	CMSIObject * pObject = GetObject(strClass, pConstraints);
	if (pObject && (pObject->IsValid() == CDataProvider::MOS_INSTANCE))
		return TRUE;

	return FALSE;

//	if ((pObject == NULL) || (pObject->IsValid() == CDataProvider::MOS_NO_INSTANCES))
//		return FALSE;
}

//-----------------------------------------------------------------------------
// Retrieve the interface pointer for the specified IEnumWbemClassObject.
// If there isn't one cached, create one and cache it. It's possible for the
// pConstraints parameter to contain a field specify a WBEM SQL condition for
// this enumerator.
//-----------------------------------------------------------------------------

CMSIEnumerator * CDataProvider::GetEnumObject(const CString & strClass, const GATH_FIELD * pConstraints)
{
	ASSERT(m_pIWbemServices);
	if (m_pIWbemServices == NULL)
		return NULL;

	// See if we've cached this enumerator object.

	CMSIEnumerator * pReturn = NULL;
	if (m_mapClassToEnumInterface.Lookup(strClass, (void * &) pReturn))
		return pReturn;

	// We'll need to create this enumerator here, and save it in the cache.

	pReturn = new CMSIEnumerator;
	if (pReturn == NULL)	
		return NULL;

	if (FAILED(pReturn->Create(strClass, pConstraints, this)))
	{
		delete pReturn;
		return NULL;
	}

	m_mapClassToEnumInterface.SetAt(strClass, (void *) pReturn);
	return pReturn;
}

//-----------------------------------------------------------------------------
// This function scans through the list of constraints to see if any of them
// are SQL filters for an enumerator. If one is, the string which serves
// as a SQL statement is returned, after being processed to replace any
// keywords (such as class.property values).
//-----------------------------------------------------------------------------
#if FALSE
CString CDataProvider::GetSQLStatement(const GATH_FIELD * pConstraints, BOOL & fMinOfOne)
{
	CString				strMinOfOne(_T("min-of-one"));
	CString				strSQLKeyword(SQL_FILTER);
	const GATH_FIELD *	pSQLConstraint = pConstraints;

	fMinOfOne = FALSE;

	// Look through the constaints to see if one starts with the SQL keyword.

	while (pSQLConstraint)
	{
		if (pSQLConstraint->m_strSource.CompareNoCase(CString(STATIC_SOURCE)) == 0)
			if (pSQLConstraint->m_strFormat.Left(strSQLKeyword.GetLength()).CompareNoCase(strSQLKeyword) == 0)
				break;
		pSQLConstraint = pSQLConstraint->m_pNext;
	}

	if (pSQLConstraint == NULL)
		return CString(_T(""));

	// Strip off the SQL keyword.

	CString strWorking(pSQLConstraint->m_strFormat);
	strWorking = strWorking.Right(strWorking.GetLength() - strSQLKeyword.GetLength());

	// Now, replace any keywords of the form "[class.property]" with the actual
	// value of the property.

	CString strResults;
	while (!strWorking.IsEmpty())
	{
		if (strWorking[0] != _T('['))
		{
			int index = strWorking.Find(_T('['));
			if (index < 0)
				index = strWorking.GetLength();
			strResults += strWorking.Left(index);
			strWorking = strWorking.Right(strWorking.GetLength() - index);
		}
		else
		{
			CString strKeyword;

			strWorking = strWorking.Right(strWorking.GetLength() - 1);
			int index = strWorking.Find(_T(']'));
			if (index < 0)
			{
				ASSERT(FALSE);
				return CString(_T(""));
			}

			strKeyword = strWorking.Left(index);
			if (strKeyword.CompareNoCase(strMinOfOne) == 0)
				fMinOfOne = TRUE;
			else if (!strKeyword.IsEmpty())
			{
				int iDotIndex = strKeyword.Find(_T('.'));
				if (iDotIndex >= 0)
				{
					CString strValue;
					if (QueryValue(strKeyword.Left(iDotIndex), strKeyword.Right(strKeyword.GetLength() - iDotIndex - 1), strValue))
						strResults += strValue;
				}
			}
			strWorking = strWorking.Right(strWorking.GetLength() - (index + 1));
		}
	}

	return strResults;
}

//-----------------------------------------------------------------------------
// This function indicates if the only constraint specified is a SQL statement.
//-----------------------------------------------------------------------------

BOOL CDataProvider::IsSQLConstraint(const GATH_FIELD * pConstraints)
{
	CString strSQLKeyword(SQL_FILTER);

	if (pConstraints)
		if (pConstraints->m_strSource.CompareNoCase(CString(STATIC_SOURCE)) == 0)
			if (pConstraints->m_strFormat.Left(strSQLKeyword.GetLength()).CompareNoCase(strSQLKeyword) == 0)
				return TRUE;
	
	return FALSE;
}
#endif

//-----------------------------------------------------------------------------
// Retrieve the interface pointer for the specified IWbemClassObject.
// If there isn't one cached, create one and cache it.
//-----------------------------------------------------------------------------

CMSIObject * CDataProvider::GetObject(const CString & strClass, const GATH_FIELD * pConstraints, CString * pstrLabel)
{
	ASSERT(m_pIWbemServices);
	if (m_pIWbemServices == NULL)
		return NULL;

	CMSIObject * pReturn = NULL;
	if (m_mapClassToInterface.Lookup(strClass, (void * &) pReturn))
		return pReturn;

	// We don't have one of these objects cached. Get one from the enumerator.

	CMSIEnumerator * pEnumerator = GetEnumObject(strClass);
	if (pEnumerator)
	{
		HRESULT hr = pEnumerator->Next(&pReturn);
		if (S_OK != hr)
		{
			if (pReturn)
				delete pReturn;
			pReturn = NULL;
			if (m_pGatherer)
			{
				if (m_dwRefreshingCategoryID)
					m_pGatherer->SetLastErrorHR(hr, m_dwRefreshingCategoryID);
				else
					m_pGatherer->SetLastErrorHR(hr);
			}
		}
	}

	if (pReturn)
		m_mapClassToInterface.SetAt(strClass, (void *) pReturn);

	return pReturn;
}

//-----------------------------------------------------------------------------
// Evaluate whether or not a specific object meets the filtering requirements
// set by the constraints (filtering are the constraints where one half is
// a static value).
//-----------------------------------------------------------------------------

BOOL CDataProvider::EvaluateFilter(IWbemClassObject * pObject, const GATH_FIELD * pConstraints)
{
	const GATH_FIELD	*	pLHS = pConstraints, * pRHS = NULL;
	VARIANT					variant;
	CString					strValue;
	BSTR					propName;

	ASSERT(m_pIWbemServices && pObject);
	if (m_pIWbemServices == NULL || pObject == NULL)
		return FALSE;

	while (pLHS && pLHS->m_pNext)
	{
		pRHS = pLHS->m_pNext;
		VariantInit(&variant);

		// If either the left or right hand side is static, we need to do the check.
		// First check out if the left side is static.

		if (pLHS->m_strSource.CompareNoCase(CString(STATIC_SOURCE)) == 0 && pRHS->m_pArgs)
		{
			propName = pRHS->m_pArgs->m_strText.AllocSysString();
			strValue.Empty();

			VariantClear(&variant);
			if (pObject->Get(propName, 0L, &variant, NULL, NULL) == S_OK)
				if (VariantChangeType(&variant, &variant, 0, VT_BSTR) == S_OK)
				{
					strValue = V_BSTR(&variant);
					if (strValue.CompareNoCase(pLHS->m_strFormat) != 0)
						return FALSE;
				}
		}

		// Next check out if the right side is static.

		if (pRHS->m_strSource.CompareNoCase(CString(STATIC_SOURCE)) == 0 && pLHS->m_pArgs)
		{
			propName = pLHS->m_pArgs->m_strText.AllocSysString();
			strValue.Empty();

			VariantClear(&variant);
			if (pObject->Get(propName, 0L, &variant, NULL, NULL) == S_OK)
				if (VariantChangeType(&variant, &variant, 0, VT_BSTR) == S_OK)
				{
					strValue = V_BSTR(&variant);
					if (strValue.CompareNoCase(pRHS->m_strFormat) != 0)
						return FALSE;
				}
		}

		// Advance our pointer to the left hand side by two.

		pLHS = pRHS->m_pNext;
	}

	return TRUE;
}

//-----------------------------------------------------------------------------
// This method uses an object interface and the constraint fields to advance
// any joined classes to the correct instances.
//-----------------------------------------------------------------------------

void CDataProvider::EvaluateJoin(const CString & strClass, IWbemClassObject * pObject, const GATH_FIELD * pConstraints)
{
	const GATH_FIELD		*pLHS = pConstraints, *pRHS = NULL;
	const GATH_FIELD		*pEnumerated, *pJoinedTo;
	GATH_FIELD				fieldEnumerated, fieldJoinedTo;
	VARIANT					variant;
	CString					strValue;
	BSTR					propName;

	ASSERT(m_pIWbemServices && pObject);
	if (m_pIWbemServices == NULL || pObject == NULL)
		return;

	while (pLHS && pLHS->m_pNext)
	{
		pRHS = pLHS->m_pNext;

		// If either side is static, this is a filter, rather than a join.

		if ((pRHS->m_strSource.CompareNoCase(CString(STATIC_SOURCE)) == 0) ||
			 (pLHS->m_strSource.CompareNoCase(CString(STATIC_SOURCE)) == 0))
		{
			pLHS = pRHS->m_pNext;
			continue;
		}

		// Find out which side refers to the class we're enumerating.

		if (pRHS->m_strSource.CompareNoCase(strClass) == 0)
		{
			pEnumerated = pRHS;
			pJoinedTo = pLHS;
		}
		else if (pLHS->m_strSource.CompareNoCase(strClass) == 0)
		{
			pEnumerated = pLHS;
			pJoinedTo = pRHS;
		}
		else
		{
			pLHS = pRHS->m_pNext;
			continue;
		}

		// Next, enumerate through the instances of the joined to class until
		// we find one which satisfies the constraint. We can use the EvaluateFilter
		// method to find out when the constraint is met. Set up a field pointer
		// for the constraint (get the value from the enumerated class and use it
		// as a static.

		fieldJoinedTo = *pJoinedTo;
		fieldJoinedTo.m_pNext = NULL;

		VariantInit(&variant);
		strValue.Empty();
		if (pEnumerated->m_pArgs)
		{
			propName = pEnumerated->m_pArgs->m_strText.AllocSysString();
			VariantClear(&variant);
			if (pObject->Get(propName, 0L, &variant, NULL, NULL) == S_OK)
				if (VariantChangeType(&variant, &variant, 0, VT_BSTR) == S_OK)
				{
					strValue = V_BSTR(&variant);
				}
		}

		fieldEnumerated.m_strSource = CString(STATIC_SOURCE);
		fieldEnumerated.m_pNext = &fieldJoinedTo;
		fieldEnumerated.m_strFormat = strValue;

		// Now, enumerate the joined to class until it meets the constraints.

		RemoveObject(pJoinedTo->m_strSource);
		ResetClass(pJoinedTo->m_strSource, &fieldEnumerated);
		GetObject(pJoinedTo->m_strSource, &fieldEnumerated);

		// Advance our pointer to the left hand side by two.

		pLHS = pRHS->m_pNext;
	}

	// Because the GATH_FIELD destructor follows next pointers, we want
	// to unlink our two GATH_FIELD locals. Also, we don't want the
	// destructor for fieldJoinedTo to delete the arguments.

	fieldEnumerated.m_pNext = NULL;
	fieldJoinedTo.m_pArgs = NULL;
}

//-----------------------------------------------------------------------------
// Evaluate whether or not the constraints indicate that a class is being
// enumerated as a dependency class. This is currently indicated by a single
// field structure with a static value of "dependency".
//-----------------------------------------------------------------------------

BOOL CDataProvider::IsDependencyJoin(const GATH_FIELD * pConstraints)
{
	if (pConstraints != NULL && pConstraints->m_pNext == NULL)
		if (pConstraints->m_strSource.CompareNoCase(CString(STATIC_SOURCE)) == 0)
			if (pConstraints->m_strFormat.CompareNoCase(CString(DEPENDENCY_JOIN)) == 0)
				return TRUE;

	return FALSE;
}

//-----------------------------------------------------------------------------
// This method is used when a dependency class is being enumerated. In a
// dependency class, each property of a class instance contains a reference
// to an instance in another class. This method will cache eache of the
// instances specified by the dependency class so properties of those instances
// can be referred to in the line structures.
//-----------------------------------------------------------------------------

void CDataProvider::EvaluateDependencyJoin(IWbemClassObject * pObject)
{
	VARIANT				variant, varClassName;
	IWbemClassObject *	pNewObject = NULL;

	ASSERT(m_pIWbemServices);
	if (m_pIWbemServices == NULL)
		return;

	//if (pObject->BeginEnumeration(WBEM_FLAG_REFS_ONLY | WBEM_FLAG_LOCAL_ONLY) == S_OK)
	//while (pObject->Next(0, NULL, &variant, NULL, NULL) == S_OK)

	VariantInit(&variant);
	VariantClear(&variant);
	if (pObject->BeginEnumeration(WBEM_FLAG_REFS_ONLY | WBEM_FLAG_NONSYSTEM_ONLY) == WBEM_S_NO_ERROR)
		while (pObject->Next(0, NULL, &variant, NULL, NULL) == WBEM_S_NO_ERROR)
		{
			if (VariantChangeType(&variant, &variant, 0, VT_BSTR) == S_OK)
			{
				// Use the object path to create a pointer to the specified
				// object and store it in the cache.

				CString strObjectPath = V_BSTR(&variant);
				BSTR	bstrObjectPath = strObjectPath.AllocSysString();

				HRESULT hRes = m_pIWbemServices->GetObject(bstrObjectPath, 0, NULL, &pNewObject, NULL);

				if (SUCCEEDED(hRes))
				{
					// We need to get the class name of the new object so we know
					// where to cache it. We could parse it out of the object path,
					// but it will be better in the long run to get it by querying
					// the new object.

					if (pNewObject)
					{
						CString	strClassName, strClassNameProp(_T("__CLASS"));
						BSTR	classNameProp = strClassNameProp.AllocSysString();

						VariantInit(&varClassName);
						VariantClear(&varClassName);
						if (pNewObject->Get(classNameProp, 0L, &varClassName, NULL, NULL) == S_OK)
							if (VariantChangeType(&varClassName, &varClassName, 0, VT_BSTR) == S_OK)
								strClassName = V_BSTR(&varClassName);

						if (!strClassName.IsEmpty())
						{
							CMSIObject * pNewMSIObject = new CMSIObject(pNewObject, CString(_T("")), S_OK, this, CDataProvider::MOS_INSTANCE);
							if (pNewMSIObject)
							{
								CMSIObject * pOldObject = NULL;
								
								if (m_mapClassToInterface.Lookup(strClassName, (void * &) pOldObject) && pOldObject)
									delete pOldObject;
								m_mapClassToInterface.SetAt(strClassName, (void *) pNewMSIObject);
							}
						}
						else
						{
							delete pNewObject;
							pNewObject = NULL;
						}
					}
				}
			}
			VariantClear(&variant);
		}
}

//-----------------------------------------------------------------------------
// Remove the specified IEnumWbemClassObject pointer from the cache.
//-----------------------------------------------------------------------------

void CDataProvider::RemoveEnumObject(const CString & strClass)
{
	CMSIEnumerator * pEnumObject = NULL;

	if (m_mapClassToEnumInterface.Lookup(strClass, (void * &) pEnumObject) && pEnumObject)
		delete pEnumObject;

	m_mapClassToEnumInterface.RemoveKey(strClass);
}

//-----------------------------------------------------------------------------
// Remove the specified IWbemClassObject pointer from the cache.
//-----------------------------------------------------------------------------

void CDataProvider::RemoveObject(const CString & strClass)
{
	CMSIObject * pObject = NULL;

	if (m_mapClassToInterface.Lookup(strClass, (void * &) pObject) && pObject)
		delete pObject;

	m_mapClassToInterface.RemoveKey(strClass);
}

//-----------------------------------------------------------------------------
// Clear out the contents of the caches (forcing the interfaces to be
// retrieved again).
//-----------------------------------------------------------------------------

void CDataProvider::ClearCache()
{
	CMSIObject *			pObject = NULL;
	CMSIEnumerator *		pEnumObject = NULL;
	POSITION                pos;
	CString                 strClass;

	ASSERT(m_fInitialized);
	if (!m_fInitialized)
		return;

	for (pos = m_mapClassToInterface.GetStartPosition(); pos != NULL;)
	{
		m_mapClassToInterface.GetNextAssoc(pos, strClass, (void * &) pObject);
		if (pObject)
			delete pObject;
	}
	m_mapClassToInterface.RemoveAll();

	for (pos = m_mapClassToEnumInterface.GetStartPosition(); pos != NULL;)
	{
		m_mapClassToEnumInterface.GetNextAssoc(pos, strClass, (void * &) pEnumObject);
		if (pEnumObject)
			delete pEnumObject;
	}
	m_mapClassToEnumInterface.RemoveAll();
}

//-----------------------------------------------------------------------------
// Implement the CMSIObject class. This is just a thin wrapper for the
// IWbemClassObject interface.
//-----------------------------------------------------------------------------

CMSIObject::CMSIObject(IWbemClassObject * pObject, const CString & strLabel, HRESULT hres, CDataProvider * pProvider, CDataProvider::MSIObjectState objState)
{
	m_pObject		= pObject;
	m_strLabel		= strLabel;
	m_hresCreation	= hres;
	m_pProvider		= pProvider;
	m_objState		= objState;
}

CMSIObject::~CMSIObject()
{
	if (m_pObject)
	{
		m_pObject->Release();
		m_pObject = NULL;
	}
}

HRESULT CMSIObject::Get(BSTR property, LONG lFlags, VARIANT *pVal, VARTYPE *pvtType, LONG *plFlavor)
{
	ASSERT(m_objState != CDataProvider::MOS_NO_INSTANCES);

	// If there is an object interface, just pass the request on through.

	if (m_pObject)
		return m_pObject->Get(property, lFlags, pVal, pvtType, plFlavor);

	// Otherwise, we need to return the appropriate string.
	
	CString strReturn;
	GetErrorLabel(strReturn);

	V_BSTR(pVal) = strReturn.AllocSysString();
	pVal->vt = VT_BSTR;
	return S_OK;
}

CDataProvider::MSIObjectState CMSIObject::IsValid()
{
	return m_objState;
}

HRESULT CMSIObject::GetErrorLabel(CString & strError)
{
	switch (m_hresCreation)
	{
	case WBEM_E_ACCESS_DENIED:
		strError = m_pProvider->m_strAccessDeniedLabel;
		break;

	case WBEM_E_TRANSPORT_FAILURE:
		strError = m_pProvider->m_strTransportFailureLabel;
		break;

	case S_OK:
	case WBEM_S_FALSE:
	default:
		// This object was created from an enumeration that was marked as "min-of-one",
		// meaning that at least one object, even if it's not valid, needed to be
		// returned from the enumeration. Return the string we saved at object creation.

		if (!m_strLabel.IsEmpty())
			strError = m_strLabel;
		else
			strError = m_pProvider->m_strBadProperty;
		break;
	}

	return S_OK;
}

//-----------------------------------------------------------------------------
// The CEnumMap is a utility class to cache IEnumWbemClassObject pointers.
// There will be one instance of this class used to improve performance
// by avoiding the high overhead associated with creating enumerators for
// certain classes.
//-----------------------------------------------------------------------------

IEnumWbemClassObject * CEnumMap::GetEnumerator(const CString & strClass)
{
	IEnumWbemClassObject * pEnum = NULL;
	IEnumWbemClassObject * pNewEnum = NULL;

	if (m_mapEnum.Lookup(strClass, (void * &) pEnum))
	{
		if (pEnum && SUCCEEDED(pEnum->Clone(&pNewEnum)) && pNewEnum)
		{
			START_TIMER();
			pNewEnum->Reset();
			END_TIMER(_T("clone HIT [%s]\r\n"), strClass);
		}
		else
			pNewEnum = NULL;
	}
	else
	{
		WRITE(_T("GetEnumerator MISS for %s.\r\n"), strClass);
	}

	return pNewEnum;
}

void CEnumMap::SetEnumerator(const CString & strClass, IEnumWbemClassObject * pEnum)
{
	if (pEnum)
	{
		IEnumWbemClassObject * pEnumExisting = NULL;
		if (m_mapEnum.Lookup(strClass, (void * &) pEnumExisting))
		{
			WRITE(_T("SetEnumerator for %s, already exists, ignoring.\r\n"), strClass);
		}
		else
		{
			pEnum->AddRef();
			m_mapEnum.SetAt(strClass, pEnum);
			WRITE(_T("SetEnumerator for %s.\r\n"), strClass);
		}
	}
	else
	{
		WRITE(_T("SetEnumerator with NULL pointer for %s, ignoring.\r\n"), strClass);
	}
}

void CEnumMap::Reset()
{
	IEnumWbemClassObject *	pEnum = NULL;
	CString					key;

	WRITE(_T("CEnumMap::Reset()\r\n"));

	for (POSITION pos = m_mapEnum.GetStartPosition(); pos != NULL;)
	{
	   m_mapEnum.GetNextAssoc(pos, key, (void * &) pEnum);
	   if (pEnum)
		   pEnum->Release();
	}

	m_mapEnum.RemoveAll();
}

//-----------------------------------------------------------------------------
// The CMSIEnumerator class encapsulates the WBEM enumerator interface, or
// implements our own form of enumerator (such as for the LNK command in the
// template file).
//
// Nothing particularly interesting about the constructor or destructor.
//-----------------------------------------------------------------------------

CMSIEnumerator::CMSIEnumerator()
{
	m_enumtype			= CMSIEnumerator::CLASS;
	m_fOnlyDups			= FALSE;
	m_fGotDuplicate		= FALSE;
	m_fMinOfOne			= FALSE;
	m_iMinOfOneCount	= 0;
	m_pEnum				= NULL;
	m_pProvider			= NULL;
	m_pConstraints		= NULL;
	m_pSavedDup			= NULL;
	m_pstrList			= NULL;
	m_hresCreation		= S_OK;
}

CMSIEnumerator::~CMSIEnumerator()
{
	if (m_pEnum)
	{
		switch (m_enumtype)
		{
		case CMSIEnumerator::WQL:
			break;

		case CMSIEnumerator::LNK:
			m_pProvider->m_enumMap.SetEnumerator(m_strAssocClass, m_pEnum);
			break;

		case CMSIEnumerator::INTERNAL:
			if (m_pstrList)
			{
				delete m_pstrList;
				m_pstrList = NULL;
			}
			break;
			
		case CMSIEnumerator::CLASS:
		default:
			m_pProvider->m_enumMap.SetEnumerator(m_strClass, m_pEnum);
			break;
		}
		
		m_pEnum->Release();
		m_pEnum = NULL;
	}
}

//-----------------------------------------------------------------------------
// Creating the CMSIEnumerator object involves determining what sort of
// enumerator is required. We support the following types:
//
//		1. Straight enumeration of a class
//		2. Enumerate class, with applied constraints
//		3. Enumerate the results of a WQL statement.
//		4. Interprete a LNK command to enumerate associated classes.
//		5. Do internal processing on an INTERNAL type.
//-----------------------------------------------------------------------------

HRESULT CMSIEnumerator::Create(const CString & strClass, const GATH_FIELD * pConstraints, CDataProvider * pProvider)
{
	if (strClass.IsEmpty() || !pProvider || !pProvider->m_pIWbemServices)
		return E_INVALIDARG;

	// Create may be called multiple times (to reset the enumerator). So we may need to
	// release the enumerator pointer.

	if (m_pEnum)
	{
		m_pEnum->Release();
		m_pEnum = NULL;
	}

	// Divide the specified class into class and namespace parts, get the WBEM service.

	CString strNamespacePart(_T("")), strClassPart(strClass);
	int		i = strClass.Find(_T(":"));
	if (i != -1)
	{
		strNamespacePart = strClass.Left(i);
		strClassPart = strClass.Right(strClass.GetLength() - i - 1);
	}

	IWbemServices * pServices = pProvider->GetWBEMService(&strNamespacePart);
	if (pServices == NULL)
		return NULL;

	// First, we need to determine what type of enumerator this is. Scan through
	// the constraints - if we see one which has a string starting with "WQL:" or
	// "LNK:", then we know what type this enumerator is.

	CString				strStatement;
	const GATH_FIELD *	pScanConstraint = pConstraints;

	while (pScanConstraint)
	{
		if (pScanConstraint->m_strSource.CompareNoCase(CString(STATIC_SOURCE)) == 0)
		{
			if (pScanConstraint->m_strFormat.Left(4).CompareNoCase(CString(_T("WQL:"))) == 0)
				m_enumtype = CMSIEnumerator::WQL;
			else if (pScanConstraint->m_strFormat.Left(4).CompareNoCase(CString(_T("LNK:"))) == 0)
				m_enumtype = CMSIEnumerator::LNK;
			else if (pScanConstraint->m_strFormat.Left(4).CompareNoCase(CString(_T("INT:"))) == 0)
				m_enumtype = CMSIEnumerator::INTERNAL;

			if (m_enumtype != CMSIEnumerator::CLASS)
			{
				strStatement = pScanConstraint->m_strFormat;
				strStatement = strStatement.Right(strStatement.GetLength() - 4);
				break;
			}
		}
		pScanConstraint = pScanConstraint->m_pNext;
	}

	// If this is a WQL or a LNK enumerator, processes the statement by replacing
	// [class.property] with the actual value from WBEM. If we find the string
	// "[min-of-one]", make a note of it for later.

	if (m_enumtype == CMSIEnumerator::WQL)
		ProcessEnumString(strStatement, m_fMinOfOne, m_fOnlyDups, pProvider, m_strNoInstanceLabel, TRUE);
	else if (m_enumtype == CMSIEnumerator::LNK)
		if (SUCCEEDED(ParseLNKCommand(strStatement, m_strObjPath, m_strAssocClass, m_strResultClass)))
		{
			// Save the object path for later - so we can change the object without
			// completely reprocessing the statement. Then replace the keywords in
			// the statement and break out the pieces again.

			m_strLNKObject = m_strObjPath;
			ProcessEnumString(strStatement, m_fMinOfOne, m_fOnlyDups, pProvider, m_strNoInstanceLabel);
			ParseLNKCommand(strStatement, m_strObjPath, m_strAssocClass, m_strResultClass);
		}

	// Now, based on the enumerator type, create the WBEM enumerator object.

	switch (m_enumtype)
	{
	case CMSIEnumerator::WQL:
		{
			BSTR language = SysAllocString(_T("WQL"));
			BSTR query = SysAllocString(strStatement);

			if (msiLog.IsLogging(CMSInfoLog::WMI))
				msiLog.WriteLog(CMSInfoLog::WMI, _T("WMI Create WQL enum \"%s\" - "), strStatement);

			START_TIMER();
			m_hresCreation = pServices->ExecQuery(language, query, WBEM_FLAG_RETURN_IMMEDIATELY, 0, &m_pEnum);
			END_TIMER(_T("create WQL[%s]"), strStatement);

			if (msiLog.IsLogging(CMSInfoLog::WMI))
				msiLog.WriteLog(CMSInfoLog::WMI, _T("OK\r\n"), TRUE);

			SysFreeString(query);
			SysFreeString(language);
		}
		break;

	case CMSIEnumerator::LNK:
		{
			m_hresCreation = ParseLNKCommand(strStatement, m_strObjPath, m_strAssocClass, m_strResultClass);
			if (SUCCEEDED(m_hresCreation))
			{
				BSTR className = m_strAssocClass.AllocSysString();
				START_TIMER();
				m_pEnum = pProvider->m_enumMap.GetEnumerator(m_strAssocClass);
				if (m_pEnum)
					m_hresCreation = S_OK;
				else
				{
					if (msiLog.IsLogging(CMSInfoLog::WMI))
						msiLog.WriteLog(CMSInfoLog::WMI, _T("WMI Create enum \"%s\" - "), m_strAssocClass);

					m_hresCreation = pServices->CreateInstanceEnum(className, WBEM_FLAG_SHALLOW | WBEM_FLAG_RETURN_IMMEDIATELY, NULL, &m_pEnum);

					if (msiLog.IsLogging(CMSInfoLog::WMI))
						msiLog.WriteLog(CMSInfoLog::WMI, _T("OK\r\n"), TRUE);
				}
				END_TIMER(_T("create LNK[%s]"), m_strAssocClass);
				SysFreeString(className);
			}
		}
		break;

	case CMSIEnumerator::INTERNAL:
		// We'll call a function here so we can do whatever processing is required
		// to create this internal enumeration.

		m_hresCreation = CreateInternalEnum(strStatement, pProvider);
		break;

	case CMSIEnumerator::CLASS:
	default:
		{
			BSTR className = SysAllocString(strClassPart);
			START_TIMER();
			m_pEnum = pProvider->m_enumMap.GetEnumerator(strClassPart);
			if (m_pEnum)
				m_hresCreation = S_OK;
			else
			{
				if (msiLog.IsLogging(CMSInfoLog::WMI))
					msiLog.WriteLog(CMSInfoLog::WMI, _T("WMI Create enum \"%s\" - "), strClassPart);

				m_hresCreation = pServices->CreateInstanceEnum(className, WBEM_FLAG_SHALLOW | WBEM_FLAG_RETURN_IMMEDIATELY, NULL, &m_pEnum);

				if (msiLog.IsLogging(CMSInfoLog::WMI))
					msiLog.WriteLog(CMSInfoLog::WMI, _T("OK\r\n"), TRUE);
			}
			END_TIMER(_T("create CLS[%s]"), strClassPart);
			SysFreeString(className);
		}
	}

	// Set some of the other member variables.

	m_strClass			= strClass;
	m_pProvider			= pProvider;
	m_iMinOfOneCount	= (m_fMinOfOne) ? 1 : 0;
	m_pConstraints		= pConstraints;

	if (m_pEnum)
		ChangeWBEMSecurity(m_pEnum);

	// Based on the HRESULT from creating the enumeration, determine what to return.
	// For certain errors, we want to act like the creation succeeded, then supply
	// objects which return the error text.

	if (FAILED(m_hresCreation))
	{
		m_fMinOfOne = TRUE;
		m_iMinOfOneCount = 1;
	}

	return S_OK;
}

//-----------------------------------------------------------------------------
// This function is used to create internal enumeration types (enumerations
// which are beyond the template file syntax). Basically a bunch of special
// cases.
//-----------------------------------------------------------------------------

HRESULT CMSIEnumerator::CreateInternalEnum(const CString & strInternal, CDataProvider * pProvider)
{
	if (strInternal.CompareNoCase(CString(_T("dlls"))) == 0)
	{
		// We want to enumerate all the loaded dlls and exes on the system. 
		// This can be done by enumerating the CIM_ProcessExecutable class
		// and removing duplicate file names. We'll keep the filenames (with
		// path information) in a string list.

		if (m_pstrList == NULL)
		{
			m_pstrList = new CStringList;
			if (m_pstrList == NULL)
				return E_FAIL;
		}
		else
			m_pstrList->RemoveAll();

		HRESULT hr = S_OK;
		IWbemServices * pServices = pProvider->GetWBEMService();
		if (pServices)
		{
			BSTR className = SysAllocString(_T("CIM_ProcessExecutable"));
			IEnumWbemClassObject * pEnum = NULL;
			hr = pServices->CreateInstanceEnum(className, WBEM_FLAG_SHALLOW | WBEM_FLAG_RETURN_IMMEDIATELY, NULL, &pEnum);
			
			if (SUCCEEDED(hr))
			{
				IWbemClassObject *	pWBEMObject = NULL;
				ULONG				uReturned;
				VARIANT				variant;
				BSTR				propName = SysAllocString(_T("Antecedent"));

				VariantInit(&variant);

				do 
				{
					uReturned = 0;
					hr = pEnum->Next(TIMEOUT, 1, &pWBEMObject, &uReturned);
					if (SUCCEEDED(hr) && pWBEMObject && uReturned)
					{
						// For each instance of CIM_ProcessExecutable, get the 
						// Antecedent property (which contains the file path).
						// If it is unique, save it in the list.

						VariantClear(&variant);
						if (pWBEMObject->Get(propName, 0L, &variant, NULL, NULL) == S_OK)
						{
							if (VariantChangeType(&variant, &variant, 0, VT_BSTR) == S_OK)
							{
								CString strResult = V_BSTR(&variant);

								strResult.MakeLower();
								if (m_pstrList->Find(strResult) == NULL)
									m_pstrList->AddHead(strResult);
							}
						}
					}
				} while (SUCCEEDED(hr) && pWBEMObject && uReturned);

				::SysFreeString(propName);
				pEnum->Release();
			}

			::SysFreeString(className);
		}

		return hr;
	}

	return S_OK;
}

//-----------------------------------------------------------------------------
// Help function for ProcessEnumString, used to convert single backslashes
// into double backslashes (required for WQL statements).
//-----------------------------------------------------------------------------

void MakeDoubleBackslashes(CString & strValue)
{
	CString strTemp(strValue);
	CString strResults;

	while (!strTemp.IsEmpty())
	{
		if (strTemp[0] != _T('\\'))
		{
			int index = strTemp.Find(_T('\\'));
			if (index < 0)
				index = strTemp.GetLength();
			strResults += strTemp.Left(index);
			strTemp = strTemp.Right(strTemp.GetLength() - index);
		}
		else
		{
			strResults += CString("\\\\");
			strTemp = strTemp.Mid(1);
		}
	}

	strValue = strResults;
}

//-----------------------------------------------------------------------------
// This function replaces [class.property] with the actual value of the
// property, and strings out [min-of-one], indicating if it was present in
// the fMinOfOne parameter.
//-----------------------------------------------------------------------------

void CMSIEnumerator::ProcessEnumString(CString & strStatement, BOOL & fMinOfOne, BOOL & fOnlyDups, CDataProvider * pProvider, CString & strNoInstanceLabel, BOOL fMakeDoubleBackslashes)
{
	CString	strMinOfOne(_T("min-of-one"));
	CString strOnlyDups(_T("more-than-one"));
	CString strResults;

	fMinOfOne = FALSE;
	fOnlyDups = FALSE;

	while (!strStatement.IsEmpty())
	{
		if (strStatement[0] != _T('['))
		{
			int index = strStatement.Find(_T('['));
			if (index < 0)
				index = strStatement.GetLength();
			strResults += strStatement.Left(index);
			strStatement = strStatement.Right(strStatement.GetLength() - index);
		}
		else
		{
			CString strKeyword;

			strStatement = strStatement.Right(strStatement.GetLength() - 1);
			int index = strStatement.Find(_T(']'));
			if (index < 0)
				break;

			strKeyword = strStatement.Left(index);
			if (strKeyword.Left(strMinOfOne.GetLength()).CompareNoCase(strMinOfOne) == 0)
			{
				fMinOfOne = TRUE;
				
				int iEqualsIndex = strKeyword.Find(_T('='));
				if (iEqualsIndex > 0)
					strNoInstanceLabel = strKeyword.Right(strKeyword.GetLength() - iEqualsIndex - 1);
			}
			else if (strKeyword.Left(strOnlyDups.GetLength()).CompareNoCase(strOnlyDups) == 0)
			{
				fOnlyDups = TRUE;
				
				int iEqualsIndex = strKeyword.Find(_T('='));
				if (iEqualsIndex > 0)
					strNoInstanceLabel = strKeyword.Right(strKeyword.GetLength() - iEqualsIndex - 1);
			}
			else if (!strKeyword.IsEmpty())
			{
				int iDotIndex = strKeyword.Find(_T('.'));
				if (iDotIndex >= 0)
				{
					CString strValue;
					if (pProvider->QueryValue(strKeyword.Left(iDotIndex), strKeyword.Right(strKeyword.GetLength() - iDotIndex - 1), strValue))
					{
						if (fMakeDoubleBackslashes)
							MakeDoubleBackslashes(strValue);
						strResults += strValue;
					}
				}
			}
			strStatement = strStatement.Right(strStatement.GetLength() - (index + 1));
		}
	}

	strStatement = strResults;
}

//-----------------------------------------------------------------------------
// Parse the component classes from the LNK command.
//-----------------------------------------------------------------------------
			
HRESULT CMSIEnumerator::ParseLNKCommand(const CString & strStatement, CString & strObjPath, CString & strAssocClass, CString & strResultClass)
{
	// We need to parse out the LNK statement into two or three components,
	// from the form "objPath->assocClass[->resultClass]", with the
	// brackets indicating that the resultClass is optional.

	CString strWorking(strStatement);

	int iArrowIndex = strWorking.Find(_T("->"));
	if (iArrowIndex == -1)
		return E_INVALIDARG;

	strObjPath = strWorking.Left(iArrowIndex);
	strWorking = strWorking.Right(strWorking.GetLength() - (iArrowIndex + 2));

	iArrowIndex = strWorking.Find(_T("->"));
	if (iArrowIndex == -1)
		strAssocClass = strWorking;
	else
	{
		strAssocClass = strWorking.Left(iArrowIndex);
		strWorking = strWorking.Right(strWorking.GetLength() - (iArrowIndex + 2));
		strResultClass = strWorking;
		strResultClass.MakeLower();
	}

	strAssocClass.TrimRight(); strAssocClass.TrimLeft();
	strObjPath.TrimRight(); strObjPath.TrimLeft();
	strResultClass.TrimRight(); strResultClass.TrimLeft();

	return S_OK;
}

//-----------------------------------------------------------------------------
// The Next method will advance the enumerator based on the type of this
// enumerator.
//-----------------------------------------------------------------------------

HRESULT CMSIEnumerator::Next(CMSIObject ** ppObject)
{
	if (!ppObject)
		return E_INVALIDARG;

	*ppObject = NULL;

	// If there was an error creating the enumeration, return the error code.

	if (FAILED(m_hresCreation))
		return m_hresCreation;

	if (m_pEnum == NULL && m_enumtype != CMSIEnumerator::INTERNAL)
		return E_UNEXPECTED;

	HRESULT				hRes = S_OK;
	IWbemClassObject *	pWBEMObject = NULL;

	switch (m_enumtype)
	{
	case CMSIEnumerator::LNK:
		{
			// Scan through the enumerated associate class. Look for one which
			// satisfies our requirements.

			CString				strTemp, strAssociatedObject(_T(""));
			ULONG				uReturned;
			IWbemClassObject *	pAssocObj;

			if (msiLog.IsLogging(CMSInfoLog::WMI))
				msiLog.WriteLog(CMSInfoLog::WMI, _T("WMI Enumerate LNK \"%s\" - "), m_strAssocClass);

			do
			{
				pAssocObj = NULL;
				uReturned = 0;
				START_TIMER();
				hRes = m_pEnum->Next(TIMEOUT, 1, &pAssocObj, &uReturned);
				END_TIMER(_T("next LNK[%s]"), m_strAssocClass);

				if (!pAssocObj || FAILED(hRes) || uReturned != 1)
				{
					// Even if we didn't succeed in getting a new object,
					// we might have a saved one if we're only showing
					// "more-than-one" objects.

					if (m_fOnlyDups && m_pSavedDup && m_fGotDuplicate)
					{
						// We have found one previously, so return it.
						// Make it look like the Next call was successful.

						m_pSavedDup = NULL;
						hRes = S_OK;
						uReturned = 1;
						strAssociatedObject = m_strSavedDup;
						break;
					}
					else
					{
						if (m_pSavedDup)
						{
							// We only got one object instance, so get rid of it.

							m_pSavedDup->Release();
							m_pSavedDup = NULL;
						}
						break;
					}
				}

				if (AssocObjectOK(pAssocObj, strTemp))
				{
					// This object passed the filter - but if we're showing
					// only "more-than-one" objects, save this one and return
					// the saved one.

					if (m_fOnlyDups)
					{
						if (m_pSavedDup)
						{
							// We have found one previously, so return it and
							// save the current.

							IWbemClassObject *	pSwap = pAssocObj;
							CString				strSwap = strTemp;

							pAssocObj = m_pSavedDup;
							m_pSavedDup = pSwap;

							strTemp = m_strSavedDup;
							m_strSavedDup = strSwap;

							m_fGotDuplicate = TRUE;
						}
						else
						{
							// This is the first one we've found - don't
							// return it until we find another.

							m_pSavedDup = pAssocObj;
							m_strSavedDup = strTemp;
							m_fGotDuplicate = FALSE;
							continue;
						}
					}

					strAssociatedObject = strTemp;
					pAssocObj->Release();
					break;
				}

				pAssocObj->Release();
			} while (pAssocObj);

			if (msiLog.IsLogging(CMSInfoLog::WMI))
				msiLog.WriteLog(CMSInfoLog::WMI, _T("OK\r\n"), TRUE);

			// If there is an associated object path, get the object.

			if (!strAssociatedObject.IsEmpty())
			{
				BSTR path = strAssociatedObject.AllocSysString();
				hRes = m_pProvider->m_pIWbemServices->GetObject(path, 0, NULL, &pWBEMObject, NULL);
				SysFreeString(path);
			}
		}
		break;

	case CMSIEnumerator::WQL:
		{
			ULONG uReturned;

			if (msiLog.IsLogging(CMSInfoLog::WMI))
				msiLog.WriteLog(CMSInfoLog::WMI, _T("WMI Enumerate WQL \"%s\" - "), m_strClass);

			START_TIMER();
			hRes = m_pEnum->Next(TIMEOUT, 1, &pWBEMObject, &uReturned);
			END_TIMER(_T("next WQL[%s]"), m_strClass);

			if (msiLog.IsLogging(CMSInfoLog::WMI))
				msiLog.WriteLog(CMSInfoLog::WMI, _T("OK\r\n"), TRUE);
		}
		break;

	case CMSIEnumerator::INTERNAL:
		hRes = InternalNext(&pWBEMObject);
		break;

	case CMSIEnumerator::CLASS:
	default:
		{
			ULONG uReturned;

			if (msiLog.IsLogging(CMSInfoLog::WMI))
				msiLog.WriteLog(CMSInfoLog::WMI, _T("WMI Enumerate CLASS \"%s\" - "), m_strClass);

			// EvaluateFilter and IsDependencyJoin handle a NULL pConstraints parameter,
			// but for efficiency we're going to have a distinct branch for a non-NULL
			// value (since it will usually be NULL).

			if (m_pConstraints)
			{
				// Keep enumerating the instances of this class until we've
				// found one which satisfies all of the filters.

				do
				{
					pWBEMObject = NULL;
					START_TIMER();
					hRes = m_pEnum->Next(TIMEOUT, 1, &pWBEMObject, &uReturned);
					END_TIMER(_T("next CLS[%s]"), m_strClass);

					if (!pWBEMObject || hRes != S_OK || uReturned != 1)
						break;
					else if (m_pProvider->EvaluateFilter(pWBEMObject, m_pConstraints))
						break;

					pWBEMObject->Release();
				} while (pWBEMObject);

				// If this class is being enumerated as a dependency class, then
				// locate all the objects it references. If it isn't, we still
				// need to check for any joins to other classes formed by the constraints.

				if (pWBEMObject)
					if (m_pProvider->IsDependencyJoin(m_pConstraints))
						m_pProvider->EvaluateDependencyJoin(pWBEMObject);
					else
						m_pProvider->EvaluateJoin(m_strClass, pWBEMObject, m_pConstraints);
			}
			else
				hRes = m_pEnum->Next(TIMEOUT, 1, &pWBEMObject, &uReturned);

			if (msiLog.IsLogging(CMSInfoLog::WMI))
				msiLog.WriteLog(CMSInfoLog::WMI, _T("OK\r\n"), TRUE);
		}
		break;
	}

	if (pWBEMObject == NULL)
	{
		// There was no object to get. We'll still create a CMSIObject, but
		// we'll set its state to indicate either that there are no instances,
		// or one instance with an error message.

		if (SUCCEEDED(hRes) && (m_iMinOfOneCount == 0))
			*ppObject = new CMSIObject(pWBEMObject, m_strNoInstanceLabel, hRes, m_pProvider, CDataProvider::MOS_NO_INSTANCES);
		else
			*ppObject = new CMSIObject(pWBEMObject, m_strNoInstanceLabel, hRes, m_pProvider, CDataProvider::MOS_MSG_INSTANCE);
	}
	else
		*ppObject = new CMSIObject(pWBEMObject, m_strNoInstanceLabel, hRes, m_pProvider, CDataProvider::MOS_INSTANCE);

	if (m_iMinOfOneCount)
		m_iMinOfOneCount--;

	return S_OK;
}

//-----------------------------------------------------------------------------
// InternalNext is used to return a WBEM object for an internal enumeration
// (one that requires processing beyond the template file). Basically a 
// set of special cases.
//-----------------------------------------------------------------------------

HRESULT CMSIEnumerator::InternalNext(IWbemClassObject ** ppWBEMObject)
{
	if (m_pstrList && !m_pstrList->IsEmpty())
	{
		CString strNextObject = m_pstrList->RemoveHead();
		if (!strNextObject.IsEmpty())
		{
			IWbemServices * pServices = m_pProvider->GetWBEMService();
			if (pServices)
			{
				BSTR objectpath = ::SysAllocString(strNextObject);
				HRESULT hr = S_OK;

 				if (FAILED(pServices->GetObject(objectpath, 0, NULL, ppWBEMObject, NULL)))
					hr = E_FAIL;
				::SysFreeString(objectpath);
				return hr;
			}
		}
	}

	return S_OK;
}

//-----------------------------------------------------------------------------
// Reset should just reset the enumerator pointer.
//-----------------------------------------------------------------------------

HRESULT CMSIEnumerator::Reset(const GATH_FIELD * pConstraints)
{
	HRESULT hRes = S_OK;

	if (m_pEnum)
	{
		switch (m_enumtype)
		{
		case CMSIEnumerator::WQL:
			START_TIMER();
			hRes = Create(m_strClass, pConstraints, m_pProvider);
			END_TIMER(_T("reset WQL[%s]"), m_strClass);
			break;

		case CMSIEnumerator::LNK:
			{
				BOOL	fDummy, fDummy2;
				CString	strDummy;

				m_strObjPath = m_strLNKObject;
				ProcessEnumString(m_strObjPath, fDummy, fDummy2, m_pProvider, strDummy);
				m_iMinOfOneCount = (m_fMinOfOne) ? 1 : 0;
				START_TIMER();
				hRes = m_pEnum->Reset();
				END_TIMER(_T("reset LNK[%s]"), m_strAssocClass);
			}
			break;

		case CMSIEnumerator::INTERNAL:
			hRes = Create(m_strClass, pConstraints, m_pProvider);
			break;

		case CMSIEnumerator::CLASS:
		default:
			m_iMinOfOneCount = (m_fMinOfOne) ? 1 : 0;
			START_TIMER();
			hRes = m_pEnum->Reset();
			END_TIMER(_T("reset CLS[%s]"), m_strClass);
			break;
		}
	}
	else
		hRes = E_UNEXPECTED;
	
	return hRes;
}

//-----------------------------------------------------------------------------
// Evaluate if the pObject parameter is valid for this LNK enumerator. In
// particular, we must find the m_strObjPath in one of its properties, and
// possibly finding another property containing the m_strResultClass string.
//-----------------------------------------------------------------------------

BOOL CMSIEnumerator::AssocObjectOK(IWbemClassObject * pObject, CString & strAssociatedObject)
{
	strAssociatedObject.Empty();
	ASSERT(pObject);
	if (pObject == NULL)
		return FALSE;

	VARIANT variant;
	CString strReturn(_T("")), strValue;

	// Traverse the set of non-system properties. Look for one the is the same
	// as the object path.

	pObject->BeginEnumeration(WBEM_FLAG_REFS_ONLY | WBEM_FLAG_NONSYSTEM_ONLY);
	VariantInit(&variant);
	while (pObject->Next(0, NULL, &variant, NULL, NULL) == WBEM_S_NO_ERROR)
	{
		if (VariantChangeType(&variant, &variant, 0, VT_BSTR) == S_OK)
			strValue = V_BSTR(&variant);
		VariantClear(&variant);

		if (strValue.CompareNoCase(m_strObjPath) == 0)
			break;
	}
	pObject->EndEnumeration();

	// If we found a property containing the object path, look through for other
	// paths which might be to objects we're insterested in.

	if (strValue.CompareNoCase(m_strObjPath) == 0)
	{
		pObject->BeginEnumeration(WBEM_FLAG_REFS_ONLY | WBEM_FLAG_NONSYSTEM_ONLY);
		while (strReturn.IsEmpty() && (pObject->Next(0, NULL, &variant, NULL, NULL) == WBEM_S_NO_ERROR))
		{
			if (VariantChangeType(&variant, &variant, 0, VT_BSTR) == S_OK)
				strValue = V_BSTR(&variant);

			if (strValue.CompareNoCase(m_strObjPath) != 0)
			{
				if (m_strResultClass.IsEmpty())
					strReturn = strValue;
				else
				{
					CString strSearch(strValue);
					strSearch.MakeLower();
					if (strSearch.Find(m_strResultClass) != -1)
						strReturn = strValue;
				}
			}

			VariantClear(&variant);
		}
		pObject->EndEnumeration();
	}

	if (!strReturn.IsEmpty())
	{
		strAssociatedObject = strReturn;
		return TRUE;
	}

	return FALSE;
}

//-----------------------------------------------------------------------------
// Look up strVal in the ValueMap (if it exists) for strClass.strProperty
// If the value or the ValueMap is not found, return E_Something.
//
// Useful code snippet - this will dump the contents of the cache of
// saved values. To find all value mapped properties, but this code
// someplace where it will execute when MSInfo exits, change QueryValue
// to call CheckValueMap for all properties, then run MSInfo and do a global
// refresh (like to save an NFO).
//
//	msiLog.WriteLog(CMSInfoLog::BASIC, _T("BEGIN Dump of ValueMap Cache\r\n"));
//	CString key, val, log;
//	for (POSITION pos = g_mapValueMap.GetStartPosition(); pos != NULL;)
//	{
//		g_mapValueMap.GetNextAssoc(pos, key, val);
//		log.Format(_T(" %s = %s\r\n", key, val);
//		msiLog.WriteLog(CMSInfoLog::BASIC, log);
//	}
//	msiLog.WriteLog(CMSInfoLog::BASIC, _T("END Dump of ValueMap Cache\r\n"));
//-----------------------------------------------------------------------------

CMapStringToString g_mapValueMap;

HRESULT CDataProvider::CheckValueMap(const CString& strClass, const CString& strProperty, const CString& strVal, CString &strResult)
{
	IWbemClassObject *	pWBEMClassObject = NULL;
    HRESULT				hrMap = S_OK, hr = S_OK;
    VARIANT				vArray, vMapArray;
	IWbemQualifierSet *	qual = NULL;

	// Check the cache of saved values.

	CString strLookup = strClass + CString(_T(".")) + strProperty + CString(_T(":")) + strVal;
	if (g_mapValueMap.Lookup(strLookup, strResult))
		return S_OK;

	// Get the class object (not instance) for this class.

	IWbemServices * pServices = GetWBEMService();
	if (!pServices)
		return E_FAIL;

	CString strFullClass(_T("\\\\.\\root\\cimv2:"));
	strFullClass += strClass;
	BSTR bstrObjectPath = ::SysAllocString(strFullClass);
	hr = pServices->GetObject(bstrObjectPath, WBEM_FLAG_USE_AMENDED_QUALIFIERS, NULL, &pWBEMClassObject, NULL);
	::SysFreeString(bstrObjectPath);

	if (FAILED(hr))
		return hr;

	// Get the qualifiers from the class object.

	BSTR bstrProperty = ::SysAllocString(strProperty);
    hr = pWBEMClassObject->GetPropertyQualifierSet(bstrProperty, &qual);
	::SysFreeString(bstrProperty);

	if (SUCCEEDED(hr) && qual)
	{
		// Get the ValueMap and Value arrays.

		hrMap = qual->Get(_T("ValueMap"), 0, &vMapArray, NULL);
		hr = qual->Get(_T("Values"), 0, &vArray, NULL);

		if (SUCCEEDED(hr) && vArray.vt == (VT_BSTR | VT_ARRAY))
		{
			// Get the property value we're mapping.

			long index;
			if (SUCCEEDED(hrMap))
			{
				SAFEARRAY * pma = V_ARRAY(&vMapArray);
				long lLowerBound = 0, lUpperBound = 0 ;

				SafeArrayGetLBound(pma, 1, &lLowerBound);
				SafeArrayGetUBound(pma, 1, &lUpperBound);
				BSTR vMap;

				for (long x = lLowerBound; x <= lUpperBound; x++)
				{
					
					SafeArrayGetElement(pma, &x, &vMap);
					
					if (0 == strVal.CompareNoCase((LPCTSTR)vMap))
					{
						index = x;
						break; // found it
					}
				} 
			}
			else
			{
				// Shouldn't hit this case - if mof is well formed
				// means there is no value map where we are expecting one.
				// If the strVal we are looking for is a number, treat it
				// as an index for the Values array. If it's a string, 
				// then this is an error.

				TCHAR * szTest = NULL;
				index = _tcstol((LPCTSTR)strVal, &szTest, 10);

				if (szTest == NULL || (index == 0 && *szTest != 0) || strVal.IsEmpty())
					hr = E_FAIL;
			}

			// Lookup the string.

			if (SUCCEEDED(hr))
			{
				SAFEARRAY * psa = V_ARRAY(&vArray);
				long ix[1] = {index};
				BSTR str2;

				hr = SafeArrayGetElement(psa, ix, &str2);
				if (SUCCEEDED(hr))
				{
					strResult = str2;
					SysFreeString(str2);
					hr = S_OK;
				}
				else
				{
					hr = WBEM_E_VALUE_OUT_OF_RANGE;
				}
			}
		}

		qual->Release();
	}

	if (SUCCEEDED(hr))
		g_mapValueMap.SetAt(strLookup, strResult);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by MSInfo.rc
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
#define IDS_PROJNAME                    100
#define IDS_DESCRIPTION                 101
#define IDD_FORMVIEW                    101
#define IDD_FIND                        101
#define IDS_COMPANY                     102
#define IDS_VERSION                     103
#define IDS_NODENAME                    104
#define IDS_NODEDESCRIPTION             105
#define IDS_REGISTRY                    106
#define IDS_EXTENSIONDESCRIPTION        106
#define IDS_SAVEREPORTMENUNAME          107
#define IDS_SAVEFILEMENUNAME            108
#define IDS_FINDMENUNAME                109
#define IDS_OPENFILEMENUNAME            110
#define IDS_SAVEREPORTSTATUS            111
#define IDS_SAVEFILESTATUS              112
#define IDS_OPENFILESTATUS              113
#define IDS_FINDSTATUS                  114
#define IDS_PRINTMENUNAME               115
#define IDS_PRINTSTATUS                 116
#define IDS_SUPPORTTOOLS                117
#define IDS_SUPPORTITEM                 118
#define IDS_ORDERED_TBTEXT0             119
#define IDS_ORDERED_TBTEXT1             120
#define IDS_ORDERED_TBTEXT2             121
#define IDS_ORDERED_TBTEXT3             122
#define IDS_ORDERED_TBTEXT4             123
#define IDS_ORDERED_TBTEXT5             124
#define IDS_ORDERED_TBTEXT6             125
#define IDS_ORDERED_TBTEXT7             126
#define IDS_ORDERED_TBTEXT8             127
#define IDS_ORDERED_TBTTIP0             128
#define IDS_ORDERED_TBTTIP1             129
#define IDS_ORDERED_TBTTIP2             130
#define IDS_ORDERED_TBTTIP3             131
#define IDS_ORDERED_TBTTIP4             132
#define IDS_ORDERED_TBTTIP5             133
#define IDS_ORDERED_TBTTIP6             134
#define IDS_ORDERED_TBTTIP7             135
#define IDS_ORDERED_TBTTIP8             136
#define IDS_COLUMN1                     137
#define IDS_COLUMN2                     138
#define IDS_COLUMN3                     139
#define IDS_COLUMN4                     140
#define IDS_COLUMN5                     141
#define IDS_CHOOSER_INVALID_COMPUTERNAME 142
#define IDS_CIMOMMESSAGE                143
#define IDS_NOTEMPLATE                  144
#define IDS_TRUE                        145
#define IDS_FALSE                       146
#define IDS_NOGATHERER                  147
#define IDS_TEMPLATELOADERROR           148
#define IDS_PROPERTYTITLE               149
#define IDS_NOFILE                      150
#define IDS_BADTEMPLATE                 151
#define IDS_BADCATEGORY                 152
#define IDS_UNEXPECTED                  153
#define IDS_TIME_FORMAT                 154
#define IDS_EXTENSIONNODENAME           155
#define IDS_FILENODE                    156
#define IDS_V500FILENODE                156
#define IDS_POLICYFORBIDSRUN            157
#define IDS_NOPATH                      158
#define IDS_TEMPLATEVERSION             159
#define IDS_ADVANCEDVIEWNAME            160
#define IDS_ADVANCEDSTATUS              161
#define IDS_BASICVIEWNAME               162
#define IDS_BASICSTATUS                 163
#define IDS_MSINFOTOOLSET               164
#define IDS_WBEMUSERMANAGERITEM         165
#define IDS_DRWATSONITEM                166
#define IDS_DEFRAGITEM                  167
#define IDS_WINDOWSREPORTITEM           168
#define IDS_NETWORKMONITORITEM          169
#define IDS_CLOSEMENUNAME               170
#define IDS_CLOSESTATUS                 171
#define IDS_NOFINDDATA                  172
#define IDS_NOMOREMATCHES               172
#define IDS_DATANOTFOUND                173
#define IDS_HARDWAREWIZARDITEM          174
#define IDS_NETWORKPANELITEM            175
#define IDS_SIGVERIFITEM                176
#define IDS_ALLCATEGORIES               177
#define IDS_PRINT_FONT_HEIGHT           178
#define IDS_PRINT_FONT_WEIGHT           179
#define IDS_PRINT_FONT_CHARSET          180
#define IDS_PRINT_FONT_PITCHANDFAMILY   181
#define IDS_PRINT_FONT_FACENAME         182
#define IDS_PRINT_HDR_LEFT              183
#define IDS_PRINT_FTR_CTR               184
#define IDS_PRINT_HDR_RIGHT_CURRENT     185
#define IDS_PRINT_GENERIC               186
#define IDS_PRINT_NOMEMORY              187
#define IDS_PRINT_NODISK                188
#define IDS_PRINT_APPABORTED            189
#define IDS_PRINT_USERABORTED           190
#define IDS_UNRECOGNIZED_FILE           191
#define IDS_CORRUPTEDFILE               192
#define IDS_V410FILENODE                193
#define IDS_LOCALMACHINE                194
#define IDS_FINDSTOPPED                 195
#define IDS_HELPFILE                    196
#define IDS_FINDWINDOWNAME              197
#define IDS_FINDCLASS                   198
#define IDS_DLLNAME                     199
#define IDS_BAD_PATH                    199
#define IDS_ACCESS_DENIED               200
#define IDC_FIND                        201
#define IDS_DIRECTORY_FULL              201
#define IDB_LARGE                       202
#define IDC_FINDNEXT                    202
#define IDS_HARDIO                      202
#define IDB_TOOLBAR1                    203
#define IDC_STOP                        203
#define IDB_TOOLBAR                     203
#define IDB_TOOLBARALT                  203
#define IDC_CLOSE                       203
#define IDS_DISK_FULL                   203
#define IDB_32x32                       204
#define IDC_NEWSEARCH                   204
#define IDS_UNKNOWN_FILE                204
#define IDB_SMALLBMP                    205
#define IDC_MACHINECOMBO                205
#define IDS_SHARING_VIOLATION           205
#define IDB_TOOLBAR2                    206
#define IDC_SEARCHTERM                  206
#define IDS_CAB_DIR_NAME                206
#define IDB_16x16                       207
#define IDC_CATEGORYCHECK               207
#define IDS_MSI_FILE_EXTENSION          207
#define IDR_SUPPORTTOOLS                208
#define IDC_MACHINECOMBO2               208
#define IDC_CATEGORYCOMBO               208
#define IDS_MSI_REG_BASE                208
#define IDC_COMBO1                      210
#define IDC_FINDIN                      210
#define IDC_BUTTON1                     211
#define IDC_STOPFIND                    211
#define IDI_MSINFO                      212
#define IDB_TOOLS                       216
#define IDB_ICON32                      219
#define IDB_ICON16                220
#define IDC_CHOOSER_STATIC              970
#define IDD_CHOOSER_CHOOSE_MACHINE      970
#define IDC_CHOOSER_GROUP_TARGET_MACHINE 971
#define IDC_CHOOSER_RADIO_LOCAL_MACHINE 972
#define IDC_CHOOSER_RADIO_SPECIFIC_MACHINE 973
#define IDC_CHOOSER_EDIT_MACHINE_NAME   974
#define IDC_CHOOSER_BUTTON_BROWSE_MACHINENAMES 975
#define IDC_CHOOSER_CHECK_OVERRIDE_MACHINE_NAME 976
#define IDI_FOLDER                      32512
#define ID_SUPPORTTOOLS_FIRSTTOOL       32768
#define ID_SUPPORTTOOLS_FIRSTTOOL_SUBTOOL1 32770
#define ID_SUPPORTTOOLS_FIRSTTOOL_SUBTOOL2 32771
#define ID_SUPPORTTOOLS_SECONDTOOLSET_THIRDTOOL 32773
#define ID_SUPPORTTOOLS_THIRDTOOLSET_FOURTHTOOL 32775

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        218
#define _APS_NEXT_COMMAND_VALUE         32776
#define _APS_NEXT_CONTROL_VALUE         213
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\scopemap.cpp ===
//	ScopeMap.cpp - Provides the implementation of a map for scope items.
//		Currently only defines constants
//
//  Copyright (c) 1998-1999 Microsoft Corporation

#include "ScopeMap.h"

const int CScopeItemMap::MapIncrement = 20;
const int CScopeItemMap::HashSize = 80;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\scopemap.h ===
//	ScopeMap.h - Create a map of Scope items.
//
// History:	a-jsari		10/7/97		Initial version
//
// Copyright (c) 1998-1999 Microsoft Corporation

#pragma once

#include <afxtempl.h>
#include "DataSrc.h"
#include "ViewObj.h"
#include "Consts.h"

//	This hack is required because we may be building in an environment
//	which doesn't have a late enough version of rpcndr.h
#if		__RPCNDR_H_VERSION__ < 440
#define __RPCNDR_H_VERSION__ 440
#define MIDL_INTERFACE(x)	interface
#endif

#ifndef __mmc_h__
#include <mmc.h>
#endif // __mmc_h__

/*
 * CScopeItem - an object which can be inserted in a CMapStringToOb which contains
 *		an HSCOPEITEM
 *
 * History:	a-jsari		12/16/97		Initial version.
 */
class CScopeItem : public CObject {
public:
	CScopeItem()	{}
	CScopeItem(HSCOPEITEM hsiNew) :m_hsiValue(hsiNew)					{ }
	CScopeItem(const CScopeItem &siCopy) :m_hsiValue(siCopy.m_hsiValue)	{ }

	~CScopeItem()	{}

	const CScopeItem &operator=(const CScopeItem &siCopy)
	{
		if (&siCopy != this)
			SetValue(siCopy.GetValue());
		return *this;
	}
	void		SetValue(HSCOPEITEM hsiSet)					{ m_hsiValue = hsiSet; }
	HSCOPEITEM	GetValue() const							{ return m_hsiValue; }
private:
	HSCOPEITEM	m_hsiValue;
};

/*
 * CScopeItemMap - Wrapper function for two cross-mappings of HSCOPEITEM and
 *		CViewObject pairs.
 *
 * History:	a-jsari		10/7/97		Initial version.
 */
class CScopeItemMap {
public:
	CScopeItemMap() :m_mapScopeToView(MapIncrement), m_mapViewToScope(MapIncrement)
		{ m_mapScopeToView.InitHashTable(HashSize); m_mapViewToScope.InitHashTable(HashSize); }
	~CScopeItemMap()					{ Clear(); }

	CFolder			*CategoryFromScope(HSCOPEITEM hsiNode) const;
	void			InsertRoot(CViewObject *pvoRootData, HSCOPEITEM hsiNode);
	void			Insert(CViewObject *pvoData, HSCOPEITEM hsiNode);
	BOOL			ScopeFromView(CViewObject *pvoNode, HSCOPEITEM &hsiNode) const;
	BOOL			ScopeFromName(const CString &strName, HSCOPEITEM &hsiNode) const;
	void			Clear();
private:
	static const int MapIncrement;
	static const int HashSize;

	CMap<HSCOPEITEM, HSCOPEITEM &, CViewObject *, CViewObject * &>		m_mapScopeToView;
	CMap<CViewObject *, CViewObject * &, HSCOPEITEM, HSCOPEITEM &>		m_mapViewToScope;
	CMapStringToOb														m_mapNameToScope;
};

/*
 * CategoryFromScope - Return the CDataCategory pointer, given the hsiNode.
 *		Note: Do not free the resultant pointer.
 *
 * History: a-jsari		10/7/97
 */
inline CFolder *CScopeItemMap::CategoryFromScope(HSCOPEITEM hsiNode) const
{
	CViewObject		*pvoData;
	if (m_mapScopeToView.Lookup(hsiNode, pvoData) == 0) return NULL;
	//	Root category.
	return pvoData->Category();
}

/*
 * Insert - Inserts the pvoData <-> hsiNode pairing into the maps.
 *
 * History:	a-jsari		10/8/97
 */
inline void CScopeItemMap::Insert(CViewObject *pvoData, HSCOPEITEM hsiNode)
{
	CString		strName;

	m_mapScopeToView.SetAt(hsiNode, pvoData);
	m_mapViewToScope.SetAt(pvoData, hsiNode);
	pvoData->Category()->InternalName(strName);
	m_mapNameToScope.SetAt(strName, new CScopeItem(hsiNode));
}

/*
 * InsertRoot - Special case insertion for the ROOT node (which always has
 *		a Cookie of Zero), but which we want to have a legitamate object for
 *		the Node.
 *
 * History: a-jsari		10/10/97
 */
inline void CScopeItemMap::InsertRoot(CViewObject *pvoData, HSCOPEITEM hsiNode)
{
	CString		strValue = cszRootName;

	CViewObject		*pvoNullCookie = NULL;
	m_mapScopeToView.SetAt(hsiNode, pvoData);
	// Insert the NULL cookie as the index for the HSCOPEITEM
	m_mapViewToScope.SetAt(pvoNullCookie, hsiNode);
	m_mapNameToScope.SetAt(strValue, new CScopeItem(hsiNode));
}

/*
 * ScopeFromView - Return the HSCOPEITEM pvoNode maps to, in hsiNode.
 *
 * Return Codes:
 *		TRUE - Successful completion
 *		FALSE - pvoNode could not be found in the map.
 *
 * History: a-jsari		10/8/97
 */
inline BOOL CScopeItemMap::ScopeFromView(CViewObject *pvoNode, HSCOPEITEM &hsiNode) const
{
	return m_mapViewToScope.Lookup(pvoNode, hsiNode);
}

/*
 * ScopeFromName - Return the scope item
 *
 * History:	a-jsari		12/11/97
 */
inline BOOL CScopeItemMap::ScopeFromName(const CString &strName, HSCOPEITEM &hsiNode) const
{
	BOOL		fReturn;
	CScopeItem	*psiNode;
	fReturn = m_mapNameToScope.Lookup(strName, (CObject * &)psiNode);
	if (fReturn) hsiNode = psiNode->GetValue();
	return fReturn;
}

/*
 * clear - Remove all map items and free the CViewObject pointers
 *
 * History:	a-jsari		10/7/97
 */
inline void CScopeItemMap::Clear()
{
	if (m_mapScopeToView.IsEmpty()) {
		ASSERT(m_mapViewToScope.IsEmpty());
		return;
	}
	CViewObject		*pvoIterator;
	CString			strIterator;
	CScopeItem		*psiIterator;
	HSCOPEITEM		hsiIterator;
	POSITION		posCurrent;

	posCurrent = m_mapScopeToView.GetStartPosition();
	while (posCurrent != NULL) {
		m_mapScopeToView.GetNextAssoc(posCurrent, hsiIterator, pvoIterator);
		VERIFY(m_mapScopeToView.RemoveKey(hsiIterator));
		delete pvoIterator;
	}
	posCurrent = m_mapNameToScope.GetStartPosition();
	while (posCurrent != NULL) {
		m_mapNameToScope.GetNextAssoc(posCurrent, strIterator, (CObject * &)psiIterator);
		VERIFY(m_mapNameToScope.RemoveKey(strIterator));
		delete psiIterator;
	}
	ASSERT(m_mapScopeToView.IsEmpty());
	m_mapViewToScope.RemoveAll();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\refresh.cpp ===
//=============================================================================
// File:			refresh.cpp
// Author:		a-jammar
// Covers:		CRefreshFunctions
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// This file contains functions useful for refreshing the internal data
// categories. The CRefreshFunctions class just has static functions, and
// is used to group the functions together.
//=============================================================================

#include "stdafx.h"
#include "gather.h"
#include "gathint.h"
#include "resrc1.h"

//-----------------------------------------------------------------------------
// This method takes the information in a GATH_FIELD struct and uses it to
// generate a current GATH_VALUE struct.
//-----------------------------------------------------------------------------

BOOL CRefreshFunctions::RefreshValue(CDataGatherer * pGatherer, GATH_VALUE * pVal, GATH_FIELD * pField)
{
	TCHAR			szFormatFragment[MAX_PATH];
	const TCHAR		*pSourceChar;
	TCHAR			*pDestinationChar;
	TCHAR			cFormat = _T('\0');
	BOOL			fReadPercent = FALSE;
	BOOL			fReturnValue = TRUE;
	CString			strResult, strTemp;
	int				iArgNumber = 0;
	DWORD			dwValue = 0L;

	// Process the format string. Because of the difficulty caused by having
	// variable number of arguments to be inserted (like printf), we'll need
	// to break the format string into chunks and do the sprintf function
	// for each format flag we come across.

	pSourceChar			= (LPCTSTR) pField->m_strFormat;
	pDestinationChar	= szFormatFragment;

	while (*pSourceChar)
	{
		if (fReadPercent)
		{
			// If we read a percent sign, we should be looking for a valid flag.
			// We are using some additional flags to printf (and not supporting
			// others). If we read another percent, just insert a single percent.
			
			switch (*pSourceChar)
			{
			case _T('%'):
				fReadPercent = FALSE;
				break;

			case _T('b'): case _T('B'):
			case _T('l'): case _T('L'):
			case _T('u'): case _T('U'):
			case _T('s'): case _T('S'):
				fReadPercent = FALSE;
				cFormat = *pSourceChar;
				*pDestinationChar = _T('s');
				break;

			case _T('t'): case _T('T'):
				fReadPercent = FALSE;
				cFormat = *pSourceChar;
				*pDestinationChar = _T('s');
				break;

			case _T('x'): case _T('X'):
			case _T('d'): case _T('D'):
				fReadPercent = FALSE;
				cFormat = _T('d');
				*pDestinationChar = *pSourceChar;
				break;

			case _T('q'): case _T('Q'):
				fReadPercent = FALSE;
				cFormat = _T('q');
				*pDestinationChar = _T('s');
				break;

			case _T('z'): case _T('Z'):
				fReadPercent = FALSE;
				cFormat = _T('z');
				*pDestinationChar = _T('s');
				break;

			case _T('y'): case _T('Y'):
				fReadPercent = FALSE;
				cFormat = _T('y');
				*pDestinationChar = _T('s');
				break;

			case _T('v'): case _T('V'):
				fReadPercent = FALSE;
				cFormat = _T('v');
				*pDestinationChar = _T('s');
				break;

			case _T('f'): case _T('F'):
				fReadPercent = FALSE;
				cFormat = *pSourceChar;
				*pDestinationChar = *pSourceChar;
				break;

			default:
				*pDestinationChar = *pSourceChar;
			}
		}
		else if (*pSourceChar == _T('%'))
		{
			*pDestinationChar = _T('%');
			fReadPercent = TRUE;
		}
		else
			*pDestinationChar = *pSourceChar;

		pSourceChar++;
		pDestinationChar++;

		// If a format flag is set or we are at the end of the source string,
		// then we have a complete fragment and we should produce some output,
		// which will be concatenated to the strResult string.

		if (cFormat || *pSourceChar == _T('\0'))
		{
			*pDestinationChar = _T('\0');
			if (cFormat)
			{
				// Based on the format type, get a value from the provider for
				// the next argument. Format the result using the formatting 
				// fragment we extracted, and concatenate it.

				if (GetValue(pGatherer, cFormat, szFormatFragment, strTemp, dwValue, pField, iArgNumber++))
				{
					strResult += strTemp;
					cFormat = _T('\0');
				}
				else
				{
					strResult = strTemp;
					break;
				}
			}
			else
			{
				// There was no format flag, but we are at the end of the string.
				// Add the fragment we got to the result string.

				strResult += CString(szFormatFragment);
			}

			pDestinationChar = szFormatFragment;
		}
	}

	// Assign the values we generated to the GATH_VALUE structure. Important note:
	// the dwValue variable will only have ONE value, even though multiple values
	// might have been generated to build the strResult string. Only the last
	// value will be saved in dwValue. This is OK, because this value is only
	// used for sorting a column when the column is marked for non-lexical sorting.
	// In that case, there should be only one value used to generat the string.

	pVal->m_strText = strResult;
	pVal->m_dwValue = dwValue;

	return fReturnValue;
}

//-----------------------------------------------------------------------------
// Return a string with delimiters added for the number.
//-----------------------------------------------------------------------------

CString DelimitNumber(double dblValue)
{
	NUMBERFMT fmt;
	TCHAR szResult[MAX_PATH] = _T("");
	TCHAR szDelimiter[4] = _T(",");

	GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, szDelimiter, 4);

	memset(&fmt, 0, sizeof(NUMBERFMT));
	fmt.Grouping = 3;
	fmt.lpDecimalSep = _T(""); // doesn't matter - there aren't decimal digits
	fmt.lpThousandSep = szDelimiter;

	CString strValue;
	strValue.Format(_T("%.0f"), dblValue);
	GetNumberFormat(LOCALE_USER_DEFAULT, 0, strValue, &fmt, szResult, MAX_PATH);

	return CString(szResult);
}

//-----------------------------------------------------------------------------
// This method gets a single value from the provider, based on the format
// character from the template file. It formats the results using the 
// format string szFormatFragment, which should only take one argument.
//-----------------------------------------------------------------------------

BOOL CRefreshFunctions::GetValue(CDataGatherer *pGatherer, TCHAR cFormat, TCHAR *szFormatFragment, CString &strResult, DWORD &dwResult, GATH_FIELD *pField, int iArgNumber)
{
	CString			strTemp;
	COleDateTime	datetimeTemp;
	double			dblValue;

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	strResult.Empty();
	dwResult = 0L;

	if (!pField->m_strSource.IsEmpty() && pField->m_strSource.CompareNoCase(CString(STATIC_SOURCE)) != 0)
	{
		CDataProvider * pProvider = pGatherer->GetProvider();

		if (!pProvider)
			return FALSE;

		// Find the right argument for this formatting (indicated by the iArgNumber
		// parameter.

		GATH_VALUE * pArg = pField->m_pArgs;
		while (iArgNumber && pArg)
		{
			pArg = pArg->m_pNext;
			iArgNumber--;
		}

		if (pArg == NULL)
			return FALSE;

		switch (cFormat)
		{
		case 'b': case 'B':
			// This is a boolean type. Show either true or false, depending on
			// the numeric value.

			if (pProvider->QueryValueDWORD(pField->m_strSource, pArg->m_strText, dwResult, strTemp))
			{
				strTemp = (dwResult) ? pProvider->m_strTrue : pProvider->m_strFalse;
				strResult.Format(szFormatFragment, strTemp);
				return TRUE;
			}
			else
			{
				strResult = strTemp;
				return FALSE;
			}
			break;

		case 'd': case 'D':
			// This is the numeric type.

			if (pProvider->QueryValueDWORD(pField->m_strSource, pArg->m_strText, dwResult, strTemp))
			{
				strResult.Format(szFormatFragment, dwResult);
				return TRUE;
			}
			else
			{
				strResult = strTemp;
				return FALSE;
			}
			break;

		case 'f': case 'F':
			// This is the double floating point type.

			if (pProvider->QueryValueDoubleFloat(pField->m_strSource, pArg->m_strText, dblValue, strTemp))
			{
				strResult.Format(szFormatFragment, dblValue);
				return TRUE;
			}
			else
			{
				strResult = strTemp;
				return FALSE;
			}
			break;

		case 't': case 'T':
			// This is the OLE date and time type. Format the date and time into the
			// string result, and return the date part in the DWORD (the day number is
			// to the left of the decimal in the DATE type).

			if (pProvider->QueryValueDateTime(pField->m_strSource, pArg->m_strText, datetimeTemp, strTemp))
			{
				strResult = datetimeTemp.Format();
				dwResult  = (DWORD)(DATE)datetimeTemp;
				return TRUE;
			}
			else
			{
				strResult = strTemp;
				return FALSE;
			}
			break;

		case 'l': case 'L':
			// This is a string type, with the string converted to lower case.

			if (pProvider->QueryValue(pField->m_strSource, pArg->m_strText, strTemp))
			{
				strTemp.MakeLower();
				strResult.Format(szFormatFragment, strTemp);
				return TRUE;
			}
			else
			{
				strResult = strTemp;
				return FALSE;
			}
			break;

		case 'u': case 'U':
			// This is a string type, with the string converted to upper case.

			if (pProvider->QueryValue(pField->m_strSource, pArg->m_strText, strTemp))
			{
				strTemp.MakeUpper();
				strResult.Format(szFormatFragment, strTemp);
				return TRUE;
			}
			else
			{
				strResult = strTemp;
				return FALSE;
			}
			break;

		case 's': case 'S':
			// This is the string type (string is the default type).

			if (pProvider->QueryValue(pField->m_strSource, pArg->m_strText, strTemp))
			{
				strResult.Format(szFormatFragment, strTemp);

				// We only need to do this when the value returned is a number
				// and is going in a column that we want to sort numerically.
				// This won't break the case where a numeric string is to be
				// sorted as a string because dwResult will be ignored.
				if (iswdigit( strTemp[0]))
					dwResult = _ttol( (LPCTSTR)strTemp);

				return TRUE;
			}
			else
			{
				strResult = strTemp;
				return FALSE;
			}
			break;

		case 'q': case 'Q':
			// This is a specialized type for the Win32_BIOS class. We want to show
			// the "Version" property - if it isn't there, then we want to show
			// the "Name" property and "ReleaseDate" properties concatenated
			// together.

			if (pProvider->QueryValue(pField->m_strSource, CString(_T("Version")), strTemp))
			{
				strResult = strTemp;
				return TRUE;
			}
			else
			{
				if (pProvider->QueryValue(pField->m_strSource, CString(_T("Name")), strTemp))
					strResult = strTemp;

				if (pProvider->QueryValueDateTime(pField->m_strSource, CString(_T("ReleaseDate")), datetimeTemp, strTemp))
					strResult += CString(_T(" ")) + datetimeTemp.Format();

				return TRUE;
			}
			break;

		case 'z': case 'Z':
			// This is a specialized size type, where the value is a numeric count
			// of bytes. We want to convert it into the best possible units for
			// display (for example, display "4.20 MB (4,406,292 bytes)").

			if (pProvider->QueryValueDoubleFloat(pField->m_strSource, pArg->m_strText, dblValue, strTemp))
			{
				double	dValue = (double) dblValue;
				DWORD	dwDivisor = 1;

				// Reduce the dValue to the smallest possible number (with a larger unit).

				while (dValue > 1024.0 && dwDivisor < (1024 * 1024 * 1024))
				{
					dwDivisor *= 1024;
					dValue /= 1024.0;
				}

				if (dwDivisor == 1)
					strResult.Format(IDS_SIZEBYTES, DelimitNumber(dblValue));
				else if (dwDivisor == (1024))
					strResult.Format(IDS_SIZEKB_BYTES, dValue, DelimitNumber(dblValue));
				else if (dwDivisor == (1024 * 1024))
					strResult.Format(IDS_SIZEMB_BYTES, dValue, DelimitNumber(dblValue));
				else if (dwDivisor == (1024 * 1024 * 1024))
					strResult.Format(IDS_SIZEGB_BYTES, dValue, DelimitNumber(dblValue));

				dwResult = (DWORD) dblValue;	// So we can sort on this value (bug 391127).
			}
			else
			{
				strResult = strTemp;
				return FALSE;
			}
			break;

		case 'y': case 'Y':
			// This is a specialized size type, where the value is a numeric count
			// of bytes, already in KB. If it's big enough, show it in MB or GB.

			if (pProvider->QueryValueDoubleFloat(pField->m_strSource, pArg->m_strText, dblValue, strTemp))
			{
				strResult.Format(IDS_SIZEKB, DelimitNumber(dblValue));
				dwResult = (DWORD) dblValue;	// So we can sort on this value (bug 391127).
			}
			else
			{
				strResult = strTemp;
				return FALSE;
			}
			break;

		case 'v': case 'V':
			// This is a specialized type, assumed to be an LCID (locale ID). Show the
			// locale.

			if (pProvider->QueryValue(pField->m_strSource, pArg->m_strText, strTemp))
			{
				// strTemp contains a string locale ID (like "0409"). Convert it into
				// and actual LCID.

				LCID lcid = (LCID) _tcstoul(strTemp, NULL, 16);
				TCHAR szCountry[MAX_PATH];
				if (GetLocaleInfo(lcid, LOCALE_SCOUNTRY, szCountry, MAX_PATH))
					strResult = szCountry;
				else
					strResult = strTemp;
			}
			else
			{
				strResult = strTemp;
				return FALSE;
			}
			break;

		default:
			ASSERT(FALSE); // unknown formatting flag
			return TRUE;
		}
	}

	return FALSE;
}

//-----------------------------------------------------------------------------
// Refresh the list of columns based on the list of column fields. We'll also
// need to set the number of columns.
//-----------------------------------------------------------------------------

BOOL CRefreshFunctions::RefreshColumns(CDataGatherer * pGatherer, INTERNAL_CATEGORY * pInternal)
{
	ASSERT(pInternal);
	GATH_FIELD * pField = pInternal->m_pColSpec;

	// Count the number of columns.

	pInternal->m_dwColCount = 0;
	while (pField)
	{
		pInternal->m_dwColCount++;
		pField = pField->m_pNext;
	}

	// Allocate the array of column values.

	if (pInternal->m_aCols)
		delete [] pInternal->m_aCols;

	if (pInternal->m_dwColCount == 0)
		return TRUE;

	pInternal->m_aCols = new GATH_VALUE[pInternal->m_dwColCount];
	if (pInternal->m_aCols == NULL)
		return FALSE;

	// Finally get each column name based on the column field.

	pField = pInternal->m_pColSpec;
	for (DWORD dwIndex = 0; dwIndex < pInternal->m_dwColCount; dwIndex++)
	{
		if (!RefreshValue(pGatherer, &pInternal->m_aCols[dwIndex], pField))
			return FALSE;
		pField = pField->m_pNext;
	}

	return TRUE;
}

//-----------------------------------------------------------------------------
// Refresh the list of lines based on the list of line fields. We'll also
// need to set the number of lines. The list of lines is generated based on
// the pLineSpec pointer and dwColumns variables. The generated lines are
// returned in the listLinePtrs parameter.
//-----------------------------------------------------------------------------

BOOL CRefreshFunctions::RefreshLines(CDataGatherer * pGatherer, GATH_LINESPEC * pLineSpec, DWORD dwColumns, CPtrList & listLinePtrs, volatile BOOL * pfCancel)
{
	BOOL	bReturn = TRUE;

	// Traverse the list of line specifiers to generate the list of lines.

	GATH_LINESPEC *	pCurrentLineSpec = pLineSpec;
	GATH_LINE *			pLine = NULL;

	while (pCurrentLineSpec && (pfCancel == NULL || *pfCancel == FALSE))
	{
		// Check if the current line spec is for a single line or an enumerated group.

		if (pCurrentLineSpec->m_strEnumerateClass.IsEmpty() || pCurrentLineSpec->m_strEnumerateClass.CompareNoCase(CString(STATIC_SOURCE)) == 0)
		{
			// This is for a single line. Allocate a new line structure and fill it
			// in with the data generated from the line spec.

			pLine = new GATH_LINE;
			if (pLine == NULL)
			{
				bReturn = FALSE;
				break;
			}

			if (RefreshOneLine(pGatherer, pLine, pCurrentLineSpec, dwColumns))
				listLinePtrs.AddTail((void *) pLine);
			else
			{
				bReturn = FALSE;
				break;
			}
		}
		else
		{
			// This line represents an enumerated group of lines. We need to enumerate
			// the class and call RefreshLines for the group of enumerated lines, once
			// for each class instance.

			CDataProvider * pProvider = pGatherer->GetProvider();
			if (pProvider && pProvider->ResetClass(pCurrentLineSpec->m_strEnumerateClass, pCurrentLineSpec->m_pConstraintFields))
				do
				{
					if (!RefreshLines(pGatherer, pCurrentLineSpec->m_pEnumeratedGroup, dwColumns, listLinePtrs))
						break;
				} while (pProvider->EnumClass(pCurrentLineSpec->m_strEnumerateClass, pCurrentLineSpec->m_pConstraintFields));
		}

		pCurrentLineSpec = pCurrentLineSpec->m_pNext;
	}

	if (pfCancel && *pfCancel)
		return FALSE;

	// If there was a failure generating the lines, clean up after ourselves.

	if (!bReturn)
	{
		if (pLine)
			delete pLine;

		for (POSITION pos = listLinePtrs.GetHeadPosition(); pos != NULL;)
		{
			pLine = (GATH_LINE *) listLinePtrs.GetNext(pos) ;
			if (pLine)
				delete pLine;
		}

		listLinePtrs.RemoveAll();
		return FALSE;
	}

	return TRUE;
}

//-----------------------------------------------------------------------------
// Refresh a line based on a line spec.
//-----------------------------------------------------------------------------

BOOL CRefreshFunctions::RefreshOneLine(CDataGatherer * pGatherer, GATH_LINE * pLine, GATH_LINESPEC * pLineSpec, DWORD dwColCount)
{
	// Allocate the new array of values.

	if (pLine->m_aValue)
		delete [] pLine->m_aValue;

	pLine->m_aValue = new GATH_VALUE[dwColCount];
	if (pLine->m_aValue == NULL)
		return FALSE;

	// Set the data complexity for the line based on the line spec.

	pLine->m_datacomplexity = pLineSpec->m_datacomplexity;

	// Compute each of the values for the fields.

	GATH_FIELD * pField = pLineSpec->m_pFields;
	for (DWORD dwIndex = 0; dwIndex < dwColCount; dwIndex++)
	{
		if (pField == NULL)
			return FALSE;
		if (!RefreshValue(pGatherer, &pLine->m_aValue[dwIndex], pField))
			return FALSE;
		pField = pField->m_pNext;
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\revents.cpp ===
//	REvents.cpp : All result-pane Notify events.  These functions are all
//	part of the CSystemInfo class.
//
//  Copyright (c) 1998-1999 Microsoft Corporation

#include "StdAfx.h"

//	This hack is required because we may be building in an environment
//	which doesn't have a late enough version of rpcndr.h
#if		__RPCNDR_H_VERSION__ < 440
#define __RPCNDR_H_VERSION__ 440
#define MIDL_INTERFACE(x)	interface
#endif

#ifndef __mmc_h__
#include <mmc.h>		//	..\..\..\public\sdk\inc
#endif
#include <htmlhelp.h>	//	..\..\..\public\sdk\inc

#include "DataObj.h"
#include "SysInfo.h"
#include "ViewObj.h"

//	This is not necessary; these are enumerated in the scope pane.
#if 0
/*
 * EnumerateCategories - Enumerate all sub-categories of pDataObject
 *		in the result pane.
 *
 * History:	a-jsari		10/2/97		Initial version
 */
HRESULT CSystemInfo::EnumerateCategories(CFolder *pfolSelection)
{
	HRESULT			hr		= S_OK;

	RESULTDATAITEM		rdiItem;

	rdiItem.mask	= RDI_STR | RDI_PARAM | RDI_IMAGE;
	rdiItem.str		= MMC_CALLBACK;
	rdiItem.nCol	= 0;
	rdiItem.nImage	= 0;

	CFolder		*pfolIterator = pfolSelection->GetChildNode();
	LPRESULTDATA	pResultPane = pResult();
	for (rdiItem.nIndex = 0; pfolIterator; ++rdiItem.nIndex,
			pfolIterator = pfolIterator->GetNextSibling()) {
		//	This would leak memory if we used it.
		CResultViewObject	*proCategory = new CCategoryObject(pfolIterator,
				rdiItem.nIndex);
		rdiItem.lParam = reinterpret_cast<long>(proCategory);
		hr = pResultPane->InsertItem(&rdiItem);
		if (FAILED(hr)) break;
	}
	return hr;
}
#endif

/*
 * ClearResultsPane - Clear out all saved state about the results pane,
 *		in preparation for rebuilding the information.
 *
 * History: a-jsari		10/7/97		Initial version
 */
HRESULT CSystemInfo::ClearResultsPane()
{
	// Delete all items.

	HRESULT hres = pResult()->DeleteAllRsltItems();

	// Clear our list of ViewObjects.
	
	m_lstView.Clear();
	
	return hres;
}

/*
 * EnumerateValues - Enumerate all result pane rows, given the CFolder object
 *		to be displayed.
 *
 * We do this by getting the number of rows the folder contains and creating a
 *		single CDatumObject for each row in the folder, attaching that object
 *		as the lParam data for the RESULTDATAITEM inserted.
 *
 * History:	a-jsari		10/2/97		Initial version
 */
HRESULT CSystemInfo::EnumerateValues(CFolder *pfolSelection)
{
	HRESULT			hr		= S_OK;

	RESULTDATAITEM		rdiItem;

	//	Set the information common to all of our inserted items
	//	(Modified below for selected items and by specific item data.)
	rdiItem.mask	= RDI_STR | RDI_PARAM | RDI_IMAGE;
	rdiItem.str		= MMC_CALLBACK;
	rdiItem.nCol	= 0;
	rdiItem.nImage	= 1;

	ASSERT(pfolSelection->GetType() != CDataSource::OCX);
	int				cRows = dynamic_cast<CListViewFolder *>(pfolSelection)->GetRows();
	int				nSelectionRow = pfolSelection->GetSelectedItem();

	LPRESULTDATA	pResultPane		= pResult();
	if (cRows > 0) {
		pResultPane->ModifyViewStyle((MMC_RESULT_VIEW_STYLE ) 0x0008 /* = MMC_ENSUREFOCUSVISIBLE */, (MMC_RESULT_VIEW_STYLE ) 0);
		for (rdiItem.nIndex = 0 ; rdiItem.nIndex < cRows ; ++rdiItem.nIndex) {
			//	Create our new CDatumObject so we have strings for GetDisplayInfo.
			CViewObject	*proValue = new CDatumObject(pfolSelection,
					rdiItem.nIndex);

			//	Attach it in our data.
			rdiItem.lParam = reinterpret_cast<LPARAM>(proValue);
			//	If we are the item selected by a prior find operation, set ourselves
			//	as focused and selected, otherwise just add as usual.
			if (rdiItem.nIndex == nSelectionRow) {
				rdiItem.mask |= RDI_STATE;
				rdiItem.nState = LVIS_FOCUSED | LVIS_SELECTED;
				hr = pResultPane->InsertItem(&rdiItem);
				rdiItem.mask &= ~RDI_STATE;
			} else
				hr = pResultPane->InsertItem(&rdiItem);
			if (FAILED(hr)) break;

			//	Insert our new'd pointer into the list so we may delete them when we
			//	clear out our result pane data.
			m_lstView.Add(proValue);
		}
		//	Set ourselves to the view mode which gives us column data.
		pResultPane->SetViewMode(LVS_REPORT);
		pResultPane->ModifyViewStyle((MMC_RESULT_VIEW_STYLE ) 0, (MMC_RESULT_VIEW_STYLE ) 0x0008 /* = MMC_ENSUREFOCUSVISIBLE */);
	} else {
		//	No rows means only automatic [folder] result data items, so use
		//	a list view.
		pResultPane->SetViewMode(LVS_LIST);
	}

	return hr;
}

/*
 * HandleStandardVerbs - Set all of the standard verb states, based on
 *		the context of lpDataObject and the activity state.
 *
 * History: a-jsari		9/22/97		Initial version
 */
HRESULT CSystemInfo::HandleStandardVerbs(BOOL fScope, LPDATAOBJECT lpDataObject)
{
	//	CHECK:	Candidate for optimization?
	SetInitialVerbState(fScope);

	CDataObject	* pDataObject = GetInternalFromDataObject(lpDataObject);
	if (pDataObject)
	{
		LPCONSOLEVERB pVerbSetting = pConsoleVerb();

		if (pVerbSetting)
		{
			BOOL fIsPrimarySnapin = TRUE;
			if (pComponentData())
				fIsPrimarySnapin = dynamic_cast<CSystemInfoScope *>(pComponentData())->IsPrimaryImpl();

			CDataSource * pSource = pDataObject->pSource();
			if (fIsPrimarySnapin && pSource && pSource->GetType() == CDataSource::GATHERER)
				pVerbSetting->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);
			else
				pVerbSetting->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, FALSE);
		}
	}

	return S_OK;
}

/*
 * SetInitialVerbState - Sets the default state for all of the MMC standard
 *		verbs.
 *
 * History:	a-jsari		9/22/97		Initial version
 */
void CSystemInfo::SetInitialVerbState(BOOL fScope)
{
	HRESULT		hr;

	LPCONSOLEVERB	pVerbSetting = pConsoleVerb();
	ASSERT(pVerbSetting != NULL);

#if 1
	hr = pVerbSetting->SetVerbState(MMC_VERB_PRINT, HIDDEN, FALSE);
	ASSERT(hr == S_OK);
	hr = pVerbSetting->SetVerbState(MMC_VERB_PRINT, ENABLED, TRUE);
	ASSERT(hr == S_OK);
#endif

//	hr = pVerbSetting->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, !fScope);
//	ASSERT(hr == S_OK);
//	hr = pVerbSetting->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, fScope);
//	ASSERT(hr == S_OK);

	hr = pVerbSetting->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, FALSE);
	ASSERT(hr == S_OK);
	hr = pVerbSetting->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);
	ASSERT(hr == S_OK);

	//	Enable Open verb for result pane folder nodes only.
	hr = pVerbSetting->SetVerbState(MMC_VERB_OPEN, HIDDEN, TRUE);
	ASSERT(hr == S_OK);
	hr = pVerbSetting->SetVerbState(MMC_VERB_OPEN, ENABLED, FALSE);
	ASSERT(hr == S_OK);

	BOOL	fRefreshAvailable = FALSE;
	if (((CSystemInfoScope *)pComponentData())->pSource() != NULL
		&& ((CSystemInfoScope *)pComponentData())->pSource()->GetType() == CDataSource::GATHERER)
		fRefreshAvailable = TRUE;
	hr = pVerbSetting->SetVerbState(MMC_VERB_REFRESH, HIDDEN, !fRefreshAvailable);
	ASSERT(hr == S_OK);
	hr = pVerbSetting->SetVerbState(MMC_VERB_REFRESH, ENABLED, fRefreshAvailable);
	ASSERT(hr == S_OK);

	hr = pVerbSetting->SetVerbState(MMC_VERB_COPY, HIDDEN, TRUE);
	ASSERT(hr == S_OK);
	hr = pVerbSetting->SetVerbState(MMC_VERB_COPY, ENABLED, FALSE);
	ASSERT(hr == S_OK);
	hr = pVerbSetting->SetVerbState(MMC_VERB_PASTE, HIDDEN, TRUE);
	ASSERT(hr == S_OK);
	hr = pVerbSetting->SetVerbState(MMC_VERB_PASTE, ENABLED, FALSE);
	ASSERT(hr == S_OK);
	hr = pVerbSetting->SetVerbState(MMC_VERB_DELETE, HIDDEN, TRUE);
	ASSERT(hr == S_OK);
	hr = pVerbSetting->SetVerbState(MMC_VERB_DELETE, ENABLED, FALSE);
	ASSERT(hr == S_OK);
	hr = pVerbSetting->SetVerbState(MMC_VERB_RENAME, ENABLED, FALSE);
	ASSERT(hr == S_OK);
}

/*
 * SetResultHeaderColumns - Sets the header columns used to display
 *		standard result pane data.
 *
 * History:	a-jsari		10/2/97		Initial version.
 */
HRESULT CSystemInfo::SetResultHeaderColumns(CFolder *pCategory)
{
	LPHEADERCTRL	pResultHeader;
	HRESULT			hr;
	CListViewFolder	*plvfCategory;

	AFX_MANAGE_STATE(::AfxGetStaticModuleState());

	pResultHeader = pHeaderCtrl();
	ASSERT(pResultHeader != NULL);

	int		cColumns;

	ASSERT(pCategory != NULL);
	ASSERT(pCategory->GetType() != CDataSource::OCX);
	plvfCategory = dynamic_cast<CListViewFolder *>(pCategory);
	cColumns = plvfCategory->GetColumns();

	do {
		hr = pResultHeader->DeleteColumn(0);
	} while (hr == S_OK);

	for (int i = 0; i < cColumns ; ++i) {
		CString		szColumnHeading;
		DWORD		nColumnWidth;

		VERIFY(plvfCategory->GetColumnTextAndWidth(i, szColumnHeading, (unsigned &)nColumnWidth));

		hr = pResultHeader->InsertColumn(i, (LPCWSTR)szColumnHeading,
				LVCFMT_LEFT, nColumnWidth);
		if (FAILED(hr)) break;
	}
	return hr;
}

/*
 * OnActivate - Activate event handler
 *
 * History:	a-jsari		10/3/97		Stub version
 */
HRESULT	CSystemInfo::OnActivate(LPDATAOBJECT, LPARAM)
{
	return S_OK;
}

/*
 * OnAddImages - Add the folder and leaf item images for the result pane.
 *
 * History: a-jsari		9/24/97		Stub version
 */
HRESULT CSystemInfo::OnAddImages(LPDATAOBJECT, LPIMAGELIST pImageList, HSCOPEITEM)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	::CBitmap	bmLarge;
	bmLarge.LoadBitmap(IDB_LARGE);
	::CBitmap	bmSmall;
	bmSmall.LoadBitmap(IDB_SMALLBMP);
	HRESULT hr = pImageList->ImageListSetStrip(reinterpret_cast<LONG_PTR *>((HBITMAP)bmSmall),
			reinterpret_cast<LONG_PTR *>((HBITMAP)bmLarge), 0, RGB(255,0,255));
	ASSERT(hr == S_OK);
	return hr;
}

/*
 * OnButtonClick - Handle a toolbar button click.
 *
 * History:	a-jsari		9/24/97		Stub version
 */
HRESULT CSystemInfo::OnButtonClick(LPDATAOBJECT pDataObject, LPARAM idButton)
{
	switch (idButton) {
	case IDM_TBB_FIND:
		pExtendContextMenu()->Command(CSystemInfoScope::IDM_FIND, pDataObject);
		break;
	case IDM_TBB_OPEN:
		pExtendContextMenu()->Command(CSystemInfoScope::IDM_TASK_OPENFILE, pDataObject);
		break;
	case IDM_TBB_SAVE:
		pExtendContextMenu()->Command(CSystemInfoScope::IDM_SAVEFILE, pDataObject);
		break;
#if 0
	case IDM_TBB_PRINT:
		pExtendContextMenu()->Command(CSystemInfoScope::IDM_PRINT, pDataObject);
		break;
#endif
	case IDM_TBB_REPORT:
		pExtendContextMenu()->Command(CSystemInfoScope::IDM_SAVEREPORT, pDataObject);
		break;
	default:
		ASSERT(FALSE);
		break;
	}
	return S_OK;
}

/*
 * CustomToolbarHandler - Handle the MSInfo-specific toolbar selection event.
 *		Note this also handles the toolbar deselect all event.
 *
 * History:	a-jsari		9/24/97		Initial version
 */
HRESULT CSystemInfo::OnControlbarSelect(BOOL fDeselectAll, LPARAM lSelection,
			LPDATAOBJECT)
{
#if 0
	ASSERT(IsPrimaryImpl());
	if (IsPrimaryImpl() == FALSE) return S_OK;
#endif

	HRESULT		hr;

	//		Split selection into scope/selection.
	BOOL		bScope = (BOOL) LOWORD(lSelection);
	BOOL		bSelect = (BOOL) HIWORD(lSelection);

	if (fDeselectAll) bSelect = FALSE;
	do {
		hr = EnableToolbar(bSelect);
		if (FAILED(hr)) break;
		hr = EnableSupportTools(bSelect);
	} while (0);
	return hr;
}

/*
 * OnDoubleClick - Handler for Double click event
 *
 * History:	a-jsari		10/3/97		Stub version
 */
HRESULT CSystemInfo::OnDoubleClick(LPDATAOBJECT	pDataObject)
{
	CDataObject *pdoSelection = GetInternalFromDataObject(pDataObject);

	if(NULL == pdoSelection)
		return E_FAIL;

	//	Allow MMC to open the scope node..
	if (pdoSelection->Context() == CCT_SCOPE) return S_FALSE;
	return S_OK;
}

/*
 * OnMenuButtonClick - Handle the SupportTool MENUBUTTON Button click event.
 *
 * History:	a-jsari		9/18/97		Initial version.
 */
HRESULT CSystemInfo::OnMenuButtonClick(LPDATAOBJECT *ppDataObject,
			LPMENUBUTTONDATA pMenuData)
{
	AFX_MANAGE_STATE(::AfxGetStaticModuleState());

	ASSERT(ppDataObject != NULL);
	ASSERT(pMenuData != NULL);

	if (ppDataObject == NULL || pMenuData == NULL) return E_POINTER;

	//	Get the pop-up menu we will use to process our commands.
	CMenu	*pMenu = m_mnuSupport.GetSubMenu(0);

	if (pMenu == NULL) return S_FALSE;
	unsigned long lCommand = pMenu->TrackPopupMenu(TPM_RETURNCMD | TPM_NONOTIFY,
		pMenuData->x, pMenuData->y, ::AfxGetMainWnd());
	//	We track both the Toolset index and the Tool index with a single long,
	//	bit-shifting and or'ing them together into lCommand.
	//
	//	The lCommand item is the index of the Toolset left-shifted 8 times
	//	or'd with the index of the Tool

	//	lCommand == 0 is the value for items we didn't set.
	if (lCommand != 0)
		(*m_plistTools)[lCommand >> 8]->RunTool((lCommand & 0xff) - 1);

	return S_OK;
}

/*
 * OnPrint - Handle the print event.
 *
 * History:	a-jsari		2/26/98		Initial version
 */
HRESULT CSystemInfo::OnPrint()
{
	dynamic_cast<CSystemInfoScope *>(pComponentData())->PrintReport();
	return S_OK;
}

/*
 * OnProperties - Handle the VERB_PROPERTIES event.
 *
 * History:	a-jsari		10/3/97		Stub version.
 */
HRESULT CSystemInfo::OnProperties(LPDATAOBJECT)
{
	return S_OK;
}

/*
 * OnPropertyChange - Handle the property change event.
 *
 * History: a-jsari		9/1/97		Stub version
 */
HRESULT CSystemInfo::OnPropertyChange(LPDATAOBJECT lpdo)
{
	return dynamic_cast<CSystemInfoScope *>(pComponentData())->OnProperties((LPARAM)lpdo);
}

/*
 * OnRefresh - Handle the refresh event.
 *
 * History: a-jsari		10/3/97		Initial version
 */
HRESULT CSystemInfo::OnRefresh(LPDATAOBJECT)
{
	dynamic_cast<CSystemInfoScope *>(pComponentData())->Refresh(m_pfLast, this);
	return S_OK;
}

/*
 * OnSelect - Called when any node is selected or deselected.
 *
 * History: a-jsari		9/24/97		Initial version
 */

HRESULT CSystemInfo::OnSelect(LPDATAOBJECT pDataObject, LPARAM lSelection)
{
	HRESULT hr = S_OK;

	hr = HandleStandardVerbs(LOWORD(lSelection), pDataObject); // LOWORD(lSelection) is scope flag

	// It turns out that it's better to handle drawing the contents of a category
	// only on the SHOW message (rather than the SELECT message). This avoids showing
	// data for a category which wasn't fully selected (i.e. right click, then ESC
	// from the context menu).

	return hr;

#if FALSE
	HRESULT hr = S_OK;

	do 
	{
		BOOL fSelect = HIWORD(lSelection);
		BOOL fScope	 = LOWORD(lSelection);

		hr = HandleStandardVerbs(fScope, pDataObject);
		if (FAILED(hr)) break;

		CDataObject * pdoLast = GetInternalFromDataObject(pDataObject);

		// If the folder is being deselected, check to see if it is currently
		// being refreshed. If it is, change the variable so the threaded
		// refresh knows not to update the display.

		if (fScope && !fSelect)
		{
			if (pdoLast->Category() == m_pLastRefreshedFolder)
				m_pLastRefreshedFolder = NULL;
		}

		// We handle it if it's a scope item and is being selected.

		if (fScope && fSelect) 
		{
			// Remember the last selection for OnViewChange.

			ASSERT(pdoLast != NULL);
			ASSERT(pdoLast->Context() == CCT_SCOPE);

			// Remember the last selected Folder.

			m_pfLast = pdoLast->Category();
			m_pLastRefreshedFolder = m_pfLast;
			DisplayFolder(m_pfLast);
			dynamic_cast<CSystemInfoScope *>(pComponentData())->SetSelectedFolder(m_pfLast);
		}
	} while (0);
	return hr;
#endif
}

/*
 * DisplayFolder - Display all result-pane data for the current folder.
 *
 * History:	a-jsari		12/11/97		Initial version
 */
HRESULT CSystemInfo::DisplayFolder(CFolder *pFolder)
{
	HRESULT		hr;

	if (pFolder && pFolder->GetType() == CDataSource::OCX)
	{
		// If the refresh fails (for instance, if there is no OCX installed to show
		// the stream), display a message (unless this is the root node).

		COCXFolder * pOCXFolder = reinterpret_cast<COCXFolder *>(pFolder);

		LPOLESTR lpCLSID;
		if (pOCXFolder && SUCCEEDED(StringFromCLSID(pOCXFolder->m_clsid, &lpCLSID)))
		{
			CString strCLSID(lpCLSID);
			CoTaskMemFree(lpCLSID);

			IUnknown * pUnknown = NULL;
			m_mapCLSIDToIUnknown.Lookup(strCLSID, (void*&) pUnknown);
			if (!pOCXFolder->Refresh(pUnknown) && pFolder->GetParentNode() && pFolder->GetChildNode() == NULL)
				SetRefreshing(lparamNoOCXIndicator);
		}

		return S_OK;
	}

	CSystemInfoScope * pSysScope = dynamic_cast<CSystemInfoScope *>(pComponentData());
	if (pSysScope && pSysScope->InRefresh() && pFolder && pFolder->GetChildNode() == NULL)
	{
		SetRefreshing(lparamRefreshIndicator);
		return S_OK;
	}

	do {
		hr = ClearResultsPane();
		ASSERT(hr == S_OK);
		if (FAILED(hr)) break;

		//	Create this folder's header columns
		hr = SetResultHeaderColumns(pFolder);
		if (FAILED(hr)) break;

		//	Display all values under those column headers.
		hr = EnumerateValues(pFolder);
	} while (FALSE);

	return hr;
}

/*
 * OnShow - Notification when a scope item gets its first selection, or
 *		when the Snap-in is being unloaded.
 *
 * History:	a-jsari		10/2/97		Initial version
 */
HRESULT CSystemInfo::OnShow(LPDATAOBJECT pDataObject, LPARAM fActive, HSCOPEITEM)
{
	HRESULT			hr = S_OK;
	CDataObject	*	pdoSelection = GetInternalFromDataObject(pDataObject);

	if (!fActive) 
	{
		// If the folder is being deselected, check to see if it is currently
		// being refreshed. If it is, change the variable so the threaded
		// refresh knows not to update the display.

		if (pdoSelection->Category() == m_pLastRefreshedFolder)
			m_pLastRefreshedFolder = NULL;

		return hr;
	}

	do 
	{
		ASSERT(pdoSelection != NULL);
		ASSERT(pdoSelection->Context() == CCT_SCOPE);

		CFolder * pfolSelection = pdoSelection->Category();

		m_pLastRefreshedFolder = pfolSelection;
		dynamic_cast<CSystemInfoScope *>(pComponentData())->RefreshAsync(pfolSelection, this);

		// Remember the last selected Folder.

		m_pfLast = pfolSelection;
		dynamic_cast<CSystemInfoScope *>(pComponentData())->SetSelectedFolder(m_pfLast);

		//	Folders may be NULL if Initialize fails.

		if (pfolSelection != NULL)
		{
			hr = DisplayFolder(pfolSelection);
			hr = HandleStandardVerbs((BOOL)fActive, pDataObject);
		}
	} while (0);

	return hr;
}

/*
 * OnUpdateView - Handle the view update event
 *
 * History:	a-jsari		9/1/97		Stub version
 */
HRESULT CSystemInfo::OnUpdateView(LPARAM arg)
{
	HRESULT	hr = S_OK;
	//	arg != 0 is passed by CSystemInfoScope::OpenFile
	if (m_pfLast != NULL && arg == 0) {
		hr = DisplayFolder(m_pfLast);
	}
	//	Do this so that the refresh verb goes away when we load a file.
	SetInitialVerbState(TRUE);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information
//
// Copyright (c) 1998-1999 Microsoft Corporation

#include "stdafx.h"

//jps 09/02/97 - Removed ATL wizard includes
//#ifdef _ATL_STATIC_REGISTRY
//#include <statreg.h>
//#include <statreg.cpp>
//#endif

#ifdef MSINFO_DEBUG_HACK
int	g_HackFindMe	= 0;
#endif // DEBUG_HACK

#include <atlimpl.cpp>

const CLSID CLSID_MSInfo = {0x45ac8c63,0x23e2,0x11d1,{0xa6,0x96,0x00,0xc0,0x4f,0xd5,0x8b,0xc3}};
const CLSID CLSID_About = {0x45ac8c65,0x23e2,0x11d1,{0xa6,0x96,0x00,0xc0,0x4f,0xd5,0x8b,0xc3}};
const CLSID CLSID_Extension = {0x45ac8c64,0x23e2,0x11d1,{0xa6,0x96,0x00,0xc0,0x4f,0xd5,0x8b,0xc3}};

LPCTSTR		cszClsidMSInfoSnapin	= _T("{45ac8c63-23e2-11d1-a696-00c04fd58bc3}");
LPCTSTR		cszClsidAboutMSInfo		= _T("{45ac8c65-23e2-11d1-a696-00c04fd58bc3}");
//	CHECK: Use the same value?
LPCTSTR		cszClsidMSInfoExtension	= _T("{45ac8c64-23e2-11d1-a696-00c04fd58bc3}");
#include "ndmgr_i.c"

// Static NodeType GUID in numeric & string formats.
const GUID	cNodeTypeStatic		= {0x45ac8c66,0x23e2,0x11d1,{0xA6,0x96,0x00,0xC0,0x4F,0xD5,0x8b,0xc3}};
LPCTSTR		cszNodeTypeStatic	= _T("{45ac8c66-23e2-11d1-a696-00c04fd58bc3}");

//	CHECK:	Will we use these?
// Dynamicaly created objects.
const GUID	cNodeTypeDynamic	= {0x0ac69b7a,0xafce,0x11d0,{0xa7,0x9b,0x00,0xc0,0x4f,0xd8,0xd5,0x65}};
LPCTSTR		cszNodeTypeDynamic	= _T("{0ac69b7a-afce-11d0-a79b-00c04fd8d565}");

//
// OBJECT TYPE for result items.
//

//	Result items object type GUID in numeric & string formats.
const GUID	cObjectTypeResultItem	= {0x00c86e52,0xaf90,0x11d0,{0xa7,0x9b,0x00,0xc0,0x4f,0xd8,0xd5,0x65}};
LPCTSTR		cszObjectTypeResultItem = _T("{00c86e52-af90-11d0-a79b-00c04fd8d565}");

//	Program Files 
LPCTSTR		cszWindowsCurrentKey	= _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion");
LPCTSTR		cszCommonFilesValue		= _T("CommonFilesDir");
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\strlist.h ===
// The StringList class, purely a wrapper for CArray<CString>
// History:	a-jsari		10/7/97
//
// Copyright (c) 1998-1999 Microsoft Corporation

#pragma once

#include <afxtempl.h>

/*
 * CStringValues - A place to store string values for value display.
 *
 * History:	a-jsari		10/30/97		Initial version
 */
class CStringValues {
public:
	//	32 should be big enough . . .
	CStringValues(int wSize = 32)					{ SetSize(wSize); }
	CStringValues(const CStringValues &strList)		{ m_arStrings.Copy(strList.m_arStrings); }
	~CStringValues()								{ }

	const CString	&operator[](int iList) const	{ return (m_arStrings.GetData())[iList]; }
	CString			&operator[](int iList)			{ return m_arStrings.ElementAt(iList); }

	void			SetSize(int wSize)				{ m_arStrings.SetSize(wSize); }
private:
	CArray<CString, CString &>		m_arStrings;
};

/*
 * CDwordValues - A place to store unsigned values for value display
 *
 * History:	a-jsari		12/16/97		Initial version
 */
class CDwordValues {
public:
	CDwordValues()								{ }
	CDwordValues(const CDwordValues &dwList)	{ m_arDword.Copy(dwList.m_arDword); }
	~CDwordValues()								{ }

//	const DWORD	&operator[](int iList) const	{ return (m_arDword.GetData())[iList]; }
	DWORD		&operator[](int iList)			{ return m_arDword[iList]; }

	void		SetSize(int wSize)				{ m_arDword.SetSize(wSize); }
private:
	CArray<DWORD, DWORD &>	m_arDword;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently
//
// Copyright (c) 1998-1999 Microsoft Corporation

#if !defined(MSINFO_STDAFX_H)
#define MSINFO_STDAFX_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef STRICT
#define STRICT
#endif

#include <afxwin.h>
#include <afxdisp.h>

//	jps 09/02/97 - This will be 0x0500.
//	#define _WIN32_WINNT 0x0400

//	jps 09/02/97 - The sample doesn't define this
//  #define _ATL_APARTMENT_THREADED


#include <atlbase.h>

#ifndef ATL_NO_NAMESPACE
using namespace ATL;
#endif

//	MMC requires unicode DLL's.
#ifndef _UNICODE
#define _UNICODE
#endif

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include "consts.h"

//-----------------------------------------------------------------------------
// This class is used to encapsulate the instrumentation for the snap-in. We
// make this a class so a single instance can be created, and the file closed
// during the destructor.
//-----------------------------------------------------------------------------

class CMSInfoLog
{
public:
	enum { BASIC = 0x01, TOOL = 0x02, MENU = 0x04, CATEGORY = 0x08, WMI = 0x10 };

public:
	CMSInfoLog();
	~CMSInfoLog();

	BOOL IsLogging() { return m_fLoggingEnabled; };
	BOOL IsLogging(int iFlag) { return (m_fLoggingEnabled && ((iFlag & m_iLoggingMask) != 0)); };
	BOOL WriteLog(int iType, const CString & strMessage, BOOL fContinuation = FALSE);
	BOOL WriteLog(int iType, const CString & strFormat, const CString & strReplace1);
	
private:
	BOOL OpenLogFile();
	void ReadLoggingStatus();
	BOOL WriteLogInternal(const CString & strMessage);
	void WriteSpaces(DWORD dwCount);

private:
	CFile *	m_pLogFile;
	CString	m_strFilename;
	BOOL	m_fLoggingEnabled;
	int		m_iLoggingMask;
	DWORD	m_dwMaxFileSize;
	CString m_strEndMarker;
	BOOL	m_fTimestamp;
};

extern CMSInfoLog msiLog;

template<class TYPE>
inline void SAFE_RELEASE(TYPE*& pObj)
{
    if (pObj != NULL) 
    { 
        pObj->Release(); 
        pObj = NULL; 
    } 
    else 
    { 
        TRACE(_T("Release called on NULL interface ptr\n")); 
    }
}

#define OLESTR_FROM_CSTRING(cstr)	\
	(T2OLE(const_cast<LPTSTR>((LPCTSTR)(cstr))))
#define WSTR_FROM_CSTRING(cstr)		\
	(const_cast<LPWSTR>(T2CW(cstr)))


#ifdef _DEBUG
//#define MSINFO_DEBUG_HACK
#endif // _DEBUG

// Taken from the Example Snap-in.
// Debug instance counter
#ifdef _DEBUG
	inline void DbgInstanceRemaining(char * pszClassName, int cInstRem)
	{
		char buf[100];
		wsprintfA(buf, "%s has %d instances left over.", pszClassName, cInstRem);
		::MessageBoxA(NULL, buf, "MSInfo Snapin: Memory Leak!!!", MB_OK);
	}
    #define DEBUG_DECLARE_INSTANCE_COUNTER(cls)      extern int s_cInst_##cls = 0;
    #define DEBUG_INCREMENT_INSTANCE_COUNTER(cls)    ++(s_cInst_##cls);
    #define DEBUG_DECREMENT_INSTANCE_COUNTER(cls)    --(s_cInst_##cls);
    #define DEBUG_VERIFY_INSTANCE_COUNT(cls)    \
        extern int s_cInst_##cls; \
        if (s_cInst_##cls) DbgInstanceRemaining(#cls, s_cInst_##cls);

#ifdef MSINFO_DEBUG_HACK
	extern int g_HackFindMe;
	//	Temporary fix.
#undef ASSERT
#define ASSERT(f) \
	do \
	{ \
	if (!(g_HackFindMe && (f)) && AfxAssertFailedLine(THIS_FILE, __LINE__)) \
		g_HackFindMe = 1;	\
		AfxDebugBreak(); \
	} while (0)

#endif // DEBUG_HACK

#else
    #define DEBUG_DECLARE_INSTANCE_COUNTER(cls)   
    #define DEBUG_INCREMENT_INSTANCE_COUNTER(cls)    
    #define DEBUG_DECREMENT_INSTANCE_COUNTER(cls)    
    #define DEBUG_VERIFY_INSTANCE_COUNT(cls)    
#endif

	//		Unicode definitions
#ifdef _UNICODE
#define atoi(lpTStr)	_wtoi(lpTStr)
#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(MSINFO_STDAFX_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\taskpad.cpp ===
/* Taskpad.cpp
 *
 * Code to handle the taskpad interface.
 * 
 * Copyright (c) 1998-1999 Microsoft Corporation
 */

#include "StdAfx.h"
#include "DataObj.h"
#include "SysInfo.h"
#include "Taskpad.h"
#include <atlbase.h>

#ifndef IDS_TASK_TITLE
#include "resrc1.h"
#endif

static inline void		GetMSInfoResourceName(LPOLESTR &, UINT);
static inline void		GetMMCResourceName(LPOLESTR &, UINT);
static inline void		LoadNewString(LPOLESTR &, UINT);
static inline LPOLESTR	CoTaskStrDup(const CString &);

/*
 * GetResultViewType - Set the Result view to the default.
 *
 * History:	a-jsari		9/1/97		Initial version
 */
STDMETHODIMP CSystemInfo::GetResultViewType(MMC_COOKIE cookie, LPOLESTR *ppViewType, long *pViewOptions)
{
#ifdef _DEBUG
	TRACE(_T("CSystemInfo::GetResultViewType(%lx, ViewType, ViewOptions)\n"), cookie);
#endif
	ASSERT(ppViewType != NULL);
	ASSERT(pViewOptions != NULL);

	if (ppViewType == NULL || pViewOptions == NULL) return E_POINTER;

	//	Remove the default list menu items.
	*pViewOptions = MMC_VIEW_OPTIONS_NOLISTVIEWS;

	// Remove our taskpad view for now...
	//
	//	if (cookie == ((CSystemInfoScope *)pComponentData())->RootCookie()) {
	//		GetMMCResourceName(*ppViewType, IDS_TASKPAD_DHTML);
	//		return S_OK;
	//	}


	CViewObject	* pDataCategory = reinterpret_cast<CViewObject *>(cookie);
	if (pDataCategory)
	{
		CFolder * pFolder = pDataCategory->Category();
		if (pFolder && pFolder->GetType() == CDataSource::OCX)
		{
			// Check to see if the OCX is present.

			HKEY	hkey;
			CString strCLSID;

			reinterpret_cast<COCXFolder *>(pFolder)->GetCLSIDString(strCLSID);
			strCLSID = CString(_T("CLSID\\")) + strCLSID;
			if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, strCLSID, 0, KEY_QUERY_VALUE, &hkey))
			{
				RegCloseKey(hkey);
				if ((reinterpret_cast<COCXFolder *>(pFolder))->GetCLSID(ppViewType))
					return S_OK;
			}
		}
	}

	return S_FALSE;
}

//	IExtendTaskpad interface in CSystemInfo
/*
 * TaskNotify - The notify function for when the user selects a taskpad item.
 *
 * History:	a-jsari		2/2/98		Initial version
 */
STDMETHODIMP CSystemInfo::TaskNotify(LPDATAOBJECT, VARIANT *pvarg, VARIANT *)
{
//	ASSERT(lpDataObject != NULL);
	ASSERT(pvarg != NULL);
//	ASSERT(pvparam != NULL);

	if (pvarg->vt == VT_I4) {
		CString strPath;

		AFX_MANAGE_STATE(::AfxGetStaticModuleState());
		switch(pvarg->lVal) {
		case CTaskEnumPrimary::IDM_DISPLAY_BASIC:
			VERIFY(strPath.LoadString(IDS_SUMMARY_PATH));
			if (dynamic_cast<CSystemInfoScope *>(pComponentData())->SelectItem(strPath))
				dynamic_cast<CSystemInfoScope *>(pComponentData())->SetView(BASIC);
			break;
		case CTaskEnumPrimary::IDM_DISPLAY_ADVANCED:
			VERIFY(strPath.LoadString(IDS_SUMMARY_PATH));
			if (dynamic_cast<CSystemInfoScope *>(pComponentData())->SelectItem(strPath))
				dynamic_cast<CSystemInfoScope *>(pComponentData())->SetView(ADVANCED);
			break;
		case CTaskEnumPrimary::IDM_TASK_SAVE_FILE:
			dynamic_cast<CSystemInfoScope *>(pComponentData())->SaveFile();
			break;
		case CTaskEnumPrimary::IDM_TASK_PRINT_REPORT:
			OnPrint();
			break;
		case CTaskEnumPrimary::IDM_PROBLEM_DEVICES:
			VERIFY(strPath.LoadString(IDS_PROBLEM_DEVICES_PATH));
			dynamic_cast<CSystemInfoScope *>(pComponentData())->SelectItem(strPath);
			break;
		case CTaskEnumExtension::IDM_MSINFO32:
			VERIFY(strPath.LoadString(IDS_INITIAL_PATH));
			dynamic_cast<CSystemInfoScope *>(pComponentData())->SelectItem(strPath);
			break;
		default:
			ASSERT(FALSE);
			break;
		}
	}

	return S_OK;
}

/*
 * EnumTasks - Enumerate our available tasks.
 *
 * History:	a-jsari		2/2/98		Initial version
 */
STDMETHODIMP CSystemInfo::EnumTasks(LPDATAOBJECT, LPOLESTR szGroup, LPENUMTASK *ppEnumTask)
{
	ASSERT(ppEnumTask != NULL);

	CString strTaskpadName;

	AFX_MANAGE_STATE(::AfxGetStaticModuleState());
	VERIFY(strTaskpadName.LoadString(IDS_ROOT_TASKPAD));
	if (!strTaskpadName.Compare(szGroup)) {
		CComObject<CTaskEnumPrimary>	*pEnumTask;
		CComObject<CTaskEnumPrimary>::CreateInstance(&pEnumTask);

		ASSERT(pEnumTask != NULL);
		if (pEnumTask == NULL) ::AfxThrowMemoryException();

		pEnumTask->AddRef();
		HRESULT hr = pEnumTask->QueryInterface(IID_IEnumTASK, (void **)ppEnumTask);
		ASSERT(hr == S_OK);
		pEnumTask->Release();
	} else {
		CComObject<CTaskEnumExtension>		*pEnumTask;
		CComObject<CTaskEnumExtension>::CreateInstance(&pEnumTask);

		ASSERT(pEnumTask != NULL);
		if (pEnumTask == NULL) ::AfxThrowMemoryException();

		pEnumTask->AddRef();
		HRESULT hr = pEnumTask->QueryInterface(IID_IEnumTASK, (void **)ppEnumTask);
		ASSERT(hr == S_OK);
		pEnumTask->Release();
	}
	return S_OK;
}

/*
 * GetListPadInfo - Return information about the list view version of the task pad.
 *
 * History:	a-jsari		3/24/98		Initial version
 */
STDMETHODIMP CSystemInfo::GetListPadInfo(LPOLESTR, MMC_LISTPAD_INFO *lpListPadInfo)
{
	const int LISTPAD_COMMAND = 1234;
	//	We don't distinguish between which way we're loaded for the data we display.
	//	If we need to, switch off of the first LPOLESTR parameter.  Our taskpad group
	//	is IDS_ROOT_TASKPAD.

	//	Use our main title as the same title for the List view.
	GetTitle((BSTR) 0, &lpListPadInfo->szTitle);
	LoadNewString(lpListPadInfo->szButtonText, IDS_LISTPAD_BUTTON);
	lpListPadInfo->nCommandID = LISTPAD_COMMAND;
	return S_OK;
}

/* 
 * GetTitle - Return in pszTitle a pointer to the title for the taskpad.
 *
 * History:	a-jsari		2/2/98		Initial version
 */
STDMETHODIMP CSystemInfo::GetTitle(BSTR, LPOLESTR *pszTitle)
{
	ASSERT(pszTitle != NULL);

	LoadNewString(*pszTitle, IDS_TASK_TITLE);

	return S_OK;
}

/* 
 * GetBackground - Return the background resource.
 *
 * History:	a-jsari		2/2/98		Initial version
 */
STDMETHODIMP CSystemInfo::GetBackground(BSTR, MMC_TASK_DISPLAY_OBJECT *)
{
//	ASSERT(pszBackground != NULL);

//	GetMSInfoResourceName(*pszBackground, IDS_BACKGROUND_RESPATH);

	return S_OK;
}

STDMETHODIMP CSystemInfo::GetDescriptiveText(BSTR, LPOLESTR *)
{
	return S_OK;
}

#if 0
/*
 * OnListPad - Listpad notification.  I don't expect we will receive this
 *		notification unless we implement listpads.
 *
 * History:	a-jsari		3/24/98		Initial version
 */
STDMETHODIMP CSystemInfo::OnListPad()
{
	return E_NOTIMPL;
}
#endif

/*
 * Next - Get the next task.  Since we have only one, this function is quite
 *		small.
 *
 * History:	a-jsari		3/4/98		Initial version
 */
STDMETHODIMP CTaskEnumBase::Next(ULONG celt, MMC_TASK *rgelt, ULONG *pceltFetched)
{
	ASSERT(rgelt != NULL);
	ASSERT(!IsBadWritePtr(rgelt, celt * sizeof(MMC_TASK)));
	ASSERT(pceltFetched != NULL);

	ULONG i;
	//	According to the documentation, celt will always be 1.
	::memset(rgelt, 0, celt * sizeof(MMC_TASK));
	try {
		for (i = 0 ; i < celt ; ++i, ++m_iTask, ++rgelt) {
			//	Increment our task value and test to see if they are fetching an invalid task.
			if (m_iTask >= m_cTasks) {
				*pceltFetched = i;
				return S_FALSE;
			}

//			GetMSInfoResourceName(rgelt->szMouseOverBitmap, MouseOverResourceID());
//			GetMSInfoResourceName(rgelt->szMouseOffBitmap, FirstMouseOffResourceID() + m_iTask);

			//	The resource IDs for these items must be sequential.
			LoadNewString(rgelt->szText, FirstTaskTextResourceID() + m_iTask);
			LoadNewString(rgelt->szHelpString, FirstTaskHelpResourceID() + m_iTask);

			rgelt->eActionType = MMC_ACTION_ID;
			//	The Command IDs are in sorted order.
			rgelt->nCommandID = FirstCommandID() + m_iTask;
		}
	}
	catch (CMemoryException *) {
//		if (rgelt->szMouseOverBitmap)
//			::CoTaskMemFree(rgelt->szMouseOverBitmap);
//		if (rgelt->szMouseOffBitmap)
//			::CoTaskMemFree(rgelt->szMouseOffBitmap);
		if (rgelt->szText)
			::CoTaskMemFree(rgelt->szText);
		if (rgelt->szHelpString)
			::CoTaskMemFree(rgelt->szHelpString);
		*pceltFetched = i;
		return S_FALSE;
	}
	return S_OK;
}

/*
 * Skip - Skip the next task.  Will reportedly never be called.
 *
 * History:	a-jsari		3/4/98		Initial version
 */
STDMETHODIMP CTaskEnumBase::Skip(ULONG celt)
{
	m_iTask += celt;
	if (m_iTask >= m_cTasks) {
		m_iTask = m_cTasks;
		return S_FALSE;
	}
	return S_OK;
}

/*
 * Reset - Reset to the first task.
 *
 * History:	a-jsari		3/4/98		Initial version.
 */
STDMETHODIMP CTaskEnumBase::Reset()
{
	m_iTask = 0;
	return S_OK;
}

/* 
 * Clone - Clone this task.  Will reportedly never be called.
 *
 * History:	a-jsari		3/4/98		Initial version
 */
STDMETHODIMP CTaskEnumBase::Clone(IEnumTASK **)
{
	ASSERT(FALSE);
	return E_NOTIMPL;
}

/*
 * CoTaskStrDup - Copy the CString passed in as a LPOLESTR, allocating
 *		the memory to store the string using CoTaskMemAlloc.
 *
 * History:	a-jsari		3/4/98		Initial version
 */
static inline LPOLESTR CoTaskStrDup(const CString &strCopy)
{
	USES_CONVERSION;
	LPOLESTR	szDuplicate = (LPOLESTR) ::CoTaskMemAlloc((strCopy.GetLength() + 1)
		* sizeof(OLECHAR));
	ASSERT(szDuplicate != NULL);
	if (szDuplicate != NULL) {
		::lstrcpy(szDuplicate, T2CW((LPCTSTR)strCopy));
	}
	return szDuplicate;
}

/*
 * GetMSInfoResourceName - Get the initial path to a resource in the currently
 *		loaded DLL.
 *
 * History:	a-jsari		3/4/98		Initial version.
 */
static inline void GetMSInfoResourceName(LPOLESTR &szNewString, UINT nResource)
{
	AFX_MANAGE_STATE(::AfxGetStaticModuleState());

	OLECHAR		szExePath[MAX_PATH];

	CString	strResource;
	strResource = _T("res://");
	HINSTANCE hInstance = ::AfxGetInstanceHandle();
	ASSERT(hInstance != NULL);
	DWORD dwCount = ::GetModuleFileName(hInstance, szExePath, MAX_PATH);
	ASSERT(dwCount != 0);

	strResource += szExePath;

	CString	strResPath;

	VERIFY(strResPath.LoadString(nResource));
	strResource += strResPath;

	szNewString = CoTaskStrDup(strResource);
	if (szNewString == NULL) ::AfxThrowMemoryException();
}

/*
 * GetMMCResourceName - Get the initial path to a resource in MMC.EXE.
 *
 * History:	a-jsari		3/5/98		Initial version
 */
static inline void GetMMCResourceName(LPOLESTR &szNewString, UINT nResource)
{
	AFX_MANAGE_STATE(::AfxGetStaticModuleState());
	OLECHAR		szExePath[MAX_PATH];

	CString	strResource;
	VERIFY(strResource.LoadString(IDS_MMCEXE));
	HINSTANCE hInstance = ::GetModuleHandle(strResource);
	ASSERT(hInstance != NULL);
	DWORD dwCount = ::GetModuleFileName(hInstance, szExePath, MAX_PATH);
	ASSERT(dwCount != 0);

	strResource = _T("res://");
	strResource += szExePath;

	CString	strResPath;

	VERIFY(strResPath.LoadString(nResource));
	strResource += strResPath;

	szNewString = CoTaskStrDup(strResource);
	if (szNewString == NULL) ::AfxThrowMemoryException();
}

/*
 * LoadNewString - Load the string at nResource from the Resources, then
 *		allocate memory for the pointer and copy that string in.
 *
 * History:	a-jsari		3/4/98		Initial version.
 */
static inline void LoadNewString(LPOLESTR &szNewString, UINT nResource)
{
	AFX_MANAGE_STATE(::AfxGetStaticModuleState());

	CString	strResource;
	VERIFY(strResource.LoadString(nResource));

	szNewString = CoTaskStrDup(strResource);
	if (szNewString == NULL) ::AfxThrowMemoryException();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\sysinfo.h ===
// SysInfo.h : the main OLE interface class to MSInfo.
//
// Copyright (c) 1998-1999 Microsoft Corporation

#pragma once		// MSINFO_SYSINFO_H

//	This hack is required because we may be building in an environment
//	which doesn't have a late enough version of rpcndr.h
#if		__RPCNDR_H_VERSION__ < 440
#define __RPCNDR_H_VERSION__ 440
#define MIDL_INTERFACE(x)	interface
#endif

#ifndef __mmc_h__
#include <mmc.h>		//	..\..\..\public\sdk\inc
#endif // __mmc_h__

class CSystemInfoScope;
class CDataCategory;

#include "StdAfx.h"
#include "CompData.h"
#include "Toolset.h"

/*
 * class CSystemInfo - The object that handles the result item User Interface
 *		in MMC.
 */
extern DWORD WINAPI ThreadRefresh(void * pArg);
class CThreadingRefresh;
class CSystemInfo :
	public IComponent,
	public IExtendContextMenu,
	public IExtendControlbar,
	public IExtendPropertySheet,
	public IExtendTaskPad,
	public IResultDataCompare,
	public CComObjectRoot
{
BEGIN_COM_MAP(CSystemInfo)
	COM_INTERFACE_ENTRY(IComponent)
	COM_INTERFACE_ENTRY(IExtendContextMenu)
	COM_INTERFACE_ENTRY(IExtendControlbar)
	COM_INTERFACE_ENTRY(IExtendPropertySheet)
	COM_INTERFACE_ENTRY(IExtendTaskPad)
	COM_INTERFACE_ENTRY(IResultDataCompare)
END_COM_MAP()

	friend DWORD WINAPI ThreadRefresh(void * pArg);
	friend class CThreadingRefresh;

public:
	CSystemInfo();
	~CSystemInfo();

	//	IComponent interface methods
public:
	STDMETHOD(Initialize)(LPCONSOLE lpConsole);
	STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
	STDMETHOD(Destroy)(MMC_COOKIE cookie);
	STDMETHOD(GetResultViewType)(MMC_COOKIE cookie, LPOLESTR *ppViewType, long *pViewOptions);
	STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT *ppDataObject);
	STDMETHOD(GetDisplayInfo)(LPRESULTDATAITEM pResult);
	STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);


//	Public access functions
public:
	HRESULT			SetIComponentData(CSystemInfoScope *pData);

	//	IExtendContextMenu interface members
public:
	STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject, LPCONTEXTMENUCALLBACK pCallback,
				long *pInsertionAllowed);
	STDMETHOD(Command)(long lCommandID, LPDATAOBJECT pDataObject);

	//	IExtendControlbar interface members
public:
	STDMETHOD(SetControlbar)(LPCONTROLBAR	pControlbar);
	STDMETHOD(ControlbarNotify)(MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);

	//	IExtendPropertySheet interface members
public:
	STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider, LONG_PTR handle,
				LPDATAOBJECT lpDataObject);
	STDMETHOD(QueryPagesFor)(LPDATAOBJECT lpDataObject);

	//	IResultDataCompare interface members
public:
	STDMETHOD(Compare)(LRESULT, MMC_COOKIE cookieA, MMC_COOKIE cookieB, int *pnResult);

	//	IExtendTaskPad interface members
public:
	STDMETHOD(TaskNotify)(LPDATAOBJECT lpDataObject, VARIANT *pvarg, VARIANT *pvparam);
	STDMETHOD(EnumTasks)(LPDATAOBJECT lpDataObject, LPOLESTR szTask, LPENUMTASK *ppEnumTask);
	STDMETHOD(GetListPadInfo)(LPOLESTR szGroup, MMC_LISTPAD_INFO *lpListPadInfo);
	STDMETHOD(GetTitle)(BSTR szGroup, LPOLESTR *pszTitle);
	STDMETHOD(GetBackground)(BSTR szGroup, MMC_TASK_DISPLAY_OBJECT * pTDO);
	STDMETHOD(GetDescriptiveText)(BSTR szGroup, LPOLESTR *pszDescriptiveText);

//	Private encapsulation methods.
private:
#if 0
	//	For if we add multi-select data objects.
	HRESULT			QueryMultiSelectDataObject(long cookie, DATA_OBJECT_TYPES type,
				LPDATAOBJECT *ppDataObject);
#endif
#if 0
	//	For if we pre-load resources.
	void		LoadResources();
#endif
	//	AddToTopMenu is a convenience wrapper for AddToMenu
	HRESULT		AddToTopMenu(LPCONTEXTMENUCALLBACK lpCallback, long lNameResource,
			long lStatusResource, long lCommandID)
	{
		return AddToMenu(lpCallback, lNameResource, lStatusResource, lCommandID,
				CCM_INSERTIONPOINTID_PRIMARY_TOP);
	}
	//	AddToTaskMenu is a convenience wrapper for AddToMenu
	HRESULT		AddToTaskMenu(LPCONTEXTMENUCALLBACK lpCallback, long lNameResource,
			long lStatusResource, long lCommandID)
	{
		return AddToMenu(lpCallback, lNameResource, lStatusResource, lCommandID,
				CCM_INSERTIONPOINTID_PRIMARY_TASK);
	}
	HRESULT		AddToMenu(LPCONTEXTMENUCALLBACK lpCallback, long lNameResource,
			long lStatusResource, long lCommandID, long lInsertionPoint);
	HRESULT		EnableToolbar(BOOL fEnable);
	HRESULT		EnableSupportTools(BOOL fEnable);
	HRESULT		AddToolbarButtons(LPTOOLBAR pToolbar);

//	Event helper functions (found in REvents.cpp)
private:
	HRESULT		ClearResultsPane();
	HRESULT		EnumerateValues(CFolder *pfolCategory);
	HRESULT		HandleStandardVerbs(BOOL fScope, LPDATAOBJECT lpDataObject);
	void		SetInitialVerbState(BOOL fScope);
	HRESULT		SetResultHeaderColumns(CFolder *pfolCategory);

//	Notification events (found in REvents.cpp)
private:
	HRESULT		DisplayFolder(CFolder *pFolder);
	HRESULT		OnActivate(LPDATAOBJECT pDataObject, LPARAM fActive);
	HRESULT		OnAddImages(LPDATAOBJECT pDataObject, LPIMAGELIST pImageList, HSCOPEITEM hSelectedItem);
	HRESULT		OnButtonClick(LPDATAOBJECT pDataObject, LPARAM idButton);
	HRESULT		OnContextHelp(LPDATAOBJECT pDataObject);
	HRESULT		OnControlbarSelect(BOOL fDeselectAll, LPARAM lSelection, LPDATAOBJECT pDataObject);
	HRESULT		OnDoubleClick(LPDATAOBJECT pDataObject);
	HRESULT		OnListPad();
	HRESULT		OnMenuButtonClick(LPDATAOBJECT *pDataObject, LPMENUBUTTONDATA pMenuButton);
	HRESULT		OnPrint();
	HRESULT		OnProperties(LPDATAOBJECT pDataObject);
	HRESULT		OnPropertyChange(LPDATAOBJECT pDataObject);
	HRESULT		OnRefresh(LPDATAOBJECT pDataObject);
	HRESULT		OnSelect(LPDATAOBJECT pDataObject, LPARAM lSelection);
	HRESULT		OnShow(LPDATAOBJECT pDataObject, LPARAM fSelect, HSCOPEITEM hSelectedItem);
	HRESULT		OnSnapinHelp(LPDATAOBJECT lpDataObject);
	HRESULT		OnUpdateView(LPARAM arg);

//	Member access functions.
private:
	LPCOMPONENTDATA		pComponentData() const		{ return m_pComponentData; }
	LPEXTENDCONTEXTMENU	pExtendContextMenu() const
	{
		LPEXTENDCONTEXTMENU pInterface; 
		HRESULT hr = m_pComponentData->QueryInterface(IID_IExtendContextMenu, (void **)&pInterface);
		ASSERT(hr == S_OK);
		return pInterface;
	}
	LPEXTENDPROPERTYSHEET	pExtendPropertySheet() const
	{
		LPEXTENDPROPERTYSHEET	pInterface;

		HRESULT hr = m_pComponentData->QueryInterface(IID_IExtendPropertySheet,
			(void **) &pInterface);
		ASSERT(hr == S_OK);
		return pInterface;
	}
	LPCONSOLE			pConsole() const			{ return m_pConsole; }
	LPCONSOLEVERB		pConsoleVerb() const		{ return m_pConsoleVerb; }
	LPTOOLBAR			ptbItems() const			{ return m_pToolbar; }
	LPMENUBUTTON		pmnbSupportTools() const	{ return m_pMenuButton; }
	LPRESULTDATA		pResult() const				{ return m_pResult; }
	LPCONTROLBAR		pControlbar() const			{ return m_pControlbar; }
	LPHEADERCTRL		pHeaderCtrl() const			{ return m_pHeader; }

//	Private enumeration types.
private:
	//	The IDs for the toolbar buttons so that our callback can switch off
	//	of the ID to process the right command based on the Toolbar selection.

	// Order is relevant here, as are the first and last elements in the
	//	enum.  If any of these criteria change, see the notes in
	//  AddToolbarButtons.
	enum ToolbarButtonID {
		IDM_TBB_SAVE = 1,
		IDM_TBB_OPEN = IDM_TBB_SAVE + 1,
		IDM_TBB_REPORT = IDM_TBB_OPEN + 1,
#if 0
		IDM_TBB_PRINT = IDM_TBB_REPORT + 1,
#endif
		IDM_TBB_FIND = IDM_TBB_REPORT + 1
	};

	enum { IDM_SUPPORT = 22222, IDM_TOOL1 = IDM_SUPPORT + 1 };
//	Private data members.
private:

//	CUSTOM_VIEW_ID		m_CustomViewID;

#ifdef _DEBUG
	BOOL				m_bInitializedC;
#endif
	//	Our snap-in's interface.
	LPCOMPONENTDATA		m_pComponentData;	//	Pointer to IComponentData interface
	//	MMC queried interfaces
	LPCONSOLE			m_pConsole;			//	Pointer to IConsole interface
	LPCONTROLBAR		m_pControlbar;		//	Pointer to IControlbar interface.
	LPHEADERCTRL		m_pHeader;			//	Pointer to IHeaderCtrl interface.
	LPRESULTDATA		m_pResult;			//	Pointer to IResultData interface.
	LPIMAGELIST			m_pImageResult;		//	Pointer to IImageList interface
	LPCONSOLEVERB		m_pConsoleVerb;		//	Pointer to IConsoleVerb interface
	LPTOOLBAR			m_pToolbar;			//	Pointer to IToolbar interface	
	LPMENUBUTTON		m_pMenuButton;		//	Pointer to IMenuButton interface
	LPDISPLAYHELP		m_pDisplayHelp;
	LPCONSOLE2			m_pConsole2;

	//	A pointer to the last folder in which we selected any result-pane items.
	CFolder				*m_pfLast;
	CFolder *			m_pLastRefreshedFolder;

	//	Internal menu item for the Support Tools menu
	CMenu				m_mnuSupport;
	//	Internal list of support tools for the Support Tools MenuButton
	CToolList			*m_plistTools;

	//	Internal list of CViewObject items 
	CViewObjectList		m_lstView;

	CString			m_strRefreshMessage;	// loaded from resource in Initialize()
	CString			m_strNoOCXMessage;

public:
	const LPARAM	lparamRefreshIndicator;	// value assigned in CSystemInfo contstructor
	const LPARAM	lparamNoOCXIndicator;	// value assigned in CSystemInfo contstructor

	void SetStatusText(LPCTSTR szText);
	void SetStatusText(UINT nResID);
	void SelectLine(int iLine);
	void SetRefreshing(LPARAM lparamMessage);

	CMapStringToPtr		m_mapCLSIDToIUnknown;
};	// CSystemInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\taskpad.h ===
/* Taskpad.h
 *
 * Define the CTaskEnum class interface.
 *
 * Copyright (c) 1998-1999 Microsoft Corporation
 */

#include <atlcom.h>
#ifndef __mmc_h__
#include <mmc.h>	// ..\..\..\public\sdk\inc
#endif

#ifndef IDS_TASK_TITLE
#include "resrc1.h"
#endif

/*
 * CTaskEnumBase - a class to handle our taskpad functionality.
 *
 * History:	a-jsari		3/4/98		Initial version.
 */
class CTaskEnumBase:
	public IEnumTASK,
	public CComObjectRoot
{
BEGIN_COM_MAP(CTaskEnumBase)
	COM_INTERFACE_ENTRY(IEnumTASK)
END_COM_MAP()

public:
	~CTaskEnumBase()				{ }

	//	IEnumTask interface
public:
	STDMETHOD(Next)(ULONG celt, MMC_TASK *rgelt, ULONG *pceltFetched);
	STDMETHOD(Skip)(ULONG celt);
	STDMETHOD(Reset)();
	STDMETHOD(Clone)(IEnumTASK **ppenum);

protected:
	CTaskEnumBase(unsigned cTasks)	: m_iTask(0), m_cTasks(cTasks)	{ }
	virtual long		FirstCommandID() = 0;
	virtual unsigned	FirstTaskTextResourceID() = 0;
	virtual unsigned	FirstTaskHelpResourceID() = 0;
	virtual unsigned	FirstMouseOffResourceID() = 0;
	unsigned			MouseOverResourceID()	{ return IDS_MOUSEOVER_RESPATH; }

private:
	const int		m_cTasks;
	int				m_iTask;
};

/*
 * CTaskEnumPrimary - The CTaskEnum for our internal taskpad.
 *
 * History:	a-jsari		3/4/98		Initial version.
 */
class CTaskEnumPrimary : public CTaskEnumBase {
friend class CSystemInfo;

public:
	CTaskEnumPrimary() : CTaskEnumBase(5)	{ }
	~CTaskEnumPrimary()						{ }

	long		FirstCommandID()			{ return IDM_DISPLAY_BASIC; }
	unsigned	FirstTaskTextResourceID()	{ return IDS_ORDERED_TASKTEXT0; }
	unsigned	FirstTaskHelpResourceID()	{ return IDS_ORDERED_TASKHELP0; }
	unsigned	FirstMouseOffResourceID()	{ return IDS_ORDERED_TASKBUTTON0; }

private:
	enum PrimaryCommandIDs
	{	IDM_DISPLAY_BASIC		= 556,
		IDM_DISPLAY_ADVANCED	= IDM_DISPLAY_BASIC + 1,
		IDM_TASK_SAVE_FILE		= IDM_DISPLAY_ADVANCED + 1,
		IDM_TASK_PRINT_REPORT	= IDM_TASK_SAVE_FILE + 1,
		IDM_PROBLEM_DEVICES		= IDM_TASK_PRINT_REPORT + 1
	};
};

/*
 * CTaskEnumExtension - The CTaskEnum we use to extend Computer
 *		Management.  Computer management only requires a navigation task
 *		from us.
 *
 * History:	a-jsari		3/4/98		Initial version.
 */
class CTaskEnumExtension : public CTaskEnumBase {
friend class CSystemInfo;

public:
	CTaskEnumExtension() : CTaskEnumBase(1)	{ }
	~CTaskEnumExtension()					{ }

	long		FirstCommandID()			{ return IDM_MSINFO32; }
	unsigned	FirstTaskTextResourceID()	{ return IDS_NAVIGATION_TASKTEXT; }
	unsigned	FirstTaskHelpResourceID()	{ return IDS_NAVIGATION_TASKHELP; }
	unsigned	FirstMouseOffResourceID()	{ return IDS_NAVIGATION_TASKBUTTON; }
private:
	enum ExtensionCommandIDs	{ IDM_MSINFO32 = 555 };
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\sysinfo.cpp ===
// SysInfo.cpp : Objects for the main OLE interface to the snap-in result pane.
//
// Copyright (c) 1998-1999 Microsoft Corporation

#include "StdAfx.h"

//	This hack is required because we may be building in an environment
//	which doesn't have a late enough version of rpcndr.h
#if		__RPCNDR_H_VERSION__ < 440
#define __RPCNDR_H_VERSION__ 440
#define MIDL_INTERFACE(x)	interface
#endif

#ifndef __mmc_h__
#include <mmc.h>		//	..\..\..\public\sdk\inc
#endif

#include "DataObj.h"
#include "SysInfo.h"
#include "ViewObj.h"
#include "CompData.h"
#include "Toolset.h"

#ifndef IDS_TASK_TITLE
#include "Resource.h"
#endif

/*
 * CSystemInfo - Constructor just NULLs all pointers.
 *
 * History: a-jsari		9/1/97		Initial version
 */

CSystemInfo::CSystemInfo()
:m_pComponentData(NULL), m_pConsole(NULL), m_pToolbar(NULL), m_pMenuButton(NULL),
m_pControlbar(NULL), m_pHeader(NULL), m_pResult(NULL), m_pImageResult(NULL),
m_pConsoleVerb(NULL), m_pfLast(NULL), m_plistTools(NULL), m_pDisplayHelp(NULL),
m_pConsole2(NULL), m_pLastRefreshedFolder(NULL), lparamRefreshIndicator(0xFFFFFFFE), lparamNoOCXIndicator(0xFFFFFFFD)
{
}

/*
 * ~CSystemInfo - Destructor just makes sure all the pointers have been
 *		properly released.
 *
 * History:	a-jsari		9/1/97		Initial version
 */
CSystemInfo::~CSystemInfo()
{
	ASSERT(m_pToolbar == NULL);
	ASSERT(m_pMenuButton == NULL);
	ASSERT(m_pConsole == NULL);
	ASSERT(m_pConsoleVerb == NULL);
	ASSERT(m_pComponentData == NULL);
	ASSERT(m_pControlbar == NULL);
	ASSERT(m_pResult == NULL);
	ASSERT(m_pImageResult == NULL);
	ASSERT(m_pHeader == NULL);
	ASSERT(m_pDisplayHelp == NULL);

	if (m_plistTools)
	{
		delete m_plistTools;
		m_plistTools = NULL;
	}
}

/*
 * Initialize - Get all the required Interface pointers from pConsole.
 *
 * History:	a-jsari		9/1/97		Initial version
 */
STDMETHODIMP CSystemInfo::Initialize(LPCONSOLE lpConsole)
{
	TRACE(_T("CSystemInfo::Initialize\n"));
	ASSERT(lpConsole != NULL);
#ifdef _DEBUG
	m_bInitializedC = true;
#endif	// _DEBUG

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	m_pConsole = lpConsole;
	m_pConsole->AddRef();

#if 0
	LoadResources();
#endif

	m_strRefreshMessage.LoadString(IDS_REFRESHING_MSG);
	m_strNoOCXMessage = CString(_T("")); // if we could add a string, this would be "OCX not available"

	HRESULT hr = m_pConsole->QueryInterface(IID_IHeaderCtrl,
				reinterpret_cast<void **>(&m_pHeader));
	ASSERT(hr == S_OK);

	if (SUCCEEDED(hr)) {
		hr = m_pConsole->SetHeader(m_pHeader);
		ASSERT(hr == S_OK);
	}

	hr = m_pConsole->QueryInterface(IID_IResultData,
				reinterpret_cast<void **>(&m_pResult));
	ASSERT(hr == S_OK);

	hr = m_pConsole->QueryResultImageList(&m_pImageResult);
	ASSERT(hr == S_OK);

	hr = m_pConsole->QueryConsoleVerb(&m_pConsoleVerb);
	ASSERT(hr == S_OK);

	hr = m_pConsole->QueryInterface(IID_IDisplayHelp, reinterpret_cast<void **>(&m_pDisplayHelp));
	ASSERT(hr == S_OK);

	hr = m_pConsole->QueryInterface(IID_IConsole2, reinterpret_cast<void **>(&m_pConsole2));
	ASSERT(hr == S_OK);

	return S_OK;
}

/*
 * Destroy - Releases all QI'd pointers.
 *
 * History:	a-jsari		9/1/97		Initial version
 */
STDMETHODIMP CSystemInfo::Destroy(
#ifdef _DEBUG
		MMC_COOKIE cookie
#else
		MMC_COOKIE
#endif
								  )
{
#ifdef _DEBUG
	TRACE(_T("CSystemInfo::Destroy(%lx)\n"), cookie);
	ASSERT(m_bInitializedC);
#endif // _DEBUG

	LPCONSOLE		pMMC = pConsole();

	if (pMMC != NULL) {
		pMMC->SetHeader(NULL);
		SAFE_RELEASE(m_pHeader);

		SAFE_RELEASE(m_pResult);
		SAFE_RELEASE(m_pImageResult);

		SAFE_RELEASE(m_pConsole);
		SAFE_RELEASE(m_pConsole2);
		SAFE_RELEASE(m_pComponentData);
		SAFE_RELEASE(m_pConsoleVerb);

		SAFE_RELEASE(m_pDisplayHelp);

		IUnknown *	pUnknown;
		CString		strKey;
		for (POSITION pos = m_mapCLSIDToIUnknown.GetStartPosition(); pos != NULL;)
		{
			m_mapCLSIDToIUnknown.GetNextAssoc(pos, strKey, (void * &) pUnknown);
			if (pUnknown)
				pUnknown->Release();
		}
		m_mapCLSIDToIUnknown.RemoveAll();
	}

	return S_OK;
}

/*
 * Compare - Compares two result data items for the sorting.
 *
 * History:	a-jsari		11/28/97		Initial version.
 */
STDMETHODIMP CSystemInfo::Compare(LRESULT, MMC_COOKIE cookieA, MMC_COOKIE cookieB, int *pnResult)
{
	CDatumObject		*pdoA		= reinterpret_cast<CDatumObject *>(cookieA);
	CDatumObject		*pdoB		= reinterpret_cast<CDatumObject *>(cookieB);
	CFolder				*pCategory	= pdoA->Parent();
	MSIColumnSortType	stColumn;

	ASSERT(pCategory == pdoB->Parent());
	ASSERT(pCategory->GetType());
	VERIFY(reinterpret_cast<CListViewFolder *>(pCategory)->GetSortType((DWORD)*pnResult, stColumn));
	switch (stColumn) {
	case NOSORT:
		*pnResult = 0;
		break;
	case LEXICAL:
		{
			LPCWSTR	szTextA = pdoA->GetTextItem(*pnResult);
			LPCWSTR szTextB = pdoB->GetTextItem(*pnResult);

			*pnResult = ::_wcsicmp(szTextA, szTextB);
		}
		break;
	case BYVALUE:
		{
			DWORD	iSortA = pdoA->GetSortIndex(*pnResult);
			DWORD	iSortB = pdoB->GetSortIndex(*pnResult);

			if (iSortA < iSortB) *pnResult = -1;
			else if (iSortA > iSortB) *pnResult = 1;
			else *pnResult = 0;
		}
		break;
	default:
		ASSERT(FALSE);
		break;
	}
	return S_OK;
}

/*
 * CompareObjects - Compares two data objects to see if they are the same
 *		object.
 *
 * Return Codes:
 *		E_POINTER - One (or both) of the pointers is invalid.
 *		S_OK - Both objects are the same.
 *		S_FALSE - The objects don't match.
 *
 * History: a-jsari		9/1/97		Stub version
 */
STDMETHODIMP CSystemInfo::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
	TRACE(_T("CSystemInfo::CompareObjects\n"));
	return CDataObject::CompareObjects(lpDataObjectA, lpDataObjectB);
}

/*
 * GetDisplayInfo - Set the MMC_CALLBACK information (currently only the
 *		Display string) for the result pane item pResult.
 *
 * History: a-jsari		9/1/97		Stub version
 */

STDMETHODIMP CSystemInfo::GetDisplayInfo(LPRESULTDATAITEM pResult)
{
#if 0
	TRACE(_T("CSystemInfo::GetDisplayInfo(%lx)\n"), reinterpret_cast<long>(pResult));
#endif
	ASSERT(pResult != NULL);
	ASSERT(pResult->mask & RDI_STR);

	USES_CONVERSION;

	// If the lParam indicates that the data is currently refreshing, show the
	// appropriate message. Although we have to cast away the const-ness of the
	// string, returning it as a result shouldn't be changing it.

	if (pResult->lParam == lparamRefreshIndicator)
	{
		pResult->str = T2OLE((LPTSTR)(LPCTSTR)m_strRefreshMessage);
		return S_OK;
	}
	else if (pResult->lParam == lparamNoOCXIndicator)
	{
		pResult->str = T2OLE((LPTSTR)(LPCTSTR)m_strNoOCXMessage);
		return S_OK;
	}

	if (pResult->mask & RDI_STR) 
	{
		CViewObject	* pDisplayItem = reinterpret_cast<CViewObject *>(pResult->lParam);

		if (CViewObject::DATUM == pDisplayItem->GetType())
		{
			CSystemInfoScope * pSysScope = dynamic_cast<CSystemInfoScope *>(pComponentData());
			if (pSysScope && pSysScope->InRefresh())
			{
				pResult->str = W2OLE(_T(" "));
				return S_OK;
			}
		}

		LPWSTR szName = (LPWSTR)pDisplayItem->GetTextItem(pResult->nCol);
		ASSERT(szName);
		pResult->str = W2OLE(szName);
		// In extension mode pResult is really a ScopeItem,
		// thus the nImage value is potentially garbage and needs to be filled in.
		if (pResult->bScopeItem && ( pResult->mask & SDI_IMAGE))
	    {
			if (pDisplayItem->GetType() == CViewObject::EXTENSION_ROOT)
			{
				pResult->nImage = 2; // computer icon
			}
			else
			{
				pResult->nImage = 0; // folder icon
			}
		}
	}
	return S_OK;
}

#if 0
/*
 * QueryMultiSelectDataObject - 
 *
 * History:	a-jsari		9/1/97		Stub version
 */
HRESULT	CSystemInfo::QueryMultiSelectDataObject(MMC_COOKIE /* cookie */, DATA_OBJECT_TYPES,
			LPDATAOBJECT *ppDataObject)
{
	//	FIX: Roll this into the DataObject pointer.
	ASSERT(ppDataObject != NULL);
	if (ppDataObject == NULL) return E_POINTER;

	return E_NOTIMPL;
}
#endif

/*
 * QueryDataObject - return a pointer to the data object represented by
 *		cookie and type in ppDataObject.
 *
 * Return Codes:
 *		E_POINTER - ppDataObject is invalid
 *		S_OK - Successful completion.
 *
 * History:	a-jsari		9/1/97		Initial version
 */
STDMETHODIMP CSystemInfo::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
			LPDATAOBJECT *ppDataObject)
{
	TRACE(_T("CSystemInfo::QueryDataObject(%lx, %lx, DataObject)\n"), cookie, type);
	ASSERT(ppDataObject != NULL);

	if (ppDataObject == NULL) return E_POINTER;

#if 0
	if (cookie == MMC_MULTI_SELECT_COOKIE)
		return QueryMultiSelectDataObject(cookie, type, ppDataObject);
#else
	if (cookie == MMC_MULTI_SELECT_COOKIE)
		return E_NOTIMPL;
#endif

	ASSERT(type == CCT_RESULT);

	ASSERT(pComponentData() != NULL);
	CSystemInfoScope *pScope = dynamic_cast<CSystemInfoScope*>(pComponentData());
	ASSERT(pScope != NULL);

	return CDataObject::CreateDataObject(cookie, type, pScope, ppDataObject);
}

/*
 * Notify - Handle all Microsoft Management Console notification events.
 *
 * History:	a-jsari		9/1/97		Initial version
 */

STDMETHODIMP CSystemInfo::Notify(LPDATAOBJECT pDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
	HRESULT hr = S_OK;

	TRACE(_T("CSystemInfo::Notify(%lx, %lx, %p, %p)\n"), pDataObject, event, arg, param);
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	switch(event) 
	{
	case MMCN_BTN_CLICK:
		switch(param) {
		case MMC_VERB_REFRESH:
			hr = OnRefresh(pDataObject);
			break;

		case MMC_VERB_PROPERTIES:
			hr = OnProperties(pDataObject);
			break;

		default:
			ASSERT(FALSE);	// Unknown parameter
			break;
		}
		break;

	case MMCN_DBLCLICK:
		hr = OnDoubleClick(pDataObject);
		break;

	case MMCN_INITOCX:
		{
			CDataObject * pObject = GetInternalFromDataObject(pDataObject);
			if (pObject)
			{
				CSystemInfoScope * pScope = pObject->pComponentData();
				if (pScope)
				{
					CDataSource * pSource = pScope->pSource();
					if (pSource && pSource->GetType() == CDataSource::V410FILE)
					{
						CFolder * pFolder = pObject->Category();
						if (pFolder && pFolder->GetType() == CDataSource::OCX)
						{
							LPOLESTR lpCLSID;

							if (FAILED(StringFromCLSID((reinterpret_cast<COCXFolder *>(pFolder))->m_clsid, &lpCLSID)))
								break;

							CString strCLSID(lpCLSID);
							((IUnknown *)param)->AddRef();
							m_mapCLSIDToIUnknown.SetAt(strCLSID, (CObject *) (IUnknown *)param);
							CoTaskMemFree(lpCLSID);
						}
					}
				}
			}
		}
		break;

	case MMCN_PROPERTY_CHANGE:
		if (msiLog.IsLogging())
			msiLog.WriteLog(CMSInfoLog::MENU, _T("MENU \"Properties\"\r\n"));
		hr = OnPropertyChange(pDataObject);
		break;

	case MMCN_VIEW_CHANGE:
		hr = OnUpdateView(arg);
		break;

	case MMCN_DESELECT_ALL:
		//	CHECK:	Make this correct.
		hr = OnSelect(pDataObject, TRUE);
		break;

	case MMCN_COLUMN_CLICK:
		OutputDebugString(_T("CSnapin::Notify -> MMCN_COLUMN_CLICK"));
		break;

	case MMCN_CONTEXTHELP:
	case MMCN_SNAPINHELP:
		{
			if (msiLog.IsLogging())
				msiLog.WriteLog(CMSInfoLog::MENU, _T("MENU \"Help\"\r\n"));

			CString strHelpFile;
			CString strHelpTopic;

			strHelpFile.LoadString(IDS_MSINFO_HELP_FILE);
			strHelpTopic.LoadString(IDS_MSINFO_HELP_TOPIC);

			CString		strHelp = strHelpFile + CString(_T("::")) + strHelpTopic;
			LPOLESTR	pHelp = reinterpret_cast<LPOLESTR>(CoTaskMemAlloc((strHelp.GetLength() + 1) * sizeof(wchar_t)));
			if (pHelp && m_pDisplayHelp)
			{
				USES_CONVERSION;
				wcscpy(pHelp, T2OLE((LPTSTR)(LPCTSTR)strHelp));
				hr = m_pDisplayHelp->ShowTopic(pHelp);
			}

			break;
		}

	case MMCN_SELECT:
		hr = OnSelect(pDataObject, arg);
		break;

	case MMCN_ADD_IMAGES:
		hr = OnAddImages(pDataObject, reinterpret_cast<LPIMAGELIST>(arg), param);
		break;

	case MMCN_SHOW:
		hr = OnShow(pDataObject, arg, param);
		break;

	case MMCN_ACTIVATE:
		hr = OnActivate(pDataObject, arg);
		break;

	case MMCN_REFRESH:
		if (msiLog.IsLogging())
			msiLog.WriteLog(CMSInfoLog::MENU, _T("MENU \"Refresh\"\r\n"));
		hr = OnRefresh(pDataObject);
		break;

	case MMCN_QUERY_PASTE:
		hr = S_OK;
		break;

	case MMCN_PRINT:
		if (msiLog.IsLogging())
			msiLog.WriteLog(CMSInfoLog::MENU, _T("MENU \"Print\"\r\n"));
		hr = OnPrint();
		break;

#if 0
	case MMCN_LISTPAD:
		hr = OnListPad();
		break;
#endif

	default:
		ASSERT(FALSE);
		hr = S_OK;
		break;
	}
	return hr;
}

/*
 * AddMenuItems - Add our menu items to the right-click context menu.
 *
 * History: a-jsari		9/1/97		Initial version
 */
STDMETHODIMP CSystemInfo::AddMenuItems(LPDATAOBJECT lpDataObject, LPCONTEXTMENUCALLBACK pCallback,
				long *pInsertionAllowed)
{
	LPEXTENDCONTEXTMENU		pContextMenu = pExtendContextMenu();
	TRACE(_T("CSystemInfo::AddMenuItems(%lx, Callback, InsertionAllowed)\n"), lpDataObject);
	ASSERT(pContextMenu != NULL);
	return pContextMenu->AddMenuItems(lpDataObject, pCallback, pInsertionAllowed);
}

/*
 * Command - Process the exact same menu commands we process in the scope
 *		pane.
 *
 * History:	a-jsari		9/22/97		Initial version
 */
STDMETHODIMP CSystemInfo::Command(long lCommandID, LPDATAOBJECT pDataObject)
{
	LPEXTENDCONTEXTMENU		pContextMenu = pExtendContextMenu();
	TRACE(_T("CSystemInfo::Command(%lx, %lx)\n"), lCommandID, pDataObject);
	ASSERT(pContextMenu != NULL);
	return pContextMenu->Command(lCommandID, pDataObject);
}

/*
 * EnableToolbar - Set the toolbar enabled flag to fEnable
 *
 * History: a-jsari		9/24/97		Initial version
 *
 * Note: Depends on the order of enum ToolbarButtonID
 */
HRESULT CSystemInfo::EnableToolbar(BOOL fEnable)
{
	HRESULT		hr;
	LPTOOLBAR	pToolbar = ptbItems();

	ASSERT(pToolbar != NULL);
	if (fEnable) {
		hr = m_pControlbar->Attach(TOOLBAR, pToolbar);
		//	These return S_FALSE (Undocumented)
		ASSERT(SUCCEEDED(hr));
		if (FAILED(hr)) return hr;
		for (int i = IDM_TBB_FIND ; i <= IDM_TBB_REPORT ; ++i) {
			hr = pToolbar->SetButtonState(i, ENABLED, fEnable);
			if (FAILED(hr)) return hr;
		}
	}
	return S_OK;
}

/*
 * EnableSupportTools - Set the MenuButton enabled flag to fEnable
 *
 * History:	a-jsari		9/24/97		Initial version
 */
HRESULT	CSystemInfo::EnableSupportTools(BOOL fEnable)
{
	HRESULT		hr = S_FALSE;

	LPMENUBUTTON	pTools = pmnbSupportTools();
	ASSERT(pTools != NULL);
	if (fEnable) {
		hr = pControlbar()->Attach(MENUBUTTON, pTools);
		ASSERT(SUCCEEDED(hr));
		if (FAILED(hr)) return hr;
		hr = pTools->SetButtonState(IDM_SUPPORT, ENABLED, TRUE);
		ASSERT(hr == S_OK);
		if (FAILED(hr)) return hr;
		hr = pTools->SetButtonState(IDM_SUPPORT, HIDDEN, FALSE);
		ASSERT(hr == S_OK);
	}
	return hr;
}

/*
 * ControlbarNotify - Handle events for the Toolbar
 *
 * History: a-jsari		9/16/97		Stub version
 */
STDMETHODIMP CSystemInfo::ControlbarNotify(MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
	TRACE(_T("CSystemInfo::ControlbarNotify(%lx, %ld, %ld)\n"), event, arg, param);
	switch(event) {
	case MMCN_BTN_CLICK:
		return OnButtonClick(reinterpret_cast<LPDATAOBJECT>(arg), param);
		break;

	case MMCN_DESELECT_ALL:
	case MMCN_SELECT:
		return OnControlbarSelect((event == MMCN_DESELECT_ALL), arg,
				reinterpret_cast<LPDATAOBJECT>(param));
		break;

	case MMCN_MENU_BTNCLICK:
		return OnMenuButtonClick(reinterpret_cast<LPDATAOBJECT *>(arg),
				reinterpret_cast<LPMENUBUTTONDATA>(param));
		break;

	default:
		//	Unhandled event.
		ASSERT(FALSE);
	}
	return E_NOTIMPL;
}

/*
 * AddToolbarButtons - Load the order-dependent list of toolbar buttons into
 *		CSystemInfoScope's m_pToolbar item.
 *
 * History:	a-jsari		9/18/97
 *
 * Note: The TBTTIP and TBTEXT string table elements are order dependent!
 *		If the order of these items changes, the ToolbarButtonID enum order
 *		MUST be changed to match.  The order matches the bitmaps in IDB_TOOLBAR,
 *		and the indices of the IDS_ORDERED_TBTEXT and IDS_ORDERED_TBTTIP items
 *		in the String Table.
 *
 * This module would require AFX_MANAGE_STATE, but it knows that its calling
 *		function has already called it.
 */
HRESULT CSystemInfo::AddToolbarButtons(LPTOOLBAR pToolbar)
{
	//	The first two elements (nIndex and idCommand) and the last two
	//	(Name and ToolTip) are order-dependent, changing by the loop.
	MMCBUTTON		btnToolbar = { 0, 0, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0 };

	USES_CONVERSION;
	ASSERT(pToolbar != NULL);
	//	IDM_TBB_FIND is the last element in the enum, and also has a
	//	value equal to the number of elements in the enum.
	for (int i	= 0 ; i < IDM_TBB_FIND ; ++i) {
		CString		szResourceName;
		CString		szResourceTooltip;

		btnToolbar.nBitmap = i;
		//	IDM_TBB_SAVE is the first element in the enum
		//	This line requires the ToolbarButtonID values to be consecutive.
		btnToolbar.idCommand = i + IDM_TBB_SAVE;
		VERIFY(szResourceName.LoadString(IDS_ORDERED_TBTEXT0 + i));
		btnToolbar.lpButtonText = OLESTR_FROM_CSTRING(szResourceName);
		VERIFY(szResourceTooltip.LoadString(IDS_ORDERED_TBTTIP0 + i));
		btnToolbar.lpTooltipText = OLESTR_FROM_CSTRING(szResourceTooltip);
		HRESULT		hr = pToolbar->InsertButton(i, &btnToolbar);
		ASSERT(hr == S_OK);
		if (FAILED(hr)) return hr;
	}
	return S_OK;
}

/*
 * SetControlbar - Set the exact same controlbar items we set in the scope
 *		pane.
 *
 * History:	a-jsari		9/22/97		Initial version
 */
STDMETHODIMP CSystemInfo::SetControlbar(LPCONTROLBAR pControlbar)
{
	const	int		nImages = 5;

	TRACE(_T("CSystemInfo::SetControlbar(%lx)\n"), pControlbar);
	if (pControlbar == NULL) {
		if (m_pControlbar) {
			m_pControlbar->Detach(m_pToolbar);
			SAFE_RELEASE(m_pToolbar);
			m_pControlbar->Detach(m_pMenuButton);
			SAFE_RELEASE(m_pMenuButton);
			SAFE_RELEASE(m_pControlbar);
		}
		return S_OK;
	}

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if (m_pControlbar == NULL) {
		m_pControlbar = pControlbar;
		m_pControlbar->AddRef();
	}

	HRESULT		hr = S_FALSE;

	//	If we haven't created the pull-down yet.
	if (ptbItems() == NULL) {
		hr = m_pControlbar->Create(TOOLBAR, this, reinterpret_cast<LPUNKNOWN *>(&m_pToolbar));
		ASSERT(hr == S_OK);
		if (FAILED(hr)) return hr;

		::CBitmap		pbmpToolbar;
		pbmpToolbar.LoadBitmap(IDB_TOOLS);
		hr = m_pToolbar->AddBitmap(nImages, pbmpToolbar, 16, 16, RGB(255,0,255));
		ASSERT(hr == S_OK);
		if (FAILED(hr)) return hr;

		hr = AddToolbarButtons(m_pToolbar);
		ASSERT(hr == S_OK);
		if (FAILED(hr)) return hr;

		// If we are acting as an extension snapin, remove the button for opening a file. Bug 400801.

		if (pComponentData() && !dynamic_cast<CSystemInfoScope *>(pComponentData())->IsPrimaryImpl())
			m_pToolbar->DeleteButton(IDM_TBB_OPEN - IDM_TBB_SAVE);
	}

	//	If we haven't created the pull-down yet.
	if (pmnbSupportTools() == NULL) {
		USES_CONVERSION;

		//	These should not need to be static: MMC bug.
		CString		m_szSupportTools;
		CString		m_szSupportTooltip;

		hr = m_pControlbar->Create(MENUBUTTON, this, reinterpret_cast<LPUNKNOWN *>(&m_pMenuButton));
		ASSERT(hr == S_OK);
		if (FAILED(hr)) return hr;

		VERIFY(m_szSupportTools.LoadString(IDS_SUPPORTTOOLS));
		VERIFY(m_szSupportTooltip.LoadString(IDS_SUPPORTITEM));

		hr = m_pMenuButton->AddButton(IDM_SUPPORT, OLESTR_FROM_CSTRING(m_szSupportTools),
				OLESTR_FROM_CSTRING(m_szSupportTooltip));
		ASSERT(hr == S_OK);
		if (FAILED(hr)) return hr;
	}
	return hr;
}

/*
 * SetIComponentData - Set the IComponentData pointer
 *
 * History:	a-jsari		9/2/97
 */
HRESULT CSystemInfo::SetIComponentData(CSystemInfoScope *pData)
{
	ASSERT(pData);
	ASSERT(m_pComponentData == NULL);

	LPUNKNOWN pUnk = pData->GetUnknown();

	HRESULT hr = pUnk->QueryInterface(IID_IComponentData, reinterpret_cast<void **>(&m_pComponentData));

	m_plistTools = new CToolList(reinterpret_cast<CSystemInfoScope *>(m_pComponentData));
	VERIFY(m_mnuSupport.CreatePopupMenu());
	m_plistTools->AddToMenu(&m_mnuSupport);

	ASSERT(hr == S_OK);

	return hr;
}

/*
 * CreatePropertyPages - Call the Scope pane version of this function.
 *
 * History:	a-jsari		12/9/97		Initial version
 */
STDMETHODIMP CSystemInfo::CreatePropertyPages(LPPROPERTYSHEETCALLBACK pProvider,
			LONG_PTR handle, LPDATAOBJECT pDataObject)
{
	return pExtendPropertySheet()->CreatePropertyPages(pProvider, handle, pDataObject);
}

/*
 * QueryPagesFor - Call the ScopePane version of this function.
 *
 * History:	a-jsari		12/9/97		Initial version
 */
STDMETHODIMP CSystemInfo::QueryPagesFor(LPDATAOBJECT lpDataObject)
{
	return pExtendPropertySheet()->QueryPagesFor(lpDataObject);
}

//-----------------------------------------------------------------------------
// Sets the text in the status bar on the main MMC window. There are three
// panes, divided in the string by '|' characters. The middle one can be
// used as a progress bar by using "%nn" in the string. See the MMC docs
// for more information.
//-----------------------------------------------------------------------------

void CSystemInfo::SetStatusText(LPCTSTR szText)
{ 
	if (m_pConsole2)
		m_pConsole2->SetStatusText((LPOLESTR) (szText ? szText : _T("||")));
}

void CSystemInfo::SetStatusText(UINT nResID)
{
	CString strText(_T("||"));

	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	if (nResID)
		strText.LoadString(nResID);
	SetStatusText((LPCTSTR) strText);
}

//-----------------------------------------------------------------------------
// We want to set the display to indicate that a refresh is being performed.
// Delete all the items in the results pane and add an item with a specific
// lValue indicating the refresh message.
//
// The LPARAM parameter has been added to allow this function to set different
// messages in the results pane. It's value is examined in GetDisplayInfo.
//-----------------------------------------------------------------------------

void CSystemInfo::SetRefreshing(LPARAM lparamMessage)
{
	if (pResult() == NULL || pHeaderCtrl() == NULL)
		return;

	CThreadingRefresh * pRefreshThread = NULL;
	CSystemInfoScope * pScope = reinterpret_cast<CSystemInfoScope *>(m_pComponentData);
	if (pScope)
	{
		CDataSource * pSource = pScope->pSource();
		if (pSource && pSource->GetType() == CDataSource::GATHERER)
		{
			CWBEMDataSource * pWBEMSource = reinterpret_cast<CWBEMDataSource *>(pSource);
			if (pWBEMSource)
				pRefreshThread = pWBEMSource->m_pThreadRefresh;
		}
	}

	if (pRefreshThread && pRefreshThread->ResultsPaneNotAvailable())
		return;

	// Updating the results pane is a critical section - we don't want the refresh
	// thread to update the list view while we're in the middle of it.

	if (pRefreshThread)
		pRefreshThread->EnterCriticalSection();

	// Delete current contents of results pane.

	pResult()->DeleteAllRsltItems();
	m_lstView.Clear();

	// Remove all of the current column headers, and add back a single column.

	for (HRESULT hr = S_OK; hr == S_OK; hr = pHeaderCtrl()->DeleteColumn(0));

	CString	strHeading(_T(" "));
	strHeading.LoadString(IDS_DESCRIPTION);
	pHeaderCtrl()->InsertColumn(0, (LPCWSTR)strHeading, LVCFMT_LEFT, 446);

	// Add the single item with lParam indicating a refresh message, and refresh.

	RESULTDATAITEM rdiItem;
	rdiItem.mask	= RDI_STR | RDI_PARAM | RDI_IMAGE | RDI_INDEX;
	rdiItem.str		= MMC_CALLBACK;
	rdiItem.nCol	= 0;
	rdiItem.nImage	= 1;
	rdiItem.nIndex	= 0;
	rdiItem.lParam  = lparamMessage;

	pResult()->InsertItem(&rdiItem);
	if (pRefreshThread)
		pRefreshThread->LeaveCriticalSection();
	pResult()->UpdateItem(rdiItem.itemID);
}

//-----------------------------------------------------------------------------
// Select the specified line on the results pane. (Used by find.)
//-----------------------------------------------------------------------------

void CSystemInfo::SelectLine(int iLine)
{
	LPRESULTDATA pResultPane = pResult();
	if (!pResultPane)
		return;

	RESULTDATAITEM rdi;

	rdi.mask   = RDI_STATE | RDI_INDEX;
	rdi.nIndex = iLine;
	rdi.nState = LVIS_FOCUSED | LVIS_SELECTED;

	pResultPane->ModifyViewStyle((MMC_RESULT_VIEW_STYLE ) 0x0008 /* = MMC_ENSUREFOCUSVISIBLE */, (MMC_RESULT_VIEW_STYLE ) 0);
	pResultPane->SetItem(&rdi);
	pResultPane->ModifyViewStyle((MMC_RESULT_VIEW_STYLE ) 0, (MMC_RESULT_VIEW_STYLE ) 0x0008 /* = MMC_ENSUREFOCUSVISIBLE */);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\thread.h ===
//=============================================================================
// File:		thread.h
// Author:		a-jammar
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// This header file defines the class used to perform threaded refreshes in
// MSInfo (added late in the game). All refreshes should use this class.
//=============================================================================

#pragma once

class CFolder;
class CSystemInfo;
class CDataGatherer;

//-----------------------------------------------------------------------------
// This structure is used to communicate with the thread function. A pointer is
// passed when the thread function is called. We declare a static instance of
// the struct which will be reused.
//-----------------------------------------------------------------------------

class CThreadingRefresh;
struct SThreadInfo
{
	volatile BOOL		m_fShowData;
	volatile BOOL		m_fCancel;		// cancel the current refresh, stay in thread
	volatile BOOL		m_fQuit;		// exit the thread
	volatile BOOL		m_fRecursive;	// refresh folders recursively
	volatile BOOL		m_fSoftRefresh;	// if TRUE, don't force a refresh on existing data
	CFolder *			m_pFolder;		// the folder to refresh
	CSystemInfo *		m_pSysInfo;		// CSystemInfo to update when complete
	CDataGatherer *		m_pGatherer;	// use this to refresh the data
	CThreadingRefresh * m_pThreadRefresh;

	HANDLE				m_eventDone;	// refresh thread fires when done
	HANDLE				m_eventStart;	// main thread fires when more data
};
 
//static SThreadInfo threadinfo;

class CThreadingRefresh
{
public:
	CThreadingRefresh(CDataGatherer * pGatherer);
	~CThreadingRefresh();

	BOOL	IsRefreshing();
	int		PerchentageComplete();
	void	RefreshAll(CFolder * pFolder, volatile BOOL * pfCancel = NULL);
	void	RefreshFolder(CFolder * pFolder, BOOL fRecursive = FALSE, BOOL fSoftRefresh = FALSE);
	void	RefreshFolderAsync(CFolder * pFolder, CSystemInfo * pSysInfo, BOOL fRecursive = FALSE, BOOL fSoftRefresh = FALSE);
	void	CancelRefresh(BOOL fUpdateUI = TRUE);
	void	KillRefreshThread();
	BOOL	WaitForRefresh();
	BOOL	ResultsPaneNotAvailable();
	void	EnterCriticalSection() { ::EnterCriticalSection(&m_csThreadRefresh); };
	void	LeaveCriticalSection() { ::LeaveCriticalSection(&m_csThreadRefresh); };

private:
	CDataGatherer *		m_pGatherer;
	HANDLE				m_hThread;
	DWORD				m_dwThreadID;
	SThreadInfo *		m_pThreadInfo;
	CRITICAL_SECTION	m_csThreadRefresh;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\thread.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation

#include "StdAfx.h"
#include <windows.h>
#include <process.h>
#include <atlbase.h>

#include "DataObj.h"
#include "CompData.h"
#include "DataSrc.h"
#include "SysInfo.h"
#include "gathint.h"
#include "gather.h"
#include "thread.h"

//-----------------------------------------------------------------------------
// Construction and destruction. Cancel any refresh in progress while
// destructing the object.
//-----------------------------------------------------------------------------

CThreadingRefresh::CThreadingRefresh(CDataGatherer * pGatherer) : m_pGatherer(pGatherer)
{
	InitializeCriticalSection(&m_csThreadRefresh);

	// Generate a system wide unique name for the events (in case there are multiple
	// instances of MSInfo running). If we can't generate a GUID for this, use the tick count.
	// Unique name generation fixes bug 394884.

	CString strEvent(_T(""));
	GUID	guid;

	if (SUCCEEDED(::CoCreateGuid(&guid)))
	{
		LPOLESTR lpGUID;

		if (SUCCEEDED(StringFromCLSID(guid, &lpGUID)))
		{
			strEvent = lpGUID;
			CoTaskMemFree(lpGUID);
		}
	}

	if (strEvent.IsEmpty())
		strEvent.Format(_T("%08x"), ::GetTickCount());

	m_pThreadInfo = new SThreadInfo;
	m_pThreadInfo->m_eventDone  = CreateEvent(NULL, TRUE, TRUE, CString(_T("MSInfoDone")) + strEvent);
	m_pThreadInfo->m_eventStart = CreateEvent(NULL, TRUE, FALSE, CString(_T("MSInfoStart")) + strEvent);
	m_pThreadInfo->m_pThreadRefresh = this;

	m_hThread = NULL;
}

CThreadingRefresh::~CThreadingRefresh()
{
	KillRefreshThread();
	DeleteCriticalSection(&m_csThreadRefresh);
	CloseHandle(m_pThreadInfo->m_eventDone);
	CloseHandle(m_pThreadInfo->m_eventStart);

	delete m_pThreadInfo;
	m_pThreadInfo = NULL;
}

//-----------------------------------------------------------------------------
// This function lets the part of the other thread which updates the results
// pane whether or not it's safe to do so. If the refresh thread is currently
// updating the display, the UI thread should leave it alone. This is used
// by SetRefreshing().
//
// It's a global function, it's not pretty, but it's for functionality added
// to the system after it was done.
//-----------------------------------------------------------------------------

BOOL CThreadingRefresh::ResultsPaneNotAvailable()
{
	return ((WAIT_TIMEOUT != ::WaitForSingleObject(m_pThreadInfo->m_eventDone, 0)) && m_pThreadInfo->m_fShowData);
}

//-----------------------------------------------------------------------------
// Is there currently a thread doing a refresh?
//-----------------------------------------------------------------------------

BOOL CThreadingRefresh::IsRefreshing()
{
	return (WAIT_TIMEOUT == ::WaitForSingleObject(m_pThreadInfo->m_eventDone, 0));
}

//-----------------------------------------------------------------------------
// Wait until the current refresh is done (or a long timeout period passes).
//-----------------------------------------------------------------------------

BOOL CThreadingRefresh::WaitForRefresh()
{
	if (IsRefreshing())
		return (WAIT_TIMEOUT != ::WaitForSingleObject(m_pThreadInfo->m_eventDone, 600000));

	return TRUE;
}

//-----------------------------------------------------------------------------
// What is the percentage complete? Not implemented at this time.
//-----------------------------------------------------------------------------

int CThreadingRefresh::PerchentageComplete()
{
	return 0;
}

//-----------------------------------------------------------------------------
// Refresh all of the data recursively from pFolder, not returning until the
// refresh is complete.
//-----------------------------------------------------------------------------

void CThreadingRefresh::RefreshAll(CFolder * pFolder, volatile BOOL * pfCancel)
{
	CWaitCursor waitcursor;

	if (pFolder && pFolder->GetType() == CDataSource::GATHERER)
	{
		RefreshFolderAsync(pFolder, NULL, TRUE, FALSE);

		while (IsRefreshing())
		{
			if (pfCancel && *pfCancel)
			{
				CancelRefresh();
				break;
			}

			Sleep(250);
		}
	}
}

//-----------------------------------------------------------------------------
// A simple synchronous refresh on a folder. We don't return until it's done.
// We'll cancel any existing refresh in progress, though.
//-----------------------------------------------------------------------------

void CThreadingRefresh::RefreshFolder(CFolder * pFolder, BOOL fRecursive, BOOL fSoftRefresh)
{
	if (IsRefreshing() && pFolder == m_pThreadInfo->m_pFolder)
		return;

	RefreshFolderAsync(pFolder, NULL, fRecursive, fSoftRefresh);
	WaitForRefresh();
}

//-----------------------------------------------------------------------------
// This is an asynchronous refresh for a specified folder. It starts a thread
// to perform the refresh, and returns immediately.
//-----------------------------------------------------------------------------

DWORD WINAPI ThreadRefresh(void * pArg);
void CThreadingRefresh::RefreshFolderAsync(CFolder * pFolder, CSystemInfo * pSysInfo, BOOL fRecursive, BOOL fSoftRefresh)
{
	if (!m_pGatherer || !pFolder || pFolder->GetType() != CDataSource::GATHERER)
		return;

	// If we're currently refreshing this folder, don't bother.

	if (m_pThreadInfo->m_pFolder == pFolder && IsRefreshing())
		return;

	// Stop any refresh in progress.

	CancelRefresh();

	// If this is a soft refresh, if the folder has already been refreshed,
	// bounce out of here.

	CWBEMFolder * pWBEMFolder = reinterpret_cast<CWBEMFolder *>(pFolder);
	if (fSoftRefresh)
	{
		if (!pWBEMFolder || pWBEMFolder->m_fBeenRefreshed)
			return;

		if (pWBEMFolder->m_pCategory && pWBEMFolder->m_pCategory->HasBeenRefreshed())
			return;
	}

	// Give some visual indicators that we're refreshing.

	if (pSysInfo)
	{
		pSysInfo->ClearResultsPane();
		pSysInfo->SetStatusText(IDS_REFRESHING_MSG);
		if (pFolder && pFolder->GetChildNode() == NULL)
			pSysInfo->SetRefreshing(pSysInfo->lparamRefreshIndicator);
	}

	// Set the fields in the shared memory. We know the thread is in a paused
	// state (isn't using these fields) because of the CancelRefresh().

	m_pThreadInfo->m_fShowData		= FALSE;
	m_pThreadInfo->m_fCancel		= FALSE;
	m_pThreadInfo->m_fQuit			= FALSE;
	m_pThreadInfo->m_pFolder		= pFolder;
	m_pThreadInfo->m_pSysInfo		= pSysInfo;
	m_pThreadInfo->m_pGatherer		= m_pGatherer;
	m_pThreadInfo->m_fRecursive		= fRecursive;
	m_pThreadInfo->m_fSoftRefresh	= fSoftRefresh;

	// If the thread hasn't been created, create it now. It will do the refresh,
	// then pause waiting for m_eventStart to be triggered. Otherwise, just
	// do the trigger so the thread wakes up and refreshes.

	if (m_hThread == NULL)
	{
		m_pThreadInfo->m_fShowData = TRUE;
		::ResetEvent(m_pThreadInfo->m_eventDone);
		::ResetEvent(m_pThreadInfo->m_eventStart);
		m_hThread = ::CreateThread(NULL, 0, ThreadRefresh, (LPVOID) m_pThreadInfo, 0, &m_dwThreadID);
	}
	else
	{
		::ResetEvent(m_pThreadInfo->m_eventDone);
		::SetEvent(m_pThreadInfo->m_eventStart);
	}
}

//-----------------------------------------------------------------------------
// Cancel a refresh in progress by setting the flag and waiting for thread to
// signal that it's done.
//-----------------------------------------------------------------------------

void CThreadingRefresh::CancelRefresh(BOOL fUpdateUI)
{
	if (IsRefreshing())
	{
		if (fUpdateUI)
		{
			CWaitCursor waitcursor;

			m_pThreadInfo->m_fCancel = TRUE;
			if (!WaitForRefresh())
				; // Something bad has happened.
		}
		else
		{
			m_pThreadInfo->m_fCancel = TRUE;
			if (!WaitForRefresh())
				; // Something bad has happened.
		}

		if (fUpdateUI && m_pThreadInfo->m_pSysInfo)
			m_pThreadInfo->m_pSysInfo->SetStatusText(_T(""));
	}
}

//-----------------------------------------------------------------------------
// Terminates the thread which does the refresh, presumably before exiting.
//-----------------------------------------------------------------------------

void CThreadingRefresh::KillRefreshThread()
{
	CancelRefresh();
	m_pThreadInfo->m_fQuit = TRUE;
	m_pThreadInfo->m_fCancel = TRUE;

	::SetEvent(m_pThreadInfo->m_eventStart);
	if (WAIT_TIMEOUT == ::WaitForSingleObject(m_hThread, 60000))
		::TerminateThread(m_hThread, 0);

	::CloseHandle(m_hThread);
	m_hThread = NULL;
}

//-----------------------------------------------------------------------------
// The thread function which actually performs the work.
//-----------------------------------------------------------------------------

DWORD WINAPI ThreadRefresh(void * pArg)
{
	SThreadInfo * pThreadInfo = (SThreadInfo *) pArg;
	if (pThreadInfo == NULL)
		return 0;

	CoInitialize(NULL);

	CDataProvider * pOurProvider = NULL;
	CDataProvider * pLastExternalProvider = NULL;
	CString			strLastExternalComputer(_T(""));

	while (!pThreadInfo->m_fQuit)
	{
		if (pThreadInfo->m_pFolder && pThreadInfo->m_pGatherer)
		{
			// If the provider pointer in the gatherer object has changed since
			// we last did a refresh, we should recreate our own provider.

			if (pLastExternalProvider != pThreadInfo->m_pGatherer->m_pProvider || 
				strLastExternalComputer.CompareNoCase(pThreadInfo->m_pGatherer->m_strDeferredProvider) != 0)
			{
				// Get the computer name to which we connect.

				strLastExternalComputer = pThreadInfo->m_pGatherer->m_strDeferredProvider;
				if (pThreadInfo->m_pGatherer->m_pProvider)
					strLastExternalComputer = pThreadInfo->m_pGatherer->m_pProvider->m_strComputer;

				// Create a new CDataProvider for that computer.

				if (pOurProvider)
					delete pOurProvider;

				pOurProvider = new CDataProvider;
				if (pOurProvider)
					pOurProvider->Create(strLastExternalComputer, pThreadInfo->m_pGatherer);
			}

			// Save the external provider pointer, and replace it with ours.
			// The main thread shouldn't be touching it while we are running
			// (i.e. when m_eventDone is not set).

			pLastExternalProvider = pThreadInfo->m_pGatherer->m_pProvider;
			pThreadInfo->m_pGatherer->m_pProvider = pOurProvider;

			// Do the refresh on the folder.

			if (pThreadInfo->m_pFolder->GetType() == CDataSource::GATHERER)
			{
				if (pThreadInfo->m_pGatherer && !pThreadInfo->m_fSoftRefresh)
					pThreadInfo->m_pGatherer->SetLastError(GATH_ERR_NOERROR);

				CWBEMFolder * pWBEMFolder = reinterpret_cast<CWBEMFolder *>(pThreadInfo->m_pFolder);
				if (pWBEMFolder && pWBEMFolder->m_pCategory != NULL)
					pWBEMFolder->m_pCategory->Refresh(pThreadInfo->m_fRecursive, &(pThreadInfo->m_fCancel), pThreadInfo->m_fSoftRefresh);
			
				if (!pThreadInfo->m_fCancel)
					pWBEMFolder->m_fBeenRefreshed = TRUE;
			}

			// Restore the external provider pointer.

			pOurProvider = pThreadInfo->m_pGatherer->m_pProvider;
			pThreadInfo->m_pGatherer->m_pProvider = pLastExternalProvider;

			// Signal that we're done, to release the UI thread (if it's waiting to cancel us and start
			// a new refresh).

			::SetEvent(pThreadInfo->m_eventDone);

			// Make sure we've cleared the UI thread updating the results pane by entering and immediately
			// leaving the critical section.

			if (pThreadInfo->m_pThreadRefresh)
			{
				pThreadInfo->m_pThreadRefresh->EnterCriticalSection();
				pThreadInfo->m_pThreadRefresh->LeaveCriticalSection();
			}

			// If the refresh wasn't cancelled, and the user hasn't selected a
			// different category while we were refreshing, then update the
			// display. Note, we have to indicate that we're done before doing
			// this.

			if (!pThreadInfo->m_fCancel && pThreadInfo->m_pSysInfo && pThreadInfo->m_pSysInfo->m_pConsole2)
			{
				pThreadInfo->m_pSysInfo->SetStatusText(_T(""));
				if (pThreadInfo->m_fShowData)
				{
					if (pThreadInfo->m_pSysInfo->m_pLastRefreshedFolder == pThreadInfo->m_pFolder)
					{
						pThreadInfo->m_pSysInfo->ClearResultsPane();
						pThreadInfo->m_pSysInfo->SetResultHeaderColumns(pThreadInfo->m_pFolder);
						pThreadInfo->m_pSysInfo->EnumerateValues(pThreadInfo->m_pFolder);
					}
				}
			}
			else
			{
				// Invalidate the refresh (didn't get to display it).

				CWBEMFolder * pWBEMFolder = reinterpret_cast<CWBEMFolder *>(pThreadInfo->m_pFolder);
				if (pWBEMFolder)
					pWBEMFolder->m_fBeenRefreshed = FALSE;
			}
		}
		else
			::SetEvent(pThreadInfo->m_eventDone);

		pThreadInfo->m_fShowData = FALSE;

		// Go to sleep until it's time to return to work.

		::WaitForSingleObject(pThreadInfo->m_eventStart, INFINITE);
		::ResetEvent(pThreadInfo->m_eventStart);
		::ResetEvent(pThreadInfo->m_eventDone);

		pThreadInfo->m_fShowData = TRUE;

		if (!pThreadInfo->m_fCancel && !pThreadInfo->m_fQuit && pThreadInfo->m_pSysInfo)
			pThreadInfo->m_pSysInfo->SetStatusText(IDS_REFRESHING_MSG);
	}

	if (pOurProvider)
		delete pOurProvider;

	CoUninitialize();
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\toolset.cpp ===
//	Toolset.cpp - Classes to manage the tools menu.
//
//  Copyright (c) 1998-1999 Microsoft Corporation

#include <process.h>
#include "StdAfx.h"
#include "Toolset.h"
#include "DataObj.h"
#include "CompData.h"
#include <atlbase.h>
#include "Resource.h"
#include "resrc1.h"
#include "msicab.h"

#ifdef _UNICODE
#define _tspawnl _wspawnl
#else
#define _tspawnl _spawnl
#endif

const unsigned KEY_SIZE = MAX_PATH;
const unsigned CToolset::MAXIMUM_TOOLS = 256;

LPCTSTR	cszRoot					= _T("Software\\Microsoft\\Shared Tools\\MSInfo");
LPCTSTR	cszToolsetKey			= _T("ToolSets");
LPCTSTR	cszMSInfoRoot			= _T("Software\\Microsoft\\Shared Tools\\MSInfo\\ToolSets");
LPCTSTR cszMSInfoCommandKey		= _T("command");
LPCTSTR cszMSInfoParamKey		= _T("param");
LPCTSTR cszMSInfoDescriptionKey = _T("description");
LPCTSTR cszSystemPolicyKey		= _T("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer");
LPCTSTR cszRunKey				= _T("NoRun");
LPCTSTR cszDefaultToolsetKey	= _T("MSInfo");
LPCTSTR cszExplorerSubPath		= _T("\\explorer.exe");

LPCTSTR cszAppletExtension		= _T(".cpl");
LPCTSTR cszSnapinExtension		= _T(".msc");

/*
 * CTool - Construct from the registry.
 *
 * History:	a-jsari		11/11/97		Initial version.
 */

CTool::CTool(CRegKey * pKeyTool) : m_strName(_T("")), m_strPath(_T("")), m_strParam(_T("")), m_strDescription(_T("")), m_fValid(TRUE)
{
	if (pKeyTool == NULL)
		return;

	TCHAR szBuffer[MAX_PATH];
	DWORD dwSize;

	dwSize = MAX_PATH;
	if (pKeyTool->QueryValue(szBuffer, NULL, &dwSize) == ERROR_SUCCESS)
		m_strName = szBuffer;

	dwSize = MAX_PATH;
	if (pKeyTool->QueryValue(szBuffer, cszMSInfoCommandKey, &dwSize) == ERROR_SUCCESS)
		m_strPath = szBuffer;

	dwSize = MAX_PATH;
	if (pKeyTool->QueryValue(szBuffer, cszMSInfoParamKey, &dwSize) == ERROR_SUCCESS)
		m_strParam = szBuffer;

	dwSize = MAX_PATH;
	if (pKeyTool->QueryValue(szBuffer, cszMSInfoDescriptionKey, &dwSize) == ERROR_SUCCESS)
		m_strDescription = szBuffer;

	m_fValid = PathExists();
}

/*
 * operator= - Assignment operator, used to assign CTools to the CToolset array.
 *
 * History:	a-jsari		11/11/97		Initial version
 */
const CTool &CTool::operator=(const CTool &toolCopy)
{
	if (&toolCopy != this) {
		m_strName = toolCopy.m_strName;
		m_strPath = toolCopy.m_strPath;
		m_strDescription = toolCopy.m_strDescription;
		m_fValid = toolCopy.m_fValid;
	}
	return *this;
}

//-----------------------------------------------------------------------------
// PathExists - Return a flag specifying whether we can access the path
// to our executable, excluding any parameters.
//-----------------------------------------------------------------------------

BOOL CTool::PathExists() const
{
	// First, we'll look for the command, to see if that file exists.

	if (::_taccess((LPCTSTR)m_strPath, A_READ) != 0)
		return FALSE;

	// Also, the parameter value might contain a file (like a control
	// panel or an MSC snap-in file) we should check for. We need to get
	// a little bit kludgy here - if the param part ends with a CPL or
	// MSC extension, then back up in the string, so we can check for
	// the existence of that file.

	if (m_strParam.Right(4).CompareNoCase(cszAppletExtension) == 0 || m_strParam.Right(4).CompareNoCase(cszSnapinExtension) == 0)
	{
		LPCTSTR szFile = ::_tcsrchr((LPCTSTR)m_strParam, (TCHAR)' ');
		if (szFile)
			szFile++; // advance past the space
		else
			szFile = (LPCTSTR)m_strParam;

		if (szFile && ::_taccess(szFile, A_READ) != 0)
			return FALSE;
	}

	return TRUE;
}

//-----------------------------------------------------------------------------
// RunTool - Spawn a process executing the current tool.
//-----------------------------------------------------------------------------

HRESULT CTool::RunTool()
{
	AFX_MANAGE_STATE(::AfxGetStaticModuleState());
	
	if (PolicyPermitRun() == FALSE)
	{
		CString strMessage;
		strMessage.LoadString(IDS_POLICYFORBIDSRUN);
		return S_OK;
	}

	LPCTSTR	cszPath = GetPath();
	LPCTSTR	cszParam = GetParam();

	if (msiLog.IsLogging())
		msiLog.WriteLog(CMSInfoLog::TOOL, _T("TOOL \"%s\"\r\n"), m_strName);

	intptr_t hProcess;
	if (cszParam && *cszParam)
		hProcess = ::_tspawnl(_P_NOWAIT, cszPath, cszPath, cszParam, NULL);
	else
		hProcess = ::_tspawnl(_P_NOWAIT, cszPath, cszPath, NULL);

	if (hProcess < 0)
	{
		CString strMessage;
		strMessage.Format(IDS_NOPATH, cszPath);
		return E_UNEXPECTED;
	}

	return S_OK;
}

/*
 * PolicyPermitRun - returns a BOOLEAN value which determines whether
 *
 * History:	ericflo		11/21/97		Boilerplate version
 *			a-jsari		11/21/97		Initial edits
 */
BOOL CTool::PolicyPermitRun()
{
	HKEY	hKeyPolicy;
	BOOL	bReturn = TRUE;
	DWORD	dwSize, dwData, dwType;

	//	Explorer\\NoRun == 1
	do {
		if (RegOpenKeyEx (HKEY_CURRENT_USER, cszSystemPolicyKey, 0,
			KEY_READ, &hKeyPolicy) == ERROR_SUCCESS) {
			dwSize = sizeof(dwData);

			if (RegQueryValueEx(hKeyPolicy, cszRunKey, NULL, &dwType,
				(LPBYTE) &dwData, &dwSize) != ERROR_SUCCESS) break;
			RegCloseKey (hKeyPolicy);

			//	I'm not sure which type this value is, so make an assumption.
			switch (dwType) {
			case REG_DWORD:
				if (dwData == 1)
					bReturn = FALSE;
				break;
			default:
				//	We are assuming the wrong value type.
				ASSERT(FALSE);
				break;
			}
		}
	} while (FALSE);
	return bReturn;
}

/*
 * CCabTool - Construct the Cab explosion item.
 *
 * History: a-jsari		3/25/98		Initial version.
 */
CCabTool::CCabTool(CSystemInfoScope *pScope)
:m_pScope(pScope)
{
	TCHAR	szBuffer[MAX_PATH + 1];
	UINT	uSize = MAX_PATH;
	AFX_MANAGE_STATE(::AfxGetStaticModuleState());

	m_strName.LoadString(IDS_CAB_NAME);
	m_strDescription.LoadString(IDS_CAB_DESCRIPTION);
	VERIFY(GetWindowsDirectory(szBuffer, uSize));
	m_strPath = szBuffer;
	m_strPath += cszExplorerSubPath;
}

/*
 * IsValid - Determine whether we have opened a CAB to explode.
 *
 * History:	a-jsari		3/25/98		Initial version.
 */
BOOL CCabTool::IsValid() const
{
	if (m_pScope == NULL || m_pScope->pSource() == NULL || m_pScope->pSource()->GetType() == CDataSource::GATHERER)
		return FALSE;
	if (!PathExists()) return FALSE;
	return reinterpret_cast<CBufferDataSource *>(m_pScope->pSource())->HasCAB();
}

/*
 * GetPath - Return the path to explorer with the CAB directory.
 *
 * History:	a-jsari		3/25/98		Initial version.
 */
const CString &CCabTool::GetPath()
{
	TCHAR	szBuffer[MAX_PATH + 1];
	UINT	uSize = MAX_PATH;

	VERIFY(GetWindowsDirectory(szBuffer, uSize));
	m_strPath = (LPTSTR)szBuffer;
	m_strPath += cszExplorerSubPath;
	return m_strPath;
}

const CString &CCabTool::GetParam()
{
	if (m_strParam.IsEmpty())
		::GetCABExplodeDir(m_strParam, FALSE, CString(_T("")));
	return m_strParam;
}

BOOL CToolset::s_fCabAdded = FALSE;

/*
 * CToolset - Construct a toolset, reading the tools from the Registry key.
 *
 * History:	a-jsari		11/6/97		Initial version
 */
CToolset::CToolset(CSystemInfoScope *pScope, CRegKey *pKeySet, CString *pstrName)
:m_pPopup(NULL)
{
	CRegKey		keySub;
	if (pKeySet) {
		long lResult;
		do {
			if (pstrName != NULL) {
				//	szName represents the name of a subkey to open.
				lResult = keySub.Open(*pKeySet, *pstrName, KEY_READ);
				ASSERT(lResult == ERROR_SUCCESS);
				if (lResult != ERROR_SUCCESS) break;
			}
			DWORD		dwSize;
			TCHAR		szBuffer[KEY_SIZE];
			CRegKey		keyTool;
			FILETIME	keyTime;

			dwSize = sizeof(szBuffer);
			keySub.QueryValue(szBuffer, NULL, &dwSize);
			m_strName = szBuffer;
			for (DWORD iTool = 0 ; ; ++iTool) {

				//dwSize = sizeof(szBuffer);
				dwSize = sizeof(szBuffer) / sizeof(TCHAR);
				lResult = RegEnumKeyEx(keySub, iTool, szBuffer, &dwSize, NULL /* reserved */,
					NULL /* class */, NULL /* class size */, &keyTime);
				if (lResult == ERROR_NO_MORE_ITEMS) break;
				//	Hard limit of 256 tools per set.
				if (iTool == MAXIMUM_TOOLS) break;
				ASSERT(lResult == ERROR_SUCCESS);
				if (lResult != ERROR_SUCCESS) break;
				lResult = keyTool.Open(keySub, szBuffer, KEY_QUERY_VALUE);
				if (lResult != ERROR_SUCCESS) break;
				CTool		*toolNew = new CTool(&keyTool);
				m_Tools.SetAtGrow(iTool, toolNew);
			}
			if (!s_fCabAdded) {
				CTool	*pTool = new CCabTool(pScope);
				s_fCabAdded = TRUE;
				m_Tools.SetAtGrow(iTool, pTool);
			}
		} while (FALSE);
	}
}

/*
 * ~CToolset - Delete our objects.
 *
 * History:	a-jsari		11/6/97		Initial version
 */
CToolset::~CToolset()
{
	delete m_pPopup;
	unsigned iTool = (unsigned)m_Tools.GetSize();
	while (iTool--) {
		delete m_Tools[iTool];
	}
}

/*
 * operator= - Set one toolset equal to another (for list insertion).
 *
 * History:	a-jsari		11/6/97		Initial version
 */
const CToolset &CToolset::operator=(const CToolset &tCopy)
{
	if (this != &tCopy) {
		m_strName	= tCopy.m_strName;
		m_Tools.Copy(tCopy.m_Tools);
	}
	return *this;
}

/*
 * AddToMenu - Add an item to the specified menu; set the CommandID to allow us to find
 *		the correct menu item.
 *
 * History:	a-jsari		11/6/97		Initial version
 */
HRESULT CToolset::AddToMenu(unsigned long iSet, CMenu *pMenu)
{
	m_pPopup = new CMenu;
	if (m_pPopup == NULL) ::AfxThrowMemoryException();
	m_pPopup->CreatePopupMenu();
	UINT	iTool = GetToolCount();
	UINT	iSetCount = 0;
	while (iTool) {
		//	Decrement the tool after we have set the command, so that the command ID
		//	is equal to the set or'd with the Tool + 1.
		UINT wCommand = iSet | (iTool--);

		//	Don't add a menu item for a
		if (m_Tools[iTool]->IsValid()) {
			++iSetCount;
			VERIFY(m_pPopup->InsertMenu(0, MF_BYPOSITION | MF_STRING, wCommand, m_Tools[iTool]->GetName()));
		} else {
			;	//	Log an error message!
		}
	}
	//	Only add the sub-menu if there was at least one valid menu item.
	if (iSetCount > 0)
		pMenu->AppendMenu(MF_POPUP | MF_STRING, (UINT_PTR)m_pPopup->GetSafeHmenu(), m_strName);
	return S_OK;
}

/*
 * CToolList - Read the list of tools from the registry.
 *
 * History:	a-jsari		11/6/97		Initial version.
 */
CToolList::CToolList(CSystemInfoScope *pScope)
:m_pMainPopup(NULL)
{
	CRegKey		crkToolRoot;
	TCHAR		szToolsetName[MAX_PATH];
	CString		szObject;
	DWORD		dwSize;
	long		lResult;
	FILETIME	keyTime;

	lResult = crkToolRoot.Open(HKEY_LOCAL_MACHINE, cszMSInfoRoot, KEY_READ);
	if (lResult != ERROR_SUCCESS) {
		lResult = Register(TRUE);
		if (lResult != ERROR_SUCCESS) return;
		lResult = crkToolRoot.Open(HKEY_LOCAL_MACHINE, cszMSInfoRoot, KEY_READ);
		ASSERT(lResult == ERROR_SUCCESS);
		if (lResult != ERROR_SUCCESS) return;
	}
	for (DWORD iKey = 0 ; ; ++iKey) {
		//dwSize = sizeof(szToolsetName);
		dwSize = sizeof(szToolsetName) / sizeof(TCHAR);
		lResult = RegEnumKeyEx(crkToolRoot, iKey, szToolsetName, &dwSize, NULL /* reserved */,
			NULL /* class */, NULL /* class size */, &keyTime);
		if (lResult == ERROR_NO_MORE_ITEMS) break;
		szObject = szToolsetName;
		CToolset	*setNew = new CToolset(pScope, &crkToolRoot, &szObject);
		Add(setNew);
	}
}

/*
 * ~CToolList - Delete our saved pop-up menu.
 *
 * History:	a-jsari		11/6/97		Initial version
 */
CToolList::~CToolList()
{
	delete m_pMainPopup;
	unsigned iToolset = (unsigned)m_InternalList.GetSize();
	while (iToolset--) {
		delete m_InternalList[iToolset];
	}
}

/*
 * Add - Add an element to the end of the internal list.
 *
 * History:	a-jsari		11/11/97		Initial version
 */
void CToolList::Add(CToolset *toolSet)
{
	m_InternalList.Add(toolSet);
}

/*
 * AddToMenu - Create our popup menu and add all of the sub-menus of each toolset
 *		to it.
 *
 * History:	a-jsari		11/6/97		Initial version.
 */
HRESULT CToolList::AddToMenu(CMenu *pMenu)
{
//	HRESULT			hResult;
//	CToolset		eSet;
	unsigned int	ulMask;		//	To identify Toolset from the list for the CommandID.
	unsigned		cList;

	m_pMainPopup = new CMenu;
	if (m_pMainPopup == NULL) ::AfxThrowMemoryException();
	m_pMainPopup->CreatePopupMenu();
	cList = (unsigned)m_InternalList.GetSize();
	for (ulMask = 0 ; ulMask < cList ; ++ulMask) {
		//	ulMask << 16 is or'd into the lCommand to represent the Toolset number.
		HRESULT	hResult = m_InternalList[ulMask]->AddToMenu(ulMask << 8, m_pMainPopup);
		if (FAILED(hResult)) return hResult;
	}
	pMenu->AppendMenu(MF_POPUP | MF_STRING, (UINT_PTR) m_pMainPopup->GetSafeHmenu(), _T(""));
	return S_OK;
}

//-----------------------------------------------------------------------------
// Register (or unregister) the tools which show up in the MSInfo tools menu.
// The tools are stored in a string resource, which we should process here
// to create the registry entries.
//
// Under the toolset registry entry, each tool will have a key. Values under
// the key will be:
//
// <default>	Name of the tool, to appear in menu (may be localized).
// commnd		Command line for tool.
// param		Parameter for the tool.
//-----------------------------------------------------------------------------

long CToolList::Register(BOOL fRegister)
{
	long	lResult;
	CRegKey crkToolsetRoot;

	//	If unregistering - recursively delete the ToolSets key under
	//	HKEY_LOCAL_MACHINE\Software\Microsoft\Shared Tools\MSInfo.

	if (!fRegister)
	{
		lResult = crkToolsetRoot.Open(HKEY_LOCAL_MACHINE, cszRoot);
		if (lResult != ERROR_SUCCESS)
			return lResult;
		return crkToolsetRoot.RecurseDeleteKey(cszToolsetKey);
	}

	AFX_MANAGE_STATE(::AfxGetStaticModuleState());

	CRegKey crkNewToolset, crkTool;
	CString	strKeyValue;

	// Create ToolSets key.

	lResult = crkToolsetRoot.Create(HKEY_LOCAL_MACHINE, cszMSInfoRoot);
	if (lResult != ERROR_SUCCESS)
		return lResult;

	// Delete anything which might already be under the MSInfo subkey.

	lResult = crkToolsetRoot.Open(HKEY_LOCAL_MACHINE, cszMSInfoRoot);
	if (lResult == ERROR_SUCCESS)
		crkToolsetRoot.RecurseDeleteKey(cszDefaultToolsetKey);

	lResult = crkNewToolset.Create(crkToolsetRoot, cszDefaultToolsetKey);
	if (lResult != ERROR_SUCCESS)
		return lResult;
	
	VERIFY(strKeyValue.LoadString(IDS_MSINFOTOOLSET));
	lResult = crkNewToolset.SetValue(strKeyValue);
	if (lResult != ERROR_SUCCESS)
		return lResult;

	// Get the windows directory and system32 directory.

	TCHAR szDirectory[MAX_PATH];

	CString strSystemDirectory;
	if (::GetSystemDirectory(szDirectory, MAX_PATH))
		strSystemDirectory = szDirectory;

	CString strWindowsDirectory;
	if (::GetWindowsDirectory(szDirectory, MAX_PATH))
		strWindowsDirectory = szDirectory;

	// Load the string containing the tools to add to the registry.

	CString strTools;
	strTools.LoadString(IDS_DEFAULT_TOOLS);

	CString strKeyName, strName, strCommand, strParam;
	int		iDelim;
	while (!strTools.IsEmpty())
	{
		// First, get the different values we're going to add to the registry.

		iDelim = strTools.Find((TCHAR) '|');
		if (iDelim >= 0)
		{
			strKeyName = strTools.Left(iDelim);
			strTools = strTools.Right(strTools.GetLength() - (iDelim + 1));
		}

		iDelim = strTools.Find((TCHAR) '|');
		if (iDelim >= 0)
		{
			strName = strTools.Left(iDelim);
			strTools = strTools.Right(strTools.GetLength() - (iDelim + 1));
		}

		iDelim = strTools.Find((TCHAR) '|');
		if (iDelim >= 0)
		{
			strCommand = strTools.Left(iDelim);
			strTools = strTools.Right(strTools.GetLength() - (iDelim + 1));
		}

		iDelim = strTools.Find((TCHAR) '|');
		if (iDelim >= 0)
		{
			strParam = strTools.Left(iDelim);
			strTools = strTools.Right(strTools.GetLength() - (iDelim + 1));
		}

		// Now we need to convert the sequences in the string which contain
		// references to the windows directory, etc.

		ReplaceString(strCommand, _T("%sys32%"), strSystemDirectory);
		ReplaceString(strCommand, _T("%win%"), strWindowsDirectory);
		ReplaceString(strParam, _T("%sys32%"), strSystemDirectory);
		ReplaceString(strParam, _T("%win%"), strWindowsDirectory);

		// Finally, create the registry entries.

		lResult = crkTool.Create(crkNewToolset, strKeyName);
		if (lResult != ERROR_SUCCESS)
			continue;
		crkTool.SetValue(strName);
		crkTool.SetValue(strCommand, cszMSInfoCommandKey);
		crkTool.SetValue(strParam, cszMSInfoParamKey);
	}

	return ERROR_SUCCESS;
}

//-----------------------------------------------------------------------------
// Look for instances of strFind in strString, and replace them with
// strReplace. There's a method to do this in CString in version 6.
//-----------------------------------------------------------------------------

void CToolList::ReplaceString(CString & strString, const CString & strFind, const CString & strReplace)
{
	int iStart = strString.Find(strFind);
	while (iStart != -1)
	{
		CString strTemp = strString.Left(iStart);
		strTemp += strReplace;
		strTemp += strString.Right(strString.GetLength() - iStart - strFind.GetLength());
		strString = strTemp;
		iStart = strString.Find(strFind);
	}
}

/* operator[] - Index our internal list.
 *
 * History:	a-jsari		11/11/97		Initial version. */

CToolset *CToolList::operator[](int iSet) const
{
	return m_InternalList[iSet];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\toolset.h ===
//	Toolset.h		A set of tools added by a menu item.
//
//  Copyright (c) 1998-1999 Microsoft Corporation

#pragma once	// MSINFO_TOOLSET_H

#include "StdAfx.h"
#include <afxtempl.h>

/*
 * CTool - A single tool object, defining the menu item and interface for execution.
 *
 * History:	a-jsari		11/11/97		Initial version.
 */
class CTool {
public:
	CTool(CRegKey *pKeyTool = NULL);
	~CTool()								{ }

	const CString			&GetName() const		{ return m_strName; }
	const CString			&GetDescription() const	{ return m_strDescription; }
	const CTool				&operator=(const CTool &tCopy);
	HRESULT					RunTool();
	virtual BOOL			IsValid() const			{ return m_fValid; }
	virtual const CString	&GetPath()				{ return m_strPath; }
	virtual const CString	&GetParam()				{ return m_strParam; }

	static BOOL		PolicyPermitRun();

protected:
	BOOL				PathExists() const;

	BOOL				m_fValid;
	CString				m_strName;
	CString				m_strPath;
	CString				m_strParam;
	CString				m_strDescription;
};

class CSystemInfoScope;
/*
 * CCabTool - A tool to run the internal cab explosion code.
 *
 * History:	a-jsari		2/13/98		Initial version
 */
class CCabTool : public CTool {
public:
	CCabTool(CSystemInfoScope *pScope);
	~CCabTool() {};

	BOOL			IsValid() const;
	const CString	&GetPath();
	const CString	&GetParam();

private:
	CSystemInfoScope		*m_pScope;
};

/*
 * CToolset - A set of tools under a common heading.
 *
 * History:	a-jsari		11/6/97		Initial version
 */
class CToolset {
public:
	CToolset(CSystemInfoScope *pScope, CRegKey *pKeyTool = NULL, CString *szName = NULL);
	~CToolset();

	const CString	&GetName() const					{ return m_strName; }
	unsigned		GetToolCount() const				{ return (unsigned)m_Tools.GetSize(); }
	const CString	&GetToolName(unsigned iTool) const	{ return m_Tools[iTool]->GetName(); }
	HRESULT			RunTool(unsigned iTool) const		{ return m_Tools[iTool]->RunTool(); }
	HRESULT			AddToMenu(unsigned long iSet, CMenu *pMenu);
	const CToolset	&operator=(const CToolset &tCopy);

	static const unsigned	MAXIMUM_TOOLS;
private:
	static	BOOL	s_fCabAdded;

	CMenu						*m_pPopup;
	CString						m_strName;
	CArray <CTool *, CTool * &>	m_Tools;
};

/*
 * CToolList - A list of toolsets.  Currently only one of these exists in the
 *		CSystemInfo item.
 *
 * History:	a-jsari		11/6/97		Initial version.
 */
class CToolList {
public:
	CToolList(CSystemInfoScope *pScope);
	~CToolList();

	void		Add(CToolset *pTool);
	HRESULT		AddToMenu(CMenu *pMenu);
	CToolset	*operator[](int iSet) const;

	static long	Register(BOOL fRegister = TRUE);
	static void	ReplaceString(CString & strString, const CString & strFind, const CString & strReplace);
private:
	CMenu								*m_pMainPopup;
	CArray <CToolset *, CToolset * &>	m_InternalList;
};

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\tmplfile.cpp ===
//=============================================================================
// File:		tmplfile.cpp
// Author:		a-jammar
// Covers:		CTemplateFileFunctions
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// This file contains the functions necessary to read in the MSInfo template
// file. The template file is a text file with an NFT extension. Reading
// multiple template files is allowed - the contents are merged together into
// the category tree maintained by the snap-in.
//=============================================================================

#include "stdafx.h"
#include "gather.h"
#include "gathint.h"

//-----------------------------------------------------------------------------
// This function is the main entry point for reading the template file into
// the category structure used by the CDataGatherer object. If there is no
// tree when this function is called, the tree is created from the contents
// of the file. If there is a tree already in place, then the contents of the
// file are loaded under the existing root node.
//-----------------------------------------------------------------------------

BOOL CTemplateFileFunctions::ReadTemplateFile(CFile *pFile, CDataGatherer *pGatherer)
{
	ASSERT(pFile && pGatherer);

	if (!VerifyUNICODEFile(pFile))
	{
		TRACE0("-- CTemplateFileFunctions::ReadTemplateFile() passed non-UNICODE file\n");
		return FALSE;
	}

	if (!ReadHeaderInfo(pFile, pGatherer))
	{
		TRACE0("-- CTemplateFileFunctions::ReadTemplateFile() failed from ReadHeaderInfo\n");
		return FALSE;
	}

	if (pGatherer->m_dwRootID)
	{
		// There is already a tree present. Insert the contents of the file under
		// the root node, after the last first level node. Walk through the first
		// level of the internal category tree. TBD: add a way to extend a specified node

		INTERNAL_CATEGORY *pInternal = pGatherer->GetInternalRep(pGatherer->m_dwRootID);
		ASSERT(pInternal);

		if (pInternal)
		{
			pInternal = pGatherer->GetInternalRep(pInternal->m_dwChildID);
			while (pInternal && pInternal->m_dwNextID)
				pInternal = pGatherer->GetInternalRep(pInternal->m_dwNextID);
		}

		DWORD dwPrevID = (pInternal) ? pInternal->m_dwID : 0;
		if (ReadNodeRecursive(pFile, pGatherer, pGatherer->m_dwRootID, dwPrevID) == 0)
			return FALSE;
		return TRUE;
	}
	else
	{
		pGatherer->m_dwRootID = ReadNodeRecursive(pFile, pGatherer, 0, 0);
		if (pGatherer->m_dwRootID == 0)
			return FALSE;
		return TRUE;
	}
}

//-----------------------------------------------------------------------------
// This method reads the header information from the file before the recursive
// category descriptions. Note: since this is the first and only version of
// the template file, we take the easy way out and just make sure that the
// identifier and version are there.
//-----------------------------------------------------------------------------

BOOL CTemplateFileFunctions::ReadHeaderInfo(CFile *pFile, CDataGatherer * /* pGatherer */)
{
	return VerifyAndAdvanceFile(pFile, CString(_T(TEMPLATE_FILE_TAG)));
}

//-----------------------------------------------------------------------------
// This method verifies that the passed file is a UNICODE file, by reading the
// value 0xFEFF from the file. It also leaves the file pointer past this word.
//-----------------------------------------------------------------------------

BOOL CTemplateFileFunctions::VerifyUNICODEFile(CFile *pFile)
{
	WORD	verify;

	if (pFile->Read((void *) &verify, sizeof(WORD)) != sizeof(WORD))
	{
		TRACE0("-- CTemplateFileFunctions::VerifyUNICODEFile() couldn't read WORD\n");
		return FALSE;
	}

	return (verify == 0xFEFF);
}

//-----------------------------------------------------------------------------
// This is the recursive function to read a node. It reads the information
// from the node parameters, creates the node, and processes the contents of
// the block following the node (contained within "{}"'s). It's called
// recursively if there are any nodes in that block.
//-----------------------------------------------------------------------------

DWORD CTemplateFileFunctions::ReadNodeRecursive(CFile *pFile, CDataGatherer *pGatherer, DWORD dwParentID, DWORD dwPrevID)
{
	// Determine if we need to create a new category for this node. Search through the
	// other sibling nodes to see if there is one which matches this category's name.
	// If there is, just use that category, and don't create a new one. Read the 
	// information from the file to determine the identifier for the new category.

	CString	strEnumerateClass, strIdentifier;

	if (!VerifyAndAdvanceFile(pFile, CString(NODE_KEYWORD) + CString("(")))
	{
		TRACE0("-- CTemplateFileFunctions::ReadNodeRecursive() Verify.. failed on node keyword\n");
		return 0;
	}

	if (!ReadArgument(pFile, strEnumerateClass))
	{
		TRACE0("-- CTemplateFileFunctions::ReadNodeRecursive() ReadArgument failed on enumerate class\n");
		return 0;
	}

	if (!ReadArgument(pFile, strIdentifier))
	{
		TRACE0("-- CTemplateFileFunctions::ReadNodeRecursive() ReadArgument failed on identifier\n");
		return 0;
	}

	// Look for a node among the siblings which has a matching strIdentifier.

	INTERNAL_CATEGORY *	pInternal;
	DWORD				dwSearchID = dwPrevID, dwMatchingID = 0;

	while (dwMatchingID == 0 && dwSearchID != 0)
	{
		pInternal = pGatherer->GetInternalRep(dwSearchID);

		if (pInternal)
		{
			if (pInternal->m_strIdentifier.CompareNoCase(strIdentifier) == 0)
				dwMatchingID = dwSearchID;
			dwSearchID = pInternal->m_dwPrevID;
		}
		else
		{
			ASSERT(pInternal);
			break;
		}
	}

	INTERNAL_CATEGORY *	pCategory = ((dwMatchingID) ? pInternal : NULL);
	DWORD				dwID = dwMatchingID;

	if (pCategory == NULL)
	{
		// Create the category for the node.

		dwID = CreateCategory(pGatherer, dwParentID, dwPrevID);
		pCategory = pGatherer->GetInternalRep(dwID);
		if (!pCategory)
			return 0;

		// Read the contents of the node argument list ("node(enum, identifier, field(source, formatstr, arg...))")
		// We've already read up to and including the identifier.

		pCategory->m_strEnumerateClass = strEnumerateClass;
		pCategory->m_strIdentifier = strIdentifier;

		if (!ReadField(pFile, pCategory->m_fieldName))
			return 0;

		// Copy the field name to the name of the category (they are two different
		// member variables to allow for dynamically refreshed names, which turns
		// out to be unnecessary in this version).

		pCategory->m_categoryName.m_strText = pCategory->m_fieldName.m_strFormat;

		if (!ReadArgument(pFile, pCategory->m_strNoInstances))
		{
			TRACE0("-- CTemplateFileFunctions::ReadNodeRecursive() ReadArgument failed on no instance message\n");
			return 0;
		}
	}
	else
	{
		// This node already existed, and we just want to read past the rest of
		// it's description without changing the existing node.

		GATH_FIELD	fieldTemp;
		CString		strTemp;

		if (!ReadField(pFile, fieldTemp))
			return 0;

		if (!ReadArgument(pFile, strTemp))
		{
			TRACE0("-- CTemplateFileFunctions::ReadNodeRecursive() ReadArgument failed on no instance message\n");
			return 0;
		}
	}

	if (!VerifyAndAdvanceFile(pFile, CString("){")))
	{
		TRACE1("-- CTemplateFileFunctions::ReadNodeRecursive() Verify.. failed on node \"){\" (%s)\n", pCategory->m_strIdentifier);
		return 0;
	}

	// Process the contents of the block (enclosed in "{}") for this node.

	DWORD	dwSubNodePrev = 0, dwNewNode = 0;
	CString	strKeyword;

	// If this new category isn't actually new (i.e. it is being read from a
	// template and overlaps an existing category) see if there are any
	// existing children.

	if (pCategory->m_dwChildID)
	{
		pInternal = pGatherer->GetInternalRep(pCategory->m_dwChildID); ASSERT(pInternal);
		while (pInternal && pInternal->m_dwNextID)
			pInternal = pGatherer->GetInternalRep(pInternal->m_dwNextID);

		if (pInternal)
			dwSubNodePrev = pInternal->m_dwID;
	}

	while (GetKeyword(pFile, strKeyword))
	{
		if (strKeyword.CompareNoCase(CString(NODE_KEYWORD)) == 0)
		{
			dwNewNode = ReadNodeRecursive(pFile, pGatherer, dwID, dwSubNodePrev);
			if (dwNewNode == 0)
				return 0;

			// If this is the first child node we've read, save its ID.

			if (pCategory->m_dwChildID == 0)
				pCategory->m_dwChildID = dwNewNode;

			// If we've read another child node, set its next field appropriately.

			if (dwSubNodePrev)
			{
				INTERNAL_CATEGORY * pPrevCategory = pGatherer->GetInternalRep(dwSubNodePrev);
				if (pPrevCategory)
					pPrevCategory->m_dwNextID = dwNewNode;
			}
			dwSubNodePrev = dwNewNode;
		}
		else if (strKeyword.CompareNoCase(CString(COLUMN_KEYWORD)) == 0)
		{
			if (!ReadColumnInfo(pFile, pGatherer, dwID))
			{
				TRACE0("-- CTemplateFileFunctions::ReadNodeRecursive() failed on ReadColumnInfo\n");
				return FALSE;
			}
		}
		else if (strKeyword.CompareNoCase(CString(LINE_KEYWORD)) == 0)
		{
			GATH_LINESPEC * pNewLineSpec = ReadLineInfo(pFile, pGatherer);
			
			if (pNewLineSpec == NULL)
			{
				TRACE0("-- CTemplateFileFunctions::ReadNodeRecursive() failed on ReadLineInfo\n");
				return FALSE;
			}

			// Add the line we just read in to the end of the list of line specs for this
			// internal category.

			if (pCategory->m_pLineSpec == NULL)
				pCategory->m_pLineSpec = pNewLineSpec;
			else
			{
				GATH_LINESPEC * pLineSpec = pCategory->m_pLineSpec;
				while (pLineSpec->m_pNext)
					pLineSpec = pLineSpec->m_pNext;
				pLineSpec->m_pNext = pNewLineSpec;
			}
		}
		else if (strKeyword.CompareNoCase(CString(ENUMLINE_KEYWORD)) == 0)
		{
			GATH_LINESPEC * pNewLineSpec = ReadLineEnumRecursive(pFile, pGatherer);
			
			if (pNewLineSpec == NULL)
			{
				TRACE0("-- CTemplateFileFunctions::ReadNodeRecursive() failed on ReadLineEnumRecursive\n");
				return FALSE;
			}

			// Add the line we just read in to the end of the list of line specs for this
			// internal category.

			if (pCategory->m_pLineSpec == NULL)
				pCategory->m_pLineSpec = pNewLineSpec;
			else
			{
				GATH_LINESPEC * pLineSpec = pCategory->m_pLineSpec;
				while (pLineSpec->m_pNext)
					pLineSpec = pLineSpec->m_pNext;
				pLineSpec->m_pNext = pNewLineSpec;
			}

			//if (!ReadLineEnumRecursive(pFile, pGatherer, dwID))
			//{
			//	TRACE0("CTemplateFileFunctions::ReadNodeRecursive() failed on ReadLineEnumRecursive\n");
			//	return FALSE;
			//}
		}
		else
		{
			ASSERT(FALSE);
			VerifyAndAdvanceFile(pFile, strKeyword);
		}
	}

	if (!VerifyAndAdvanceFile(pFile, CString("}")))
	{
		TRACE0("CTemplateFileFunctions::ReadNodeRecursive() Verify.. failed on \"}\"\n");
		return 0;
	}

	return dwID;
}

//-----------------------------------------------------------------------------
// This method verifies that the text in strVerify comes next in the file (not
// including case or whitespace differences) and advances the file past that
// text. If the text was the next content in the file, TRUE is returned,
// otherwise FALSE. If FALSE is returned, the file is backed up to where it
// was when this method was called.
//-----------------------------------------------------------------------------

BOOL CTemplateFileFunctions::VerifyAndAdvanceFile(CFile * pFile, const CString &strVerify)
{
	DWORD	dwPosition = pFile->GetPosition();
	TCHAR	cLastChar, cCurrentChar = _T('\0');
	BOOL	fInComment = FALSE;
	int		iCharIndex = 0, iStringLen = strVerify.GetLength();

	while (iCharIndex < iStringLen)
	{
		// Save the last character read, since the comment token ("//") is
		// two characters long.

		cLastChar = cCurrentChar;

		// Read the next character in the file.

		if (pFile->Read((void *) &cCurrentChar, sizeof(TCHAR)) != sizeof(TCHAR))
		{
			TRACE0("-- CTemplateFileFunctions::VerifyAndAdvanceFile() couldn't read character\n");
			return FALSE;
		}

		// If we're in a comment, and the character we just read isn't a new line,
		// we want to ignore it.

		if (fInComment)
		{
			if (cCurrentChar == _T('\n'))
				fInComment = FALSE;
			continue;
		}

		// Check to see if we've started into a comment. Note that we ignore
		// the first '/' also by continuing.

		if (cCurrentChar == _T('/'))
		{
			if (cLastChar == _T('/'))
				fInComment = TRUE;
			continue;
		}
		
		// Skip whitespace, and also leading commas.

		if (_istspace(cCurrentChar) || (cCurrentChar == _T(',') && iCharIndex == 0))
			continue;

		if (cCurrentChar != strVerify[iCharIndex])
		{
			pFile->Seek((LONG)dwPosition, CFile::begin);
			return FALSE;
		}

		iCharIndex++;
	}

	return TRUE;
}

//-----------------------------------------------------------------------------
// Create a new category, and return the ID for the category.
//-----------------------------------------------------------------------------

DWORD CTemplateFileFunctions::CreateCategory(CDataGatherer * pGatherer, DWORD dwParentID, DWORD dwPrevID)
{
	DWORD				dwID = pGatherer->m_dwNextFreeID;
	INTERNAL_CATEGORY *	pInternalCat;
	INTERNAL_CATEGORY *	pPreviousCat;
	CString				strName;

	pInternalCat = new INTERNAL_CATEGORY;
	if (!pInternalCat)
		return 0;

	pInternalCat->m_fListView	= TRUE;
	pInternalCat->m_dwID		= dwID;
	pInternalCat->m_dwParentID	= dwParentID;
	pInternalCat->m_dwPrevID	= dwPrevID;

	if (dwPrevID)
	{
		pPreviousCat = pGatherer->GetInternalRep(dwPrevID);
		if (pPreviousCat)
			pPreviousCat->m_dwNextID = dwID;
	}

	pGatherer->m_mapCategories.SetAt((WORD)dwID, (void *) pInternalCat);
	pGatherer->m_dwNextFreeID++;

	return dwID;
}

//-----------------------------------------------------------------------------
// This method returns the next keyword in the file. Any whitespace or
// punctuation is skipped until an alphanumeric character is read. The keyword
// returned is the string starting with this character until whitespace or
// punctuation is encountered. Note: it is very important that this function
// returns the file to the state it was in when the function started, with
// the current position restored.
//
// TBD: inefficient
//-----------------------------------------------------------------------------

BOOL CTemplateFileFunctions::GetKeyword(CFile * pFile, CString & strKeyword)
{
	CString	strTemp = CString("");
	DWORD	dwPosition = pFile->GetPosition();
	TCHAR	cLastChar, cCurrentChar = _T('\0');
	BOOL	fInComment = FALSE;

	// Skip over whitespace characters until we reach an alphanumeric char.

	do
	{
		// Save the last character read, since the comment token ("//") is
		// two characters long.

		cLastChar = cCurrentChar;

		// Read the next character in the file.

		if (pFile->Read((void *) &cCurrentChar, sizeof(TCHAR)) != sizeof(TCHAR))
			return FALSE;

		// If we're in a comment, and the character we just read isn't a new line,
		// we want to ignore it.

		if (fInComment)
		{
			if (cCurrentChar == _T('\n'))
				fInComment = FALSE;
			continue;
		}

		// Check to see if we've started into a comment.

		if (cCurrentChar == _T('/'))
		{
			if (cLastChar == _T('/'))
				fInComment = TRUE;
			continue;
		}
	} while (_istspace(cCurrentChar) || cCurrentChar == _T('/') || fInComment);
		
	// Read the keyword while it's alphanumeric.

	if (_istalnum(cCurrentChar))
		do
		{
			strTemp += CString(cCurrentChar);

			if (pFile->Read((void *) &cCurrentChar, sizeof(TCHAR)) != sizeof(TCHAR))
				return FALSE;
		} while (_istalnum(cCurrentChar));

	// Reset the file, set the keyword and return.

	pFile->Seek((LONG)dwPosition, CFile::begin);
	strKeyword = strTemp;
	return !strTemp.IsEmpty();
}

//-----------------------------------------------------------------------------
// This method reads in a "column" line from the file, adding the appropriate
// entries for the columns into the category referenced by dwID. The column
// line contains a bunch of fields in a list.
//-----------------------------------------------------------------------------

BOOL CTemplateFileFunctions::ReadColumnInfo(CFile * pFile, CDataGatherer * pGatherer, DWORD dwID)
{
	CString	strTemp;

	if (!VerifyAndAdvanceFile(pFile, CString(COLUMN_KEYWORD) + CString("(")))
	{
		TRACE0("CTemplateFileFunctions::ReadColumnInfo() Verify.. failed on column keyword\n");
		return FALSE;
	}

	// Get the internal category referenced by dwID.

	INTERNAL_CATEGORY * pCategory = pGatherer->GetInternalRep(dwID);
	if (!pCategory)
		return FALSE;

	// We only allow one column specifier list per node.

	if (pCategory->m_pColSpec)
	{
		TRACE0("CTemplateFileFunctions::ReadColumnInfo() already column information present\n");
		return FALSE;
	}

	// While we are still reading fields from the file, keep adding to the column list.

	GATH_FIELD * pNewField = new GATH_FIELD;
	if (pNewField == NULL)
		return FALSE;

	while (ReadField(pFile, *pNewField))
	{
		if (pCategory->m_pColSpec == NULL)
			pCategory->m_pColSpec = pNewField;
		else
		{
			// Scan to the last field in the linespec.m_pFields list, and insert the new field.

			GATH_FIELD * pFieldScan = pCategory->m_pColSpec;
			while (pFieldScan->m_pNext)
				pFieldScan = pFieldScan->m_pNext;
			pFieldScan->m_pNext = pNewField;
		}

		// Parse the width out of the column caption.

		if (pNewField->m_strFormat.ReverseFind(_T(',')) != -1)
		{
			strTemp = pNewField->m_strFormat.Right(pNewField->m_strFormat.GetLength() - pNewField->m_strFormat.ReverseFind(_T(',')) - 1);
			pNewField->m_usWidth = (unsigned short) atoi(strTemp);
			pNewField->m_strFormat = pNewField->m_strFormat.Left(pNewField->m_strFormat.GetLength() - strTemp.GetLength() - 1);
		}
		else
		{
			ASSERT(FALSE);
			pNewField->m_usWidth = (unsigned short) 80;
		}
		
		// Parse off any remaining information in the column label (the label ends
		// with [name, n], when n is the width, and name is the ID for the column
		// which should not be displayed).

		if (pNewField->m_strFormat.ReverseFind(_T('[')) != -1)
			pNewField->m_strFormat = pNewField->m_strFormat.Left(pNewField->m_strFormat.ReverseFind(_T('[')) - 1);

		// Read the sorting type from the file.

		if (ReadArgument(pFile, strTemp))
		{
			if (strTemp.CompareNoCase(CString(_T(SORT_LEXICAL))) == 0)
				pNewField->m_sort = LEXICAL;
			else if (strTemp.CompareNoCase(CString(_T(SORT_VALUE))) == 0)
				pNewField->m_sort = BYVALUE;
			else
				pNewField->m_sort = NOSORT;
		}
		else
		{
			TRACE0("CTemplateFileFunctions::ReadColumnInfo() couldn't read column sorting\n");
			return FALSE;
		}

		// Read the complexity (BASIC or ADVANCED) from the file.

		if (ReadArgument(pFile, strTemp))
		{
			if (strTemp.CompareNoCase(CString(_T(COMPLEXITY_ADVANCED))) == 0)
				pNewField->m_datacomplexity = ADVANCED;
			else
				pNewField->m_datacomplexity = BASIC;
		}
		else
		{
			TRACE0("CTemplateFileFunctions::ReadColumnInfo() couldn't read data complexity\n");
			return FALSE;
		}

		pNewField = new GATH_FIELD;
		if (pNewField == NULL)
			return FALSE;
	}

	delete pNewField;

	if (!VerifyAndAdvanceFile(pFile, CString(")")))
	{
		TRACE0("CTemplateFileFunctions::ReadColumnInfo() Verify.. failed on \")\"\n");
		return FALSE;
	}

	return TRUE;
}

//-----------------------------------------------------------------------------
// Read in the information for a single line. Add the line to the internal
// representation of the category. TBD: inefficient, since this will be
// called multiple times and the line list will need to be scanned to the
// end each time.
//-----------------------------------------------------------------------------

GATH_LINESPEC * CTemplateFileFunctions::ReadLineInfo(CFile * pFile, CDataGatherer * /* pGatherer */)
{

	if (!VerifyAndAdvanceFile(pFile, CString(LINE_KEYWORD) + CString("(")))
	{
		TRACE0("CTemplateFileFunctions::ReadLineInfo() Verify.. failed on line keyword\n");
		return NULL;
	}

	// Declare a line specification variable to store the line info.

	GATH_LINESPEC * pNewLineSpec = new GATH_LINESPEC;
	if (pNewLineSpec == NULL)
		return NULL;

	// While we are still reading fields from the file, keep adding to the column list.
	// TBD: inefficient, repeated scans through linespec.m_pFields list.

	GATH_FIELD * pNewField = new GATH_FIELD;
	if (pNewField == NULL)
	{
		delete pNewLineSpec;
		return NULL;
	}

	// Read in the complexity (BASIC or ADVANCED) for this line.

	CString strTemp;
	if (ReadArgument(pFile, strTemp))
	{
		if (strTemp.CompareNoCase(CString(_T(COMPLEXITY_ADVANCED))) == 0)
			pNewLineSpec->m_datacomplexity = ADVANCED;
		else
			pNewLineSpec->m_datacomplexity = BASIC;
	}
	else
	{
		TRACE0("CTemplateFileFunctions::ReadLineInfo() couldn't read complexity\n");
		return FALSE;
	}

	while (ReadField(pFile, *pNewField))
	{
		if (pNewLineSpec->m_pFields == NULL)
			pNewLineSpec->m_pFields = pNewField;
		else
		{
			// Scan to the last field in the linespec.m_pFields list, and insert the new field.

			GATH_FIELD * pFieldScan = pNewLineSpec->m_pFields;
			while (pFieldScan->m_pNext)
				pFieldScan = pFieldScan->m_pNext;
			pFieldScan->m_pNext = pNewField;
		}

		pNewField = new GATH_FIELD;
		if (pNewField == NULL)
		{
			delete pNewLineSpec;
			return NULL;
		}
	}

	delete pNewField;

	if (!VerifyAndAdvanceFile(pFile, CString(")")))
	{
		TRACE0("CTemplateFileFunctions::ReadLineInfo() Verify.. failed on \")\"\n");
		delete pNewLineSpec;
		return NULL;
	}

	return pNewLineSpec;
}

//-----------------------------------------------------------------------------
// This method simply reads an argument (as string) from the file, until a
// punctuation or whitespace character is found. If a quote mark is found,
// all characters are included in the string until another quote is found.
// TBD: currently no way to have a quote mark in the string.
//-----------------------------------------------------------------------------

BOOL CTemplateFileFunctions::ReadArgument(CFile * pFile, CString & strSource)
{
	BOOL	fInQuote = FALSE, fInComment = FALSE;
	CString	strTemp;
	TCHAR	cLastChar, cCurrentChar = _T('\0');

	// Skip over characters until we reach an alphanumeric char. If we find
	// a close paren, then we've reached the end of the argument list and
	// should return FALSE.

	do
	{
		// Save the last character read, since the comment token ("//") is
		// two characters long.

		cLastChar = cCurrentChar;

		// Read the next character in the file.

		if (pFile->Read((void *) &cCurrentChar, sizeof(TCHAR)) != sizeof(TCHAR))
		{
			TRACE0("CTemplateFileFunctions::ReadArgument() couldn't read character\n");
			return FALSE;
		}

		// If we're in a comment, and the character we just read isn't a new line,
		// we want to ignore it.

		if (fInComment)
		{
			if (cCurrentChar == _T('\n'))
				fInComment = FALSE;
			continue;
		}

		// Check to see if we've started into a comment.

		if (cCurrentChar == _T('/'))
		{
			if (cLastChar == _T('/'))
				fInComment = TRUE;
			continue;
		}

		if (cCurrentChar == _T(')'))
			return FALSE;
	} while (!_istalnum(cCurrentChar) && cCurrentChar != _T('"'));

	// Read characters into the string until we find whitespace or punctuation.

	do
	{
		if (cCurrentChar == _T('"'))
		{
			fInQuote = !fInQuote;
			continue;
		}

		if (_istalnum(cCurrentChar) || fInQuote)
			strTemp += CString(cCurrentChar);
		else
			break;
	} while (pFile->Read((void *) &cCurrentChar, sizeof(TCHAR)) == sizeof(TCHAR));

	// If the last character read (the one which terminated this argument) was
	// not a comma, then back the file up so that the character can be re-read
	// and interpreted.

	if (cCurrentChar != _T(','))
		pFile->Seek(-(LONG)sizeof(TCHAR), CFile::current);

	strSource = strTemp;
	return TRUE;
}

//-----------------------------------------------------------------------------
// A field consists of a source string, followed by a format string, followed
// by a list of zero or more arguments.
//-----------------------------------------------------------------------------

BOOL CTemplateFileFunctions::ReadField(CFile * pFile, GATH_FIELD & field)
{
	// Advance past the field keyword and read the two source and format strings.

	if (!VerifyAndAdvanceFile(pFile, CString(FIELD_KEYWORD) + CString("(")))
		return FALSE;

	if (!ReadArgument(pFile, field.m_strSource))
	{
		TRACE0("CTemplateFileFunctions::ReadField() ReadArgument failed on source\n");
		return FALSE;
	}

	if (!ReadArgument(pFile, field.m_strFormat))
	{
		TRACE0("CTemplateFileFunctions::ReadField() ReadArgument failed on format\n");
		return FALSE;
	}

	// Read arguments until there are no more, building them into a list of
	// arguments stored by the FIELD struct.

	GATH_VALUE		arg;
	GATH_VALUE *	pArg = NULL;

	while (ReadArgument(pFile, arg.m_strText))
	{
		if (pArg == NULL)
		{
			field.m_pArgs = new GATH_VALUE;
			if (field.m_pArgs == NULL)
			{
				TRACE0("CTemplateFileFunctions::ReadField() field.m_pArgs allocation failed\n");
				return FALSE;
			}
			*field.m_pArgs = arg;
			pArg = field.m_pArgs;
		}
		else
		{
			pArg->m_pNext = new GATH_VALUE;
			if (pArg->m_pNext == NULL)
			{
				TRACE0("CTemplateFileFunctions::ReadField() pArg->m_pNext allocation failed\n");
				return FALSE;
			}
			*pArg->m_pNext = arg;
			pArg = pArg->m_pNext;
		}
	}

	return TRUE;
}

//-----------------------------------------------------------------------------
// Read an enumline(){} block. This construct is used to group lines together
// which are enumerated for each instance of a class. A line is added to 
// the parent node's list of lines with a m_strEnumerateClass equal to the 
// class to be enumerated. The added line structure will have children lines 
// (the lines to be enumerated) referenced by m_pEnumeratedGroup.
//-----------------------------------------------------------------------------

GATH_LINESPEC * CTemplateFileFunctions::ReadLineEnumRecursive(CFile * pFile, CDataGatherer * pGatherer)
{
	if (!VerifyAndAdvanceFile(pFile, CString(ENUMLINE_KEYWORD) + CString("(")))
	{
		TRACE0("CTemplateFileFunctions::ReadLineEnumRecursive() Verify.. failed on enum line keyword\n");
		return NULL;
	}

	// Declare a line specification variable to store the line info.

	GATH_LINESPEC * pNewLineSpec = new GATH_LINESPEC;
	if (pNewLineSpec == NULL)
		return NULL;

	// Read in the enumerated class variable.

	if (!ReadArgument(pFile, pNewLineSpec->m_strEnumerateClass))
	{
		delete pNewLineSpec;
		TRACE0("CTemplateFileFunctions::ReadLineEnumRecursive() ReadArgument failed on enumerate class\n");
		return NULL;
	}

	// Read in the variable (zero or more) number of fields for the constraints.

	GATH_FIELD * pNewField = new GATH_FIELD;
	if (pNewField == NULL)
		return NULL;

	while (ReadField(pFile, *pNewField))
	{
		if (pNewLineSpec->m_pConstraintFields == NULL)
			pNewLineSpec->m_pConstraintFields = pNewField;
		else
		{
			// Add the newly read field to the end of the field list. Note,
			// this is inefficient, and should be fixed. (TBD)

			GATH_FIELD * pFieldScan = pNewLineSpec->m_pConstraintFields;
			while (pFieldScan->m_pNext)
				pFieldScan = pFieldScan->m_pNext;
			pFieldScan->m_pNext = pNewField;
		}

		pNewField = new GATH_FIELD;
		if (pNewField == NULL)
			return NULL;
	}

	delete pNewField;

	// Advance past the close paren and the (necessary) open bracket.

	if (!VerifyAndAdvanceFile(pFile, CString("){")))
	{
		TRACE0("CTemplateFileFunctions::ReadLineEnumRecursive() Verify.. failed on \"){\"\n");
		delete pNewLineSpec;
		return NULL;
	}

	// Read the contents of the block (should be all lines or enumlines).

	CString strKeyword;
	while (GetKeyword(pFile, strKeyword))
	{
		if (strKeyword.CompareNoCase(CString(LINE_KEYWORD)) == 0)
		{
			GATH_LINESPEC * pNewSubLine = ReadLineInfo(pFile, pGatherer);
			if (pNewSubLine == NULL)
			{
				delete pNewLineSpec;
				return NULL;
			}

			if (pNewLineSpec->m_pEnumeratedGroup == NULL)
				pNewLineSpec->m_pEnumeratedGroup = pNewSubLine;
			else
			{
				GATH_LINESPEC * pLineSpec = pNewLineSpec->m_pEnumeratedGroup;
				while (pLineSpec->m_pNext)
					pLineSpec = pLineSpec->m_pNext;
				pLineSpec->m_pNext = pNewSubLine;
			}
		}
		else if (strKeyword.CompareNoCase(CString(ENUMLINE_KEYWORD)) == 0)
		{
			GATH_LINESPEC * pNewSubLine = ReadLineEnumRecursive(pFile, pGatherer);
			if (pNewSubLine == NULL)
			{
				delete pNewLineSpec;
				return NULL;
			}

			if (pNewLineSpec->m_pEnumeratedGroup == NULL)
				pNewLineSpec->m_pEnumeratedGroup = pNewSubLine;
			else
			{
				GATH_LINESPEC * pLineSpec = pNewLineSpec->m_pEnumeratedGroup;
				while (pLineSpec->m_pNext)
					pLineSpec = pLineSpec->m_pNext;
				pLineSpec->m_pNext = pNewSubLine;
			}
		}
		else
		{
			TRACE0("CTemplateFileFunctions::ReadLineEnumRecursive(), bad keyword in enumlines block\n");
			delete pNewLineSpec;
			return NULL;
		}
	}

	if (!VerifyAndAdvanceFile(pFile, CString("}")))
	{
		TRACE0("CTemplateFileFunctions::ReadLineEnumRecursive() Verify.. failed on \"}\"\n");
		delete pNewLineSpec;
		return NULL;
	}

	return pNewLineSpec;
}

//-----------------------------------------------------------------------------
// This function is used to adjust the tree of loaded categories based on 
// a string (which indicates what categories should be included). The
// following rules are applied:
//
// 1. By default, no categories are included.
// 2. If "+all" is in the string, all categories are included.
// 3. If "+cat" is in the string, the cat, all its children and ancestors
//    are included.
// 4. If "-cat" is in the string, the cat and all its children are excluded.
//
// First this function must recurse through the tree, marking each node
// with whether it should be deleted or not. Then the nodes are actually
// removed from the tree. Yippee skip.
//-----------------------------------------------------------------------------

BOOL CTemplateFileFunctions::ApplyCategories(const CString & strCategories, CDataGatherer * pGatherer)
{
	CString strLoweredCats(strCategories);
	strLoweredCats.MakeLower();
	
	BOOL fDefaultAdd = (strLoweredCats.Find(CString(_T("+all"))) > -1);
	RecurseTreeCategories(fDefaultAdd, pGatherer->m_dwRootID, strLoweredCats, pGatherer);
	RemoveExtraCategories(pGatherer->m_dwRootID, pGatherer);

	return TRUE;
}

//-----------------------------------------------------------------------------
// Remove all the categories from the tree which aren't marked as "include".
//-----------------------------------------------------------------------------

void CTemplateFileFunctions::RemoveExtraCategories(DWORD dwID, CDataGatherer * pGatherer)
{
	if (dwID == 0)
		return;

	INTERNAL_CATEGORY *pInternal = pGatherer->GetInternalRep(dwID);
	if (pInternal == NULL)
		return;

	// If this category is not marked as included, delete it and
	// all the children.

	if (!pInternal->m_fIncluded)
	{
		DWORD dwChildID = pInternal->m_dwChildID;
		DWORD dwNextChild = 0;
		while (dwChildID)
		{
			INTERNAL_CATEGORY *pChild = pGatherer->GetInternalRep(dwChildID);
			if (pChild)
				dwNextChild = pChild->m_dwNextID;
			else
				dwNextChild = 0;
			RemoveExtraCategories(dwChildID, pGatherer);
			dwChildID = dwNextChild;
		}
		pGatherer->m_mapCategories.SetAt((WORD)pInternal->m_dwID, (void *) NULL);
		delete pInternal;

		return;
	}

	// Otherwise, if we are to save this category, scan through all the
	// children, recursively calling this function on each one, and
	// constructing a new list of children which are included.

	INTERNAL_CATEGORY * pLastGood = NULL;
	DWORD dwChildID = pInternal->m_dwChildID;
	DWORD dwNextChild = 0;
	while (dwChildID)
	{
		INTERNAL_CATEGORY *pChild = pGatherer->GetInternalRep(dwChildID);
		if (pChild)
		{
			dwNextChild = pChild->m_dwNextID;
			if (!pChild->m_fIncluded)
			{
				// We're removing this child. If this is the first child,
				// set the pInternal field, otherwise, remove it from
				// the list of children.

				if (dwChildID == pInternal->m_dwChildID)
					pInternal->m_dwChildID = dwNextChild;
				else if (pLastGood) // this better be true
					pLastGood->m_dwNextID = dwNextChild;
			}
			else
				pLastGood = pChild;
			RemoveExtraCategories(dwChildID, pGatherer);
		}
		else
			dwNextChild = 0;
		dwChildID = dwNextChild;
	}
}

//-----------------------------------------------------------------------------
// This function recursively processes the categories to determine which
// ones should be included.
//-----------------------------------------------------------------------------

BOOL CTemplateFileFunctions::RecurseTreeCategories(BOOL fParentOK, DWORD dwID, const CString & strCategories, CDataGatherer * pGatherer)
{
	if (dwID == 0)
		return FALSE;

	INTERNAL_CATEGORY *pInternal = pGatherer->GetInternalRep(dwID);
	if (pInternal == NULL)
		return FALSE;

	// Default to using the same status as the parent category.

	pInternal->m_fIncluded = fParentOK;

	// If we are added or removed by the category string, change our status.

	CString strCategoryID(pInternal->m_strIdentifier);
	strCategoryID.MakeLower();
	
	int iIndex = strCategories.Find(strCategoryID);
	if (iIndex > 0)
	{
		// Make sure that we aren't matching part of a longer string,
		// by making sure this is either the last string, or a + or -
		// immediately follows.

		if ((iIndex + strCategoryID.GetLength()) >= strCategories.GetLength() ||
			strCategories[iIndex + strCategoryID.GetLength()] == _T('+') ||
			strCategories[iIndex + strCategoryID.GetLength()] == _T('-'))
		{
			if (strCategories[iIndex - 1] == _T('+'))
				pInternal->m_fIncluded = TRUE;
			else if (strCategories[iIndex - 1] == _T('-'))
				pInternal->m_fIncluded = FALSE;
		}
	}

	// Now, for each child of this node, recurse using this node's status.
	// If any of the children return TRUE for an included status, we must
	// modify this node to TRUE.

	DWORD	dwChildID = pInternal->m_dwChildID;
	BOOL	fChildIncluded = FALSE;
	while (dwChildID)
	{
		fChildIncluded |= RecurseTreeCategories(pInternal->m_fIncluded, dwChildID, strCategories, pGatherer);
		INTERNAL_CATEGORY *pChild = pGatherer->GetInternalRep(dwChildID);
		if (pChild)
			dwChildID = pChild->m_dwNextID;
		else
			dwChildID = 0;
	}

	pInternal->m_fIncluded |= fChildIncluded;
	return pInternal->m_fIncluded;
}

//-----------------------------------------------------------------------------
// This function is used to load template information from DLLs (the new
// method, to allow resources to be selected on the fly). The HKEY passed in
// is the base key for the entries which describe the DLLs containing template
// information. It's enumerated for subkeys, each of which is used to load a
// DLL. A standard entry point for the DLL is used, and the template
// information retrieved and passed into the file parsing functions.
//-----------------------------------------------------------------------------

typedef DWORD (__cdecl *pfuncGetTemplate)(void ** ppBuffer);
extern "C" DWORD __cdecl GetTemplate(void ** ppBuffer);

BOOL CTemplateFileFunctions::LoadTemplateDLLs(HKEY hkeyBase, CDataGatherer * pGatherer)
{
	CStringList strlistTemplates;

	// Add a keyword to the list of DLLs which indicates that we should add
	// information from ourselves (we don't want to just add ourselves normally,
	// since we would do a LoadLibrary on ourselves, which opens up can of
	// unnecessary initializion worms). So, we'll just add "this" to the string list.

	strlistTemplates.AddTail(_T("this"));

	// Enumerate the registry key, adding each subkey to a list of DLL names to
	// process (the DLL path is in the default value of the subkey).

	if (hkeyBase)
	{
		TCHAR szName[64], szValue[MAX_PATH];
		DWORD dwIndex = 0;
		DWORD dwLength = sizeof(szName) / sizeof(TCHAR);
		
		while (ERROR_SUCCESS == RegEnumKeyEx(hkeyBase, dwIndex++, szName, &dwLength, NULL, NULL, NULL, NULL))
		{
			dwLength = sizeof(szValue) / sizeof(TCHAR);
			if (ERROR_SUCCESS == RegQueryValue(hkeyBase, szName, szValue, (long *)&dwLength))
				if (*szValue)
					strlistTemplates.AddTail(szValue);
				
			dwLength = sizeof(szName) / sizeof(TCHAR);
		}
	}

	// For each DLL in the list of templates, we'll attempt to get the template info.

	CString				strFileName;
	HINSTANCE			hinst;
	DWORD				dwBufferSize;
	pfuncGetTemplate	pfunc;
	unsigned char *		pBuffer;
	CMemFile			memfile;

	while (!strlistTemplates.IsEmpty())
	{
		strFileName = strlistTemplates.RemoveHead();

		// Try to load the library, and get a pointer to the entry point.

		if (strFileName.Compare(_T("this")) == 0)
		{
			hinst = NULL;
			pfunc = &GetTemplate;
		}
		else
		{
			hinst = LoadLibrary(strFileName);
			if (hinst == NULL)
				continue;

			pfunc = (pfuncGetTemplate) GetProcAddress(hinst, "GetTemplate");
			if (pfunc == NULL)
			{
				FreeLibrary(hinst);
				continue;
			}
		}

		// Call the DLL function with a NULL parameter to get the size of the buffer.

		dwBufferSize = (*pfunc)((void **)&pBuffer);
		if (dwBufferSize && pBuffer)
		{
			memfile.Attach((BYTE *)pBuffer, dwBufferSize, 0);
			CTemplateFileFunctions::ReadTemplateFile(&memfile, pGatherer);
			memfile.Detach();
			(void)(*pfunc)(NULL); // calling the exported DLL function with NULL frees its buffers
		}

		if (hinst != NULL)
		{
			FreeLibrary(hinst);
			hinst = NULL;
		}
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\uni2utf.c ===
/*
 *  UNI2UTF -- Unicode to/from UTF conversions
 *
 *  Copyright (C) 1996, Microsoft Corporation.  All rights reserved.
 *
 *  History:
 *
 *      10-14-96    msliger     Created.
 */

#include <stdio.h>

#include "uni2utf.h"        /* prototype verification */


/*
 *  Unicode2UTF()
 *
 *  This function converts any 0-terminated Unicode string to the corresponding
 *  nul-terminated UTF string, and returns a pointer to the resulting string.
 *  The pointer references a single, static internal buffer, so the result will
 *  be destroyed on the next call.
 *
 *  If the generated UTF string would be too long, NULL is returned.
 */

char *Unicode2UTF(const wchar_t *unicode)
{
    static char utfbuffer[MAX_UTF_LENGTH + 4];
    int utfindex = 0;

    while (*unicode != 0)
    {
        if (utfindex >= MAX_UTF_LENGTH)
        {
            return(NULL);
        }

        if (*unicode < 0x0080)
        {
            utfbuffer[utfindex++] = (char) *unicode;
        }
        else if (*unicode < 0x0800)
        {
            utfbuffer[utfindex++] = (char) (0xC0 + (*unicode >> 6));
            utfbuffer[utfindex++] = (char) (0x80 + (*unicode & 0x3F));
        }
        else
        {
            utfbuffer[utfindex++] = (char) (0xE0 + (*unicode >> 12));
            utfbuffer[utfindex++] = (char) (0x80 + ((*unicode >> 6) & 0x3F));
            utfbuffer[utfindex++] = (char) (0x80 + (*unicode & 0x3F));
        }

        unicode++;
    }

    utfbuffer[utfindex] = '\0';

    return(utfbuffer);
}


/*
 *  UTF2Unicode()
 *
 *  This function converts a valid UTF string into the corresponding unicode string,
 *  and returns a pointer to the resulting unicode.  The pointer references a single,
 *  internal static buffer, which will be destroyed on the next call.
 *
 *  If the generated unicode string would be too long, or if the UTF string contains
 *  any illegal UTF values, NULL is returned.
 */

wchar_t *UTF2Unicode(const char *utfString)
{
    static wchar_t unicodebuffer[MAX_UNICODE_LENGTH + 1];
    int unicodeindex = 0;
    int c;

    while (*utfString != 0)
    {
        if (unicodeindex >= MAX_UNICODE_LENGTH)
        {
            return(NULL);
        }

        c = (*utfString++ & 0x00FF);

        if (c < 0x0080)
        {
            unicodebuffer[unicodeindex] = (unsigned short) c;
        }
        else if (c < 0x00C0)
        {
            return(NULL);   /* 0x0080..0x00BF illegal */
        }
        else if (c < 0x00E0)
        {
            unicodebuffer[unicodeindex] = (unsigned short) ((c & 0x001F) << 6);

            c = (*utfString++ & 0x00FF);

            if ((c < 0x0080) || (c > 0x00BF))
            {
                return(NULL);   /* trail must be 0x0080..0x00BF */
            }

            unicodebuffer[unicodeindex] |= (c & 0x003F);
        }
        else if (c < 0x00F0)
        {
            unicodebuffer[unicodeindex] = (unsigned short) ((c & 0x000F) << 12);

            c = (*utfString++ & 0x00FF);

            if ((c < 0x0080) || (c > 0x00BF))
            {
                return(NULL);   /* trails must be 0x0080..0x00BF */
            }

            unicodebuffer[unicodeindex] |= ((c & 0x003F) << 6);

            c = (*utfString++ & 0x00FF);

            if ((c < 0x0080) || (c > 0x00BF))
            {
                return(NULL);   /* trails must be 0x0080..0x00BF */
            }

            unicodebuffer[unicodeindex] |= (c & 0x003F);
        }
        else
        {
            return(NULL);       /* lead can't be > 0x00EF */
        }

        unicodeindex++;
    }

    unicodebuffer[unicodeindex] = 0;

    return(unicodebuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\uni2utf.h ===
/* uni2utf.h */
/* Copyright (c) 1998-1999 Microsoft Corporation */

#define     MAX_UTF_LENGTH          200     /* arbitrary */
#define     MAX_UNICODE_LENGTH      200     /* arbitrary */

extern char *Unicode2UTF(const wchar_t *unicodeString);
extern wchar_t *UTF2Unicode(const char *utfString);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\viewobj.h ===
// ResltObj.h	The classes for result objects.
//
// Copyright (c) 1998-1999 Microsoft Corporation

#pragma once
#define MSINFO_RESLTOBJ_H

#include <afxtempl.h>
#include "DataSrc.h"
#include "StrList.h"
#include "resource.h"
#include "resrc1.h"

/*
 * CViewObject - A single view item (scope or result).
 *
 * History:	a-jsari		10/3/97		Initial version
 */
class CViewObject {
public:
	virtual	~CViewObject() {}

	enum ViewType { CATEGORY, DATUM, EXTENSION_ROOT };

	virtual LPCWSTR			GetTextItem(int nCol = 0) = 0;
	virtual ViewType		GetType() const = 0;
	virtual CFolder			*Parent() const = 0;
	CFolder					*Category() const { return m_pCategory; }

protected:
	CViewObject(CFolder *pfolSelection)	:m_pCategory(pfolSelection)	{ }
	CFolder					*m_pCategory;
};

/*
 * CCategoryObject - A single category.
 *
 * History:	a-jsari		10/3/97		Initial version
 */
class CCategoryObject : public CViewObject {
public:
	CCategoryObject(CFolder *pfolSelection) :CViewObject(pfolSelection)		{ }
	virtual ~CCategoryObject() {}

	virtual LPCWSTR			GetTextItem(int nCol = 0);
	virtual ViewType		GetType() const		{ return CATEGORY; }
	virtual CFolder			*Parent() const		{ return m_pCategory->GetParentNode(); }
private:
	CCategoryObject();
	CString			m_strElement;
};

/*
 * CDatumObject - A single datum item.
 *
 * History:	a-jsari		10/3/97		Initial version
 */
class CDatumObject : public CViewObject {
public:
	CDatumObject(CFolder *pfolSelection, int nIndex)
		:CViewObject(pfolSelection), m_nRow(nIndex) {	ASSERT(pfolSelection->GetType() != CDataSource::OCX); }
	virtual ~CDatumObject() {}

	virtual LPCWSTR			GetTextItem(int nCol = 0);
	virtual ViewType		GetType() const		{ return DATUM; }
	virtual CFolder			*Parent() const		{ return m_pCategory; }
	virtual DWORD			GetSortIndex(int nCol = 0) const;

private:
	CStringValues	m_szValues;
	int				m_nRow;
};

/*
 * CExtensionRootObject - The unique
 *
 * History: a-jsari		1/7/98		Initial version.
 */
class CExtensionRootObject : public CViewObject {
public:
	CExtensionRootObject(CFolder *pfolSelection);

	virtual LPCWSTR			GetTextItem(int nCol = 0);
	virtual ViewType		GetType() const		{ return EXTENSION_ROOT; }
	virtual CFolder			*Parent() const		{ return NULL; }
private:
	CString		m_strTitle;
};

/* 
 * GetTextItem - Return the text result value for a result field item.
 *
 * History:	a-jsari		10/5/97		Initial version
 */
inline LPCWSTR CDatumObject::GetTextItem(int nCol)
{
	BOOL		fReturn;

	//	OCX Folders should not have this called for them.
	ASSERT(m_pCategory->GetType() != CDataSource::OCX);
	fReturn = dynamic_cast<CListViewFolder *>(m_pCategory)->GetSubElement(m_nRow, nCol,
			m_szValues[nCol]);
	return fReturn ? (LPCWSTR)m_szValues[nCol] : NULL;
}

/*
 * GetSortIndex - Return the sort index associated with the current row and column.
 *
 * History:	a-jsari		12/1/97		Initial version
 */
inline DWORD CDatumObject::GetSortIndex(int nCol) const
{
	DWORD		iSort;
	CString		szValue;

	ASSERT(m_pCategory->GetType() != CDataSource::OCX);
	iSort = dynamic_cast<CListViewFolder *>(m_pCategory)->GetSortIndex(m_nRow, nCol);
	return iSort;
}

/*
 * GetTextItem - Return the text result values for a category item.
 *
 * History:	a-jsari		10/5/97		Initial version
 */
inline LPCWSTR CCategoryObject::GetTextItem(int nCol)
{
	BOOL		fReturn;

	if (nCol > 0) {
		return L"";
	} else {
		fReturn = m_pCategory->GetName(m_strElement);
		return m_strElement;
	}
}

/*
 * CExtensionRootObject - Load the extension root node name from the resources.
 *
 * History:	a-jsari		1/7/98		Initial version.
 */
inline CExtensionRootObject::CExtensionRootObject(CFolder *pfolSelection)
:CViewObject(pfolSelection)
{
	AFX_MANAGE_STATE(::AfxGetStaticModuleState());
	VERIFY(m_strTitle.LoadString(IDS_EXTENSIONNODENAME));
}

/*
 * GetTextItem - Return the root extension object's text value.
 *
 * History:	a-jsari		1/7/98		Initial version.
 */
inline LPCWSTR CExtensionRootObject::GetTextItem(int nCol)
{
	AFX_MANAGE_STATE(::AfxGetStaticModuleState());
	USES_CONVERSION;

	static CString strCaption(_T(""));
	switch (nCol)
	{
	case 0:
		strCaption = m_strTitle;
		break;

	case 1:
		strCaption.LoadString(IDS_ROOT_NODE_TYPE);
		break;

	case 2:
		strCaption.LoadString(IDS_ROOT_NODE_DESCRIPTION);
		break;

	default:
		ASSERT(FALSE);
	}

	return T2CW((LPCTSTR)strCaption);
}

/*
 * CViewObjectList - A list of CViewObject items.
 *
 * History:	a-jsari		10/8/97		Initial version
 */
class CViewObjectList {
public:
	//	60 is the size of a resize unit; when it resizes, it does it in
	//	increments of 60
	CViewObjectList() :m_lstViewObjects(60) {}
	~CViewObjectList() { Clear(); }
	void	Add(CViewObject *pvoNode) { (void) m_lstViewObjects.AddHead(pvoNode); }
	void	Clear();
private:
	CList<CViewObject *, CViewObject * &>		m_lstViewObjects;
};

/*
 * ~CViewObjectList - Delete all CViewObject pointers.
 *
 * History:	a-jsari		10/8/97		Initial version
 */
inline void CViewObjectList::Clear()
{
	CViewObject		*pvoIterator;

	while (!m_lstViewObjects.IsEmpty()) {
		pvoIterator = m_lstViewObjects.RemoveHead();
		delete pvoIterator;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\v500file.cpp ===
//	File5Src.cpp Implementation of Version 5.00 data file methods.
//
//  Copyright (c) 1998-1999 Microsoft Corporation

#include "DataSrc.h"
#ifndef IDS_V500FILENODE
#include "resource.h"
#endif

#ifndef _UNICODE
#define _ttoupper	toupper
#define _ttolower	tolower
#define _tislower	islower
#define _tisupper	isupper
#else
#define _ttoupper	towupper
#define _ttolower	towlower
#define _tislower	iswlower
#define _tisupper	iswupper
#endif

/*
 * CBufferV500DataSource - Construct the DataSource from a file, which mostly
 *		means constructing all the folder.
 *
 * History:	a-jsari		10/17/97		Initial version
 */
CBufferV500DataSource::CBufferV500DataSource(CMSInfoFile *pFileSink)
:CBufferDataSource(pFileSink)
{
	AFX_MANAGE_STATE(::AfxGetStaticModuleState());
	CBufferFolder	*pFolder;
	CBufferFolder	*pLast;
	unsigned		uReadCase;
	try {
		ReadHeader(pFileSink);
		m_szFileName = pFileSink->GetFileName();
		unsigned	cFolders = 0;
		ReadFolder(pFileSink, (CFolder * &)pLast, NULL);
		//	CFolders read by our ReadFolder are guaranteed to be CBufferFolder's.
		m_RootFolder = pLast;
		do {
			pFileSink->ReadUnsignedInt(uReadCase);

			//	Only switch off the flags, not the extended bits.
			switch (uReadCase & CBufferV500DataSource::MASK) {
			case CBufferV500DataSource::CHILD:
				ReadFolder(pFileSink, (CFolder * &)(pFolder), pLast);
				ASSERT(pLast->m_ChildFolder == NULL);
				pLast->m_ChildFolder = pFolder;
				break;
			case CBufferV500DataSource::NEXT:
				ReadFolder(pFileSink, (CFolder * &)(pFolder), pLast->GetParentNode());
				//	Attach the folder to the tree.
				pLast->m_NextFolder = pFolder;
				break;
			case CBufferV500DataSource::PARENT:
				unsigned	iDepth;
				//	Ascend to the right level in the tree.
				iDepth = (uReadCase & ~CBufferV500DataSource::MASK);
				while (iDepth--) {
					pLast = (CBufferFolder *)pLast->GetParentNode();
				}
				ReadFolder(pFileSink, (CFolder * &)pFolder, pLast->GetParentNode());
				//	Now attach the folder as a sibling at the right level.
				while (pLast->m_NextFolder != NULL) {
					pLast = (CBufferFolder *)pLast->m_NextFolder;
				}
				pLast->m_NextFolder = pFolder;
				break;
			case CBufferV500DataSource::END:
				return;
				break;
			default:
				ThrowFileFormatException();
				break;
			}
			pLast = pFolder;
		//	Never intended to exit until END key is read or an exception occurs.
		} while (TRUE);
	}
	catch (CException *e) {

		CString strMessage, strTitle;
		strMessage.LoadString( IDS_CORRUPTEDFILE);
		strTitle.LoadString( IDS_DESCRIPTION);
		::MessageBox( ::AfxGetMainWnd()->GetSafeHwnd(), strMessage, strTitle, MB_OK);
		delete pFolder;
		throw e;
	}
	catch (...) {
		ASSERT(FALSE);
	}
}

/*
 * ~CBufferDataSource - Destructor.  Does nothing; the file created here
 *		is deleted in the CDataSource destructor.
 *
 * History:	a-jsari		10/17/97		Initial version
 */
CBufferV500DataSource::~CBufferV500DataSource()
{
}

/*
 * GetNodeName - Return in strName the formatted name for the root node.
 *
 * History:	a-jsari		1/16/98		Initial version
 */
BOOL CBufferV500DataSource::GetNodeName(CString &strName)
{
	AFX_MANAGE_STATE(::AfxGetStaticModuleState());

	CString	strFileName	= FileName();
	LPCTSTR szFilePart	= ::_tcsrchr((LPCTSTR)strFileName, '\\');

	ASSERT(szFilePart != NULL);
	if (szFilePart == NULL)
		szFilePart = strFileName;
	else
		++szFilePart;
	strName.Format(IDS_V500FILENODE, szFilePart);
	return TRUE;
}

/*
 * ReadElements - Read all of the element data into our buffers.
 *
 * History:	a-jsari		11/3/97			Initial version
 */
void CBufferV500DataSource::ReadElements(CMSInfoFile *pFileSink, CBufferFolder *pFolder)
{
	pFileSink->ReadUnsignedInt(pFolder->m_cColumns);
	if (pFolder->m_cColumns == 0) {
		pFolder->m_cRows = 0;
		return;
	}
	unsigned		iColumn = pFolder->m_cColumns;
	BYTE			bComplexity;
	DataComplexity	dcComplexity;
	pFolder->m_uWidths.SetSize(iColumn);
	pFolder->m_szColumns.SetSize(iColumn);
	pFolder->m_SortData.SetColumns(iColumn);
	while (iColumn--) {
		unsigned	wSortType;

		pFileSink->ReadUnsignedInt(pFolder->m_uWidths[iColumn]);
		pFileSink->ReadString(pFolder->m_szColumns[iColumn]);
		pFileSink->ReadUnsignedInt(wSortType);
		pFileSink->ReadByte(bComplexity);
		dcComplexity = (DataComplexity)bComplexity;
		if (dcComplexity != BASIC && dcComplexity != ADVANCED)
			dcComplexity = BASIC;
		pFolder->m_dcColumns.SetAtGrow(iColumn, dcComplexity);
		if (pFolder->m_SortData.SetSortType(iColumn, wSortType) == FALSE)
			if (pFolder->m_SortData.SetSortType(iColumn, NOSORT) == FALSE)
				::ThrowFileFormatException();
	}
	pFileSink->ReadUnsignedInt(pFolder->m_cRows);
	pFolder->m_szElements.SetSize(pFolder->m_cRows);
	pFolder->m_SortData.SetRows(pFolder->m_cRows);
	iColumn = pFolder->m_cColumns;
	unsigned	iRow = pFolder->m_cRows;
	//	Size the rows.
	while (iRow--) {
		pFolder->m_szElements[iRow].SetSize(pFolder->m_cColumns);
		pFileSink->ReadByte(bComplexity);
		dcComplexity = (DataComplexity)bComplexity;
		pFolder->m_dcRows.SetAtGrow(iRow, dcComplexity);
	}
	while (iColumn--) {
		iRow = pFolder->m_cRows;
		while (iRow--) {
			pFileSink->ReadString(pFolder->m_szElements[iRow][iColumn]);
		}
		pFolder->m_SortData.ReadSortValues(pFileSink, iColumn);
	}
}

/*
 * ReadFolder - Reads the data of a folder
 *
 * History:	a-jsari		10/17/97		Initial version
 */
void CBufferV500DataSource::ReadFolder(CMSInfoFile *pFileSink, CFolder * &pFolder, CFolder *pParentFolder)
{
	CBufferFolder *pBufferFolder = new CBufferFolder(this, pParentFolder);
	if (pBufferFolder == NULL) ::AfxThrowMemoryException();
	pFileSink->ReadString(pBufferFolder->m_szName);
	ReadElements(pFileSink, pBufferFolder);
	pFolder = pBufferFolder;
}

/*
 * ReadHeader - Read header information for this buffer
 *
 * History:	a-jsari		10/17/97		Initial version
 */
void CBufferV500DataSource::ReadHeader(CMSInfoFile *pFileSink)
{
        LONG  l;
	ASSERT(pFileSink != NULL);
	pFileSink->ReadLong(l);	//	Save time.
        m_tsSaveTime = (ULONG) l;
#ifdef _WIN64
	pFileSink->ReadLong(l);	//	Save time.
        m_tsSaveTime |= ((time_t) l) << 32;
#endif
	CString		szDummy;
	pFileSink->ReadString(szDummy);		//	Network machine name
	pFileSink->ReadString(szDummy);		//	Network user name
}

/*
 * VerifyFileVersion - Read the top two unsigned ints, and verify that they
 *		have the expected values.
 *
 * History:	a-jsari		11/23/97		Initial version
 */
BOOL CBufferV500DataSource::VerifyFileVersion(CMSInfoFile *pFile)
{
	UINT uVersion;
	pFile->ReadUnsignedInt(uVersion);
	ASSERT(uVersion == CMSInfoFile::VERSION_500_MAGIC_NUMBER);
	if (uVersion != CMSInfoFile::VERSION_500_MAGIC_NUMBER)
		return FALSE;
	pFile->ReadUnsignedInt(uVersion);
	ASSERT(uVersion == 0x0500);
	return (uVersion == 0x0500);
}

/*
 * Save - Save initialization information to the IStream passed in.
 *
 * History:	a-jsari		11/13/97		Initial version
 */
HRESULT CBufferV500DataSource::Save(IStream *pStm)
{
	unsigned	wValue;
	ULONG		dwSize;
	HRESULT		hResult;

	USES_CONVERSION;
	do {
		wValue = GetType();
		hResult = pStm->Write(&wValue, sizeof(wValue), &dwSize);
		ASSERT(SUCCEEDED(hResult) && (dwSize == sizeof(wValue)));
		if (FAILED(hResult)) break;
		wValue = m_szFileName.GetLength();
		hResult = pStm->Write(&wValue, sizeof(wValue), &dwSize);
		ASSERT(SUCCEEDED(hResult) && (dwSize == sizeof(wValue)));
		if (FAILED(hResult)) break;
		wValue *= sizeof(WCHAR);
		//	Save the file name as a wide character string to avoid different
		//	types of save filenames.
		hResult = pStm->Write(T2CW((LPCTSTR)m_szFileName), wValue, &dwSize);
		ASSERT(SUCCEEDED(hResult) && (dwSize == wValue));
	} while (FALSE);
	return hResult;
}

/*
 * CaseInsensitiveMatch - Compare two TCHARs without regard to case.
 *
 * History:	a-jsari		12/31/97		Initial version
 */
static inline BOOL CaseInsensitiveMatch(TCHAR aChar, TCHAR bChar)
{
	if (::_tisupper(aChar))
		aChar = ::_ttolower(aChar);
#if 0
	//	We've already guaranteed that the second string is all lowercase.
	if (::_tisupper(bChar))
		bChar = ::_ttolower(bChar);
#endif
	return aChar == bChar;
}

/*
 * FindCaseInsensitive - Like CString::Find, but not case sensitive.
 *
 * History:	a-jsari		12/31/97		Initial version
 */
static inline int FindCaseInsensitive(LPCTSTR szSearch, LPCTSTR szMatch)
{
	int		iString;
	//		Set the number of iterations through the string: the number of
	//		substrings we'll need to test.
	int		iCount = ::_tcslen(szSearch)-::_tcslen(szMatch)+1;
	//		Set the size so that we can return the proper index when we
	//		successfully find the substring.
	int		nSize = iCount-1;

	//		We can't find a substring larger than our search string.
	if (iCount <= 0) return -1;
	while (iCount--) {
		iString = 0;
		while (CaseInsensitiveMatch(szSearch[iString], szMatch[iString])) {
			if (szMatch[++iString] == 0) {
				//	End of match string; return index.
				return nSize-iCount;
			}
		}
		//	Increment our search string.
		++szSearch;
	}
	//	End of search string; failure.
	return -1;
}

/*
 * FolderContains - Test to see if the fCurrent folder contains the substring
 *
 * History:	a-jsari		12/16/97		Initial version.
 */
BOOL CBufferV500DataSource::FolderContains(const CListViewFolder *fCurrent,
				const CString &strSearch, int &wRow, long lFolderOptions)
{
	CString		strName;
	int			wRowMax = fCurrent->GetRows();
	unsigned	uColMax = fCurrent->GetColumns();
	CString		strLowerSearch = strSearch;

	strLowerSearch.MakeLower();
	fCurrent->GetName(strName);
	if (wRow == -1) {
		if (FindCaseInsensitive(strName, strLowerSearch) != -1)
			return TRUE;
		wRow = 0;
	}
	//	Don't check the data elements if we are only checking categories.
	if ((lFolderOptions & FIND_OPTION_CATEGORY_ONLY) == FIND_OPTION_CATEGORY_ONLY)
		return FALSE;
	for ( ; wRow < wRowMax ; ++wRow) {
		unsigned iCol = uColMax;
		while (iCol--) {
			fCurrent->GetSubElement(wRow, iCol, strName);
			if (FindCaseInsensitive(strName, strLowerSearch) != -1) {
				return TRUE;
			}
			if (FindStopped() == TRUE)
				return FALSE;
		}
	}
	return FALSE;
}

/*
 * Find - Traverse the tree looking for a match.
 *
 * History:	a-jsari		12/11/97		Initial version
 */
BOOL CBufferV500DataSource::Find(const CString &strSearch, long lFindOptions)
{
	//	Record our depth in the tree so we don't go above our initial search
	//	category when ascending.
	static int			iDepth;

	CFolder				*pfNext;
	CString				strName;

	ASSERT(strSearch.GetLength() != 0);
	StartSearch();
	if (m_pfLast == NULL || (lFindOptions & FIND_OPTION_REPEAT_SEARCH) == 0) {
		//	If we are searching all categories, reset to the root, otherwise
		//	our root is set for us.
		if ((lFindOptions & FIND_OPTION_ONE_CATEGORY) == 0)
			m_pfLast = GetRootNode();
		iDepth = 0;
	} else
		++m_iLine;
	while (m_pfLast) {
		if (FolderContains(dynamic_cast<CListViewFolder *>(m_pfLast),
			strSearch, m_iLine, lFindOptions)) {
			m_pfLast->InternalName(m_strPath);
			StopSearch();
			return TRUE;
		}
		else if (FindStopped() == TRUE)
			return FALSE;
		//	For the next folder searched, start with the folder name
		m_iLine = -1;
		do {
			//	Depth-first
			pfNext = m_pfLast->GetChildNode();
			if (pfNext != NULL) {
				++iDepth;
				break;
			}
			pfNext = m_pfLast->GetNextNode();
			if (pfNext != NULL) break;
			pfNext = m_pfLast->GetParentNode();
			if (pfNext) {
				//	Check that we don't ascend back above our current category.
				if (--iDepth == 0 && (lFindOptions & FIND_OPTION_ONE_CATEGORY)
						== FIND_OPTION_ONE_CATEGORY) {
					pfNext = NULL;
					break;
				}
				pfNext = pfNext->GetNextNode();
			}
		} while (FALSE);
		m_pfLast = pfNext;
	}
	//	No matches; restart the next search at the beginning.
	m_pfLast = NULL;
	return FALSE;
}

#if 0
/*
 * StopSearch - Ends the current search.
 *
 * History:	a-jsari		1/19/98		Initial version
 */
BOOL CBufferV500DataSource::StopSearch()
{
	if (m_fSearching == TRUE) {
		m_fSearching = FALSE;
		return TRUE;
	}
	return FALSE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\v410file.cpp ===
//	V410File.cpp	Implementation of Version 4.10 data file methods.
//
//  Copyright (c) 1998-1999 Microsoft Corporation

#include "DataSrc.h"
#ifndef IDS_V410FILENODE
#include "resource.h"
#endif
#include "resrc1.h"

//-----------------------------------------------------------------------------
// This struct is used to read the internals of a 4.10 data file.
//-----------------------------------------------------------------------------

typedef struct
{
	char	szCLSID[40];
	char	szStreamName[12];
	char	szName[_MAX_PATH];
	char	szVersion[20];
	DWORD	dwSize;
} SAVED_CONTROL_INFO;

/*
 * CBufferV410DataSource - Stub
 *
 * History:	a-jsari		9/17/97		Initial version
 */
CBufferV410DataSource::CBufferV410DataSource(CMSInfoFile *pFileSink)
:CBufferDataSource(pFileSink)
{

}

//-----------------------------------------------------------------------------
// The constructor for the version 4.10 NFO file data source reads information
// from an IStream in a compound file.
//-----------------------------------------------------------------------------

CBufferV410DataSource::CBufferV410DataSource(IStorage * pStorage, IStream * pStream)
 : CBufferDataSource(NULL)
{
	ReadMSInfo410Stream(pStream);
	m_pStorage = pStorage;
	m_pStorage->AddRef();
}

//-----------------------------------------------------------------------------
// The destructor should release the pointer to the compound doc we saved.
//-----------------------------------------------------------------------------

CBufferV410DataSource::~CBufferV410DataSource()
{
	if (m_pStorage)
	{
		m_pStorage->Release();
		m_pStorage = NULL;
	}
}

//-----------------------------------------------------------------------------
// Read in the information from the "msinfo" stream. The most vital things
// in this file are the tree structure of categories, and the map from
// CLSID to stream name. 
//-----------------------------------------------------------------------------

BOOL CBufferV410DataSource::ReadMSInfo410Stream(IStream *pStream)
{
	const DWORD	MSI_FILE_VER = 0x03000000;
	DWORD		dwVersion, dwCount;

	// First, read and check the version number in the stream.

	if (FAILED(pStream->Read((void *) &dwVersion, sizeof(DWORD), &dwCount)) || dwCount != sizeof(DWORD))
		return FALSE;

	if (dwVersion != MSI_FILE_VER)
		return FALSE;

	// The next thing in the stream is a set of three strings, each terminated by
	// a newline character. These three strings are the time/date, machine name and
	// user name from the saving system. The length of the total string precedes 
	// the string.

	DWORD dwSize;
	if (FAILED(pStream->Read((void *) &dwSize, sizeof(DWORD), &dwCount)) || dwCount != sizeof(DWORD))
		return FALSE;

	char * szBuffer = new char[dwSize];
	if (szBuffer == NULL)
		return FALSE;

	if (FAILED(pStream->Read((void *) szBuffer, dwSize, &dwCount)) || (int)dwCount != dwSize)
	{
		delete szBuffer;
		return FALSE;
	}

	// We don't actually care about these values (now at least).

#if FALSE
	CString strData(szBuffer, dwSize);
	m_strTimeDateStamp = strData.SpanExcluding("\n");
	strData = strData.Right(strData.GetLength() - m_strTimeDateStamp.GetLength() - 1);
	m_strMachineName = strData.SpanExcluding("\n");
	strData = strData.Right(strData.GetLength() - m_strMachineName.GetLength() - 1);
	m_strUserName = strData.SpanExcluding("\n");
#endif

	delete szBuffer;

	// Next, read the map from CLSIDs to stream names. This also includes some
	// other information about the controls. First we should find a DWORD with
	// the count of controls.

	DWORD dwControlCount;
	if (FAILED(pStream->Read((void *) &dwControlCount, sizeof(DWORD), &dwCount)) || dwCount != sizeof(int))
		return FALSE;

	SAVED_CONTROL_INFO controlInfo;
	CString strCLSID, strStreamName;

	for (DWORD i = 0; i < dwControlCount; i++)
	{
		if (FAILED(pStream->Read((void *) &controlInfo, sizeof(SAVED_CONTROL_INFO), &dwCount)) || dwCount != sizeof(SAVED_CONTROL_INFO))
			return FALSE;

		strCLSID = controlInfo.szCLSID;
		strStreamName = controlInfo.szStreamName;

		// We don't currently care about this information...

#if FALSE
		strSize.Format("%ld", controlInfo.dwSize);
		strInfo.FormatMessage(IDS_OCX_INFO, controlInfo.szName, controlInfo.szVersion, strSize);
		m_mapCLSIDToInfo.SetAt(strCLSID, strInfo);
#endif

		m_mapStreams.SetAt(strCLSID, strStreamName);
	}

	// Read and build the category tree. Read the first level, which must be 0.

	int iLevel;
	if (FAILED(pStream->Read((void *) &iLevel, sizeof(int), &dwCount)) || dwCount != sizeof(int))
		return FALSE;

	if (iLevel == 0)
	{
		LARGE_INTEGER li; li.HighPart = -1; li.LowPart = (ULONG)(0 - sizeof(int));
		if (FAILED(pStream->Seek(li, STREAM_SEEK_CUR, NULL)))
			return FALSE;
	
		if (!RecurseLoad410Tree(pStream))
			return FALSE;
		
		// After RecurseLoadTree is through, we should be able to read a -1
		// for the next level.

		if (FAILED(pStream->Read((void *) &iLevel, sizeof(int), &dwCount)) || dwCount != sizeof(int) || iLevel != -1)
			return FALSE;
	}
	else
		return FALSE;

	return TRUE;
}

//-----------------------------------------------------------------------------
// This function creates a COCXFolder object based on the information read
// from the stream.
//-----------------------------------------------------------------------------

COCXFolder * CBufferV410DataSource::ReadOCXFolder(IStream *pStream, COCXFolder * pParent, COCXFolder * pPrevious)
{
	// Read in the values from the stream. Make sure they're all there before
	// we create the COCXFolder.

	BOOL	fUsesView = FALSE;
	BOOL	fControl = FALSE;
	DWORD	dwView = 0;
	CLSID	clsidCategory;
	char	szName[100];

	if (FAILED(pStream->Read((void *) &fUsesView, sizeof(BOOL), NULL))) return NULL;
	if (FAILED(pStream->Read((void *) &fControl, sizeof(BOOL), NULL))) return NULL;
	if (FAILED(pStream->Read((void *) &dwView, sizeof(DWORD), NULL))) return NULL;
	if (FAILED(pStream->Read((void *) &clsidCategory, sizeof(CLSID), NULL))) return NULL;
	if (FAILED(pStream->Read((void *) &szName, sizeof(char) * 100, NULL))) return NULL;

	USES_CONVERSION;
	LPOLESTR lpName = A2W(szName);
	COCXFolder * pFolder = new COCXFolder(this, clsidCategory, pParent, pPrevious, dwView, lpName);

	return pFolder;
}

//-----------------------------------------------------------------------------
// This function (which doesn't really use recursion - the name is left over
// from 4.10 MSInfo) read the category tree from the MSInfo stream and creates
// the necessary COCXFolder objects to represent it.
//-----------------------------------------------------------------------------

BOOL CBufferV410DataSource::RecurseLoad410Tree(IStream *pStream)
{
	m_RootFolder = NULL;

	// This array of folders is used to keep track of the last folder read
	// on each level. This is useful for getting the parent and previous
	// sibling when reading a new folder.

	COCXFolder * aFolderHistory[20];
	for (int i = 0; i < 20; i++) aFolderHistory[i] = NULL;

	// The iLevel variable keeps track of the current tree level we are
	// reading a folder for. A -1 indicates the end of the tree.

	DWORD dwCount;
	int iLevel = 0;
	if (FAILED(pStream->Read((void *) &iLevel, sizeof(int), &dwCount)) || dwCount != sizeof(int))
		return FALSE;

	int iLastLevel = iLevel;
	while (iLevel >= 0 && iLevel < 20)
	{
		aFolderHistory[iLevel] = ReadOCXFolder(pStream, ((iLevel) ? aFolderHistory[iLevel - 1] : NULL), ((iLevel <= iLastLevel) ? aFolderHistory[iLevel] : NULL));
		iLastLevel = iLevel;
		if (FAILED(pStream->Read((void *) &iLevel, sizeof(int), &dwCount)) || dwCount != sizeof(int))
			return FALSE;
	}

	m_RootFolder = aFolderHistory[0];

	// The root OCX folder will not show up in version 5.0, so we need to make
	// the first child folder contain the same values as the root.

	COCXFolder * pRootFolder = reinterpret_cast<COCXFolder *>(m_RootFolder);
	if (pRootFolder)
	{
		CFolder * pOriginalChild = pRootFolder->m_ChildFolder;
		
		pRootFolder->m_ChildFolder = new COCXFolder(this, pRootFolder->m_clsid, pRootFolder, NULL, pRootFolder->m_dwView, L"");
		reinterpret_cast<COCXFolder *>(pRootFolder->m_ChildFolder)->m_strName.LoadString(IDS_410SUMMARY_NODE);
		pRootFolder->m_ChildFolder->m_NextFolder = pOriginalChild;
	}

	// We read a -1 to exit the loop, then we are through with the
	// category tree. Backup (so any other recursion trees will read
	// the -1 as well) and return TRUE.

	if (iLevel == -1)
	{
		LARGE_INTEGER li; li.HighPart = -1; li.LowPart = (ULONG)(0 - sizeof(int));
		if (FAILED(pStream->Seek(li, STREAM_SEEK_CUR, NULL)))
			return FALSE;
	}

	return TRUE;
}

/*
 * GetNodeName - 
 *
 * History: a-jsari		1/16/98		Initial version.
 */
BOOL CBufferV410DataSource::GetNodeName(CString &strNodeName)
{
	AFX_MANAGE_STATE(::AfxGetStaticModuleState());
	strNodeName.Format(IDS_V410FILENODE);
	return TRUE;
}

/*
 * GetRootNode - Stub
 *
 * History: a-jsari		9/17/97		Initial version
 */

CFolder *CBufferV410DataSource::GetRootNode()
{
	return CDataSource::GetRootNode();
}

/*
 * ReadHeader - Stub
 *
 * History: a-jsari		9/17/97		Initial version
 */
void CBufferV410DataSource::ReadHeader(CMSInfoFile *)
{

}

/*
 * ReadFolder - Stub
 *
 * History:	a-jsari		9/17/97		Initial version
 */
void CBufferV410DataSource::ReadFolder(CMSInfoFile *, CFolder * & /* pParentFolder */, CFolder * /* pFolder */)
{

}

/*
 * Save - Stub
 *
 * History:	a-jsari		11/13/97		Initial version
 */
HRESULT CBufferV410DataSource::Save(IStream * /* pStm */)
{
	return E_NOTIMPL;
}

/*
 * Find - Stub
 *
 * History: a-jsari		12/11/97		Initial version
 */
BOOL CBufferV410DataSource::Find(const CString & /* strSearch */, long /* lFindOptions */)
{
	return FALSE;
}

//-----------------------------------------------------------------------------
// When the OCX folder is refreshed, we should call the appropriate methods
// in the OCX (if it is there).
//-----------------------------------------------------------------------------

BOOL COCXFolder::Refresh(IUnknown * pUnknown)
{
	// Get the CLSID as a string (since all our tables are based on the string).

	LPOLESTR lpCLSID;
	if (FAILED(StringFromCLSID(m_clsid, &lpCLSID)))
		return FALSE;
	CString strCLSID(lpCLSID);

	CBufferV410DataSource * pV410Source = reinterpret_cast<CBufferV410DataSource *>(DataSource());
	if (pV410Source == NULL)
		return FALSE;

	if (pUnknown == NULL)
		return FALSE;

	// Get the stream for this control, and load it.

	CString strStream;
	if (pV410Source->m_pStorage && pV410Source->m_mapStreams.Lookup(strCLSID, strStream))
	{
		DWORD grfMode = STGM_DIRECT | STGM_READWRITE | STGM_SHARE_EXCLUSIVE;
		IStream * pStream = NULL;

		if (SUCCEEDED(pV410Source->m_pStorage->OpenStream(strStream, NULL, grfMode, 0, &pStream)))
		{
			IPersistStreamInit * pPersistStream = NULL;
			
			if (SUCCEEDED(pUnknown->QueryInterface(IID_IPersistStreamInit, reinterpret_cast<void **>(&pPersistStream))) && pPersistStream)
			{
				if (SUCCEEDED(pPersistStream->Load(pStream)))
				{
					// Delete the entry for the this stream (so that we don't keep
					// loading the stream into the control).

					pV410Source->m_mapStreams.RemoveKey(strCLSID);
				}
				pPersistStream->Release();
			}

			pStream->Release();
		}
	}

	// Set the view index for the OCX.

	SetOCXView(pUnknown, m_dwView);

	return TRUE;
}

//---------------------------------------------------------------------------
// Use the OCX's IDispatch interface to set the view index and call the
// function to refresh the control (for the new index).
//---------------------------------------------------------------------------

void COCXFolder::SetOCXView(IUnknown * pUnknown, DWORD dwView)
{
	IDispatch * pDispatch = NULL;
	if (SUCCEEDED(pUnknown->QueryInterface(IID_IDispatch, reinterpret_cast<void **>(&pDispatch))) && pDispatch)
	{
		DISPID viewdispid, updatedispid;

		if (!GetDISPID(pDispatch, _T("MSInfoView"), &viewdispid) || !GetDISPID(pDispatch, _T("MSInfoUpdateView"), &updatedispid))
			return;

		DISPID mydispid = DISPID_PROPERTYPUT;
		DISPPARAMS dispparams;
		VARIANTARG disparg;

		disparg.vt = VT_I4;
		disparg.lVal = m_dwView;
		dispparams.rgvarg = &disparg;
		dispparams.rgdispidNamedArgs = &mydispid;
		dispparams.cArgs = 1;
		dispparams.cNamedArgs = 1;

		pDispatch->Invoke(viewdispid, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_PROPERTYPUT, &dispparams, NULL, NULL, NULL);

		DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
		pDispatch->Invoke(updatedispid, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &dispparamsNoArgs, NULL, NULL, NULL);
		
		pDispatch->Release();
	}
}

//---------------------------------------------------------------------------
// GetDISPID returns the DISPID for a given string, by looking it up using
// IDispatch->GetIDsOfNames. This avoids hardcoding DISPIDs in this class.
//---------------------------------------------------------------------------

BOOL COCXFolder::GetDISPID(IDispatch * pDispatch, LPOLESTR szMember, DISPID *pID)
{
	BOOL	result = FALSE;
	DISPID	dispid;

	if (SUCCEEDED(pDispatch->GetIDsOfNames(IID_NULL, &szMember, 1, LOCALE_SYSTEM_DEFAULT, &dispid)))
	{
		*pID = dispid;
		result = TRUE;
	}

	return result;
}

//-----------------------------------------------------------------------------
// Return the folder's CLSID as string.
//-----------------------------------------------------------------------------

BOOL COCXFolder::GetCLSIDString(CString & strCLSID) 
{
	LPOLESTR lpCLSID;
	if (FAILED(StringFromCLSID(m_clsid, &lpCLSID)))
		return FALSE;

	strCLSID = lpCLSID;
	CoTaskMemFree(lpCLSID);
	return TRUE; 
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\wbemsvc.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Tue Aug 19 16:16:10 1997
 */
/* Compiler settings for wbemsvc.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
	Copyright (c) 1998-1999 Microsoft Corporation
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wbemsvc_h__
#define __wbemsvc_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IWbemClassObject_FWD_DEFINED__
#define __IWbemClassObject_FWD_DEFINED__
typedef interface IWbemClassObject IWbemClassObject;
#endif 	/* __IWbemClassObject_FWD_DEFINED__ */


#ifndef __IWbemQualifierSet_FWD_DEFINED__
#define __IWbemQualifierSet_FWD_DEFINED__
typedef interface IWbemQualifierSet IWbemQualifierSet;
#endif 	/* __IWbemQualifierSet_FWD_DEFINED__ */


#ifndef __IWbemServices_FWD_DEFINED__
#define __IWbemServices_FWD_DEFINED__
typedef interface IWbemServices IWbemServices;
#endif 	/* __IWbemServices_FWD_DEFINED__ */


#ifndef __IWbemLocator_FWD_DEFINED__
#define __IWbemLocator_FWD_DEFINED__
typedef interface IWbemLocator IWbemLocator;
#endif 	/* __IWbemLocator_FWD_DEFINED__ */


#ifndef __IWbemObjectSink_FWD_DEFINED__
#define __IWbemObjectSink_FWD_DEFINED__
typedef interface IWbemObjectSink IWbemObjectSink;
#endif 	/* __IWbemObjectSink_FWD_DEFINED__ */


#ifndef __IEnumWbemClassObject_FWD_DEFINED__
#define __IEnumWbemClassObject_FWD_DEFINED__
typedef interface IEnumWbemClassObject IEnumWbemClassObject;
#endif 	/* __IEnumWbemClassObject_FWD_DEFINED__ */


#ifndef __IWbemConfigure_FWD_DEFINED__
#define __IWbemConfigure_FWD_DEFINED__
typedef interface IWbemConfigure IWbemConfigure;
#endif 	/* __IWbemConfigure_FWD_DEFINED__ */


#ifndef __IWbemPropertyProvider_FWD_DEFINED__
#define __IWbemPropertyProvider_FWD_DEFINED__
typedef interface IWbemPropertyProvider IWbemPropertyProvider;
#endif 	/* __IWbemPropertyProvider_FWD_DEFINED__ */


#ifndef __IWbemTransport_FWD_DEFINED__
#define __IWbemTransport_FWD_DEFINED__
typedef interface IWbemTransport IWbemTransport;
#endif 	/* __IWbemTransport_FWD_DEFINED__ */


#ifndef __IWbemSecurityHelp_FWD_DEFINED__
#define __IWbemSecurityHelp_FWD_DEFINED__
typedef interface IWbemSecurityHelp IWbemSecurityHelp;
#endif 	/* __IWbemSecurityHelp_FWD_DEFINED__ */


#ifndef __IWbemLevel1Login_FWD_DEFINED__
#define __IWbemLevel1Login_FWD_DEFINED__
typedef interface IWbemLevel1Login IWbemLevel1Login;
#endif 	/* __IWbemLevel1Login_FWD_DEFINED__ */


#ifndef __IWbemCallResult_FWD_DEFINED__
#define __IWbemCallResult_FWD_DEFINED__
typedef interface IWbemCallResult IWbemCallResult;
#endif 	/* __IWbemCallResult_FWD_DEFINED__ */


#ifndef __IWbemContext_FWD_DEFINED__
#define __IWbemContext_FWD_DEFINED__
typedef interface IWbemContext IWbemContext;
#endif 	/* __IWbemContext_FWD_DEFINED__ */


#ifndef __IWbemUnboundObjectSink_FWD_DEFINED__
#define __IWbemUnboundObjectSink_FWD_DEFINED__
typedef interface IWbemUnboundObjectSink IWbemUnboundObjectSink;
#endif 	/* __IWbemUnboundObjectSink_FWD_DEFINED__ */


#ifndef __WbemLevel1Login_FWD_DEFINED__
#define __WbemLevel1Login_FWD_DEFINED__

#ifdef __cplusplus
typedef class WbemLevel1Login WbemLevel1Login;
#else
typedef struct WbemLevel1Login WbemLevel1Login;
#endif /* __cplusplus */

#endif 	/* __WbemLevel1Login_FWD_DEFINED__ */


#ifndef __WbemLevel1LoginHelp_FWD_DEFINED__
#define __WbemLevel1LoginHelp_FWD_DEFINED__

#ifdef __cplusplus
typedef class WbemLevel1LoginHelp WbemLevel1LoginHelp;
#else
typedef struct WbemLevel1LoginHelp WbemLevel1LoginHelp;
#endif /* __cplusplus */

#endif 	/* __WbemLevel1LoginHelp_FWD_DEFINED__ */


#ifndef __WbemLocator_FWD_DEFINED__
#define __WbemLocator_FWD_DEFINED__

#ifdef __cplusplus
typedef class WbemLocator WbemLocator;
#else
typedef struct WbemLocator WbemLocator;
#endif /* __cplusplus */

#endif 	/* __WbemLocator_FWD_DEFINED__ */


#ifndef __WbemSecurityHelp_FWD_DEFINED__
#define __WbemSecurityHelp_FWD_DEFINED__

#ifdef __cplusplus
typedef class WbemSecurityHelp WbemSecurityHelp;
#else
typedef struct WbemSecurityHelp WbemSecurityHelp;
#endif /* __cplusplus */

#endif 	/* __WbemSecurityHelp_FWD_DEFINED__ */


#ifndef __PrivateWbemLevel1Login_FWD_DEFINED__
#define __PrivateWbemLevel1Login_FWD_DEFINED__

#ifdef __cplusplus
typedef class PrivateWbemLevel1Login PrivateWbemLevel1Login;
#else
typedef struct PrivateWbemLevel1Login PrivateWbemLevel1Login;
#endif /* __cplusplus */

#endif 	/* __PrivateWbemLevel1Login_FWD_DEFINED__ */


#ifndef __InProcWbemLevel1LoginHelp_FWD_DEFINED__
#define __InProcWbemLevel1LoginHelp_FWD_DEFINED__

#ifdef __cplusplus
typedef class InProcWbemLevel1LoginHelp InProcWbemLevel1LoginHelp;
#else
typedef struct InProcWbemLevel1LoginHelp InProcWbemLevel1LoginHelp;
#endif /* __cplusplus */

#endif 	/* __InProcWbemLevel1LoginHelp_FWD_DEFINED__ */


#ifndef __InProcWbemLevel1Login_FWD_DEFINED__
#define __InProcWbemLevel1Login_FWD_DEFINED__

#ifdef __cplusplus
typedef class InProcWbemLevel1Login InProcWbemLevel1Login;
#else
typedef struct InProcWbemLevel1Login InProcWbemLevel1Login;
#endif /* __cplusplus */

#endif 	/* __InProcWbemLevel1Login_FWD_DEFINED__ */


#ifndef __WbemContext_FWD_DEFINED__
#define __WbemContext_FWD_DEFINED__

#ifdef __cplusplus
typedef class WbemContext WbemContext;
#else
typedef struct WbemContext WbemContext;
#endif /* __cplusplus */

#endif 	/* __WbemContext_FWD_DEFINED__ */


#ifndef __WbemClassObjectProxy_FWD_DEFINED__
#define __WbemClassObjectProxy_FWD_DEFINED__

#ifdef __cplusplus
typedef class WbemClassObjectProxy WbemClassObjectProxy;
#else
typedef struct WbemClassObjectProxy WbemClassObjectProxy;
#endif /* __cplusplus */

#endif 	/* __WbemClassObjectProxy_FWD_DEFINED__ */


#ifndef __IWbemClassObject_FWD_DEFINED__
#define __IWbemClassObject_FWD_DEFINED__
typedef interface IWbemClassObject IWbemClassObject;
#endif 	/* __IWbemClassObject_FWD_DEFINED__ */


#ifndef __IWbemQualifierSet_FWD_DEFINED__
#define __IWbemQualifierSet_FWD_DEFINED__
typedef interface IWbemQualifierSet IWbemQualifierSet;
#endif 	/* __IWbemQualifierSet_FWD_DEFINED__ */


#ifndef __IWbemLocator_FWD_DEFINED__
#define __IWbemLocator_FWD_DEFINED__
typedef interface IWbemLocator IWbemLocator;
#endif 	/* __IWbemLocator_FWD_DEFINED__ */


#ifndef __IWbemObjectSink_FWD_DEFINED__
#define __IWbemObjectSink_FWD_DEFINED__
typedef interface IWbemObjectSink IWbemObjectSink;
#endif 	/* __IWbemObjectSink_FWD_DEFINED__ */


#ifndef __IWbemUnboundObjectSink_FWD_DEFINED__
#define __IWbemUnboundObjectSink_FWD_DEFINED__
typedef interface IWbemUnboundObjectSink IWbemUnboundObjectSink;
#endif 	/* __IWbemUnboundObjectSink_FWD_DEFINED__ */


#ifndef __IEnumWbemClassObject_FWD_DEFINED__
#define __IEnumWbemClassObject_FWD_DEFINED__
typedef interface IEnumWbemClassObject IEnumWbemClassObject;
#endif 	/* __IEnumWbemClassObject_FWD_DEFINED__ */


#ifndef __IWbemContext_FWD_DEFINED__
#define __IWbemContext_FWD_DEFINED__
typedef interface IWbemContext IWbemContext;
#endif 	/* __IWbemContext_FWD_DEFINED__ */


#ifndef __IWbemCallResult_FWD_DEFINED__
#define __IWbemCallResult_FWD_DEFINED__
typedef interface IWbemCallResult IWbemCallResult;
#endif 	/* __IWbemCallResult_FWD_DEFINED__ */


#ifndef __IWbemServices_FWD_DEFINED__
#define __IWbemServices_FWD_DEFINED__
typedef interface IWbemServices IWbemServices;
#endif 	/* __IWbemServices_FWD_DEFINED__ */


#ifndef __IWbemConfigure_FWD_DEFINED__
#define __IWbemConfigure_FWD_DEFINED__
typedef interface IWbemConfigure IWbemConfigure;
#endif 	/* __IWbemConfigure_FWD_DEFINED__ */


#ifndef __IWbemPropertyProvider_FWD_DEFINED__
#define __IWbemPropertyProvider_FWD_DEFINED__
typedef interface IWbemPropertyProvider IWbemPropertyProvider;
#endif 	/* __IWbemPropertyProvider_FWD_DEFINED__ */


#ifndef __IWbemLevel1Login_FWD_DEFINED__
#define __IWbemLevel1Login_FWD_DEFINED__
typedef interface IWbemLevel1Login IWbemLevel1Login;
#endif 	/* __IWbemLevel1Login_FWD_DEFINED__ */


#ifndef __IWbemLevel1LoginHelp_FWD_DEFINED__
#define __IWbemLevel1LoginHelp_FWD_DEFINED__
typedef interface IWbemLevel1LoginHelp IWbemLevel1LoginHelp;
#endif 	/* __IWbemLevel1LoginHelp_FWD_DEFINED__ */


#ifndef __IWbemSecurityHelp_FWD_DEFINED__
#define __IWbemSecurityHelp_FWD_DEFINED__
typedef interface IWbemSecurityHelp IWbemSecurityHelp;
#endif 	/* __IWbemSecurityHelp_FWD_DEFINED__ */


#ifndef __IWbemTransport_FWD_DEFINED__
#define __IWbemTransport_FWD_DEFINED__
typedef interface IWbemTransport IWbemTransport;
#endif 	/* __IWbemTransport_FWD_DEFINED__ */


void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


#ifndef __WbemServices_v1_LIBRARY_DEFINED__
#define __WbemServices_v1_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: WbemServices_v1
 * at Tue Aug 19 16:16:10 1997
 * using MIDL 3.01.75
 ****************************************/
/* [uuid] */ 
















typedef 
enum tag_WBEM_GENUS_TYPE
    {	WBEM_GENUS_CLASS	= 1,
	WBEM_GENUS_INSTANCE	= 2
    }	WBEM_GENUS_TYPE;

typedef 
enum tag_WBEM_CHANGE_FLAG_TYPE
    {	WBEM_FLAG_CREATE_OR_UPDATE	= 0,
	WBEM_FLAG_UPDATE_ONLY	= 0x1,
	WBEM_FLAG_CREATE_ONLY	= 0x2
    }	WBEM_CHANGE_FLAG_TYPE;

typedef 
enum tag_WBEM_ASYNCHRONICITY_TYPE
    {	WBEM_RETURN_WHEN_COMPLETE	= 0,
	WBEM_RETURN_IMMEDIATELY	= 0x10
    }	WBEM_ASYNCHRONICITY_TYPE;

typedef 
enum tag_WBEM_CONDITION_FLAG_TYPE
    {	WBEM_FLAG_ALWAYS	= 0,
	WBEM_FLAG_ONLY_IF_TRUE	= 0x1,
	WBEM_FLAG_ONLY_IF_FALSE	= 0x2,
	WBEM_FLAG_ONLY_IF_IDENTICAL	= 0x3,
	WBEM_MASK_PRIMARY_CONDITION	= 0x3,
	WBEM_FLAG_KEYS_ONLY	= 0x4,
	WBEM_FLAG_REFS_ONLY	= 0x8,
	WBEM_FLAG_LOCAL_ONLY	= 0x10,
	WBEM_FLAG_PROPAGATED_ONLY	= 0x20,
	WBEM_FLAG_SYSTEM_ONLY	= 0x30,
	WBEM_FLAG_NONSYSTEM_ONLY	= 0x40,
	WBEM_MASK_CONDITION_ORIGIN	= 0x70
    }	WBEM_CONDITION_FLAG_TYPE;

typedef 
enum tag_WBEM_FLAVOR_TYPE
    {	WBEM_FLAVOR_DONT_PROPAGATE	= 0,
	WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE	= 0x1,
	WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS	= 0x2,
	WBEM_FLAVOR_MASK_PROPAGATION	= 0xf,
	WBEM_FLAVOR_OVERRIDABLE	= 0,
	WBEM_FLAVOR_NOT_OVERRIDABLE	= 0x10,
	WBEM_FLAVOR_MASK_PERMISSIONS	= 0x10,
	WBEM_FLAVOR_ORIGIN_LOCAL	= 0,
	WBEM_FLAVOR_ORIGIN_PROPAGATED	= 0x20,
	WBEM_FLAVOR_ORIGIN_SYSTEM	= 0x40,
	WBEM_FLAVOR_MASK_ORIGIN	= 0x60
    }	WBEM_FLAVOR_TYPE;

typedef 
enum tag_WBEM_DEPTH_FLAG_TYPE
    {	WBEM_FLAG_DEEP	= 0,
	WBEM_FLAG_SHALLOW	= 1
    }	WBEM_DEPTH_FLAG_TYPE;

typedef 
enum tag_WBEM_LIMITATION_FLAG_TYPE
    {	WBEM_FLAG_EXCLUDE_OBJECT_QUALIFIERS	= 0x10,
	WBEM_FLAG_EXCLUDE_PROPERTY_QUALIFIERS	= 0x20
    }	WBEM_LIMITATION_FLAG_TYPE;

typedef 
enum tag_WBEM_MERGE_FLAG_TYPE
    {	WBEM_FLAG_PREFER_THIS	= 0,
	WBEM_FLAG_PREFER_SOURCE	= WBEM_FLAG_PREFER_THIS + 1
    }	WBEM_MERGE_FLAG_TYPE;

typedef 
enum tag_WBEM_TEXT_FLAG_TYPE
    {	WBEM_FLAG_NO_FLAVORS	= 0x1
    }	WBEM_TEXT_FLAG_TYPE;

typedef 
enum tag_WBEM_COMPARISON_FLAG
    {	WBEM_COMPARISON_INCLUDE_ALL	= 0,
	WBEM_FLAG_IGNORE_QUALIFIERS	= 0x1,
	WBEM_FLAG_IGNORE_OBJECT_SOURCE	= 0x2,
	WBEM_FLAG_IGNORE_DEFAULT_VALUES	= 0x4,
	WBEM_FLAG_IGNORE_CLASS	= 0x8,
	WBEM_FLAG_IGNORE_CASE	= 0x10,
	WBEM_FLAG_IGNORE_FLAVOR	= 0x20
    }	WBEM_COMPARISON_FLAG;

typedef 
enum tag_WBEM_CONFIGURATION_FLAG
    {	WBEM_CONFIGURATION_NORMAL	= 0,
	WBEM_CONFIGURATION_FLAG_CRITICAL_USER	= 1
    }	WBEM_COMFIGURATION_FLAG;

typedef 
enum tag_WBEM_MISC_FLAG_TYPE
    {	WBEM_FLAG_NO_CLASS_PROVIDERS	= 0x40,
	WBEM_FLAG_NO_EVENTS	= 0x20
    }	WBEM_MISC_FLAG_TYPE;

typedef 
enum tag_WBEM_LOGIN_TYPE
    {	WBEM_FLAG_INPROC_LOGIN	= 0,
	WBEM_FLAG_LOCAL_LOGIN	= 1,
	WBEM_FLAG_REMOTE_LOGIN	= 2
    }	WBEM_LOGIN_TYPE;

typedef 
enum tag_WBEM_AUTHENTICATION
    {	WBEM_AUTHENTICATION_DEFAULT	= 0,
	WBEM_AUTHENTICATION_NTLM	= 0x1,
	WBEM_AUTHENTICATION_WBEM	= 0x2
    }	WBEM_LOGIN_AUTHENTICATION;

typedef 
enum tag_WBEMSTATUS
    {	WBEM_NO_ERROR	= 0,
	WBEM_S_NO_ERROR	= 0,
	WBEM_S_SAME	= 0,
	WBEM_S_FALSE	= 1,
	WBEM_S_ALREADY_EXISTS	= 0x40001,
	WBEM_S_RESET_TO_DEFAULT	= WBEM_S_ALREADY_EXISTS + 1,
	WBEM_S_DIFFERENT	= WBEM_S_RESET_TO_DEFAULT + 1,
	WBEM_S_TIMEDOUT	= WBEM_S_DIFFERENT + 1,
	WBEM_S_NO_MORE_DATA	= WBEM_S_TIMEDOUT + 1,
	WBEM_S_PRELOGIN	= WBEM_S_NO_MORE_DATA + 1,
	WBEM_S_LOGIN	= WBEM_S_PRELOGIN + 1,
	WBEM_S_OPERATION_CANCELED	= WBEM_S_LOGIN + 1,
	WBEM_S_PENDING	= WBEM_S_OPERATION_CANCELED + 1,
	WBEM_E_FAILED	= 0x80041001,
	WBEM_E_NOT_FOUND	= WBEM_E_FAILED + 1,
	WBEM_E_ACCESS_DENIED	= WBEM_E_NOT_FOUND + 1,
	WBEM_E_PROVIDER_FAILURE	= WBEM_E_ACCESS_DENIED + 1,
	WBEM_E_TYPE_MISMATCH	= WBEM_E_PROVIDER_FAILURE + 1,
	WBEM_E_OUT_OF_MEMORY	= WBEM_E_TYPE_MISMATCH + 1,
	WBEM_E_INVALID_CONTEXT	= WBEM_E_OUT_OF_MEMORY + 1,
	WBEM_E_INVALID_PARAMETER	= WBEM_E_INVALID_CONTEXT + 1,
	WBEM_E_NOT_AVAILABLE	= WBEM_E_INVALID_PARAMETER + 1,
	WBEM_E_CRITICAL_ERROR	= WBEM_E_NOT_AVAILABLE + 1,
	WBEM_E_INVALID_STREAM	= WBEM_E_CRITICAL_ERROR + 1,
	WBEM_E_NOT_SUPPORTED	= WBEM_E_INVALID_STREAM + 1,
	WBEM_E_INVALID_SUPERCLASS	= WBEM_E_NOT_SUPPORTED + 1,
	WBEM_E_INVALID_NAMESPACE	= WBEM_E_INVALID_SUPERCLASS + 1,
	WBEM_E_INVALID_OBJECT	= WBEM_E_INVALID_NAMESPACE + 1,
	WBEM_E_INVALID_CLASS	= WBEM_E_INVALID_OBJECT + 1,
	WBEM_E_PROVIDER_NOT_FOUND	= WBEM_E_INVALID_CLASS + 1,
	WBEM_E_INVALID_PROVIDER_REGISTRATION	= WBEM_E_PROVIDER_NOT_FOUND + 1,
	WBEM_E_PROVIDER_LOAD_FAILURE	= WBEM_E_INVALID_PROVIDER_REGISTRATION + 1,
	WBEM_E_INITIALIZATION_FAILURE	= WBEM_E_PROVIDER_LOAD_FAILURE + 1,
	WBEM_E_TRANSPORT_FAILURE	= WBEM_E_INITIALIZATION_FAILURE + 1,
	WBEM_E_INVALID_OPERATION	= WBEM_E_TRANSPORT_FAILURE + 1,
	WBEM_E_INVALID_QUERY	= WBEM_E_INVALID_OPERATION + 1,
	WBEM_E_INVALID_QUERY_TYPE	= WBEM_E_INVALID_QUERY + 1,
	WBEM_E_ALREADY_EXISTS	= WBEM_E_INVALID_QUERY_TYPE + 1,
	WBEM_E_OVERRIDE_NOT_ALLOWED	= WBEM_E_ALREADY_EXISTS + 1,
	WBEM_E_PROPAGATED_QUALIFIER	= WBEM_E_OVERRIDE_NOT_ALLOWED + 1,
	WBEM_E_PROPAGATED_PROPERTY	= WBEM_E_PROPAGATED_QUALIFIER + 1,
	WBEM_E_UNEXPECTED	= WBEM_E_PROPAGATED_PROPERTY + 1,
	WBEM_E_ILLEGAL_OPERATION	= WBEM_E_UNEXPECTED + 1,
	WBEM_E_CANNOT_BE_KEY	= WBEM_E_ILLEGAL_OPERATION + 1,
	WBEM_E_INCOMPLETE_CLASS	= WBEM_E_CANNOT_BE_KEY + 1,
	WBEM_E_INVALID_SYNTAX	= WBEM_E_INCOMPLETE_CLASS + 1,
	WBEM_E_NONDECORATED_OBJECT	= WBEM_E_INVALID_SYNTAX + 1,
	WBEM_E_READ_ONLY	= WBEM_E_NONDECORATED_OBJECT + 1,
	WBEM_E_PROVIDER_NOT_CAPABLE	= WBEM_E_READ_ONLY + 1,
	WBEM_E_CLASS_HAS_CHILDREN	= WBEM_E_PROVIDER_NOT_CAPABLE + 1,
	WBEM_E_CLASS_HAS_INSTANCES	= WBEM_E_CLASS_HAS_CHILDREN + 1,
	WBEM_E_QUERY_NOT_IMPLEMENTED	= WBEM_E_CLASS_HAS_INSTANCES + 1,
	WBEM_E_ILLEGAL_NULL	= WBEM_E_QUERY_NOT_IMPLEMENTED + 1,
	WBEM_E_INVALID_QUALIFIER_TYPE	= WBEM_E_ILLEGAL_NULL + 1,
	WBEM_E_INVALID_PROPERTY_TYPE	= WBEM_E_INVALID_QUALIFIER_TYPE + 1,
	WBEM_E_VALUE_OUT_OF_RANGE	= WBEM_E_INVALID_PROPERTY_TYPE + 1,
	WBEM_E_CANNOT_BE_SINGLETON	= WBEM_E_VALUE_OUT_OF_RANGE + 1,
	WBEM_E_INVALID_CIM_TYPE	= WBEM_E_CANNOT_BE_SINGLETON + 1,
	WBEM_E_INVALID_METHOD	= WBEM_E_INVALID_CIM_TYPE + 1,
	WBEM_E_INVALID_METHOD_PARAMETERS	= WBEM_E_INVALID_METHOD + 1,
	WBEM_E_SYSTEM_PROPERTY	= WBEM_E_INVALID_METHOD_PARAMETERS + 1,
	WBEM_E_INVALID_PROPERTY	= WBEM_E_SYSTEM_PROPERTY + 1,
	WBEMESS_E_REGISTRATION_TOO_BROAD	= 0x80005001,
	WBEMESS_E_REGISTRATION_TOO_PRECISE	= WBEMESS_E_REGISTRATION_TOO_BROAD + 1
    }	WBEMSTATUS;

typedef 
enum tag_WBEM_COM_METHOD_MASK
    {	WBEM_METHOD_OpenNamespace	= 0x1,
	WBEM_METHOD_CancelAsyncCall	= 0x2,
	WBEM_METHOD_QueryObjectSink	= 0x4,
	WBEM_METHOD_GetObject	= 0x8,
	WBEM_METHOD_GetObjectAsync	= 0x10,
	WBEM_METHOD_PutClass	= 0x20,
	WBEM_METHOD_PutClassAsync	= 0x40,
	WBEM_METHOD_DeleteClass	= 0x80,
	WBEM_METHOD_DeleteClassAsync	= 0x100,
	WBEM_METHOD_CreateClassEnum	= 0x200,
	WBEM_METHOD_CreateClassEnumAsync	= 0x400,
	WBEM_METHOD_PutInstance	= 0x800,
	WBEM_METHOD_PutInstanceAsync	= 0x1000,
	WBEM_METHOD_DeleteInstance	= 0x2000,
	WBEM_METHOD_DeleteInstanceAsync	= 0x4000,
	WBEM_METHOD_CreateInstanceEnum	= 0x8000,
	WBEM_METHOD_CreateInstanceEnumAsync	= 0x10000,
	WBEM_METHOD_ExecQuery	= 0x20000,
	WBEM_METHOD_ExecQueryAsync	= 0x40000,
	WBEM_METHOD_ExecNotificationQuery	= 0x80000,
	WBEM_METHOD_ExecNotificationQueryAsync	= 0x100000,
	WBEM_METHOD_ExecMethod	= 0x400000,
	WBEM_METHOD_ExecMethodAsync	= 0x800000
    }	WBEM_COM_METHOD_MASK;

typedef 
enum tag_WBEM_EVENT_TYPE
    {	WBEM_EVENTTYPE_Invalid	= 0,
	WBEM_EVENTTYPE_Extrinsic	= 5,
	WBEM_EVENTTYPE_Timer	= WBEM_EVENTTYPE_Extrinsic + 1,
	WBEM_EVENTTYPE_NamespaceCreation	= WBEM_EVENTTYPE_Timer + 1,
	WBEM_EVENTTYPE_NamespaceDeletion	= WBEM_EVENTTYPE_NamespaceCreation + 1,
	WBEM_EVENTTYPE_NamespaceModification	= WBEM_EVENTTYPE_NamespaceDeletion + 1,
	WBEM_EVENTTYPE_ClassCreation	= WBEM_EVENTTYPE_NamespaceModification + 1,
	WBEM_EVENTTYPE_ClassDeletion	= WBEM_EVENTTYPE_ClassCreation + 1,
	WBEM_EVENTTYPE_ClassModification	= WBEM_EVENTTYPE_ClassDeletion + 1,
	WBEM_EVENTTYPE_InstanceCreation	= WBEM_EVENTTYPE_ClassModification + 1,
	WBEM_EVENTTYPE_InstanceDeletion	= WBEM_EVENTTYPE_InstanceCreation + 1,
	WBEM_EVENTTYPE_InstanceModification	= WBEM_EVENTTYPE_InstanceDeletion + 1
    }	WBEM_EVENT_TYPE;

typedef /* [length_is][size_is] */ BYTE __RPC_FAR *WBEM_128BITS;


EXTERN_C const IID LIBID_WbemServices_v1;

#ifndef __IWbemClassObject_INTERFACE_DEFINED__
#define __IWbemClassObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IWbemClassObject
 * at Tue Aug 19 16:16:10 1997
 * using MIDL 3.01.75
 ****************************************/
/* [oleautomation][dual][uuid][object][local] */ 



EXTERN_C const IID IID_IWbemClassObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("dc12a681-737f-11cf-884d-00aa004b2e24")
    IWbemClassObject : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetQualifierSet( 
            /* [out] */ IWbemQualifierSet __RPC_FAR *__RPC_FAR *ppQualSet) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Get( 
            /* [in] */ BSTR Name,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ VARIANT __RPC_FAR *pVal,
            /* [unique][in][out] */ VARTYPE __RPC_FAR *pvtType,
            /* [unique][in][out] */ long __RPC_FAR *plFlavor) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Put( 
            /* [in] */ BSTR Name,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT __RPC_FAR *pVal,
            /* [in] */ VARTYPE vtType) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Delete( 
            /* [in] */ BSTR Name) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetNames( 
            /* [in] */ BSTR QualifierName,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT __RPC_FAR *pQualifierVal,
            /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pNames) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE BeginEnumeration( 
            /* [in] */ long lEnumFlags) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ long lFlags,
            /* [unique][in][out] */ BSTR __RPC_FAR *pName,
            /* [unique][in][out] */ VARIANT __RPC_FAR *pVal,
            /* [unique][in][out] */ VARTYPE __RPC_FAR *pvtType,
            /* [unique][in][out] */ long __RPC_FAR *plFlavor) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE EndEnumeration( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetPropertyQualifierSet( 
            /* [in] */ BSTR pProperty,
            /* [out] */ IWbemQualifierSet __RPC_FAR *__RPC_FAR *ppQualSet) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppCopy) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetObjectText( 
            /* [in] */ long lFlags,
            /* [out] */ BSTR __RPC_FAR *pObjectText) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SpawnDerivedClass( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppNewClass) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SpawnInstance( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppNewInstance) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE CompareTo( 
            /* [in] */ long lFlags,
            /* [in] */ IWbemClassObject __RPC_FAR *pCompareTo) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetPropertyOrigin( 
            /* [in] */ BSTR strName,
            /* [out] */ BSTR __RPC_FAR *pstrClassName) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE InheritsFrom( 
            /* [in] */ BSTR strAncestor) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemClassObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWbemClassObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWbemClassObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IWbemClassObject __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetQualifierSet )( 
            IWbemClassObject __RPC_FAR * This,
            /* [out] */ IWbemQualifierSet __RPC_FAR *__RPC_FAR *ppQualSet);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Get )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ BSTR Name,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ VARIANT __RPC_FAR *pVal,
            /* [unique][in][out] */ VARTYPE __RPC_FAR *pvtType,
            /* [unique][in][out] */ long __RPC_FAR *plFlavor);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Put )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ BSTR Name,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT __RPC_FAR *pVal,
            /* [in] */ VARTYPE vtType);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ BSTR Name);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNames )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ BSTR QualifierName,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT __RPC_FAR *pQualifierVal,
            /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pNames);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginEnumeration )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ long lEnumFlags);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ BSTR __RPC_FAR *pName,
            /* [unique][in][out] */ VARIANT __RPC_FAR *pVal,
            /* [unique][in][out] */ VARTYPE __RPC_FAR *pvtType,
            /* [unique][in][out] */ long __RPC_FAR *plFlavor);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndEnumeration )( 
            IWbemClassObject __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropertyQualifierSet )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ BSTR pProperty,
            /* [out] */ IWbemQualifierSet __RPC_FAR *__RPC_FAR *ppQualSet);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IWbemClassObject __RPC_FAR * This,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppCopy);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetObjectText )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [out] */ BSTR __RPC_FAR *pObjectText);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SpawnDerivedClass )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppNewClass);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SpawnInstance )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppNewInstance);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CompareTo )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [in] */ IWbemClassObject __RPC_FAR *pCompareTo);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropertyOrigin )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ BSTR strName,
            /* [out] */ BSTR __RPC_FAR *pstrClassName);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InheritsFrom )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ BSTR strAncestor);
        
        END_INTERFACE
    } IWbemClassObjectVtbl;

    interface IWbemClassObject
    {
        CONST_VTBL struct IWbemClassObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemClassObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemClassObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemClassObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemClassObject_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWbemClassObject_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWbemClassObject_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWbemClassObject_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWbemClassObject_GetQualifierSet(This,ppQualSet)	\
    (This)->lpVtbl -> GetQualifierSet(This,ppQualSet)

#define IWbemClassObject_Get(This,Name,lFlags,pVal,pvtType,plFlavor)	\
    (This)->lpVtbl -> Get(This,Name,lFlags,pVal,pvtType,plFlavor)

#define IWbemClassObject_Put(This,Name,lFlags,pVal,vtType)	\
    (This)->lpVtbl -> Put(This,Name,lFlags,pVal,vtType)

#define IWbemClassObject_Delete(This,Name)	\
    (This)->lpVtbl -> Delete(This,Name)

#define IWbemClassObject_GetNames(This,QualifierName,lFlags,pQualifierVal,pNames)	\
    (This)->lpVtbl -> GetNames(This,QualifierName,lFlags,pQualifierVal,pNames)

#define IWbemClassObject_BeginEnumeration(This,lEnumFlags)	\
    (This)->lpVtbl -> BeginEnumeration(This,lEnumFlags)

#define IWbemClassObject_Next(This,lFlags,pName,pVal,pvtType,plFlavor)	\
    (This)->lpVtbl -> Next(This,lFlags,pName,pVal,pvtType,plFlavor)

#define IWbemClassObject_EndEnumeration(This)	\
    (This)->lpVtbl -> EndEnumeration(This)

#define IWbemClassObject_GetPropertyQualifierSet(This,pProperty,ppQualSet)	\
    (This)->lpVtbl -> GetPropertyQualifierSet(This,pProperty,ppQualSet)

#define IWbemClassObject_Clone(This,ppCopy)	\
    (This)->lpVtbl -> Clone(This,ppCopy)

#define IWbemClassObject_GetObjectText(This,lFlags,pObjectText)	\
    (This)->lpVtbl -> GetObjectText(This,lFlags,pObjectText)

#define IWbemClassObject_SpawnDerivedClass(This,lFlags,ppNewClass)	\
    (This)->lpVtbl -> SpawnDerivedClass(This,lFlags,ppNewClass)

#define IWbemClassObject_SpawnInstance(This,lFlags,ppNewInstance)	\
    (This)->lpVtbl -> SpawnInstance(This,lFlags,ppNewInstance)

#define IWbemClassObject_CompareTo(This,lFlags,pCompareTo)	\
    (This)->lpVtbl -> CompareTo(This,lFlags,pCompareTo)

#define IWbemClassObject_GetPropertyOrigin(This,strName,pstrClassName)	\
    (This)->lpVtbl -> GetPropertyOrigin(This,strName,pstrClassName)

#define IWbemClassObject_InheritsFrom(This,strAncestor)	\
    (This)->lpVtbl -> InheritsFrom(This,strAncestor)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IWbemClassObject_GetQualifierSet_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [out] */ IWbemQualifierSet __RPC_FAR *__RPC_FAR *ppQualSet);


void __RPC_STUB IWbemClassObject_GetQualifierSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemClassObject_Get_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [in] */ BSTR Name,
    /* [in] */ long lFlags,
    /* [unique][in][out] */ VARIANT __RPC_FAR *pVal,
    /* [unique][in][out] */ VARTYPE __RPC_FAR *pvtType,
    /* [unique][in][out] */ long __RPC_FAR *plFlavor);


void __RPC_STUB IWbemClassObject_Get_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemClassObject_Put_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [in] */ BSTR Name,
    /* [in] */ long lFlags,
    /* [in] */ VARIANT __RPC_FAR *pVal,
    /* [in] */ VARTYPE vtType);


void __RPC_STUB IWbemClassObject_Put_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemClassObject_Delete_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [in] */ BSTR Name);


void __RPC_STUB IWbemClassObject_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemClassObject_GetNames_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [in] */ BSTR QualifierName,
    /* [in] */ long lFlags,
    /* [in] */ VARIANT __RPC_FAR *pQualifierVal,
    /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pNames);


void __RPC_STUB IWbemClassObject_GetNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemClassObject_BeginEnumeration_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [in] */ long lEnumFlags);


void __RPC_STUB IWbemClassObject_BeginEnumeration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemClassObject_Next_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [unique][in][out] */ BSTR __RPC_FAR *pName,
    /* [unique][in][out] */ VARIANT __RPC_FAR *pVal,
    /* [unique][in][out] */ VARTYPE __RPC_FAR *pvtType,
    /* [unique][in][out] */ long __RPC_FAR *plFlavor);


void __RPC_STUB IWbemClassObject_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemClassObject_EndEnumeration_Proxy( 
    IWbemClassObject __RPC_FAR * This);


void __RPC_STUB IWbemClassObject_EndEnumeration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemClassObject_GetPropertyQualifierSet_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [in] */ BSTR pProperty,
    /* [out] */ IWbemQualifierSet __RPC_FAR *__RPC_FAR *ppQualSet);


void __RPC_STUB IWbemClassObject_GetPropertyQualifierSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemClassObject_Clone_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppCopy);


void __RPC_STUB IWbemClassObject_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemClassObject_GetObjectText_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [out] */ BSTR __RPC_FAR *pObjectText);


void __RPC_STUB IWbemClassObject_GetObjectText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemClassObject_SpawnDerivedClass_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppNewClass);


void __RPC_STUB IWbemClassObject_SpawnDerivedClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemClassObject_SpawnInstance_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppNewInstance);


void __RPC_STUB IWbemClassObject_SpawnInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemClassObject_CompareTo_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [in] */ IWbemClassObject __RPC_FAR *pCompareTo);


void __RPC_STUB IWbemClassObject_CompareTo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemClassObject_GetPropertyOrigin_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [in] */ BSTR strName,
    /* [out] */ BSTR __RPC_FAR *pstrClassName);


void __RPC_STUB IWbemClassObject_GetPropertyOrigin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemClassObject_InheritsFrom_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [in] */ BSTR strAncestor);


void __RPC_STUB IWbemClassObject_InheritsFrom_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemClassObject_INTERFACE_DEFINED__ */


#ifndef __IWbemQualifierSet_INTERFACE_DEFINED__
#define __IWbemQualifierSet_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IWbemQualifierSet
 * at Tue Aug 19 16:16:10 1997
 * using MIDL 3.01.75
 ****************************************/
/* [dual][oleautomation][uuid][local][object] */ 



EXTERN_C const IID IID_IWbemQualifierSet;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("dc12a680-737f-11cf-884d-00aa004b2e24")
    IWbemQualifierSet : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Get( 
            /* [in] */ BSTR Name,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ VARIANT __RPC_FAR *pVal,
            /* [unique][in][out] */ long __RPC_FAR *plFlavor) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Put( 
            /* [in] */ BSTR Name,
            /* [in] */ VARIANT __RPC_FAR *pVal,
            /* [in] */ long lFlavor) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Delete( 
            /* [in] */ BSTR Name) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetNames( 
            /* [in] */ long lFlags,
            /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pNames) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE BeginEnumeration( 
            /* [in] */ long lFlags) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ long lFlags,
            /* [unique][in][out] */ BSTR __RPC_FAR *pName,
            /* [unique][in][out] */ VARIANT __RPC_FAR *pVal,
            /* [unique][in][out] */ long __RPC_FAR *plFlavor) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE EndEnumeration( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemQualifierSetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWbemQualifierSet __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWbemQualifierSet __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWbemQualifierSet __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IWbemQualifierSet __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IWbemQualifierSet __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IWbemQualifierSet __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IWbemQualifierSet __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Get )( 
            IWbemQualifierSet __RPC_FAR * This,
            /* [in] */ BSTR Name,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ VARIANT __RPC_FAR *pVal,
            /* [unique][in][out] */ long __RPC_FAR *plFlavor);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Put )( 
            IWbemQualifierSet __RPC_FAR * This,
            /* [in] */ BSTR Name,
            /* [in] */ VARIANT __RPC_FAR *pVal,
            /* [in] */ long lFlavor);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IWbemQualifierSet __RPC_FAR * This,
            /* [in] */ BSTR Name);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNames )( 
            IWbemQualifierSet __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pNames);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginEnumeration )( 
            IWbemQualifierSet __RPC_FAR * This,
            /* [in] */ long lFlags);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IWbemQualifierSet __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ BSTR __RPC_FAR *pName,
            /* [unique][in][out] */ VARIANT __RPC_FAR *pVal,
            /* [unique][in][out] */ long __RPC_FAR *plFlavor);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndEnumeration )( 
            IWbemQualifierSet __RPC_FAR * This);
        
        END_INTERFACE
    } IWbemQualifierSetVtbl;

    interface IWbemQualifierSet
    {
        CONST_VTBL struct IWbemQualifierSetVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemQualifierSet_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemQualifierSet_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemQualifierSet_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemQualifierSet_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWbemQualifierSet_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWbemQualifierSet_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWbemQualifierSet_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWbemQualifierSet_Get(This,Name,lFlags,pVal,plFlavor)	\
    (This)->lpVtbl -> Get(This,Name,lFlags,pVal,plFlavor)

#define IWbemQualifierSet_Put(This,Name,pVal,lFlavor)	\
    (This)->lpVtbl -> Put(This,Name,pVal,lFlavor)

#define IWbemQualifierSet_Delete(This,Name)	\
    (This)->lpVtbl -> Delete(This,Name)

#define IWbemQualifierSet_GetNames(This,lFlags,pNames)	\
    (This)->lpVtbl -> GetNames(This,lFlags,pNames)

#define IWbemQualifierSet_BeginEnumeration(This,lFlags)	\
    (This)->lpVtbl -> BeginEnumeration(This,lFlags)

#define IWbemQualifierSet_Next(This,lFlags,pName,pVal,plFlavor)	\
    (This)->lpVtbl -> Next(This,lFlags,pName,pVal,plFlavor)

#define IWbemQualifierSet_EndEnumeration(This)	\
    (This)->lpVtbl -> EndEnumeration(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IWbemQualifierSet_Get_Proxy( 
    IWbemQualifierSet __RPC_FAR * This,
    /* [in] */ BSTR Name,
    /* [in] */ long lFlags,
    /* [unique][in][out] */ VARIANT __RPC_FAR *pVal,
    /* [unique][in][out] */ long __RPC_FAR *plFlavor);


void __RPC_STUB IWbemQualifierSet_Get_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemQualifierSet_Put_Proxy( 
    IWbemQualifierSet __RPC_FAR * This,
    /* [in] */ BSTR Name,
    /* [in] */ VARIANT __RPC_FAR *pVal,
    /* [in] */ long lFlavor);


void __RPC_STUB IWbemQualifierSet_Put_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemQualifierSet_Delete_Proxy( 
    IWbemQualifierSet __RPC_FAR * This,
    /* [in] */ BSTR Name);


void __RPC_STUB IWbemQualifierSet_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemQualifierSet_GetNames_Proxy( 
    IWbemQualifierSet __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pNames);


void __RPC_STUB IWbemQualifierSet_GetNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemQualifierSet_BeginEnumeration_Proxy( 
    IWbemQualifierSet __RPC_FAR * This,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemQualifierSet_BeginEnumeration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemQualifierSet_Next_Proxy( 
    IWbemQualifierSet __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [unique][in][out] */ BSTR __RPC_FAR *pName,
    /* [unique][in][out] */ VARIANT __RPC_FAR *pVal,
    /* [unique][in][out] */ long __RPC_FAR *plFlavor);


void __RPC_STUB IWbemQualifierSet_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemQualifierSet_EndEnumeration_Proxy( 
    IWbemQualifierSet __RPC_FAR * This);


void __RPC_STUB IWbemQualifierSet_EndEnumeration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemQualifierSet_INTERFACE_DEFINED__ */


#ifndef __IWbemServices_INTERFACE_DEFINED__
#define __IWbemServices_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IWbemServices
 * at Tue Aug 19 16:16:10 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][dual][oleautomation][uuid][object] */ 



EXTERN_C const IID IID_IWbemServices;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("9556dc99-828c-11cf-a37e-00aa003240c7")
    IWbemServices : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE OpenNamespace( 
            /* [in] */ BSTR Namespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetObjectAsync( 
            /* [in] */ BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE PutClass( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE PutClassAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE DeleteClass( 
            /* [in] */ BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
            /* [in] */ BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE CreateClassEnum( 
            /* [in] */ BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
            /* [in] */ BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE PutInstance( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE DeleteInstance( 
            /* [in] */ BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
            /* [in] */ BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
            /* [in] */ BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
            /* [in] */ BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ BSTR QueryLanguage,
            /* [in] */ BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
            /* [in] */ BSTR QueryLanguage,
            /* [in] */ BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
            /* [in] */ BSTR QueryLanguage,
            /* [in] */ BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
            /* [in] */ BSTR QueryLanguage,
            /* [in] */ BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ExecMethod( 
            /* [in] */ BSTR ObjectPath,
            /* [in] */ BSTR MethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
            /* [in] */ BSTR ObjectPath,
            /* [in] */ BSTR MethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemServicesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWbemServices __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWbemServices __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IWbemServices __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenNamespace )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ BSTR Namespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CancelAsyncCall )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryObjectSink )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetObject )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetObjectAsync )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutClass )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutClassAsync )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteClass )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteClassAsync )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateClassEnum )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateClassEnumAsync )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutInstance )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutInstanceAsync )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteInstance )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteInstanceAsync )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateInstanceEnum )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateInstanceEnumAsync )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExecQuery )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ BSTR QueryLanguage,
            /* [in] */ BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExecQueryAsync )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ BSTR QueryLanguage,
            /* [in] */ BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExecNotificationQuery )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ BSTR QueryLanguage,
            /* [in] */ BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExecNotificationQueryAsync )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ BSTR QueryLanguage,
            /* [in] */ BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExecMethod )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ BSTR ObjectPath,
            /* [in] */ BSTR MethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExecMethodAsync )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ BSTR ObjectPath,
            /* [in] */ BSTR MethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        END_INTERFACE
    } IWbemServicesVtbl;

    interface IWbemServices
    {
        CONST_VTBL struct IWbemServicesVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemServices_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemServices_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemServices_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemServices_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWbemServices_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWbemServices_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWbemServices_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWbemServices_OpenNamespace(This,Namespace,lFlags,pCtx,ppWorkingNamespace,ppResult)	\
    (This)->lpVtbl -> OpenNamespace(This,Namespace,lFlags,pCtx,ppWorkingNamespace,ppResult)

#define IWbemServices_CancelAsyncCall(This,pSink)	\
    (This)->lpVtbl -> CancelAsyncCall(This,pSink)

#define IWbemServices_QueryObjectSink(This,lFlags,ppResponseHandler)	\
    (This)->lpVtbl -> QueryObjectSink(This,lFlags,ppResponseHandler)

#define IWbemServices_GetObject(This,ObjectPath,lFlags,pCtx,ppObject,ppCallResult)	\
    (This)->lpVtbl -> GetObject(This,ObjectPath,lFlags,pCtx,ppObject,ppCallResult)

#define IWbemServices_GetObjectAsync(This,ObjectPath,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> GetObjectAsync(This,ObjectPath,lFlags,pCtx,pResponseHandler)

#define IWbemServices_PutClass(This,pObject,lFlags,pCtx,ppCallResult)	\
    (This)->lpVtbl -> PutClass(This,pObject,lFlags,pCtx,ppCallResult)

#define IWbemServices_PutClassAsync(This,pObject,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> PutClassAsync(This,pObject,lFlags,pCtx,pResponseHandler)

#define IWbemServices_DeleteClass(This,Class,lFlags,pCtx,ppCallResult)	\
    (This)->lpVtbl -> DeleteClass(This,Class,lFlags,pCtx,ppCallResult)

#define IWbemServices_DeleteClassAsync(This,Class,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> DeleteClassAsync(This,Class,lFlags,pCtx,pResponseHandler)

#define IWbemServices_CreateClassEnum(This,Superclass,lFlags,pCtx,ppEnum)	\
    (This)->lpVtbl -> CreateClassEnum(This,Superclass,lFlags,pCtx,ppEnum)

#define IWbemServices_CreateClassEnumAsync(This,Superclass,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> CreateClassEnumAsync(This,Superclass,lFlags,pCtx,pResponseHandler)

#define IWbemServices_PutInstance(This,pInst,lFlags,pCtx,ppCallResult)	\
    (This)->lpVtbl -> PutInstance(This,pInst,lFlags,pCtx,ppCallResult)

#define IWbemServices_PutInstanceAsync(This,pInst,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> PutInstanceAsync(This,pInst,lFlags,pCtx,pResponseHandler)

#define IWbemServices_DeleteInstance(This,ObjectPath,lFlags,pCtx,ppCallResult)	\
    (This)->lpVtbl -> DeleteInstance(This,ObjectPath,lFlags,pCtx,ppCallResult)

#define IWbemServices_DeleteInstanceAsync(This,ObjectPath,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> DeleteInstanceAsync(This,ObjectPath,lFlags,pCtx,pResponseHandler)

#define IWbemServices_CreateInstanceEnum(This,Class,lFlags,pCtx,ppEnum)	\
    (This)->lpVtbl -> CreateInstanceEnum(This,Class,lFlags,pCtx,ppEnum)

#define IWbemServices_CreateInstanceEnumAsync(This,Class,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> CreateInstanceEnumAsync(This,Class,lFlags,pCtx,pResponseHandler)

#define IWbemServices_ExecQuery(This,QueryLanguage,Query,lFlags,pCtx,ppEnum)	\
    (This)->lpVtbl -> ExecQuery(This,QueryLanguage,Query,lFlags,pCtx,ppEnum)

#define IWbemServices_ExecQueryAsync(This,QueryLanguage,Query,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> ExecQueryAsync(This,QueryLanguage,Query,lFlags,pCtx,pResponseHandler)

#define IWbemServices_ExecNotificationQuery(This,QueryLanguage,Query,lFlags,pCtx,ppEnum)	\
    (This)->lpVtbl -> ExecNotificationQuery(This,QueryLanguage,Query,lFlags,pCtx,ppEnum)

#define IWbemServices_ExecNotificationQueryAsync(This,QueryLanguage,Query,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> ExecNotificationQueryAsync(This,QueryLanguage,Query,lFlags,pCtx,pResponseHandler)

#define IWbemServices_ExecMethod(This,ObjectPath,MethodName,lFlags,pCtx,pInParams,ppOutParams,ppCallResult)	\
    (This)->lpVtbl -> ExecMethod(This,ObjectPath,MethodName,lFlags,pCtx,pInParams,ppOutParams,ppCallResult)

#define IWbemServices_ExecMethodAsync(This,ObjectPath,MethodName,lFlags,pCtx,pInParams,pResponseHandler)	\
    (This)->lpVtbl -> ExecMethodAsync(This,ObjectPath,MethodName,lFlags,pCtx,pInParams,pResponseHandler)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IWbemServices_OpenNamespace_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ BSTR Namespace,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult);


void __RPC_STUB IWbemServices_OpenNamespace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemServices_CancelAsyncCall_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ IWbemObjectSink __RPC_FAR *pSink);


void __RPC_STUB IWbemServices_CancelAsyncCall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemServices_QueryObjectSink_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler);


void __RPC_STUB IWbemServices_QueryObjectSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemServices_GetObject_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ BSTR ObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);


void __RPC_STUB IWbemServices_GetObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemServices_GetObjectAsync_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ BSTR ObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);


void __RPC_STUB IWbemServices_GetObjectAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemServices_PutClass_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ IWbemClassObject __RPC_FAR *pObject,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);


void __RPC_STUB IWbemServices_PutClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemServices_PutClassAsync_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ IWbemClassObject __RPC_FAR *pObject,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);


void __RPC_STUB IWbemServices_PutClassAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemServices_DeleteClass_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ BSTR Class,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);


void __RPC_STUB IWbemServices_DeleteClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemServices_DeleteClassAsync_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ BSTR Class,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);


void __RPC_STUB IWbemServices_DeleteClassAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemServices_CreateClassEnum_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ BSTR Superclass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IWbemServices_CreateClassEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemServices_CreateClassEnumAsync_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ BSTR Superclass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);


void __RPC_STUB IWbemServices_CreateClassEnumAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemServices_PutInstance_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ IWbemClassObject __RPC_FAR *pInst,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);


void __RPC_STUB IWbemServices_PutInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemServices_PutInstanceAsync_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ IWbemClassObject __RPC_FAR *pInst,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);


void __RPC_STUB IWbemServices_PutInstanceAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemServices_DeleteInstance_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ BSTR ObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);


void __RPC_STUB IWbemServices_DeleteInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemServices_DeleteInstanceAsync_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ BSTR ObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);


void __RPC_STUB IWbemServices_DeleteInstanceAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemServices_CreateInstanceEnum_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ BSTR Class,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IWbemServices_CreateInstanceEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemServices_CreateInstanceEnumAsync_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ BSTR Class,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);


void __RPC_STUB IWbemServices_CreateInstanceEnumAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemServices_ExecQuery_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ BSTR QueryLanguage,
    /* [in] */ BSTR Query,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IWbemServices_ExecQuery_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemServices_ExecQueryAsync_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ BSTR QueryLanguage,
    /* [in] */ BSTR Query,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);


void __RPC_STUB IWbemServices_ExecQueryAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemServices_ExecNotificationQuery_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ BSTR QueryLanguage,
    /* [in] */ BSTR Query,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IWbemServices_ExecNotificationQuery_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemServices_ExecNotificationQueryAsync_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ BSTR QueryLanguage,
    /* [in] */ BSTR Query,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);


void __RPC_STUB IWbemServices_ExecNotificationQueryAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemServices_ExecMethod_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ BSTR ObjectPath,
    /* [in] */ BSTR MethodName,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
    /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);


void __RPC_STUB IWbemServices_ExecMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemServices_ExecMethodAsync_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ BSTR ObjectPath,
    /* [in] */ BSTR MethodName,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);


void __RPC_STUB IWbemServices_ExecMethodAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemServices_INTERFACE_DEFINED__ */


#ifndef __IWbemLocator_INTERFACE_DEFINED__
#define __IWbemLocator_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IWbemLocator
 * at Tue Aug 19 16:16:10 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][oleautomation][dual][uuid][local][object] */ 



EXTERN_C const IID IID_IWbemLocator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("dc12a687-737f-11cf-884d-00aa004b2e24")
    IWbemLocator : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ConnectServer( 
            /* [in] */ BSTR NetworkResource,
            /* [in] */ BSTR User,
            /* [in] */ BSTR Password,
            /* [in] */ BSTR Locale,
            /* [in] */ long lSecurityFlags,
            /* [in] */ BSTR Authority,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppNamespace) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemLocatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWbemLocator __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWbemLocator __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWbemLocator __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IWbemLocator __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IWbemLocator __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IWbemLocator __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IWbemLocator __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ConnectServer )( 
            IWbemLocator __RPC_FAR * This,
            /* [in] */ BSTR NetworkResource,
            /* [in] */ BSTR User,
            /* [in] */ BSTR Password,
            /* [in] */ BSTR Locale,
            /* [in] */ long lSecurityFlags,
            /* [in] */ BSTR Authority,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppNamespace);
        
        END_INTERFACE
    } IWbemLocatorVtbl;

    interface IWbemLocator
    {
        CONST_VTBL struct IWbemLocatorVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemLocator_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemLocator_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemLocator_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemLocator_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWbemLocator_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWbemLocator_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWbemLocator_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWbemLocator_ConnectServer(This,NetworkResource,User,Password,Locale,lSecurityFlags,Authority,pCtx,ppNamespace)	\
    (This)->lpVtbl -> ConnectServer(This,NetworkResource,User,Password,Locale,lSecurityFlags,Authority,pCtx,ppNamespace)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemLocator_ConnectServer_Proxy( 
    IWbemLocator __RPC_FAR * This,
    /* [in] */ BSTR NetworkResource,
    /* [in] */ BSTR User,
    /* [in] */ BSTR Password,
    /* [in] */ BSTR Locale,
    /* [in] */ long lSecurityFlags,
    /* [in] */ BSTR Authority,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppNamespace);


void __RPC_STUB IWbemLocator_ConnectServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemLocator_INTERFACE_DEFINED__ */


#ifndef __IWbemObjectSink_INTERFACE_DEFINED__
#define __IWbemObjectSink_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IWbemObjectSink
 * at Tue Aug 19 16:16:10 1997
 * using MIDL 3.01.75
 ****************************************/
/* [dual][oleautomation][uuid][object] */ 



EXTERN_C const IID IID_IWbemObjectSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("7c857801-7381-11cf-884d-00aa004b2e24")
    IWbemObjectSink : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Indicate( 
            /* [in] */ long lObjectCount,
            /* [size_is][in] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObjArray) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetStatus( 
            /* [in] */ long lFlags,
            /* [in] */ HRESULT hResult,
            /* [in] */ BSTR strParam,
            /* [in] */ IWbemClassObject __RPC_FAR *pObjParam) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemObjectSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWbemObjectSink __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWbemObjectSink __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWbemObjectSink __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IWbemObjectSink __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IWbemObjectSink __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IWbemObjectSink __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IWbemObjectSink __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Indicate )( 
            IWbemObjectSink __RPC_FAR * This,
            /* [in] */ long lObjectCount,
            /* [size_is][in] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObjArray);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStatus )( 
            IWbemObjectSink __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [in] */ HRESULT hResult,
            /* [in] */ BSTR strParam,
            /* [in] */ IWbemClassObject __RPC_FAR *pObjParam);
        
        END_INTERFACE
    } IWbemObjectSinkVtbl;

    interface IWbemObjectSink
    {
        CONST_VTBL struct IWbemObjectSinkVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemObjectSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemObjectSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemObjectSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemObjectSink_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWbemObjectSink_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWbemObjectSink_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWbemObjectSink_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWbemObjectSink_Indicate(This,lObjectCount,ppObjArray)	\
    (This)->lpVtbl -> Indicate(This,lObjectCount,ppObjArray)

#define IWbemObjectSink_SetStatus(This,lFlags,hResult,strParam,pObjParam)	\
    (This)->lpVtbl -> SetStatus(This,lFlags,hResult,strParam,pObjParam)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IWbemObjectSink_Indicate_Proxy( 
    IWbemObjectSink __RPC_FAR * This,
    /* [in] */ long lObjectCount,
    /* [size_is][in] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObjArray);


void __RPC_STUB IWbemObjectSink_Indicate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemObjectSink_SetStatus_Proxy( 
    IWbemObjectSink __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [in] */ HRESULT hResult,
    /* [in] */ BSTR strParam,
    /* [in] */ IWbemClassObject __RPC_FAR *pObjParam);


void __RPC_STUB IWbemObjectSink_SetStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemObjectSink_INTERFACE_DEFINED__ */


#ifndef __IEnumWbemClassObject_INTERFACE_DEFINED__
#define __IEnumWbemClassObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumWbemClassObject
 * at Tue Aug 19 16:16:10 1997
 * using MIDL 3.01.75
 ****************************************/
/* [dual][oleautomation][uuid][object] */ 



EXTERN_C const IID IID_IEnumWbemClassObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("027947e1-d731-11ce-a357-000000000001")
    IEnumWbemClassObject : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ long lTimeout,
            /* [in] */ unsigned long uCount,
            /* [length_is][size_is][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObjects,
            /* [out] */ unsigned long __RPC_FAR *puReturned) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE NextAsync( 
            /* [in] */ unsigned long uCount,
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ long lTimeout,
            /* [in] */ unsigned long nCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumWbemClassObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumWbemClassObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumWbemClassObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumWbemClassObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IEnumWbemClassObject __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IEnumWbemClassObject __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IEnumWbemClassObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IEnumWbemClassObject __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumWbemClassObject __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumWbemClassObject __RPC_FAR * This,
            /* [in] */ long lTimeout,
            /* [in] */ unsigned long uCount,
            /* [length_is][size_is][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObjects,
            /* [out] */ unsigned long __RPC_FAR *puReturned);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NextAsync )( 
            IEnumWbemClassObject __RPC_FAR * This,
            /* [in] */ unsigned long uCount,
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumWbemClassObject __RPC_FAR * This,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumWbemClassObject __RPC_FAR * This,
            /* [in] */ long lTimeout,
            /* [in] */ unsigned long nCount);
        
        END_INTERFACE
    } IEnumWbemClassObjectVtbl;

    interface IEnumWbemClassObject
    {
        CONST_VTBL struct IEnumWbemClassObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumWbemClassObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumWbemClassObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumWbemClassObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumWbemClassObject_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IEnumWbemClassObject_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IEnumWbemClassObject_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IEnumWbemClassObject_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IEnumWbemClassObject_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumWbemClassObject_Next(This,lTimeout,uCount,ppObjects,puReturned)	\
    (This)->lpVtbl -> Next(This,lTimeout,uCount,ppObjects,puReturned)

#define IEnumWbemClassObject_NextAsync(This,uCount,pSink)	\
    (This)->lpVtbl -> NextAsync(This,uCount,pSink)

#define IEnumWbemClassObject_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumWbemClassObject_Skip(This,lTimeout,nCount)	\
    (This)->lpVtbl -> Skip(This,lTimeout,nCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IEnumWbemClassObject_Reset_Proxy( 
    IEnumWbemClassObject __RPC_FAR * This);


void __RPC_STUB IEnumWbemClassObject_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IEnumWbemClassObject_Next_Proxy( 
    IEnumWbemClassObject __RPC_FAR * This,
    /* [in] */ long lTimeout,
    /* [in] */ unsigned long uCount,
    /* [length_is][size_is][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObjects,
    /* [out] */ unsigned long __RPC_FAR *puReturned);


void __RPC_STUB IEnumWbemClassObject_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IEnumWbemClassObject_NextAsync_Proxy( 
    IEnumWbemClassObject __RPC_FAR * This,
    /* [in] */ unsigned long uCount,
    /* [in] */ IWbemObjectSink __RPC_FAR *pSink);


void __RPC_STUB IEnumWbemClassObject_NextAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IEnumWbemClassObject_Clone_Proxy( 
    IEnumWbemClassObject __RPC_FAR * This,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IEnumWbemClassObject_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IEnumWbemClassObject_Skip_Proxy( 
    IEnumWbemClassObject __RPC_FAR * This,
    /* [in] */ long lTimeout,
    /* [in] */ unsigned long nCount);


void __RPC_STUB IEnumWbemClassObject_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumWbemClassObject_INTERFACE_DEFINED__ */


#ifndef __IWbemConfigure_INTERFACE_DEFINED__
#define __IWbemConfigure_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IWbemConfigure
 * at Tue Aug 19 16:16:10 1997
 * using MIDL 3.01.75
 ****************************************/
/* [dual][oleautomation][uuid][object] */ 



EXTERN_C const IID IID_IWbemConfigure;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("9a368276-26cf-11d0-ad3c-00c04fd8fdff")
    IWbemConfigure : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetConfigurationFlags( 
            /* [in] */ long lFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemConfigureVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWbemConfigure __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWbemConfigure __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWbemConfigure __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IWbemConfigure __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IWbemConfigure __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IWbemConfigure __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IWbemConfigure __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetConfigurationFlags )( 
            IWbemConfigure __RPC_FAR * This,
            /* [in] */ long lFlags);
        
        END_INTERFACE
    } IWbemConfigureVtbl;

    interface IWbemConfigure
    {
        CONST_VTBL struct IWbemConfigureVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemConfigure_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemConfigure_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemConfigure_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemConfigure_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWbemConfigure_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWbemConfigure_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWbemConfigure_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWbemConfigure_SetConfigurationFlags(This,lFlags)	\
    (This)->lpVtbl -> SetConfigurationFlags(This,lFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IWbemConfigure_SetConfigurationFlags_Proxy( 
    IWbemConfigure __RPC_FAR * This,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemConfigure_SetConfigurationFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemConfigure_INTERFACE_DEFINED__ */


#ifndef __IWbemPropertyProvider_INTERFACE_DEFINED__
#define __IWbemPropertyProvider_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IWbemPropertyProvider
 * at Tue Aug 19 16:16:10 1997
 * using MIDL 3.01.75
 ****************************************/
/* [uuid][local][object] */ 



EXTERN_C const IID IID_IWbemPropertyProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("CE61E841-65BC-11d0-B6BD-00AA003240C7")
    IWbemPropertyProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ long lFlags,
            /* [in] */ BSTR Locale,
            /* [in] */ BSTR ClassMapping,
            /* [in] */ BSTR InstMapping,
            /* [in] */ BSTR PropMapping,
            /* [out] */ VARIANT __RPC_FAR *pvValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutProperty( 
            /* [in] */ long lFlags,
            /* [in] */ BSTR Locale,
            /* [in] */ BSTR ClassMapping,
            /* [in] */ BSTR InstMapping,
            /* [in] */ BSTR PropMapping,
            /* [in] */ VARIANT __RPC_FAR *pvValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemPropertyProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWbemPropertyProvider __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWbemPropertyProvider __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWbemPropertyProvider __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProperty )( 
            IWbemPropertyProvider __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [in] */ BSTR Locale,
            /* [in] */ BSTR ClassMapping,
            /* [in] */ BSTR InstMapping,
            /* [in] */ BSTR PropMapping,
            /* [out] */ VARIANT __RPC_FAR *pvValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutProperty )( 
            IWbemPropertyProvider __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [in] */ BSTR Locale,
            /* [in] */ BSTR ClassMapping,
            /* [in] */ BSTR InstMapping,
            /* [in] */ BSTR PropMapping,
            /* [in] */ VARIANT __RPC_FAR *pvValue);
        
        END_INTERFACE
    } IWbemPropertyProviderVtbl;

    interface IWbemPropertyProvider
    {
        CONST_VTBL struct IWbemPropertyProviderVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemPropertyProvider_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemPropertyProvider_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemPropertyProvider_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemPropertyProvider_GetProperty(This,lFlags,Locale,ClassMapping,InstMapping,PropMapping,pvValue)	\
    (This)->lpVtbl -> GetProperty(This,lFlags,Locale,ClassMapping,InstMapping,PropMapping,pvValue)

#define IWbemPropertyProvider_PutProperty(This,lFlags,Locale,ClassMapping,InstMapping,PropMapping,pvValue)	\
    (This)->lpVtbl -> PutProperty(This,lFlags,Locale,ClassMapping,InstMapping,PropMapping,pvValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemPropertyProvider_GetProperty_Proxy( 
    IWbemPropertyProvider __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [in] */ BSTR Locale,
    /* [in] */ BSTR ClassMapping,
    /* [in] */ BSTR InstMapping,
    /* [in] */ BSTR PropMapping,
    /* [out] */ VARIANT __RPC_FAR *pvValue);


void __RPC_STUB IWbemPropertyProvider_GetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemPropertyProvider_PutProperty_Proxy( 
    IWbemPropertyProvider __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [in] */ BSTR Locale,
    /* [in] */ BSTR ClassMapping,
    /* [in] */ BSTR InstMapping,
    /* [in] */ BSTR PropMapping,
    /* [in] */ VARIANT __RPC_FAR *pvValue);


void __RPC_STUB IWbemPropertyProvider_PutProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemPropertyProvider_INTERFACE_DEFINED__ */


#ifndef __IWbemTransport_INTERFACE_DEFINED__
#define __IWbemTransport_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IWbemTransport
 * at Tue Aug 19 16:16:10 1997
 * using MIDL 3.01.75
 ****************************************/
/* [uuid][object][local][restricted] */ 



EXTERN_C const IID IID_IWbemTransport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("553fe584-2156-11d0-b6ae-00aa003240c7")
    IWbemTransport : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ IWbemLocator __RPC_FAR *pInProcLocator) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemTransportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWbemTransport __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWbemTransport __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWbemTransport __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            IWbemTransport __RPC_FAR * This,
            /* [in] */ IWbemLocator __RPC_FAR *pInProcLocator);
        
        END_INTERFACE
    } IWbemTransportVtbl;

    interface IWbemTransport
    {
        CONST_VTBL struct IWbemTransportVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemTransport_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemTransport_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemTransport_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemTransport_Initialize(This,pInProcLocator)	\
    (This)->lpVtbl -> Initialize(This,pInProcLocator)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemTransport_Initialize_Proxy( 
    IWbemTransport __RPC_FAR * This,
    /* [in] */ IWbemLocator __RPC_FAR *pInProcLocator);


void __RPC_STUB IWbemTransport_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemTransport_INTERFACE_DEFINED__ */


#ifndef __IWbemSecurityHelp_INTERFACE_DEFINED__
#define __IWbemSecurityHelp_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IWbemSecurityHelp
 * at Tue Aug 19 16:16:10 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][restricted][uuid][object][local] */ 



EXTERN_C const IID IID_IWbemSecurityHelp;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("32e0ef00-c578-11d0-b6ca-00aa003240c7")
    IWbemSecurityHelp : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ComputeMD5( 
            /* [in] */ BYTE __RPC_FAR *pBlob,
            /* [in] */ long lBlobLength,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *pMD5) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ComputeWBEMAccessToken( 
            /* [in] */ BYTE __RPC_FAR *pNonce,
            /* [in] */ LPWSTR pCleartextPassword,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *pAccessToken) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemSecurityHelpVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWbemSecurityHelp __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWbemSecurityHelp __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWbemSecurityHelp __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ComputeMD5 )( 
            IWbemSecurityHelp __RPC_FAR * This,
            /* [in] */ BYTE __RPC_FAR *pBlob,
            /* [in] */ long lBlobLength,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *pMD5);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ComputeWBEMAccessToken )( 
            IWbemSecurityHelp __RPC_FAR * This,
            /* [in] */ BYTE __RPC_FAR *pNonce,
            /* [in] */ LPWSTR pCleartextPassword,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *pAccessToken);
        
        END_INTERFACE
    } IWbemSecurityHelpVtbl;

    interface IWbemSecurityHelp
    {
        CONST_VTBL struct IWbemSecurityHelpVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemSecurityHelp_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemSecurityHelp_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemSecurityHelp_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemSecurityHelp_ComputeMD5(This,pBlob,lBlobLength,pMD5)	\
    (This)->lpVtbl -> ComputeMD5(This,pBlob,lBlobLength,pMD5)

#define IWbemSecurityHelp_ComputeWBEMAccessToken(This,pNonce,pCleartextPassword,pAccessToken)	\
    (This)->lpVtbl -> ComputeWBEMAccessToken(This,pNonce,pCleartextPassword,pAccessToken)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemSecurityHelp_ComputeMD5_Proxy( 
    IWbemSecurityHelp __RPC_FAR * This,
    /* [in] */ BYTE __RPC_FAR *pBlob,
    /* [in] */ long lBlobLength,
    /* [out] */ BYTE __RPC_FAR *__RPC_FAR *pMD5);


void __RPC_STUB IWbemSecurityHelp_ComputeMD5_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemSecurityHelp_ComputeWBEMAccessToken_Proxy( 
    IWbemSecurityHelp __RPC_FAR * This,
    /* [in] */ BYTE __RPC_FAR *pNonce,
    /* [in] */ LPWSTR pCleartextPassword,
    /* [out] */ BYTE __RPC_FAR *__RPC_FAR *pAccessToken);


void __RPC_STUB IWbemSecurityHelp_ComputeWBEMAccessToken_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemSecurityHelp_INTERFACE_DEFINED__ */


#ifndef __IWbemLevel1Login_INTERFACE_DEFINED__
#define __IWbemLevel1Login_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IWbemLevel1Login
 * at Tue Aug 19 16:16:10 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][restricted][object] */ 



EXTERN_C const IID IID_IWbemLevel1Login;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("F309AD18-D86A-11d0-A075-00C04FB68820")
    IWbemLevel1Login : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RequestChallenge( 
            /* [string][unique][in] */ LPWSTR pNetworkResource,
            /* [string][unique][in] */ LPWSTR pUser,
            /* [out] */ WBEM_128BITS Nonce,
            /* [in] */ DWORD dwProcessId,
            /* [unique][in][out] */ DWORD __RPC_FAR *pAuthEventHandle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SspiPreLogin( 
            /* [string][unique][in] */ LPWSTR pNetworkResource,
            /* [string][unique][in] */ LPSTR pszSSPIPkg,
            /* [in] */ long lFlags,
            /* [in] */ long lBufSize,
            /* [size_is][in] */ byte __RPC_FAR *pInToken,
            /* [in] */ long lOutBufSize,
            /* [out] */ long __RPC_FAR *plOutBufBytes,
            /* [size_is][out][in] */ byte __RPC_FAR *pOutToken,
            /* [in] */ DWORD dwProcessId,
            /* [unique][in][out] */ DWORD __RPC_FAR *pAuthEventHandle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Login( 
            /* [string][unique][in] */ LPWSTR pNetworkResource,
            /* [string][unique][in] */ LPWSTR pTokenType,
            /* [string][unique][in] */ LPWSTR pPreferredLocale,
            /* [unique][in] */ WBEM_128BITS AccessToken,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppNamespace) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemLevel1LoginVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWbemLevel1Login __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWbemLevel1Login __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWbemLevel1Login __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RequestChallenge )( 
            IWbemLevel1Login __RPC_FAR * This,
            /* [string][unique][in] */ LPWSTR pNetworkResource,
            /* [string][unique][in] */ LPWSTR pUser,
            /* [out] */ WBEM_128BITS Nonce,
            /* [in] */ DWORD dwProcessId,
            /* [unique][in][out] */ DWORD __RPC_FAR *pAuthEventHandle);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SspiPreLogin )( 
            IWbemLevel1Login __RPC_FAR * This,
            /* [string][unique][in] */ LPWSTR pNetworkResource,
            /* [string][unique][in] */ LPSTR pszSSPIPkg,
            /* [in] */ long lFlags,
            /* [in] */ long lBufSize,
            /* [size_is][in] */ byte __RPC_FAR *pInToken,
            /* [in] */ long lOutBufSize,
            /* [out] */ long __RPC_FAR *plOutBufBytes,
            /* [size_is][out][in] */ byte __RPC_FAR *pOutToken,
            /* [in] */ DWORD dwProcessId,
            /* [unique][in][out] */ DWORD __RPC_FAR *pAuthEventHandle);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Login )( 
            IWbemLevel1Login __RPC_FAR * This,
            /* [string][unique][in] */ LPWSTR pNetworkResource,
            /* [string][unique][in] */ LPWSTR pTokenType,
            /* [string][unique][in] */ LPWSTR pPreferredLocale,
            /* [unique][in] */ WBEM_128BITS AccessToken,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppNamespace);
        
        END_INTERFACE
    } IWbemLevel1LoginVtbl;

    interface IWbemLevel1Login
    {
        CONST_VTBL struct IWbemLevel1LoginVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemLevel1Login_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemLevel1Login_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemLevel1Login_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemLevel1Login_RequestChallenge(This,pNetworkResource,pUser,Nonce,dwProcessId,pAuthEventHandle)	\
    (This)->lpVtbl -> RequestChallenge(This,pNetworkResource,pUser,Nonce,dwProcessId,pAuthEventHandle)

#define IWbemLevel1Login_SspiPreLogin(This,pNetworkResource,pszSSPIPkg,lFlags,lBufSize,pInToken,lOutBufSize,plOutBufBytes,pOutToken,dwProcessId,pAuthEventHandle)	\
    (This)->lpVtbl -> SspiPreLogin(This,pNetworkResource,pszSSPIPkg,lFlags,lBufSize,pInToken,lOutBufSize,plOutBufBytes,pOutToken,dwProcessId,pAuthEventHandle)

#define IWbemLevel1Login_Login(This,pNetworkResource,pTokenType,pPreferredLocale,AccessToken,lFlags,pCtx,ppNamespace)	\
    (This)->lpVtbl -> Login(This,pNetworkResource,pTokenType,pPreferredLocale,AccessToken,lFlags,pCtx,ppNamespace)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemLevel1Login_RequestChallenge_Proxy( 
    IWbemLevel1Login __RPC_FAR * This,
    /* [string][unique][in] */ LPWSTR pNetworkResource,
    /* [string][unique][in] */ LPWSTR pUser,
    /* [out] */ WBEM_128BITS Nonce,
    /* [in] */ DWORD dwProcessId,
    /* [unique][in][out] */ DWORD __RPC_FAR *pAuthEventHandle);


void __RPC_STUB IWbemLevel1Login_RequestChallenge_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemLevel1Login_SspiPreLogin_Proxy( 
    IWbemLevel1Login __RPC_FAR * This,
    /* [string][unique][in] */ LPWSTR pNetworkResource,
    /* [string][unique][in] */ LPSTR pszSSPIPkg,
    /* [in] */ long lFlags,
    /* [in] */ long lBufSize,
    /* [size_is][in] */ byte __RPC_FAR *pInToken,
    /* [in] */ long lOutBufSize,
    /* [out] */ long __RPC_FAR *plOutBufBytes,
    /* [size_is][out][in] */ byte __RPC_FAR *pOutToken,
    /* [in] */ DWORD dwProcessId,
    /* [unique][in][out] */ DWORD __RPC_FAR *pAuthEventHandle);


void __RPC_STUB IWbemLevel1Login_SspiPreLogin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemLevel1Login_Login_Proxy( 
    IWbemLevel1Login __RPC_FAR * This,
    /* [string][unique][in] */ LPWSTR pNetworkResource,
    /* [string][unique][in] */ LPWSTR pTokenType,
    /* [string][unique][in] */ LPWSTR pPreferredLocale,
    /* [unique][in] */ WBEM_128BITS AccessToken,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppNamespace);


void __RPC_STUB IWbemLevel1Login_Login_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemLevel1Login_INTERFACE_DEFINED__ */


#ifndef __IWbemCallResult_INTERFACE_DEFINED__
#define __IWbemCallResult_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IWbemCallResult
 * at Tue Aug 19 16:16:10 1997
 * using MIDL 3.01.75
 ****************************************/
/* [dual][oleautomation][uuid][object] */ 



EXTERN_C const IID IID_IWbemCallResult;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("44aca675-e8fc-11d0-a07c-00c04fb68820")
    IWbemCallResult : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetResultObject( 
            /* [in] */ long lTimeout,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppResultObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetResultString( 
            /* [in] */ long lTimeout,
            /* [out] */ BSTR __RPC_FAR *pstrResultString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetResultServices( 
            /* [in] */ long lTimeout,
            /* [out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppServices) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCallStatus( 
            /* [in] */ long lTimeout,
            /* [out] */ long __RPC_FAR *plStatus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemCallResultVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWbemCallResult __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWbemCallResult __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWbemCallResult __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IWbemCallResult __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IWbemCallResult __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IWbemCallResult __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IWbemCallResult __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetResultObject )( 
            IWbemCallResult __RPC_FAR * This,
            /* [in] */ long lTimeout,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppResultObject);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetResultString )( 
            IWbemCallResult __RPC_FAR * This,
            /* [in] */ long lTimeout,
            /* [out] */ BSTR __RPC_FAR *pstrResultString);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetResultServices )( 
            IWbemCallResult __RPC_FAR * This,
            /* [in] */ long lTimeout,
            /* [out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppServices);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCallStatus )( 
            IWbemCallResult __RPC_FAR * This,
            /* [in] */ long lTimeout,
            /* [out] */ long __RPC_FAR *plStatus);
        
        END_INTERFACE
    } IWbemCallResultVtbl;

    interface IWbemCallResult
    {
        CONST_VTBL struct IWbemCallResultVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemCallResult_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemCallResult_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemCallResult_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemCallResult_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWbemCallResult_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWbemCallResult_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWbemCallResult_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWbemCallResult_GetResultObject(This,lTimeout,ppResultObject)	\
    (This)->lpVtbl -> GetResultObject(This,lTimeout,ppResultObject)

#define IWbemCallResult_GetResultString(This,lTimeout,pstrResultString)	\
    (This)->lpVtbl -> GetResultString(This,lTimeout,pstrResultString)

#define IWbemCallResult_GetResultServices(This,lTimeout,ppServices)	\
    (This)->lpVtbl -> GetResultServices(This,lTimeout,ppServices)

#define IWbemCallResult_GetCallStatus(This,lTimeout,plStatus)	\
    (This)->lpVtbl -> GetCallStatus(This,lTimeout,plStatus)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemCallResult_GetResultObject_Proxy( 
    IWbemCallResult __RPC_FAR * This,
    /* [in] */ long lTimeout,
    /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppResultObject);


void __RPC_STUB IWbemCallResult_GetResultObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemCallResult_GetResultString_Proxy( 
    IWbemCallResult __RPC_FAR * This,
    /* [in] */ long lTimeout,
    /* [out] */ BSTR __RPC_FAR *pstrResultString);


void __RPC_STUB IWbemCallResult_GetResultString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemCallResult_GetResultServices_Proxy( 
    IWbemCallResult __RPC_FAR * This,
    /* [in] */ long lTimeout,
    /* [out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppServices);


void __RPC_STUB IWbemCallResult_GetResultServices_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemCallResult_GetCallStatus_Proxy( 
    IWbemCallResult __RPC_FAR * This,
    /* [in] */ long lTimeout,
    /* [out] */ long __RPC_FAR *plStatus);


void __RPC_STUB IWbemCallResult_GetCallStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemCallResult_INTERFACE_DEFINED__ */


#ifndef __IWbemContext_INTERFACE_DEFINED__
#define __IWbemContext_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IWbemContext
 * at Tue Aug 19 16:16:10 1997
 * using MIDL 3.01.75
 ****************************************/
/* [dual][oleautomation][uuid][local][object] */ 



EXTERN_C const IID IID_IWbemContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("44aca674-e8fc-11d0-a07c-00c04fb68820")
    IWbemContext : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IWbemContext __RPC_FAR *__RPC_FAR *pNewCopy) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetNames( 
            /* [in] */ long lFlags,
            /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pNames) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE BeginEnumeration( 
            /* [in] */ long lFlags) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ long lFlags,
            /* [out] */ BSTR __RPC_FAR *pName,
            /* [out] */ VARIANT __RPC_FAR *pValue) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE EndEnumeration( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetValue( 
            /* [in] */ BSTR Name,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT __RPC_FAR *pValue) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetValue( 
            /* [in] */ BSTR Name,
            /* [in] */ long lFlags,
            /* [out] */ VARIANT __RPC_FAR *pValue) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE DeleteValue( 
            /* [in] */ BSTR Name,
            /* [in] */ long lFlags) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE DeleteAll( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWbemContext __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWbemContext __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWbemContext __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IWbemContext __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IWbemContext __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IWbemContext __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IWbemContext __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IWbemContext __RPC_FAR * This,
            /* [out] */ IWbemContext __RPC_FAR *__RPC_FAR *pNewCopy);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNames )( 
            IWbemContext __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pNames);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginEnumeration )( 
            IWbemContext __RPC_FAR * This,
            /* [in] */ long lFlags);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IWbemContext __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [out] */ BSTR __RPC_FAR *pName,
            /* [out] */ VARIANT __RPC_FAR *pValue);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndEnumeration )( 
            IWbemContext __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetValue )( 
            IWbemContext __RPC_FAR * This,
            /* [in] */ BSTR Name,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT __RPC_FAR *pValue);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetValue )( 
            IWbemContext __RPC_FAR * This,
            /* [in] */ BSTR Name,
            /* [in] */ long lFlags,
            /* [out] */ VARIANT __RPC_FAR *pValue);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteValue )( 
            IWbemContext __RPC_FAR * This,
            /* [in] */ BSTR Name,
            /* [in] */ long lFlags);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteAll )( 
            IWbemContext __RPC_FAR * This);
        
        END_INTERFACE
    } IWbemContextVtbl;

    interface IWbemContext
    {
        CONST_VTBL struct IWbemContextVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemContext_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemContext_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemContext_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemContext_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWbemContext_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWbemContext_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWbemContext_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWbemContext_Clone(This,pNewCopy)	\
    (This)->lpVtbl -> Clone(This,pNewCopy)

#define IWbemContext_GetNames(This,lFlags,pNames)	\
    (This)->lpVtbl -> GetNames(This,lFlags,pNames)

#define IWbemContext_BeginEnumeration(This,lFlags)	\
    (This)->lpVtbl -> BeginEnumeration(This,lFlags)

#define IWbemContext_Next(This,lFlags,pName,pValue)	\
    (This)->lpVtbl -> Next(This,lFlags,pName,pValue)

#define IWbemContext_EndEnumeration(This)	\
    (This)->lpVtbl -> EndEnumeration(This)

#define IWbemContext_SetValue(This,Name,lFlags,pValue)	\
    (This)->lpVtbl -> SetValue(This,Name,lFlags,pValue)

#define IWbemContext_GetValue(This,Name,lFlags,pValue)	\
    (This)->lpVtbl -> GetValue(This,Name,lFlags,pValue)

#define IWbemContext_DeleteValue(This,Name,lFlags)	\
    (This)->lpVtbl -> DeleteValue(This,Name,lFlags)

#define IWbemContext_DeleteAll(This)	\
    (This)->lpVtbl -> DeleteAll(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IWbemContext_Clone_Proxy( 
    IWbemContext __RPC_FAR * This,
    /* [out] */ IWbemContext __RPC_FAR *__RPC_FAR *pNewCopy);


void __RPC_STUB IWbemContext_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemContext_GetNames_Proxy( 
    IWbemContext __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pNames);


void __RPC_STUB IWbemContext_GetNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemContext_BeginEnumeration_Proxy( 
    IWbemContext __RPC_FAR * This,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemContext_BeginEnumeration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemContext_Next_Proxy( 
    IWbemContext __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [out] */ BSTR __RPC_FAR *pName,
    /* [out] */ VARIANT __RPC_FAR *pValue);


void __RPC_STUB IWbemContext_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemContext_EndEnumeration_Proxy( 
    IWbemContext __RPC_FAR * This);


void __RPC_STUB IWbemContext_EndEnumeration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemContext_SetValue_Proxy( 
    IWbemContext __RPC_FAR * This,
    /* [in] */ BSTR Name,
    /* [in] */ long lFlags,
    /* [in] */ VARIANT __RPC_FAR *pValue);


void __RPC_STUB IWbemContext_SetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemContext_GetValue_Proxy( 
    IWbemContext __RPC_FAR * This,
    /* [in] */ BSTR Name,
    /* [in] */ long lFlags,
    /* [out] */ VARIANT __RPC_FAR *pValue);


void __RPC_STUB IWbemContext_GetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemContext_DeleteValue_Proxy( 
    IWbemContext __RPC_FAR * This,
    /* [in] */ BSTR Name,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemContext_DeleteValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemContext_DeleteAll_Proxy( 
    IWbemContext __RPC_FAR * This);


void __RPC_STUB IWbemContext_DeleteAll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemContext_INTERFACE_DEFINED__ */


#ifndef __IWbemUnboundObjectSink_INTERFACE_DEFINED__
#define __IWbemUnboundObjectSink_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IWbemUnboundObjectSink
 * at Tue Aug 19 16:16:10 1997
 * using MIDL 3.01.75
 ****************************************/
/* [uuid][object] */ 



EXTERN_C const IID IID_IWbemUnboundObjectSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("e246107b-b06e-11d0-ad61-00c04fd8fdff")
    IWbemUnboundObjectSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IndicateToConsumer( 
            /* [in] */ IWbemClassObject __RPC_FAR *pLogicalConsumer,
            /* [in] */ long lNumObjects,
            /* [size_is][in] */ IWbemClassObject __RPC_FAR *__RPC_FAR *apObjects) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemUnboundObjectSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWbemUnboundObjectSink __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWbemUnboundObjectSink __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWbemUnboundObjectSink __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IndicateToConsumer )( 
            IWbemUnboundObjectSink __RPC_FAR * This,
            /* [in] */ IWbemClassObject __RPC_FAR *pLogicalConsumer,
            /* [in] */ long lNumObjects,
            /* [size_is][in] */ IWbemClassObject __RPC_FAR *__RPC_FAR *apObjects);
        
        END_INTERFACE
    } IWbemUnboundObjectSinkVtbl;

    interface IWbemUnboundObjectSink
    {
        CONST_VTBL struct IWbemUnboundObjectSinkVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemUnboundObjectSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemUnboundObjectSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemUnboundObjectSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemUnboundObjectSink_IndicateToConsumer(This,pLogicalConsumer,lNumObjects,apObjects)	\
    (This)->lpVtbl -> IndicateToConsumer(This,pLogicalConsumer,lNumObjects,apObjects)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemUnboundObjectSink_IndicateToConsumer_Proxy( 
    IWbemUnboundObjectSink __RPC_FAR * This,
    /* [in] */ IWbemClassObject __RPC_FAR *pLogicalConsumer,
    /* [in] */ long lNumObjects,
    /* [size_is][in] */ IWbemClassObject __RPC_FAR *__RPC_FAR *apObjects);


void __RPC_STUB IWbemUnboundObjectSink_IndicateToConsumer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemUnboundObjectSink_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_WbemLevel1Login;

class DECLSPEC_UUID("8BC3F05E-D86B-11d0-A075-00C04FB68820")
WbemLevel1Login;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_WbemLevel1LoginHelp;

class DECLSPEC_UUID("8BC3F05F-D86B-11d0-A075-00C04FB68820")
WbemLevel1LoginHelp;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_WbemLocator;

class DECLSPEC_UUID("4590f811-1d3a-11d0-891f-00aa004b2e24")
WbemLocator;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_WbemSecurityHelp;

class DECLSPEC_UUID("fa39d5a1-c584-11d0-9e48-00c04fc324a8")
WbemSecurityHelp;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_PrivateWbemLevel1Login;

class DECLSPEC_UUID("7d191c92-d92b-11d0-9e48-00c04fc324a8")
PrivateWbemLevel1Login;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_InProcWbemLevel1LoginHelp;

class DECLSPEC_UUID("7d191c93-d92b-11d0-9e48-00c04fc324a8")
InProcWbemLevel1LoginHelp;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_InProcWbemLevel1Login;

class DECLSPEC_UUID("1214c791-dd2a-11d0-9e49-00c04fc324a8")
InProcWbemLevel1Login;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_WbemContext;

class DECLSPEC_UUID("674B6698-EE92-11d0-AD71-00C04FD8FDFF")
WbemContext;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_WbemClassObjectProxy;

class DECLSPEC_UUID("4590f812-1d3a-11d0-891f-00aa004b2e24")
WbemClassObjectProxy;
#endif
#endif /* __WbemServices_v1_LIBRARY_DEFINED__ */

/****************************************
 * Generated header for interface: __MIDL_itf_wbemsvc_0000
 * at Tue Aug 19 16:16:10 1997
 * using MIDL 3.01.75
 ****************************************/
/* [local] */ 





extern RPC_IF_HANDLE __MIDL_itf_wbemsvc_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wbemsvc_0000_v0_0_s_ifspec;

/****************************************
 * Generated header for interface: __MIDL_itf_wbemsvc_0072
 * at Tue Aug 19 16:16:10 1997
 * using MIDL 3.01.75
 ****************************************/
/* [local] */ 






extern RPC_IF_HANDLE __MIDL_itf_wbemsvc_0072_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wbemsvc_0072_v0_0_s_ifspec;

#ifndef __IWbemLevel1LoginHelp_INTERFACE_DEFINED__
#define __IWbemLevel1LoginHelp_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IWbemLevel1LoginHelp
 * at Tue Aug 19 16:16:10 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][restricted][uuid][local][object] */ 



EXTERN_C const IID IID_IWbemLevel1LoginHelp;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("F309AD19-D86A-11d0-A075-00C04FB68820")
    IWbemLevel1LoginHelp : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InvalidateToken( 
            /* [unique][in] */ WBEM_128BITS AccessToken) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ValidateSignature( 
            /* [in] */ long lFlags,
            /* [unique][in] */ WBEM_128BITS PartialDigest,
            /* [unique][in] */ WBEM_128BITS AccessToken,
            /* [unique][in] */ WBEM_128BITS PacketSignature) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GenerateSignature( 
            /* [in] */ long lFlags,
            /* [unique][in] */ WBEM_128BITS PartialDigest,
            /* [unique][in] */ WBEM_128BITS AccessToken,
            /* [out] */ WBEM_128BITS PacketSignature) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemLevel1LoginHelpVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWbemLevel1LoginHelp __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWbemLevel1LoginHelp __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWbemLevel1LoginHelp __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InvalidateToken )( 
            IWbemLevel1LoginHelp __RPC_FAR * This,
            /* [unique][in] */ WBEM_128BITS AccessToken);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ValidateSignature )( 
            IWbemLevel1LoginHelp __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [unique][in] */ WBEM_128BITS PartialDigest,
            /* [unique][in] */ WBEM_128BITS AccessToken,
            /* [unique][in] */ WBEM_128BITS PacketSignature);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GenerateSignature )( 
            IWbemLevel1LoginHelp __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [unique][in] */ WBEM_128BITS PartialDigest,
            /* [unique][in] */ WBEM_128BITS AccessToken,
            /* [out] */ WBEM_128BITS PacketSignature);
        
        END_INTERFACE
    } IWbemLevel1LoginHelpVtbl;

    interface IWbemLevel1LoginHelp
    {
        CONST_VTBL struct IWbemLevel1LoginHelpVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemLevel1LoginHelp_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemLevel1LoginHelp_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemLevel1LoginHelp_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemLevel1LoginHelp_InvalidateToken(This,AccessToken)	\
    (This)->lpVtbl -> InvalidateToken(This,AccessToken)

#define IWbemLevel1LoginHelp_ValidateSignature(This,lFlags,PartialDigest,AccessToken,PacketSignature)	\
    (This)->lpVtbl -> ValidateSignature(This,lFlags,PartialDigest,AccessToken,PacketSignature)

#define IWbemLevel1LoginHelp_GenerateSignature(This,lFlags,PartialDigest,AccessToken,PacketSignature)	\
    (This)->lpVtbl -> GenerateSignature(This,lFlags,PartialDigest,AccessToken,PacketSignature)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemLevel1LoginHelp_InvalidateToken_Proxy( 
    IWbemLevel1LoginHelp __RPC_FAR * This,
    /* [unique][in] */ WBEM_128BITS AccessToken);


void __RPC_STUB IWbemLevel1LoginHelp_InvalidateToken_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemLevel1LoginHelp_ValidateSignature_Proxy( 
    IWbemLevel1LoginHelp __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [unique][in] */ WBEM_128BITS PartialDigest,
    /* [unique][in] */ WBEM_128BITS AccessToken,
    /* [unique][in] */ WBEM_128BITS PacketSignature);


void __RPC_STUB IWbemLevel1LoginHelp_ValidateSignature_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemLevel1LoginHelp_GenerateSignature_Proxy( 
    IWbemLevel1LoginHelp __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [unique][in] */ WBEM_128BITS PartialDigest,
    /* [unique][in] */ WBEM_128BITS AccessToken,
    /* [out] */ WBEM_128BITS PacketSignature);


void __RPC_STUB IWbemLevel1LoginHelp_GenerateSignature_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemLevel1LoginHelp_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\wbemcli.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Mon Jan 12 00:22:07 1998
 */
/* Compiler settings for wbemcli.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none

  Copyright (c) 1998-1999 Microsoft Corporation
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wbemcli_h__
#define __wbemcli_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IWbemClassObject_FWD_DEFINED__
#define __IWbemClassObject_FWD_DEFINED__
typedef interface IWbemClassObject IWbemClassObject;
#endif 	/* __IWbemClassObject_FWD_DEFINED__ */


#ifndef __IWbemObjectAccess_FWD_DEFINED__
#define __IWbemObjectAccess_FWD_DEFINED__
typedef interface IWbemObjectAccess IWbemObjectAccess;
#endif 	/* __IWbemObjectAccess_FWD_DEFINED__ */


#ifndef __IWbemQualifierSet_FWD_DEFINED__
#define __IWbemQualifierSet_FWD_DEFINED__
typedef interface IWbemQualifierSet IWbemQualifierSet;
#endif 	/* __IWbemQualifierSet_FWD_DEFINED__ */


#ifndef __IWbemServices_FWD_DEFINED__
#define __IWbemServices_FWD_DEFINED__
typedef interface IWbemServices IWbemServices;
#endif 	/* __IWbemServices_FWD_DEFINED__ */


#ifndef __IWbemLocator_FWD_DEFINED__
#define __IWbemLocator_FWD_DEFINED__
typedef interface IWbemLocator IWbemLocator;
#endif 	/* __IWbemLocator_FWD_DEFINED__ */


#ifndef __IWbemObjectSink_FWD_DEFINED__
#define __IWbemObjectSink_FWD_DEFINED__
typedef interface IWbemObjectSink IWbemObjectSink;
#endif 	/* __IWbemObjectSink_FWD_DEFINED__ */


#ifndef __IEnumWbemClassObject_FWD_DEFINED__
#define __IEnumWbemClassObject_FWD_DEFINED__
typedef interface IEnumWbemClassObject IEnumWbemClassObject;
#endif 	/* __IEnumWbemClassObject_FWD_DEFINED__ */


#ifndef __IWbemCallResult_FWD_DEFINED__
#define __IWbemCallResult_FWD_DEFINED__
typedef interface IWbemCallResult IWbemCallResult;
#endif 	/* __IWbemCallResult_FWD_DEFINED__ */


#ifndef __IWbemContext_FWD_DEFINED__
#define __IWbemContext_FWD_DEFINED__
typedef interface IWbemContext IWbemContext;
#endif 	/* __IWbemContext_FWD_DEFINED__ */


#ifndef __IWbemRefresher_FWD_DEFINED__
#define __IWbemRefresher_FWD_DEFINED__
typedef interface IWbemRefresher IWbemRefresher;
#endif 	/* __IWbemRefresher_FWD_DEFINED__ */


#ifndef __IWbemConfigureRefresher_FWD_DEFINED__
#define __IWbemConfigureRefresher_FWD_DEFINED__
typedef interface IWbemConfigureRefresher IWbemConfigureRefresher;
#endif 	/* __IWbemConfigureRefresher_FWD_DEFINED__ */


#ifndef __IUnsecuredApartment_FWD_DEFINED__
#define __IUnsecuredApartment_FWD_DEFINED__
typedef interface IUnsecuredApartment IUnsecuredApartment;
#endif 	/* __IUnsecuredApartment_FWD_DEFINED__ */


#ifndef __WbemLocator_FWD_DEFINED__
#define __WbemLocator_FWD_DEFINED__

#ifdef __cplusplus
typedef class WbemLocator WbemLocator;
#else
typedef struct WbemLocator WbemLocator;
#endif /* __cplusplus */

#endif 	/* __WbemLocator_FWD_DEFINED__ */


#ifndef __WbemContext_FWD_DEFINED__
#define __WbemContext_FWD_DEFINED__

#ifdef __cplusplus
typedef class WbemContext WbemContext;
#else
typedef struct WbemContext WbemContext;
#endif /* __cplusplus */

#endif 	/* __WbemContext_FWD_DEFINED__ */


#ifndef __UnsecuredApartment_FWD_DEFINED__
#define __UnsecuredApartment_FWD_DEFINED__

#ifdef __cplusplus
typedef class UnsecuredApartment UnsecuredApartment;
#else
typedef struct UnsecuredApartment UnsecuredApartment;
#endif /* __cplusplus */

#endif 	/* __UnsecuredApartment_FWD_DEFINED__ */


#ifndef __WbemRefresher_FWD_DEFINED__
#define __WbemRefresher_FWD_DEFINED__

#ifdef __cplusplus
typedef class WbemRefresher WbemRefresher;
#else
typedef struct WbemRefresher WbemRefresher;
#endif /* __cplusplus */

#endif 	/* __WbemRefresher_FWD_DEFINED__ */


#ifndef __IWbemClassObject_FWD_DEFINED__
#define __IWbemClassObject_FWD_DEFINED__
typedef interface IWbemClassObject IWbemClassObject;
#endif 	/* __IWbemClassObject_FWD_DEFINED__ */


#ifndef __IWbemQualifierSet_FWD_DEFINED__
#define __IWbemQualifierSet_FWD_DEFINED__
typedef interface IWbemQualifierSet IWbemQualifierSet;
#endif 	/* __IWbemQualifierSet_FWD_DEFINED__ */


#ifndef __IWbemLocator_FWD_DEFINED__
#define __IWbemLocator_FWD_DEFINED__
typedef interface IWbemLocator IWbemLocator;
#endif 	/* __IWbemLocator_FWD_DEFINED__ */


#ifndef __IWbemObjectSink_FWD_DEFINED__
#define __IWbemObjectSink_FWD_DEFINED__
typedef interface IWbemObjectSink IWbemObjectSink;
#endif 	/* __IWbemObjectSink_FWD_DEFINED__ */


#ifndef __IEnumWbemClassObject_FWD_DEFINED__
#define __IEnumWbemClassObject_FWD_DEFINED__
typedef interface IEnumWbemClassObject IEnumWbemClassObject;
#endif 	/* __IEnumWbemClassObject_FWD_DEFINED__ */


#ifndef __IWbemContext_FWD_DEFINED__
#define __IWbemContext_FWD_DEFINED__
typedef interface IWbemContext IWbemContext;
#endif 	/* __IWbemContext_FWD_DEFINED__ */


#ifndef __IWbemCallResult_FWD_DEFINED__
#define __IWbemCallResult_FWD_DEFINED__
typedef interface IWbemCallResult IWbemCallResult;
#endif 	/* __IWbemCallResult_FWD_DEFINED__ */


#ifndef __IWbemServices_FWD_DEFINED__
#define __IWbemServices_FWD_DEFINED__
typedef interface IWbemServices IWbemServices;
#endif 	/* __IWbemServices_FWD_DEFINED__ */


#ifndef __IWbemObjectAccess_FWD_DEFINED__
#define __IWbemObjectAccess_FWD_DEFINED__
typedef interface IWbemObjectAccess IWbemObjectAccess;
#endif 	/* __IWbemObjectAccess_FWD_DEFINED__ */


#ifndef __IWbemRefresher_FWD_DEFINED__
#define __IWbemRefresher_FWD_DEFINED__
typedef interface IWbemRefresher IWbemRefresher;
#endif 	/* __IWbemRefresher_FWD_DEFINED__ */


#ifndef __IWbemConfigureRefresher_FWD_DEFINED__
#define __IWbemConfigureRefresher_FWD_DEFINED__
typedef interface IWbemConfigureRefresher IWbemConfigureRefresher;
#endif 	/* __IWbemConfigureRefresher_FWD_DEFINED__ */


#ifndef __IUnsecuredApartment_FWD_DEFINED__
#define __IUnsecuredApartment_FWD_DEFINED__
typedef interface IUnsecuredApartment IUnsecuredApartment;
#endif 	/* __IUnsecuredApartment_FWD_DEFINED__ */


void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


#ifndef __WbemClient_v1_LIBRARY_DEFINED__
#define __WbemClient_v1_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: WbemClient_v1
 * at Mon Jan 12 00:22:07 1998
 * using MIDL 3.01.75
 ****************************************/
/* [uuid] */ 














typedef 
enum tag_WBEM_GENUS_TYPE
    {	WBEM_GENUS_CLASS	= 1,
	WBEM_GENUS_INSTANCE	= 2
    }	WBEM_GENUS_TYPE;

typedef 
enum tag_WBEM_CHANGE_FLAG_TYPE
    {	WBEM_FLAG_CREATE_OR_UPDATE	= 0,
	WBEM_FLAG_UPDATE_ONLY	= 0x1,
	WBEM_FLAG_CREATE_ONLY	= 0x2
    }	WBEM_CHANGE_FLAG_TYPE;

typedef 
enum tag_WBEM_ASYNCHRONICITY_TYPE
    {	WBEM_RETURN_WHEN_COMPLETE	= 0,
	WBEM_RETURN_IMMEDIATELY	= 0x10,
	WBEM_FLAG_RETURN_IMMEDIATELY	= 0x10,
	WBEM_FLAG_FORWARD_ONLY	= 0x20,
	WBEM_FLAG_NO_ERROR_OBJECT	= 0x40,
	WBEM_FLAG_SEND_STATUS	= 0x80,
	WBEM_FLAG_DONT_SEND_STATUS	= 0
    }	WBEM_ASYNCHRONICITY_TYPE;

typedef 
enum tag_WBEM_STATUS_TYPE
    {	WBEM_STATUS_COMPLETE	= 0,
	WBEM_STATUS_REQUIREMENTS	= 1,
	WBEM_STATUS_PROGRESS	= 2
    }	WBEM_STATUS_TYPE;

typedef 
enum tag_WBEM_TIMEOUT_TYPE
    {	WBEM_NO_WAIT	= 0,
	WBEM_INFINITE	= 0xffffffff
    }	WBEM_TIMEOUT_TYPE;

typedef 
enum tag_WBEM_CONDITION_FLAG_TYPE
    {	WBEM_FLAG_ALWAYS	= 0,
	WBEM_FLAG_ONLY_IF_TRUE	= 0x1,
	WBEM_FLAG_ONLY_IF_FALSE	= 0x2,
	WBEM_FLAG_ONLY_IF_IDENTICAL	= 0x3,
	WBEM_MASK_PRIMARY_CONDITION	= 0x3,
	WBEM_FLAG_KEYS_ONLY	= 0x4,
	WBEM_FLAG_REFS_ONLY	= 0x8,
	WBEM_FLAG_LOCAL_ONLY	= 0x10,
	WBEM_FLAG_PROPAGATED_ONLY	= 0x20,
	WBEM_FLAG_SYSTEM_ONLY	= 0x30,
	WBEM_FLAG_NONSYSTEM_ONLY	= 0x40,
	WBEM_MASK_CONDITION_ORIGIN	= 0x70
    }	WBEM_CONDITION_FLAG_TYPE;

typedef 
enum tag_WBEM_FLAVOR_TYPE
    {	WBEM_FLAVOR_DONT_PROPAGATE	= 0,
	WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE	= 0x1,
	WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS	= 0x2,
	WBEM_FLAVOR_MASK_PROPAGATION	= 0xf,
	WBEM_FLAVOR_OVERRIDABLE	= 0,
	WBEM_FLAVOR_NOT_OVERRIDABLE	= 0x10,
	WBEM_FLAVOR_MASK_PERMISSIONS	= 0x10,
	WBEM_FLAVOR_ORIGIN_LOCAL	= 0,
	WBEM_FLAVOR_ORIGIN_PROPAGATED	= 0x20,
	WBEM_FLAVOR_ORIGIN_SYSTEM	= 0x40,
	WBEM_FLAVOR_MASK_ORIGIN	= 0x60
    }	WBEM_FLAVOR_TYPE;

typedef 
enum tag_WBEM_QUERY_FLAG_TYPE
    {	WBEM_FLAG_DEEP	= 0,
	WBEM_FLAG_SHALLOW	= 1,
	WBEM_FLAG_PROTOTYPE	= 2
    }	WBEM_QUERY_FLAG_TYPE;

typedef 
enum tag_WBEM_LIMITATION_FLAG_TYPE
    {	WBEM_FLAG_EXCLUDE_OBJECT_QUALIFIERS	= 0x10,
	WBEM_FLAG_EXCLUDE_PROPERTY_QUALIFIERS	= 0x20
    }	WBEM_LIMITATION_FLAG_TYPE;

typedef 
enum tag_WBEM_TEXT_FLAG_TYPE
    {	WBEM_FLAG_NO_FLAVORS	= 0x1
    }	WBEM_TEXT_FLAG_TYPE;

typedef 
enum tag_WBEM_COMPARISON_FLAG
    {	WBEM_COMPARISON_INCLUDE_ALL	= 0,
	WBEM_FLAG_IGNORE_QUALIFIERS	= 0x1,
	WBEM_FLAG_IGNORE_OBJECT_SOURCE	= 0x2,
	WBEM_FLAG_IGNORE_DEFAULT_VALUES	= 0x4,
	WBEM_FLAG_IGNORE_CLASS	= 0x8,
	WBEM_FLAG_IGNORE_CASE	= 0x10,
	WBEM_FLAG_IGNORE_FLAVOR	= 0x20
    }	WBEM_COMPARISON_FLAG;

typedef 
enum tag_WBEM_AUTHENTICATION
    {	WBEM_AUTHENTICATION_DEFAULT	= 0,
	WBEM_AUTHENTICATION_NTLM	= 0x1,
	WBEM_AUTHENTICATION_WBEM	= 0x2
    }	WBEM_LOGIN_AUTHENTICATION;

typedef 
enum tag_WBEM_LOCKING
    {	WBEM_FLAG_ALLOW_READ	= 0x1
    }	WBEM_LOCKING_FLAG_TYPE;

typedef 
enum tag_WBEMSTATUS
    {	WBEM_NO_ERROR	= 0,
	WBEM_S_NO_ERROR	= 0,
	WBEM_S_SAME	= 0,
	WBEM_S_FALSE	= 1,
	WBEM_S_ALREADY_EXISTS	= 0x40001,
	WBEM_S_RESET_TO_DEFAULT	= WBEM_S_ALREADY_EXISTS + 1,
	WBEM_S_DIFFERENT	= WBEM_S_RESET_TO_DEFAULT + 1,
	WBEM_S_TIMEDOUT	= WBEM_S_DIFFERENT + 1,
	WBEM_S_NO_MORE_DATA	= WBEM_S_TIMEDOUT + 1,
	WBEM_S_PRELOGIN	= WBEM_S_NO_MORE_DATA + 1,
	WBEM_S_LOGIN	= WBEM_S_PRELOGIN + 1,
	WBEM_S_OPERATION_CANCELED	= WBEM_S_LOGIN + 1,
	WBEM_S_PENDING	= WBEM_S_OPERATION_CANCELED + 1,
	WBEM_E_FAILED	= 0x80041001,
	WBEM_E_NOT_FOUND	= WBEM_E_FAILED + 1,
	WBEM_E_ACCESS_DENIED	= WBEM_E_NOT_FOUND + 1,
	WBEM_E_PROVIDER_FAILURE	= WBEM_E_ACCESS_DENIED + 1,
	WBEM_E_TYPE_MISMATCH	= WBEM_E_PROVIDER_FAILURE + 1,
	WBEM_E_OUT_OF_MEMORY	= WBEM_E_TYPE_MISMATCH + 1,
	WBEM_E_INVALID_CONTEXT	= WBEM_E_OUT_OF_MEMORY + 1,
	WBEM_E_INVALID_PARAMETER	= WBEM_E_INVALID_CONTEXT + 1,
	WBEM_E_NOT_AVAILABLE	= WBEM_E_INVALID_PARAMETER + 1,
	WBEM_E_CRITICAL_ERROR	= WBEM_E_NOT_AVAILABLE + 1,
	WBEM_E_INVALID_STREAM	= WBEM_E_CRITICAL_ERROR + 1,
	WBEM_E_NOT_SUPPORTED	= WBEM_E_INVALID_STREAM + 1,
	WBEM_E_INVALID_SUPERCLASS	= WBEM_E_NOT_SUPPORTED + 1,
	WBEM_E_INVALID_NAMESPACE	= WBEM_E_INVALID_SUPERCLASS + 1,
	WBEM_E_INVALID_OBJECT	= WBEM_E_INVALID_NAMESPACE + 1,
	WBEM_E_INVALID_CLASS	= WBEM_E_INVALID_OBJECT + 1,
	WBEM_E_PROVIDER_NOT_FOUND	= WBEM_E_INVALID_CLASS + 1,
	WBEM_E_INVALID_PROVIDER_REGISTRATION	= WBEM_E_PROVIDER_NOT_FOUND + 1,
	WBEM_E_PROVIDER_LOAD_FAILURE	= WBEM_E_INVALID_PROVIDER_REGISTRATION + 1,
	WBEM_E_INITIALIZATION_FAILURE	= WBEM_E_PROVIDER_LOAD_FAILURE + 1,
	WBEM_E_TRANSPORT_FAILURE	= WBEM_E_INITIALIZATION_FAILURE + 1,
	WBEM_E_INVALID_OPERATION	= WBEM_E_TRANSPORT_FAILURE + 1,
	WBEM_E_INVALID_QUERY	= WBEM_E_INVALID_OPERATION + 1,
	WBEM_E_INVALID_QUERY_TYPE	= WBEM_E_INVALID_QUERY + 1,
	WBEM_E_ALREADY_EXISTS	= WBEM_E_INVALID_QUERY_TYPE + 1,
	WBEM_E_OVERRIDE_NOT_ALLOWED	= WBEM_E_ALREADY_EXISTS + 1,
	WBEM_E_PROPAGATED_QUALIFIER	= WBEM_E_OVERRIDE_NOT_ALLOWED + 1,
	WBEM_E_PROPAGATED_PROPERTY	= WBEM_E_PROPAGATED_QUALIFIER + 1,
	WBEM_E_UNEXPECTED	= WBEM_E_PROPAGATED_PROPERTY + 1,
	WBEM_E_ILLEGAL_OPERATION	= WBEM_E_UNEXPECTED + 1,
	WBEM_E_CANNOT_BE_KEY	= WBEM_E_ILLEGAL_OPERATION + 1,
	WBEM_E_INCOMPLETE_CLASS	= WBEM_E_CANNOT_BE_KEY + 1,
	WBEM_E_INVALID_SYNTAX	= WBEM_E_INCOMPLETE_CLASS + 1,
	WBEM_E_NONDECORATED_OBJECT	= WBEM_E_INVALID_SYNTAX + 1,
	WBEM_E_READ_ONLY	= WBEM_E_NONDECORATED_OBJECT + 1,
	WBEM_E_PROVIDER_NOT_CAPABLE	= WBEM_E_READ_ONLY + 1,
	WBEM_E_CLASS_HAS_CHILDREN	= WBEM_E_PROVIDER_NOT_CAPABLE + 1,
	WBEM_E_CLASS_HAS_INSTANCES	= WBEM_E_CLASS_HAS_CHILDREN + 1,
	WBEM_E_QUERY_NOT_IMPLEMENTED	= WBEM_E_CLASS_HAS_INSTANCES + 1,
	WBEM_E_ILLEGAL_NULL	= WBEM_E_QUERY_NOT_IMPLEMENTED + 1,
	WBEM_E_INVALID_QUALIFIER_TYPE	= WBEM_E_ILLEGAL_NULL + 1,
	WBEM_E_INVALID_PROPERTY_TYPE	= WBEM_E_INVALID_QUALIFIER_TYPE + 1,
	WBEM_E_VALUE_OUT_OF_RANGE	= WBEM_E_INVALID_PROPERTY_TYPE + 1,
	WBEM_E_CANNOT_BE_SINGLETON	= WBEM_E_VALUE_OUT_OF_RANGE + 1,
	WBEM_E_INVALID_CIM_TYPE	= WBEM_E_CANNOT_BE_SINGLETON + 1,
	WBEM_E_INVALID_METHOD	= WBEM_E_INVALID_CIM_TYPE + 1,
	WBEM_E_INVALID_METHOD_PARAMETERS	= WBEM_E_INVALID_METHOD + 1,
	WBEM_E_SYSTEM_PROPERTY	= WBEM_E_INVALID_METHOD_PARAMETERS + 1,
	WBEM_E_INVALID_PROPERTY	= WBEM_E_SYSTEM_PROPERTY + 1,
	WBEM_E_CALL_CANCELLED	= WBEM_E_INVALID_PROPERTY + 1,
	WBEM_E_SHUTTING_DOWN	= WBEM_E_CALL_CANCELLED + 1,
	WBEM_E_PROPAGATED_METHOD	= WBEM_E_SHUTTING_DOWN + 1,
	WBEMESS_E_REGISTRATION_TOO_BROAD	= 0x80005001,
	WBEMESS_E_REGISTRATION_TOO_PRECISE	= WBEMESS_E_REGISTRATION_TOO_BROAD + 1
    }	WBEMSTATUS;


EXTERN_C const IID LIBID_WbemClient_v1;

#ifndef __IWbemClassObject_INTERFACE_DEFINED__
#define __IWbemClassObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IWbemClassObject
 * at Mon Jan 12 00:22:07 1998
 * using MIDL 3.01.75
 ****************************************/
/* [uuid][object][restricted][local] */ 



EXTERN_C const IID IID_IWbemClassObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("dc12a681-737f-11cf-884d-00aa004b2e24")
    IWbemClassObject : public IUnknown
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetQualifierSet( 
            /* [out] */ IWbemQualifierSet __RPC_FAR *__RPC_FAR *ppQualSet) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Get( 
            /* [in] */ BSTR Name,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ VARIANT __RPC_FAR *pVal,
            /* [unique][in][out] */ VARTYPE __RPC_FAR *pvtType,
            /* [unique][in][out] */ long __RPC_FAR *plFlavor) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Put( 
            /* [in] */ BSTR Name,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT __RPC_FAR *pVal,
            /* [in] */ VARTYPE vtType) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Delete( 
            /* [in] */ BSTR Name) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetNames( 
            /* [in] */ BSTR QualifierName,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT __RPC_FAR *pQualifierVal,
            /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pNames) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE BeginEnumeration( 
            /* [in] */ long lEnumFlags) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ long lFlags,
            /* [unique][in][out] */ BSTR __RPC_FAR *pName,
            /* [unique][in][out] */ VARIANT __RPC_FAR *pVal,
            /* [unique][in][out] */ VARTYPE __RPC_FAR *pvtType,
            /* [unique][in][out] */ long __RPC_FAR *plFlavor) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE EndEnumeration( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetPropertyQualifierSet( 
            /* [in] */ BSTR pProperty,
            /* [out] */ IWbemQualifierSet __RPC_FAR *__RPC_FAR *ppQualSet) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppCopy) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetObjectText( 
            /* [in] */ long lFlags,
            /* [out] */ BSTR __RPC_FAR *pObjectText) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SpawnDerivedClass( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppNewClass) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SpawnInstance( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppNewInstance) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE CompareTo( 
            /* [in] */ long lFlags,
            /* [in] */ IWbemClassObject __RPC_FAR *pCompareTo) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetPropertyOrigin( 
            /* [in] */ BSTR strName,
            /* [out] */ BSTR __RPC_FAR *pstrClassName) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE InheritsFrom( 
            /* [in] */ BSTR strAncestor) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetMethod( 
            /* [in] */ BSTR Name,
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *pInSignature,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *pOutSignature) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE PutMethod( 
            /* [in] */ BSTR Name,
            /* [in] */ long lFlags,
            /* [in] */ IWbemClassObject __RPC_FAR *pInSignature,
            /* [in] */ IWbemClassObject __RPC_FAR *pOutSignature) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE DeleteMethod( 
            /* [in] */ BSTR Name) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE BeginMethodEnumeration( 
            /* [in] */ long lEnumFlags) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE NextMethod( 
            /* [in] */ long lFlags,
            /* [unique][in][out] */ BSTR __RPC_FAR *pName,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *pInSignature,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *pOutSignature) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE EndMethodEnumeration( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetMethodQualifierSet( 
            /* [in] */ BSTR Method,
            /* [out] */ IWbemQualifierSet __RPC_FAR *__RPC_FAR *ppQualSet) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetMethodOrigin( 
            /* [in] */ BSTR strMethodName,
            /* [out] */ BSTR __RPC_FAR *strClassName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemClassObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWbemClassObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWbemClassObject __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetQualifierSet )( 
            IWbemClassObject __RPC_FAR * This,
            /* [out] */ IWbemQualifierSet __RPC_FAR *__RPC_FAR *ppQualSet);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Get )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ BSTR Name,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ VARIANT __RPC_FAR *pVal,
            /* [unique][in][out] */ VARTYPE __RPC_FAR *pvtType,
            /* [unique][in][out] */ long __RPC_FAR *plFlavor);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Put )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ BSTR Name,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT __RPC_FAR *pVal,
            /* [in] */ VARTYPE vtType);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ BSTR Name);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNames )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ BSTR QualifierName,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT __RPC_FAR *pQualifierVal,
            /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pNames);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginEnumeration )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ long lEnumFlags);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ BSTR __RPC_FAR *pName,
            /* [unique][in][out] */ VARIANT __RPC_FAR *pVal,
            /* [unique][in][out] */ VARTYPE __RPC_FAR *pvtType,
            /* [unique][in][out] */ long __RPC_FAR *plFlavor);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndEnumeration )( 
            IWbemClassObject __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropertyQualifierSet )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ BSTR pProperty,
            /* [out] */ IWbemQualifierSet __RPC_FAR *__RPC_FAR *ppQualSet);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IWbemClassObject __RPC_FAR * This,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppCopy);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetObjectText )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [out] */ BSTR __RPC_FAR *pObjectText);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SpawnDerivedClass )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppNewClass);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SpawnInstance )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppNewInstance);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CompareTo )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [in] */ IWbemClassObject __RPC_FAR *pCompareTo);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropertyOrigin )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ BSTR strName,
            /* [out] */ BSTR __RPC_FAR *pstrClassName);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InheritsFrom )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ BSTR strAncestor);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMethod )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ BSTR Name,
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *pInSignature,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *pOutSignature);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutMethod )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ BSTR Name,
            /* [in] */ long lFlags,
            /* [in] */ IWbemClassObject __RPC_FAR *pInSignature,
            /* [in] */ IWbemClassObject __RPC_FAR *pOutSignature);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteMethod )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ BSTR Name);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginMethodEnumeration )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ long lEnumFlags);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NextMethod )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ BSTR __RPC_FAR *pName,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *pInSignature,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *pOutSignature);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndMethodEnumeration )( 
            IWbemClassObject __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMethodQualifierSet )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ BSTR Method,
            /* [out] */ IWbemQualifierSet __RPC_FAR *__RPC_FAR *ppQualSet);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMethodOrigin )( 
            IWbemClassObject __RPC_FAR * This,
            /* [in] */ BSTR strMethodName,
            /* [out] */ BSTR __RPC_FAR *strClassName);
        
        END_INTERFACE
    } IWbemClassObjectVtbl;

    interface IWbemClassObject
    {
        CONST_VTBL struct IWbemClassObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemClassObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemClassObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemClassObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemClassObject_GetQualifierSet(This,ppQualSet)	\
    (This)->lpVtbl -> GetQualifierSet(This,ppQualSet)

#define IWbemClassObject_Get(This,Name,lFlags,pVal,pvtType,plFlavor)	\
    (This)->lpVtbl -> Get(This,Name,lFlags,pVal,pvtType,plFlavor)

#define IWbemClassObject_Put(This,Name,lFlags,pVal,vtType)	\
    (This)->lpVtbl -> Put(This,Name,lFlags,pVal,vtType)

#define IWbemClassObject_Delete(This,Name)	\
    (This)->lpVtbl -> Delete(This,Name)

#define IWbemClassObject_GetNames(This,QualifierName,lFlags,pQualifierVal,pNames)	\
    (This)->lpVtbl -> GetNames(This,QualifierName,lFlags,pQualifierVal,pNames)

#define IWbemClassObject_BeginEnumeration(This,lEnumFlags)	\
    (This)->lpVtbl -> BeginEnumeration(This,lEnumFlags)

#define IWbemClassObject_Next(This,lFlags,pName,pVal,pvtType,plFlavor)	\
    (This)->lpVtbl -> Next(This,lFlags,pName,pVal,pvtType,plFlavor)

#define IWbemClassObject_EndEnumeration(This)	\
    (This)->lpVtbl -> EndEnumeration(This)

#define IWbemClassObject_GetPropertyQualifierSet(This,pProperty,ppQualSet)	\
    (This)->lpVtbl -> GetPropertyQualifierSet(This,pProperty,ppQualSet)

#define IWbemClassObject_Clone(This,ppCopy)	\
    (This)->lpVtbl -> Clone(This,ppCopy)

#define IWbemClassObject_GetObjectText(This,lFlags,pObjectText)	\
    (This)->lpVtbl -> GetObjectText(This,lFlags,pObjectText)

#define IWbemClassObject_SpawnDerivedClass(This,lFlags,ppNewClass)	\
    (This)->lpVtbl -> SpawnDerivedClass(This,lFlags,ppNewClass)

#define IWbemClassObject_SpawnInstance(This,lFlags,ppNewInstance)	\
    (This)->lpVtbl -> SpawnInstance(This,lFlags,ppNewInstance)

#define IWbemClassObject_CompareTo(This,lFlags,pCompareTo)	\
    (This)->lpVtbl -> CompareTo(This,lFlags,pCompareTo)

#define IWbemClassObject_GetPropertyOrigin(This,strName,pstrClassName)	\
    (This)->lpVtbl -> GetPropertyOrigin(This,strName,pstrClassName)

#define IWbemClassObject_InheritsFrom(This,strAncestor)	\
    (This)->lpVtbl -> InheritsFrom(This,strAncestor)

#define IWbemClassObject_GetMethod(This,Name,lFlags,pInSignature,pOutSignature)	\
    (This)->lpVtbl -> GetMethod(This,Name,lFlags,pInSignature,pOutSignature)

#define IWbemClassObject_PutMethod(This,Name,lFlags,pInSignature,pOutSignature)	\
    (This)->lpVtbl -> PutMethod(This,Name,lFlags,pInSignature,pOutSignature)

#define IWbemClassObject_DeleteMethod(This,Name)	\
    (This)->lpVtbl -> DeleteMethod(This,Name)

#define IWbemClassObject_BeginMethodEnumeration(This,lEnumFlags)	\
    (This)->lpVtbl -> BeginMethodEnumeration(This,lEnumFlags)

#define IWbemClassObject_NextMethod(This,lFlags,pName,pInSignature,pOutSignature)	\
    (This)->lpVtbl -> NextMethod(This,lFlags,pName,pInSignature,pOutSignature)

#define IWbemClassObject_EndMethodEnumeration(This)	\
    (This)->lpVtbl -> EndMethodEnumeration(This)

#define IWbemClassObject_GetMethodQualifierSet(This,Method,ppQualSet)	\
    (This)->lpVtbl -> GetMethodQualifierSet(This,Method,ppQualSet)

#define IWbemClassObject_GetMethodOrigin(This,strMethodName,strClassName)	\
    (This)->lpVtbl -> GetMethodOrigin(This,strMethodName,strClassName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IWbemClassObject_GetQualifierSet_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [out] */ IWbemQualifierSet __RPC_FAR *__RPC_FAR *ppQualSet);


void __RPC_STUB IWbemClassObject_GetQualifierSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemClassObject_Get_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [in] */ BSTR Name,
    /* [in] */ long lFlags,
    /* [unique][in][out] */ VARIANT __RPC_FAR *pVal,
    /* [unique][in][out] */ VARTYPE __RPC_FAR *pvtType,
    /* [unique][in][out] */ long __RPC_FAR *plFlavor);


void __RPC_STUB IWbemClassObject_Get_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemClassObject_Put_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [in] */ BSTR Name,
    /* [in] */ long lFlags,
    /* [in] */ VARIANT __RPC_FAR *pVal,
    /* [in] */ VARTYPE vtType);


void __RPC_STUB IWbemClassObject_Put_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemClassObject_Delete_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [in] */ BSTR Name);


void __RPC_STUB IWbemClassObject_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemClassObject_GetNames_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [in] */ BSTR QualifierName,
    /* [in] */ long lFlags,
    /* [in] */ VARIANT __RPC_FAR *pQualifierVal,
    /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pNames);


void __RPC_STUB IWbemClassObject_GetNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemClassObject_BeginEnumeration_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [in] */ long lEnumFlags);


void __RPC_STUB IWbemClassObject_BeginEnumeration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemClassObject_Next_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [unique][in][out] */ BSTR __RPC_FAR *pName,
    /* [unique][in][out] */ VARIANT __RPC_FAR *pVal,
    /* [unique][in][out] */ VARTYPE __RPC_FAR *pvtType,
    /* [unique][in][out] */ long __RPC_FAR *plFlavor);


void __RPC_STUB IWbemClassObject_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemClassObject_EndEnumeration_Proxy( 
    IWbemClassObject __RPC_FAR * This);


void __RPC_STUB IWbemClassObject_EndEnumeration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemClassObject_GetPropertyQualifierSet_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [in] */ BSTR pProperty,
    /* [out] */ IWbemQualifierSet __RPC_FAR *__RPC_FAR *ppQualSet);


void __RPC_STUB IWbemClassObject_GetPropertyQualifierSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemClassObject_Clone_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppCopy);


void __RPC_STUB IWbemClassObject_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemClassObject_GetObjectText_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [out] */ BSTR __RPC_FAR *pObjectText);


void __RPC_STUB IWbemClassObject_GetObjectText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemClassObject_SpawnDerivedClass_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppNewClass);


void __RPC_STUB IWbemClassObject_SpawnDerivedClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemClassObject_SpawnInstance_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppNewInstance);


void __RPC_STUB IWbemClassObject_SpawnInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemClassObject_CompareTo_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [in] */ IWbemClassObject __RPC_FAR *pCompareTo);


void __RPC_STUB IWbemClassObject_CompareTo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemClassObject_GetPropertyOrigin_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [in] */ BSTR strName,
    /* [out] */ BSTR __RPC_FAR *pstrClassName);


void __RPC_STUB IWbemClassObject_GetPropertyOrigin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemClassObject_InheritsFrom_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [in] */ BSTR strAncestor);


void __RPC_STUB IWbemClassObject_InheritsFrom_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemClassObject_GetMethod_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [in] */ BSTR Name,
    /* [in] */ long lFlags,
    /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *pInSignature,
    /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *pOutSignature);


void __RPC_STUB IWbemClassObject_GetMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemClassObject_PutMethod_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [in] */ BSTR Name,
    /* [in] */ long lFlags,
    /* [in] */ IWbemClassObject __RPC_FAR *pInSignature,
    /* [in] */ IWbemClassObject __RPC_FAR *pOutSignature);


void __RPC_STUB IWbemClassObject_PutMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemClassObject_DeleteMethod_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [in] */ BSTR Name);


void __RPC_STUB IWbemClassObject_DeleteMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemClassObject_BeginMethodEnumeration_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [in] */ long lEnumFlags);


void __RPC_STUB IWbemClassObject_BeginMethodEnumeration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemClassObject_NextMethod_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [unique][in][out] */ BSTR __RPC_FAR *pName,
    /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *pInSignature,
    /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *pOutSignature);


void __RPC_STUB IWbemClassObject_NextMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemClassObject_EndMethodEnumeration_Proxy( 
    IWbemClassObject __RPC_FAR * This);


void __RPC_STUB IWbemClassObject_EndMethodEnumeration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemClassObject_GetMethodQualifierSet_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [in] */ BSTR Method,
    /* [out] */ IWbemQualifierSet __RPC_FAR *__RPC_FAR *ppQualSet);


void __RPC_STUB IWbemClassObject_GetMethodQualifierSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemClassObject_GetMethodOrigin_Proxy( 
    IWbemClassObject __RPC_FAR * This,
    /* [in] */ BSTR strMethodName,
    /* [out] */ BSTR __RPC_FAR *strClassName);


void __RPC_STUB IWbemClassObject_GetMethodOrigin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemClassObject_INTERFACE_DEFINED__ */


#ifndef __IWbemObjectAccess_INTERFACE_DEFINED__
#define __IWbemObjectAccess_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IWbemObjectAccess
 * at Mon Jan 12 00:22:07 1998
 * using MIDL 3.01.75
 ****************************************/
/* [uuid][object][restricted][local] */ 



EXTERN_C const IID IID_IWbemObjectAccess;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("49353c9a-516b-11d1-aea6-00c04fb68820")
    IWbemObjectAccess : public IWbemClassObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPropertyHandle( 
            /* [in] */ BSTR strPropertyName,
            /* [out] */ VARTYPE __RPC_FAR *pvt,
            /* [out] */ long __RPC_FAR *plHandle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WritePropertyValue( 
            /* [in] */ long lHandle,
            /* [in] */ long lNumBytes,
            /* [size_is][in] */ byte __RPC_FAR *pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadPropertyValue( 
            /* [in] */ long lHandle,
            /* [in] */ long lBufferSize,
            /* [out] */ long __RPC_FAR *plNumBytes,
            /* [length_is][size_is][out] */ byte __RPC_FAR *pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadDWORD( 
            /* [in] */ long lHandle,
            /* [out] */ DWORD __RPC_FAR *pdw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteDWORD( 
            /* [in] */ long lHandle,
            /* [in] */ DWORD dw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadQWORD( 
            /* [in] */ long lHandle,
            /* [out] */ MIDL_uhyper __RPC_FAR *pqw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteQWORD( 
            /* [in] */ long lHandle,
            /* [in] */ MIDL_uhyper pw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropertyInfoByHandle( 
            /* [in] */ long lHandle,
            /* [out] */ BSTR __RPC_FAR *pstrName,
            /* [out] */ VARTYPE __RPC_FAR *pvt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Lock( 
            /* [in] */ long lFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unlock( 
            /* [in] */ long lFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemObjectAccessVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWbemObjectAccess __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWbemObjectAccess __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetQualifierSet )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [out] */ IWbemQualifierSet __RPC_FAR *__RPC_FAR *ppQualSet);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Get )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ BSTR Name,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ VARIANT __RPC_FAR *pVal,
            /* [unique][in][out] */ VARTYPE __RPC_FAR *pvtType,
            /* [unique][in][out] */ long __RPC_FAR *plFlavor);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Put )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ BSTR Name,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT __RPC_FAR *pVal,
            /* [in] */ VARTYPE vtType);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ BSTR Name);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNames )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ BSTR QualifierName,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT __RPC_FAR *pQualifierVal,
            /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pNames);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginEnumeration )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ long lEnumFlags);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ BSTR __RPC_FAR *pName,
            /* [unique][in][out] */ VARIANT __RPC_FAR *pVal,
            /* [unique][in][out] */ VARTYPE __RPC_FAR *pvtType,
            /* [unique][in][out] */ long __RPC_FAR *plFlavor);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndEnumeration )( 
            IWbemObjectAccess __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropertyQualifierSet )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ BSTR pProperty,
            /* [out] */ IWbemQualifierSet __RPC_FAR *__RPC_FAR *ppQualSet);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppCopy);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetObjectText )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [out] */ BSTR __RPC_FAR *pObjectText);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SpawnDerivedClass )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppNewClass);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SpawnInstance )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppNewInstance);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CompareTo )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [in] */ IWbemClassObject __RPC_FAR *pCompareTo);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropertyOrigin )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ BSTR strName,
            /* [out] */ BSTR __RPC_FAR *pstrClassName);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InheritsFrom )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ BSTR strAncestor);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMethod )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ BSTR Name,
            /* [in] */ long lFlags,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *pInSignature,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *pOutSignature);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutMethod )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ BSTR Name,
            /* [in] */ long lFlags,
            /* [in] */ IWbemClassObject __RPC_FAR *pInSignature,
            /* [in] */ IWbemClassObject __RPC_FAR *pOutSignature);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteMethod )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ BSTR Name);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginMethodEnumeration )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ long lEnumFlags);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NextMethod )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ BSTR __RPC_FAR *pName,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *pInSignature,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *pOutSignature);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndMethodEnumeration )( 
            IWbemObjectAccess __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMethodQualifierSet )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ BSTR Method,
            /* [out] */ IWbemQualifierSet __RPC_FAR *__RPC_FAR *ppQualSet);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMethodOrigin )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ BSTR strMethodName,
            /* [out] */ BSTR __RPC_FAR *strClassName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropertyHandle )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ BSTR strPropertyName,
            /* [out] */ VARTYPE __RPC_FAR *pvt,
            /* [out] */ long __RPC_FAR *plHandle);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WritePropertyValue )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ long lHandle,
            /* [in] */ long lNumBytes,
            /* [size_is][in] */ byte __RPC_FAR *pData);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReadPropertyValue )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ long lHandle,
            /* [in] */ long lBufferSize,
            /* [out] */ long __RPC_FAR *plNumBytes,
            /* [length_is][size_is][out] */ byte __RPC_FAR *pData);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReadDWORD )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ long lHandle,
            /* [out] */ DWORD __RPC_FAR *pdw);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WriteDWORD )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ long lHandle,
            /* [in] */ DWORD dw);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReadQWORD )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ long lHandle,
            /* [out] */ MIDL_uhyper __RPC_FAR *pqw);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WriteQWORD )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ long lHandle,
            /* [in] */ MIDL_uhyper pw);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropertyInfoByHandle )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ long lHandle,
            /* [out] */ BSTR __RPC_FAR *pstrName,
            /* [out] */ VARTYPE __RPC_FAR *pvt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Lock )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ long lFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Unlock )( 
            IWbemObjectAccess __RPC_FAR * This,
            /* [in] */ long lFlags);
        
        END_INTERFACE
    } IWbemObjectAccessVtbl;

    interface IWbemObjectAccess
    {
        CONST_VTBL struct IWbemObjectAccessVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemObjectAccess_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemObjectAccess_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemObjectAccess_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemObjectAccess_GetQualifierSet(This,ppQualSet)	\
    (This)->lpVtbl -> GetQualifierSet(This,ppQualSet)

#define IWbemObjectAccess_Get(This,Name,lFlags,pVal,pvtType,plFlavor)	\
    (This)->lpVtbl -> Get(This,Name,lFlags,pVal,pvtType,plFlavor)

#define IWbemObjectAccess_Put(This,Name,lFlags,pVal,vtType)	\
    (This)->lpVtbl -> Put(This,Name,lFlags,pVal,vtType)

#define IWbemObjectAccess_Delete(This,Name)	\
    (This)->lpVtbl -> Delete(This,Name)

#define IWbemObjectAccess_GetNames(This,QualifierName,lFlags,pQualifierVal,pNames)	\
    (This)->lpVtbl -> GetNames(This,QualifierName,lFlags,pQualifierVal,pNames)

#define IWbemObjectAccess_BeginEnumeration(This,lEnumFlags)	\
    (This)->lpVtbl -> BeginEnumeration(This,lEnumFlags)

#define IWbemObjectAccess_Next(This,lFlags,pName,pVal,pvtType,plFlavor)	\
    (This)->lpVtbl -> Next(This,lFlags,pName,pVal,pvtType,plFlavor)

#define IWbemObjectAccess_EndEnumeration(This)	\
    (This)->lpVtbl -> EndEnumeration(This)

#define IWbemObjectAccess_GetPropertyQualifierSet(This,pProperty,ppQualSet)	\
    (This)->lpVtbl -> GetPropertyQualifierSet(This,pProperty,ppQualSet)

#define IWbemObjectAccess_Clone(This,ppCopy)	\
    (This)->lpVtbl -> Clone(This,ppCopy)

#define IWbemObjectAccess_GetObjectText(This,lFlags,pObjectText)	\
    (This)->lpVtbl -> GetObjectText(This,lFlags,pObjectText)

#define IWbemObjectAccess_SpawnDerivedClass(This,lFlags,ppNewClass)	\
    (This)->lpVtbl -> SpawnDerivedClass(This,lFlags,ppNewClass)

#define IWbemObjectAccess_SpawnInstance(This,lFlags,ppNewInstance)	\
    (This)->lpVtbl -> SpawnInstance(This,lFlags,ppNewInstance)

#define IWbemObjectAccess_CompareTo(This,lFlags,pCompareTo)	\
    (This)->lpVtbl -> CompareTo(This,lFlags,pCompareTo)

#define IWbemObjectAccess_GetPropertyOrigin(This,strName,pstrClassName)	\
    (This)->lpVtbl -> GetPropertyOrigin(This,strName,pstrClassName)

#define IWbemObjectAccess_InheritsFrom(This,strAncestor)	\
    (This)->lpVtbl -> InheritsFrom(This,strAncestor)

#define IWbemObjectAccess_GetMethod(This,Name,lFlags,pInSignature,pOutSignature)	\
    (This)->lpVtbl -> GetMethod(This,Name,lFlags,pInSignature,pOutSignature)

#define IWbemObjectAccess_PutMethod(This,Name,lFlags,pInSignature,pOutSignature)	\
    (This)->lpVtbl -> PutMethod(This,Name,lFlags,pInSignature,pOutSignature)

#define IWbemObjectAccess_DeleteMethod(This,Name)	\
    (This)->lpVtbl -> DeleteMethod(This,Name)

#define IWbemObjectAccess_BeginMethodEnumeration(This,lEnumFlags)	\
    (This)->lpVtbl -> BeginMethodEnumeration(This,lEnumFlags)

#define IWbemObjectAccess_NextMethod(This,lFlags,pName,pInSignature,pOutSignature)	\
    (This)->lpVtbl -> NextMethod(This,lFlags,pName,pInSignature,pOutSignature)

#define IWbemObjectAccess_EndMethodEnumeration(This)	\
    (This)->lpVtbl -> EndMethodEnumeration(This)

#define IWbemObjectAccess_GetMethodQualifierSet(This,Method,ppQualSet)	\
    (This)->lpVtbl -> GetMethodQualifierSet(This,Method,ppQualSet)

#define IWbemObjectAccess_GetMethodOrigin(This,strMethodName,strClassName)	\
    (This)->lpVtbl -> GetMethodOrigin(This,strMethodName,strClassName)


#define IWbemObjectAccess_GetPropertyHandle(This,strPropertyName,pvt,plHandle)	\
    (This)->lpVtbl -> GetPropertyHandle(This,strPropertyName,pvt,plHandle)

#define IWbemObjectAccess_WritePropertyValue(This,lHandle,lNumBytes,pData)	\
    (This)->lpVtbl -> WritePropertyValue(This,lHandle,lNumBytes,pData)

#define IWbemObjectAccess_ReadPropertyValue(This,lHandle,lBufferSize,plNumBytes,pData)	\
    (This)->lpVtbl -> ReadPropertyValue(This,lHandle,lBufferSize,plNumBytes,pData)

#define IWbemObjectAccess_ReadDWORD(This,lHandle,pdw)	\
    (This)->lpVtbl -> ReadDWORD(This,lHandle,pdw)

#define IWbemObjectAccess_WriteDWORD(This,lHandle,dw)	\
    (This)->lpVtbl -> WriteDWORD(This,lHandle,dw)

#define IWbemObjectAccess_ReadQWORD(This,lHandle,pqw)	\
    (This)->lpVtbl -> ReadQWORD(This,lHandle,pqw)

#define IWbemObjectAccess_WriteQWORD(This,lHandle,pw)	\
    (This)->lpVtbl -> WriteQWORD(This,lHandle,pw)

#define IWbemObjectAccess_GetPropertyInfoByHandle(This,lHandle,pstrName,pvt)	\
    (This)->lpVtbl -> GetPropertyInfoByHandle(This,lHandle,pstrName,pvt)

#define IWbemObjectAccess_Lock(This,lFlags)	\
    (This)->lpVtbl -> Lock(This,lFlags)

#define IWbemObjectAccess_Unlock(This,lFlags)	\
    (This)->lpVtbl -> Unlock(This,lFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemObjectAccess_GetPropertyHandle_Proxy( 
    IWbemObjectAccess __RPC_FAR * This,
    /* [in] */ BSTR strPropertyName,
    /* [out] */ VARTYPE __RPC_FAR *pvt,
    /* [out] */ long __RPC_FAR *plHandle);


void __RPC_STUB IWbemObjectAccess_GetPropertyHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectAccess_WritePropertyValue_Proxy( 
    IWbemObjectAccess __RPC_FAR * This,
    /* [in] */ long lHandle,
    /* [in] */ long lNumBytes,
    /* [size_is][in] */ byte __RPC_FAR *pData);


void __RPC_STUB IWbemObjectAccess_WritePropertyValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectAccess_ReadPropertyValue_Proxy( 
    IWbemObjectAccess __RPC_FAR * This,
    /* [in] */ long lHandle,
    /* [in] */ long lBufferSize,
    /* [out] */ long __RPC_FAR *plNumBytes,
    /* [length_is][size_is][out] */ byte __RPC_FAR *pData);


void __RPC_STUB IWbemObjectAccess_ReadPropertyValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectAccess_ReadDWORD_Proxy( 
    IWbemObjectAccess __RPC_FAR * This,
    /* [in] */ long lHandle,
    /* [out] */ DWORD __RPC_FAR *pdw);


void __RPC_STUB IWbemObjectAccess_ReadDWORD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectAccess_WriteDWORD_Proxy( 
    IWbemObjectAccess __RPC_FAR * This,
    /* [in] */ long lHandle,
    /* [in] */ DWORD dw);


void __RPC_STUB IWbemObjectAccess_WriteDWORD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectAccess_ReadQWORD_Proxy( 
    IWbemObjectAccess __RPC_FAR * This,
    /* [in] */ long lHandle,
    /* [out] */ MIDL_uhyper __RPC_FAR *pqw);


void __RPC_STUB IWbemObjectAccess_ReadQWORD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectAccess_WriteQWORD_Proxy( 
    IWbemObjectAccess __RPC_FAR * This,
    /* [in] */ long lHandle,
    /* [in] */ MIDL_uhyper pw);


void __RPC_STUB IWbemObjectAccess_WriteQWORD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectAccess_GetPropertyInfoByHandle_Proxy( 
    IWbemObjectAccess __RPC_FAR * This,
    /* [in] */ long lHandle,
    /* [out] */ BSTR __RPC_FAR *pstrName,
    /* [out] */ VARTYPE __RPC_FAR *pvt);


void __RPC_STUB IWbemObjectAccess_GetPropertyInfoByHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectAccess_Lock_Proxy( 
    IWbemObjectAccess __RPC_FAR * This,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemObjectAccess_Lock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemObjectAccess_Unlock_Proxy( 
    IWbemObjectAccess __RPC_FAR * This,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemObjectAccess_Unlock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemObjectAccess_INTERFACE_DEFINED__ */


#ifndef __IWbemQualifierSet_INTERFACE_DEFINED__
#define __IWbemQualifierSet_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IWbemQualifierSet
 * at Mon Jan 12 00:22:07 1998
 * using MIDL 3.01.75
 ****************************************/
/* [uuid][local][restricted][object] */ 



EXTERN_C const IID IID_IWbemQualifierSet;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("dc12a680-737f-11cf-884d-00aa004b2e24")
    IWbemQualifierSet : public IUnknown
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Get( 
            /* [in] */ BSTR Name,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ VARIANT __RPC_FAR *pVal,
            /* [unique][in][out] */ long __RPC_FAR *plFlavor) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Put( 
            /* [in] */ BSTR Name,
            /* [in] */ VARIANT __RPC_FAR *pVal,
            /* [in] */ long lFlavor) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Delete( 
            /* [in] */ BSTR Name) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetNames( 
            /* [in] */ long lFlags,
            /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pNames) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE BeginEnumeration( 
            /* [in] */ long lFlags) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ long lFlags,
            /* [unique][in][out] */ BSTR __RPC_FAR *pName,
            /* [unique][in][out] */ VARIANT __RPC_FAR *pVal,
            /* [unique][in][out] */ long __RPC_FAR *plFlavor) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE EndEnumeration( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemQualifierSetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWbemQualifierSet __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWbemQualifierSet __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWbemQualifierSet __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Get )( 
            IWbemQualifierSet __RPC_FAR * This,
            /* [in] */ BSTR Name,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ VARIANT __RPC_FAR *pVal,
            /* [unique][in][out] */ long __RPC_FAR *plFlavor);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Put )( 
            IWbemQualifierSet __RPC_FAR * This,
            /* [in] */ BSTR Name,
            /* [in] */ VARIANT __RPC_FAR *pVal,
            /* [in] */ long lFlavor);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IWbemQualifierSet __RPC_FAR * This,
            /* [in] */ BSTR Name);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNames )( 
            IWbemQualifierSet __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pNames);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginEnumeration )( 
            IWbemQualifierSet __RPC_FAR * This,
            /* [in] */ long lFlags);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IWbemQualifierSet __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ BSTR __RPC_FAR *pName,
            /* [unique][in][out] */ VARIANT __RPC_FAR *pVal,
            /* [unique][in][out] */ long __RPC_FAR *plFlavor);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndEnumeration )( 
            IWbemQualifierSet __RPC_FAR * This);
        
        END_INTERFACE
    } IWbemQualifierSetVtbl;

    interface IWbemQualifierSet
    {
        CONST_VTBL struct IWbemQualifierSetVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemQualifierSet_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemQualifierSet_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemQualifierSet_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemQualifierSet_Get(This,Name,lFlags,pVal,plFlavor)	\
    (This)->lpVtbl -> Get(This,Name,lFlags,pVal,plFlavor)

#define IWbemQualifierSet_Put(This,Name,pVal,lFlavor)	\
    (This)->lpVtbl -> Put(This,Name,pVal,lFlavor)

#define IWbemQualifierSet_Delete(This,Name)	\
    (This)->lpVtbl -> Delete(This,Name)

#define IWbemQualifierSet_GetNames(This,lFlags,pNames)	\
    (This)->lpVtbl -> GetNames(This,lFlags,pNames)

#define IWbemQualifierSet_BeginEnumeration(This,lFlags)	\
    (This)->lpVtbl -> BeginEnumeration(This,lFlags)

#define IWbemQualifierSet_Next(This,lFlags,pName,pVal,plFlavor)	\
    (This)->lpVtbl -> Next(This,lFlags,pName,pVal,plFlavor)

#define IWbemQualifierSet_EndEnumeration(This)	\
    (This)->lpVtbl -> EndEnumeration(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IWbemQualifierSet_Get_Proxy( 
    IWbemQualifierSet __RPC_FAR * This,
    /* [in] */ BSTR Name,
    /* [in] */ long lFlags,
    /* [unique][in][out] */ VARIANT __RPC_FAR *pVal,
    /* [unique][in][out] */ long __RPC_FAR *plFlavor);


void __RPC_STUB IWbemQualifierSet_Get_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemQualifierSet_Put_Proxy( 
    IWbemQualifierSet __RPC_FAR * This,
    /* [in] */ BSTR Name,
    /* [in] */ VARIANT __RPC_FAR *pVal,
    /* [in] */ long lFlavor);


void __RPC_STUB IWbemQualifierSet_Put_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemQualifierSet_Delete_Proxy( 
    IWbemQualifierSet __RPC_FAR * This,
    /* [in] */ BSTR Name);


void __RPC_STUB IWbemQualifierSet_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemQualifierSet_GetNames_Proxy( 
    IWbemQualifierSet __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pNames);


void __RPC_STUB IWbemQualifierSet_GetNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemQualifierSet_BeginEnumeration_Proxy( 
    IWbemQualifierSet __RPC_FAR * This,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemQualifierSet_BeginEnumeration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemQualifierSet_Next_Proxy( 
    IWbemQualifierSet __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [unique][in][out] */ BSTR __RPC_FAR *pName,
    /* [unique][in][out] */ VARIANT __RPC_FAR *pVal,
    /* [unique][in][out] */ long __RPC_FAR *plFlavor);


void __RPC_STUB IWbemQualifierSet_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemQualifierSet_EndEnumeration_Proxy( 
    IWbemQualifierSet __RPC_FAR * This);


void __RPC_STUB IWbemQualifierSet_EndEnumeration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemQualifierSet_INTERFACE_DEFINED__ */


#ifndef __IWbemServices_INTERFACE_DEFINED__
#define __IWbemServices_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IWbemServices
 * at Mon Jan 12 00:22:07 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][restricted][object] */ 



EXTERN_C const IID IID_IWbemServices;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("9556dc99-828c-11cf-a37e-00aa003240c7")
    IWbemServices : public IUnknown
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE OpenNamespace( 
            /* [in] */ BSTR Namespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetObjectAsync( 
            /* [in] */ BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE PutClass( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE PutClassAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE DeleteClass( 
            /* [in] */ BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
            /* [in] */ BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE CreateClassEnum( 
            /* [in] */ BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
            /* [in] */ BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE PutInstance( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE DeleteInstance( 
            /* [in] */ BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
            /* [in] */ BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
            /* [in] */ BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
            /* [in] */ BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ BSTR QueryLanguage,
            /* [in] */ BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
            /* [in] */ BSTR QueryLanguage,
            /* [in] */ BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
            /* [in] */ BSTR QueryLanguage,
            /* [in] */ BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
            /* [in] */ BSTR QueryLanguage,
            /* [in] */ BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ExecMethod( 
            /* [in] */ BSTR ObjectPath,
            /* [in] */ BSTR MethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
            /* [in] */ BSTR ObjectPath,
            /* [in] */ BSTR MethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemServicesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWbemServices __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWbemServices __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenNamespace )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ BSTR Namespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CancelAsyncCall )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryObjectSink )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetObject )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetObjectAsync )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutClass )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutClassAsync )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteClass )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteClassAsync )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateClassEnum )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateClassEnumAsync )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutInstance )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutInstanceAsync )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteInstance )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteInstanceAsync )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateInstanceEnum )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateInstanceEnumAsync )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExecQuery )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ BSTR QueryLanguage,
            /* [in] */ BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExecQueryAsync )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ BSTR QueryLanguage,
            /* [in] */ BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExecNotificationQuery )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ BSTR QueryLanguage,
            /* [in] */ BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExecNotificationQueryAsync )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ BSTR QueryLanguage,
            /* [in] */ BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExecMethod )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ BSTR ObjectPath,
            /* [in] */ BSTR MethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExecMethodAsync )( 
            IWbemServices __RPC_FAR * This,
            /* [in] */ BSTR ObjectPath,
            /* [in] */ BSTR MethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
        
        END_INTERFACE
    } IWbemServicesVtbl;

    interface IWbemServices
    {
        CONST_VTBL struct IWbemServicesVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemServices_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemServices_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemServices_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemServices_OpenNamespace(This,Namespace,lFlags,pCtx,ppWorkingNamespace,ppResult)	\
    (This)->lpVtbl -> OpenNamespace(This,Namespace,lFlags,pCtx,ppWorkingNamespace,ppResult)

#define IWbemServices_CancelAsyncCall(This,pSink)	\
    (This)->lpVtbl -> CancelAsyncCall(This,pSink)

#define IWbemServices_QueryObjectSink(This,lFlags,ppResponseHandler)	\
    (This)->lpVtbl -> QueryObjectSink(This,lFlags,ppResponseHandler)

#define IWbemServices_GetObject(This,ObjectPath,lFlags,pCtx,ppObject,ppCallResult)	\
    (This)->lpVtbl -> GetObject(This,ObjectPath,lFlags,pCtx,ppObject,ppCallResult)

#define IWbemServices_GetObjectAsync(This,ObjectPath,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> GetObjectAsync(This,ObjectPath,lFlags,pCtx,pResponseHandler)

#define IWbemServices_PutClass(This,pObject,lFlags,pCtx,ppCallResult)	\
    (This)->lpVtbl -> PutClass(This,pObject,lFlags,pCtx,ppCallResult)

#define IWbemServices_PutClassAsync(This,pObject,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> PutClassAsync(This,pObject,lFlags,pCtx,pResponseHandler)

#define IWbemServices_DeleteClass(This,Class,lFlags,pCtx,ppCallResult)	\
    (This)->lpVtbl -> DeleteClass(This,Class,lFlags,pCtx,ppCallResult)

#define IWbemServices_DeleteClassAsync(This,Class,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> DeleteClassAsync(This,Class,lFlags,pCtx,pResponseHandler)

#define IWbemServices_CreateClassEnum(This,Superclass,lFlags,pCtx,ppEnum)	\
    (This)->lpVtbl -> CreateClassEnum(This,Superclass,lFlags,pCtx,ppEnum)

#define IWbemServices_CreateClassEnumAsync(This,Superclass,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> CreateClassEnumAsync(This,Superclass,lFlags,pCtx,pResponseHandler)

#define IWbemServices_PutInstance(This,pInst,lFlags,pCtx,ppCallResult)	\
    (This)->lpVtbl -> PutInstance(This,pInst,lFlags,pCtx,ppCallResult)

#define IWbemServices_PutInstanceAsync(This,pInst,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> PutInstanceAsync(This,pInst,lFlags,pCtx,pResponseHandler)

#define IWbemServices_DeleteInstance(This,ObjectPath,lFlags,pCtx,ppCallResult)	\
    (This)->lpVtbl -> DeleteInstance(This,ObjectPath,lFlags,pCtx,ppCallResult)

#define IWbemServices_DeleteInstanceAsync(This,ObjectPath,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> DeleteInstanceAsync(This,ObjectPath,lFlags,pCtx,pResponseHandler)

#define IWbemServices_CreateInstanceEnum(This,Class,lFlags,pCtx,ppEnum)	\
    (This)->lpVtbl -> CreateInstanceEnum(This,Class,lFlags,pCtx,ppEnum)

#define IWbemServices_CreateInstanceEnumAsync(This,Class,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> CreateInstanceEnumAsync(This,Class,lFlags,pCtx,pResponseHandler)

#define IWbemServices_ExecQuery(This,QueryLanguage,Query,lFlags,pCtx,ppEnum)	\
    (This)->lpVtbl -> ExecQuery(This,QueryLanguage,Query,lFlags,pCtx,ppEnum)

#define IWbemServices_ExecQueryAsync(This,QueryLanguage,Query,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> ExecQueryAsync(This,QueryLanguage,Query,lFlags,pCtx,pResponseHandler)

#define IWbemServices_ExecNotificationQuery(This,QueryLanguage,Query,lFlags,pCtx,ppEnum)	\
    (This)->lpVtbl -> ExecNotificationQuery(This,QueryLanguage,Query,lFlags,pCtx,ppEnum)

#define IWbemServices_ExecNotificationQueryAsync(This,QueryLanguage,Query,lFlags,pCtx,pResponseHandler)	\
    (This)->lpVtbl -> ExecNotificationQueryAsync(This,QueryLanguage,Query,lFlags,pCtx,pResponseHandler)

#define IWbemServices_ExecMethod(This,ObjectPath,MethodName,lFlags,pCtx,pInParams,ppOutParams,ppCallResult)	\
    (This)->lpVtbl -> ExecMethod(This,ObjectPath,MethodName,lFlags,pCtx,pInParams,ppOutParams,ppCallResult)

#define IWbemServices_ExecMethodAsync(This,ObjectPath,MethodName,lFlags,pCtx,pInParams,pResponseHandler)	\
    (This)->lpVtbl -> ExecMethodAsync(This,ObjectPath,MethodName,lFlags,pCtx,pInParams,pResponseHandler)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IWbemServices_OpenNamespace_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ BSTR Namespace,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult);


void __RPC_STUB IWbemServices_OpenNamespace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemServices_CancelAsyncCall_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ IWbemObjectSink __RPC_FAR *pSink);


void __RPC_STUB IWbemServices_CancelAsyncCall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemServices_QueryObjectSink_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler);


void __RPC_STUB IWbemServices_QueryObjectSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemServices_GetObject_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ BSTR ObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);


void __RPC_STUB IWbemServices_GetObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemServices_GetObjectAsync_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ BSTR ObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);


void __RPC_STUB IWbemServices_GetObjectAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemServices_PutClass_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ IWbemClassObject __RPC_FAR *pObject,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);


void __RPC_STUB IWbemServices_PutClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemServices_PutClassAsync_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ IWbemClassObject __RPC_FAR *pObject,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);


void __RPC_STUB IWbemServices_PutClassAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemServices_DeleteClass_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ BSTR Class,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);


void __RPC_STUB IWbemServices_DeleteClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemServices_DeleteClassAsync_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ BSTR Class,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);


void __RPC_STUB IWbemServices_DeleteClassAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemServices_CreateClassEnum_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ BSTR Superclass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IWbemServices_CreateClassEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemServices_CreateClassEnumAsync_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ BSTR Superclass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);


void __RPC_STUB IWbemServices_CreateClassEnumAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemServices_PutInstance_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ IWbemClassObject __RPC_FAR *pInst,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);


void __RPC_STUB IWbemServices_PutInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemServices_PutInstanceAsync_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ IWbemClassObject __RPC_FAR *pInst,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);


void __RPC_STUB IWbemServices_PutInstanceAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemServices_DeleteInstance_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ BSTR ObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);


void __RPC_STUB IWbemServices_DeleteInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemServices_DeleteInstanceAsync_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ BSTR ObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);


void __RPC_STUB IWbemServices_DeleteInstanceAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemServices_CreateInstanceEnum_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ BSTR Class,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IWbemServices_CreateInstanceEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemServices_CreateInstanceEnumAsync_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ BSTR Class,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);


void __RPC_STUB IWbemServices_CreateInstanceEnumAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemServices_ExecQuery_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ BSTR QueryLanguage,
    /* [in] */ BSTR Query,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IWbemServices_ExecQuery_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemServices_ExecQueryAsync_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ BSTR QueryLanguage,
    /* [in] */ BSTR Query,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);


void __RPC_STUB IWbemServices_ExecQueryAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemServices_ExecNotificationQuery_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ BSTR QueryLanguage,
    /* [in] */ BSTR Query,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IWbemServices_ExecNotificationQuery_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemServices_ExecNotificationQueryAsync_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ BSTR QueryLanguage,
    /* [in] */ BSTR Query,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);


void __RPC_STUB IWbemServices_ExecNotificationQueryAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemServices_ExecMethod_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ BSTR ObjectPath,
    /* [in] */ BSTR MethodName,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
    /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult);


void __RPC_STUB IWbemServices_ExecMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemServices_ExecMethodAsync_Proxy( 
    IWbemServices __RPC_FAR * This,
    /* [in] */ BSTR ObjectPath,
    /* [in] */ BSTR MethodName,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);


void __RPC_STUB IWbemServices_ExecMethodAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemServices_INTERFACE_DEFINED__ */


#ifndef __IWbemLocator_INTERFACE_DEFINED__
#define __IWbemLocator_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IWbemLocator
 * at Mon Jan 12 00:22:07 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][local][restricted][object] */ 



EXTERN_C const IID IID_IWbemLocator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("dc12a687-737f-11cf-884d-00aa004b2e24")
    IWbemLocator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ConnectServer( 
            /* [in] */ BSTR NetworkResource,
            /* [in] */ BSTR User,
            /* [in] */ BSTR Password,
            /* [in] */ BSTR Locale,
            /* [in] */ long lSecurityFlags,
            /* [in] */ BSTR Authority,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppNamespace) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemLocatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWbemLocator __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWbemLocator __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWbemLocator __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ConnectServer )( 
            IWbemLocator __RPC_FAR * This,
            /* [in] */ BSTR NetworkResource,
            /* [in] */ BSTR User,
            /* [in] */ BSTR Password,
            /* [in] */ BSTR Locale,
            /* [in] */ long lSecurityFlags,
            /* [in] */ BSTR Authority,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppNamespace);
        
        END_INTERFACE
    } IWbemLocatorVtbl;

    interface IWbemLocator
    {
        CONST_VTBL struct IWbemLocatorVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemLocator_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemLocator_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemLocator_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemLocator_ConnectServer(This,NetworkResource,User,Password,Locale,lSecurityFlags,Authority,pCtx,ppNamespace)	\
    (This)->lpVtbl -> ConnectServer(This,NetworkResource,User,Password,Locale,lSecurityFlags,Authority,pCtx,ppNamespace)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemLocator_ConnectServer_Proxy( 
    IWbemLocator __RPC_FAR * This,
    /* [in] */ BSTR NetworkResource,
    /* [in] */ BSTR User,
    /* [in] */ BSTR Password,
    /* [in] */ BSTR Locale,
    /* [in] */ long lSecurityFlags,
    /* [in] */ BSTR Authority,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppNamespace);


void __RPC_STUB IWbemLocator_ConnectServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemLocator_INTERFACE_DEFINED__ */


#ifndef __IWbemObjectSink_INTERFACE_DEFINED__
#define __IWbemObjectSink_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IWbemObjectSink
 * at Mon Jan 12 00:22:07 1998
 * using MIDL 3.01.75
 ****************************************/
/* [uuid][restricted][object] */ 



EXTERN_C const IID IID_IWbemObjectSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("7c857801-7381-11cf-884d-00aa004b2e24")
    IWbemObjectSink : public IUnknown
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Indicate( 
            /* [in] */ long lObjectCount,
            /* [size_is][in] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObjArray) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetStatus( 
            /* [in] */ long lFlags,
            /* [in] */ HRESULT hResult,
            /* [in] */ BSTR strParam,
            /* [in] */ IWbemClassObject __RPC_FAR *pObjParam) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemObjectSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWbemObjectSink __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWbemObjectSink __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWbemObjectSink __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Indicate )( 
            IWbemObjectSink __RPC_FAR * This,
            /* [in] */ long lObjectCount,
            /* [size_is][in] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObjArray);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStatus )( 
            IWbemObjectSink __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [in] */ HRESULT hResult,
            /* [in] */ BSTR strParam,
            /* [in] */ IWbemClassObject __RPC_FAR *pObjParam);
        
        END_INTERFACE
    } IWbemObjectSinkVtbl;

    interface IWbemObjectSink
    {
        CONST_VTBL struct IWbemObjectSinkVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemObjectSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemObjectSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemObjectSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemObjectSink_Indicate(This,lObjectCount,ppObjArray)	\
    (This)->lpVtbl -> Indicate(This,lObjectCount,ppObjArray)

#define IWbemObjectSink_SetStatus(This,lFlags,hResult,strParam,pObjParam)	\
    (This)->lpVtbl -> SetStatus(This,lFlags,hResult,strParam,pObjParam)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IWbemObjectSink_Indicate_Proxy( 
    IWbemObjectSink __RPC_FAR * This,
    /* [in] */ long lObjectCount,
    /* [size_is][in] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObjArray);


void __RPC_STUB IWbemObjectSink_Indicate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemObjectSink_SetStatus_Proxy( 
    IWbemObjectSink __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [in] */ HRESULT hResult,
    /* [in] */ BSTR strParam,
    /* [in] */ IWbemClassObject __RPC_FAR *pObjParam);


void __RPC_STUB IWbemObjectSink_SetStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemObjectSink_INTERFACE_DEFINED__ */


#ifndef __IEnumWbemClassObject_INTERFACE_DEFINED__
#define __IEnumWbemClassObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumWbemClassObject
 * at Mon Jan 12 00:22:07 1998
 * using MIDL 3.01.75
 ****************************************/
/* [uuid][restricted][object] */ 



EXTERN_C const IID IID_IEnumWbemClassObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("027947e1-d731-11ce-a357-000000000001")
    IEnumWbemClassObject : public IUnknown
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ long lTimeout,
            /* [in] */ ULONG uCount,
            /* [length_is][size_is][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObjects,
            /* [out] */ ULONG __RPC_FAR *puReturned) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE NextAsync( 
            /* [in] */ ULONG uCount,
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ long lTimeout,
            /* [in] */ ULONG nCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumWbemClassObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumWbemClassObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumWbemClassObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumWbemClassObject __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumWbemClassObject __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumWbemClassObject __RPC_FAR * This,
            /* [in] */ long lTimeout,
            /* [in] */ ULONG uCount,
            /* [length_is][size_is][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObjects,
            /* [out] */ ULONG __RPC_FAR *puReturned);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NextAsync )( 
            IEnumWbemClassObject __RPC_FAR * This,
            /* [in] */ ULONG uCount,
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumWbemClassObject __RPC_FAR * This,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumWbemClassObject __RPC_FAR * This,
            /* [in] */ long lTimeout,
            /* [in] */ ULONG nCount);
        
        END_INTERFACE
    } IEnumWbemClassObjectVtbl;

    interface IEnumWbemClassObject
    {
        CONST_VTBL struct IEnumWbemClassObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumWbemClassObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumWbemClassObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumWbemClassObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumWbemClassObject_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumWbemClassObject_Next(This,lTimeout,uCount,ppObjects,puReturned)	\
    (This)->lpVtbl -> Next(This,lTimeout,uCount,ppObjects,puReturned)

#define IEnumWbemClassObject_NextAsync(This,uCount,pSink)	\
    (This)->lpVtbl -> NextAsync(This,uCount,pSink)

#define IEnumWbemClassObject_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumWbemClassObject_Skip(This,lTimeout,nCount)	\
    (This)->lpVtbl -> Skip(This,lTimeout,nCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IEnumWbemClassObject_Reset_Proxy( 
    IEnumWbemClassObject __RPC_FAR * This);


void __RPC_STUB IEnumWbemClassObject_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IEnumWbemClassObject_Next_Proxy( 
    IEnumWbemClassObject __RPC_FAR * This,
    /* [in] */ long lTimeout,
    /* [in] */ ULONG uCount,
    /* [length_is][size_is][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObjects,
    /* [out] */ ULONG __RPC_FAR *puReturned);


void __RPC_STUB IEnumWbemClassObject_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IEnumWbemClassObject_NextAsync_Proxy( 
    IEnumWbemClassObject __RPC_FAR * This,
    /* [in] */ ULONG uCount,
    /* [in] */ IWbemObjectSink __RPC_FAR *pSink);


void __RPC_STUB IEnumWbemClassObject_NextAsync_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IEnumWbemClassObject_Clone_Proxy( 
    IEnumWbemClassObject __RPC_FAR * This,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IEnumWbemClassObject_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IEnumWbemClassObject_Skip_Proxy( 
    IEnumWbemClassObject __RPC_FAR * This,
    /* [in] */ long lTimeout,
    /* [in] */ ULONG nCount);


void __RPC_STUB IEnumWbemClassObject_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumWbemClassObject_INTERFACE_DEFINED__ */


#ifndef __IWbemCallResult_INTERFACE_DEFINED__
#define __IWbemCallResult_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IWbemCallResult
 * at Mon Jan 12 00:22:07 1998
 * using MIDL 3.01.75
 ****************************************/
/* [uuid][restricted][object] */ 



EXTERN_C const IID IID_IWbemCallResult;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("44aca675-e8fc-11d0-a07c-00c04fb68820")
    IWbemCallResult : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetResultObject( 
            /* [in] */ long lTimeout,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppResultObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetResultString( 
            /* [in] */ long lTimeout,
            /* [out] */ BSTR __RPC_FAR *pstrResultString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetResultServices( 
            /* [in] */ long lTimeout,
            /* [out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppServices) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCallStatus( 
            /* [in] */ long lTimeout,
            /* [out] */ long __RPC_FAR *plStatus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemCallResultVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWbemCallResult __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWbemCallResult __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWbemCallResult __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetResultObject )( 
            IWbemCallResult __RPC_FAR * This,
            /* [in] */ long lTimeout,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppResultObject);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetResultString )( 
            IWbemCallResult __RPC_FAR * This,
            /* [in] */ long lTimeout,
            /* [out] */ BSTR __RPC_FAR *pstrResultString);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetResultServices )( 
            IWbemCallResult __RPC_FAR * This,
            /* [in] */ long lTimeout,
            /* [out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppServices);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCallStatus )( 
            IWbemCallResult __RPC_FAR * This,
            /* [in] */ long lTimeout,
            /* [out] */ long __RPC_FAR *plStatus);
        
        END_INTERFACE
    } IWbemCallResultVtbl;

    interface IWbemCallResult
    {
        CONST_VTBL struct IWbemCallResultVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemCallResult_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemCallResult_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemCallResult_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemCallResult_GetResultObject(This,lTimeout,ppResultObject)	\
    (This)->lpVtbl -> GetResultObject(This,lTimeout,ppResultObject)

#define IWbemCallResult_GetResultString(This,lTimeout,pstrResultString)	\
    (This)->lpVtbl -> GetResultString(This,lTimeout,pstrResultString)

#define IWbemCallResult_GetResultServices(This,lTimeout,ppServices)	\
    (This)->lpVtbl -> GetResultServices(This,lTimeout,ppServices)

#define IWbemCallResult_GetCallStatus(This,lTimeout,plStatus)	\
    (This)->lpVtbl -> GetCallStatus(This,lTimeout,plStatus)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemCallResult_GetResultObject_Proxy( 
    IWbemCallResult __RPC_FAR * This,
    /* [in] */ long lTimeout,
    /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppResultObject);


void __RPC_STUB IWbemCallResult_GetResultObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemCallResult_GetResultString_Proxy( 
    IWbemCallResult __RPC_FAR * This,
    /* [in] */ long lTimeout,
    /* [out] */ BSTR __RPC_FAR *pstrResultString);


void __RPC_STUB IWbemCallResult_GetResultString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemCallResult_GetResultServices_Proxy( 
    IWbemCallResult __RPC_FAR * This,
    /* [in] */ long lTimeout,
    /* [out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppServices);


void __RPC_STUB IWbemCallResult_GetResultServices_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemCallResult_GetCallStatus_Proxy( 
    IWbemCallResult __RPC_FAR * This,
    /* [in] */ long lTimeout,
    /* [out] */ long __RPC_FAR *plStatus);


void __RPC_STUB IWbemCallResult_GetCallStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemCallResult_INTERFACE_DEFINED__ */


#ifndef __IWbemContext_INTERFACE_DEFINED__
#define __IWbemContext_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IWbemContext
 * at Mon Jan 12 00:22:07 1998
 * using MIDL 3.01.75
 ****************************************/
/* [uuid][local][restricted][object] */ 



EXTERN_C const IID IID_IWbemContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("44aca674-e8fc-11d0-a07c-00c04fb68820")
    IWbemContext : public IUnknown
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IWbemContext __RPC_FAR *__RPC_FAR *pNewCopy) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetNames( 
            /* [in] */ long lFlags,
            /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pNames) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE BeginEnumeration( 
            /* [in] */ long lFlags) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ long lFlags,
            /* [out] */ BSTR __RPC_FAR *pName,
            /* [out] */ VARIANT __RPC_FAR *pValue) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE EndEnumeration( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetValue( 
            /* [in] */ BSTR Name,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT __RPC_FAR *pValue) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetValue( 
            /* [in] */ BSTR Name,
            /* [in] */ long lFlags,
            /* [out] */ VARIANT __RPC_FAR *pValue) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE DeleteValue( 
            /* [in] */ BSTR Name,
            /* [in] */ long lFlags) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE DeleteAll( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWbemContext __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWbemContext __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWbemContext __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IWbemContext __RPC_FAR * This,
            /* [out] */ IWbemContext __RPC_FAR *__RPC_FAR *pNewCopy);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNames )( 
            IWbemContext __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pNames);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginEnumeration )( 
            IWbemContext __RPC_FAR * This,
            /* [in] */ long lFlags);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IWbemContext __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [out] */ BSTR __RPC_FAR *pName,
            /* [out] */ VARIANT __RPC_FAR *pValue);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndEnumeration )( 
            IWbemContext __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetValue )( 
            IWbemContext __RPC_FAR * This,
            /* [in] */ BSTR Name,
            /* [in] */ long lFlags,
            /* [in] */ VARIANT __RPC_FAR *pValue);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetValue )( 
            IWbemContext __RPC_FAR * This,
            /* [in] */ BSTR Name,
            /* [in] */ long lFlags,
            /* [out] */ VARIANT __RPC_FAR *pValue);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteValue )( 
            IWbemContext __RPC_FAR * This,
            /* [in] */ BSTR Name,
            /* [in] */ long lFlags);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteAll )( 
            IWbemContext __RPC_FAR * This);
        
        END_INTERFACE
    } IWbemContextVtbl;

    interface IWbemContext
    {
        CONST_VTBL struct IWbemContextVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemContext_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemContext_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemContext_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemContext_Clone(This,pNewCopy)	\
    (This)->lpVtbl -> Clone(This,pNewCopy)

#define IWbemContext_GetNames(This,lFlags,pNames)	\
    (This)->lpVtbl -> GetNames(This,lFlags,pNames)

#define IWbemContext_BeginEnumeration(This,lFlags)	\
    (This)->lpVtbl -> BeginEnumeration(This,lFlags)

#define IWbemContext_Next(This,lFlags,pName,pValue)	\
    (This)->lpVtbl -> Next(This,lFlags,pName,pValue)

#define IWbemContext_EndEnumeration(This)	\
    (This)->lpVtbl -> EndEnumeration(This)

#define IWbemContext_SetValue(This,Name,lFlags,pValue)	\
    (This)->lpVtbl -> SetValue(This,Name,lFlags,pValue)

#define IWbemContext_GetValue(This,Name,lFlags,pValue)	\
    (This)->lpVtbl -> GetValue(This,Name,lFlags,pValue)

#define IWbemContext_DeleteValue(This,Name,lFlags)	\
    (This)->lpVtbl -> DeleteValue(This,Name,lFlags)

#define IWbemContext_DeleteAll(This)	\
    (This)->lpVtbl -> DeleteAll(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IWbemContext_Clone_Proxy( 
    IWbemContext __RPC_FAR * This,
    /* [out] */ IWbemContext __RPC_FAR *__RPC_FAR *pNewCopy);


void __RPC_STUB IWbemContext_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemContext_GetNames_Proxy( 
    IWbemContext __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pNames);


void __RPC_STUB IWbemContext_GetNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemContext_BeginEnumeration_Proxy( 
    IWbemContext __RPC_FAR * This,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemContext_BeginEnumeration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemContext_Next_Proxy( 
    IWbemContext __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [out] */ BSTR __RPC_FAR *pName,
    /* [out] */ VARIANT __RPC_FAR *pValue);


void __RPC_STUB IWbemContext_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemContext_EndEnumeration_Proxy( 
    IWbemContext __RPC_FAR * This);


void __RPC_STUB IWbemContext_EndEnumeration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemContext_SetValue_Proxy( 
    IWbemContext __RPC_FAR * This,
    /* [in] */ BSTR Name,
    /* [in] */ long lFlags,
    /* [in] */ VARIANT __RPC_FAR *pValue);


void __RPC_STUB IWbemContext_SetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemContext_GetValue_Proxy( 
    IWbemContext __RPC_FAR * This,
    /* [in] */ BSTR Name,
    /* [in] */ long lFlags,
    /* [out] */ VARIANT __RPC_FAR *pValue);


void __RPC_STUB IWbemContext_GetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemContext_DeleteValue_Proxy( 
    IWbemContext __RPC_FAR * This,
    /* [in] */ BSTR Name,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemContext_DeleteValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IWbemContext_DeleteAll_Proxy( 
    IWbemContext __RPC_FAR * This);


void __RPC_STUB IWbemContext_DeleteAll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemContext_INTERFACE_DEFINED__ */


#ifndef __IWbemRefresher_INTERFACE_DEFINED__
#define __IWbemRefresher_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IWbemRefresher
 * at Mon Jan 12 00:22:07 1998
 * using MIDL 3.01.75
 ****************************************/
/* [uuid][object][restricted][local] */ 



EXTERN_C const IID IID_IWbemRefresher;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("49353c99-516b-11d1-aea6-00c04fb68820")
    IWbemRefresher : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Refresh( 
            /* [in] */ long lFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemRefresherVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWbemRefresher __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWbemRefresher __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWbemRefresher __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Refresh )( 
            IWbemRefresher __RPC_FAR * This,
            /* [in] */ long lFlags);
        
        END_INTERFACE
    } IWbemRefresherVtbl;

    interface IWbemRefresher
    {
        CONST_VTBL struct IWbemRefresherVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemRefresher_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemRefresher_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemRefresher_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemRefresher_Refresh(This,lFlags)	\
    (This)->lpVtbl -> Refresh(This,lFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemRefresher_Refresh_Proxy( 
    IWbemRefresher __RPC_FAR * This,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemRefresher_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemRefresher_INTERFACE_DEFINED__ */


#ifndef __IWbemConfigureRefresher_INTERFACE_DEFINED__
#define __IWbemConfigureRefresher_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IWbemConfigureRefresher
 * at Mon Jan 12 00:22:07 1998
 * using MIDL 3.01.75
 ****************************************/
/* [uuid][object][restricted][local] */ 



EXTERN_C const IID IID_IWbemConfigureRefresher;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("49353c92-516b-11d1-aea6-00c04fb68820")
    IWbemConfigureRefresher : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddObjectByPath( 
            /* [in] */ IWbemServices __RPC_FAR *pNamespace,
            /* [string][in] */ LPCWSTR wszPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pContext,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppRefreshable,
            /* [unique][in][out] */ long __RPC_FAR *plId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddObjectByTemplate( 
            /* [in] */ IWbemServices __RPC_FAR *pNamespace,
            /* [in] */ IWbemClassObject __RPC_FAR *pTemplate,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pContext,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppRefreshable,
            /* [unique][in][out] */ long __RPC_FAR *plId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddRefresher( 
            /* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ long __RPC_FAR *plId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ long lId,
            /* [in] */ long lFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWbemConfigureRefresherVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWbemConfigureRefresher __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWbemConfigureRefresher __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWbemConfigureRefresher __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddObjectByPath )( 
            IWbemConfigureRefresher __RPC_FAR * This,
            /* [in] */ IWbemServices __RPC_FAR *pNamespace,
            /* [string][in] */ LPCWSTR wszPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pContext,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppRefreshable,
            /* [unique][in][out] */ long __RPC_FAR *plId);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddObjectByTemplate )( 
            IWbemConfigureRefresher __RPC_FAR * This,
            /* [in] */ IWbemServices __RPC_FAR *pNamespace,
            /* [in] */ IWbemClassObject __RPC_FAR *pTemplate,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pContext,
            /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppRefreshable,
            /* [unique][in][out] */ long __RPC_FAR *plId);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddRefresher )( 
            IWbemConfigureRefresher __RPC_FAR * This,
            /* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
            /* [in] */ long lFlags,
            /* [unique][in][out] */ long __RPC_FAR *plId);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Remove )( 
            IWbemConfigureRefresher __RPC_FAR * This,
            /* [in] */ long lId,
            /* [in] */ long lFlags);
        
        END_INTERFACE
    } IWbemConfigureRefresherVtbl;

    interface IWbemConfigureRefresher
    {
        CONST_VTBL struct IWbemConfigureRefresherVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWbemConfigureRefresher_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWbemConfigureRefresher_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWbemConfigureRefresher_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWbemConfigureRefresher_AddObjectByPath(This,pNamespace,wszPath,lFlags,pContext,ppRefreshable,plId)	\
    (This)->lpVtbl -> AddObjectByPath(This,pNamespace,wszPath,lFlags,pContext,ppRefreshable,plId)

#define IWbemConfigureRefresher_AddObjectByTemplate(This,pNamespace,pTemplate,lFlags,pContext,ppRefreshable,plId)	\
    (This)->lpVtbl -> AddObjectByTemplate(This,pNamespace,pTemplate,lFlags,pContext,ppRefreshable,plId)

#define IWbemConfigureRefresher_AddRefresher(This,pRefresher,lFlags,plId)	\
    (This)->lpVtbl -> AddRefresher(This,pRefresher,lFlags,plId)

#define IWbemConfigureRefresher_Remove(This,lId,lFlags)	\
    (This)->lpVtbl -> Remove(This,lId,lFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWbemConfigureRefresher_AddObjectByPath_Proxy( 
    IWbemConfigureRefresher __RPC_FAR * This,
    /* [in] */ IWbemServices __RPC_FAR *pNamespace,
    /* [string][in] */ LPCWSTR wszPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pContext,
    /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppRefreshable,
    /* [unique][in][out] */ long __RPC_FAR *plId);


void __RPC_STUB IWbemConfigureRefresher_AddObjectByPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemConfigureRefresher_AddObjectByTemplate_Proxy( 
    IWbemConfigureRefresher __RPC_FAR * This,
    /* [in] */ IWbemServices __RPC_FAR *pNamespace,
    /* [in] */ IWbemClassObject __RPC_FAR *pTemplate,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pContext,
    /* [out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppRefreshable,
    /* [unique][in][out] */ long __RPC_FAR *plId);


void __RPC_STUB IWbemConfigureRefresher_AddObjectByTemplate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemConfigureRefresher_AddRefresher_Proxy( 
    IWbemConfigureRefresher __RPC_FAR * This,
    /* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
    /* [in] */ long lFlags,
    /* [unique][in][out] */ long __RPC_FAR *plId);


void __RPC_STUB IWbemConfigureRefresher_AddRefresher_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IWbemConfigureRefresher_Remove_Proxy( 
    IWbemConfigureRefresher __RPC_FAR * This,
    /* [in] */ long lId,
    /* [in] */ long lFlags);


void __RPC_STUB IWbemConfigureRefresher_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWbemConfigureRefresher_INTERFACE_DEFINED__ */


#ifndef __IUnsecuredApartment_INTERFACE_DEFINED__
#define __IUnsecuredApartment_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IUnsecuredApartment
 * at Mon Jan 12 00:22:07 1998
 * using MIDL 3.01.75
 ****************************************/
/* [object][uuid][restricted] */ 



EXTERN_C const IID IID_IUnsecuredApartment;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("1cfaba8c-1523-11d1-ad79-00c04fd8fdff")
    IUnsecuredApartment : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateObjectStub( 
            /* [in] */ IUnknown __RPC_FAR *pObject,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppStub) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUnsecuredApartmentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IUnsecuredApartment __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IUnsecuredApartment __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IUnsecuredApartment __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateObjectStub )( 
            IUnsecuredApartment __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pObject,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppStub);
        
        END_INTERFACE
    } IUnsecuredApartmentVtbl;

    interface IUnsecuredApartment
    {
        CONST_VTBL struct IUnsecuredApartmentVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUnsecuredApartment_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUnsecuredApartment_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUnsecuredApartment_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUnsecuredApartment_CreateObjectStub(This,pObject,ppStub)	\
    (This)->lpVtbl -> CreateObjectStub(This,pObject,ppStub)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUnsecuredApartment_CreateObjectStub_Proxy( 
    IUnsecuredApartment __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pObject,
    /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppStub);


void __RPC_STUB IUnsecuredApartment_CreateObjectStub_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUnsecuredApartment_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_WbemLocator;

class DECLSPEC_UUID("4590f811-1d3a-11d0-891f-00aa004b2e24")
WbemLocator;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_WbemContext;

class DECLSPEC_UUID("674B6698-EE92-11d0-AD71-00C04FD8FDFF")
WbemContext;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_UnsecuredApartment;

class DECLSPEC_UUID("49bd2028-1523-11d1-ad79-00c04fd8fdff")
UnsecuredApartment;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_WbemRefresher;

class DECLSPEC_UUID("c71566f2-561e-11d1-ad87-00c04fd8fdff")
WbemRefresher;
#endif
#endif /* __WbemClient_v1_LIBRARY_DEFINED__ */

/****************************************
 * Generated header for interface: __MIDL_itf_wbemcli_0000
 * at Mon Jan 12 00:22:07 1998
 * using MIDL 3.01.75
 ****************************************/
/* [local] */ 





extern RPC_IF_HANDLE __MIDL_itf_wbemcli_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wbemcli_0000_v0_0_s_ifspec;

/****************************************
 * Generated header for interface: __MIDL_itf_wbemcli_0072
 * at Mon Jan 12 00:22:07 1998
 * using MIDL 3.01.75
 ****************************************/
/* [local] */ 






extern RPC_IF_HANDLE __MIDL_itf_wbemcli_0072_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wbemcli_0072_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\wbemsvc_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 3.01.75 */
/* at Tue Aug 19 16:16:10 1997
 */
/* Compiler settings for wbemsvc.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none

  Copyright (c) 1998-1999 Microsoft Corporation
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID LIBID_WbemServices_v1 = {0x027947f3,0xd731,0x11ce,{0xa3,0x57,0x00,0x00,0x00,0x00,0x00,0x01}};


const IID IID_IWbemClassObject = {0xdc12a681,0x737f,0x11cf,{0x88,0x4d,0x00,0xaa,0x00,0x4b,0x2e,0x24}};


const IID IID_IWbemQualifierSet = {0xdc12a680,0x737f,0x11cf,{0x88,0x4d,0x00,0xaa,0x00,0x4b,0x2e,0x24}};


const IID IID_IWbemServices = {0x9556dc99,0x828c,0x11cf,{0xa3,0x7e,0x00,0xaa,0x00,0x32,0x40,0xc7}};


const IID IID_IWbemLocator = {0xdc12a687,0x737f,0x11cf,{0x88,0x4d,0x00,0xaa,0x00,0x4b,0x2e,0x24}};


const IID IID_IWbemObjectSink = {0x7c857801,0x7381,0x11cf,{0x88,0x4d,0x00,0xaa,0x00,0x4b,0x2e,0x24}};


const IID IID_IEnumWbemClassObject = {0x027947e1,0xd731,0x11ce,{0xa3,0x57,0x00,0x00,0x00,0x00,0x00,0x01}};


const IID IID_IWbemConfigure = {0x9a368276,0x26cf,0x11d0,{0xad,0x3c,0x00,0xc0,0x4f,0xd8,0xfd,0xff}};


const IID IID_IWbemPropertyProvider = {0xCE61E841,0x65BC,0x11d0,{0xB6,0xBD,0x00,0xAA,0x00,0x32,0x40,0xC7}};


const IID IID_IWbemTransport = {0x553fe584,0x2156,0x11d0,{0xb6,0xae,0x00,0xaa,0x00,0x32,0x40,0xc7}};


const IID IID_IWbemSecurityHelp = {0x32e0ef00,0xc578,0x11d0,{0xb6,0xca,0x00,0xaa,0x00,0x32,0x40,0xc7}};


const IID IID_IWbemLevel1Login = {0xF309AD18,0xD86A,0x11d0,{0xA0,0x75,0x00,0xC0,0x4F,0xB6,0x88,0x20}};


const IID IID_IWbemCallResult = {0x44aca675,0xe8fc,0x11d0,{0xa0,0x7c,0x00,0xc0,0x4f,0xb6,0x88,0x20}};


const IID IID_IWbemContext = {0x44aca674,0xe8fc,0x11d0,{0xa0,0x7c,0x00,0xc0,0x4f,0xb6,0x88,0x20}};


const IID IID_IWbemUnboundObjectSink = {0xe246107b,0xb06e,0x11d0,{0xad,0x61,0x00,0xc0,0x4f,0xd8,0xfd,0xff}};


const CLSID CLSID_WbemLevel1Login = {0x8BC3F05E,0xD86B,0x11d0,{0xA0,0x75,0x00,0xC0,0x4F,0xB6,0x88,0x20}};


const CLSID CLSID_WbemLevel1LoginHelp = {0x8BC3F05F,0xD86B,0x11d0,{0xA0,0x75,0x00,0xC0,0x4F,0xB6,0x88,0x20}};


const CLSID CLSID_WbemLocator = {0x4590f811,0x1d3a,0x11d0,{0x89,0x1f,0x00,0xaa,0x00,0x4b,0x2e,0x24}};


const CLSID CLSID_WbemSecurityHelp = {0xfa39d5a1,0xc584,0x11d0,{0x9e,0x48,0x00,0xc0,0x4f,0xc3,0x24,0xa8}};


const CLSID CLSID_PrivateWbemLevel1Login = {0x7d191c92,0xd92b,0x11d0,{0x9e,0x48,0x00,0xc0,0x4f,0xc3,0x24,0xa8}};


const CLSID CLSID_InProcWbemLevel1LoginHelp = {0x7d191c93,0xd92b,0x11d0,{0x9e,0x48,0x00,0xc0,0x4f,0xc3,0x24,0xa8}};


const CLSID CLSID_InProcWbemLevel1Login = {0x1214c791,0xdd2a,0x11d0,{0x9e,0x49,0x00,0xc0,0x4f,0xc3,0x24,0xa8}};


const CLSID CLSID_WbemContext = {0x674B6698,0xEE92,0x11d0,{0xAD,0x71,0x00,0xC0,0x4F,0xD8,0xFD,0xFF}};


const CLSID CLSID_WbemClassObjectProxy = {0x4590f812,0x1d3a,0x11d0,{0x89,0x1f,0x00,0xaa,0x00,0x4b,0x2e,0x24}};


const IID IID_IWbemLevel1LoginHelp = {0xF309AD19,0xD86A,0x11d0,{0xA0,0x75,0x00,0xC0,0x4F,0xB6,0x88,0x20}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\stubexe\msinfo32_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 5.01.0164 */
/* at Wed Feb 09 14:08:57 2000
 */
/* Compiler settings for E:\inet\sysinfo\control\msinfo32.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_IMSInfo = {0x2A930152,0xAE13,0x4659,{0xA0,0x11,0x36,0x37,0x7D,0x5F,0xC4,0x38}};


const IID LIBID_MSINFO32Lib = {0x7AC18319,0x0739,0x4377,{0x89,0x84,0x84,0x85,0x73,0xD5,0x19,0xA5}};


const CLSID CLSID_MSInfo = {0x273380E8,0x1438,0x4B2C,{0x95,0xB0,0x71,0x32,0x84,0xFB,0xC3,0x02}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\stubexe\stubexe.h ===
//	StubExe.h	- Define the class for 
//
// Copyright (c) 1998-1999 Microsoft Corporation

#include <afxwin.h>

extern const CLSID		CLSID_SystemInfo;
extern const IID		IID_ISystemInfo;

class CMSInfoApp : public CWinApp {
	BOOL	InitInstance();
	BOOL	RunMSInfoInHelpCtr();
};

CMSInfoApp theApp;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\stubexe\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by InfoStub.rc
//
// Copyright (c) 1998-2000 Microsoft Corporation

#define IDS_FILENOTFOUND                1
#define IDS_CANTACCESS                  2
#define IDS_UNKNOWN                     3
#define IDS_NOEXECUTABLE                4
#define IDS_DESCRIPTION                 5
#define IDS_MEMORY                      6
#define IDS_UNEXPECTED                  7
#define IDS_NOMSCFILE                   8
#define IDS_USAGE                       9
#define IDD_MSICMDLINE                  101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\stubmsd\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by InfoStub.rc
//
// Copyright (c) 1998-1999 Microsoft Corporation

#define IDS_FILENOTFOUND                1
#define IDS_CANTACCESS                  2
#define IDS_UNKNOWN                     3
#define IDS_NOEXECUTABLE                4
#define IDS_DESCRIPTION                 5
#define IDS_MEMORY                      6
#define IDS_UNEXPECTED                  7
#define IDS_NOMSCFILE                   8
#define IDS_NOMSINFO32					9
#define IDS_COMMONFILES_SUBPATH         10
#define IDS_MSINFO_PATH                 11
#define IDS_MSDNOTE			12

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\stubmsd\stubmsd.h ===
// Copyright (c) 1998-1999 Microsoft Corporation

#include <afxwin.h>

class CMSInfoApp : public CWinApp {
	BOOL	InitInstance();
};

CMSInfoApp theApp;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\stubexe\stubexe.cpp ===
//	stubexe.cpp		A command line program which runs the appropriate version
//		of MSInfo, based on the registry settings
//
// History:	a-jsari		10/13/97
//
// Copyright (c) 1998-1999 Microsoft Corporation

#include <afx.h>
#include <afxwin.h>
#include <io.h>
#include <process.h>
#include <errno.h>
#include "StdAfx.h"
#include "Resource.h"

#include "StubExe.h"

#include "MSInfo.h"
#include "MSInfo_i.c"

//-----------------------------------------------------------------------------
// These global variables hold arguments passed as command line parameters.
//-----------------------------------------------------------------------------

CString strComputerParam(_T(""));
CString strCategoryParam(_T(""));
CString strNFOFileParam(_T(""));
CString strReportFileParam(_T(""));

#ifndef HRESULT
typedef long HRESULT;
#endif

//	For Windows 95, the maximum length of a command line is 1024 characters.
//	Not sure what it is for NT.
const int MAX_COMMAND_LINE	= 1024;

LPCTSTR		cszDefaultDirectory = _T("\\Microsoft Shared\\MSInfo\\");

LPCTSTR		cszRegistryRoot = _T("Software\\Microsoft\\Shared Tools\\MSInfo");
LPCTSTR		cszDirectoryKey = _T("Path");

LPCTSTR		cszWindowsRoot = _T("Software\\Microsoft\\Windows\\CurrentVersion");
LPCTSTR		cszCommonFilesKey  = _T("CommonFilesDir");

CException *g_pException = NULL;

//		Microsoft Management Console is the program that hosts MSInfo.
//		This is a definition so that we can take its size.
#define		cszProgram	_T("mmc.exe")

/*
 * ThrowErrorException -
 *
 * History:	a-jsari		10/14/97		Initial version.
 */
inline void ThrowErrorException()
{
	::g_pException = new CException;
	if (::g_pException == NULL) ::AfxThrowMemoryException();
	throw ::g_pException;
}

/*
 * CMSInfo - A class to encapsulate using the DLL's COM interface.
 *
 * History:	a-jsari		3/26/98		Initial version
 */
class CMSInfo {
public:
	CMSInfo();
	~CMSInfo();

	HRESULT nfo(LPCTSTR lpszParams);
    HRESULT report(LPCTSTR lpszParams);
	HRESULT s(LPCTSTR lpszParams);
	HRESULT SaveNFO();
	HRESULT SaveReport();

private:
	ISystemInfo		*m_pISystemInfo;
	HRESULT			m_hr;
};

/* 
 * CSystemExecutable - The class that implements finding and running an
 *		executable.
 *
 * History:	a-jsari		10/14/97		Initial version.
 */
class CSystemExecutable {
public:
	CSystemExecutable(LPTSTR szProgram);
	~CSystemExecutable() { DeleteStrings(); }
	void	Run();
	void	Find();
	void	ProcessCommandLine();

	//	Helper methods.
protected:

	void	DeleteStrings();
	void	FindFileOnSystem(CString &szFileName, CString &szDestination);

	//	Instance variables.
protected:
	CString		*m_pszPath;
	CString		*m_pszProgramName;
	CString		*m_pszCommandLine;
};

/*
 * CMSInfoExecutable - MSInfo-specific functions.
 *
 * History: a-jsari		10/15/97		Initial version
 */
class CMSInfoExecutable : public CSystemExecutable {
public:
	CMSInfoExecutable(LPTSTR szProgram);
	~CMSInfoExecutable() {}

	void	ProcessCommandLine();

private:
	void	DisplayHelp();
	void	DeleteStrings();
	void	FindSavedConsole();
	LPCTSTR	GetMSIParameter(LPCTSTR szCommand, CString & strParam);

	//	Instance variables
private:
	static const LPCTSTR	cszSavedConsole;
	CString					*m_pszSavedConsole;
};

const LPCTSTR CMSInfoExecutable::cszSavedConsole = _T("MSInfo32.msc");

/*
 * CMSInfo - Initialize COM and create our ISystemInfo object.
 *
 * History:	a-jsari		3/26/98		Initial version.
 */
CMSInfo::CMSInfo()
:m_pISystemInfo(NULL)
{
	HRESULT hr = CoInitialize(NULL);
	if (FAILED(hr)) ::AfxThrowUserException();

	m_hr = CoCreateInstance(CLSID_SystemInfo, NULL, CLSCTX_ALL, IID_ISystemInfo, (void **)&m_pISystemInfo);
}

LPCTSTR cszSeparators = _T(" \t,");

//-----------------------------------------------------------------------------
// Call the msinfo32.dll using COM to save an NFO file. Use the parameters
// parsed from the command line (categories, computer).
//-----------------------------------------------------------------------------

HRESULT CMSInfo::SaveNFO()
{
	CString strFilename(strNFOFileParam);
	CString strComputer(strComputerParam);
	CString strCategory(strCategoryParam);

	BSTR filename = strFilename.AllocSysString();
	BSTR computer = strComputer.AllocSysString();
	BSTR category = strCategory.AllocSysString();

	if (m_pISystemInfo)
		return m_pISystemInfo->MakeNFO(filename, computer, category);

	return E_NOTIMPL;
}

//-----------------------------------------------------------------------------
// Call the msinfo32.dll using COM to save a report. Use the parameters
// parsed from the command line (categories, computer).
//-----------------------------------------------------------------------------

HRESULT CMSInfo::SaveReport()
{
	CString strFilename(strReportFileParam);
	CString strComputer(strComputerParam);
	CString strCategory(strCategoryParam);

	BSTR filename = strFilename.AllocSysString();
	BSTR computer = strComputer.AllocSysString();
	BSTR category = strCategory.AllocSysString();

	if (m_pISystemInfo)
		return m_pISystemInfo->MakeReport(filename, computer, category);

	return E_NOTIMPL;
}

/*
 * make_nfo - Process our parameters and call our ISystemInfo pointer's make_nfo function.
 *
 * History:	a-jsari		3/26/98		Initial version.
 */

HRESULT CMSInfo::nfo(LPCTSTR lpszParams)
{
	CString	strBuffer = lpszParams;
	CString	strFilename;
	LPCTSTR	szComputer = NULL;
	int		iSpace;

	strBuffer.TrimLeft();
	iSpace = strBuffer.FindOneOf(cszSeparators);
	do {
		if (iSpace == -1) {
			if (strBuffer.IsEmpty())
				return E_INVALIDARG;
			strFilename = strBuffer;
		} else {
			strFilename = strBuffer.Left(iSpace);
			strBuffer = strBuffer.Mid(iSpace + 1);
			strBuffer.TrimLeft();
			if (strBuffer[0] == (TCHAR)',')
				strBuffer = strBuffer.Mid(1);
			strBuffer.TrimLeft();
			iSpace = strBuffer.FindOneOf(cszSeparators);
			if (iSpace != -1) {
				strBuffer.Left(iSpace);
				break;
			}
			szComputer = (LPCTSTR)strBuffer;
		}
	} while (FALSE);
	if (m_pISystemInfo != NULL)
		return m_pISystemInfo->make_nfo(const_cast<LPTSTR>((LPCTSTR)strFilename),
				const_cast<LPTSTR>(szComputer));
	return m_hr;
}

/*
 * report - Process our parameters and call our ISystemInfo's make_report function.
 *
 * History:	a-jsari		3/26/98		Initial version.
 */
HRESULT CMSInfo::report(LPCTSTR lpszParams)
{
	CString	strBuffer = lpszParams;
	CString	strFilename;
	CString	strComputer;
	LPCTSTR szComputer = NULL;
	LPCTSTR szCategory = NULL;
	int		iSpace;

	strBuffer.TrimLeft();
	iSpace = strBuffer.FindOneOf(cszSeparators);
	do {
		if (iSpace == -1) {
			if (strBuffer.IsEmpty())
				return E_INVALIDARG;
			strFilename = strBuffer;
		} else {
			strFilename = strBuffer.Left(iSpace);
			strBuffer = strBuffer.Mid(iSpace + 1);
			strBuffer.TrimLeft();
			if (strBuffer[0] == (TCHAR)',')
				strBuffer = strBuffer.Mid(1);
			strBuffer.TrimLeft();
			iSpace = strBuffer.FindOneOf(cszSeparators);
			if (iSpace == -1) {
				strComputer = strBuffer;
				szComputer = (LPCTSTR)strComputer;
				break;
			}
			strComputer = strBuffer.Left(iSpace);
			szComputer = (LPCTSTR)strComputer;
			strBuffer = strBuffer.Mid(iSpace + 1);
			strBuffer.TrimLeft();
			if (strBuffer[0] == (TCHAR)',')
				strBuffer = strBuffer.Mid(1);
			strBuffer.TrimLeft();
			iSpace = strBuffer.FindOneOf(cszSeparators);
			if (iSpace != -1) {
				strBuffer = strBuffer.Left(iSpace);
			}
			szCategory = (LPCTSTR)strBuffer;
		}
	} while (FALSE);
	if (m_pISystemInfo != NULL)
		return m_pISystemInfo->make_report(const_cast<LPTSTR>((LPCTSTR)strFilename),
				const_cast<LPTSTR>(szComputer), const_cast<LPTSTR>(szCategory));
	return m_hr;
}

/*
 * s - Process our parameters and call our ISystemInfo's make_nfo function.
 *
 * History: a-jsari		3/26/98		Initial version.
 */
HRESULT CMSInfo::s(LPCTSTR lpszParams)
{
	CString	strBuffer = lpszParams;
	int		iSpace;

	strBuffer.TrimLeft();
	iSpace = strBuffer.FindOneOf(_T(" \t"));
	if (iSpace != -1)
		strBuffer = strBuffer.Left(iSpace);
	if (!strBuffer.IsEmpty())
		m_hr = E_INVALIDARG;
	else {
		if (m_pISystemInfo != NULL)
			m_hr = m_pISystemInfo->make_nfo(const_cast<LPTSTR>((LPCTSTR)strBuffer), NULL);
	}
	return m_hr;
}

/*
 * ~CMSInfo - Uninitialize COM and delete our ISystemInfo object.
 *
 * History:	a-jsari		3/26/98		Initial version.
 */
CMSInfo::~CMSInfo()
{
	if (SUCCEEDED(m_hr))
		m_pISystemInfo->Release();
	CoUninitialize();
}

/*
 * CExecutable - Constructor which determines the type of the executable to
 *		be executed.
 *
 * History:	a-jsari		10/14/97		Initial version.
 */
CSystemExecutable::CSystemExecutable(LPTSTR szProgram)
:m_pszProgramName(new CString), m_pszPath(new CString), m_pszCommandLine(new CString)
{
	if (!(m_pszProgramName && m_pszPath && m_pszCommandLine)) AfxThrowMemoryException();
	*m_pszProgramName = szProgram;
}

/*
 * DeleteStrings - Delete all of the strings used by the object.  Used to free
 *		our memory before calling exec.
 *
 * History: a-jsari		10/15/97		Initial version
 */
void CSystemExecutable::DeleteStrings()
{
	delete m_pszPath;
	m_pszPath = NULL;
	delete m_pszProgramName;
	m_pszProgramName = NULL;
	delete m_pszCommandLine;
	m_pszCommandLine = NULL;
}

/*
 * FindFileOnSystem - We may eventually put code here to test multiple
 *		found copies and use the right one.  But probably not.
 *
 * History:	a-jsari		10/15/97		Stub version
 */
void CSystemExecutable::FindFileOnSystem(CString &szFileName,
		CString &szDestination)
{
	//	Not reached.
	CFileFind		FileFinder;
	BOOL			bFindResult;

	bFindResult = FileFinder.FindFile(szFileName);
	if (!bFindResult) ThrowErrorException();
	szDestination = FileFinder.GetFilePath();
#if 0
	//	Choose among all versions of the file?
	while (bFindResult) {
		FileFinder.FindNextFile();
	}
#endif
}

/* 
 * Find - Return a pointer to a string containing the full path
 *		to the MMC executable.
 *
 * History:	a-jsari		10/13/97		Initial version
 */
void CSystemExecutable::Find()
{
	UINT		uReturnSize;
	TCHAR		szSystemDirectory[MAX_PATH + 1];

	uReturnSize = GetSystemDirectory(szSystemDirectory, MAX_PATH);
	if (uReturnSize == 0) ThrowErrorException();
	if (uReturnSize > MAX_PATH) {
		//	Our buffer isn't big enough.  This code will never get called.
		AfxThrowResourceException();
	}
	*m_pszPath += szSystemDirectory;
	*m_pszPath += _T("\\") + *m_pszProgramName;
	if (_taccess(*m_pszPath, A_READ) < 0) {
		//	These may eventually want to be distinct exceptions.
		if (errno == ENOENT) {
			ThrowErrorException();
		} else {
			ASSERT(errno == EACCES);
			ThrowErrorException();
		}
	}
}

/*
 * Run - Call exec with the parameters we so meticulously collected.
 *
 * History:	a-jsari		10/15/97		Initial version.
 */
void CSystemExecutable::Run()
{
#if !defined(UNICODE)
	TCHAR	szPath[MAX_PATH + 1];
	TCHAR	szProgramName[MAX_PATH + 1];
	TCHAR	szCommandLine[MAX_COMMAND_LINE + 1];

	_tcscpy(szPath, (LPCTSTR)*m_pszPath);
	_tcscpy(szProgramName, (LPCTSTR)*m_pszProgramName);
	_tcscpy(szCommandLine, (LPCTSTR)*m_pszCommandLine);
	DeleteStrings();
	::_execlp(szPath, szProgramName, szCommandLine, 0);
	ThrowErrorException();
#else
	char	szPath[MAX_PATH + 1];
	char	szProgramName[MAX_PATH + 1];
	char	szCommandLine[MAX_COMMAND_LINE + 1];

	wcstombs(szPath, (LPCTSTR) *m_pszPath, MAX_PATH);
	wcstombs(szProgramName, (LPCTSTR) *m_pszProgramName, MAX_PATH);
	wcstombs(szCommandLine, (LPCTSTR) *m_pszCommandLine, MAX_COMMAND_LINE);

	DeleteStrings();
	::_execlp(szPath, szProgramName, szCommandLine, 0);
	ThrowErrorException();
#endif
}

/*
 * ProcessCommandLine - Pass all command line parameters to the called
 *		executable.
 *
 * History: a-jsari		10/14/97		Initial version
 */
void CSystemExecutable::ProcessCommandLine()
{
	*m_pszCommandLine = GetCommandLine();

	//	Skip over the first element in the line, which is the path to
	//	the current executable.  Preserve everything else.
	const int	FIND_NO_MATCH = -1;
	int			wIndex;

	m_pszCommandLine->TrimLeft();
	wIndex = m_pszCommandLine->FindOneOf(_T("\" \t\n"));
	if ((*m_pszCommandLine)[wIndex] == '"') {
		//	This is the primary, if not guaranteed method.
		*m_pszCommandLine = m_pszCommandLine->Right(m_pszCommandLine->GetLength() - (wIndex + 1));
		wIndex = m_pszCommandLine->Find('"');
		*m_pszCommandLine = m_pszCommandLine->Right(m_pszCommandLine->GetLength() - (wIndex + 1));
	} else if (wIndex == FIND_NO_MATCH) {
		*m_pszCommandLine = _T("");
	} else {
		*m_pszCommandLine = m_pszCommandLine->Right(m_pszCommandLine->GetLength() - (wIndex + 1));
	}
}

/*
 * CMSInfoExecutable - Just pass all parameters to the base constructor.
 *
 * History: a-jsari		10/15/97		Initial version
 */
CMSInfoExecutable::CMSInfoExecutable(LPTSTR szProgram)
:CSystemExecutable(szProgram), m_pszSavedConsole(new CString)
{
	if (m_pszSavedConsole == NULL) AfxThrowMemoryException();
}

//-----------------------------------------------------------------------------
// This function is used to get a parameter from the command line. The first
// character may be one or more whitespace, or a ":" or a "=". After that, the
// string is read until a whitespace character is read outside of quotes.
//
// Return the pointer to the character location where we stopped reading.
//-----------------------------------------------------------------------------

LPCTSTR CMSInfoExecutable::GetMSIParameter(LPCTSTR szCommand, CString & strParam)
{
	strParam.Empty();
	if (!szCommand)
		return NULL;

	// Advance past any leading whitespace, ':' or '='.

	while (*szCommand && (*szCommand == _T(' ') || *szCommand == _T('\t') || *szCommand == _T(':') || *szCommand == _T('=')))
		szCommand++;

	if (*szCommand == _T('\0'))
		return szCommand;

	// Now read the parameter in until the end of the string or a non-quoted
	// whitespace is found. Remove the quote marks.

	BOOL fInQuote = FALSE;
	while (*szCommand)
	{
		if (!fInQuote && (*szCommand == _T(' ') || *szCommand == _T('\t')))
			break;

		if (*szCommand == _T('"'))
		{
			fInQuote = !fInQuote;
			szCommand++;
			continue;
		}

		strParam += *szCommand++;
	}

	return szCommand;
}

//-----------------------------------------------------------------------------
// This function reads the command line, looking for parameters we know how to
// handle. Anything we don't know about, we assemble into a new command line
// to pass to MMC when we launch MSInfo (if we launch it).
//-----------------------------------------------------------------------------

void CMSInfoExecutable::ProcessCommandLine()
{
	CSystemExecutable::ProcessCommandLine();
	FindSavedConsole();
	
	CString strNewCommandLine;
	int iLine = 0;

	// Process the items on the command line. If we recognize the flag,
	// save the value for use later. Otherwise add it to the command line
	// we'll pass to the snapin.

	while (m_pszCommandLine->GetLength() > 0) 
	{
		// Remove the part of the command line we just processed.

		*m_pszCommandLine = m_pszCommandLine->Mid(iLine);
		iLine = m_pszCommandLine->FindOneOf(_T(" \t")) + 1;

		if (iLine == 0)
			iLine = m_pszCommandLine->GetLength();

		// See if the first char is a command line switch.

		TCHAR tcFirst = (*m_pszCommandLine)[0];
		if (tcFirst == (TCHAR)'/' || tcFirst == (TCHAR)'-') 
		{
			LPCTSTR pString = *m_pszCommandLine;
			++pString;

			// This is a command line switch - see if we recognize it.

			if (::_tcsnicmp(pString, _T("?"), 1) == 0) 
			{
				DisplayHelp();
				exit(0);
			}
			else if (::_tcsnicmp(pString, _T("report"), 6) == 0)
			{
				LPCTSTR szEnd = GetMSIParameter(pString + 6, strReportFileParam);
				szEnd++;
				*m_pszCommandLine = szEnd;
				iLine = 0;
				continue;
			}
			else if (::_tcsnicmp(pString, _T("s"), 1) == 0) 
			{
				LPCTSTR szEnd = GetMSIParameter(pString + 1, strNFOFileParam);
				szEnd++;
				*m_pszCommandLine = szEnd;
				iLine = 0;
				continue;
			} 
			else if (::_tcsnicmp(pString, _T("nfo"), 3) == 0) 
			{
				LPCTSTR szEnd = GetMSIParameter(pString + 3, strNFOFileParam);
				szEnd++;
				*m_pszCommandLine = szEnd;
				iLine = 0;
				continue;
			}
			else if (::_tcsnicmp(pString, _T("computer"), 8) == 0)
			{
				LPCTSTR szEnd = GetMSIParameter(pString + 8, strComputerParam);
				szEnd++;
				*m_pszCommandLine = szEnd;
				iLine = 0;
				continue;
			}
			else if (::_tcsnicmp(pString, _T("categories"), 10) == 0)
			{
				LPCTSTR szEnd = GetMSIParameter(pString + 10, strCategoryParam);
				szEnd++;
				*m_pszCommandLine = szEnd;
				iLine = 0;
				continue;
			}
		}

		//	If we don't match one of our internal switches, pass it on.

		strNewCommandLine += m_pszCommandLine->Left(iLine);
	}

	// Now, check the parameters we parsed from the command line to decide what
	// to do. If we are to save an NFO or report, we should just exit after
	// doing so.

	if (!strNFOFileParam.IsEmpty() || !strReportFileParam.IsEmpty())
	{
		CMSInfo sysInfo;

		if (!strNFOFileParam.IsEmpty())
			sysInfo.SaveNFO();
		else if (!strReportFileParam.IsEmpty())
			sysInfo.SaveReport();
		exit(0);
	}

	// Construct the command line for MMC.

	*m_pszCommandLine = _T("/s \"") + *m_pszSavedConsole + _T("\" ") + strNewCommandLine;

	if (!strComputerParam.IsEmpty())
		*m_pszCommandLine += _T(" /computer \"") + strComputerParam + _T("\" ");

	if (!strCategoryParam.IsEmpty())
		*m_pszCommandLine += _T(" /msinfo_showcategories=\"") + strCategoryParam + _T("\" ");

	delete m_pszSavedConsole;
	m_pszSavedConsole = NULL;
}

/*
 * FindSavedConsole - Finds SysInfo.msc using the registry, or the
 *		default directory.
 *
 * History:	a-jsari		10/13/97		Initial version
 */
void CMSInfoExecutable::FindSavedConsole()
{
	HKEY		keyMSInfoRoot;
	long		lResult;
	DWORD		dwKeyLength = MAX_PATH;
	DWORD		dwType;
	TCHAR		szDirectory[MAX_PATH+1];


	*m_pszSavedConsole = _T("");
	do {
		//	Check the current directory.
		if (::_taccess(cszSavedConsole, A_READ) == 0) {
			*m_pszSavedConsole = cszSavedConsole;
			return;
		}

		//	Check the MSInfo Path key.
		lResult = ::RegOpenKeyEx(HKEY_LOCAL_MACHINE, cszRegistryRoot, 0, KEY_READ,
				&keyMSInfoRoot);
		if (lResult == ERROR_SUCCESS) {
			lResult = ::RegQueryValueEx(keyMSInfoRoot, cszDirectoryKey, 0, &dwType,
					reinterpret_cast<BYTE *>(szDirectory), &dwKeyLength);
			if (lResult == ERROR_SUCCESS) {
				LPTSTR pszPath = ::_tcsrchr(szDirectory, (TCHAR)'\\');
				if (pszPath) *pszPath = 0;
				*m_pszSavedConsole = szDirectory;
				*m_pszSavedConsole += _T("\\");
				*m_pszSavedConsole += cszSavedConsole;
				if (::_taccess(*m_pszSavedConsole, A_READ) == 0)
					return;
			}
		}

		//	Use the hard-coded path %ProgramFilesRoot%\Common Files\MSInfo
		lResult = ::RegOpenKeyEx(HKEY_LOCAL_MACHINE, cszWindowsRoot, 0, KEY_READ, &keyMSInfoRoot);
		ASSERT(lResult == ERROR_SUCCESS);
		if (lResult != ERROR_SUCCESS) break;
		dwKeyLength = sizeof( szDirectory);
		lResult = ::RegQueryValueEx(keyMSInfoRoot, cszCommonFilesKey, 0, &dwType,
				reinterpret_cast<BYTE *>(szDirectory), &dwKeyLength);
		ASSERT(lResult == ERROR_SUCCESS);
		if (lResult != ERROR_SUCCESS) break;

		*m_pszSavedConsole = szDirectory;
		*m_pszSavedConsole += cszDefaultDirectory;
		*m_pszSavedConsole += cszSavedConsole;

		if (::_taccess(*m_pszSavedConsole, A_READ) == 0)
			return;
		
	} while (0);
//	AFX_MANAGE_STATE(::AfxGetStaticModuleState());
	CString	szNoMSCFile;
	szNoMSCFile.LoadString(IDS_NOMSCFILE);
	::AfxMessageBox(szNoMSCFile);
	::ThrowErrorException();
}

/*
 * DisplayHelp - Print the command line help for the executable.
 *
 * History:	a-jsari		10/13/97		Initial version.
 *			a-adaml		03/15/99		Modified to display help in message box
 *			
 */

void CMSInfoExecutable::DisplayHelp()
{
	CString strMsg, strTitle;

	strTitle.LoadString(IDS_DESCRIPTION);
	strMsg.LoadString(IDS_USAGE);

	::MessageBox( NULL, strMsg, strTitle, MB_ICONINFORMATION | MB_OK);
}

/*
 * InitInstance - The main entry point for the stub executable, the subclass InitInstance
 *		function 
 *
 * History:	a-jsari		10/13/97		Initial version
 */
BOOL CMSInfoApp::InitInstance()
{
#if FALSE	// just run the helpctr version now
	CString		szResText;
	CString		szResTitle;

	do {
		try {
			//	FIX:	Pre-load the memory resource in case memory problems develop.

			CMSInfoExecutable		exeMSInfo(cszProgram);

			exeMSInfo.Find();
			exeMSInfo.ProcessCommandLine();
			exeMSInfo.Run();
			//	We never get past this on successful completion.
		}
		catch (CMemoryException e_Mem) {
			AFX_MANAGE_STATE(AfxGetStaticModuleState());
			VERIFY(szResText.LoadString(IDS_MEMORY));
			VERIFY(szResTitle.LoadString(IDS_DESCRIPTION));
			if (::MessageBox(NULL, szResText, szResTitle, MB_RETRYCANCEL | MB_ICONERROR) == IDCANCEL)
				break;
			continue;
		}
		catch (CException e_Generic) {
			AFX_MANAGE_STATE(AfxGetStaticModuleState());
			VERIFY(szResText.LoadString(IDS_UNEXPECTED));
			::MessageBox(NULL, szResText, szResTitle, MB_OK | MB_ICONERROR);
			delete ::g_pException;
			break;
		}
		catch (...) {
			ASSERT(FALSE);
			break;
		}
		break;
	} while (TRUE);
#endif

	if (!RunMSInfoInHelpCtr())
	{
		CDialog help(IDD_MSICMDLINE);
		help.DoModal();
	}

	return FALSE;
}

//-----------------------------------------------------------------------------
// Required to use the new MSInfo DLL in HelpCtr.
//-----------------------------------------------------------------------------

typedef class MSInfo MSInfo;

EXTERN_C const IID IID_IMSInfo;

struct IMSInfo : public IDispatch
{
public:
    virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_AutoSize( 
        /* [in] */ VARIANT_BOOL vbool) = 0;
    
    virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_AutoSize( 
        /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbool) = 0;
    
    virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_BackColor( 
        /* [in] */ OLE_COLOR clr) = 0;
    
    virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_BackColor( 
        /* [retval][out] */ OLE_COLOR __RPC_FAR *pclr) = 0;
    
    virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_BackStyle( 
        /* [in] */ long style) = 0;
    
    virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_BackStyle( 
        /* [retval][out] */ long __RPC_FAR *pstyle) = 0;
    
    virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_BorderColor( 
        /* [in] */ OLE_COLOR clr) = 0;
    
    virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_BorderColor( 
        /* [retval][out] */ OLE_COLOR __RPC_FAR *pclr) = 0;
    
    virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_BorderStyle( 
        /* [in] */ long style) = 0;
    
    virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_BorderStyle( 
        /* [retval][out] */ long __RPC_FAR *pstyle) = 0;
    
    virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_BorderWidth( 
        /* [in] */ long width) = 0;
    
    virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_BorderWidth( 
        /* [retval][out] */ long __RPC_FAR *width) = 0;
    
    virtual /* [id][propputref] */ HRESULT STDMETHODCALLTYPE putref_Font( 
        /* [in] */ IFontDisp __RPC_FAR *pFont) = 0;
    
    virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Font( 
        /* [in] */ IFontDisp __RPC_FAR *pFont) = 0;
    
    virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Font( 
        /* [retval][out] */ IFontDisp __RPC_FAR *__RPC_FAR *ppFont) = 0;
    
    virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_ForeColor( 
        /* [in] */ OLE_COLOR clr) = 0;
    
    virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ForeColor( 
        /* [retval][out] */ OLE_COLOR __RPC_FAR *pclr) = 0;
    
    virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Window( 
        /* [retval][out] */ long __RPC_FAR *phwnd) = 0;
    
    virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_BorderVisible( 
        /* [in] */ VARIANT_BOOL vbool) = 0;
    
    virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_BorderVisible( 
        /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbool) = 0;
    
    virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Appearance( 
        /* [in] */ short appearance) = 0;
    
    virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Appearance( 
        /* [retval][out] */ short __RPC_FAR *pappearance) = 0;
    
    virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetHistoryStream( 
        IStream __RPC_FAR *pStream) = 0;
    
    virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DCO_IUnknown( 
        /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *pVal) = 0;
    
    virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DCO_IUnknown( 
        /* [in] */ IUnknown __RPC_FAR *newVal) = 0;
    
    virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SaveFile( 
        BSTR filename,
        BSTR computer,
        BSTR category) = 0;
    
};

#include "msinfo32_i.c"

//-----------------------------------------------------------------------------
// This function encapsulates the functionality to run the new MSInfo in
// HelpCtr. If this function returns false, the help should be displayed.
//-----------------------------------------------------------------------------

void StringReplace(CString & str, LPCTSTR szLookFor, LPCTSTR szReplaceWith);
BOOL CMSInfoApp::RunMSInfoInHelpCtr()
{
	//-------------------------------------------------------------------------
	// Parse the command line parameters into one big string to pass to the
	// ActiveX control. There are a few which would keep us from launching
	// HelpCtr.
	//-------------------------------------------------------------------------

	CString		strCommandLine(CWinApp::m_lpCmdLine);

	CString		strLastFlag;
	CString		strCategory;
	CString		strCategories;
	CString		strComputer;
	CString		strOpenFile;
	CString		strPrintFile;
	CString		strSilentNFO;
	CString		strSilentExport;
	CString		strTemp;
	BOOL		fShowPCH = FALSE;
	BOOL		fShowHelp = FALSE;
	BOOL		fShowCategories = FALSE;

	while (!strCommandLine.IsEmpty())
	{
		// Remove the leading whitespace from the string.
		
		strTemp = strCommandLine.SpanIncluding(_T(" \t=:"));
		strCommandLine = strCommandLine.Right(strCommandLine.GetLength() - strTemp.GetLength());

		// If the first character is a / or a -, then this is a flag.

		if (strCommandLine[0] == _T('/') || strCommandLine[0] == _T('-'))
		{
			strCommandLine = strCommandLine.Right(strCommandLine.GetLength() - 1);
			strLastFlag = strCommandLine.SpanExcluding(_T(" \t=:"));
			strCommandLine = strCommandLine.Right(strCommandLine.GetLength() - strLastFlag.GetLength());
			strLastFlag.MakeLower();

			if (strLastFlag == CString(_T("pch")))
			{
				fShowPCH = TRUE;
				strLastFlag.Empty();
			}
			else if (strLastFlag == CString(_T("?")) || strLastFlag == CString(_T("h")))
			{
				fShowHelp = TRUE;
				strLastFlag.Empty();
			}
			else if (strLastFlag == CString(_T("showcategories")))
			{
				fShowCategories = TRUE;
				strLastFlag.Empty();
			}

			continue;
		}

		// Otherwise, this is either a filename to open, or a parameter from the
		// previous command line flag. This might have quotes around it.

		if (strCommandLine[0] != _T('"'))
		{
			strTemp = strCommandLine.SpanExcluding(_T(" \t"));
			strCommandLine = strCommandLine.Right(strCommandLine.GetLength() - strTemp.GetLength());
		}
		else
		{
			strCommandLine = strCommandLine.Right(strCommandLine.GetLength() - 1);
			strTemp = strCommandLine.SpanExcluding(_T("\""));
			strCommandLine = strCommandLine.Right(strCommandLine.GetLength() - strTemp.GetLength() - 1);
		}

		if (strLastFlag.IsEmpty() || strLastFlag == CString(_T("msinfo_file")))
			strOpenFile = strTemp;
		else if (strLastFlag == CString(_T("p")))
			strPrintFile = strTemp;
		else if (strLastFlag == CString(_T("category")))
			strCategory = strTemp;
		else if (strLastFlag == CString(_T("categories")))
			strCategories = strTemp;
		else if (strLastFlag == CString(_T("computer")))
			strComputer = strTemp;
		else if (strLastFlag == CString(_T("report")))
			strSilentExport = strTemp;
		else if (strLastFlag == CString(_T("nfo")) || strLastFlag == CString(_T("s")))
			strSilentNFO = strTemp;

		strLastFlag.Empty();
	}

	if (fShowHelp)
		return FALSE;

	TCHAR szCurrent[MAX_PATH];
	GetCurrentDirectory(MAX_PATH, szCurrent);
	CString strCurrent(szCurrent);
	if (strCurrent.Right(1) != CString(_T("\\")))
		strCurrent += CString(_T("\\"));

	HRESULT hrInitialize = CoInitialize(NULL);

	if (!strSilentNFO.IsEmpty() || !strSilentExport.IsEmpty())
	{
		IMSInfo * pMSInfo = NULL;

		if (SUCCEEDED(CoCreateInstance(CLSID_MSInfo, NULL, CLSCTX_ALL, IID_IMSInfo, (void **)&pMSInfo)) && pMSInfo != NULL)
		{
			BSTR computer = strComputer.AllocSysString();
			BSTR category = strCategories.AllocSysString();

			if (!strSilentNFO.IsEmpty())
			{
				if (strSilentNFO.Find(_T('\\')) == -1)
					strSilentNFO = strCurrent + strSilentNFO;

				if (strSilentNFO.Right(4).CompareNoCase(CString(_T(".nfo"))) != 0)
					strSilentNFO += CString(_T(".nfo"));

				BSTR filename = strSilentNFO.AllocSysString();
				pMSInfo->SaveFile(filename, computer, category);
				SysFreeString(filename);
			}

			if (!strSilentExport.IsEmpty())
			{
				if (strSilentExport.Find(_T('\\')) == -1)
					strSilentExport = strCurrent + strSilentExport;

				BSTR filename = strSilentExport.AllocSysString();
				pMSInfo->SaveFile(filename, computer, category);
				SysFreeString(filename);
			}

			SysFreeString(computer);
			SysFreeString(category);
			pMSInfo->Release();
		}

		if (SUCCEEDED(hrInitialize))
			CoUninitialize();

		return TRUE;
	}

	CString strURLParam;

	if (fShowPCH)
		strURLParam += _T("pch");

	if (fShowCategories)
		strURLParam += _T(",showcategories");

	if (!strComputer.IsEmpty())
		strURLParam += _T(",computer=") + strComputer;

	if (!strCategory.IsEmpty())
		strURLParam += _T(",category=") + strCategory;

	if (!strCategories.IsEmpty())
		strURLParam += _T(",categories=") + strCategories;

	if (!strPrintFile.IsEmpty())
	{
		if (strPrintFile.Find(_T('\\')) == -1)
			strPrintFile = strCurrent + strPrintFile;

		strURLParam += _T(",print=") + strPrintFile;
	}

	if (!strOpenFile.IsEmpty())
	{
		if (strOpenFile.Find(_T('\\')) == -1)
			strOpenFile = strCurrent + strOpenFile;
		
		strURLParam += _T(",open=") + strOpenFile;
	}

	if (!strURLParam.IsEmpty())
	{
		strURLParam.TrimLeft(_T(","));
		strURLParam = CString(_T("?")) + strURLParam;
	}

	CString strURLAddress(_T("hcp://system/sysinfo/msinfo.htm"));
	CString strURL = strURLAddress + strURLParam;

	//-------------------------------------------------------------------------
	// Check to see if we can run MSInfo in HelpCtr. We need the HTM file
	// to be present.
	//-------------------------------------------------------------------------

	BOOL fRunVersion6 = TRUE;

	TCHAR szPath[MAX_PATH];
	if (ExpandEnvironmentStrings(_T("%windir%\\pchealth\\helpctr\\system\\sysinfo\\msinfo.htm"), szPath, MAX_PATH))
	{
		WIN32_FIND_DATA finddata;
		HANDLE			h = FindFirstFile(szPath, &finddata);

		if (INVALID_HANDLE_VALUE != h)
			FindClose(h);
		else
			fRunVersion6 = FALSE;
	}

	// This would be used to check if the control is registered. Turns out we want to run anyway.
	//
	// IUnknown * pUnknown;
	// if (fRunVersion6 && SUCCEEDED(CoCreateInstance(CLSID_MSInfo, NULL, CLSCTX_ALL, IID_IUnknown, (void **) &pUnknown)))
	//		pUnknown->Release();
	// else
	//		fRunVersion6 = FALSE;

	StringReplace(strURL, _T(" "), _T("%20"));

	if (fRunVersion6)
	{
		// HelpCtr now supports running MSInfo in its own window. We need to
		// execute the following:
		//
		//		helpctr -mode hcp://system/sysinfo/msinfo.xml
		//
		// Additionally, we can pass parameters in the URL using the
		// following flag:
		//
		//		-url hcp://system/sysinfo/msinfo.htm?open=c:\savedfile.nfo
		//
		// First, find out of the XML file is present.

		BOOL fXMLPresent = TRUE;
		if (ExpandEnvironmentStrings(_T("%windir%\\pchealth\\helpctr\\system\\sysinfo\\msinfo.xml"), szPath, MAX_PATH))
		{
			WIN32_FIND_DATA finddata;
			HANDLE			h = FindFirstFile(szPath, &finddata);

			if (INVALID_HANDLE_VALUE != h)
				FindClose(h);
			else
				fXMLPresent = FALSE;
		}

		// If the XML file is present and we can get the path for helpctr.exe, we
		// should launch it the new way.

		TCHAR szHelpCtrPath[MAX_PATH];
		if (fXMLPresent && ExpandEnvironmentStrings(_T("%windir%\\pchealth\\helpctr\\binaries\\helpctr.exe"), szHelpCtrPath, MAX_PATH))
		{
			CString strParams(_T("-mode hcp://system/sysinfo/msinfo.xml"));
			if (!strURLParam.IsEmpty())
				strParams += CString(_T(" -url ")) + strURL;

			ShellExecute(NULL, NULL, szHelpCtrPath, strParams, NULL, SW_SHOWNORMAL);
		}
		else
			ShellExecute(NULL, NULL, strURL, NULL, NULL, SW_SHOWNORMAL);
	}
	else
		ShellExecute(NULL, NULL, _T("hcp://system"), NULL, NULL, SW_SHOWNORMAL);

	if (SUCCEEDED(hrInitialize))
		CoUninitialize();

	return TRUE;
}

//-----------------------------------------------------------------------------
// This was used originally to replace some MFC functionality not in the ME
// build tree.
//-----------------------------------------------------------------------------

void StringReplace(CString & str, LPCTSTR szLookFor, LPCTSTR szReplaceWith)
{
	CString strWorking(str);
	CString strReturn;
	CString strLookFor(szLookFor);
	CString strReplaceWith(szReplaceWith);

	int iLookFor = strLookFor.GetLength();
	int iNext;

	while (!strWorking.IsEmpty())
	{
		iNext = strWorking.Find(strLookFor);
		if (iNext == -1)
		{
			strReturn += strWorking;
			strWorking.Empty();
		}
		else
		{
			strReturn += strWorking.Left(iNext);
			strReturn += strReplaceWith;
			strWorking = strWorking.Right(strWorking.GetLength() - (iNext + iLookFor));
		}
	}

	str = strReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\sniffpol\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define _WIN32_WINNT 0x0400	//for WinNT 4.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "PPServer_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\sniffpol\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__23D1AE2C_8023_11D3_8D47_00C04F949D33__INCLUDED_)
#define AFX_DLLDATAX_H__23D1AE2C_8023_11D3_8D47_00C04F949D33__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__23D1AE2C_8023_11D3_8D47_00C04F949D33__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\sniffpol\ppserverclass.cpp ===
// PPServerClass.cpp : Implementation of CPPServerClass
#include "stdafx.h"
#include "PPServer.h"
#include "PPServerClass.h"

/////////////////////////////////////////////////////////////////////////////
// Keys
#define REG_LOCAL_TS_LOC		_T("SOFTWARE\\Microsoft")
#define REG_LOCAL_TS_PROGRAM	_T("TShoot")
// Values ///////////////////////////////////////////////////////////////////
#define SNIFF_AUTOMATIC_STR		_T("AutomaticSniffing")
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CPPServerClass

bool CPPServerClass::Create(HKEY hKeyParent, LPCTSTR strKeyName, bool* bCreatedNew, REGSAM access)
{
	HKEY hRetKey = NULL;
	DWORD dwDisposition = 0;

	long nWinError = ::RegCreateKeyEx(
		hKeyParent,
		strKeyName,
		0,
		NULL,
		REG_OPTION_NON_VOLATILE,
		access,
		NULL,
		&hRetKey,
		&dwDisposition
		);

	if(nWinError == ERROR_SUCCESS)
	{
		m_hKey = hRetKey;
		*bCreatedNew = dwDisposition == REG_CREATED_NEW_KEY ? true : false;
		
		try
		{
			m_arrKeysToClose.push_back(hRetKey);
		}
		catch (exception&)
		{
			return false;
		}

		return true;
	}
	return false;
}

bool CPPServerClass::SetNumericValue(LPCTSTR strValueName, DWORD dwValue)
{
	BYTE* pData = (BYTE*)&dwValue;
	long nWinError = ::RegSetValueEx(
		m_hKey,
		strValueName,
		0,
		REG_DWORD,
		pData,
		sizeof(DWORD)
		);

	if (nWinError == ERROR_SUCCESS)
		return true;
	return false;
}

bool CPPServerClass::GetNumericValue(LPCTSTR strValueName, DWORD& dwValue)
{
	DWORD tmp = 0;
	BYTE* pData = (BYTE*)&tmp;
	DWORD type = 0;
	DWORD size = sizeof(DWORD);

	long nWinError = ::RegQueryValueEx(
		m_hKey,
		strValueName,
		NULL,
		&type,
		pData,
		&size
		);

	if (type != REG_DWORD)
		return false;

	if (nWinError == ERROR_SUCCESS)
	{
		dwValue = tmp;
		return true;
	}
	return false;
}

void CPPServerClass::Close()
{
	for (vector<HKEY>::reverse_iterator i = m_arrKeysToClose.rbegin(); i != m_arrKeysToClose.rend(); i++)
		::RegCloseKey( *i );

	m_arrKeysToClose.clear();
}

STDMETHODIMP CPPServerClass::AllowAutomaticSniffing(VARIANT *pvarShow)
{

	bool was_created = false;
	DWORD dwAllowSniffing = 1;

	// [BC - 20010302] - Changed regsitry access level from WRITE to QUERY and READ. Write access
	// not allowed for certain user accts, such as WinXP built in guest acct. Write access should
	// not be required by this component.
	if (Create(HKEY_LOCAL_MACHINE, REG_LOCAL_TS_LOC, &was_created, KEY_QUERY_VALUE))
	{
		if (Create(m_hKey, REG_LOCAL_TS_PROGRAM, &was_created, KEY_READ))
		{
			// this call can be not successfull, if there is no such value.
			//  BUT we do not set this value,
			//  we leave dwAllowSniffing as initialized ("1")
			// This approach will comply the "Sniffing version 3.2.doc" statement,
			//  that if "AutomaticSniffing" value is missed, we treat it as set to "1"
			GetNumericValue(SNIFF_AUTOMATIC_STR, dwAllowSniffing);
		}
	}

	Close();

	::VariantInit(pvarShow);
	V_VT(pvarShow) = VT_I4;

	if (dwAllowSniffing == 1)
		pvarShow->lVal = 1;
	else
		pvarShow->lVal = 0;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\sniffpol\ppserver.cpp ===
// PPServer.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for PPServer.idl by adding the following 
//      files to the Outputs.
//          PPServer_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f PPServerps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "PPServer.h"
#include "dlldatax.h"

#include "PPServer_i.c"
#include "PPServerClass.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_PPServerClass, CPPServerClass)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_PPSERVERLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\sniffpol\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\stubmsd\stubmsd.cpp ===
// This file was originally stubexe.cpp (written by a-jsari), and was copied
// to create stubmsd.cpp to generate an identical stub program for winmsd.
//
// Copyright (c) 1998-1999 Microsoft Corporation

#include <afx.h>
#include <afxwin.h>
#include <io.h>
#include <process.h>
#include <errno.h>
#include <iostream.h>
#include "StdAfx.h"
#include "Resource.h"

#include "stubmsd.h"

#ifndef HRESULT
typedef long HRESULT;
#endif

//	For Windows 95, the maximum length of a command line is 1024 characters.
//	Not sure what it is for NT.
const int MAX_COMMAND_LINE	= 1024;

LPCTSTR		cszDefaultDirectory = _T("\\Microsoft Shared\\MSInfo\\");

LPCTSTR		cszRegistryRoot = _T("Software\\Microsoft\\Shared Tools\\MSInfo");
LPCTSTR		cszDirectoryKey = _T("Path");

LPCTSTR		cszWindowsRoot = _T("Software\\Microsoft\\Windows\\CurrentVersion");
LPCTSTR		cszCommonFilesKey = _T("CommonFilesDir");

CException *g_pException = NULL;

//		Microsoft Management Console is the program that hosts MSInfo.
//		This is a definition so that we can take its size.
#define		cszProgram	_T("mmc.exe")

/*
 * ThrowErrorException -
 *
 * History:	a-jsari		10/14/97		Initial version.
 */
inline void ThrowErrorException()
{
	::g_pException = new CException;
	if (::g_pException == NULL) ::AfxThrowMemoryException();
	throw ::g_pException;
}

/* 
 * CSystemExecutable - The class that implements finding and running an
 *		executable.
 *
 * History:	a-jsari		10/14/97		Initial version.
 */
class CSystemExecutable {
public:
	CSystemExecutable(LPTSTR szProgram);
	~CSystemExecutable() { DeleteStrings(); }
	void	Run();
	void	Find();
	void	ProcessCommandLine();

	//	Helper methods.
protected:

	void	DeleteStrings();
	void	FindFileOnSystem(CString &szFileName, CString &szDestination);

	//	Instance variables.
protected:
	CString		*m_pszPath;
	CString		*m_pszProgramName;
	CString		*m_pszCommandLine;
};

/*
 * CMSInfoExecutable - MSInfo-specific functions.
 *
 * History: a-jsari		10/15/97		Initial version
 */
class CMSInfoExecutable : public CSystemExecutable {
public:
	CMSInfoExecutable(LPTSTR szProgram);
	~CMSInfoExecutable() {}

	BOOL	ProcessCommandLine();

private:
	void	DisplayHelp();
	void	DeleteStrings();
	void	FindSavedConsole();
	void	FindMSInfoEXE();

	//	Instance variables
private:
	static const LPCTSTR	cszSavedConsole;
	static const LPCTSTR	cszMSInfo32;
	CString					*m_pszSavedConsole;
};

const LPCTSTR CMSInfoExecutable::cszSavedConsole = _T("MSInfo32.msc");
const LPCTSTR CMSInfoExecutable::cszMSInfo32	 = _T("msinfo32.exe");

/*
 * CExecutable - Constructor which determines the type of the executable to
 *		be executed.
 *
 * History:	a-jsari		10/14/97		Initial version.
 */
CSystemExecutable::CSystemExecutable(LPTSTR szProgram)
:m_pszProgramName(new CString), m_pszPath(new CString), m_pszCommandLine(new CString)
{
	if (!(m_pszProgramName && m_pszPath && m_pszCommandLine)) AfxThrowMemoryException();
	*m_pszProgramName = szProgram;
}

/*
 * DeleteStrings - Delete all of the strings used by the object.  Used to free
 *		our memory before calling exec.
 *
 * History: a-jsari		10/15/97		Initial version
 */
void CSystemExecutable::DeleteStrings()
{
	delete m_pszPath;
	m_pszPath = NULL;
	delete m_pszProgramName;
	m_pszProgramName = NULL;
	delete m_pszCommandLine;
	m_pszCommandLine = NULL;
}

/*
 * FindFileOnSystem - We may eventually put code here to test multiple
 *		found copies and use the right one.  But probably not.
 *
 * History:	a-jsari		10/15/97		Stub version
 */
void CSystemExecutable::FindFileOnSystem(CString &szFileName,
		CString &szDestination)
{
	//	Not reached.
	CFileFind		FileFinder;
	BOOL			bFindResult;

	bFindResult = FileFinder.FindFile(szFileName);
	if (!bFindResult) ThrowErrorException();
	szDestination = FileFinder.GetFilePath();
#if 0
	//	Choose among all versions of the file?
	while (bFindResult) {
		FileFinder.FindNextFile();
	}
#endif
}

/* 
 * Find - Return a pointer to a string containing the full path
 *		to the MMC executable.
 *
 * History:	a-jsari		10/13/97		Initial version
 */
void CSystemExecutable::Find()
{
// We no longer call mmc, we instead call msinfo32.exe so that
// winmsd appears to support all the same command line options
// whatever they may be.
#ifdef BUILD_MMC_COMMAND_LINE 

	UINT		uReturnSize;
	TCHAR		szSystemDirectory[MAX_PATH + 1];

	uReturnSize = GetSystemDirectory(szSystemDirectory, MAX_PATH);
	if (uReturnSize == 0) ThrowErrorException();
	if (uReturnSize > MAX_PATH) {
		//	Our buffer isn't big enough.  This code will never get called.
		AfxThrowResourceException();
	}
	*m_pszPath += szSystemDirectory;
	*m_pszPath += _T("\\") + *m_pszProgramName;
	if (_taccess(*m_pszPath, A_READ) < 0) {
		//	These may eventually want to be distinct exceptions.
		if (errno == ENOENT) {
			ThrowErrorException();
		} else {
			ASSERT(errno == EACCES);
			ThrowErrorException();
		}
	}

#endif

}

/*
 * Run - Call exec with the parameters we so meticulously collected.
 *
 * History:	a-jsari		10/15/97		Initial version.
 */
void CSystemExecutable::Run()
{
#if !defined(UNICODE)
	TCHAR	szPath[MAX_PATH + 1];
	TCHAR	szProgramName[MAX_PATH + 1];
	TCHAR	szCommandLine[MAX_COMMAND_LINE + 1];

	_tcscpy(szPath, (LPCTSTR)*m_pszPath);
	_tcscpy(szProgramName, (LPCTSTR)*m_pszProgramName);
	_tcscpy(szCommandLine, (LPCTSTR)*m_pszCommandLine);
	DeleteStrings();
	::_execlp(szPath, szProgramName, szCommandLine, 0);
	ThrowErrorException();
#else
	char	szPath[MAX_PATH + 1];
	char	szProgramName[MAX_PATH + 1];
	char	szCommandLine[MAX_COMMAND_LINE + 1];

	wcstombs(szPath, (LPCTSTR) *m_pszPath, MAX_PATH);
	wcstombs(szProgramName, (LPCTSTR) *m_pszProgramName, MAX_PATH);
	wcstombs(szCommandLine, (LPCTSTR) *m_pszCommandLine, MAX_COMMAND_LINE);

	DeleteStrings();
	::_execlp(szPath, szProgramName, szCommandLine, 0);
	ThrowErrorException();
#endif
}

/*
 * ProcessCommandLine - Pass all command line parameters to the called
 *		executable.
 *
 * History: a-jsari		10/14/97		Initial version
 */
void CSystemExecutable::ProcessCommandLine()
{
	*m_pszCommandLine = GetCommandLine();
	
	//	Skip over the first element in the line, which is the path to
	//	the current executable.  Preserve everything else.
	const int	FIND_NO_MATCH = -1;
	int			wIndex;

	m_pszCommandLine->TrimLeft();
	wIndex = m_pszCommandLine->FindOneOf(_T("\" \t\n"));
	if ((*m_pszCommandLine)[wIndex] == '"') {
		//	This is the primary, if not guaranteed method.
		*m_pszCommandLine = m_pszCommandLine->Right(m_pszCommandLine->GetLength() - (wIndex + 1));
		wIndex = m_pszCommandLine->Find('"');
		*m_pszCommandLine = m_pszCommandLine->Right(m_pszCommandLine->GetLength() - (wIndex + 1));
	} else if (wIndex == FIND_NO_MATCH) {
		*m_pszCommandLine = _T("");
	} else {
		*m_pszCommandLine = m_pszCommandLine->Right(m_pszCommandLine->GetLength() - (wIndex + 1));
	}
}

/*
 * CMSInfoExecutable - Just pass all parameters to the base constructor.
 *
 * History: a-jsari		10/15/97		Initial version
 */
CMSInfoExecutable::CMSInfoExecutable(LPTSTR szProgram)
:CSystemExecutable(szProgram), m_pszSavedConsole(new CString)
{
	if (m_pszSavedConsole == NULL) AfxThrowMemoryException();
}

/*
 * ProcessCommandLine - Process the command line parameters we can handle; pass on
 *		the ones we can't, adding the saved console file.
 *
 * History:	a-jsari		10/15/97		Initial version
 */
BOOL CMSInfoExecutable::ProcessCommandLine()
{
	// If the user specifies the "/?" switch on the winmsd.exe command line,
	// we need to inform the user that msinfo32.exe is the preferred way to
	// view the information now.

	CString strCommandLine = GetCommandLine();
	if (strCommandLine.Find(_T("/?")) != -1 && IDNO == ::AfxMessageBox(IDS_MSDNOTE, MB_YESNO))
		return FALSE;

	// builds m_pszCommandLine
	CSystemExecutable::ProcessCommandLine();

// We no longer call mmc, we instead call msinfo32.exe so that
// winmsd appears to support all the same command line options
// whatever they may be.
#ifdef BUILD_MMC_COMMAND_LINE 

	FindSavedConsole();
	CString szNewCommandLine;
	int		iLine = 0;
	while (m_pszCommandLine->GetLength() > 0) {
		*m_pszCommandLine = m_pszCommandLine->Mid(iLine);
		iLine = m_pszCommandLine->FindOneOf(_T(" \t")) + 1;
		if (iLine == 0)
			iLine = m_pszCommandLine->GetLength();

		TCHAR	tcFirst = *m_pszCommandLine[0];
		
		//	It's a command line switch.
		if (tcFirst == (TCHAR)'/' || tcFirst == (TCHAR)'-') {
			LPCTSTR pString = *m_pszCommandLine;
			++pString;
			if (::_tcsicmp(pString, _T("?")) == 0) {
				DisplayHelp();
				continue;
			} else if (::_tcsicmp(pString, _T("report")) == 0) {
				ASSERT(FALSE);
				continue;
			} else if (::_tcsicmp(pString, _T("s")) == 0) {
				ASSERT(FALSE);
				continue;
			} else if (::_tcsicmp(pString, _T("nfo")) == 0) {
				ASSERT(FALSE);
				continue;
			}
		}

		//	If we don't match one of our internal switches, pass it on.
		szNewCommandLine += m_pszCommandLine->Left(iLine);
	}
	*m_pszCommandLine = _T("/s \"") + *m_pszSavedConsole + _T("\" ") + szNewCommandLine;
	delete m_pszSavedConsole;
	m_pszSavedConsole = NULL;

#else 

	FindMSInfoEXE();

#endif 

	return TRUE;
}

//-----------------------------------------------------------------------------
// Locate the msinfo32.exe file. We'll look in the following places:
//
// 1.  In the current directory.
// 2.  In the directory in the registry under:
//	   HKLM\Software\Microsoft\Shared Tools\MSInfo\Path
// 3a. In the directory %CommonFilesDir%\Microsoft Shared\MSInfo, where 
//	   %CommonFilesDir% is found in 
//	   HKLM\Software\Microsoft\Windows\CurrentVersion\CommonFilesDir.
// 3b. Use the %CommonFilesDir% value with a subpath loaded from a
//     string resource.
// 4.  Last ditch is to look in a directory stored as a string resource
//	   for this file.
//-----------------------------------------------------------------------------

void CMSInfoExecutable::FindMSInfoEXE()
{
	m_pszPath->Empty();

	// First, check the current directory.

	if (::_taccess(_T("msinfo32.exe"), A_READ) == 0) 
	{
		*m_pszPath = _T("msinfo32.exe");
		return;
	}

	// Second, use the path key in the MSInfo registry key.

	HKEY hkey;
	if (ERROR_SUCCESS == ::RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T("Software\\Microsoft\\Shared Tools\\MSInfo"), 0, KEY_READ, &hkey))
	{
		DWORD dwType;
		TCHAR szDirectory[MAX_PATH + 1];
		DWORD dwKeyLength = MAX_PATH * sizeof(TCHAR);

		if (ERROR_SUCCESS == ::RegQueryValueEx(hkey, _T("path"), 0, &dwType, (BYTE *) szDirectory, &dwKeyLength))
			if (::_taccess(szDirectory, A_READ) == 0)
			{
				*m_pszPath = szDirectory;
				RegCloseKey(hkey);
				return;
			}

		RegCloseKey(hkey);
	}

	// Third, look for it in the %CommonFilesDir% directory. Look both in the hardcoded
	// subdirectory, and in a subdirectory loaded from a string resource.

	if (ERROR_SUCCESS == ::RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T("Software\\Microsoft\\Windows\\CurrentVersion"), 0, KEY_READ, &hkey))
	{
		DWORD dwKeyLength = MAX_PATH;
		DWORD dwType;
		TCHAR szDirectory[MAX_PATH + 1];

		if (ERROR_SUCCESS == ::RegQueryValueEx(hkey, _T("CommonFilesDir"), 0, &dwType, (BYTE *) szDirectory, &dwKeyLength))
		{
			CString strTestPath(szDirectory);
			strTestPath += _T("\\Microsoft Shared\\MSInfo\\msinfo32.exe");
			if (::_taccess(strTestPath, A_READ) == 0)
			{
				*m_pszPath = strTestPath;
				RegCloseKey(hkey);
				return;
			}

			if (strTestPath.LoadString(IDS_COMMONFILES_SUBPATH))
			{
				strTestPath = CString(szDirectory) + strTestPath;
				if (::_taccess(strTestPath, A_READ) == 0)
				{
					*m_pszPath = strTestPath;
					RegCloseKey(hkey);
					return;
				}
			}
		}

		RegCloseKey(hkey);
	}

	// Finally, look for it using the string resource.

	CString strTestPath;
	if (strTestPath.LoadString(IDS_MSINFO_PATH))
	{
		TCHAR szExpandedPath[MAX_PATH];
		if (::ExpandEnvironmentStrings(strTestPath, szExpandedPath, MAX_PATH))
			if (::_taccess(szExpandedPath, A_READ) == 0)
			{
				*m_pszPath = szExpandedPath;
				return;
			}
	}

	CString	szNoMSCFile;
	szNoMSCFile.LoadString(IDS_NOMSCFILE);
	::AfxMessageBox(szNoMSCFile);
	::ThrowErrorException();
}

/*
 * FindSavedConsole - Finds SysInfo.msc using the registry, or the
 *		default directory.
 *
 * History:	a-jsari		10/13/97		Initial version
 */
void CMSInfoExecutable::FindSavedConsole()
{
	HKEY		keyMSInfoRoot;
	long		lResult;
	DWORD		dwKeyLength = MAX_PATH;
	DWORD		dwType;
	TCHAR		szDirectory[MAX_PATH + 1];

	*m_pszSavedConsole = _T("");
	do {
		//	Check the current directory.
		if (::_taccess(cszSavedConsole, A_READ) == 0) {
			*m_pszSavedConsole = cszSavedConsole;
			return;
		}

		//	Check the MSInfo Path key.
		lResult = ::RegOpenKeyEx(HKEY_LOCAL_MACHINE, cszRegistryRoot, 0, KEY_READ,
				&keyMSInfoRoot);
		if (lResult == ERROR_SUCCESS) {
			lResult = ::RegQueryValueEx(keyMSInfoRoot, cszDirectoryKey, 0, &dwType,
					reinterpret_cast<BYTE *>(szDirectory), &dwKeyLength);
			if (lResult == ERROR_SUCCESS) {
				LPTSTR pszPath = ::_tcsrchr(szDirectory, (TCHAR)'\\');
				if (pszPath) *pszPath = 0;
				*m_pszSavedConsole = szDirectory;
				*m_pszSavedConsole += _T("\\");
				*m_pszSavedConsole += cszSavedConsole;
				if (::_taccess(*m_pszSavedConsole, A_READ) == 0)
					return;
			}
		}

		//	Use the hard-coded path %CommonFilesDir%\MSInfo
		lResult = ::RegOpenKeyEx(HKEY_LOCAL_MACHINE, cszWindowsRoot, 0, KEY_READ, &keyMSInfoRoot);
		ASSERT(lResult == ERROR_SUCCESS);
		if (lResult != ERROR_SUCCESS) break;
		dwKeyLength = sizeof( szDirectory);
		lResult = ::RegQueryValueEx(keyMSInfoRoot, cszCommonFilesKey, 0, &dwType,
				reinterpret_cast<BYTE *>(szDirectory), &dwKeyLength);
		ASSERT(lResult == ERROR_SUCCESS);
		if (lResult != ERROR_SUCCESS) break;
		*m_pszSavedConsole = szDirectory;
		*m_pszSavedConsole += cszDefaultDirectory;
		*m_pszSavedConsole += cszSavedConsole;
		if (::_taccess(*m_pszSavedConsole, A_READ) == 0)
			return;
	} while (0);
//	AFX_MANAGE_STATE(::AfxGetStaticModuleState());
	CString	szNoMSCFile;
	szNoMSCFile.LoadString(IDS_NOMSCFILE);
	::AfxMessageBox(szNoMSCFile);
	::ThrowErrorException();
}

void CMSInfoExecutable::DisplayHelp()
{
	cerr << _T("/? - display this help") << endl;
	cerr << _T("/report <filename, computername, categoryname, ...>") << endl;
	cerr << _T("/s <filename> - outputs the nfo file to the specified file") << endl;
	cerr << _T("/nfo <filesname>, <computername> - connect to the specified computer and create the named file") << endl;
}

/*
 * main - The main entry point for the stub executable.
 *
 * History:	a-jsari		10/13/97		Initial version
 */
BOOL CMSInfoApp::InitInstance()
{
	CString		szResText;
	CString		szResTitle;

//	Shouldn't need this.

	do {
		try {
			//	FIX:	Pre-load the memory resource in case memory problems develop.

			CMSInfoExecutable		exeMSInfo(cszProgram);

			exeMSInfo.Find();
			if (exeMSInfo.ProcessCommandLine())
				exeMSInfo.Run();
			//	We never get past this on successful completion.
		}
		catch (CMemoryException e_Mem) {
			AFX_MANAGE_STATE(AfxGetStaticModuleState());
			VERIFY(szResText.LoadString(IDS_MEMORY));
			VERIFY(szResTitle.LoadString(IDS_DESCRIPTION));
			if (::MessageBox(NULL, szResText, szResTitle, MB_RETRYCANCEL | MB_ICONERROR) == IDCANCEL)
				break;
			continue;
		}
		catch (CException e_Generic) {
			AFX_MANAGE_STATE(AfxGetStaticModuleState());
			VERIFY(szResText.LoadString(IDS_UNEXPECTED));
			::MessageBox(NULL, szResText, szResTitle, MB_OK | MB_ICONERROR);
			delete ::g_pException;
			break;
		}
		catch (...) {
			ASSERT(FALSE);
			break;
		}
		break;
	} while (TRUE);
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\sniffpol\ppserverclass.h ===
// PPServerClass.h : Declaration of the CPPServerClass

#ifndef __PPSERVERCLASS_H_
#define __PPSERVERCLASS_H_

#include "resource.h"       // main symbols

#include <atlctl.h>

#include <vector>
using namespace std;


/////////////////////////////////////////////////////////////////////////////
// CPPServerClass
class ATL_NO_VTABLE CPPServerClass : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CPPServerClass, &CLSID_PPServerClass>,
	public IDispatchImpl<IPPServerClass, &IID_IPPServerClass, &LIBID_PPSERVERLib>,
	public IObjectSafetyImpl<CPPServerClass, INTERFACESAFE_FOR_UNTRUSTED_CALLER>
{
public:
	CPPServerClass()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_PPSERVERCLASS)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CPPServerClass)
	COM_INTERFACE_ENTRY(IPPServerClass)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IObjectSafety)
END_COM_MAP()

// IPPServerClass
public:
	STDMETHOD(AllowAutomaticSniffing)(/*[out, retval]*/ VARIANT * pvarShow);

protected:
	
	bool Create(HKEY hKeyParent, LPCTSTR strKeyName, bool* bCreatedNew, REGSAM access =KEY_ALL_ACCESS);
	bool SetNumericValue(LPCTSTR strValueName, DWORD dwValue);
	bool GetNumericValue(LPCTSTR strValueName, DWORD& dwValue);
	void Close();
	
private:
	// Data
	HKEY m_hKey;				   // current key handle
	vector<HKEY> m_arrKeysToClose; // array of keys(subkeys) opened by the object
};

#endif //__PPSERVERCLASS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\sniffpol\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by PPServer.rc
//
#define IDS_PROJNAME                    100
#define IDR_PPSERVERCLASS               101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\sstub\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\sniffpol\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__23D1AE24_8023_11D3_8D47_00C04F949D33__INCLUDED_)
#define AFX_STDAFX_H__23D1AE24_8023_11D3_8D47_00C04F949D33__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__23D1AE24_8023_11D3_8D47_00C04F949D33__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\sstub\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define _WIN32_WINNT 0x0400	//for WinNT 4.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "SStub_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\sstub\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SStub.rc
//
#define IDS_PROJNAME                    100
#define IDR_SNIFFSTUB                   101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\sstub\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__26D19E4C_819E_11D3_8D49_00C04F949D33__INCLUDED_)
#define AFX_DLLDATAX_H__26D19E4C_819E_11D3_8D49_00C04F949D33__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__26D19E4C_819E_11D3_8D49_00C04F949D33__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\sstub\sniffstub.cpp ===
// SniffStub.cpp : Implementation of CSniffStub
#include "stdafx.h"
#include "SStub.h"
#include "SniffStub.h"

/////////////////////////////////////////////////////////////////////////////
// CSniffStub


STDMETHODIMP CSniffStub::Sniff(BSTR strNodeName, BSTR strLaunchBasis, BSTR strAdditionalArgs, VARIANT *nState)
{
	::VariantInit(nState);

	V_VT(nState) = VT_I4;
	nState->lVal = -1;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\sstub\sniffstub.h ===
// SniffStub.h : Declaration of the CSniffStub

#ifndef __SNIFFSTUB_H_
#define __SNIFFSTUB_H_

#include "resource.h"       // main symbols

#include <atlctl.h>

/////////////////////////////////////////////////////////////////////////////
// CSniffStub
class ATL_NO_VTABLE CSniffStub : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CSniffStub, &CLSID_SniffStub>,
	public IDispatchImpl<ISniffStub, &IID_ISniffStub, &LIBID_SSTUBLib>,
	public IObjectSafetyImpl<CSniffStub, INTERFACESAFE_FOR_UNTRUSTED_CALLER>
{
public:
	CSniffStub()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_SNIFFSTUB)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSniffStub)
	COM_INTERFACE_ENTRY(ISniffStub)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IObjectSafety)
END_COM_MAP()

// ISniffStub
public:
	STDMETHOD(Sniff)(/*[in]*/ BSTR strNodeName, /*[in]*/ BSTR strLaunchBasis, /*[in]*/ BSTR strAdditionalArgs, /*[out, retval]*/ VARIANT* nState);
};

#endif //__SNIFFSTUB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\sstub\sstub.cpp ===
// SStub.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for SStub.idl by adding the following 
//      files to the Outputs.
//          SStub_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f SStubps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "SStub.h"
#include "dlldatax.h"

#include "SStub_i.c"
#include "SniffStub.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_SniffStub, CSniffStub)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_SSTUBLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\sstub\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__26D19E44_819E_11D3_8D49_00C04F949D33__INCLUDED_)
#define AFX_STDAFX_H__26D19E44_819E_11D3_8D49_00C04F949D33__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__26D19E44_819E_11D3_8D49_00C04F949D33__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\apgtsassert.h ===
#ifndef __APGTSASSERT_H_
#define __APGTSASSERT_H_

#ifdef _DEBUG
#define ASSERT(f) \
	do \
	{ \
	if (!(f)) \
		DebugBreak(); \
	} while (0) 
#else
#define ASSERT(f)
#endif //_DEBUG

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\apgts.h ===
//
// MODULE: APGTS.H
//
// PURPOSE: Main header file for DLL
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Roman Mach
// 
// ORIGINAL DATE: 8-2-96
//
// NOTES: 
// 1. Based on Print Troubleshooter DLL
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V3.0		7-24-98		JM		Major revision, use STL.
//

#ifndef __APGTS_H_
#define __APGTS_H_ 1

#include <windows.h>

extern HANDLE ghModule;


///////////////////////////////////////////////////////////////////////////////
// Simple macros used to eliminate unnecessarily conditionally compiled code hopefully
// in a readable fashion.
#ifdef LOCAL_TROUBLESHOOTER
#define RUNNING_LOCAL_TS()	true
#define RUNNING_ONLINE_TS()	false
#else
#define RUNNING_LOCAL_TS()	false
#define RUNNING_ONLINE_TS()	true
#endif
///////////////////////////////////////////////////////////////////////////////

// Standard symbolic names for standard (implicit) nodes 
#define NODE_PROBLEM_ASK	_T("ProblemAsk")	// When we're posted a request, the second
										// field is ProblemAsk=<problem node symbolic name>
										// changed from "TShootProblem" 10/31/97 JM
#define NODE_LIBRARY_ASK	_T("asklibrary")	// When we're started from the Launcher,
										// name field is "asklibrary", and value is empty string
#define NODE_SERVICE		_T("Service")
#define NODE_FAIL			_T("Fail")
#define NODE_BYE			_T("Bye")
#define NODE_IMPOSSIBLE		_T("Impossible")
#define NODE_FAILALLCAUSESNORMAL _T("FailAllCausesNormal")

// Field names for HTTP request.  These are on the HTML <FORM>
#define C_TYPE			_T("type")			// pre version 3.0 normal request, now deprecated
											// First argument:
											//	type=<TS topic name>
											// Second argument:
											//	<IDH of Problem Page>=<IDH of Selected Problem>
											// or
											//	ProblemAsk=<IDH of Selected Problem>
											// Succeeding arguments may be:
											//	<number (IDH)>=<number (state)>
											// or
											//	<symbolic node name>=<number (state)>

#define C_FIRST			_T("first")			// Display "first" page (status page), which
											//	also provides access to all troubleshooting
											//	topics.
											// No further expected inputs here

#define C_FURTHER_GLOBAL	 _T("GlobalStatus")

#define C_THREAD_OVERVIEW	 _T("ThreadStatus")

#define C_TOPIC_STATUS	     _T("TopicStatus")

#define C_PRELOAD		_T("preload")		// pre version 3.0 integration with a sniffer,
											//	now deprecated
											// same inputs as C_TYPE
											// Only difference is that this means to 
											//  go looking to see if a cause is already
											//	established.

#define C_TOPIC			_T("topic")			// version 3.0 normal request
											// First argument:
											//	topic=<TS topic name>
											// Second argument:
											//	ProblemAsk=<NID or name of Selected Problem>
											// Succeeding arguments:
											//	<symbolic node name>=<number (state)>

#define C_TEMPLATE		_T("template")		// version 3.0 enhancement to permit the
											// the use of an arbitrary HTI file to be
											// used with an arbitrary DSC file.

#define C_PWD			_T("pwd")

#define C_TOPIC_AND_PROBLEM	_T("TopicAndProblem")	// version 3.x (not yet used in V3.0),
											// allows specification of topic & problem by 
											// a single radio button.  This enables an HTML
											// page seamlessly to put problems from multiple
											// topics in a single form.
											// First argument:
											//	TopicAndProblem=<TS topic name>,<NID or name of Selected Problem>
											//	The comma in the line above is a literal comma, e.g.
											//	TopicAndProblem=mem,OutOfMemory
											// Succeeding arguments:
											//	<symbolic node name>=<number (state)>

// Symbols from HTTP query
#define C_COOKIETAG		_T("CK_")		// V3.2 enhancement to support cookies passed in
										// via a GET or a POST.
#define C_SNIFFTAG		_T("SNIFFED_")	// V3.2 enhancement to allow indication of a
										// sniffed state for a particular node (independent
										// of its current state).
#define C_LAST_SNIFFED_MANUALLY	\
			_T("LAST_SNIFFED_MANUALLY")	// To identify that last node was sniffed manually
#define C_AMPERSAND		_T("&")			// Standard delimiter character.			
#define C_EQUALSIGN		_T("=")			// Standard delimiter character.


// These names serve "AllowAutomaticSniffing" checkbox.
//  Currently they are relevant for Local Troubleshooter only.
//  Oleg. 10.25.99
#define C_ALLOW_AUTOMATIC_SNIFFING_NAME			_T("boxAllowSniffing")
#define C_ALLOW_AUTOMATIC_SNIFFING_CHECKED		_T("checked")
#define C_ALLOW_AUTOMATIC_SNIFFING_UNCHECKED	_T("unchecked")


//------------- Config file manager object ---------------//

#define DLLNAME				_T("apgts.dll")
#define DLLNAME2			"apgts.dll"

#define CFG_HEADER			_T("[APGTS]")

#define REG_SOFTWARE_LOC	_T("SOFTWARE\\ISAPITroubleShoot")
#define REG_THIS_PROGRAM	_T("APGTS")

#define TS_REG_CLASS		_T("Generic_Troubleshooter_DLL")

#define REG_EVT_PATH		_T("SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application")
#define REG_EVT_MF			_T("EventMessageFile")
#define REG_EVT_TS			_T("TypesSupported")

// Default log file directory.
#define DEF_LOGFILEDIRECTORY		_T("d:\\http\\support\\tshoot\\log\\")

// maximum cache for belief networks
#define MAXCACHESIZE		200

// file extensions and suffixes
#define LOCALTS_EXTENSION_HTM   _T(".HTM") 
#define LOCALTS_SUFFIX_RESULT   _T("_result") 


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\apgtsbesread.h ===
//
// MODULE: APGTSBESREAD.H
//
// PURPOSE: BES file reading classes
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 7-29-98
//
// NOTES: 
//	Typical BES file content might be:
//		<FORM METHOD=POST ACTION="/scripts/samples/search/query.idq">
//		<INPUT TYPE=HIDDEN NAME="CiMaxRecordsPerPage" VALUE="10">
//		<INPUT TYPE=HIDDEN NAME="CiScope" VALUE="/">
//		<INPUT TYPE=HIDDEN NAME="TemplateName" VALUE="query">
//		<INPUT TYPE=HIDDEN NAME="HTMLQueryForm" VALUE="/samples/search/query.htm">
//		Enter items to search for 
//		<INPUT TYPE=TEXT NAME="CiRestriction" VALUE="print OR &quot;network print&quot;">
//		<INPUT TYPE=SUBMIT VALUE="Search">
//		</FORM>
//	See corresponding .cpp file for details of restrictions & for other notes.
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		08-04-98	OK
// V3.0		08-31-98	JM		support both returning a raw & an URL encoded form
//

#ifndef __APGTSBESREAD_H_
#define __APGTSBESREAD_H_

#include "fileread.h"


////////////////////////////////////////////////////////////////////////////////////
// CAPGTSBESReaderException
////////////////////////////////////////////////////////////////////////////////////
class CAPGTSBESReader;
class CAPGTSBESReaderException : public CFileReaderException
{
public: 
	enum eAPGTSBESErr {	eEV_GTS_ERROR_BES_MISS_TYPE_TAG, //  %1 %2 Backend search file does not have TYPE tag (make sure tag is all caps in file): TYPE= %3 %4
						eEV_GTS_ERROR_BES_MISS_CT_TAG,	//  %1 %2 Backend search file is missing close tag '>' for TYPE tag %3 %4
						eEV_GTS_ERROR_BES_MISS_CN_TAG,	//  %1 %2 Backend search file is missing close tag '>' for NAME tag %3 %4
						eEV_GTS_ERROR_BES_MISS_CV_TAG	//  %1 %2 Backend search file is missing close tag '>' for VALUE tag %3 %4
	} m_eAPGTSBESErr;

public:
	// source_file is LPCSTR rather than LPCTSTR because __FILE__ is char[35]
	CAPGTSBESReaderException(CFileReader* reader, eAPGTSBESErr err, LPCSTR source_file, int line);
};

////////////////////////////////////////////////////////////////////////////////////
// CBESPair
// represents name value pair for TYPE=TEXT field in a form
//	value (BESStr) will reflect what we're searching for.
////////////////////////////////////////////////////////////////////////////////////
struct CBESPair
{
// data
	CString Name;		// in the example in the notes at the head of this file,
						//	this would be "CiRestriction"

// code
	CString GetBESStr() const {return BESStr;}
	CBESPair& operator << (const vector<CString>& in);

protected:
	CString BESStr;		// value
};

////////////////////////////////////////////////////////////////////////////////////
// CAPGTSBESReader
// Read BES file
//  Includes interface to modify content of BES file into GET-POST method
////////////////////////////////////////////////////////////////////////////////////
class CAPGTSBESReader : public CTextFileReader
{
public:
	static LPCTSTR FORM;
	static LPCTSTR METHOD;
	static LPCTSTR ACTION;
	static LPCTSTR INPUT;
	static LPCTSTR TYPE;
	static LPCTSTR NAME;
	static LPCTSTR VALUE;
	static LPCTSTR HIDDEN;
	static LPCTSTR TEXT;

public:
	static void URLEncodeString(const CString& in, CString& out);
	static bool DecodeInputString(CFileReader* reader, const CString& str, CString& type, CString& name, CString& value);

protected:
	CString m_strURLEncodedForm;	// URL-encoded entire form (name-value pairs for a
									// GET-method query) including the string to search on.
	CBESPair m_SearchText;			// contains non-URL-encoded BES name - value pair
									// Initial BES content resides in CFileReader::m_StreamData,
									//	but is really of no interest.
	vector<CString> m_arrBESStr;    // contains array of encoded partial search strings
									//	for BES search.  In practice, these correspond to
									//	certain node/state pairs
	vector<CString> m_arrRawForm;	// contains array of unparsed strings exactly as they
									//	come from the BES file
	int m_iBES;						// index of element in m_arrRawForm before which
									// we place search string (to build a whole form).
	vector<CString> m_arrURLEncodedForm; // contains array of parsed and encoded strings
public:
	CAPGTSBESReader(CPhysicalFileReader * pPhysicalFileReader, LPCTSTR szDefaultContents = NULL);
   ~CAPGTSBESReader();

	void GenerateBES(
		const vector<CString> & arrstrIn,
		CString & strEncoded,
		CString & strRaw);

protected:
	CAPGTSBESReader& operator << (const CString& in); // add (AND) new clause into search expression.
	CAPGTSBESReader& operator >> (const CString& in); // roll back clause addition
	CAPGTSBESReader& ClearSearchString();

	void GetURLEncodedForm(CString&);
	void GetRawForm(CString&);

protected:
	virtual void Parse(); 

protected:
	virtual void BuildURLEncodedForm();
	virtual bool IsMethodString(const CString&) const;
	virtual bool IsBESString(const CString&) const;
	virtual bool IsTypeString(const CString&) const;
	virtual bool ParseMethodString(const CString& in, CString& out);
	virtual bool ParseBESString(const CString& in, CBESPair& out);
	virtual bool ParseTypeString(const CString& in, CString& out);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\apgtscac.cpp ===
//
// MODULE: APGTSCAC.CPP
//
// PURPOSE: Belief network caching support classes
//	Fully implements class CBNCacheItem
//	Fully implements class CBNCache
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel, modeled on earlier work by Roman Mach
// 
// ORIGINAL DATE: 10-2-96, completely rewritten 8/98
//
// NOTES: 
//	1. The strategy here builds a "Most-recently-used" cache (singly-linked list of 
//		CBNCacheItem ordered by how recently used)
//	2. Although you are first supposed to call FindCacheItem and only call AddCacheItem
//		if that fails, there is no support to do this in a threadsafe manner, so there
//		had better be only one thread with access to a given CCache.  Mutex protection
//		must come at a higher level.
//	3. One cache is associated with each [instance of a] Belief Network
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V3.0		8/7/98		JM		Original
//



#include "stdafx.h"
#include "event.h"
#include "apgtscac.h"
#include "baseexception.h"
#include "CharConv.h"
#include <algorithm>

// The CCacheItem comparison operators depend on the assumption that if the cache key 
//	is identical, the cache value will be, too.
bool CCacheItem::operator== (const CCacheItem &item) const
{
	return (BasisForInference == item.BasisForInference);
}

bool CCacheItem::operator!= (const CCacheItem &item) const
{
	return (BasisForInference != item.BasisForInference);
}

// Note that this is not lexicographical order.  We're saying any shorter
//	cache key compares as less than any longer.
bool CCacheItem::operator< (const CCacheItem &item) const
{
	const CBasisForInference::size_type thisSize = BasisForInference.size();
	const CBasisForInference::size_type otherSize = item.BasisForInference.size();

	if (thisSize < otherSize)
		return true;

	if (thisSize > otherSize)
		return false;

	// same length, use lexicographical order.
	return (BasisForInference < item.BasisForInference);
}

// Note that this is not lexicographical order.  We're saying any longer
//	cache key compares as greater than any shorter.
bool CCacheItem::operator> (const CCacheItem &item) const
{
	const CBasisForInference::size_type thisSize = BasisForInference.size();
	const CBasisForInference::size_type otherSize = item.BasisForInference.size();

	if (thisSize > otherSize)
		return true;

	if (thisSize < otherSize)
		return false;

	// same length, use lexicographical order.
	return (BasisForInference > item.BasisForInference);
}


// NOTE: Must call FindCacheItem first and not call this 
// function to prevent duplicate records from going into cache
bool CCache::AddCacheItem(
	const CBasisForInference &BasisForInference, 
	const CRecommendations &Recommendations)
{
	if (GetCount() >= MAXCACHESIZE)
		listItems.pop_back();

	try
	{
		CCacheItem item(BasisForInference, Recommendations);
		listItems.push_front(item);

		if (listItems.size() >= k_CacheSizeMax)
			listItems.pop_back();

		return true;	// always succeeds
	}
	catch (exception& x)
	{
		CString str;
		// Note STL exception in event log.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								CCharConversion::ConvertACharToString(x.what(), str), 
								_T(""), 
								EV_GTS_STL_EXCEPTION ); 

		return( false );
	}
}

bool CCache::FindCacheItem(
	const CBasisForInference &BasisForInference, 
	CRecommendations &Recommendations /* output */) const
{
	Recommendations.clear();
	CCacheItem item(BasisForInference, Recommendations /* effectively, a dummy */ );

	const list<CCacheItem>::const_iterator itBegin = listItems.begin();
	const list<CCacheItem>::const_iterator itEnd = listItems.end();
	const list<CCacheItem>::const_iterator itMatch = find(itBegin, itEnd, item);

	if (itMatch == itEnd)
		return false;

	Recommendations = itMatch->GetRecommendations();
	return true;
}

UINT CCache::GetCount() const
{
	return listItems.size();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\apgtscfg.cpp ===
//
// MODULE: APGTSCFG.CPP
//	Fully implements class CDBLoadConfiguration
//
// PURPOSE: 
//	Brings together the persistent pieces of the online troubleshooter configuration:
//		- the Topic Shop
//		- the registry
//		- the threads that maintain these.
//		- the template file for error reporting
//	Provides functions to get latest values on registry variables and to acquire a 
//	smart pointer to a CTopic based on its name.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Roman Mach
// 
// ORIGINAL DATE: 8-2-96
//
// NOTES: 
// 1. Based on Print Troubleshooter DLL
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V3.0		9/14/98		JM		Major revisions as classes for file management have 
//								all been rewritten
//


#pragma warning(disable:4786)
#include "stdafx.h"
#include "apgtscfg.h"

//
//
CDBLoadConfiguration::CDBLoadConfiguration(HMODULE hModule, 
										   CThreadPool * pThreadPool, 
										   const CString& strTopicName,
										   CHTMLLog *pLog)
:	m_TopicShop(),
	m_pThreadPool(pThreadPool),
	m_DirectoryMonitor(m_TopicShop ,strTopicName ),
	m_RegistryMonitor(m_DirectoryMonitor, pThreadPool, strTopicName, pLog )
{
}

//
//
CDBLoadConfiguration::~CDBLoadConfiguration()
{
}

CString CDBLoadConfiguration::GetFullResource()
{
	CString str;
	m_RegistryMonitor.GetStringInfo(CAPGTSRegConnector::eResourcePath, str);
	return str;
}

CString CDBLoadConfiguration::GetLogDir()
{
	CString str;
	m_RegistryMonitor.GetStringInfo(CAPGTSRegConnector::eLogFilePath, str);
	return str;
}

CString CDBLoadConfiguration::GetVrootPath()
{
	CString str;
	m_RegistryMonitor.GetStringInfo(CAPGTSRegConnector::eVrootPath, str);
	return str;
}

DWORD CDBLoadConfiguration::GetMaxThreads() 
{
	DWORD dw;
	m_RegistryMonitor.GetNumericInfo(CAPGTSRegConnector::eMaxThreads, dw);
	return dw;
}

// cookie life in minutes (before V3.0, was hours)
DWORD CDBLoadConfiguration::GetCookieLife() 
{
	DWORD dw;
	m_RegistryMonitor.GetNumericInfo(CAPGTSRegConnector::eCookieLife, dw);
	return dw;
}

DWORD CDBLoadConfiguration::GetReloadDelay() 
{
	DWORD dw;
	m_RegistryMonitor.GetNumericInfo(CAPGTSRegConnector::eReloadDelay, dw);
	return dw;
}

DWORD CDBLoadConfiguration::GetThreadsPP() 
{
	DWORD dw;
	m_RegistryMonitor.GetNumericInfo(CAPGTSRegConnector::eThreadsPP, dw);
	return dw;
}

DWORD CDBLoadConfiguration::GetMaxWQItems() 
{ 
	DWORD dw;
	m_RegistryMonitor.GetNumericInfo(CAPGTSRegConnector::eMaxWQItems, dw);
	return dw;
}

bool CDBLoadConfiguration::HasDetailedEventLogging() 
{
	DWORD dw;
	m_RegistryMonitor.GetNumericInfo(CAPGTSRegConnector::eDetailedEventLogging, dw);
	return dw ? true : false;
}

void CDBLoadConfiguration::GetListOfTopicNames(vector<CString>&arrstrTopic)
{
	m_TopicShop.GetListOfTopicNames(arrstrTopic);
}

// Call this function to obtain a CP_TOPIC as a pointer to the topic (identified by 
//	strTopic) that you want to operate on.  As long as the CP_TOPIC remains undeleted, 
//	the associated CTopic is guaranteed to remain undeleted.
// Warning: this function can wait a long time for the topic to be built.
CP_TOPIC & CDBLoadConfiguration::GetTopic(
	const CString & strTopic, CP_TOPIC & cpTopic, bool bNewCookie)
{
	return m_TopicShop.GetTopic(strTopic, cpTopic, bNewCookie);
}

// Call this function to obtain a CP_TEMPLATE as a pointer to the template (identified by 
//	strTopic) that you want to operate on.  As long as the CP_TEMPLATE remains undeleted, 
//	the associated CAPGTSHTIReader is guaranteed to remain undeleted.
// Warning: this function can wait a long time for the template to be built.
CP_TEMPLATE & CDBLoadConfiguration::GetTemplate(
	const CString & strTemplate, CP_TEMPLATE & cpTemplate, bool bNewCookie)
{
	return m_TopicShop.GetTemplate(strTemplate, cpTemplate, bNewCookie);
}

// Call this function to add a template to the topic shop catalog of templates and
// to add it to the directory monitor list of templates to track for changes.
void CDBLoadConfiguration::AddTemplate( const CString & strTemplateName )
{
	m_TopicShop.AddTemplate( strTemplateName );

	// Notify the directory monitor to track this file.
	m_DirectoryMonitor.AddTemplateToTrack( strTemplateName );
	return;
}

bool CDBLoadConfiguration::RetTemplateInCatalogStatus( const CString & strTemplate, bool & bValid )
{
	return( m_TopicShop.RetTemplateInCatalogStatus( strTemplate, bValid ) );
}

void CDBLoadConfiguration::CreateErrorPage(const CString & strError, CString& out)
{
	m_DirectoryMonitor.CreateErrorPage(strError, out); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\apgtsbesread.cpp ===
//
// MODULE: APGTSBESREAD.CPP
//
// PURPOSE: template file reading classes
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 8-12-98
//
// NOTES: 
// 1. URLEncodeString() and DecodeInputString() come with only minor changes from Roman's 
//	old approach to BES.
//	
// 2. Typical BES file content might be:
//		<FORM METHOD=POST ACTION="/scripts/samples/search/query.idq">
//		<INPUT TYPE=HIDDEN NAME="CiMaxRecordsPerPage" VALUE="10">
//		<INPUT TYPE=HIDDEN NAME="CiScope" VALUE="/">
//		<INPUT TYPE=HIDDEN NAME="TemplateName" VALUE="query">
//		<INPUT TYPE=HIDDEN NAME="HTMLQueryForm" VALUE="/samples/search/query.htm">
//		Enter items to search for 
//		<INPUT TYPE=TEXT NAME="CiRestriction" VALUE="print OR &quot;network print&quot;">
//		<INPUT TYPE=SUBMIT VALUE="Search">
//		</FORM>
//
//	There are some tight restrictions because of a rather naive parse:
//		FORM, ACTION, TYPE, NAME, VALUE must be capitalized
//		No white space allowed in any of 
//			<FORM
//			ACTION="
//			<INPUT
//			TYPE=
//			TYPE=TEXT
//			NAME=
//			VALUE=
//			">		(value for TYPE=TEXT)
//		At least one character (typically CR) is mandatory between each use of <INPUT ...>
//		Each <INPUT ...> must include attribute TYPE=
//		For each <INPUT ...> NAME=, VALUE= are optional, but if present attributes must be 
//			in order TYPE=, NAME=, VALUE=
//		There should be exactly one TYPE=TEXT input, and it should come after all the 
//		HIDDENs and before the SUBMIT.
//
// 3. Back End Search (BES) is used only for the service node or for the fail node.
//	The fail node is the unique, implicit node in a belief network which we reach when 
//	there are no more recommendations and no explicit skips.  The service node is the 
//	unique, implicit node which we reach when there are no more recommendations and at least
//	one explicit skip.
//	The service node and fail node are not explicitly implemented as nodes.  Instead, 
//	they are implicitly constructed from either support text or the content of the BES file.  
//	(The latter supersedes the former.)
//
// 4. We call BuildURLEncodedForm() more often than is absolutely necessary.  It really 
//	could be called only "on demand" in GetURLEncodedForm().  Since this is all in-memory 
//	stuff, it's  pretty cheap to make the extra calls, and it should make debugging easier.
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		08-04-98	OK
// V3.0		08-31-98	JM		support both returning a raw & an URL encoded form
//

#include "stdafx.h"
#include "apgtsbesread.h"
#include "CharConv.h"
#include <algorithm>
#include "event.h"

////////////////////////////////////////////////////////////////////////////////////
// CAPGTSBESReaderException
////////////////////////////////////////////////////////////////////////////////////
CAPGTSBESReaderException::CAPGTSBESReaderException(	
		CFileReader* reader, 
		eAPGTSBESErr err, 
		LPCSTR source_file, 
		int line)
: CFileReaderException(reader, eErrParse, source_file, line),
  m_eAPGTSBESErr(err)
{
}

////////////////////////////////////////////////////////////////////////////////////
// CBESPair
////////////////////////////////////////////////////////////////////////////////////
// concatenate strings to produce new BESStr.  Place " AND " between each 
//	pair of strings.
// If resulting string is to be URL-encoded, then, on input, content of strings in vector 
//	must each be URL-encoded.  In practice, we don't URL-encode this, we URL-encode the 
//	output of GetBESStr() instead.
CBESPair& CBESPair::operator << (const vector<CString>& in)
{
	BESStr = _T(""); // clear
	for (vector<CString>::const_iterator i = in.begin(); i < in.end(); i++)
	{
		vector<CString>::iterator current = (vector<CString>::iterator)i;

		BESStr += _T("(");
		BESStr += *i;
		BESStr += _T(")");
		if (++current != in.end())
			BESStr += _T(" AND ");
	}
	return *this;
}

////////////////////////////////////////////////////////////////////////////////////
// CAPGTSBESReader
////////////////////////////////////////////////////////////////////////////////////
/*static*/ LPCTSTR CAPGTSBESReader::FORM = _T("FORM");
/*static*/ LPCTSTR CAPGTSBESReader::METHOD = _T("METHOD"); 
/*static*/ LPCTSTR CAPGTSBESReader::ACTION = _T("ACTION");
/*static*/ LPCTSTR CAPGTSBESReader::INPUT = _T("INPUT");
/*static*/ LPCTSTR CAPGTSBESReader::TYPE = _T("TYPE");
/*static*/ LPCTSTR CAPGTSBESReader::NAME = _T("NAME");
/*static*/ LPCTSTR CAPGTSBESReader::VALUE = _T("VALUE");
/*static*/ LPCTSTR CAPGTSBESReader::HIDDEN = _T("HIDDEN");
/*static*/ LPCTSTR CAPGTSBESReader::TEXT = _T("TEXT");

CAPGTSBESReader::CAPGTSBESReader(CPhysicalFileReader * pPhysicalFileReader, LPCTSTR szDefaultContents /* = NULL */)
			   : CTextFileReader(pPhysicalFileReader, szDefaultContents)
{
}

CAPGTSBESReader::~CAPGTSBESReader()
{
}

void CAPGTSBESReader::GenerateBES(
		const vector<CString> & arrstrIn,
		CString & strEncoded,
		CString & strRaw)
{
	LOCKOBJECT();

	ClearSearchString();
	for (vector<CString>::const_iterator i = arrstrIn.begin(); i < arrstrIn.end(); i++)
		operator << (*i);

	GetURLEncodedForm(strEncoded);
	GetRawForm(strRaw);

	UNLOCKOBJECT();
}

// string "in" will be ANDed onto the list of strings to search.
CAPGTSBESReader& CAPGTSBESReader::operator << (const CString& in)
{
	LOCKOBJECT();

	try
	{
		m_arrBESStr.push_back( in );
		m_SearchText << m_arrBESStr;
		BuildURLEncodedForm();
	}
	catch (exception& x)
	{
		CString str;
		// Note STL exception in event log.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								CCharConversion::ConvertACharToString(x.what(), str), 
								_T(""), 
								EV_GTS_STL_EXCEPTION ); 
	}

	UNLOCKOBJECT();
	return *this;
}

// string "in" will be removed from the list of strings to search.
// This is provided for class completeness, not for any current need. (JM 8/98)
CAPGTSBESReader& CAPGTSBESReader::operator >> (const CString& in)
{
	LOCKOBJECT();
	
	vector<CString>::iterator i = find( m_arrBESStr.begin(), m_arrBESStr.end(), in );
	
	if (i != m_arrBESStr.end())
	{
		m_arrBESStr.erase(i);
		m_SearchText << m_arrBESStr;
		BuildURLEncodedForm();
	}
	UNLOCKOBJECT();
	return *this;
}

// Typically, you will want to call this to clear the search string before you start
//	appending new strings to it.
CAPGTSBESReader& CAPGTSBESReader::ClearSearchString()
{
	LOCKOBJECT();

	m_arrBESStr.clear();

	m_SearchText << m_arrBESStr;
	BuildURLEncodedForm();

	UNLOCKOBJECT();
	return *this;
}

void CAPGTSBESReader::GetURLEncodedForm(CString& out)
{
	LOCKOBJECT();
	out = m_strURLEncodedForm;
	UNLOCKOBJECT();
}

void CAPGTSBESReader::GetRawForm(CString& str)
{
	vector<CString>::iterator i = NULL;

	LOCKOBJECT();

	str.Empty();

	vector<CString>::iterator itBES = m_arrRawForm.begin() + m_iBES;

	for (i = m_arrRawForm.begin(); i < itBES; i++)
	{
		if ((i + 1) < itBES)
			str += *i;
		else
		{
			// Remove the default BES VALUE off the raw string.
			TCHAR *valuestr = _T("VALUE=\"");
			int	nFoundLoc;

			nFoundLoc= (*i).Find( valuestr );
			if (nFoundLoc == -1)
				str += *i;
			else
				str += (*i).Left( nFoundLoc + _tcslen( valuestr ) );
		}
	}

	str += m_SearchText.GetBESStr();

	for (i = itBES; i < m_arrRawForm.end(); i++)
		str += *i;

	UNLOCKOBJECT();
}

void CAPGTSBESReader::Parse()
{
	CString str, tmp, strSav;
	long save_pos = 0;

	LOCKOBJECT();
	save_pos = GetPos();
	SetPos(0);

	m_iBES = 0;
	vector<CString>::iterator itBES = NULL;

	try 
	{
		// pump file content into array of lines
		m_arrRawForm.clear();
		while (GetLine(str))
		{
			m_arrRawForm.push_back(str);
		}

		m_arrURLEncodedForm.clear();
		
		// parse string-by-string
		for (vector<CString>::iterator i = m_arrRawForm.begin(); i < m_arrRawForm.end(); i++)
		{
			if (IsMethodString(*i))
			{
				if (ParseMethodString(*i, tmp)) 
				{
					m_arrURLEncodedForm.push_back(tmp);
					continue;
				}
			}
			else if (IsBESString(*i))
			{
				if (ParseBESString(*i, m_SearchText)) // modifies m_SearchText.Name
				{   
					// do not include BES string into m_arrURLEncodedForm,
					//  include it in m_SearchText instead (although typically, we
					//	will throw it away unused).
					m_SearchText << m_arrBESStr;
					itBES = i+1;
					int loc = i->Find(_T("\">"));
					strSav = i->Mid(loc);
					*i = i->Left(loc);
					continue;
				}
			}
			else if (IsTypeString(*i))
			{
				if (ParseTypeString(*i, tmp)) 
				{
					m_arrURLEncodedForm.push_back(tmp);
					continue;
				}
			}
			// else can not be parsed, leave m_arrURLEncodedForm alone.
		}

		BuildURLEncodedForm();
	} 
	catch (CAPGTSBESReaderException&)	
	{
		// Log BES file parsing error and rethrow exception.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								_T(""), _T(""), EV_GTS_ERROR_BES_PARSE ); 
		throw;
	}
	catch (exception& x)
	{
		CString str;
		// Note STL exception in event log and rethrow exception.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								CCharConversion::ConvertACharToString(x.what(), str), 
								_T(""), 
								EV_GTS_STL_EXCEPTION ); 
		throw;
	}

	if (itBES)
	{
		m_iBES = itBES - m_arrRawForm.begin();
		try
		{
			m_arrRawForm.insert(itBES, strSav);
		}
		catch (exception& x)
		{
			CString str2;
			// Note STL exception in event log.
			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									CCharConversion::ConvertACharToString(x.what(), str2), 
									_T(""), 
									EV_GTS_STL_EXCEPTION ); 
		}
	}
	
	SetPos(save_pos);
	UNLOCKOBJECT();
}

void CAPGTSBESReader::BuildURLEncodedForm()
{
	CString strTemp;

	vector<CString>::const_iterator i = m_arrURLEncodedForm.begin();

	LOCKOBJECT();

	m_strURLEncodedForm = _T(*i); // URL of web app itself
	m_strURLEncodedForm += _T("?");
	i++;
	
	// form output string without BES string
	for (; i < m_arrURLEncodedForm.end(); i++)
	{
		m_strURLEncodedForm += *i;		// name/value pair
		m_strURLEncodedForm += _T("&");
	}

	// append BES string
	URLEncodeString(m_SearchText.Name, strTemp);
	m_strURLEncodedForm += strTemp;
	m_strURLEncodedForm += _T("=");
	URLEncodeString(m_SearchText.GetBESStr(), strTemp);
	m_strURLEncodedForm += strTemp;

	m_strURLEncodedForm += _T(" HTTP/1.0");

	UNLOCKOBJECT();
}

// Determine whether or not a string constitutes a "Method" string.  Method strings need
// to contain a FORM, METHOD, and ACTION string.  Here is an example Method string.
// <FORM METHOD=POST ACTION="/scripts/samples/search/query.idq">
bool CAPGTSBESReader::IsMethodString(const CString& str) const
{
	if (-1 == str.Find(FORM)   ||
		-1 == str.Find(METHOD) ||
		-1 == str.Find(ACTION))
	{
		// All required elements were not found.
	   return false;
	}

	return true;
}

// Determine whether or not a string constitutes a "Type" string.  Type strings need
// to contain a INPUT, TYPE, NAME, and VALUE string.  Here is an example Type string.
// <INPUT TYPE=HIDDEN NAME="TemplateName" VALUE="query">
bool CAPGTSBESReader::IsTypeString(const CString& str) const
{
	if (-1 == str.Find(INPUT) ||
		-1 == str.Find(TYPE)  ||
		-1 == str.Find(NAME)  ||
		-1 == str.Find(VALUE))
	{
		// All required elements were not found.
	   return false;
	}

	return true;
}

// Determine whether or not a string constitutes a "BES" string.  BES strings need
// to contain all of the elements of a "Type" string as well as a TEXT tag.
// The following is an example BES string.
// Enter items to search for <INPUT TYPE=TEXT NAME="CiRestriction" VALUE="print OR &quot;network print&quot;">
bool CAPGTSBESReader::IsBESString(const CString& str) const
{
	if (!IsTypeString(str) || -1 == str.Find(TEXT)) 
	{
		// All required elements were not found.
	   return false;
	}

	return true;
}

bool CAPGTSBESReader::ParseMethodString(const CString& in, CString& out)
{
	long index = -1;
	LPTSTR str = (LPTSTR)(LPCTSTR)in, start =NULL, end =NULL;

	if (-1 != (index = in.Find(ACTION)))
	{
		start = (LPTSTR)(LPCTSTR)in + index;
		while (*start && *start != _T('"'))
			start++;
		if (*start)
		{
			end = ++start;

			while (*end && *end != _T('"'))
				end++;
			if (*end)
			{
				try
				{
					TCHAR* path = new TCHAR[end - start + 1];

					_tcsncpy(path, start, end - start);
					path[end - start] = 0;
					out= path;
					delete [] path;

					return true;
				}
				catch (bad_alloc&)
				{
					CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
					CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
											SrcLoc.GetSrcFileLineStr(), 
											_T(""), _T(""), EV_GTS_CANT_ALLOC ); 
					return( false );
				}
			}
		}
	}

	return false;
}

bool CAPGTSBESReader::ParseTypeString(const CString& in, CString& out)
{
	CString type, name, value;
	CString name_encoded, value_encoded;
	
	if (DecodeInputString(this, in, type, name, value))
	{
		URLEncodeString(name, name_encoded);
		URLEncodeString(value, value_encoded);

		out = _T("");
		out += name_encoded;
		out += _T("=");
		out += value_encoded;

		return true;
	}
	return false;
}

bool CAPGTSBESReader::ParseBESString(const CString& in, CBESPair& out)
{
	CString type, name, value;
	CString name_encoded, value_encoded;
	
	if (DecodeInputString(this, in, type, name, value))
	{
		URLEncodeString(name, name_encoded);
		URLEncodeString(value, value_encoded);

		out.Name = name_encoded;
		
		// Note:	We do not care about the value_encoded string as it is no longer
		//			used as all of the search parameters come from nodes visited.  RAB-981028.

		return true;
	}
	return false;
}

// URL-encoding in the narrow sense.
//	INPUT in - normal text
//	OUTPUT out - equivalent URL-encoded string
/*static*/ void CAPGTSBESReader::URLEncodeString(const CString& in, CString& out)
{
	TCHAR tostr[2048]; 
	TCHAR *ptr = (LPTSTR)(LPCTSTR)in;

	TCHAR buf[5], *str;
	TCHAR EncodeByte;

	str = ptr;

	_tcscpy(tostr, _T(""));
	while (*str) {
		if (!_istalnum(*str) || *str < 0) {
			if (*str == _T(' '))
				_tcscat(tostr, _T("+"));
			else {
				if (!_istleadbyte(*str)) {
					EncodeByte = *str;
					_stprintf(buf, _T("%%%02X"), (unsigned char) EncodeByte);
					_tcscat(tostr, buf);
				}
				else {
					EncodeByte = *str;
					_stprintf(buf, _T("%%%02X"), (unsigned char) EncodeByte);
					_tcscat(tostr, buf);
					EncodeByte = *(str + 1);
					_stprintf(buf, _T("%%%02X"), (unsigned char) EncodeByte);
					_tcscat(tostr, buf);
				}
			}
		}
		else {
			_tcsncpy(buf, str, 2);
			if (_istleadbyte(*str))
				buf[2] = NULL;
			else
				buf[1] = NULL;
			_tcscat(tostr, buf);
		}
		str = _tcsinc(str);
	}
	
	out = tostr;
	return;
}

//	Parse a line from BES file
//		<INPUT TYPE=HIDDEN NAME="CiMaxRecordsPerPage" VALUE="10">
//	See note at head of this .cpp file for detailed requirements on these lines
//
//	If const_str is a null string, returns success with type, name, value all null strings
//	Otherwise, if successful, this function sets type, name, value to the content
//		of those respective attributes, if present (e.g "HIDDEN", "CiMaxRecordsPerPage", "10").
//	All of these physically point into the (altered) string originally passed in *str
//
//	Returns true on success.  All failures throw exceptions.
//	
/*static*/ bool CAPGTSBESReader::DecodeInputString(
	CFileReader* reader, 
	const CString& const_str, 
	CString& type, 
	CString& name, 
	CString& value
)
{
	CString temp_str = const_str;

	TCHAR*  str = (LPTSTR)(LPCTSTR)temp_str;
	TCHAR*	ptrtype = NULL;
	TCHAR*	ptrname = NULL;
	TCHAR*	ptrvalue = NULL;
	
	TCHAR *typestr = _T("TYPE=");
	TCHAR *namestr = _T("NAME=");
	TCHAR *valuestr = _T("VALUE=");
	TCHAR *ptr, *ptrstart;
	
	int typelen = _tcslen(typestr);
	int namelen = _tcslen(namestr);
	int valuelen = _tcslen(valuestr);

	ptr = str;
	ptrtype = str;
	ptrname = str;
	ptrvalue = str;

	if (*ptr == _T('\0')) 
		goto SUCCESS;

	*ptr = _T('\0');
	ptr = _tcsinc(ptr);

	// must have TYPE
	if ((ptrstart = _tcsstr(ptr, typestr))==NULL) 
		throw CAPGTSBESReaderException(
					reader,
		 			CAPGTSBESReaderException::eEV_GTS_ERROR_BES_MISS_TYPE_TAG,
					__FILE__, 
					__LINE__);

	ptrstart = _tcsninc(ptrstart, typelen);

	if (*ptrstart == _T('"'))
		// Deal with optional quotation marks
		ptrstart = _tcsinc(ptrstart);

	if ((ptr = _tcschr(ptrstart, _T(' ')))==NULL) 
		if ((ptr = _tcschr(ptrstart, _T('>')))==NULL) 
			throw CAPGTSBESReaderException(
					reader,
		 			CAPGTSBESReaderException::eEV_GTS_ERROR_BES_MISS_CT_TAG,
					__FILE__, 
					__LINE__);

	if (ptrstart != ptr)
		ptr = _tcsdec(ptrstart, ptr);

	if (*ptr != _T('"'))
		ptr = _tcsinc(ptr);

	*ptr = _T('\0');
	ptr = _tcsinc(ptr);

	ptrtype = ptrstart;

	// NAME must come next if present
	if ((ptrstart = _tcsstr(ptr, namestr))==NULL) 
		goto SUCCESS;

	ptrstart = _tcsninc(ptrstart, namelen);

	if (*ptrstart == _T('"'))
		ptrstart = _tcsinc(ptrstart);

	if ((ptr = _tcschr(ptrstart, _T('"')))==NULL) 
		if ((ptr = _tcschr(ptrstart, _T(' ')))==NULL) 
			if ((ptr = _tcschr(ptrstart, _T('>')))==NULL) 
				throw CAPGTSBESReaderException(
							reader,
		 					CAPGTSBESReaderException::eEV_GTS_ERROR_BES_MISS_CN_TAG,
							__FILE__, 
							__LINE__);

	if (ptrstart != ptr)
		ptr = _tcsdec(ptrstart, ptr);

	if (*ptr != _T('"'))
		ptr = _tcsinc(ptr);

	*ptr = _T('\0');
	ptr = _tcsinc(ptr);

	ptrname = ptrstart;

	// VALUE must come next if present
	if ((ptrstart = _tcsstr(ptr, valuestr))==NULL) 
		goto SUCCESS;

	ptrstart = _tcsninc(ptrstart, valuelen);

	if (*ptrstart == _T('"'))
		ptrstart = _tcsinc(ptrstart);

	if ((ptr = _tcschr(ptrstart, _T('"')))==NULL) 
		if ((ptr = _tcschr(ptrstart, _T(' ')))==NULL) 
			if ((ptr = _tcschr(ptrstart, _T('>')))==NULL) 
				throw CAPGTSBESReaderException(
							reader,
		 					CAPGTSBESReaderException::eEV_GTS_ERROR_BES_MISS_CV_TAG,
							__FILE__, 
							__LINE__);

	if (ptrstart != ptr)
		ptr = _tcsdec(ptrstart, ptr);

	if (*ptr != _T('"'))
		ptr = _tcsinc(ptr);

	*ptr = _T('\0');
	ptr = _tcsinc(ptr);

	ptrvalue = ptrstart;

SUCCESS:
	type = ptrtype;
	name = ptrname;
	value = ptrvalue;
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\apgtscfg.h ===
//
// MODULE: APGTSCFG.H
//	Fully implements class CDBLoadConfiguration
//
// PURPOSE: 
//	Brings together the persistent pieces ofthe online troubleshooter configuration:
//		- the Topic Shop
//		- the registry
//		- the pool threads
//		- the threads that maintain these.
//		- the CRecentUse object that tracks passwords
//	Provides functions to get latest values on registry variables and to acquire a 
//	smart pointer to a CTopic based on its name.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Roman Mach
// 
// ORIGINAL DATE: 8-2-96
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		9/21/98		JM		this file abstracted from apgtscls.h
//

#ifndef _H_APGTSCFG
#define _H_APGTSCFG

#include "pointer.h"
#include "RegistryMonitor.h"
#include "ThreadPool.h"
#include "RecentUse.h"

//
// Provides in-memory access to registry values & full content of the resource directory
// Basically, on initialization, this sucks EVERYTHING in.
class CDBLoadConfiguration
{
public:
	CDBLoadConfiguration(	HMODULE hModule, 
							CThreadPool * pThreadPool, 
							const CString& strTopicName, 
							CHTMLLog *pLog);
	~CDBLoadConfiguration();
	
	// registry functions
	CString GetFullResource();
	CString GetVrootPath();
	DWORD GetMaxWQItems();
	DWORD GetCookieLife();
	DWORD GetReloadDelay();
	CString GetLogDir();

	void GetListOfTopicNames(vector<CString>&arrstrTopic);
	CP_TOPIC & GetTopic(const CString & strTopic, CP_TOPIC & cpTopic, bool bNewCookie);
	CP_TEMPLATE & GetTemplate(const CString & strTemplate, CP_TEMPLATE & cpTemplate, bool bNewCookie);
	void AddTemplate( const CString & strTemplateName );
	bool RetTemplateInCatalogStatus( const CString& strTemplate, bool& bValid );

	void CreateErrorPage(const CString & strError, CString& out);

protected:
	friend class APGTSContext;
#ifdef LOCAL_TROUBLESHOOTER
	friend class CTSHOOTCtrl;
#endif
	// for use by status pages functions of APGTSContext
	CTopicShop& GetTopicShop() {return m_TopicShop;}
	CRegistryMonitor& GetRegistryMonitor() {return m_RegistryMonitor;}
	CThreadPool& GetThreadPool() {return *m_pThreadPool;}
	CPoolQueue& GetPoolQueue() {return *m_pThreadPool->m_pPoolQueue;}
	CDirectoryMonitor& GetDirectoryMonitor() {return m_DirectoryMonitor;}
	CRecentUse& GetRecentPasswords() {return m_RecentPasswords;}

protected:
	CTopicShop m_TopicShop;					// The collection of available topics.
	CThreadPool * m_pThreadPool;
	CDirectoryMonitor m_DirectoryMonitor;	// track changes to LST, DSC, HTI, BES files.
	CRegistryMonitor m_RegistryMonitor;		// access to registry values.
	CRecentUse m_RecentPasswords;

protected:
	DWORD GetMaxThreads();
	DWORD GetThreadsPP();
	bool HasDetailedEventLogging();
};
#endif // _H_APGTSCFG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\apgtscounters.cpp ===
// ApgtsCounters.cpp: implementation of the CApgtsCounters class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ApgtsCounters.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CApgtsCounters::CApgtsCounters()
{

}

CApgtsCounters::~CApgtsCounters()
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\apgtscac.h ===
//
// MODULE: APGTSCAC.H
//
// PURPOSE: Cache (maps from a set of NID/IST pairs to a set of recommended NIDs)
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Roman Mach, Joe Mabel
// 
// ORIGINAL DATE: 8-2-96
//
// NOTES: 
// 1. Based on Print Troubleshooter DLL
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		7-24-98		JM		pulled out of apgts.h
//

#ifndef _APGTSCAC_H_DEFINED
#define _APGTSCAC_H_DEFINED

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


#include <list>

#include "nodestate.h"

// maximum cache for belief networks
#define MAXCACHESIZE				200

// Maps from a set of node/state pairs to an ordered list of recommended nodes
// This is all within the context of a particular belief network.
class CCacheItem
{
private:
	CBasisForInference BasisForInference;  // Cache key.  Set of node/state pairs, not all
						//	the nodes in the belief network, just the ones on which we
						//	have state data from the user.  State is never ST_UNKNOWN.
						//	No "special" nodes like nidFailNode; these are all valid nodes
						//	on which to base an inference.  
	CRecommendations Recommendations;	// Cache value.  Unless nodes have been skipped, only the
						//	first element of the vector really matters because we will
						//	only give one recommendation at a time.

public:
	CCacheItem() {};
	CCacheItem(const CBasisForInference & Basis, const CRecommendations &Rec) :
		BasisForInference(Basis), Recommendations(Rec)
		{};

	// note that the following makes a copy; it does not return a reference.
	CRecommendations GetRecommendations() const {return Recommendations;}

	// The following comparison operators depend on the assumption that if the cache key 
	//	is identical, the cache value will be, too.
	// Note that this we do not use lexicographical order.  We're saying any shorter
	//	cache key compares as less than any longer.
	bool operator== (const CCacheItem &item) const;
	bool operator!= (const CCacheItem &item) const;
	bool operator< (const CCacheItem &item) const;
	bool operator> (const CCacheItem &item) const;
};

class CCache
{
private:
	list<CCacheItem> listItems;
	enum {k_CacheSizeMax = 200};
public:
	CCache() {};
	~CCache() {};
	void Clear() {listItems.clear();};
	bool AddCacheItem(const CBasisForInference &BasisForInference, const CRecommendations &Recommendations);
	bool FindCacheItem(const CBasisForInference &BasisForInference, CRecommendations &Recommendations) const;
	UINT GetCount() const;
};

#endif //_APGTSCAC_H_DEFINED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\apgtscounters.h ===
//
// MODULE: ApgtsCounters.h
//
// PURPOSE: interface and implementation for the CApgtsCounters class
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 10-01-1998
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		10-01-98	JM		Original
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_APGTSCOUNTERS_H__E3FD52E9_5944_11D2_9603_00C04FC22ADD__INCLUDED_)
#define AFX_APGTSCOUNTERS_H__E3FD52E9_5944_11D2_9603_00C04FC22ADD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "counter.h"

// There should be exactly one (global) instance of this class.
// Any other class C that needs access to these counters should get a pointer to
//	the relevant counter(s) in its own constructor and thereafter access the counter
//	through the member.
// If class C only needs to increment the counter, it's pointer to the CHourlyDailyCounter
//	should be of type CAbstractCounter.
// A single .cpp file should define APGTS_COUNTER_OWNER before including the present file.
class CApgtsCounters
{
public:
	CHourlyDailyCounter m_ProgramContemporary; // really just used to track when program started.
	CHourlyDailyCounter m_StatusAccesses;
	CHourlyDailyCounter m_OperatorActions;
	CHourlyDailyCounter m_AllAccessesStart;
	CHourlyDailyCounter m_AllAccessesFinish;
	CHourlyDailyCounter m_QueueFullRejections;
	CHourlyDailyCounter m_UnknownTopics;
	CHourlyDailyCounter m_LoggedErrors;

	CApgtsCounters()
		:	m_ProgramContemporary(CCounterLocation::eIdProgramContemporary),
			m_StatusAccesses(CCounterLocation::eIdStatusAccess),
			m_OperatorActions(CCounterLocation::eIdActionAccess),
			m_AllAccessesStart(CCounterLocation::eIdTotalAccessStart),
			m_AllAccessesFinish(CCounterLocation::eIdTotalAccessFinish),
			m_QueueFullRejections(CCounterLocation::eIdRequestRejected),
			m_UnknownTopics(CCounterLocation::eIdRequestUnknown),
			m_LoggedErrors(CCounterLocation::eIdErrorLogged)
	{}
	~CApgtsCounters() {}
};

#ifdef APGTS_COUNTER_OWNER
	CApgtsCounters g_ApgtsCounters;
#else
	extern CApgtsCounters g_ApgtsCounters;
#endif

#endif // !defined(AFX_APGTSCOUNTERS_H__E3FD52E9_5944_11D2_9603_00C04FC22ADD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\apgtscls.h ===
//
// MODULE: APGTSCLS.H
//
// PURPOSE: Class header file
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Roman Mach, Joe Mabel
// 
// ORIGINAL DATE: 8-2-96
//
// NOTES: 
// 1. Based on Print Troubleshooter DLL
// 
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V3.0		7-22-98		JM		Major revision, deprecate IDH.
// V3.1		1-06-99		JM		Extract APGTSEXT.H
//

#if !defined(APGTSCLS_H_INCLUDED)
#define APGTSCLS_H_INCLUDED

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include"apgtsinf.h"
#include "apgtslog.h"
#include "LogString.h"
#include "apgtspl.h"
#include "maxbuf.h"
#include "apgts.h"

#include <map>
using namespace std;


// string constants involved in commands from sysop to take various actions.
#define SZ_OP_ACTION "TSHOOOT"		// Preface to all operator actions.  Note the extra "O".
#define SZ_EMERGENCY_DEF SZ_OP_ACTION
#define SZ_RELOAD_TOPIC "E1"		// Reload one topic
#define SZ_KILL_THREAD "E2"			// Kill (and restart) one pool thread
#define SZ_RELOAD_ALL_TOPICS "E3"	// Reload all monitored files.
#define SZ_SET_REG "E4"				// Set a registry value.

#define SZ_KILL_STUCK_THREADS "E8"	// Kill (and restart) all stuck pool threads
#define SZ_EMERGENCY_REBOOT "E9"	// want to reboot this DLL.


// The product version is loaded from the resource file upon DLL startup.
// Used for APGTS logging and status page reporting.
extern CString	gstrProductVersion;		

// HTTP spec for document type.  For validation of incoming HTTP POST request.
#define CONT_TYPE_STR	"application/x-www-form-urlencoded"


class CHttpQuery {
public:
	CHttpQuery();
	~CHttpQuery();

	BOOL GetFirst(LPCTSTR szInput, TCHAR *pchName, TCHAR *pchValue);
	BOOL GetNext(TCHAR *pchName, TCHAR *pchValue);
	void Push(LPCTSTR szPushed);

protected:
	BOOL LoopFind(TCHAR *pchName, TCHAR *pchValue);
	void AddBuffer( TCHAR ch, TCHAR *tostr);
	void PutStr(LPCTSTR instr, TCHAR *addtostr);
	static void CleanStr(TCHAR *str);

protected:
	enum decstates {
		ST_GETNEXT,
		ST_FINDNAME,		
		ST_GETDATA,	
		ST_DECODEHEX1,	
		ST_DECODEHEX2,
		ST_GETFIRST,
	};
	decstates m_state;			// used to track where we are in putting together
								// characters while deciphering HTTP encoding.
	CString m_strInput;			// The original input buffer, containing name/value pairs.
								// It is also possible to "push" a pair onto the front of 
								//	this buffer
	int m_nIndex;				// index into the string of m_strInput.  Keeps track of 
								//	where we are in the parse.
};



// forward declaration
class CDBLoadConfiguration;
class CTopic;
class CSniffConnector;
//
//
class APGTSContext
{
private:
	//
	// this nested class is an internal manager if nid-value pairs container
	//
	class CCommandsAddManager;
	class CCommands	
	{
		friend class CCommandsAddManager;

	private:
		//
		// this nested class represent name/value pairs we get from an HTML form
		//
		class NID_VALUE_PAIR 
		{
		friend class CCommands;
		private:
			NID	nid;						// Note two special values:
											//	nidProblem: value is a node
											//	nidNil: ignore value
			int	value;						// typically a node state, but for nidProblem, it's
											// problem node NID
		public:
			bool operator<(const NID_VALUE_PAIR & pair)const
				{return nid<pair.nid || value<pair.value;};
			bool operator==(const NID_VALUE_PAIR & pair)const
				{return nid==pair.nid || value==pair.value;};
		};

	private:
		vector<NID_VALUE_PAIR>m_arrPair;

	private: // CAddManager is managing addition to object of this class
		int Add( NID nid, int value );

	public:
		CCommands() {}
		~CCommands() {}

		int GetSize() const;
		void RemoveAll();
		bool GetAt( int nIndex, NID &nid, int &value ) const;
		void RotateProblemPageToFront();
	};
	//
	// this nested class is an internal manager of additions to 
	//  "Commands: and "Sniffed" objects of CCommands class
	//
	class CCommandsAddManager
	{
		CCommands& m_Commands;
		CCommands& m_Sniffed;

	public:
		CCommandsAddManager(CCommands& commands, CCommands& sniffed) : m_Commands(commands), m_Sniffed(sniffed) {}
		~CCommandsAddManager() {}

	public:
		void Add(NID nid, int value, bool sniffed);
	};
	//
	// this nested class is an internal manager if name-value pairs container
	//  carrying additional imformation from HTMP form
	//
	class CAdditionalInfo
	{
	private:
		//
		// this nested class represent name/value pairs we get from an HTML form
		//
		class NAME_VALUE_PAIR 
		{
		friend class CAdditionalInfo;
		private:
			CString name;
			CString value;

		public:
			bool operator<(const NAME_VALUE_PAIR & pair)const
				{return name<pair.name;};
			bool operator==(const NAME_VALUE_PAIR & pair)const
				{return name==pair.name;};
		};

	private:
		vector<NAME_VALUE_PAIR>m_arrPair;

	public:
		CAdditionalInfo() {}
		~CAdditionalInfo() {}

		int GetSize() const;
		void RemoveAll();
		bool GetAt( int nIndex, CString& name, CString& value ) const;
		int Add( const CString& name, const CString& value );
	};

protected:
	enum eOpAction {eNoOpAction, eReloadTopic, eKillThread, eReloadAllTopics, eSetReg};

public:
	APGTSContext(	CAbstractECB *pECB, 
					CDBLoadConfiguration *pConf, 
					CHTMLLog *pLog, 
					GTS_STATISTIC *pStat,
					CSniffConnector* pSniffConnector);
	~APGTSContext();

	void ProcessQuery();

	static BOOL StrIsDigit(LPCTSTR pSz);

	CString RetCurrentTopic() const;

protected:
	void CheckAndLogCookie();
	void DoContent();

	DWORD ProcessCommands(LPTSTR pszCmd, LPTSTR pszValue);
	VOID ClearCommandList();
	VOID ClearSniffedList();
	VOID ClearAdditionalInfoList();
	//bool PlaceNodeInCommandList(NID nid, IST ist);
	//bool PlaceNodeInSniffedList(NID nid, IST ist);
	//bool PlaceInAdditionalInfoList(const CString& name, const CString& value);
	VOID SetNodesPerCommandList();
	VOID SetNodesPerSniffedList();
	VOID ProcessAdditionalInfoList();
	VOID ReadPolicyInfo();
	VOID LogNodesPerCommandList();
	CString GetStartOverLink();
	bool StripSniffedNodePrefix(LPTSTR szName);

	DWORD DoInference(
		LPTSTR pszCmd, 
		LPTSTR pszValue, 
		CTopic * pTopic,
		bool bUsesIDH);

	DWORD NextCommand(LPTSTR pszCmd, LPTSTR pszValue, bool bUsesIDH);
	DWORD NextAdditionalInfo(LPTSTR pszCmd, LPTSTR pszValue);
	DWORD NextIgnore(LPTSTR pszCmd, LPTSTR pszValue);
	NID NIDFromSymbolicName(LPCTSTR szNodeName);
	char *GetCookieValue(char *pszName, char *pszNameValue);
	void asctimeCookie(const struct tm &gmt, char * szOut);

	void SetError(LPCTSTR szMessage);

// Operator actions
	eOpAction IdentifyOperatorAction(CAbstractECB *pECB);
	eOpAction ParseOperatorAction(CAbstractECB *pECB, CString & strArg);
	void ExecuteOperatorAction(
		CAbstractECB *pECB, 
		eOpAction action,
		const CString & strArg);

// Status pages: code is in separate StatusPage.cpp
	void DisplayFirstPage(bool bHasPwd);
	void DisplayFurtherGlobalStatusPage();
	void DisplayThreadStatusOverviewPage();
	void DisplayTopicStatusPage(LPCTSTR topic_name);
	bool ShowFullFirstPage(bool bHasPwd);
	void InsertPasswordInForm();
	void BeginSelfAddressingForm();
	
protected:
	CAbstractECB *m_pECB;					// effectively, everything that came in from
											// the user in a submitted HTML form
	DWORD m_dwErr;
	// The next 2 are arrays of TCHAR rather than being CString, because it's easier
	//	for when they need to be passed to methods of EXTENSION_CONTROL_BLOCK
	TCHAR m_ipstr[MAXBUF];					// Remote IP address (who submitted the form)
	TCHAR m_resptype[MAXBUF];				// HTTP response type e.g. "200 OK", 
											//	"302 Object Moved"
	CString m_strHeader;					// header for response file (indicates whether
											// we're sending HTML, setting a cookie, etc.)
											// >>> $UNICODE Is it OK that this is CString (based
											//	on TCHAR) or should it always be char? JM 10/27/98
	CString m_strText;						// this is where we build the string to pass 
											//	back over the net.
											// >>> $UNICODE Is it OK that this is CString (based
											//	on TCHAR) or should it always be char? JM 10/27/98
	CString m_strLocalIPAddress;			// IP address (in the dotted form) for the local machine
											//  If not defined: GetLength() == 0
	CLogString m_logstr;					// We log to this object & when we're all done
											//	destructor writes it to the log.

	CHttpQuery m_Qry;						// takes in raw URL-encoded string, gives us
											//	functions to get back scanned pairs.
	CDBLoadConfiguration *m_pConf;			// contains support-file data structures
	CString m_strVRoot;						// Local URL to this DLL
	TCHAR *m_pszQuery;						// a copy of what came in via GET or POST
	CInfer m_infer;							// belief-network handler, unique to this request
											// This works out what node to show and builds HTML
											//	fragments for the HTI template to render.
	CHTMLLog *m_pLog;						// access to writing to the log.
	bool m_bPostType;						// TRUE = post, FALSE = get
	DWORD m_dwBytes;						// length of query string in chars, excluding
											// terminating null.
	GTS_STATISTIC *m_pStat;

	CCommandsAddManager m_CommandsAddManager; // manages adding data to m_Commands and m_Sniffed
	CCommands m_Commands;					// name/value pairs we get from an HTML form
	CCommands m_Sniffed;					// name/value pairs (for sniffed nodes) we get 
											//	from an HTML form; "SNIFFED_" already stripped out.
	CAdditionalInfo m_AdditionalInfo;		// name/value pairs we get from HTML. They represent
											//  additional info. Additional info is name/value
											//  pair other then command pair (C_TYPE, C_TOPIC or C_PRELOAD), 
											//  though first in name/value pair's sequence 
											//  will be a command.
	bool m_bPreload;						// TRUE = name/value pairs aren't really from a 
											//	user, they're from a sniffer.
	bool m_bNewCookie;						// true = we had to create a new cookie for this
											//	query: they didn't already have one.
	CHourlyDailyCounter * const m_pcountUnknownTopics; // count requests where the topic is not known in
											// the LST file.
	CHourlyDailyCounter * const m_pcountAllAccessesFinish; // Each time we finish with any sort of request,
											//	successful or not, this gets incremented.
	CHourlyDailyCounter * const m_pcountStatusAccesses; // Each time we finish a request for system status											

	CHourlyDailyCounter * const m_pcountOperatorActions; // Count operator action requests.											

	CString m_TopicName;
// You can compile with the NOPWD option to suppress all password checking.
// This is intended mainly for creating test versions with this feature suppressed.
#ifndef NOPWD
	CString m_strTempPwd;					// temporary password (if this is a status request)
#endif // ifndef NOPWD
// You can compile with the SHOWPROGRESS option to get a report on the progress of this page.
#ifdef SHOWPROGRESS
	time_t timeCreateContext;
	time_t timeStartInfer;
	time_t timeEndInfer;
	time_t timeEndRender;
#endif // SHOWPROGRESS

private:
	// Functions to set and retrieve an alternate HTI file name.
	void	SetAltHTIname( const CString& strHTIname );
	CString GetAltHTIname() const;

	CString	m_strAltHTIname;	// name of the alternate HTI template file if specified.

	typedef map<CString,CString> CCookiePairs;
	CCookiePairs m_mapCookiesPairs;	// Map of command line cookie name-value pairs.
};

// global prototypes
//UINT PoolTask(LPVOID);
UINT WINAPI PoolTask( LPVOID lpParams );
bool ProcessRequest(CPoolQueue & PoolQueue);

DWORD WINAPI DirNotifyTask( LPDWORD lpParams );

/////////////////////////////////////////////////////////////////////////////
#endif // APGTSCLS_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\apgtsecb.cpp ===
//
// MODULE: APGTSECB.CPP
//
// PURPOSE: Implementation of CAbstractECB class, which provides an abstraction from Win32's
//	EXTENSION_CONTROL_BLOCK.  Using this abstract class allows us to have common code for
//	the Online Troubleshooter (which actually uses an EXTENSION_CONTROL_BLOCK) and the Local
//	Troubleshooter (which needs to simulate similar capabilities).
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 01-04-99
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.1		01-04-99	JM		Original
//

#include "stdafx.h"
#include "apgtsECB.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\apgtsecb.h ===
//
// MODULE: APGTSECB.H
//
// PURPOSE: Interface of CAbstractECB class, which provides an abstraction from Win32's
//	EXTENSION_CONTROL_BLOCK.  Using this abstract class allows us to have common code for
//	the Online Troubleshooter (which actually uses an EXTENSION_CONTROL_BLOCK) and the Local
//	Troubleshooter (which needs to simulate similar capabilities).
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 01-04-99
//
// NOTES: 
//	1. EXTENSION_CONTROL_BLOCK is extensively documented in the VC++ documentation
//	2. It is imaginable that some of these methods are needed only in the Online Troubleshooter
//		and might be eliminated from this abstract class.
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.1		01-04-99	JM		Original
//

// apgtsECB.h: interface for the CAbstractECB class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_APGTSECB_H__56CCF083_A40C_11D2_9646_00C04FC22ADD__INCLUDED_)
#define AFX_APGTSECB_H__56CCF083_A40C_11D2_9646_00C04FC22ADD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <windows.h>
#include <httpext.h>

class CAbstractECB  
{
public:
	virtual ~CAbstractECB() {}

	// Methods corresponding to EXTENSION_CONTROL_BLOCK data members.  We must provide
	//	Get methods for all inputs from end user system and Set methods for all outputs to 
	//	end user system.  Classes which inherit from this may need Set methods for inputs 
	//	or Get methods for outputs, as well.  For example, the Local Troubleshooter will need
	//	to set the Method and Query String, since it does not actually receive these in 
	//	an EXTENSION_CONTROL_BLOCK.

    // DWORD	cbSize		IN, not currently used by TS.  Would have to add a Get method if
	//							this is ever needed
    // DWORD	dwVersion	IN, not currently used by TS.  Would have to add a Get method if
	//							this is ever needed
    // HCONN	ConnID		IN, only ever of concern within class COnlineECB

	// DWORD dwHttpStatusCode					OUT
	virtual DWORD SetHttpStatusCode(DWORD dwHttpStatusCode)=0;
    
	// CHAR		lpszLogData[HSE_LOG_BUFFER_LEN]	OUT, not currently used by TS.  Would have 
	//							to add a Set method if this is ever needed

    // LPSTR	lpszMethod		IN
	virtual LPSTR GetMethod() const =0;

    // LPSTR	lpszQueryString	IN
	virtual LPSTR GetQueryString() const =0;

    // LPSTR	lpszPathInfo	IN, not currently used by TS.  Would have to add a Get method if
	//							this is ever needed
    // LPSTR	lpszPathTranslated	IN, not currently used by TS.  Would have to add a Get method if
	//							this is ever needed
    // DWORD	cbTotalBytes	IN, not currently used by TS.  Would have to add a Get method if
	//							this is ever needed
    // DWORD	cbAvailable		IN
	virtual DWORD GetBytesAvailable() const =0;

    // LPBYTE	lpbData			IN
	virtual LPBYTE GetData() const =0;

    // LPSTR	lpszContentType	IN
	virtual LPSTR GetContentType() const =0;

	// Methods corresponding to EXTENSION_CONTROL_BLOCK methods
	// Note that EXTENSION_CONTROL_BLOCK uses pointers to functions, not actual function methods,
	//	but there doesn't seem to be any good reason for that.
    virtual BOOL GetServerVariable
	  ( /*HCONN      hConn,*/	// EXTENSION_CONTROL_BLOCK has an argument here, but for us it can 
								//	always be determined from *this
        LPCSTR       lpszVariableName,	// note, more const-ness than EXTENSION_CONTROL_BLOCK
        LPVOID      lpvBuffer,
        LPDWORD     lpdwSize ) =0;

    virtual BOOL WriteClient
	  ( /*HCONN      ConnID,*/	// EXTENSION_CONTROL_BLOCK has an argument here, but for us it can 
								//	always be determined from *this
	   LPCSTR	  Buffer,	// EXTENSION_CONTROL_BLOCK::WriteClient uses LPVOID, but it should
							//	only be legit to pass SBCS text, so we're enforcing that.
							// Also, we're adding const-ness.   
       LPDWORD    lpdwBytes
	   /* ,DWORD      dwReserved */ // EXTENSION_CONTROL_BLOCK::WriteClient reserves one more arg.
       ) =0;

    virtual BOOL ServerSupportFunction
	  ( /*HCONN      hConn,*/	// EXTENSION_CONTROL_BLOCK has an argument here, but for us it can 
								//	always be determined from *this
       DWORD      dwHSERRequest,
       LPVOID     lpvBuffer,
       LPDWORD    lpdwSize,
       LPDWORD    lpdwDataType ) =0;

	// since we don't use this we haven't bothered implementing.
    // BOOL ( WINAPI * ReadClient )
    //   ( HCONN      ConnID,
    //   LPVOID     lpvBuffer,
    //   LPDWORD    lpdwSize );

};

#endif // !defined(AFX_APGTSECB_H__56CCF083_A40C_11D2_9646_00C04FC22ADD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\apgtshtiscan.cpp ===
// apgtshtiscan.cpp: implementation of the CAPGTSHTIScanner class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "event.h"
#include "apgtshtiscan.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CAPGTSHTIScanner::CAPGTSHTIScanner(CPhysicalFileReader * pPhysicalFileReader, LPCTSTR szDefaultContents /*= NULL*/)
				: CAPGTSHTIReader(pPhysicalFileReader, szDefaultContents)
{
}

CAPGTSHTIScanner::CAPGTSHTIScanner(const CAPGTSHTIReader& htiReader)
				: CAPGTSHTIReader(htiReader)
{
}

CAPGTSHTIScanner::~CAPGTSHTIScanner()
{
}

void CAPGTSHTIScanner::Scan(const CHTMLFragments& fragments)
{
	LOCKOBJECT();
	try
	{
		m_pFragments = &fragments;
		InitializeInterpreted();
		////Interpret(); - NO interpretation here, we are scanning data, 
		////			  which is read from HTI file and not modified
		ParseInterpreted();
		SetOutputToInterpreted();
	}
	catch (...)
	{
		// Catch any other exception thrown.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								_T(""), _T(""), 
								EV_GTS_GEN_EXCEPTION );		
	}
	UNLOCKOBJECT();
}

void CAPGTSHTIScanner::ParseInterpreted()
{
	for (vector<CString>::iterator i = m_arrInterpreted.begin(); i < m_arrInterpreted.end(); i++)
	{
		CString command;

		if (GetCommand(*i, command))
		{
			if (command == COMMAND_VALUE)
			{
				CString variable;

				if (GetVariable(*i, variable))
					const_cast<CHTMLFragments*>(m_pFragments)->SetValue(variable);
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\apgtshtiread.h ===
//
// MODULE: APGTSHTIREAD.H
//
// PURPOSE: HTI template file reading classes
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 8-12-98
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		08-04-98	OK
//

#ifndef __APGTSHTIREAD_H_
#define __APGTSHTIREAD_H_

#include "templateread.h"
#include "HTMLFrag.h"


// these are not really commands, just service symbols
#define COMMAND_STARTSTR		_T("<!GTS")
#define COMMAND_ENDSTR			_T(">")
#define COMMAND_IFSTR			_T("if")
#define COMMAND_STARTVARSTR		_T("$")
// JSM V3.2 -- used to decode string argumentss
#define COMMAND_DOUBLEQUOTE _T("\"")
#define COMMAND_ESCAPECHAR _T("\\")       
// commands that have to be interpreted
#define COMMAND_ELSESTR			_T("else")
#define COMMAND_ENDIFSTR		_T("endif")
#define COMMAND_FORANYSTR		_T("forany")
#define COMMAND_ENDFORSTR		_T("endfor")
// commands that presume putting substitution string on their place
#define COMMAND_DISPLAYSTR		_T("display")
#define COMMAND_RESOURCESTR		_T("resource")
// command that brings general information, that can be processed
//  in classes inherited from CHTMLFragmentsTS
#define COMMAND_INFORMATION		_T("information")
// command that makes CHTMLFragmentsTS store some value
#define COMMAND_VALUE			_T("value")
// command that substitutes Network Property in the HTML:
#define COMMAND_PROPERTY		_T("property")
//

// V3.2 Additions.
#define COMMAND_ELSEIFSTR		_T("elseif")
#define COMMAND_COOKIE			_T("<!Cookie")

#define DELIMITER_POSTFIX		_T("!")
#define DELIMITER_PREFIX		_T("_")

//
// NO error handling here - whatever the result is, it will be accepted, 
//  the program flow should go to the end. NO throw exception.
//

///////////////////////////////////////////////////////////////////////////////////////////
// CAPGTSHTIReader
//  Term "Interpret" here is: unwind initial script with <!GTS forany $Something> or
//	<!GTS if $Something> to <!GTS forany $Something!24_SomethingElse!2...>
//  This interpreted script is to be ready for direct substitutions of <!GTS display ...>
//  and <!GTS resource ...>, which are only commands left in the interpreted script
///////////////////////////////////////////////////////////////////////////////////////////
class CAPGTSHTIReader : public CTemplateReader
{
protected:	// we can use data in inherited class
	vector<CString>  m_arrInterpreted; // (partly) interpreted template - some clauses 
									   //  are interpreted, when fully parsed - ready
									   //  for simple template substitution.
	const CHTMLFragments*  m_pFragments;
	
public:
	CAPGTSHTIReader(CPhysicalFileReader * pPhysicalFileReader, LPCTSTR szDefaultContents = NULL);
   ~CAPGTSHTIReader();

protected:
	virtual void Parse(); // do nothing - no traditional parsing, we first have to interpret

public:
	void CreatePage(	const CHTMLFragments& fragments, 
						CString& out, 
						const map<CString,CString> & mapStrs,
						CString strHTTPcookies= _T("") );

	bool HasHistoryTable();

	// JSM V3.2 returns a vector containing all net props which appear
	//  in the HTI file in lines like <!GTS property "fooprop">
	void ExtractNetProps(vector<CString> &arr_props);

protected:
	// level below CreatePage(...) 
	virtual void InitializeInterpreted();	// init string array with data read from HTI file
	virtual void Interpret();				// zoom this template in a simple template where all we need is string substitution
	virtual void ParseInterpreted();		// perform this substitution
	virtual void SetOutputToInterpreted();  // set standard template output (m_StreamOutput)
											//  from interpreted m_arrInterpreted
	//
	// we can read output by CTemplateReader::GetOutput();
	//
protected:
	// level below ...Interpret...(...)
	bool ExtractClause(vector<CString>& arr_text,
					   long* pstart_index,
					   vector<CString>& arr_clause);
	bool InterpretClause(vector<CString>& arr_clause);
protected:
	// used by previous ExtractClause
	// 	start_index is supposed to be positioned to beginning of clause
	bool ExtractClause(vector<CString>& arr_text,
					   long* pstart_index,
					   vector<CString>& arr_clause,
					   const CString& str_start_command,
					   const CString& str_end_command);
	// used by InterpretClause
	bool InterpretForanyClause(vector<CString>& arr_clause);
	bool InterpretIfClause(vector<CString>& arr_clause);
	// lowest level - parsing and changing <!GTS &...> - strings
	//  This function extracts command from line
	bool GetCommand(const CString& line, CString& command);
	//  This command composes <!GTS operator $variable>
	bool ComposeCommand(const CString& oper, const CString& variable, CString& command);
	//  This function extracts variable from line
	bool GetVariable(const CString& line, CString& variable);
	//  This function parses variable like Recommendations!199_States!99 into array
	void ParseVariable(const CString& variable, FragmentIDVector& out);
	//  This function composes variable from array
	void ComposeVariable(const FragmentIDVector& parsed, CString& variable);
	//  This function substitutes <!GTS ....> in "line" with "str_substitution"
	bool SubstituteCommandBlockWith(const CString& str_substitution, CString& line);
	// This function composes command block <!GTS command $variable >
	void ComposeCommandBlock(const CString& command, const CString& variable, CString& command_block);

	// NOTION of prefix - postfix. Prefix - parent variable, delimited by "_" from our variable,
	//  and postfix - number, delimited from our variable by "!"
	
	//  This function forms variable like Recommendations!11 where postfix == 11
	void PostfixVariable(const long postfix, CString& variable);
	//  This function forms variable like Recommendations!1_State where prefix == Recommendations!1
	void PrefixVariable(const CString& prefix, CString& variable);

private:
	// VERY low level
	//  This function reads command and variable from the <!GTS command $variable > block
	bool GetCommandVariableFromControlBlock(const CString& control_block, CString& command, CString& variable);
	//  This function reads command block (<!GTS command $variable >) from line
	bool GetControlBlockFromLine(const CString& line, CString& control_block);
	
	// JSM V3.2
	// extracts a string argument from a part of the command block; called by GetCommandVariableFromControlBlock
	CString GetStringArg(const CString & strText);
	// Converts a double-quoted string w/ an `escape character' to a correct CString.
	CString GetEscapedText(const CString &strText);
	// utility function called by the above:
	CString RemoveEscapesFrom(const CString &strIn);


#ifdef __DEBUG_CUSTOM
public:
	bool FlushOutputStreamToFile(const CString& file_name);
#endif

private:
	// This function handles the substituting of "<!Cookie" clauses with the either
	// values from cookies or the default value.
	void	SubstituteCookieValues( CString& strText );
	
	// This function searches the HTTP cookies for a given cookie name and attribute.  If
	// found, this function returns a value of true and the located cookie value.
	bool	LocateCookieValue(	const CString& strCookieName,
								const CString& strCookieAttr,
								CString& strCookieValue );
private:
	CString m_strHTTPcookies;	// V3.2 Enhancement, contains cookies from HTTP header
								// which are used in the Online Troubleshooter.
	map<CString,CString> m_mapCookies;
};

#endif // __APGTSHTIREAD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\apgtshtiread.cpp ===
//
// MODULE: APGTSHTIREAD.CPP
//
// PURPOSE: HTI template file reading classes
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 8-27-98
//
// NOTES: 
// 1. HTI is loosely modeled on a Microsoft format called HTX.  It's a template for an 
//		HTML file.  Most of it is HTML, but certain pseudo-comments of the form 
//		<!GTS whatever> are intended to be interpreted as conditionals, places to 
//		insert text, etc. 
//
//		Variables are limited to the values 
//			$ProblemAsk
//			$Recommendations
//			$States
//			$Questions
//			$Success (introduced 9/24/98)
//			$StartForm
//		See class CHTMLFragmentsTS for more details. 

//		Commands are if/else/endif, forany/endfor, display
//			There is also a notion of a "resource", basically an include file.
//
//		EXAMPLE 1
//		<!GTS forany $States >
//		<!GTS display $States >
//		<!GTS endfor>
//
//		EXAMPLE 2
//		<!GTS if $ProblemAsk >
//			lots of HTML or nested calls to more GTS stuff could go here
//		<!GTS else >
//			lots of other HTML or nested calls to other GTS stuff could go here
//		<!GTS endif >
//	
//	each <!GTS...> command must fit on a single line.
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		08-04-98	OK
//

#pragma warning(disable:4786)
#include "stdafx.h"
#include "apgtshtiread.h"
#include "event.h"
#include "CharConv.h"
#include "apgtsMFC.h"

#ifdef LOCAL_TROUBLESHOOTER
#include "htmlfraglocal.h"
#endif

namespace
{
	CString k_strHTMLtag= _T("/HTML");
}

///////////////////////////////////////////////////////////////////////////////////////////
// CAPGTSHTIReader
///////////////////////////////////////////////////////////////////////////////////////////
CAPGTSHTIReader::CAPGTSHTIReader(CPhysicalFileReader * pPhysicalFileReader, LPCTSTR szDefaultContents /* NULL */)
			   : CTemplateReader(pPhysicalFileReader, szDefaultContents),
				 m_pFragments(NULL) 
{
}

CAPGTSHTIReader::~CAPGTSHTIReader()
{
}

void CAPGTSHTIReader::Parse()
{
#ifdef LOCAL_TROUBLESHOOTER
	// OVERVIEW:  For the Local Troubleshooter, search for a <!GTS resource $Previous.script>
	// token in the stream. If one is not found, then insert one for backwards 
	// compatibility.
	try
	{
		// Load the stream into a vector while searching for a "Previous.script" token and also
		// determining the position of the last closing HTML tag location in order to know where 
		// to insert the generated_previous() function.
		CString str;
		vector<CString> str_arr;
		long indexLastHTML = -1;

		// Place the content of m_StreamData, line by line, into str_arr
		SetPos( m_StreamData, 0 );
		while (GetLine( m_StreamData, str ))
		{
			// Determine whether or not this line contains the "Previous.script" token.
			CString strCommand;
			if (GetCommand( str, strCommand))
			{
				// Check if the command is the right type.
				if (strCommand == COMMAND_RESOURCESTR)
				{
					CString strVariable;
					if (GetVariable( str, strVariable ))
					{
						// Check if the variable is the right type.
						if (strVariable == VAR_PREVIOUS_SCRIPT)
						{
							// We found what we were looking for.
							// Reset the stream position and exit function.
							SetPos( m_StreamData, 0 );
							return;
						}
					}
				}
			}
			
			// Add this line to the vector.
			str_arr.push_back( str );

			// Look for an HTML closing tag in this line.
			if (str.Find( k_strHTMLtag ) != -1)
			{
				// Mark the location of the last \HTML tag found.
				indexLastHTML= str_arr.size() - 1;
			}
		}

		// Rebuild the input stream from the vector and insert the "Previous.script" token
		// in the location determined above.
		vector<CString>::iterator iLastElement = str_arr.end();
		iLastElement--;	
		m_StreamData.clear();
		CString strResult;

		long index = 0;
		for (vector<CString>::iterator i = str_arr.begin(); i < str_arr.end(); i++, index++)
		{
			if (index == indexLastHTML)
			{
				// Add the required token to the string.
				strResult+= COMMAND_STARTSTR;
				strResult+= _T(" ");
				strResult+= COMMAND_RESOURCESTR;
				strResult+= _T(" ");
				strResult+= COMMAND_STARTVARSTR;
				strResult+= VAR_PREVIOUS_SCRIPT;
				strResult+= COMMAND_ENDSTR;
				strResult+= _T("\r\n");
			}
			
			strResult += *i;
		
			if (i != iLastElement)
				strResult+= _T("\r\n");
		}
		m_StreamData.str( (LPCTSTR) strResult );
		SetPos( m_StreamData, 0 );
	}
	catch (exception& x)
	{
		CString str;
		// Note STL exception in event log.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								CCharConversion::ConvertACharToString(x.what(), str), 
								_T(""), 
								EV_GTS_STL_EXCEPTION ); 
	}
#endif
}

// JSM V3.2 adapted from CreatePage()
//  builds list of all Network props in this HTI file which appear
//   in lines like <!GTI property "fooprop">
//
//  called by apgtscontext to find network properties to pass to CHTMLFragmentsTS 
void CAPGTSHTIReader::ExtractNetProps(vector <CString> &arr_props)
{
	LOCKOBJECT();
	try
	{
		arr_props.clear();
		// InitializeInterpreted populates m_arrInterpreted and
		//   performs cookie substitutions. This is correct behavior,
		//   because cookie substitution is supposed to happen
		//   before !GTS processing, and it is conceivable
		//   that a cookie's value could be "<!GTS property fooprop>"
		InitializeInterpreted();
		// we should not call Interpret(), which involves parsing <!GTS clauses
		for (vector<CString>::iterator i = m_arrInterpreted.begin(); i < m_arrInterpreted.end(); i++)
		{
			CString command;
			if (GetCommand(*i, command))
			{
				if (command == COMMAND_PROPERTY)
				{
					CString strProperty;
					if (GetVariable(*i,strProperty))
						arr_props.push_back(strProperty);
				}
			}
		}
	}
	catch (...)
	{
		// Catch any other exception thrown.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								_T(""), _T(""), 
								EV_GTS_GEN_EXCEPTION );		
	}
	UNLOCKOBJECT();
}


void CAPGTSHTIReader::CreatePage(	const CHTMLFragments& fragments, 
									CString& out, 
									const map<CString,CString> & mapStrs,
									CString strHTTPcookies/*= _T("")*/ )
{
	LOCKOBJECT();
	try
	{
		m_pFragments = &fragments;

		// V3.2 Cookie related enhancement.
		// Opted to use a member variable rather than modifying class interface by
		// adding a parameter to virtual void method InitializeInterpreted().
		m_strHTTPcookies= strHTTPcookies;
		m_mapCookies= mapStrs;

		InitializeInterpreted();
		Interpret();
#ifdef __DEBUG_CUSTOM
		SetOutputToInterpreted();
		FlushOutputStreamToFile("..\\Files\\interpreted.hti");
#endif
		ParseInterpreted();
		SetOutputToInterpreted();
#ifdef __DEBUG_CUSTOM
		FlushOutputStreamToFile("..\\Files\\result.htm");
#endif
		out = m_StreamOutput.rdbuf()->str().c_str();
	}
	catch (...)
	{
		// Catch any other exception thrown.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								_T(""), _T(""), 
								EV_GTS_GEN_EXCEPTION );		
	}
	UNLOCKOBJECT();
}

void CAPGTSHTIReader::InitializeInterpreted()
{
	long savePos = 0;
	CString str;
	CString command;
	bool bOldFormat = true; // this is an old format (without $Success or $StartForm)
	bool bFoundFirstBlock= false;
	
	savePos = GetPos();
	bOldFormat = !Find(CString(COMMAND_STARTVARSTR)+VAR_SUCCESS) &&
			     !Find(CString(COMMAND_STARTVARSTR)+VAR_STARTFORM);
	SetPos(0);
	m_arrInterpreted.clear();

	try
	{
		while (GetLine(str)) 
		{
			if (bOldFormat && (!bFoundFirstBlock) && (-1 != str.Find( COMMAND_STARTSTR )))
			{
				// Output the $StartForm block only if it is not a resource string command.
				CString strCommand;
				if ((GetCommand( str, strCommand )) && (strCommand != COMMAND_RESOURCESTR))
				{
					/*
					<!GTS if $StartForm>
					<!GTS display $StartForm>
					<!GTS endif>
					*/
					ComposeCommand(COMMAND_IFSTR, VAR_STARTFORM, command);
					m_arrInterpreted.push_back(command);
					ComposeCommand(COMMAND_DISPLAYSTR, VAR_STARTFORM, command);
					m_arrInterpreted.push_back(command);
					ComposeCommand(COMMAND_ENDIFSTR, _T(""), command);
					m_arrInterpreted.push_back(command);

					bFoundFirstBlock = true;
				}
			}

			if (bOldFormat && (-1 != str.Find(_T("</FORM>"))))
			{
				/*
				<!GTS if $StartForm>
				*/
				ComposeCommand(COMMAND_IFSTR, VAR_STARTFORM, command);
				m_arrInterpreted.push_back(command);

				m_arrInterpreted.push_back(str);
				/*
				<!GTS endif>
				*/
				ComposeCommand(COMMAND_ENDIFSTR, _T(""), command);
				m_arrInterpreted.push_back(command);
			}
			else
			{
				// Check if we need to populate any cookie clauses.
				if (-1 != str.Find( COMMAND_COOKIE ))
					SubstituteCookieValues( str );

				m_arrInterpreted.push_back(str);
			}
		}
	}
	catch (exception& x)
	{
		CString str2;
		// Note STL exception in event log.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								CCharConversion::ConvertACharToString(x.what(), str2), 
								_T(""), 
								EV_GTS_STL_EXCEPTION ); 
	}

	SetPos(savePos);
}

void CAPGTSHTIReader::Interpret()
{
	long curr_index = 0;
	long lLastIndex= -1;	// Used to detect a HTI file with incomplete clauses.

	while(true)
	{
		vector<CString> clause_arr;

		// tries to extract clause from m_arrInterpreted starting with curr_index
		//  and remove it from m_arrInterpreted
		if (ExtractClause(m_arrInterpreted,
						  &curr_index, // in - out
						  clause_arr))
		{
			// Reset the infinite loop detection counter.
			lLastIndex= -1;

			// Now curr_index is pointing to next element 
			//  of m_arrInterpreted (after removed clause) 
			//  OR OUTSIDE boundary of m_arrInterpreted.
			if (InterpretClause(clause_arr))
			{
				vector<CString>::iterator i = m_arrInterpreted.begin();
				{	// create iterator that points to m_arrInterpreted[curr_index]
					//  or is m_arrInterpreted.end()
					long tmp_index = curr_index;
					while(tmp_index--)
						i++;
				}

				try
				{
					// insert interpreted clause there
					for (vector<CString>::iterator j = clause_arr.begin(); j < clause_arr.end(); j++)
					{
						i = m_arrInterpreted.insert(i, *j); // inserts before "i"
						i++;
						curr_index++;
					}
				}
				catch (exception& x)
				{
					CString str;
					// Note STL exception in event log.
					CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
					CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
											SrcLoc.GetSrcFileLineStr(), 
											CCharConversion::ConvertACharToString(x.what(), str), 
											_T(""), 
											EV_GTS_STL_EXCEPTION ); 
				}
			}
		}
		else
		{
			// If this condition is true, then we are in an infinite loop due to a bad HTI file.  
			if (lLastIndex == curr_index)
			{
				// Log that this HTI file does not parse correctly.
				CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
				CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
										SrcLoc.GetSrcFileLineStr(), 
										GetPathName(), _T(""), 
										EV_GTS_BAD_HTI_FILE );		
				break;
			}

			// Update the infinite loop detection counter.
			lLastIndex= curr_index;

			if (curr_index)	{
				// we finished current pass of m_arrInterpreted, start new one
				curr_index = 0;
				continue;
			}
			else {
				// we can not extract clause though we start from beginning - 
				//  m_arrInterpreted is interpreted now
				break;
			}
		}
	}
}
// modified V3.2 JSM
void CAPGTSHTIReader::ParseInterpreted()
{
	for (vector<CString>::iterator i = m_arrInterpreted.begin(); i < m_arrInterpreted.end(); i++)
	{
		CString command;

		if (GetCommand(*i, command))
		{
			if (command == COMMAND_DISPLAYSTR ||
			    command == COMMAND_RESOURCESTR ||
			    command == COMMAND_INFORMATION
			   )
			{
				CString variable;

				if (GetVariable(*i, variable))
				{
					CString substitution;
					FragmentIDVector arr_fragment;

					ParseVariable(variable, arr_fragment);
					substitution = const_cast<CHTMLFragments*>(m_pFragments)->GetText(arr_fragment, (command == COMMAND_RESOURCESTR) ? CHTMLFragments::eResource : CHTMLFragments::eNotOfInterest );
					SubstituteCommandBlockWith(substitution, *i);
				}
				else // obvious misbehaviour - "display" command should have variable
					SubstituteCommandBlockWith(_T(""), *i);
			}
			else if (command == COMMAND_VALUE)
			{
				CString variable;

				if (GetVariable(*i, variable))
					const_cast<CHTMLFragments*>(m_pFragments)->SetValue(variable);

				SubstituteCommandBlockWith(_T(""), *i);
			}
			//  V3.2 JSM
			else if (command == COMMAND_PROPERTY)
			{
				CString strProperty;
				if (GetVariable(*i,strProperty))
				{
					CString substitution;
					substitution = const_cast<CHTMLFragments*>(m_pFragments)->GetNetProp(strProperty);
					SubstituteCommandBlockWith(substitution, *i);
				}
				else // obvious misbehaviour - "property" command should have variable
					SubstituteCommandBlockWith(_T(""), *i);
			} // end V3.2 JSM
			else // obvious misbehaviour - no other commands
				SubstituteCommandBlockWith(_T(""), *i);
		}
	}
}

void CAPGTSHTIReader::SetOutputToInterpreted()
{
	vector<CString>::iterator j = m_arrInterpreted.end();

	// Decrement to point to last element.
	j--;
	m_StreamOutput.str(_T(""));
	for (vector<CString>::iterator i = m_arrInterpreted.begin(); i < m_arrInterpreted.end(); i++)
	{
		m_StreamOutput << (LPCTSTR)*i;
		if (i != j) // not last element
			m_StreamOutput << _T('\r') << _T('\n');
	}
	m_StreamOutput << ends;
}

// INPUT:  arr_text (with clause)
// IMPUT:  *pstart_index - index in arr_text
// OUTPUT: arr_text without clause
// OUTPUT: *pstart_index points to element in arr_text next to where 
//          clause used to be or outside arr_text
// OUTPUT: arr_clause - extracted clause
bool CAPGTSHTIReader::ExtractClause(vector<CString>& arr_text,
								    long* pstart_index,
								    vector<CString>& arr_clause) 
{
	if (*pstart_index > arr_text.size() - 1) // quite possible
		return false;

	for (long i = *pstart_index; i < arr_text.size(); i++)
	{
		CString str_command;

		if (GetCommand(arr_text[i], str_command))
		{
			if (str_command == COMMAND_FORANYSTR)
			{
				if (ExtractClause(arr_text,
								  &i,
								  arr_clause,
								  COMMAND_FORANYSTR,
								  COMMAND_ENDFORSTR))
				{
					*pstart_index = i;
					return true;
				}
				else
				{
					*pstart_index = i;
					return false;
				}
			}
			if (str_command == COMMAND_IFSTR)
			{
				if (ExtractClause(arr_text,
								  &i,
								  arr_clause,
								  COMMAND_IFSTR,
								  COMMAND_ENDIFSTR))
				{
					*pstart_index = i;
					return true;
				}
				else
				{
					*pstart_index = i;
					return false;
				}
			}
		}
	}
	return false;
}

bool CAPGTSHTIReader::ExtractClause(vector<CString>& arr_text,
								    long* pstart_index,
								    vector<CString>& arr_clause,
									const CString& str_start_command,
								    const CString& str_end_command)
{
	CString str_command;
	long start = *pstart_index, end = *pstart_index;
	long nest_level_counter = 1;

	while (++end < arr_text.size())
	{
		if (GetCommand(arr_text[end], str_command))
		{
			if (str_command == str_start_command)
			{
				nest_level_counter++;
			}
			if (str_command == str_end_command)
			{
				nest_level_counter--;
				if (!nest_level_counter)
				{
					vector<CString>::iterator start_it = arr_text.begin();
					vector<CString>::iterator   end_it = arr_text.begin();
					
					arr_clause.clear();
					try
					{   
						// copy clause to arr_clause
						for (long j = start; j <= end; j++)
							arr_clause.push_back(arr_text[j]);
					}
					catch (exception& x)
					{
						CString str;
						// Note STL exception in event log.
						CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
						CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
												SrcLoc.GetSrcFileLineStr(), 
												CCharConversion::ConvertACharToString(x.what(), str), 
												_T(""), 
												EV_GTS_STL_EXCEPTION ); 
					}

					// make iterators correspond indexes
					while(start--)
						start_it++;
					while(end--)
						end_it++;
					// and, because we want to delete element pointed 
					//  at this moment by end_it:
					end_it++; 
					// remove clause from arr_text
					arr_text.erase(start_it, end_it);
					return true;
				}
			}
		}
	}
	*pstart_index = --end;;
	return false;
}

bool CAPGTSHTIReader::InterpretClause(vector<CString>& arr_clause)
{
	CString str_command;

	if (arr_clause.size() &&
		GetCommand(arr_clause[0], str_command))
	{
		if (str_command == COMMAND_FORANYSTR)
			return InterpretForanyClause(arr_clause);
		if (str_command == COMMAND_IFSTR)
			return InterpretIfClause(arr_clause);
		return false;
	}
	return false;
}

bool CAPGTSHTIReader::InterpretForanyClause(vector<CString>& arr_clause)
{
	long count = 0;
	CString strVariable; // variable from 1-st line of arr_clause
	vector<CString> arrUnfolded;
	FragmentIDVector arrVariable; // array from strVariable

	if (arr_clause.size() < 2) // "forany" and "endfor" commands
		return false;

	if (!GetVariable(arr_clause[0], strVariable))
		return false;

	ParseVariable(strVariable, arrVariable);
	
	count = m_pFragments->GetCount(arrVariable);

	try
	{
		for (long i = 0; i < count; i++)
		{
			for (long j = 1; j < arr_clause.size() - 1; j++)
			{
				CString command, variable;

				if (GetCommand(arr_clause[j], command) &&
					GetVariable(arr_clause[j], variable))
				{
					if (command == COMMAND_FORANYSTR && variable == strVariable) 
					{
						// if it is clause "forany" with the same variable,
						//  there should be neither prefixing nor postfixing
					}
					else
					{
						CString line = arr_clause[j];

						if (variable == strVariable) 
						{
							PostfixVariable(i, variable);
						} 
						else 
						{
							FragmentIDVector parents, children;
							CString strVariable_postfixed = strVariable;
							PostfixVariable(i, strVariable_postfixed);

							ParseVariable(strVariable_postfixed, parents);
							ParseVariable(variable, children);
							if (m_pFragments->IsValidSeqOfVars(parents, children))
								PrefixVariable(strVariable_postfixed, variable);
						}
						CString command_block;
						ComposeCommandBlock(command, variable, command_block);
						SubstituteCommandBlockWith(command_block, line);
						arrUnfolded.push_back(line);
						continue;
					}
				}
				arrUnfolded.push_back(arr_clause[j]);
			}
		}
	}
	catch (exception& x)
	{
		CString str;
		// Note STL exception in event log.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								CCharConversion::ConvertACharToString(x.what(), str), 
								_T(""), 
								EV_GTS_STL_EXCEPTION ); 
	}

	arr_clause = arrUnfolded;
	return true;
}

bool CAPGTSHTIReader::InterpretIfClause(vector<CString>& arr_clause)
{
	CString strVariable; // variable from a line of arr_clause
	FragmentIDVector arrVariable;

	if (arr_clause.size() < 2) // "if" and "endif" commands
		return false;

	if (!GetVariable( arr_clause[ 0 ], strVariable ))
		return false;
	
	ParseVariable( strVariable, arrVariable );

	// Scan for "if", "elseif", "else", and "endif" commands
	vector<int> arrElseIfIndices;
	int elseIndex = -1; // index of "else" inside arr_clause
	int i = 0;
	int nDepthOfNesting;	
	for (i= 1, nDepthOfNesting= 0; i < arr_clause.size() - 1; i++)
	{
		CString command;
		if (GetCommand(arr_clause[i], command))
		{
			if (command == COMMAND_IFSTR)
			{
				nDepthOfNesting++;
			}
			else if (command == COMMAND_ENDIFSTR)
			{
				nDepthOfNesting--;
			}
			else if (command == COMMAND_ELSEIFSTR)
			{
				// V3.2 - Check if this elseif clause is at the level we are looking for.
				if (nDepthOfNesting == 0) 
					arrElseIfIndices.push_back( i );
			}
			else if (command == COMMAND_ELSESTR)
			{
				// Check if this else clause is at the level we are looking for.
				if (nDepthOfNesting == 0) 
				{
					elseIndex = i;
					break;
				}
			}
		}
	}


	vector<CString> arrBody; // intermediate array
	try
	{
		CString strName; // name of strVariable associated through CHTMLFragments
		strName = const_cast<CHTMLFragments*>(m_pFragments)->GetText(arrVariable);
		if (strName.GetLength())
		{   
			// Standard processing of what is inside if ... else (or endif)
			int nEndOfClause= (arrElseIfIndices.size()) ? arrElseIfIndices[ 0 ] : elseIndex;
			for (i = 1; i < (nEndOfClause == -1 ? arr_clause.size() - 1 : nEndOfClause); i++)
				arrBody.push_back(arr_clause[i]);
		}
		else
		{   
			// Process any elseif or else clauses.
			bool bDoneProcessing= false;
			for (int nElseIf= 0; nElseIf < arrElseIfIndices.size(); nElseIf++)
			{
				if (!GetVariable( arr_clause[ arrElseIfIndices[ nElseIf ] ], strVariable ))
					return false;
	
				ParseVariable( strVariable, arrVariable );

				strName = const_cast<CHTMLFragments*>(m_pFragments)->GetText(arrVariable);
				if (strName.GetLength())
				{
					// Determine the ending point of this elseif clause and extract all clauses within.
					int nEndOfClause= ((nElseIf + 1) < arrElseIfIndices.size()) 
										? arrElseIfIndices[ nElseIf + 1 ] : elseIndex;
					for (i= arrElseIfIndices[ nElseIf ] + 1; i < nEndOfClause; i++)
						arrBody.push_back( arr_clause[ i ] );
				
					bDoneProcessing= true;
					break;
				}
			}

			if ((!bDoneProcessing) && (elseIndex != -1))
			{
				// All of the clauses failed, output all clauses following the "else".
				for (i = elseIndex + 1; i < arr_clause.size() - 1; i++)
					arrBody.push_back(arr_clause[i]);
			}
		}
	}
	catch (exception& x)
	{
		CString str;
		// Note STL exception in event log.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								CCharConversion::ConvertACharToString(x.what(), str), 
								_T(""), 
								EV_GTS_STL_EXCEPTION ); 
	}
	
	arr_clause = arrBody;
	return true;
}

bool CAPGTSHTIReader::GetCommand(const CString& line, CString& command)
{
	CString control_block;
	CString variable;

	if (GetControlBlockFromLine(line, control_block))
		if (GetCommandVariableFromControlBlock(control_block, command, variable))
			return true;
	
	return false;
}

bool CAPGTSHTIReader::ComposeCommand(const CString& oper, const CString& variable, CString& command)
{
	command = _T("");
	LPCTSTR ws = _T(" ");

	command += COMMAND_STARTSTR;
	command += ws;
	command += oper;
	if (variable.GetLength()) {
		command += ws;
		command += COMMAND_STARTVARSTR;
		command += variable;
	}
	command += COMMAND_ENDSTR;
	
	return true;
}

bool CAPGTSHTIReader::GetVariable(const CString& line, CString& arg_variable)
{
	CString control_block;
	CString command, variable;

	if (GetControlBlockFromLine(line, control_block))
		if (GetCommandVariableFromControlBlock(control_block, command, variable))
			if (variable.GetLength()) {
				arg_variable = variable;
				return true;
			}
	return false;
}

void CAPGTSHTIReader::ParseVariable(const CString& variable, FragmentIDVector& out)
{
	vector<CString> arrStr;
	int start_index = 0;
	int end_index = -1;

	try
	{
		// arrStr contains strings between delimiter "_"
		while(-1 != (end_index = CString((LPCTSTR)variable + start_index).Find(DELIMITER_PREFIX)))
		{
			// end_index here is from "(LPCTSTR)variable + start_index" string
			//  so we can use it as length (2nd argument) in CString::Mid function
			arrStr.push_back(((CString&)variable).Mid(start_index, end_index));
			start_index = start_index + end_index + _tcslen(DELIMITER_PREFIX);
		}
		// pull the "tail" - after last (if any) "_"
		arrStr.push_back(((CString&)variable).Right(variable.GetLength() - start_index));

		out.clear();
		for (vector<CString>::iterator i = arrStr.begin(); i < arrStr.end(); i++)
		{
			FragmentID fragmentID;
			int curr = (*i).Find(DELIMITER_POSTFIX);
			
			if (-1 != curr)
			{
				fragmentID.VarName = (*i).Left(curr);

				curr += _tcslen(DELIMITER_POSTFIX); // skip delimiter
				
				CString strIndex = (LPCTSTR)(*i) + curr;
				strIndex.TrimLeft();
				strIndex.TrimRight();

				if (strIndex == _T("0"))
					fragmentID.Index = 0;
				else
					fragmentID.Index =    _ttol((LPCTSTR)strIndex) == 0 
										? fragmentID.Index 	// error occur
										: _ttol((LPCTSTR)strIndex);
			}
			else
				fragmentID.VarName = *i;

			out.push_back(fragmentID);
		}
	}
	catch (exception& x)
	{
		CString str;
		// Note STL exception in event log.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								CCharConversion::ConvertACharToString(x.what(), str), 
								_T(""), 
								EV_GTS_STL_EXCEPTION ); 
	}
}

void CAPGTSHTIReader::ComposeVariable(const FragmentIDVector& arr_fragment, CString& variable)
{
	variable = _T("");

	for (FragmentIDVector::const_iterator i = arr_fragment.begin(); i < arr_fragment.end(); i++)
	{
		if (i != arr_fragment.begin())
			variable += DELIMITER_PREFIX;
		
		variable += (*i).VarName;

		if ((*i).Index != -1) 
		{
			TCHAR buf[128] = {0};

			variable += DELIMITER_POSTFIX;
			_stprintf(buf, _T("%d"), (*i).Index);
			variable += buf;
		}
	}
}

bool CAPGTSHTIReader::SubstituteCommandBlockWith(const CString& str_substitution, CString& line)
{
	int start_index = -1;
	int end_index = -1;

	if (-1 != (start_index = line.Find(COMMAND_STARTSTR)))
	{
		if (-1 != (end_index = CString((LPCTSTR)line + start_index).Find(COMMAND_ENDSTR)))
		{
			CString tmp;
			
			end_index += start_index;
			end_index += _tcslen(COMMAND_ENDSTR); // skip closing bracket

			tmp += line.Left(start_index);
			tmp += str_substitution;
			tmp += line.Right(line.GetLength() - end_index);

			line = tmp;
			return true;
		}
	}
	return false;
}

void CAPGTSHTIReader::ComposeCommandBlock(const CString& command, const CString& variable, CString& command_block)
{
	command_block  = COMMAND_STARTSTR;
	command_block += _T(" ");
	command_block += command;
	command_block += _T(" ");
	command_block += COMMAND_STARTVARSTR;
	command_block += variable;
	command_block += _T(" ");
	command_block += COMMAND_ENDSTR;
}

void CAPGTSHTIReader::PostfixVariable(const long postfix, CString& variable)
{
	TCHAR buf[128] = {0};
	
	_stprintf(buf, _T("%ld"), postfix);
	variable += DELIMITER_POSTFIX;
	variable += buf;
}

void CAPGTSHTIReader::PrefixVariable(const CString& prefix, CString& variable)
{
	CString tmp = variable;

	variable = prefix;
	variable += DELIMITER_PREFIX;
	variable += tmp;
}
// JSM V3.2 -- 
//   called by GetCommandVariableFromControlBlock to handle
//    decoding the variable part of commands like <!GTS property "fooprop">
//    finds the first string argument in strText, which is either:
//       any text beginning w/ anything other than '"', ending w/ whitespace or COMMAND_ENDSTR
//       all text between doublequote marks "...." where an escape char ('\') escapes the character following.
//
CString CAPGTSHTIReader::GetStringArg(const CString & strText)
{
	CString strArg = strText;

	// look for quoted text:
	int iStartQuote = strArg.Find(COMMAND_DOUBLEQUOTE);
	if (iStartQuote != -1)
	{
		strArg = strArg.Mid(iStartQuote);
		return GetEscapedText(strArg);
	}	
	// o/w, assume that we're dealing w/ ordinary text, which ends
	//  with first whitespace or with COMMAND_ENDSTR
	strArg.TrimLeft();

	int iWhiteSpace(0), iEndCmd(0);
	for(;(iWhiteSpace < strArg.GetLength()) && !(_istspace(strArg[iWhiteSpace])); iWhiteSpace++);

	iEndCmd = strArg.Find(COMMAND_ENDSTR);

	strArg = strArg.Left(min(iEndCmd,iWhiteSpace));
	return strArg;
}

// JSM V3.2
// Called by GetEscapedText
// recursive function which does the work of removing escapes (backslashes)
//  also checks for non-escaped endquote, which terminates the process
CString CAPGTSHTIReader::RemoveEscapesFrom(const CString &strIn)
{
	int iNextESC = strIn.Find(COMMAND_ESCAPECHAR);
	int iNextQuote = strIn.Find(COMMAND_DOUBLEQUOTE);

	//	(iNextQuote == -1) means a bad input, because the string
	//   we're looking at must terminate with quote.
	//   By default, however, we'll keep running to end of strIn.
	if (iNextQuote == -1)
		iNextQuote = strIn.GetLength();

	// no more escape chars
	if (iNextESC == -1 || (iNextESC > iNextQuote))
		return strIn.Left(iNextQuote);

	CString strEscapedChar;
	strEscapedChar = strIn.GetAt(iNextESC + _tcslen(COMMAND_ESCAPECHAR));
	return strIn.Left(iNextESC) +
		   strEscapedChar + 
		   RemoveEscapesFrom(strIn.Mid(iNextESC + _tcslen(COMMAND_ESCAPECHAR) + 1));
}

// Converts a double-quoted string using backslash as an escape character to a correct CString
CString CAPGTSHTIReader::GetEscapedText(const CString &strText)
{
	CString strEscaped;

	// remove leading quote and anything preceding:
	int iLeadQuote = strText.Find(COMMAND_DOUBLEQUOTE);
	if (iLeadQuote != -1)
	{
		strEscaped = RemoveEscapesFrom(strText.Mid(iLeadQuote + _tcslen(COMMAND_DOUBLEQUOTE)));
	}
	return strEscaped;
}

// JSM V3.2 added ability to read string arguments into variable
//  e.g. <!GTS property "FOO">
// 
bool CAPGTSHTIReader::GetCommandVariableFromControlBlock(const CString& control_block, CString& command, CString& variable)
{
	int start_command_index = -1;
	int end_command_index = -1;
	int start_variable_index = -1;
	int end_variable_index = -1;


	variable.Empty(); 
	command.Empty();

	start_command_index = control_block.Find(COMMAND_STARTSTR);
	if (start_command_index == -1)			          // invalid control block
		return false;
	start_command_index += _tcslen(COMMAND_STARTSTR); // skip prefix

	// extract the variable block, which can look like:
	//               ... $variable_name  ...
	//               ... "parameter_name\\\"" ... (text in quotes w/ backslash escape)
	//                   parameter_name           (plain text)
	if (-1 != (	end_command_index = (control_block.Mid(start_command_index)).Find(COMMAND_STARTVARSTR) ) )
	{
		// Variable prefixed with '$...'
		end_command_index += start_command_index; // make end_command_index relative to start of control block
		start_variable_index = end_command_index + _tcslen(COMMAND_STARTVARSTR); // skip "$"
		end_variable_index = control_block.Find(COMMAND_ENDSTR);

		// validation of indexes
		if (-1 == min(start_command_index, end_command_index) ||
			start_command_index > end_command_index)
			return false;

		command = ((CString&)control_block).Mid(start_command_index, end_command_index - start_command_index);
		command.TrimLeft();
		command.TrimRight();

		if (start_variable_index > end_variable_index)
			return false;
		if (-1 != start_variable_index)
		{
			// extract variable from "..$varname>"
			variable = ((CString&)control_block).Mid(start_variable_index, end_variable_index - start_variable_index);
			variable.TrimLeft();
			variable.TrimRight();
		}
	}
	else
	{
		// Not prefixed with $.
		// we don't know whether we're looking for a "\"quoted\"" or
		//  non-quoted string, or no variable at all.  Also, we need
		//  to handle special cases like:
		//           <!GTS parameter ">">
		//           <!GTS endfor >
		//  etc.
		command = ((CString&)control_block).Mid(start_command_index);
		command.TrimLeft();
		command.TrimRight();
		// step through looking for whitespace at end of command:
		int iWhiteSpace;
		for(iWhiteSpace = 0;
		    (iWhiteSpace < command.GetLength()) && !(_istspace(command[iWhiteSpace]));
			iWhiteSpace++);

		if (iWhiteSpace != command.GetLength())
		{
			// found whitespace; the rest of the string may be a variable:
			variable = GetStringArg(command.Mid(iWhiteSpace));
			command = command.Left(iWhiteSpace); // truncate command where appropriate
		}
		else
		{
			// If there wasn't a variable after the command, we
			//   may still need to truncate to remove the COMMAND_ENDSTR:
			end_command_index = command.Find(COMMAND_ENDSTR);
			if (end_command_index != -1)
				command = command.Left(end_command_index);
		}
	}


	return true;
}

bool CAPGTSHTIReader::GetControlBlockFromLine(const CString& line, CString& control_block)
{
	int start_index = -1;
	int end_index = -1;

	if (-1 == (start_index = line.Find(COMMAND_STARTSTR)))
		return false;
	if (-1 == (end_index = CString((LPCTSTR)line + start_index).Find(COMMAND_ENDSTR)))
		return false;

	end_index += _tcslen(COMMAND_ENDSTR); // points beyond closing bracket
	end_index += start_index; // points in "line" string

	control_block = ((CString&)line).Mid(start_index, end_index - start_index);
	control_block.TrimLeft();
	control_block.TrimRight();

	return true;
}

bool CAPGTSHTIReader::HasHistoryTable()
{
	bool bRet;

	LOCKOBJECT();
	CString indicator = CString(COMMAND_STARTVARSTR) + VAR_RECOMMENDATIONS;
	bRet= Find( indicator );
	UNLOCKOBJECT();

	return( bRet );
}

#ifdef __DEBUG_CUSTOM
#include <io.h>
#include <fcntl.h>
#include <sys\\stat.h>
bool CAPGTSHTIReader::FlushOutputStreamToFile(const CString& file_name)
{
	int hf = 0;
	
	hf = _open(
		file_name,
		_O_CREAT | _O_TRUNC | /*_O_TEMPORARY |*/
		_O_BINARY | _O_RDWR | _O_SEQUENTIAL ,
		_S_IREAD | _S_IWRITE 
	);
			
	if (hf != -1)
	{
		//tstringstream m_StreamOutput
		basic_string<TCHAR> str = m_StreamOutput.rdbuf()->str();
		long size = str.size();
		LPCTSTR buf = str.c_str();

		int ret = _write(hf, buf, size);

		_close(hf);

		if (-1 != ret)
			return true;
	}

	return false;
}
#endif

// V3.2 - Enhancement to support cookies.
// This function handles the substituting of "<!Cookie" clauses with the either
// values from cookies, "_CK" values passed in via Get/Post, or the default value.
void CAPGTSHTIReader::SubstituteCookieValues( CString& strText )
{
	CString strNewText;
	const CString kstr_CommaChar= _T(",");
	const CString kstr_DoubleQuote= _T("\"");

	// Loop until we have processed all cookie clauses.
	int nNumericCompareStart= strText.Find( kstrCond_NumericCompare );	
	int nCookieClauseStart= strText.Find( COMMAND_COOKIE );
	while (CString::FIND_FAILED != nCookieClauseStart)
	{
		CString strCookieClause;
		CString strCookieName, strCookieAttr, strCookieValue;
		int nCookieClauseEnd, nScratchMarker;
		
		// Add any text preceding the cookie clause to the return string.
		strNewText+= strText.Left( nCookieClauseStart );

		// Remove all preceding text.
		strText= strText.Mid( nCookieClauseStart + _tcslen( COMMAND_COOKIE ) );
		
		// Look for the ending clause.
		nCookieClauseEnd= strText.Find( COMMAND_ENDSTR );
		if (CString::FIND_FAILED == nCookieClauseEnd)
		{
			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									COMMAND_ENDSTR, _T(""), 
									EV_GTS_COOKIE_COMPONENT_NOT_FOUND );		
			break;
		}

		// Pull out the current cookie clause and reset the working string.
		strCookieClause= strText.Left( nCookieClauseEnd );
		strText= strText.Mid( nCookieClauseEnd + 1 );

		// Extract the cookie name.
		nScratchMarker= strCookieClause.Find( kstr_CommaChar );
		if (CString::FIND_FAILED == nScratchMarker)
		{
			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									kstr_CommaChar, _T(""), 
									EV_GTS_COOKIE_COMPONENT_NOT_FOUND );		
			break;
		}
		strCookieName= strCookieClause.Left( nScratchMarker );
		strCookieName.TrimLeft();
		strCookieName.TrimRight();

		// Extract the cookie setting.
		strCookieClause= strCookieClause.Mid( nScratchMarker + 1 );
		nScratchMarker= strCookieClause.Find( kstr_CommaChar );
		if (CString::FIND_FAILED == nScratchMarker)
		{
			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									kstr_CommaChar, _T(""), 
									EV_GTS_COOKIE_COMPONENT_NOT_FOUND );		
			break;
		}
		strCookieAttr= strCookieClause.Left( nScratchMarker );
		strCookieAttr.TrimLeft();
		strCookieAttr.TrimRight();

		strCookieClause= strCookieClause.Mid( nScratchMarker + sizeof( TCHAR ) );

		// Attempt to locate the appropriate attribute/value pair, 
		// first checking the command line CK_ values, and
		// then checking the cookies passed in the HTTP header.
		bool bCookieNotFound= true;
		if (!m_mapCookies.empty())
		{
			// Search the command line CK_ values.
			map<CString,CString>::const_iterator iterMap= m_mapCookies.find( strCookieAttr );
			if (iterMap != m_mapCookies.end())
			{
				strCookieValue= iterMap->second;
				bCookieNotFound= false;
			}
		}
		if (bCookieNotFound)
		{
			if (!m_strHTTPcookies.IsEmpty())
			{
				// Attempt to locate the attribute in the HTTP header information.
				if (LocateCookieValue( strCookieName, strCookieAttr, strCookieValue ))
					bCookieNotFound= false;
			}
		}
		if (bCookieNotFound)
		{
			// Extract the default value for this attribute, which should be surrounded 
			//	by double quotes.
			nScratchMarker= strCookieClause.Find( kstr_DoubleQuote );
			if (CString::FIND_FAILED == nScratchMarker)
			{
				CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
				CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
										SrcLoc.GetSrcFileLineStr(), 
										kstr_DoubleQuote, _T(""), 
										EV_GTS_COOKIE_COMPONENT_NOT_FOUND );		
				break;
			}
			strCookieClause= strCookieClause.Mid( nScratchMarker + sizeof( TCHAR ) );
			nScratchMarker= strCookieClause.Find( kstr_DoubleQuote );
			if (CString::FIND_FAILED == nScratchMarker)
			{
				CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
				CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
										SrcLoc.GetSrcFileLineStr(), 
										kstr_DoubleQuote, _T(""), 
										EV_GTS_COOKIE_COMPONENT_NOT_FOUND );		
				break;
			}
			strCookieValue= strCookieClause.Left( nScratchMarker );
		}

		// Add the attribute value to the output string.  
		// >>> $MAINT - The determination of whether or not to output quotes should
		//				be improved.  I currently have no suggestions.  RAB-19990918.
		if ((nNumericCompareStart == CString::FIND_FAILED) || (nNumericCompareStart > nCookieClauseStart))
			strNewText+= _T("\"");
		strNewText+= strCookieValue;
		if ((nNumericCompareStart == CString::FIND_FAILED) || (nNumericCompareStart > nCookieClauseStart))
			strNewText+= _T("\"");

		// Look for another cookie clause.
		nNumericCompareStart= strText.Find( kstrCond_NumericCompare );
		nCookieClauseStart= strText.Find( COMMAND_COOKIE );
	}

	// Append any remaining text onto the end of the string.
	// If a cookie clause did not contain an ending marker it will be appended as well.
	strNewText+= strText;

	// Reassign the return string.
	strText= strNewText;

	return;
}


// V3.2 - Enhancement to support cookies.
// This function searches the HTTP cookies for a given cookie name and attribute.  If
// found, this function returns a value of true and the located cookie value.
bool CAPGTSHTIReader::LocateCookieValue(	const CString& strCookieName,
											const CString& strCookieAttr,
											CString& strCookieValue )
{
	bool	bCookieFound= false;
	CString strTmpCookieName= strCookieName + _T("=");
	int		nScratch;

	// URL encode the cookie name to handle underscores.
	APGTS_nmspace::CookieEncodeURL( strTmpCookieName );

	nScratch= m_strHTTPcookies.Find( strTmpCookieName );
	if (CString::FIND_FAILED != nScratch)
	{
		// Verify that we have not matched on a partial string for the cookie name.
		if ((nScratch == 0) || 
			(m_strHTTPcookies[ nScratch - 1 ] == _T(' ')) ||
			(m_strHTTPcookies[ nScratch - 1 ] == _T(';')))
		{
			// We have found the cookie that we are looking for, now look for the attribute name.
			CString strTmpCookieAttr= strCookieAttr + _T("=");
			
			// URL encode the cookie name to handle underscores.
			APGTS_nmspace::CookieEncodeURL( strTmpCookieAttr );

		
			// Jump past the starting point and the original cookie name length.
			CString strScratch = m_strHTTPcookies.Mid( nScratch + strCookieName.GetLength() );
			nScratch= strScratch.Find( _T(";") );
			if (CString::FIND_FAILED != nScratch)
			{
				// Truncate the string at the end of this particular cookie..
				if (nScratch > 0)
					strScratch= strScratch.Left( nScratch );
			}
			nScratch= strScratch.Find( strTmpCookieAttr );
			if (CString::FIND_FAILED != nScratch)  
			{
				if (nScratch > 0)
				{
					// Verify that we have not matched on a partial string for the cookie attribute.
					if ((strScratch[ nScratch - 1 ] == _T('=')) ||
						(strScratch[ nScratch - 1 ] == _T('&')))
					{
						strCookieValue= strScratch.Mid( nScratch + strTmpCookieAttr.GetLength() );
						
						// Look for and remove any delimiters.
						nScratch= strCookieValue.Find( _T("&") );
						if (CString::FIND_FAILED != nScratch)
						{	
							// Truncate the string.
							if (nScratch > 0)
								strCookieValue= strCookieValue.Left( nScratch );
						}
						nScratch= strCookieValue.Find( _T(";") );
						if (CString::FIND_FAILED != nScratch)
						{	
							// Truncate the string.
							if (nScratch > 0)
								strCookieValue= strCookieValue.Left( nScratch );
						}

						// Decode the cookie value.
						if (!strCookieValue.IsEmpty())
							APGTS_nmspace::CookieDecodeURL( strCookieValue );
						bCookieFound= true;
					}
				}
			}
		}
	}

	return( bCookieFound );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\apgtsctx.cpp ===
//
// MODULE: APGTSCTX.CPP
//
// PURPOSE: Implementation file for Thread Context
//	Fully implements class APGTSContext, which provides the full context for a "pool" thread
//	to perform a task
//	Also includes helper class CCommands.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Roman Mach, Joe Mabel
// 
// ORIGINAL DATE: 8-2-96
//
// NOTES: 
//	1. Several things in this file are marked as $ENGLISH.  That means we've hard-coded
//	English-language returns.  This may yet be revisited, but as of 10/29/98 discussion
//	between Ron Prior of Microsoft and Joe Mabel of Saltmine, we couldn't come up with a
//	better solution to this.  Notes are in the specification for the fall 1998 work on
//	the Online Troubleshooter.  
//	2. some of the methods of APGTSContext are implemented in file STATUSPAGES.CPP
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V3.0		7-22-98		JM		Major revision, deprecate IDH, totally new approach to logging.
//

#pragma warning(disable:4786)
#include "stdafx.h"
#include <time.h>
#include "event.h"
#include "apgts.h"
#include "apgtscls.h"
#include "apgtscfg.h"
#include "apgtsmfc.h"
#include "CounterMgr.h"
#include "CharConv.h"
#include "SafeTime.h"
#include "RegistryPasswords.h"
#ifdef LOCAL_TROUBLESHOOTER
#include "HTMLFragLocal.h"
#endif
#include "Sniff.h"


// HTTP header variable name where cookie information is stored.
#define kHTTP_COOKIE	"HTTP_COOKIE"

//
// CCommands ------------------------------------------------------
// The next several CCommands functions are analogous to MFC CArray
//
int APGTSContext::CCommands::GetSize( ) const
{
	return m_arrPair.size();
}

void APGTSContext::CCommands::RemoveAll( )
{
	m_arrPair.clear();
}

bool APGTSContext::CCommands::GetAt( int nIndex, NID &nid, int &value ) const
{
	if (nIndex<0 || nIndex>=m_arrPair.size())
		return false;
	nid = m_arrPair[nIndex].nid;
	value = m_arrPair[nIndex].value;
	return true;
}

int APGTSContext::CCommands::Add( NID nid, int value )
{
	NID_VALUE_PAIR pair;

	pair.nid = nid;
	pair.value = value;

	try
	{
		m_arrPair.push_back(pair);
	}
	catch (exception& x)
	{
		CString str;
		// Note STL exception in event log.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								CCharConversion::ConvertACharToString(x.what(), str), 
								_T(""), 
								EV_GTS_STL_EXCEPTION ); 
		return( -1 );
	}

	return m_arrPair.size();
}

//	a funky manipulation to deal with the following issue from old (pre V3.0) troubleshooters:
//	Pre V3.0 Logging sequence and the service node's behavior were both based on some assumptions
//	about the sequence of name/value pairs in the command list.  Basically, the
//	assumption was that the "table" would be on top of the form and the "questions"
//	below it.  This would result in ProblemAsk in first position (after any "template=
//	<template-name> and type=<troubleshooter-name>, but that's weeded out before we ever 
//	hit the command list).  If the HTI file has put	"the table" at the bottom, that assumption
//	is invalidated, so we have to manipulate the array.
//	Because we could get old GET-method queries, we still have to deal with this as a backward 
//	compatibility issue.
void APGTSContext::CCommands::RotateProblemPageToFront()
{
	int dwPairs = m_arrPair.size();

	// Rotate till ProblemAsk is in position 0. (no known scenario where it starts out
	//	anywhere past position 1)
	try
	{
		for (int i= 0; i<dwPairs; i++)
		{
			NID_VALUE_PAIR pair = m_arrPair.front(); // note: first element, not i-th element

			if (pair.nid == nidProblemPage)
				break;

			m_arrPair.erase(m_arrPair.begin());
			m_arrPair.push_back(pair);
		}
	}
	catch (exception& x)
	{
		CString str;
		// Note STL exception in event log.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								CCharConversion::ConvertACharToString(x.what(), str), 
								_T(""), 
								EV_GTS_STL_EXCEPTION ); 
	}
}
//
// CCommandsAddManager --------------------------------------------------
//
void APGTSContext::CCommandsAddManager::Add(NID nid, int value, bool sniffed)
{
	if (sniffed)
	{
		int nCommands = m_Commands.GetSize();
		for (int i = nCommands - 1; i >= 0; i--) // higher possibility, that matching
		{										 //  node will be in the end of array
			NID nid_curr;
			int value_curr;
			m_Commands.GetAt(i, nid_curr, value_curr);
			if (nid_curr == nid)
			{
				if (value_curr != value)
				{
					// If we're here, it means, that user has changed value
					//  of sniffed node in history table, therefore it is
					//  no longer treated as sniffed. 
					return;
				}
				else
				{
					m_Sniffed.Add(nid, value);
					return;
				}
			}
		}
		// sniffed node does not have matches in m_Commands
		ASSERT(false);
	}
	else
	{
		m_Commands.Add(nid, value);
	}
}
//
// CAdditionalInfo ------------------------------------------------------
// The next several CAdditionalInfo functions are analogous to MFC CArray
//
int APGTSContext::CAdditionalInfo::GetSize( ) const
{
	return m_arrPair.size();
}

void APGTSContext::CAdditionalInfo::RemoveAll( )
{
	m_arrPair.clear();
}

bool APGTSContext::CAdditionalInfo::GetAt( int nIndex, CString& name, CString& value ) const
{
	if (nIndex<0 || nIndex>=m_arrPair.size())
		return false;
	name = m_arrPair[nIndex].name;
	value = m_arrPair[nIndex].value;
	return true;
}

int APGTSContext::CAdditionalInfo::Add( const CString& name, const CString& value )
{
	NAME_VALUE_PAIR pair;

	pair.name = name;
	pair.value = value;

	try
	{
		m_arrPair.push_back(pair);
	}
	catch (exception& x)
	{
		CString str;
		// Note STL exception in event log.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								CCharConversion::ConvertACharToString(x.what(), str), 
								_T(""), 
								EV_GTS_STL_EXCEPTION ); 
		return( -1 );
	}

	return m_arrPair.size();
}


//-----------------
// INPUT *pECB		- Describes the user request that has come in.  This is our abstraction of
//						Win32 EXTENSION_CONTROL_BLOCK, which is ISAPI's packaging of CGI data.
// INPUT *pConf		- access to registry info & contents of all loaded troubleshooters
// INPUT *pLog		- access to logging
// INPUT *pStat		- statistical info, including pStat->dwRollover which is a unique number
//						for this request, unique within the time the DLL has been loaded
APGTSContext::APGTSContext(	CAbstractECB *pECB, 
							CDBLoadConfiguration *pConf,
							CHTMLLog *pLog,
							GTS_STATISTIC *pStat,
							CSniffConnector* pSniffConnector
							) :
	m_pECB(pECB),
	m_dwErr(0),
	m_strHeader(_T("Content-Type: text/html\r\n")),
	m_pConf(pConf),
	m_strVRoot(m_pConf->GetVrootPath()),
	m_pszQuery(NULL),
	m_pLog(pLog),
	m_bPostType(true),
	m_dwBytes(0),
	m_pStat(pStat),
	m_bPreload(false),
	m_bNewCookie(false),
	m_pcountUnknownTopics (&(g_ApgtsCounters.m_UnknownTopics)), 
	m_pcountAllAccessesFinish (&(g_ApgtsCounters.m_AllAccessesFinish)),
	m_pcountStatusAccesses (&(g_ApgtsCounters.m_StatusAccesses)),
	m_pcountOperatorActions (&(g_ApgtsCounters.m_OperatorActions)),
	m_TopicName(_T("")),
	m_infer(pSniffConnector),
	m_CommandsAddManager(m_Commands, m_Sniffed)
// You can compile with the SHOWPROGRESS option to get a report on the progress of this page.
#ifdef SHOWPROGRESS
	, timeCreateContext(0),
	timeStartInfer(0),
	timeEndInfer(0),
	timeEndRender(0)
#endif // SHOWPROGRESS
{
#ifdef SHOWPROGRESS
	time(&timeCreateContext);
#endif // SHOWPROGRESS
	// obtain local host IP address
	APGTS_nmspace::GetServerVariable(m_pECB, "SERVER_NAME", m_strLocalIPAddress);
		
	// HTTP response code.  This or 302 Object Moved.
	_tcscpy(m_resptype, _T("200 OK"));	// initially assume we will respond without trouble

	// supports GET, POST
	if (!strcmp(m_pECB->GetMethod(), "GET")) {
		m_bPostType = false;
		m_dwBytes = strlen(m_pECB->GetQueryString());
	}
	else 
		m_dwBytes = m_pECB->GetBytesAvailable();

	_tcscpy(m_ipstr,_T(""));

	DWORD bufsize = MAXBUF - 1;
	if (! m_pECB->GetServerVariable("REMOTE_ADDR", m_ipstr, &bufsize)) 
	 	_stprintf(m_ipstr,_T("IP?"));
	
	try
	{
		m_pszQuery = new TCHAR[m_dwBytes + 1];

		//[BC-03022001] - added check for NULL ptr to satisfy MS code analysis tool.
		if(!m_pszQuery)
			throw bad_alloc();
	}
	catch (bad_alloc&)
	{
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								_T(""), _T(""), EV_GTS_CANT_ALLOC ); 
		m_dwErr = EV_GTS_ERROR_NO_CHAR;
		return;
	}

	if (m_bPostType) 
		memcpy(m_pszQuery, m_pECB->GetData(), m_dwBytes);
	else 
		memcpy(m_pszQuery, m_pECB->GetQueryString(), m_dwBytes);

	m_pszQuery[m_dwBytes] = _T('\0');
	
}

//
// Even though this is a destructor, it does a lot of work:
//	- sends the HTTP (HTML or cookie)to the user over the net
//	- writes to the log.
APGTSContext::~APGTSContext()
{
	DWORD dwLen;
	TCHAR *ptr;

	// RESPONSE_HEADER
	m_strHeader += _T("\r\n");

	dwLen = m_strHeader.GetLength();
	ptr = m_strHeader.GetBuffer(0);

	m_pECB->ServerSupportFunction(	HSE_REQ_SEND_RESPONSE_HEADER,
									m_resptype,
									&dwLen,
									(LPDWORD) ptr );

	m_strHeader.ReleaseBuffer();

	// HTML content follows
	{
		DWORD dwLen= 0;

		if (! m_dwErr) 
			dwLen = m_strText.GetLength();
		
		if (!dwLen)
		{
			// $ENGLISH (see note at head of file)
			SetError(_T("<P>Errors Occurred in This Context"));
			dwLen = m_strText.GetLength();
		}
#ifdef SHOWPROGRESS
		CString strProgress;
		CSafeTime safetimeCreateContext(timeCreateContext);
		CSafeTime safetimeStartInfer(timeStartInfer);
		CSafeTime safetimeEndInfer(timeEndInfer);
		CSafeTime safetimeEndRender(timeEndRender);
			
		strProgress = _T("\nRequested ");
		strProgress += safetimeCreateContext.StrLocalTime();
		strProgress += _T("\n<BR>Start Infer ");
		strProgress += safetimeStartInfer.StrLocalTime();
		strProgress += _T("\n<BR>End Infer ");
		strProgress += safetimeEndInfer.StrLocalTime();
		strProgress += _T("\n<BR>End Render ");
		strProgress += safetimeEndRender.StrLocalTime();
		strProgress += _T("\n<BR>");

		int i = m_strText.Find(_T("<BODY"));
		i = m_strText.Find(_T('>'), i);		// end of BODY tag
		if (i>=0)
		{
			m_strText= m_strText.Left(i+1) 
					 + strProgress 
					 + m_strText.Mid(i+1);
		}
		dwLen += strProgress.GetLength();
#endif // SHOWPROGRESS

		// (LPCTSTR) cast gives us the underlying text bytes.
		//	>>> $UNICODE Actually, this would screw up under Unicode compile, because for HTML, 
		//	this must be SBCS.  Should really be a conversion to LPCSTR, which is non-trivial
		//	in a Unicode compile. JM 1/7/99
		m_pECB->WriteClient((LPCTSTR)m_strText, &dwLen);
	}

	// connection complete
	m_logstr.AddCurrentNode(m_infer.NIDSelected());

	if (m_dwErr)
		m_logstr.AddError(m_dwErr, 0);
	
	// finish up log
	{
		if (m_pLog) 
		{
			CString strLog (m_logstr.GetStr());

			m_dwErr = m_pLog->NewLog(strLog);
			if (m_dwErr) 
			{
				CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
				CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
										SrcLoc.GetSrcFileLineStr(), 
										_T(""),
										_T(""),
										m_dwErr ); 
			}		
		}
	}

	if (m_pszQuery)
		delete [] m_pszQuery;
}


//	Fully process a normal user request
//	Should be called within the user context created by ImpersonateLoggedOnUser
void APGTSContext::ProcessQuery()
{
	CheckAndLogCookie();

	if (m_dwErr) 
	{
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								_T("Remote IP Address:"),
								m_ipstr,
								m_dwErr ); 
	}
	else
	{
		DoContent();
// You can compile with the SHOWPROGRESS option to get a report on the progress of this page.
#ifdef SHOWPROGRESS
	time (&timeEndRender);
#endif // SHOWPROGRESS
	}

	// Log the completion of all queries, good and bad.
	m_pcountAllAccessesFinish->Increment();
}

//
//
void APGTSContext::DoContent()
{	
	TCHAR pszCmd[MAXBUF], pszValue[MAXBUF];
	
	if (m_bPostType)
	{
		// validate incoming POST request
		if (strcmp(m_pECB->GetContentType(), CONT_TYPE_STR) != 0) 
		{
			// Output the content type to the event log.
			CString strContentType;
			if (strlen( m_pECB->GetContentType() ))
				strContentType= m_pECB->GetContentType();
			else
				strContentType= _T("not specified");

			m_strText += _T("<P>Bad Data Received\n");
			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									m_ipstr,
									strContentType,
									EV_GTS_USER_BAD_DATA ); 
			return;
		}
	}

	if (RUNNING_ONLINE_TS())
	{
		// Cookies are only used in the Online TS.
		if (_tcsstr( m_pszQuery, C_COOKIETAG ) != NULL)
		{
			// V3.2 - Parse out cookies passed in either as hidden fields or as part of the URL.
			if (m_Qry.GetFirst(m_pszQuery, pszCmd, pszValue))
			{
				CString strCookieFreeQuery;
				bool	bFoundAtLeastOneCookie= false;
				do
				{
					// This is supposed to be a case sensitive setting as per the specification.
					if (!_tcsncmp( pszCmd, C_COOKIETAG, _tcslen( C_COOKIETAG )))
					{
						// Found a cookie, add it to the map.
						CString strCookieAttr= pszCmd + _tcslen( C_COOKIETAG );
						APGTS_nmspace::CookieDecodeURL( strCookieAttr );
						CString strCookieValue= pszValue;
						APGTS_nmspace::CookieDecodeURL( strCookieValue );

						// Check the cookie name for compliance.
						bool bCookieIsCompliant= true;
						for (int nPos= 0; nPos < strCookieAttr.GetLength(); nPos++)
						{
							TCHAR tcTmp= strCookieAttr.GetAt( nPos );
							if ((!_istalnum( tcTmp )) && (tcTmp != _T('_')))
							{
								bCookieIsCompliant= false;
								break;
							}
						}
						if (bCookieIsCompliant)
						{
							// Check the cookie setting for compliance.
							if (strCookieValue.Find( _T("&lt") ) != -1)
							{
								bCookieIsCompliant= false;
							}
							else if (strCookieValue.Find( _T("&gt") ) != -1)
							{
								bCookieIsCompliant= false;
							}
#if ( 0 )
							// >>> I don't think that this check is necessary. RAB-20000408.
							else
							{
								for (int nPos= 0; nPos < strCookieValue.GetLength(); nPos++)
								{
									TCHAR tcTmp= strCookieValue.GetAt( nPos );
									if ((tcTmp == _T('<')) || (tcTmp == _T('>')))
									{
										bCookieIsCompliant= false;
										break;
									}
								}
							}
#endif
						}

						if (bCookieIsCompliant)
						{
							try
							{
								m_mapCookiesPairs[ strCookieAttr ]= strCookieValue;
							}
							catch (exception& x)
							{
								CString str;
								// Note STL exception in event log.
								CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
								CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
														SrcLoc.GetSrcFileLineStr(), 
														CCharConversion::ConvertACharToString(x.what(), str), 
														_T(""), 
														EV_GTS_STL_EXCEPTION ); 
							}
						}
						bFoundAtLeastOneCookie= true;
					}
					else
					{
						// Not a cookie, add it to the cookie free query.
						if (strCookieFreeQuery.GetLength())
							strCookieFreeQuery+= C_AMPERSAND;
						strCookieFreeQuery+= pszCmd;
						strCookieFreeQuery+= C_EQUALSIGN;
						strCookieFreeQuery+= pszValue;
					}
				}
				while (m_Qry.GetNext( pszCmd, pszValue )) ;

				if (bFoundAtLeastOneCookie)
				{
					// Replace the original query string with a cookie free query.
					memcpy( m_pszQuery, strCookieFreeQuery, strCookieFreeQuery.GetLength() );
					m_pszQuery[ strCookieFreeQuery.GetLength() ] = _T('\0');
				}
			}
		}
	}

	// >>> The following code is commented by me as it is raw, and it will not work since
	//  topic pointer in m_infer is not set yet. Now we are taking SNIFFED_ nodes down
	//  to the level of APGTSContext::NextCommand, and parsing it there by 
	//  APGTSContext::StripSniffedNodePrefix, and adding to sniffed array using
	//  functionality of APGTSContext::CCommandsAddManager class.
	// Oleg. 10.29.99
	/*
	// In v3.2, sniffing is only in the Local TS. There's nothing inherent about that,
	// but as long as it's so, might as well optimize for it.
	if (RUNNING_LOCAL_TS())
	{
		ClearSniffedList();
		if (_tcsstr( m_pszQuery, C_SNIFFTAG ) != NULL)
		{
			// V3.2 - Parse out sniffed nodes passed in as hidden fields
			if (m_Qry.GetFirst(m_pszQuery, pszCmd, pszValue))
			{
				CString strSniffFreeQuery;
				bool	bFoundAtLeastOneSniff= false;
				do
				{
					// This is supposed to be a case sensitive setting as per the specification.
					if (!_tcsncmp( pszCmd, C_SNIFFTAG, _tcslen( C_SNIFFTAG )))
					{
						// Found a sniffed node, add it to the list of sniffed nodes.
						CString strSniffedNode= pszCmd + _tcslen( C_SNIFFTAG );
						// >>> I believe that despite its name, CookieDecodeURL is
						//	exactly what we want - JM 10/11/99
						APGTS_nmspace::CookieDecodeURL( strSniffedNode );
						CString strSniffedState= pszValue;
						APGTS_nmspace::CookieDecodeURL( strSniffedState );

						NID nid= NIDFromSymbolicName(strSniffedNode);
						int ist = _ttoi(strSniffedState);

						if (ist != -1)
							PlaceNodeInSniffedList(nid, ist);

						bFoundAtLeastOneSniff= true;
					}
					else
					{
						// Not a Sniffed node, add it to the sniff-free query.
						if (strSniffFreeQuery.GetLength())
							strSniffFreeQuery+= C_AMPERSAND;
						strSniffFreeQuery+= pszCmd;
						strSniffFreeQuery+= C_EQUALSIGN;
						strSniffFreeQuery+= pszValue;
					}
				}
				while (m_Qry.GetNext( pszCmd, pszValue )) ;

				if (bFoundAtLeastOneSniff)
				{
					// Replace the original query string with a cookie free query.
					memcpy( m_pszQuery, strSniffFreeQuery, strSniffFreeQuery.GetLength() );
					m_pszQuery[ strSniffFreeQuery.GetLength() ] = _T('\0');
				}
			}
		}
	}
	*/
	eOpAction OpAction = IdentifyOperatorAction(m_pECB);
	if (OpAction != eNoOpAction)
	{
		if (m_bPostType == true)
		{
			// Note: Hard-coded text that should be replaced.
			m_strText += _T("<P>Post method not permitted for operator actions\n");
		}
		else
		{
			// Increment the number of operator action requests.
			m_pcountOperatorActions->Increment();

			CString strArg;
			OpAction = ParseOperatorAction(m_pECB, strArg);
			if (OpAction != eNoOpAction)
				ExecuteOperatorAction(m_pECB, OpAction, strArg);
		}
	}
	else if (m_Qry.GetFirst(m_pszQuery, pszCmd, pszValue))
	{
		DWORD dwStat = ProcessCommands(pszCmd, pszValue);

		if (dwStat != 0) 
		{
			if (dwStat == EV_GTS_INF_FIRSTACC ||
				dwStat == EV_GTS_INF_FURTHER_GLOBALACC ||
				dwStat == EV_GTS_INF_THREAD_OVERVIEWACC ||
				dwStat == EV_GTS_INF_TOPIC_STATUSACC)
			{
				// Don't want to show contents of query, because it would put the actual 
				//	password in the file.
				CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
				CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
										SrcLoc.GetSrcFileLineStr(), 
										_T(""),
										_T(""),
										dwStat ); 
			}
			else
			{
				m_dwErr = dwStat;

				if (m_dwBytes > 78) 
				{
					// It's longer than we want to stick in the event log.
					// Cut it off with an ellipsis at byte 75, then null terminate it.
					m_pszQuery[75] = _T('.');
					m_pszQuery[76] = _T('.');
					m_pszQuery[77] = _T('.');
					m_pszQuery[78] = _T('\0');
				}

				CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
				CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
										SrcLoc.GetSrcFileLineStr(), 
										m_pszQuery,
										_T(""),
										dwStat ); 
			}
		}
	}
	else {
		m_strText += _T("<P>No Input Parameters Specified\n");
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								m_ipstr,
								_T(""),
								EV_GTS_USER_NO_STRING ); 

	}
}

//
// Read a cookie (or write one, if there isn't one already)
void APGTSContext::CheckAndLogCookie()
{
	// Suppressed this in Local TS, becuase it isn't using any cookies.
	if (RUNNING_LOCAL_TS())
		return;
	
	CString		str;	// scratch only
	char		szCookieNameValue[256];		// never Unicode, because cookies always ASCII
	char		*pszValue= NULL;			// never Unicode, because cookies always ASCII
	DWORD		dwCookieLen = 255; 
	
	if ( m_pECB->GetServerVariable(	kHTTP_COOKIE,
									szCookieNameValue,
									&dwCookieLen)) 
	{
		// Got a Cookie. Parse it
		pszValue = GetCookieValue("GTS-COOKIE", szCookieNameValue);
	}

	if( !pszValue )
	{
		// Build a funky string for the cookie value.  We want uniqueness for logging purposes.
		// Make a local copy of remote IP address, then massage its dots into letters, each 
		//	dependent on 4 bits of dwTempRO
		// While not strictly unique, there are 12 bits worth of "uniqueness" here.  However,
		//	every time the DLL is restarted, we go back to zero.  Also, all servers start at zero.
		// Later we form the cookie value by appending time to this, so it should be "pretty unique"
		DWORD		dwTempRO = m_pStat->dwRollover; // this value is unique to this user request
		TCHAR		*pch;
		TCHAR		szTemp[50];
		_tcscpy(szTemp, m_ipstr);
		while ((pch = _tcschr(szTemp, _T('.'))) != NULL) 
		{
			*pch = (TCHAR)(dwTempRO & 0x0F) + _T('A');
			dwTempRO >>= 4;
		}

		// Create a cookie
		time_t		timeNow;					// current time
		time_t		timeExpire;					// when we set the cookie to expire
		time(&timeNow);
		timeExpire = timeNow + (m_pConf->GetCookieLife() * 60 /* secs in a minute */);

		// char, not TCHAR: cookie is always ASCII.
		char szExpire[30];

		{
			CSafeTime safetimeExpire (timeExpire);
			asctimeCookie(safetimeExpire.GMTime(), szExpire);
		}

		// char, not TCHAR: cookie is always ASCII.
		char szNewCookie[256];
		char szHeader[256];

		sprintf(szNewCookie, "%s%ld, ", szTemp, timeNow); 
		sprintf(szHeader, "Set-Cookie: GTS-COOKIE=%s; expires=%s; \r\n",
						   szNewCookie, szExpire);

		CCharConversion::ConvertACharToString(szHeader, str);
		m_strHeader += str;

		pszValue = szNewCookie;
		m_bNewCookie = true;
	}

	m_logstr.AddCookie(CCharConversion::ConvertACharToString(pszValue, str));
}

//
// This takes the string returned by getting the cookie environment 
// variable and a specific cookie name and returns a the value
// of that cookie (if it exists). There could potentially be
// more than one cookie in the cookie string
//
// Cookies contain one or more semicolon-separated name/value pair:
//	name1=value1;name2=value2;   (etc.)
//
// INPUT *pszName		name we're seeking
// INPUT *pszCookie		the whole cookie string
// OUTPUT *pszCookie	this string has been written to & should not be relied on
// RETURN	value corresponding to *pszName (physically points into *pszCookie string)
//		Returns NULL if not found
char *APGTSContext::GetCookieValue(char *pszName, char *pszCookie)
{
	char *sptr, *eptr;

	sptr = pszCookie;
	while (sptr != NULL) {
		if ((eptr = strstr(sptr,"=")) == NULL)
			return(NULL);

		// replace the '=' with NULL
		*eptr = _T('\0');
		if (!strncmp(sptr,pszName,strlen(pszName)) ){
			// get the value
			sptr = eptr + 1;
			if ((eptr = strstr(sptr,";")) != NULL){
				*eptr = _T('\0');
				return(sptr);
			} else {
				// this is the last variable
				return(sptr);
			}
		}
		if ((eptr = strstr(sptr,";")) != NULL)
			sptr = eptr +1;
		else
			sptr = NULL;
	}
	return(NULL);
}

// INPUT gmt
// INPUT szOut must point to a buffer of at least 29 characters to hold 28 character
//	text plus terminating null.
// OUTPUT szOut: a pointer to a string containing a text version of date/time info.
//	Typical form would be "Sun, 3-Jan-1998 12:03:08 GMT"  There is no choice about
//	this form.  It should always be exactly 28 characters.
// Regardless of whether the program is compiled for Unicode, this must always be ASCII:
//	HTTP cookies are ASCII.
void APGTSContext::asctimeCookie(const struct tm &gmt, char * szOut)
{
	char temp[20];

	switch (gmt.tm_wday) {
		case 0: strcpy(szOut, "Sun, "); break;
		case 1: strcpy(szOut, "Mon, "); break;
		case 2: strcpy(szOut, "Tue, "); break;
		case 3: strcpy(szOut, "Wed, "); break;
		case 4: strcpy(szOut, "Thu, "); break;
		case 5: strcpy(szOut, "Fri, "); break;
		case 6: strcpy(szOut, "Sat, "); break;
		default: return;
	}

	sprintf(temp, "%02d-", gmt.tm_mday);
	strcat(szOut, temp);

	switch (gmt.tm_mon) {
		case 0: strcat(szOut, "Jan-"); break;
		case 1: strcat(szOut, "Feb-"); break;
		case 2: strcat(szOut, "Mar-"); break;
		case 3: strcat(szOut, "Apr-"); break;
		case 4: strcat(szOut, "May-"); break;
		case 5: strcat(szOut, "Jun-"); break;
		case 6: strcat(szOut, "Jul-"); break;
		case 7: strcat(szOut, "Aug-"); break;
		case 8: strcat(szOut, "Sep-"); break;
		case 9: strcat(szOut, "Oct-"); break;
		case 10: strcat(szOut, "Nov-"); break;
		case 11: strcat(szOut, "Dec-"); break;
		default: return;
	}

	sprintf(temp, "%04d ", gmt.tm_year +1900);
	strcat(szOut, temp);

	sprintf(temp, "%d:%02d:%02d GMT", gmt.tm_hour, gmt.tm_min, gmt.tm_sec);
	strcat(szOut, temp);
}

//
// Assumes m_Qry.GetFirst has already been called.
// INPUT pszCmd & pszValue are the outputs of m_Qry.GetFirst.
DWORD APGTSContext::ProcessCommands(LPTSTR pszCmd, 
									LPTSTR pszValue) 
{
	bool bTryStatus = false;	// true = try to parse as an operator status request.
	CString str;				// strictly scratch
	DWORD dwStat = 0;

	// Check first if this is a HTI independent of DSC request.
	if (!_tcsicmp( pszCmd, C_TEMPLATE))
	{
		CString strBaseName, strHTItemplate;
		bool	bValid;
	
		// Force the HTI file to be in the resource directory and have a HTI extension.
		strBaseName= CAbstractFileReader::GetJustNameWithoutExtension( pszValue );

		// Check for the case where the filename passed in was just a name.
		// This is a workaround for what is a questionable implementation of 
		// GetJustNameWithoutExtension() i.e. returning an empty string when no
		// forward slashes or backslashes or dots are detected.  RAB-981215.
		if ((strBaseName.IsEmpty()) && (_tcslen( pszValue )))
		{
			// Set the base name from the passed in string.
			strBaseName= pszValue;
			strBaseName.TrimLeft();
			strBaseName.TrimRight();
		}

		if (!strBaseName.IsEmpty())
		{
			strHTItemplate= m_pConf->GetFullResource();
			strHTItemplate+= strBaseName;
			strHTItemplate+= _T(".hti");
		}

		// Check if HTI file already exists in the map of alternate HTI templates.
		if (m_pConf->RetTemplateInCatalogStatus( strHTItemplate, bValid ))
		{
			// Template has been loaded, check if it is valid.
			if (!bValid)
				strHTItemplate= _T("");
		}
		else
		{
			CP_TEMPLATE cpTemplate;
			// Add the HTI file to the list of active alternate templates and then attempt to 
			// load the template.
			m_pConf->AddTemplate( strHTItemplate );
			m_pConf->GetTemplate( strHTItemplate, cpTemplate, m_bNewCookie);

			// If the load failed then set the alternate name to blank so that the default
			// template is used instead.
			if (cpTemplate.IsNull())
				strHTItemplate= _T("");
		}
		

		// If we have a valid HTI file, set the alternate HTI template.
		if (!strHTItemplate.IsEmpty())
			SetAltHTIname( strHTItemplate );

		// Attempt to acquire the next step of name-value pairs.
		m_Qry.GetNext( pszCmd, pszValue );
	}

	if (!_tcsicmp(pszCmd, C_TOPIC_AND_PROBLEM))
	{
		// Code in this area uses ++ and -- on TCHAR* pointers, rather than using _tcsinc()
		//	and _tcsdec.  This is OK because we never use non-ASCII in the query string.

		// value attached to first command is commma-separated topic & problem
		TCHAR * pchComma= _tcsstr(pszValue, _T(","));
		if (pchComma)
		{
			// commma found
			*pchComma = 0;	// replace it with a null
			TCHAR * pchProblem = pchComma;
			++pchProblem;	// to first character past the comma

			// strip any blanks or other junk after the comma
			while (*pchProblem > _T('\0') && *pchProblem <= _T(' '))
				++pchProblem;

			--pchComma;	// make pchComma point to last character before the comma
			// strip any blanks or other junk before the comma
			while (pchComma > pszValue && *pchComma > _T('\0') && *pchComma<= _T(' '))
				*(pchComma--) = 0;

			// Now push the problem back onto the query string to be found by a later GetNext()
			CString strProbPair(_T("ProblemAsk="));
			strProbPair += pchProblem;

			m_Qry.Push(strProbPair);
		}
		// else treat this as just a topic

		_tcscpy(pszCmd, C_TOPIC);
	}

	// first command should be troubleshooter type (symbolic name)
	// C_PRELOAD here means we've already done some "sniffing"
	// All of these commands take type symbolic belief-network name as their value
	//	C_TYPE & C_PRELOAD use (deprecated) IDHs
	//	C_TOPIC uses NIDs
	if (!_tcsicmp(pszCmd, C_TYPE) || !_tcsicmp(pszCmd, C_PRELOAD)
	||  !_tcsicmp(pszCmd, C_TOPIC) )
	{
		bool bUsesIDH = _tcsicmp(pszCmd, C_TOPIC)? true:false;  // True if NOT "topic".  
											//	The (deprecated) others use IDH.

		CString strTopicName = pszValue;
		strTopicName.MakeLower();

		m_TopicName= pszValue; // let outer world know what topic we are working on

		// We use a reference-counting smart pointer to hold onto the CTopic.  As long as
		//	cpTopic remains in scope, the relevant CTopic is guaranteed to remain in 
		//	existence.
		CP_TOPIC cpTopic;
		m_pConf->GetTopic(strTopicName, cpTopic, m_bNewCookie);
		CTopic * pTopic = cpTopic.DumbPointer();
		if (pTopic) 
		{
			m_logstr.AddTopic(strTopicName);
// You can compile with the SHOWPROGRESS option to get a report on the progress of this page.
#ifdef SHOWPROGRESS
			time (&timeStartInfer);
#endif // SHOWPROGRESS
			dwStat = DoInference(pszCmd, pszValue, pTopic, bUsesIDH);
#ifdef SHOWPROGRESS
			time (&timeEndInfer);
#endif // SHOWPROGRESS
		}
		else 
		{
			dwStat = EV_GTS_ERROR_INF_BADTYPECMD;

			// $ENGLISH (see note at head of file)
			str = _T("<P>Unexpected troubleshooter topic:");
			str += strTopicName;
			SetError(str);

			m_logstr.AddTopic(_T("*UNKNOWN*"));
			m_pcountUnknownTopics->Increment();
		}
	}
	//
	//
	// Now we are going to deal with status pages.
	//  But those pages require knowing of the IP address of the local machine.
	//  If m_strLocalIPAddress.GetLength() == 0, we were not able to identify 
	//  the IP address and have to display an error message.
	else if (0 == m_strLocalIPAddress.GetLength())
	{
			dwStat = EV_GTS_ERROR_IP_GET;

			// $ENGLISH (see note at head of file)
			SetError(_T("<P>Status request must explicitly give IP address of the server."));
	}
#ifndef LOCAL_TROUBLESHOOTER
	else if (!_tcsicmp(pszCmd, C_FIRST)) 
	{
		DisplayFirstPage(false);
		dwStat = EV_GTS_INF_FIRSTACC;
		m_pcountStatusAccesses->Increment();
	}
#endif

// You can compile with the NOPWD option to suppress all password checking.
// This is intended mainly for creating test versions with this feature suppressed.
#ifdef NOPWD
	else 
		bTryStatus = true;
#else 
	else if (!_tcsicmp(pszCmd, C_PWD)) 
	{
		CString strPwd;
		CCharConversion::ConvertACharToString( pszValue, strPwd );

		CRegistryPasswords pwd;
		if (pwd.KeyValidate( _T("StatusAccess"), strPwd) )
		{
			time_t timeNow;
			time(&timeNow);

			// Generate a temporary password
			m_strTempPwd = CCharConversion::ConvertACharToString(m_ipstr, str);
			str.Format(_T("%d"), timeNow);
			m_strTempPwd += str;

			m_pConf->GetRecentPasswords().Add(m_strTempPwd);

			// Attempt to acquire the next step of name-value pairs.
			m_Qry.GetNext( pszCmd, pszValue );
			bTryStatus = true;
		}
		else if (m_pConf->GetRecentPasswords().Validate(strPwd) )
		{
			m_strTempPwd = strPwd;

			// Attempt to acquire the next step of name-value pairs.
			m_Qry.GetNext( pszCmd, pszValue );
			bTryStatus = true;
		}
	}
#endif // ifndef NOPWD
	else {
		dwStat = EV_GTS_ERROR_INF_BADCMD;

		// $ENGLISH (see note at head of file)
		str = _T("<P>Unexpected command: ");
		str += pszCmd;
		SetError(str);
	}

#ifndef LOCAL_TROUBLESHOOTER
	if (bTryStatus)
	{
		if (!_tcsicmp(pszCmd, C_FIRST)) 
		{
			DisplayFirstPage(true);
			dwStat = EV_GTS_INF_FIRSTACC;
			m_pcountStatusAccesses->Increment();
		}
		else if (!_tcsicmp(pszCmd, C_FURTHER_GLOBAL)) 
		{
			DisplayFurtherGlobalStatusPage();
			dwStat = EV_GTS_INF_FURTHER_GLOBALACC;
			m_pcountStatusAccesses->Increment();
		}
		else if (!_tcsicmp(pszCmd, C_THREAD_OVERVIEW)) 
		{
			DisplayThreadStatusOverviewPage();
			dwStat = EV_GTS_INF_THREAD_OVERVIEWACC;
			m_pcountStatusAccesses->Increment();
		}
		else if (!_tcsicmp(pszCmd, C_TOPIC_STATUS)) 
		{
			DisplayTopicStatusPage(pszValue);
			dwStat = EV_GTS_INF_TOPIC_STATUSACC;
			m_pcountStatusAccesses->Increment();
		}
		else {
			dwStat = EV_GTS_ERROR_INF_BADCMD;

			// $ENGLISH (see note at head of file)
			str = _T("<P>Unexpected command: ");
			str += pszCmd;
			SetError(str);
		}
	}
#endif
	return (dwStat);
}

BOOL APGTSContext::StrIsDigit(LPCTSTR pSz)
{
	BOOL bRet = TRUE;
	while (*pSz)
	{
		if (!_istdigit(*pSz))
		{
			bRet = FALSE;
			break;
		}
		pSz = _tcsinc(pSz);
	}
	return bRet;
}

// INPUT szNodeName - symbolic name of node.
// RETURNS symbolic node number.  
//	On unrecognized symbolic name, returns nidNil
NID APGTSContext::NIDFromSymbolicName(LPCTSTR szNodeName)
{
	// first handle all the special cases
	if (0 == _tcsicmp(szNodeName, NODE_PROBLEM_ASK))
		return nidProblemPage;

	if (0 == _tcsicmp(szNodeName, NODE_SERVICE))
		return nidService;

	if (0 == _tcsicmp(szNodeName, NODE_FAIL))
		return nidFailNode;

	if (0 == _tcsicmp(szNodeName, NODE_FAILALLCAUSESNORMAL))
		return nidSniffedAllCausesNormalNode;

	if (0 == _tcsicmp(szNodeName, NODE_IMPOSSIBLE))
		return nidImpossibleNode;

	if (0 == _tcsicmp(szNodeName, NODE_BYE))
		return nidByeNode;

	// normal symbolic name
	NID nid = m_infer.INode(szNodeName);
	if (nid == -1)
		return nidNil;
	else
		return nid;
	
}


// Validate and convert a list of nodes and their associated states.
//
// INPUT pszCmd & pszValue are the outputs of m_Qry.GetNext.
// INPUT index into the HTTP query parameters.  Parameters may follow any of the following
//		PATTERNS.  
// INPUT dwCount is the number shown at left in each of these patterns.  Remember that this 
//		function never sees dwCount=1; that's been used to set m_bPreload:
// INPUT bUsesIDH - Interpret numerics as IDHs (a deprecated feature) rather than NIDs
// DEPRECATED BUT SUPPORTED PATTERNS when bUsesIDH == true
//	"Preload"
//	PROBABLY NOT EFFECTIVE BACKWARD COMPATIBLITY
//	because if they've added any nodes,  # of nodes in network will have changed)
//		1 -		preload=<troubleshooter symbolic name>
//		2 -		<# of nodes in network + 1000>=<problem node number + 1000>
//		3+ -	<node symbolic name>=<node state value>
//	Old "type" (we never generate these, but we have them here for backward compatibility.
//	PROBABLY NOT EFFECTIVE BACKWARD COMPATIBLITY
//	because if they've added any nodes,  # of nodes in network will have changed)
//		1 -		type=<troubleshooter symbolic name>
//		2 -		<# of nodes in network + 1000>=<problem node number + 1000>
//		3+ -	<node # + 1000>=<node state value>
//	Newer "type", should be fully backward compatible.
//		1 -		type=<troubleshooter symbolic name>
//		2 -		ProblemAsk=<problem node symbolic name>
//		3+ -	<node symbolic name>=<node state value>
//	It is presumably OK for us to allow a slight superset of the known formats, which yields:
//		1 -		preload=<troubleshooter symbolic name> OR
//				type=<troubleshooter symbolic name>
//					Determines m_bPreload before this fn is called
//		2 -		<# of nodes in network + 1000>=<problem node number + 1000> OR
//				ProblemAsk=<problem node symbolic name>
//					We can distinguish between these by whether pszCmd is numeric
//		3+ -	<node # + 1000>=<node state value> OR
//				<node symbolic name>=<node state value>
//					We can distinguish between these by whether pszCmd is numeric
//	The only assumption in this overloading is that a symbolic name will never be entirely
//	numeric.
// SUPPORTED PATTERN when bUsesIDH == false
//		1 -		topic=<troubleshooter symbolic name> 
//		2 -		ProblemAsk=<problem node symbolic name>
//		3+ -	<node symbolic name>=<node state value>
// 
// LIMITATION ON STATE NUMBERS
//	As of 11/97, <node state value> must always be one of:
//		0 - Fixed/Unfixed: Haven't solved problem 
//			Info: First option
//		1 - Info: Second option
//		101	- Go to "Bye" Page (User succeeded - applies to Fixed/Unfixed or Support Nodes only)
//		102	- Unknown (user doesn't know the correct answer here - applies to Fixed/Unfixed and 
//		  Info nodes only)
//		103	- "Anything Else I Can Try"
//  Since inputs of state values should always come from forms we generated, we don't 
//	 systematically limit state numbers in the code here.
//	V3.0 allows other numeric states: 0-99 should all be legal.
//
//	RETURN 0 on success, otherwise an error code
DWORD APGTSContext::NextCommand(LPTSTR pszCmd, LPTSTR pszValue, bool bUsesIDH)
{
	NID nid;
	int value = 0;			// if pszValue is numeric, a NID or state.
							// otherwise, pszValue is the symbolic name of a node,
							//	and this is its NID
	bool sniffed = false;

	if (StrIsDigit(pszCmd)) 
	{
		// only should arise for bUsesIDH

		// it's an IDH (typically node # + 1000), but can be <# of nodes in network> + 1000,
		//	interpreted as "ProblemAsk"
		// The pages we generate never give us these values, but we recognize them.
		IDH idh = _ttoi(pszCmd);
		nid = m_infer.NIDFromIDH(idh);
	}
	else
	{	
		// The command is a symbolic name.
		sniffed = StripSniffedNodePrefix(pszCmd);
		nid= NIDFromSymbolicName(pszCmd);
	}

	if (StrIsDigit(pszValue))
	{
		if (bUsesIDH)
		{
			int valueIDH = _ttoi(pszValue);
			if (nid == nidProblemPage)
				// problem node number + 1000
				value = m_infer.NIDFromIDH(valueIDH);
			else 
				// state value
				value = valueIDH;
		}
		else
		{
			// value is a state number.
			value = _ttoi(pszValue);
		}
	}
	else if (nid == nidProblemPage) 
	{
		// Symbolic name of problem node
		value = NIDFromSymbolicName(pszValue);
	}
    else
		return EV_GTS_ERROR_INF_BADPARAM;

	m_CommandsAddManager.Add(nid, value, sniffed);

	return 0;
}

DWORD APGTSContext::NextAdditionalInfo(LPTSTR pszCmd, LPTSTR pszValue)
{
	if (RUNNING_LOCAL_TS())
	{
		if ( 0 == _tcscmp(pszCmd, C_ALLOW_AUTOMATIC_SNIFFING_NAME) &&
			(0 == _tcsicmp(pszValue, C_ALLOW_AUTOMATIC_SNIFFING_CHECKED) || 
			 0 == _tcsicmp(pszValue, C_ALLOW_AUTOMATIC_SNIFFING_UNCHECKED)))
		{
			m_AdditionalInfo.Add(pszCmd, pszValue);
			return 0;
		}
		if (0 == _tcscmp(pszCmd, C_LAST_SNIFFED_MANUALLY))
		{
			if (0 == _tcscmp(pszValue, SZ_ST_SNIFFED_MANUALLY_TRUE))
				m_infer.SetLastSniffedManually(true);
			return 0;
		}
	}
	return EV_GTS_ERROR_INF_BADPARAM;
}

// Name - value pairs that we can ignore
DWORD APGTSContext::NextIgnore(LPTSTR pszCmd, LPTSTR pszValue)
{
	if (RUNNING_LOCAL_TS())
	{
		// Value "-1" can come from a field, used for manual sniffing,
		//  when other then "Sniff" button is pressed
		
		CString strValue(pszValue);
		CString strSniffFailure;

		strValue.TrimLeft();
		strValue.TrimRight();
		strSniffFailure.Format(_T("%d"), SNIFF_FAILURE_RESULT);
		if (strValue == strSniffFailure)
		{
			// Name in this case should be a valid node name
			
			NID nid = nidNil;

			StripSniffedNodePrefix(pszCmd);
			nid = NIDFromSymbolicName(pszCmd);
			if (nid != nidNil)
				return 0;
		}
	}
	return EV_GTS_ERROR_INF_BADPARAM;
}

VOID APGTSContext::ClearCommandList()
{
	m_Commands.RemoveAll();
}

VOID APGTSContext::ClearSniffedList()
{
	m_Sniffed.RemoveAll();
}

VOID APGTSContext::ClearAdditionalInfoList()
{
	m_AdditionalInfo.RemoveAll();
}
/*
// Return false on failure; shouldn't ever arise.
bool APGTSContext::PlaceNodeInCommandList(NID nid, IST ist)
{
	return (m_Commands.Add(nid, ist) > 0);
}
*/
/*
// Return false on failure; shouldn't ever arise.
bool APGTSContext::PlaceNodeInSniffedList(NID nid, IST ist)
{
	return (m_Sniffed.Add(nid, ist) > 0);
}
*/
/*
// Return false on failure; shouldn't ever arise.
bool APGTSContext::PlaceInAdditionalInfoList(const CString& name, const CString& value)
{
	return (m_AdditionalInfo.Add(name, value) > 0);
}
*/
// INPUT: node short name, possibly prefixed by SNIFFED_
// OUTPUT: node short name
// RETURN: true is prefix was stripped
bool APGTSContext::StripSniffedNodePrefix(LPTSTR szName)
{
	if (0 == _tcsnicmp(szName, C_SNIFFTAG, _tcslen(C_SNIFFTAG)))
	{
		// use "memmove" since we are operating with overlapped regions!
		memmove(szName, 
			    szName + _tcslen(C_SNIFFTAG), 
				_tcslen(szName + _tcslen(C_SNIFFTAG)) + 1);
		return true;
	}
	return false;
}

VOID APGTSContext::SetNodesPerCommandList()
{
	int nCommands = m_Commands.GetSize();
	for (int i= 0; i<nCommands; i++)
	{
		NID nid;
		int value;	// typically a state (IST), except if nid==nidProblemPage, where value is a NID
		m_Commands.GetAt( i, nid, value );
		m_infer.SetNodeState(nid, value);
	}
}

VOID APGTSContext::SetNodesPerSniffedList()
{
	int nSniffed = m_Sniffed.GetSize();
	for (int i= 0; i<nSniffed; i++)
	{
		NID nid;
		int ist;
		m_Sniffed.GetAt( i, nid, ist );
		m_infer.AddToSniffed(nid, ist);
	}
}

VOID APGTSContext::ProcessAdditionalInfoList()
{
	int nCount = m_AdditionalInfo.GetSize();
	
	for (int i= 0; i < nCount; i++)
	{
		if (RUNNING_LOCAL_TS())
		{
			CString name;
			CString value;
			
			m_AdditionalInfo.GetAt( i, name, value );
			if (name == C_ALLOW_AUTOMATIC_SNIFFING_NAME)
			{
				value.MakeLower();
				if (m_infer.GetSniff())
				{
					// set AllowAutomaticSniffing flag
					if (value == C_ALLOW_AUTOMATIC_SNIFFING_CHECKED)
						m_infer.GetSniff()->SetAllowAutomaticSniffingPolicy(true);
					if (value == C_ALLOW_AUTOMATIC_SNIFFING_UNCHECKED)
						m_infer.GetSniff()->SetAllowAutomaticSniffingPolicy(false);
				}
			}
		}
		else
		{
			// process additional info in Online TS here
		}
	}
}

VOID APGTSContext::ReadPolicyInfo()
{
	if (RUNNING_LOCAL_TS())
	{
		if (m_infer.GetSniff())
		{
			// set AllowManualSniffing flag
			DWORD dwManualSniffing = 0;
			m_pConf->GetRegistryMonitor().GetNumericInfo(CAPGTSRegConnector::eSniffManual, dwManualSniffing);
			m_infer.GetSniff()->SetAllowManualSniffingPolicy(dwManualSniffing ? true : false);
			// >>> $TODO$ I do not like setting Policy Editor values explicitely, 
			//  as it done here. Probably we will have to implement 
			//  CSniffPolicyInfo (abstract) class, designed for passing
			//  those values to sniffer (CSniff).
			// Oleg. 11.05.99
		}
	}
}

VOID APGTSContext::LogNodesPerCommandList()
{
	int nCommands = m_Commands.GetSize();
	for (int i= 0; i<nCommands; i++)
	{
		NID nid;
		int value;	// typically a state (IST), except if nid==nidProblemPage, where value is a NID
		m_Commands.GetAt( i, nid, value );
		if (nid == nidProblemPage)
			m_logstr.AddNode(value, 1);
		else
			m_logstr.AddNode(nid, value);
	}
}

// builds and returns the Start Over link
// only relevant for Online TS
// >>> JM 10/8/99: I believe it would be redundant to URL-encode
CString APGTSContext::GetStartOverLink()
{
	CString str;
#ifndef LOCAL_TROUBLESHOOTER
	bool bHasQuestionMark = false;

	// ISAPI DLL's URL
	str = m_strVRoot;

	// CK_ name value pairs 
	if (!m_mapCookiesPairs.empty())
	{
		// V3.2 - Output any CK_name-value pairs as hidden fields.
		for (CCookiePairs::const_iterator it = m_mapCookiesPairs.begin(); it != m_mapCookiesPairs.end(); ++it)
		{
			if (bHasQuestionMark)
				str += _T("&");
			else
			{
				str += _T("?");
				bHasQuestionMark = true;
			}
			CString strAttr= it->first;
			CString strValue= it->second;
			APGTS_nmspace::CookieEncodeURL( strAttr );
			APGTS_nmspace::CookieEncodeURL( strValue );
			str += C_COOKIETAG + strAttr;
			str += _T("=");
			str += strValue;
		}	
	}

	// template
	const CString strAltHTIname= GetAltHTIname();
	if (!strAltHTIname.IsEmpty())
	{
		if (bHasQuestionMark)
			str += _T("&");
		else
		{
			str += _T("?");
			bHasQuestionMark = true;
		}
		str += C_TEMPLATE;
		str += _T("=");
		str += strAltHTIname;
	}

	// topic
	if (!m_TopicName.IsEmpty())
	{
		if (bHasQuestionMark)
			str += _T("&");
		else
		{
			str += _T("?");
			bHasQuestionMark = true;
		}
		str += C_TOPIC;
		str += _T("=");
		str += m_TopicName;
	}
#endif
	return str;
}


// Assumes m_Qry.GetFirst has already been called.
// INPUT pszCmd & pszValue are the outputs of m_Qry.GetFirst.
//	These same buffers are used for subsequent calls to m_Qry.GetNext. 
// INPUT *pTopic - represents contents of appropriate DSC, HTI, BES
// INPUT bUsesIDH - Interpret numerics as IDHs (a deprecated feature) rather than NIDs
// Return 0 on success, EV_GTS_ERROR_INF_BADPARAM on failure.
DWORD APGTSContext::DoInference(LPTSTR pszCmd, 
								LPTSTR pszValue, 
								CTopic * pTopic,
								bool bUsesIDH)
{
	DWORD dwStat = 0;
	CString strTopic = pszValue;
	CString strHTTPcookies;
	
	if (!_tcsicmp(pszCmd, C_PRELOAD))
		m_bPreload = true;

	m_infer.SetTopic(pTopic);

	ClearCommandList();
	ClearSniffedList();
	ClearAdditionalInfoList();

	while (m_Qry.GetNext(pszCmd, pszValue)) 
	{		
		if ((dwStat = NextCommand(pszCmd, pszValue, bUsesIDH)) != 0)
			if ((dwStat = NextAdditionalInfo(pszCmd, pszValue)) != 0)
				if ((dwStat = NextIgnore(pszCmd, pszValue)) != 0)
					break;
	}

	if (!dwStat) 
	{
		m_Commands.RotateProblemPageToFront();
		LogNodesPerCommandList();
		SetNodesPerCommandList();
		SetNodesPerSniffedList();
		ProcessAdditionalInfoList();
		ReadPolicyInfo();

		// Append to m_strText: contents of an HTML page based on HTI template.
		// History & next recommendation

		// Build the $StartForm string.
		CString strStartForm;
		CString strTmpLine;
		const CString strAltHTIname= GetAltHTIname();

		if (RUNNING_LOCAL_TS())
			strStartForm =  _T("<FORM NAME=\"ButtonForm\">\n");
		else
			strStartForm.Format( _T("<FORM METHOD=POST ACTION=\"%s\">\n"), m_pConf->GetVrootPath() );

		if (RUNNING_ONLINE_TS())
		{
			// This processes name-value pairs, parallel to those which would come
			//	from a cookie to determine look and feel, but which in this case actually
			//	were originally sent in as CK_ pairs in Get or Post.
			// These values are only used in the Online TS.
			try
			{
				if (!m_mapCookiesPairs.empty())
				{
					// V3.2 - Output any CK_name-value pairs as hidden fields.
					for (CCookiePairs::const_iterator it = m_mapCookiesPairs.begin(); it != m_mapCookiesPairs.end(); ++it)
					{
						CString strAttr= it->first;
						CString strValue= it->second;
						APGTS_nmspace::CookieEncodeURL( strAttr );
						APGTS_nmspace::CookieEncodeURL( strValue );

						strTmpLine.Format(	_T("<INPUT TYPE=HIDDEN NAME=\"%s%s\" VALUE=\"%s\">\n"),
											C_COOKIETAG, strAttr, strValue );
						strStartForm+= strTmpLine;
					}	
				}
	
				// This processes name-value pairs, which actually come
				//	from a cookie to determine look and feel.
				// These values are only used in the Online TS.
				// V3.2 - Extract all look-and-feel cookie name-value pairs from the HTTP headers.
				char	szCookieNameValue[ 1024 ];	// never Unicode, because cookies always ASCII
				DWORD	dwCookieLen= 1023; 
				if ( m_pECB->GetServerVariable(	kHTTP_COOKIE,	szCookieNameValue, &dwCookieLen )) 
					strHTTPcookies= szCookieNameValue;
				else
				{
					// Determine if the buffer was too small.
					if (::GetLastError() == ERROR_INSUFFICIENT_BUFFER)
					{
						// never Unicode, because cookies always ASCII.
						char *pszCookieNameValue= new char[ dwCookieLen + 1 ];
						if ( m_pECB->GetServerVariable(	kHTTP_COOKIE, pszCookieNameValue, &dwCookieLen )) 
							strHTTPcookies= pszCookieNameValue;
						delete [] pszCookieNameValue;
					}
					else
					{
						// Note memory failure in event log.
						CString strLastError;
						strLastError.Format( _T("%d"), ::GetLastError() );
						CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
						CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
												SrcLoc.GetSrcFileLineStr(), 
												strLastError, _T(""), 
												EV_GTS_ERROR_EXTRACTING_HTTP_COOKIES ); 
					}
				}
			}
			catch (bad_alloc&)
			{
				// Note memory failure in event log.
				CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
				CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
										SrcLoc.GetSrcFileLineStr(), 
										_T(""), _T(""), EV_GTS_CANT_ALLOC ); 
			}
			catch (exception& x)
			{
				CString str;
				// Note STL exception in event log.
				CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
				CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
										SrcLoc.GetSrcFileLineStr(), 
										CCharConversion::ConvertACharToString(x.what(), str), 
										_T(""), 
										EV_GTS_STL_EXCEPTION ); 
			}
		}

		if (!strAltHTIname.IsEmpty())
		{
			// Add the alternate HTI template name to the $StartForm string.
			strTmpLine.Format(	_T("<INPUT TYPE=HIDDEN NAME=\"template\" VALUE=\"%s\">\n"),
								CAbstractFileReader::GetJustName( strAltHTIname ) );
			strStartForm+= strTmpLine;
		}
		strTmpLine.Format(	_T("<INPUT TYPE=HIDDEN NAME=\"topic\" VALUE=\"%s\">\n"), strTopic );
		strStartForm+= strTmpLine;

		// Determine whether an alternate HTI template should be used.
		bool bAlternatePageGenerated= false;
		if (!strAltHTIname.IsEmpty())
		{
			// Attempt to extract a pointer to the requested HTI template and if successful
			// then create a page from it.
			CP_TEMPLATE cpTemplate;

			m_pConf->GetTemplate( strAltHTIname, cpTemplate, m_bNewCookie );
			CAPGTSHTIReader	*pHTI= cpTemplate.DumbPointer();
			if (pHTI) 
			{
				CString strResourcePath;
				m_pConf->GetRegistryMonitor().GetStringInfo(CAPGTSRegConnector::eResourcePath, strResourcePath);
#ifdef LOCAL_TROUBLESHOOTER
				CHTMLFragmentsLocal frag( strResourcePath, pHTI->HasHistoryTable() );
#else
				CHTMLFragmentsTS frag( strResourcePath, pHTI->HasHistoryTable() );
#endif

				// Add the $StartForm string to the HTML fragments.
				frag.SetStartForm(strStartForm);

				frag.SetStartOverLink(GetStartOverLink());
				
				// JSM V3.2 get list of Net prop names needed by HTI;
				//   pass them to frag.  CInfer will fill in
				//   the net prop values, using these names, in FillInHTMLFragments()
				{
					vector<CString> arr_props;
					pHTI->ExtractNetProps(arr_props);
					for(vector<CString>::iterator i = arr_props.begin(); i < arr_props.end(); i++)
						frag.AddNetPropName(*i);
				}

				m_infer.IdentifyPresumptiveCause();
				m_infer.FillInHTMLFragments(frag);

				pHTI->CreatePage( frag, m_strText, m_mapCookiesPairs, strHTTPcookies );
				bAlternatePageGenerated= true;
			}
		}
		if (!bAlternatePageGenerated)
		{
			// The page was not generated from an alternate HTI template, generate it now.
			// >>> $MAINT an awful lot of common code with the above.  Can't we
			//		set up a private method?
			CString strResourcePath;
			m_pConf->GetRegistryMonitor().GetStringInfo(CAPGTSRegConnector::eResourcePath, strResourcePath);
#ifdef LOCAL_TROUBLESHOOTER
			CHTMLFragmentsLocal frag( strResourcePath, pTopic->HasHistoryTable() );
#else
			CHTMLFragmentsTS frag( strResourcePath, pTopic->HasHistoryTable() );
#endif

			// Add the $StartForm string to the HTML fragments.
			frag.SetStartForm(strStartForm);

			frag.SetStartOverLink(GetStartOverLink());

			// JSM V3.2 get list of Net prop names needed by HTI;
			//   pass them to frag.  CInfer will fill in
			//   the net prop values, using these names, in FillInHTMLFragments()
			{
				vector<CString> arr_props;
				pTopic->ExtractNetProps(arr_props);
				for(vector<CString>::iterator i = arr_props.begin(); i < arr_props.end(); i++)
					frag.AddNetPropName(*i);
			}
			
			m_infer.IdentifyPresumptiveCause();
			m_infer.FillInHTMLFragments(frag);

			pTopic->CreatePage( frag, m_strText, m_mapCookiesPairs, strHTTPcookies );
		}


		if (m_infer.AppendBESRedirection(m_strHeader)) 
			// We have no more recommendations, but there is a BES file present, so we
			//	have to redirect the user
			_tcscpy(m_resptype, _T("302 Object Moved"));
		
	}
	else 
	{
		SetError(_T(""));
	}

	return dwStat;
}

CString APGTSContext::RetCurrentTopic() const
{
	return( m_TopicName );
}

// Operator actions which must be performed by the main thread are caught in 
//	APGTSExtension::IsEmergencyRequest
// All other operator actions can be identified by this routine.
// INPUT *pECB: our abstraction from EXTENSION_CONTROL_BLOCK, which is ISAPI's way of 
//	packaging CGI data.   pECB should never be null.
APGTSContext::eOpAction APGTSContext::IdentifyOperatorAction(CAbstractECB *pECB)
{
	if (strcmp(pECB->GetMethod(), "GET"))
		return eNoOpAction;
	
	if (strncmp(pECB->GetQueryString(), SZ_EMERGENCY_DEF, strlen(SZ_OP_ACTION)))
		return eNoOpAction;
	
	if ( ! strncmp(pECB->GetQueryString() + strlen(SZ_OP_ACTION), 
		SZ_RELOAD_TOPIC, strlen(SZ_RELOAD_TOPIC)))
		return eReloadTopic;
	if ( ! strncmp(pECB->GetQueryString() + strlen(SZ_OP_ACTION), 
		SZ_KILL_THREAD, strlen(SZ_KILL_THREAD)))
		return eKillThread;
	if ( ! strncmp(pECB->GetQueryString() + strlen(SZ_OP_ACTION), 
		SZ_RELOAD_ALL_TOPICS, strlen(SZ_RELOAD_ALL_TOPICS)))
		return eReloadAllTopics;
	if ( ! strncmp(pECB->GetQueryString() + strlen(SZ_OP_ACTION), 
		SZ_SET_REG, strlen(SZ_SET_REG)))
		return eSetReg;

	return eNoOpAction;
}

// Identify a request to perform an operator action that does not have to be performed
//	on the main thread.
// Should be called only after we have determined this is an operator action: sends an 
//	error msg to end user if it's not.
// Based loosely on APGTSExtension::ParseEmergencyRequest
// INPUT *pECB: our abstraction from EXTENSION_CONTROL_BLOCK, which is ISAPI's way of 
//	packaging CGI data.   pECB should never be null.
// OUTPUT strArg - any argument for this operation
// Returns identified operator action.
APGTSContext::eOpAction APGTSContext::ParseOperatorAction(
	CAbstractECB *pECB, 
	CString & strArg)
{
	TCHAR *pszProblem= NULL;
	CHAR * ptr = pECB->GetQueryString();

	CHAR * ptrArg = strstr(pECB->GetQueryString(), "&");
	if(ptrArg)
	{
		// Turn the ampersand into a terminator and point past it.
		// Everything past it is an argument.
		*(ptrArg++) = '\0';		
		CCharConversion::ConvertACharToString(ptrArg, strArg) ;
	}
	else
		strArg = _T("");

	// In a sense this test is redundant (should know this before this fn is called) but
	//	this seemed like a safer way to code JM 11/2/98
	eOpAction ret = IdentifyOperatorAction(pECB);

	if ( ret == eNoOpAction) 
		pszProblem= _T("Wrong Format");
	else
	{
		switch(ret)
		{
			case eReloadTopic:
				ptr += strlen(SZ_OP_ACTION) + strlen(SZ_RELOAD_TOPIC);
				break;
			case eKillThread:
				ptr += strlen(SZ_OP_ACTION) + strlen(SZ_KILL_THREAD);
				break;
			case eReloadAllTopics:
				ptr += strlen(SZ_OP_ACTION) + strlen(SZ_RELOAD_ALL_TOPICS);
				break;
			case eSetReg:
				ptr += strlen(SZ_OP_ACTION) + strlen(SZ_SET_REG);
				break;
			default:
				CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
				CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
										SrcLoc.GetSrcFileLineStr(), 
										_T(""), _T(""), 
										EV_GTS_ERROR_INVALIDOPERATORACTION ); 
		}
		
// You can compile with the NOPWD option to suppress all password checking.
// This is intended mainly for creating test versions with this feature suppressed.
#ifndef NOPWD
		CRegistryPasswords pwd;
		CString str;
		if (! pwd.KeyValidate( 
				_T("ActionAccess"), 
				CCharConversion::ConvertACharToString(ptr, str) ) )
		{
			pszProblem= _T("Bad password");
			ret = eNoOpAction;
		}
#endif // ifndef NOPWD
	}

	if (pszProblem)
	{
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								pszProblem,
								_T(""),
								EV_GTS_CANT_PROC_OP_ACTION );

		m_dwErr = EV_GTS_CANT_PROC_OP_ACTION;
	}

	return ret;
}

// Execute a request to  do one of:
// - Reload one topic
// - Kill (and restart) one pool thread
// - Reload all monitored files.
// INPUT *pECB: our abstraction from EXTENSION_CONTROL_BLOCK, which is ISAPI's way of 
//	packaging CGI data.   pECB should never be null.
// INPUT action - chooses among the three possible actions
// INPUT strArg - provides any necessary arguments for that action
// RETURNS HSE_STATUS_SUCCESS, HSE_STATUS_ERROR
void APGTSContext::ExecuteOperatorAction(
	CAbstractECB *pECB, 
	eOpAction action,
	const CString & strArg)
{
	m_strText += _T("<HTML><HEAD><TITLE>AP GTS Command</TITLE></HEAD>");
	m_strText += _T("<BODY BGCOLOR=#FFFFFF>");

	switch (action)
	{
		case eReloadTopic:
			{
				bool bAlreadyInCatalog;
				m_strText += _T("<H1>Reload Topic ");
				m_strText += strArg;
				m_strText += _T("</H1>");
				m_pConf->GetTopicShop().BuildTopic(strArg, &bAlreadyInCatalog);
				if (!bAlreadyInCatalog)
				{
					m_strText += strArg;
					m_strText += _T(" is not a known topic.  Either it is not in the current LST file")
						_T(" or the Online Troubleshooter is waiting to see the resource directory")
						_T(" &quot;settle&quot; before loading the LST file.");
				}
				break;
			}
		case eKillThread:
			m_strText += _T("<H1>Kill Thread");
			m_strText += strArg;
			m_strText += _T("</H1>");
			if (m_pConf->GetThreadPool().ReinitializeThread(_ttoi(strArg)))
				m_strText += _T("Thread killed.  System will attempt to spin a new thread.");
			else
				m_strText += _T("No such thread");
			break;
		case eReloadAllTopics:
			m_strText += _T("<H1>Reload All Topics</H1>");
			m_pConf->GetTopicShop().RebuildAll();
			break;
		case eSetReg:
			{
				CHttpQuery query;
				TCHAR szCmd[MAXBUF];
				TCHAR szVal[MAXBUF];
				CString strCmd, strVal;
				query.GetFirst(strArg, szCmd, szVal);
				CCharConversion::ConvertACharToString(szCmd, strCmd);
				CCharConversion::ConvertACharToString(szVal, strVal);
				
				m_strText += _T("<H1>Set registry value");
				m_strText += strCmd;
				m_strText += _T(" = ");
				m_strText += strVal;
				m_strText += _T("</H1>");

				CAPGTSRegConnector RegConnect( _T("") );
				bool bChanged ;
				bool bExists = RegConnect.SetOneValue(szCmd, szVal, bChanged );

				CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
				CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								strCmd,
								strVal,
								bExists ? 
									EV_GTS_SET_REG_VALUE :
									EV_GTS_CANT_SET_REG_VALUE); 

				if (bChanged)
					m_strText +=  _T("Successful.");
				else if (bExists)
				{
					m_strText +=  strCmd;
					m_strText +=  _T(" already had value ");
					m_strText +=  strVal;
					m_strText +=  _T(".");
				}
				else
				{
					m_strText +=  strCmd;
					m_strText +=  _T(" Unknown.");
				}
									 

				break;
			}
		default:
			m_strText += _T("<H1>Unknown operation</H1>");
			break;
	}
	m_strText += strArg;

	m_strText += _T("</BODY></HTML>");
}

// override any partially written page with an error page.
void APGTSContext::SetError(LPCTSTR szMessage)
{
	_tcscpy(m_resptype, _T("400 Bad Request"));

	CString str(_T("<H3>Possible invalid data received</H3>\n"));
	str += szMessage;

	m_pConf->CreateErrorPage(str, m_strText);

}

void APGTSContext::SetAltHTIname( const CString& strHTIname )
{
	m_strAltHTIname= strHTIname;
}

CString APGTSContext::GetAltHTIname() const
{
	return( m_strAltHTIname );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\apgtshtiscan.h ===
// apgtshtiscan.h: interface for the CAPGTSHTIScanner class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_APGTSHTISCAN_H__05C561A4_6C50_11D3_8D37_00C04F949D33__INCLUDED_)
#define AFX_APGTSHTISCAN_H__05C561A4_6C50_11D3_8D37_00C04F949D33__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "apgtshtiread.h"

class CAPGTSHTIScanner : protected CAPGTSHTIReader  
{
public:
	CAPGTSHTIScanner(CPhysicalFileReader * pPhysicalFileReader, LPCTSTR szDefaultContents = NULL);
	CAPGTSHTIScanner(const CAPGTSHTIReader& htiReader);
	~CAPGTSHTIScanner();

public:
	bool Read();
	void Scan(const CHTMLFragments& fragments);

protected:	
	virtual void ParseInterpreted();
};

inline bool CAPGTSHTIScanner::Read()
{
	return CAPGTSHTIReader::Read();	
}

#endif // !defined(AFX_APGTSHTISCAN_H__05C561A4_6C50_11D3_8D37_00C04F949D33__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\apgtsinf.cpp ===
//
// MODULE: APGTSINF.CPP
//
// PURPOSE: Inference Engine Interface
//  Completely implement class CInfer.  VERY IMPORTANT STUFF!
//	One of these is created for each user request
//	Some utility functions at end of file.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Roman Mach, Joe Mabel
// 
// ORIGINAL DATE: 8-2-96
//
// NOTES: 
// 1. Many methods in this class could be const if BNTS had more appropriate use of const
// 2. Several places in this file you will see a space after %s in the format passed to 
//	CInfer::AppendMultilineNetProp() or CInfer::AppendMultilineNodeProp().  This is the 
//	upshot of some 12/98 correspondence between Microsoft and Saltmine.  Many older DSC files
//	were built with a tool that could not handle more than 255 characters in a string.
//	The DSC feil format's "Array of string" was used to build up longer strings.  Newer 
//	DSC files (and all Argon-produced DSC files) should use only the first element of this
//	array.
//	The older DSC files assumed that the separate strings would effectively be separated 
//	by white space, so we must maintain that situation.
// 3. >>> $MAINT - exception-handling strategy for push_back and other memory allocation
//	functions is really overkill.  If we run out of memory, we're screwed anyway.  Really
//	would suffice to handle try/catch just at the main function of the thread.
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V3.0		7-21-98		JM		Major revision, deprecate IDH.
//			8-27-98		JM		Totally new method of communicating with template
//

#pragma warning(disable:4786)
#include "stdafx.h"
#include "event.h"
#include "apgts.h"
#include "apgtsinf.h"
#include "apgtsmfc.h"
#include "apgtsassert.h"
#include "CharConv.h"
#include "maxbuf.h"
#include <algorithm>
#include <vector>
#include <map>
#include "Sniff.h"
#include "SniffController.h"
#ifdef LOCAL_TROUBLESHOOTER
 #include "SniffLocal.h"
#endif

// -------------------------------------------------------------------
// Constructor/Destructor, other initialization
// -------------------------------------------------------------------
//
// INPUT *pCtxt is a buffer for building the string to pass back over the net.
CInfer::CInfer(CSniffConnector* pSniffConnector) :
#ifdef LOCAL_TROUBLESHOOTER
	m_pSniff(new CSniffLocal(pSniffConnector, NULL)),
#else
	m_pSniff(NULL),
#endif
	m_nidProblem(nidNil),
	m_bDone(false),
	m_bRecOK (false),
	m_SniffedRecommendation(nidNil, SNIFF_FAILURE_RESULT),
	m_bUseBackEndRedirection(false),
	m_bRecycleSkippedNode(false),
	m_nidRecycled(0),
	m_bRecyclingInitialized(false),
	m_nidSelected(nidNil),
	m_bLastSniffedManually(false)
{
}

//
//
CInfer::~CInfer()
{
	delete m_pSniff;
}

// The intention is that this be called only once.
// It would be ideal if this were part of the constructor, but the CTopic * is not
//	yet available at time of construction.  
// The expectation is that this should be called before calling any other function. (Some
//	are technically OK to call, but it's smartest not to rely on that.) 
void CInfer::SetTopic(CTopic *pTopic)
{
	m_pTopic = pTopic;
	if (m_pSniff)
		m_pSniff->SetTopic(pTopic);
}

// This fn exists so APGTSContext can access *m_pSniff to tell it what the sniffing 
//	policies are.  
CSniff* CInfer::GetSniff()
{
	return m_pSniff;
}

// -------------------------------------------------------------------
// First, we set the states of nodes, based on the query string we got from the HTML form
// -------------------------------------------------------------------

// Convert IDH to NID.  Needed on some old query string formats
// "Almost vestigial", still supported in v3.2, but will be dropped in v4.0.
NID CInfer::NIDFromIDH(IDH idh) const 
{
	if (idh == m_pTopic->CNode() + idhFirst)
		return nidProblemPage;
	
	if (idh == nidService + idhFirst)
		return nidService;

	if (idh == IDH_FAIL)
		return nidFailNode;
	
	if (idh == IDH_BYE)
		return nidByeNode;

	ASSERT (idh >= idhFirst);
	return idh - idhFirst;
}

// Associate a state with a node.
// INPUT nid
// INPUT ist -	Normally, index of a state for that node. 
//	If nid == nidProblemPage, then ist is actually NID of selected problem
void CInfer::SetNodeState(NID nid, IST ist)
{
	if (nid == nidNil)
		return;

	CString strTemp;
	CString strTxt;

	if (ist == ST_WORKED) 
	{
		if (nid == nidFailNode || nid == nidSniffedAllCausesNormalNode
			|| nid == nidService || nid == nidImpossibleNode)
		{
			if (m_pTopic->HasBES())
			{
				m_bUseBackEndRedirection = true;
				CString strThrowaway;	// we don't really care about this string;
										//	we call OutputBackend strictly for the side 
										//	effect of setting m_strEncodedForm.
				OutputBackend(strThrowaway);
				return;
			}
		}

		m_bDone = true;
		AddToBasisForInference(nid, ist); // this node still needs to be present 
										  //  in m_arrBasisForInference, as it is
										  //  present in m_SniffedStates.

		// Add to the visited array to be displayed in the visible history page.  RAB-20000628.
		try
		{
			m_arrnidVisited.push_back( nid );
		}
		catch (exception& x)
		{
			CString str;
			// Note STL exception in event log.
			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									CCharConversion::ConvertACharToString(x.what(), str),
									_T(""), 
									EV_GTS_STL_EXCEPTION ); 
		}

		return;
	}

	if (ist == ST_ANY)
	{
		// We rely on the fact that only a service node offers ST_ANY 
		//	("Is there anything else I can try?")
		m_bRecycleSkippedNode = true; 
		return;
	}

	// We should never have service node go past this point (always ST_WORKED or ST_ANY).

	if (nid == nidByeNode || nid == nidFailNode || nid == nidSniffedAllCausesNormalNode)
		return;

	if (ist == ST_UNKNOWN)	
	{
		// Add it to the list of skipped nodes & visited nodes
		try
		{
			m_arrnidSkipped.push_back(nid);
			m_arrnidVisited.push_back(nid);
		}
		catch (exception& x)
		{
			CString str;
			// Note STL exception in event log.
			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									CCharConversion::ConvertACharToString(x.what(), str), 
									_T(""), 
									EV_GTS_STL_EXCEPTION ); 
		}
		return;
	}

	if (nid == nidProblemPage) 
	{
		if (!IsProblemNode(ist))
		{
			// Totally bogus query.  Arbitrary course of action.
			m_bRecycleSkippedNode = true;
			return;
		}

		// Change this around to the way we would express it for any other node.
		nid = ist;
		ist = 1;	// Set this problem node to a state value of 1 (in fact, we never
					//	explicitly set problem nodes to state value of 0)

		m_nidProblem = nid;			// special case: here instead of in m_arrnidVisited
		AddToBasisForInference(nid, ist);
		return;
	}

	AddToBasisForInference(nid, ist);

	// Store into our list of nodes obtained from the user
	try
	{
		m_arrnidVisited.push_back(nid);
	}
	catch (exception& x)
	{
		CString str;
		// Note STL exception in event log.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								CCharConversion::ConvertACharToString(x.what(), str),
								_T(""), 
								EV_GTS_STL_EXCEPTION ); 
	}
}

void CInfer::AddToBasisForInference(NID nid, IST ist)
{
	try
	{
		m_BasisForInference.push_back(CNodeStatePair(nid, ist)); 
	}
	catch (exception& x)
	{
		CString str;
		// Note STL exception in event log.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								CCharConversion::ConvertACharToString(x.what(), str),
								_T(""), 
								EV_GTS_STL_EXCEPTION ); 
	}
}

// Add to the list of (previously) sniffed nodes.
void CInfer::AddToSniffed(NID nid, IST ist)
{
	try
	{
		if (ist == ST_WORKED && m_pTopic->IsCauseNode(nid)) 
		{   // in case of cause node in abnormal state (which is ST_WORKED)
			//  we need to set state to "1" as if it was sniffed.
			// This situation happens during manual sniffing of cause node that worked.
			ist = 1;
		}
		m_SniffedStates.push_back(CNodeStatePair(nid, ist)); 
	}
	catch (exception& x)
	{
		CString str;
		// Note STL exception in event log.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								CCharConversion::ConvertACharToString(x.what(), str),
								_T(""), 
								EV_GTS_STL_EXCEPTION ); 
	}
}

// Be careful not to call this redundantly: its call to CTopic::GetRecommendations()
//	is expensive.
void CInfer::GetRecommendations()
{
	// if we haven't previously sought a recommendation...
	if ( m_SniffedRecommendation.nid() != nidNil )
	{
		// The one and only relevant recommendation is already forced, so don't bother 
		//	getting recommendations.
		// m_SniffedRecommendation.nid() is a Cause node in its abnormal state
		m_Recommendations.empty();
		try
		{
			m_Recommendations.push_back(m_SniffedRecommendation.nid());
			m_bRecOK = true;
		}
		catch (exception& x)
		{
			CString str;
			// Note STL exception in event log.
			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									CCharConversion::ConvertACharToString(x.what(), str),
									_T(""), 
									EV_GTS_STL_EXCEPTION ); 
		}
	}
	else
	{
		// Pass data into m_pTopic
		// Get back recomendations.
		int status = m_pTopic->GetRecommendations(m_BasisForInference, m_Recommendations);
		m_bRecOK = (status == CTopic::RS_OK);
	}
}

// returns true if nid is a problem node of this network
bool CInfer::IsProblemNode(NID nid) const
{
	// get data array of problem nodes
	vector<NID>* parrnid = NULL;
	
	m_pTopic->GetProblemArray(parrnid);

	vector<NID>::const_iterator itnidBegin = parrnid->begin();
	vector<NID>::const_iterator itnidEnd = parrnid->end();
	vector<NID>::const_iterator itnidProblem = find(itnidBegin, itnidEnd, nid);

	if (itnidProblem == itnidEnd)
		return false;
	else
		return true;
}

bool CInfer::IsInSniffedArray(NID nid) const
{
	UINT nSniffedNodes = m_SniffedStates.size();

	for (UINT i = 0; i < nSniffedNodes; i++)
	{
		if (m_SniffedStates[i].nid() == nid)
		{
			// Do not have to check for state, as m_SniffedStates will
			//  have only valid states (states, which are accepted by BNTS),
			//  no 102 or -1 states
			return true;
		}
	}

	return false;
}

// -------------------------------------------------------------------
// For writing the new page after inference: the following texts are
//	invariant for a given topic (aka network).
// -------------------------------------------------------------------

// CreateUnknownButtonText:  Reads the network property for the 
// unknown-state radio button from the network dsc file.
// Puts value in strUnknown
// This is specific to the radio button for "unknown" in the history table, 
//	that is, for a node which has previously been visited.  This should not be
//	used for the radio button for the "unknown" state of the present node.
void CInfer::CreateUnknownButtonText(CString & strUnknown) const
{
	strUnknown = m_pTopic->GetNetPropItemStr(HTK_UNKNOWN_RBTN);
	if (strUnknown.IsEmpty())
		strUnknown = SZ_UNKNOWN;
	return;
}

// AppendNextButtonText:  Reads the network property for the 
// NEXT button from the network dsc file and append it to str.
void CInfer::AppendNextButtonText(CString & str) const
{
	CString strTemp = m_pTopic->GetNetPropItemStr(HTK_NEXT_BTN);

	if (strTemp.IsEmpty())
		strTemp = SZ_NEXT_BTN;

	str += strTemp;
	return;
}

// AppendNextButtonText:  Reads the network property for the 
// NEXT button from the network dsc file and append it to str.
void CInfer::AppendStartOverButtonText(CString & str) const
{
	CString strTemp = m_pTopic->GetNetPropItemStr(HTK_START_BTN);

	if (strTemp.IsEmpty())
		strTemp = SZ_START_BTN;

	str += strTemp;
	return;
}

// AppendBackButtonText:  Reads the network property for the 
// BACK button from the network dsc file and append it to str.
void CInfer::AppendBackButtonText(CString & str) const
{
	CString strTemp = m_pTopic->GetNetPropItemStr(HTK_BACK_BTN);

	if (strTemp.IsEmpty())
		strTemp = SZ_BACK_BTN;

	str += strTemp;
	return;
}

// AppendPPSnifferButtonText:  Reads the network property for the 
// sniffer button from the network dsc file.
// NOTE that this button is related to "expensive" sniffing only.
// Appends to str.
void CInfer::AppendPPSnifferButtonText(CString & str) const
{	
	CString strTemp = m_pTopic->GetNetPropItemStr(HTK_SNIF_BTN);

	if (strTemp.IsEmpty())
		strTemp = SZ_PP_SNIF_BTN;

	str += strTemp;
}

// AppendManualSniffButtonText:  Reads the network property for the 
// manual sniff button from the network dsc file.
// Appends to str.
void CInfer::AppendManualSniffButtonText(CString & str) const
{	
	CString strTemp = m_pTopic->GetNetPropItemStr(H_NET_TEXT_SNIFF_ONE_NODE);

	if (strTemp.IsEmpty())
		strTemp = SZ_SNIFF_ONE_NODE;

	str += strTemp;
}

// AppendHistTableSniffedText:  Reads the network property for the 
// indication in history table that a node was sniffed.
// Appends to str.
void CInfer::AppendHistTableSniffedText(CString & str) const
{	
	CString strTemp = m_pTopic->GetNetPropItemStr(H_NET_HIST_TABLE_SNIFFED_TEXT);

	if (strTemp.IsEmpty())
		strTemp = SZ_HIST_TABLE_SNIFFED_TEXT;

	str+= _T("<BR>\n");
	str += strTemp;
}

// AppendAllowSniffingText:  Reads the network property for the 
// label of the AllowSniffing checkbox from the network dsc file.
// Appends to str.
void CInfer::AppendAllowSniffingText(CString & str) const
{	
	CString strTemp = m_pTopic->GetNetPropItemStr(H_NET_ALLOW_SNIFFING_TEXT);

	if (strTemp.IsEmpty())
		strTemp = SZ_ALLOW_SNIFFING_TEXT;

	str += strTemp;
}

// AppendSniffFailedText:  Reads the network property for the 
// alert box to be used when manual sniffing fails from the network dsc file.
// Appends to str.
void CInfer::AppendSniffFailedText(CString & str) const
{	
	CString strTemp = m_pTopic->GetNetPropItemStr(H_NET_TEXT_SNIFF_ALERT_BOX);

	if (strTemp.IsEmpty())
		strTemp = SZ_SNIFF_FAILED;

	str += strTemp;
}

// Appends an HTML link but makes it look like an HTML Form Button
// useful for Start Over in Online TS, because with no idea what browser user will have, 
// we can't usefully use an onClick method (not supported in older browsers).
// Online TS runs in a "no scripting" environment.
// Pure HTML doesn't provide a means to put both a "Next" and a "Start Over" button
//	in the same HTML form.  Conversely, if Start Over btn was outside the form, pure HTML 
//	doesn't provide a means to align it with a button in the form.
// Note that x.gif does not exist: its absence creates a 1-pixel placeholder.
// >>>$MAINT We may want to change some of the rowspans to better emulate the exact size 
//	of a button; try to make it look perfect under IE
void CInfer::AppendLinkAsButton(
	CString & str, 
	const CString & strTarget, 
	const CString & strLabel) const
{
	str += _T("<!-- Begin pseudo button -->"
		"<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\">\n"
		"<tr>\n"
		"	<td rowspan=\"6\" bgcolor=\"white\">\n"
		"		<img src=\"x.gif\" width=\"1\" height=\"1\"></td>\n"
		"	<td colspan=\"3\" bgcolor=\"white\">\n"
		"		<img src=\"x.gif\" width=\"1\" height=\"1\"></td>\n"
		"</tr>\n"
		"<tr>\n"
		"	<td bgcolor=\"#C0C0C0\">\n"
		"		<img src=\"x.gif\" width=\"1\" height=\"3\"></td>\n"
		"	<td rowspan=\"4\" bgcolor=\"#808080\">\n"
		"		<img src=\"x.gif\" width=\"1\" height=\"1\"></td>\n"
		"	<td rowspan=\"4\" bgcolor=\"#000000\">\n"
		"		<img src=\"x.gif\" width=\"1\" height=\"1\"></td>\n"
		"</tr>\n"
		"<tr>\n"
		"	<td bgcolor=\"#C0C0C0\">\n");

	// >>> $MAINT might want to change the font/style in the following
	str += _T("<font face=\"Arial\" size=\"2\">&nbsp;&nbsp;&nbsp;\n"
		"	<a href=\"");
	str += strTarget;
	str += _T("\" style=\"text-decoration:none; color:black\">\n"
		"	<font color=\"black\">");
	str += strLabel;
	str += _T("</font></a>\n"
		"	&nbsp;&nbsp;&nbsp;</font></td>\n"
		"</tr>\n"
		"<tr>\n"
		"	<td bgcolor=\"#C0C0C0\">\n"
		"		<img src=\"x.gif\" width=\"1\" height=\"3\"></td>\n"
		"</tr>\n"
		"<tr>\n"
		"	<td bgcolor=\"#808080\">\n"
		"		<img src=\"x.gif\" width=\"1\" height=\"1\"></td>\n"
		"</tr>\n"
		"<tr>\n"
		"	<td colspan=\"3\" bgcolor=\"#000000\">\n"
		"		<img src=\"x.gif\" width=\"1\" height=\"1\"></td>\n"
		"</tr>\n"
		"</table>\n"
		"<!-- End pseudo button -->\n");
}

// -------------------------------------------------------------------
// Writing to the new HTML page.  Miscellaneous low-level pieces.
// -------------------------------------------------------------------

// If the state name is missing or is simply "<hide>", return true.
// This indicates a state that should never be overtly presented to the user as a choice.
// Typically used in an informational node, this may describe a state that can be deduced with
//	100% certainty from certain other node/state combinations.
/* static */ bool CInfer::HideState(LPCTSTR szStateName)
{
	if (szStateName && *szStateName && _tcscmp(szStateName, _T("<hide>") ) )
		return false;

	return true;
}

// write a symbolic name (based on NID) to a string sz
// INPUT nid - node ID
// OUTPUT str - the string to which we write.
// RETURNS true if successful
// NOTE that this restores the "current" node when it is finished.
//	Alternative would be side effect of setting current node (by omitting nidOld), but that
//	would work strangely on "special" nodes (e.g. Service, Fail), which aren't in BNTS.
bool CInfer::SymbolicFromNID(CString & str, NID nid) const
{
	if (nid == nidProblemPage)
    {
		str= NODE_PROBLEM_ASK;
		return true;
	}
	if (nid == nidService) 
	{
		str= NODE_SERVICE;
		return true;
	}

	if (nid == nidFailNode)
	{
		str= NODE_FAIL;
		return true;
	}
	
	if (nid == nidSniffedAllCausesNormalNode)
	{
		str= NODE_FAILALLCAUSESNORMAL;
		return true;
	}
	
	if (nid == nidImpossibleNode)
	{
		str= NODE_IMPOSSIBLE;
		return true;
	}
	
	if (nid == nidByeNode)
	{
		str= NODE_BYE;
		return true;
	}

	// if it's a "normal" node, this will fill in the name
	str= m_pTopic->GetNodeSymName(nid);

	return (!str.IsEmpty() );
}

// append an HTML radio button to str
// INPUT/OUTPUT str - the string to which we append
// INPUT szName, szValue - For <INPUT TYPE=RADIO NAME=szName VALUE=szValue> 
// INPUT szLabel - text to appear after the radio button but before a line break
/*static*/ void CInfer::AppendRadioButtonCurrentNode(
	CString &str, LPCTSTR szName, LPCTSTR szValue, LPCTSTR szLabel, bool bChecked/*= false*/)
{
	CString strTxt;

	if ( ! HideState(szLabel))
	{
		if (RUNNING_LOCAL_TS())
			str += "\n<TR>\n<TD>\n";

		strTxt.Format(_T("<INPUT TYPE=RADIO NAME=\"%s\" VALUE=\"%s\" %s> %s"), 
					  szName, szValue, bChecked ? _T("CHECKED") : _T(""), szLabel);
		str += strTxt;

		if (RUNNING_LOCAL_TS())
			str += "\n</TD>\n</TR>\n";
		else
			str += "\n<BR>\n";
	}
}

//	This is different than other radio buttons because it 
//		- has a different format for label szLabel.
//		- vanishes if bShowHistory is false and this button isn't CHECKED
//		- turns into a hidden field if bShowHistory is false and this button is CHECKED
//		- writes SNIFFED_ values as applicable...although that's not in this function: it's
//			handled in a separate call to AppendHiddenFieldSniffed()
// JM 11/12/99 previously, we special-cased hidden states here.  However, per 11/11/99 email 
//	from John Locke, the only state we ever hide in the History Table (for v3.2) is the
//	Unknown/skipped state, and that is handled elsewhere.
// INPUT/OUTPUT str - string to which we append the HTML for this button.
// INPUT nid - NID of node
// INPUT value - state 
// INPUT bSet - true ==> button is CHECKED
// INPUT szctype - short name of the state
// INPUT bShowHistory - see explanation a few lines above
void CInfer::AppendRadioButtonVisited(
	CString &str, NID nid, UINT value, bool bSet, LPCTSTR szLabel, bool bShowHistory) const
{
	CString strTxt;
	CString strSymbolic;

	SymbolicFromNID(strSymbolic, nid);

	if (bShowHistory)
		strTxt.Format(_T("<INPUT TYPE=RADIO NAME=%s VALUE=%u%s>%-16s \n"), 
			strSymbolic, value, bSet ? _T(" CHECKED") : _T(""), szLabel);
	else if (bSet)
		strTxt.Format(_T("<INPUT TYPE=HIDDEN NAME=%s VALUE=%u>\n"), 
			strSymbolic, value);

	str += strTxt;
}

// If this nid is an already sniffed node, then we append this fact as a 
//	"hidden" value in the HTML in str.
// For example, if a node with symbolic name FUBAR has been sniffed in state 1,
//	we will append "<INPUT TYPE=HIDDEN NAME=SNIFFED_FUBAR VALUE=1>\n"
// INPUT: string to have appended; node ID
// OUTPUT: string with appended hidden field if node was sniffed
// RETURN: true id string is appended
void CInfer::AppendHiddenFieldSniffed(CString &str, NID nid) const
{
	CString strSymbolic;
	UINT nSniffedNodes = m_SniffedStates.size();

	SymbolicFromNID(strSymbolic, nid);

	for (UINT i = 0; i < nSniffedNodes; i++)
	{
		if (m_SniffedStates[i].nid() == nid)
		{
			// Do not have to check for state, as m_SniffedStates will
			//  have only valid states (states, which are accepted by BNTS),
			//  no 102 or -1 states

			// In case that this is manually sniffed cause node in abnormal state
			//  (and we just re-submit previous page), we need not mention
			//  this node as sniffed.
			
			if (!(IsManuallySniffedNode(nid) &&
				  m_SniffedStates[i].state() == 1 &&
				  m_pTopic->IsCauseNode(nid))
			   )
			{
				CString strTxt;

				strTxt.Format(_T("<INPUT TYPE=HIDDEN NAME=%s%s VALUE=%u>\n"), 
							  C_SNIFFTAG, strSymbolic, m_SniffedStates[i].state());
				str += strTxt;
				return;
			}
		}
	}
}

// Appends (to str) info conveying whether Automatic Sniffing is allowed.
void CInfer::AddAllowAutomaticSniffingHiddenField(CString &str) const
{
	CString strTxt;

	strTxt.Format(_T("<INPUT TYPE=HIDDEN NAME=%s VALUE=%s>\n"), 
				  C_ALLOW_AUTOMATIC_SNIFFING_NAME, C_ALLOW_AUTOMATIC_SNIFFING_CHECKED);
	str += strTxt;
}

// Radio buttons for currently recommended node
// Each button will appear only if appropriate string property is defined 
// Accounts for multi-state or simple binary node.
// INPUT nid - identifies a node of an appropriate type
// INPUT/OUTPUT str - string to which we are appending to build HTML page we send back.
// The detailed behavior of this function was changed at John Locke's request 11/30/98 for V3.0.
// Then for v3.1, handling of H_ST_AB_TXT_STR, H_ST_NORM_TXT_STR removed 8/19/99 per request 
//	from John Locke & Alex Sloley
void CInfer::AppendCurrentRadioButtons(NID nid, CString & str)
{
	CString strSymbolic;

	SymbolicFromNID(strSymbolic, nid);

	CString strPropLongName;	// long name of property

	int nStates = m_pTopic->GetCountOfStates(nid);

	if (RUNNING_LOCAL_TS())
		str += "\n<TABLE>";

	for (IST state=0; state < nStates; state ++)
	{
		TCHAR szStateNumber[MAXBUF]; // buffer for _itot()
		CString strDisplayState = _itot( state, szStateNumber, 10 );
		if (state == 1 && m_pTopic->IsCauseNode( nid ))
			strDisplayState = SZ_ST_WORKED;

		strPropLongName = _T("");

		if (strPropLongName.IsEmpty())
			// account for multistate node
			strPropLongName = m_pTopic->GetNodePropItemStr(nid, MUL_ST_LONG_NAME_STR, state);

		// if we're not past the end of states, append a button
		if (!strPropLongName.IsEmpty())
			AppendRadioButtonCurrentNode(str, 
										 strSymbolic, 
										 strDisplayState, 
										 strPropLongName, 
										 // check state button if this state was sniffed
										 m_SniffedRecommendation.state() == state ? true : false);
	};

	// "unknown" state (e.g. "I want to skip this")
	strPropLongName = m_pTopic->GetNodePropItemStr(nid, H_ST_UKN_TXT_STR);
	if (!strPropLongName.IsEmpty())
		AppendRadioButtonCurrentNode(str, strSymbolic, SZ_ST_UNKNOWN, strPropLongName);

	if (RUNNING_LOCAL_TS())
		str += "</TABLE>\n";

	return;
}

// If we are showing the history table, place a localizable Full Name 
//	(e.g."Printouts appear garbled") of problem and a hidden-data  
//	field corresponding to this problem into str.
// Otherwise, just the hidden data field
void CInfer::CreateProblemVisitedText(CString & str, NID nidProblem, bool bShowHistory)
{
	// This code is structured in pieces as sending all of these strings to a single
	// CString::Format() results in a program exception. Did some research into this
	// behavior but did not discover anything.  RAB-981014.
	CString tmpStr;

	tmpStr.Format( _T("%s"), bShowHistory ? m_pTopic->GetNodeFullName(nidProblem) : _T("") );
	str= tmpStr;
	tmpStr.Format( _T("<INPUT TYPE=HIDDEN NAME=%s "), NODE_PROBLEM_ASK ); 
	str+= tmpStr;
	tmpStr.Format( _T("VALUE=%s>"), m_pTopic->GetNodeSymName(nidProblem) );
	str+= tmpStr;
	tmpStr.Format( _T("%s"), bShowHistory ? _T("") : _T("\n") );
	str+= tmpStr;
	str+= _T("\n");
}

// Append a NET property (for Belief Network as a whole, not for one 
//	particular node) to str.
// INPUT/OUTPUT str - string to append to
// INPUT item - Property name
// INPUT szFormat - string to format each successive line.  Should contain one %s, otherwise
//	constant text.
void CInfer::AppendMultilineNetProp(CString & str, LPCTSTR szPropName, LPCTSTR szFormat)
{
	str += m_pTopic->GetMultilineNetProp(szPropName, szFormat);
}

// Like AppendMultilineNetProp, but for a NODE property item, for one particular node.
// INPUT/OUTPUT str - string to append to
// INPUT item - Property name
// INPUT szFormat - string to format each successive line.  Should contain one %s, otherwise
//	constant text.
void CInfer::AppendMultilineNodeProp(CString & str, NID nid, LPCTSTR szPropName, LPCTSTR szFormat)
{
	str += m_pTopic->GetMultilineNodeProp(nid, szPropName, szFormat);
}


// JSM V3.2 Wrapper for AppendMultilineNetProp to make it easier
//  to fill in the Net properties in HTMLFragments
CString CInfer::ConvertNetProp(const CString &strNetPropName)
{
	CString strNetPropVal;
	AppendMultilineNetProp(strNetPropVal,strNetPropName,"%s");
	return strNetPropVal;
}


// If there is a pre-sniffed recommendation, remove it from the list & set m_SniffedRecommendation.
void CInfer::IdentifyPresumptiveCause()
{
	vector<NID> arrnidNoSequence;
	multimap<int, NID> mapSeqToNID;

	// Find all presumptive causes
	for (int i = 0; i < m_SniffedStates.size(); i++)
	{
		if (m_pTopic->IsCauseNode(m_SniffedStates[i].nid())  // cause node ...
			&& 
			m_SniffedStates[i].state() == 1) // ... that is sniffed in abnormal (1) state
		{
			if (IsManuallySniffedNode(m_SniffedStates[i].nid()))
			{
				// now we have manually sniffed cause node in abnormal state.
				// It means that we are re-submitting the page. We will set m_SniffedRecommendation
				//  to this node, and return.
				m_SniffedRecommendation = CNodeStatePair(m_SniffedStates[i].nid(), 1 /*cause node abnormal state*/);
				return;
			}

			NID nid = m_SniffedStates[i].nid();
			CString str = m_pTopic->GetNodePropItemStr(nid, H_NODE_CAUSE_SEQUENCE);
			try
			{
				if (str.IsEmpty())
					arrnidNoSequence.push_back(nid);
				else
				{
					mapSeqToNID.insert(pair<int, NID>(_ttoi(str), nid));
				}
			}
			catch (exception& x)
			{
				CString str;
				// Note STL exception in event log.
				CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
				CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
										SrcLoc.GetSrcFileLineStr(), 
										CCharConversion::ConvertACharToString(x.what(), str),
										_T(""), 
										EV_GTS_STL_EXCEPTION ); 
			}
		}
	}

	// We want the first in sequence according to H_NODE_CAUSE_SEQUENCE numbering.
	// If nothing has a number, we settle for the (arbitrary) first in the array of
	//	unnumbered Cause nodes.
	if (mapSeqToNID.size() > 0)
		m_SniffedRecommendation = CNodeStatePair( (mapSeqToNID.begin()->second), 1 /*cause node abnormal state*/);
	else if (arrnidNoSequence.size() > 0)
		m_SniffedRecommendation = CNodeStatePair( *(arrnidNoSequence.begin()), 1 /*cause node abnormal state*/);

	// now remove the matching nid from the incoming arrays
	if (m_SniffedRecommendation.nid() != nidNil)
	{
		for (i = 0; i < m_BasisForInference.size(); i++)
		{
			if (m_BasisForInference[i].nid() == m_SniffedRecommendation.nid())
			{
				m_BasisForInference.erase(m_BasisForInference.begin() + i);
				break;
			}
		}
		for (i = 0; i < m_SniffedStates.size(); i++)
		{
			if (m_SniffedStates[i].nid() == m_SniffedRecommendation.nid())
			{
				m_SniffedStates.erase(m_SniffedStates.begin() + i);
				break;
			}
		}
		for (i = 0; i < m_arrnidVisited.size(); i++)
		{
			if (m_arrnidVisited[i] == m_SniffedRecommendation.nid())
			{
				m_arrnidVisited.erase(m_arrnidVisited.begin() + i);
				break;
			}
		}
	}
}

// return true if every Cause node in the topic is determined to be normal;
//	this would imply that there is nothing useful this topic can do for us.
bool CInfer::AllCauseNodesNormal()
{
	// for every node in this Belief Network (but taking action only on "cause" nodes)
	// see if each of these is known to be Normal
	for(int nid = 0; nid < m_pTopic->CNode(); nid++)
	{
		if (m_pTopic->IsCauseNode(nid))
		{
			bool bFound=false;

			for (CBasisForInference::iterator p= m_SniffedStates.begin();
				p != m_SniffedStates.end();
				++p)
			{
				if (p->nid() == nid)
				{
					if (p->state() != 0)
						// found a Cause node in an abnormal state (or skipped)
						return false;

					bFound = true;
					break;
				}
			}
			if (!bFound)
				// found a Cause node for which no state is set
				return false;
		}
	}
	return true;
}

// -------------------------------------------------------------
// Writing pieces of the new HTML page.  This builds a structure to be used under HTI 
//	control to represent the recommended node and the (visible or invisible) history table.
// -------------------------------------------------------------
void CInfer::FillInHTMLFragments(CHTMLFragmentsTS &frag)
{
	vector<NID>arrnidPresumptiveCause;

	// First, a side effect: get the URL for the Online TS Start Over link / pseudo-button
	m_strStartOverLink = frag.GetStartOverLink();

	// Then on to the main business at hand.  In practice (at least as of 11/99)
	//	bIncludesHistoryTable and bIncludesHiddenHistory are mutually exclusive, 
	//	but this class doesn't need that knowledge.
	const bool bIncludesHistoryTable = frag.IncludesHistoryTable(); 
	const bool bIncludesHiddenHistory = frag.IncludesHiddenHistory();

	{
		// JSM V3.2: convert the net properties in the HTML fragment
		// The HTI template may indicate that certain net properties are to be written
		//	directly into the resulting page. We get a list of these properties and
		//	fill in a structrue in frag to contain their values.
		CString strNetPropName;
		for(;frag.IterateNetProp(strNetPropName);)
			frag.SetNetProp(strNetPropName,ConvertNetProp(strNetPropName));
	}
	{
		// JM V3.2 to handle sniffing correctly, must do this before history table: sniffing
		//	on the fly (which happens in AppendCurrentNodeText()) could add to the history.
		CString strCurrentNode;
		AppendCurrentNodeText(strCurrentNode);
		frag.SetCurrentNodeText(strCurrentNode);
	}

	CString strHiddenHistory;
	if (m_nidProblem != nidNil)
	{
		CString strProblem;
		CreateProblemVisitedText(strProblem, m_nidProblem, frag.IncludesHistoryTable());

		// OK V3.2 We use hidden field to save the value returned by the "AllowSniffing" 
		//	checkbox (on the problem page) and pass it to each subsequent page.
		// We effectively place this before the history table.
		if (m_pSniff)
			if (m_pSniff->GetAllowAutomaticSniffingPolicy())
				AddAllowAutomaticSniffingHiddenField(strProblem);

		// Added for V3.2 sniffing
		// Not lovely, but this is where we insert sniffed presumptive causes (as hidden
		//	fields).  
		// >>> $MAINT Once we integrate with a launcher, this may require 
		//	further thought: what if we sniff presumptive causes before we have an 
		//	identified problem? Where do we put those hidden fields?
		for (UINT i=0; i<m_arrnidVisited.size(); i++)
		{
			NID nid = m_arrnidVisited[i];
			int stateSet = SNIFF_FAILURE_RESULT;

			{
				UINT nSetNodes = m_SniffedStates.size();
				for (UINT ii = 0; ii < nSetNodes; ii++)
					if (m_SniffedStates[ii].nid() == nid) {
						stateSet = m_SniffedStates[ii].state();
						break;
					}
			}

			if (m_pTopic->IsCauseNode(nid) && stateSet == 1)
			{
				// This is a cause node sniffed as abnormal, to be presented eventually 
				//	as a "presumptive" cause.  All we put in the History table is hidden
				AppendStateText(strProblem, nid, 1, true, false, false, stateSet);
				try
				{
					arrnidPresumptiveCause.push_back(nid);
				}
				catch (exception& x)
				{
					CString str;
					// Note STL exception in event log.
					CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
					CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
											SrcLoc.GetSrcFileLineStr(), 
											CCharConversion::ConvertACharToString(x.what(), str),
											_T(""), 
											EV_GTS_STL_EXCEPTION ); 
				}
			}
		}

		if (bIncludesHistoryTable)
			frag.SetProblemText(strProblem);
		if (bIncludesHiddenHistory)
			strHiddenHistory = strProblem;
	}


	UINT nVisitedNodes = m_arrnidVisited.size();
	// iVisited incremented for every visited node, iHistory only for a subset:
	//	if we have a visible History table, iHistory provides an index of nodes visible
	//	to the end user.  If not, iHistory is a harmless irrelevance
	for (UINT iVisited=0, iHistory=0; iVisited<nVisitedNodes; iVisited++)
	{
		NID nid = m_arrnidVisited[iVisited];
		int nStates = m_pTopic->GetCountOfStates(nid);
		int stateSet = -1;

		if (IsSkipped(nid))
		{
			// "skipped" node.
			// instead of ST_UNKNOWN (==102), stateSet uses the number immediately 
			//	past the last valid state of this node.  Most nodes have only states 
			//	0, 1, and 102 so typically stateSet is set = 2, but a multistate 
			//	node can use a different number
			stateSet = nStates;
		}
		else
		{
			UINT nSetNodes = m_BasisForInference.size();
			for (UINT ii = 0; ii < nSetNodes; ii++)
				if (m_BasisForInference[ii].nid() == nid) {
					stateSet = m_BasisForInference[ii].state();
					break;
				}
		}

		// The following test added for V3.2 sniffing
		// Weed out cause node sniffed as abnormal, to be presented eventually 
		//	as a "presumptive" cause.  Handled above as a hidden field.
		if (find(arrnidPresumptiveCause.begin(), arrnidPresumptiveCause.end(), nid)
			!= arrnidPresumptiveCause.end())
		{
			// cause node sniffed as abnormal
		}
		else
		{
			if (bIncludesHistoryTable)
			{
				CString strVisitedNode;
				AppendVisitedNodeText(strVisitedNode, nid, true);
				frag.PushBackVisitedNodeText(strVisitedNode);
			}

			for (UINT iState=0; iState <= nStates; iState++)
			{
				if (bIncludesHistoryTable)
				{
					CString strState;

					AppendStateText(strState, nid, iState, iState == stateSet, 
									iState == nStates, true, stateSet);

					// If we are processing last state, and we need to attach
					//  hidden field for this node as sniffed one 
					//  (if it ts really sniffed)
					if (iState == nStates)
						AppendHiddenFieldSniffed(strState, nid);

					// We need not have empty entry in CHTMLFragment's array,
					//  describing history table, so by applying "numPresumptiveCauseNodesEncounered"
					//  we make this array continuous
					frag.PushBackStateText(iHistory, strState);
				}
				if (bIncludesHiddenHistory)
				{
					AppendStateText(strHiddenHistory, nid, iState, iState == stateSet, 
									iState == nStates, false, stateSet);

					// same as in case of visible history table applies.
					if (iState == nStates)
						AppendHiddenFieldSniffed(strHiddenHistory, nid);
				}
			}

			if (bIncludesHistoryTable)
			{
				// Check if we need to mark this as visibly sniffed.
				UINT nSniffedNodes = m_SniffedStates.size();
				for (UINT i = 0; i < nSniffedNodes; i++)
				{
					if (m_SniffedStates[i].nid() == nid)
					{
						// mark it visibly as sniffed
						CString strState;
						AppendHistTableSniffedText( strState );
						frag.PushBackStateText(iHistory, strState);
						break;
					}
				}
			}
			iHistory++;
		}
	}

	if (frag.IncludesHiddenHistory())
		frag.SetHiddenHistoryText(strHiddenHistory);

	frag.SetSuccessBool(m_bDone);
}

// Append the text for the current (recommended) node to str
void CInfer::AppendCurrentNodeText(CString & str)
{
	CString strSave = str;

	if (m_nidProblem == nidNil) 
		// show first page (radio-button list of possible problems)
		AppendProblemPage(str);
	else if (m_bDone && !ManuallySniffedNodeExists())
		AppendNIDPage(nidByeNode, str);
	else if ( m_SniffedRecommendation.nid() != nidNil )
		// we already have a recommendation, presumably from a sniffer
		AppendNIDPage(m_SniffedRecommendation.nid(), str);
	else 
	{
		// sniff/resniff all, as needed
		if (RUNNING_LOCAL_TS())
		{
			// Before we mess with m_BasisForInference, determine if the only node with a 
			//	state is the problem node			
			// [BC - 20010301] - Added check for size of skipped node count when setting
			// bHaveOnlyProblem here. This catches case where user selects to skip first
			// node presented, when that node is sniffed in abnormal state.
			bool bHaveOnlyProblem = (m_BasisForInference.size() == 1) &&
									(m_arrnidSkipped.size() == 0);


			if (m_pSniff)
			{
				long nExplicitlySetByUser = 0;
				CBasisForInference arrManuallySniffed; // can contain max 1 element;
													   //  used to prevent resniffing
													   //  of already sniffed node.
				// We need arrayOrderRestorer in order to make sure that when sniffed
				//	nodes are first removed from the array of visited nodes, then restored,
				//	we maintain the same sequence in which nodes were visited in the first 
				//	place.  This order is important in our caching strategy and also provides
				//	a sense of consistency for the end user.
				CArrayOrderRestorer	arrayOrderRestorer(m_arrnidVisited);

				if (ManuallySniffedNodeExists())
				{
					arrManuallySniffed.push_back(m_SniffedStates[m_SniffedStates.size()-1]);
				}
				
				// Remove all sniffed nodes from m_BasisForInference 
				m_BasisForInference -= m_SniffedStates;

				// remove m_SniffedStates from m_arrnidVisited
				m_arrnidVisited -= m_SniffedStates;
				nExplicitlySetByUser = m_arrnidVisited.size();

				if (bHaveOnlyProblem)					
				{
					// sniff all since we're in problem page
					m_pSniff->SniffAll(m_SniffedStates);
				}
				else
				{
					CBasisForInference arrSniffed;

					// resniff all except recently sniffed manually (if any)
					arrSniffed = m_SniffedStates;
					arrSniffed -= arrManuallySniffed;
					m_pSniff->Resniff(arrSniffed);
					arrSniffed += arrManuallySniffed;
					m_SniffedStates = arrSniffed;
				}

				// add updated m_SniffedStates to m_arrnidVisited
				m_arrnidVisited += m_SniffedStates;

				arrayOrderRestorer.Restore(nExplicitlySetByUser, m_arrnidVisited);

				// Add all sniffed nodes into m_BasisForInference
				m_BasisForInference += m_SniffedStates;

				if (bHaveOnlyProblem && AllCauseNodesNormal())
				{
					// We just sniffed at startup & we already know all Cause nodes
					//	are in their normal states. There is absolutely nothing this
					//	troubleshooting topic can do to help this user.
					AppendSniffAllCausesNormalPage(str);
					return;
				}
			}

			// in case that we do not have sniffed recommendation from manual sniffing
			if (m_SniffedRecommendation.nid() == nidNil)
			{
				// Did we get a presumptive cause out of that?
				IdentifyPresumptiveCause();
			}
			if ( m_SniffedRecommendation.nid() != nidNil )
			{
				AppendNIDPage(m_SniffedRecommendation.nid(), str);
				return;
			}
		}

		bool bSniffSucceeded = true;
		while (bSniffSucceeded)
		{
			IST state = -1;
			NID nidNew = nidNil;

			GetRecommendations();

			if (!m_bRecOK)
			{
				str = strSave;
				AppendImpossiblePage(str);
				return;
			}
			else if (m_Recommendations.empty())
			{
				str = strSave;
				AppendNIDPage(nidFailNode, str);
				return;
			}
			else // Have Recommendations
			{
				// Find a recommendation from list of recommendations that is
				// not in the skip list. This is normally the first node in the
				// list.
				int n = m_Recommendations.size();

				for (UINT i=0; i<n; i++) 
				{
					if (!IsSkipped(m_Recommendations[i])) 
					{
						nidNew = m_Recommendations[i];
						str = strSave;
						AppendNIDPage(nidNew, str);
						break;	// out of for loop: just one recommendation is actually 
								// reported back to user.
					}
				}

				// It is our first pass, no sniffed node pages
				//  were composed earlier in this loop
				if (nidNew == nidNil)
				{
					// We fell though if the entire list of recommendations has been skipped
					// via "ST_UNKNOWN" selection by the user.
					if (m_bRecycleSkippedNode)
						RecycleSkippedNode(); // this can affect m_bRecycleSkippedNode

					if (m_bRecycleSkippedNode)
					{
						// The user got the service node earlier and now wants to review
						// the nodes they marked "Unknown".  We already removed the first 
						// "Unknown" node from the skip list and put its NID in 
						// m_nidRecycled. Now we just do a normal display of the page 
						// for that node.
						nidNew = m_nidRecycled;
						str = strSave;
						AppendNIDPage(nidNew, str);
						return;
					}
					else if (!m_arrnidSkipped.empty())
					{
						// We've got "Unknowns", they weren't just in the service page,
						// so give 'em the service page
						str = strSave;
						AppendNIDPage(nidService, str);
						return;
					}
					else
					{
						// no unknowns.  Fail.  Believed never to arise here, but coded
						// this way for safety.
						str = strSave;
						AppendNIDPage(nidFailNode, str);
						return;
					}
				}
			}

			bSniffSucceeded = false;

			// sniffing on the fly
			if (m_pSniff)
				bSniffSucceeded = m_pSniff->SniffNode(nidNew, &state);

			if (bSniffSucceeded)
			{
				// if it's a cause node and was sniffed as abnormal
				if (m_pTopic->IsCauseNode(nidNew) && state == 1)
				{
					// Display this page as a presumptive cause.
					m_SniffedRecommendation = CNodeStatePair( nidNew, state );
					str = strSave;
					AppendNIDPage(nidNew, str);
					return;
				}
				CNodeStatePair nodestateNew(nidNew, state);
				try
				{
					m_SniffedStates.push_back(nodestateNew);
					m_BasisForInference.push_back(nodestateNew);
					m_arrnidVisited.push_back(nidNew);
				}
				catch (exception& x)
				{
					CString str;
					// Note STL exception in event log.
					CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
					CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
											SrcLoc.GetSrcFileLineStr(), 
											CCharConversion::ConvertACharToString(x.what(), str),
											_T(""), 
											EV_GTS_STL_EXCEPTION ); 
				}
			}
		}
	}
}


// Write radio buttons describing what was decided by user in a previous node.  Part 
//	of "the table" (aka "the visited node table" or "table of previous responses").  
//
// Note that Cause nodes are specially handled.  On a cause node:
//	state 0 = "no, this didn't fix it"
//	state 1 = This wasn't OK, so we have a diagnosis.  In that case, we
//		wouldn't be displaying these radio buttons.
//		We don't want the user selecting that value from the history table.
//		We append this only if it's been sniffed and must be presented as a presumptive 
//		cause, and even then we always append it "hidden"
//	state 2 = "skipped"
//
// In other words, on a cause node, the only possibilities we offer to the user through 
//	a visible history table are state 0 () and "skip".  
//
// In the case where a Cause node has been sniffed abnormal, THE CALLING ROUTINE is 
//	responsible to call this only for the abnormal state.  Otherwise, call for all states.
//
// OUTPUT str - string to which we append
// INPUT nid	node of which this is a state
// INPUT state	state number; for ST_UNKNOWN, this is the count of states, not 102
// INPUT bSet	true = this is the current state of this node
// INPUT bSkipped true = this is the "skipped" state, not a normal node state known to BNTS
// INPUT bShowHistory true = we are showing a history table, false = history is stored
//		invisibly in the HTML.
void CInfer::AppendStateText(CString & str, NID nid, UINT state, bool bSet, bool bSkipped, 
							 bool bShowHistory, int nStateSet) 
{
	// Check if this selection worked.  
	// If so only display the "it worked" text in the history table.
	if (m_pTopic->IsCauseNode(nid) && nStateSet == ST_WORKED)
	{
		if (state == 1) // it is presumptive cause ...
			AppendRadioButtonVisited(	str, nid, state, true, 
										m_pTopic->GetStateName(nid, state), bShowHistory);
		return;
	}

	if (bSkipped)
	{
		CString strUnknownLongName = m_pTopic->GetNodePropItemStr(nid, H_ST_UKN_TXT_STR);
		// The following test is per 11/11/99 email from John Locke
		if (HideState(strUnknownLongName))
			return;		// totally omit Unknown from history table: Unknown cannot be
						// selected for this node.

		// Previous calls to AppendStateText have looped through the states known to BNTS; 
		//	now we handle "skipped", which is a concept BNTS lacks.
		CString strUnknown;

		CreateUnknownButtonText(strUnknown);
		AppendRadioButtonVisited(str, nid, ST_UNKNOWN, bSet, strUnknown, bShowHistory);
		return;
	}

	if (m_pTopic->IsCauseNode(nid) && state == 1) // it is presumptive cause ...
	{
		if (IsInSniffedArray(nid)) //... taken from sniffed array, but NOT current node.
		{
			// We are about to add entry for presumptive cause node.
			//  Actually, since this is sniffed node, we need to have two entries:
			//  one hidden fiels with node name and one hidden field with node name 
			//  prefixed by "SNIFFED" prefix.
			if (bSet)
			{
				// "bSet" will always set to true, as sniffed presumptive cause will never
				//  be visible.
				AppendRadioButtonVisited(str, nid, state, bSet, m_pTopic->GetStateName(nid, state), false);
				AppendHiddenFieldSniffed(str, nid);
			}
		}
		return;
	}

	AppendRadioButtonVisited(str, nid, state, bSet, m_pTopic->GetStateName(nid, state), bShowHistory);
	return;
}

// This is used to get the name of a node that has already been visited (for the
//	history table).
// INPUT nid -		node ID of desired node
// OUTPUT str - The "full name" of the node is appended to this, something like
//		"Disable IBM AntiVirus" or "Make all paths less than 66 characters"
//		If its value was sniffed, we append the appropriate string to mark it visibly
//		as sniffed (typically, just "SNIFFED").
// INPUT bShowHistory
//		If !bShowHistory, no appending: no need to show full name in a hidden table.
//		Symbolic name will be written in a hidden field.
// Note that our CString, unlike MFC's, won't throw an exception on += out of memory
// RETURNS true if node number exists
bool CInfer::AppendVisitedNodeText(CString & str, NID nid, bool bShowHistory) const
{
	if (!bShowHistory)
		return true;

	CString strTemp = m_pTopic->GetNodeFullName(nid);
	if ( !strTemp.IsEmpty() )
	{
		str += strTemp;
		return true;
	}
	else
		return false;
}

// -------------------------------------------------------------------
// Writing to the new HTML page.  Representing the recommended node.
// This is what is often called the page, although it is really only part of 
//	the body of the HTML page, along with history.
// -------------------------------------------------------------------

// AppendImpossiblePage:  Gets the body of text that is 
// displayed when the network is in an unreliable state.
void CInfer::AppendImpossiblePage(CString & str) 
{
	CString strHeader, strText;

	strHeader = m_pTopic->GetMultilineNetProp(HTK_IMPOSSIBLE_HEADER, _T("<H4> %s </H4>\n"));
	strText	  = m_pTopic->GetMultilineNetProp(HTK_IMPOSSIBLE_TEXT	, _T("%s "));

	if (!strHeader.IsEmpty() && !strText.IsEmpty())
	{
		str = strHeader + strText + _T("<BR>\n<BR>\n");
	}
	else
	{
		strHeader = m_pTopic->GetMultilineNetProp(HX_FAIL_HD_STR	, _T("<H4> %s </H4>\n"));
		strText	  = m_pTopic->GetMultilineNetProp(HX_FAIL_TXT_STR	, _T("%s "));

		if (!strHeader.IsEmpty() && !strText.IsEmpty())
		{
			str = strHeader + strText + _T("<BR>\n<BR>\n");
		}
		else
		{
			str = SZ_I_NO_RESULT_PAGE;
		}
	}

	//  Make a radio button with name = NODE_IMPOSSIBLE & value = SZ_ST_WORKED
	CString strTemp = m_pTopic->GetNetPropItemStr(HX_IMPOSSIBLE_NORM_STR);
	if (strTemp.IsEmpty()) // fall back on Fail node's property
		strTemp = m_pTopic->GetNetPropItemStr(HX_FAIL_NORM_STR);
	if (!strTemp.IsEmpty())
	{
		if (RUNNING_LOCAL_TS())
			str += "\n<TABLE>";

		AppendRadioButtonCurrentNode(str, NODE_IMPOSSIBLE, SZ_ST_WORKED, strTemp);

		if (RUNNING_LOCAL_TS())
			str += "</TABLE>\n";
	}

	str += _T("<P>");
	AppendActionButtons (str, k_BtnNext|k_BtnBack|k_BtnStartOver);
}

// AppendSniffAllCausesNormalPage:  Gets the body of text that is displayed when sniffing 
// on startup detects that all Cause nodes are in their Normal states.
void CInfer::AppendSniffAllCausesNormalPage(CString & str) 
{
	CString strHeader, strText;

	strHeader = m_pTopic->GetMultilineNetProp(HTK_SNIFF_FAIL_HEADER, _T("<H4> %s </H4>\n"));
	strText	  = m_pTopic->GetMultilineNetProp(HTK_SNIFF_FAIL_TEXT	, _T("%s "));

	if (!strHeader.IsEmpty() && !strText.IsEmpty())
	{
		str = strHeader + strText + _T("<BR>\n<BR>\n");
	}
	else
	{
		strHeader = m_pTopic->GetMultilineNetProp(HX_FAIL_HD_STR	, _T("<H4> %s </H4>\n"));
		strText	  = m_pTopic->GetMultilineNetProp(HX_FAIL_TXT_STR	, _T("%s "));

		if (!strHeader.IsEmpty() && !strText.IsEmpty())
		{
			str = strHeader + strText + _T("<BR>\n<BR>\n");
		}
		else
		{
			str = SZ_I_NO_RESULT_PAGE;
		}
	}

	// Make a radio button with name = NODE_FAILALLCAUSESNORMAL & value = SZ_ST_WORKED
	CString strTemp = m_pTopic->GetNetPropItemStr(HX_SNIFF_FAIL_NORM);
	if (strTemp.IsEmpty()) // fall back on Fail node's property
		strTemp = m_pTopic->GetNetPropItemStr(HX_FAIL_NORM_STR);
	if (!strTemp.IsEmpty())
	{
		if (RUNNING_LOCAL_TS())
			str += "\n<TABLE>";

		AppendRadioButtonCurrentNode(str, NODE_FAILALLCAUSESNORMAL, SZ_ST_WORKED, strTemp);

		if (RUNNING_LOCAL_TS())
			str += "</TABLE>\n";
	}

	str += _T("<P>");
	AppendActionButtons (str, k_BtnNext|k_BtnBack|k_BtnStartOver);
}

// OUTPUT str - string to which we are appending to build HTML page we send back.
// Append (to str) a group of radio buttons, one for each "problem" node in the Belief Network
void CInfer::AppendProblemPage(CString & str)
{
	CString strTemp;

	m_nidSelected = nidProblemPage;
	
	// text to precede list of problems.  Introduced 8/98 for version 3.0.
	// space after %s in next line: see note at head of file
	str += m_pTopic->GetMultilineNetProp(H_PROB_PAGE_TXT_STR, _T("%s "));

	// write problem header.  This is text written as HTML <H4>.
	strTemp.Format(_T("<H4> %s </H4>\n\n"), m_pTopic->GetNetPropItemStr(H_PROB_HD_STR));
	str += strTemp;

	// Write a comment in the HTML in service of automated test program
	str += _T("<!-- IDH = PROBLEM -->\n");
	//str += "<BR>";
	
	if (RUNNING_LOCAL_TS())
		str += "\n<TABLE>";

	AppendProblemNodes(str);

	if (RUNNING_LOCAL_TS())
		str += "\n</TABLE>\n";
			
	if (m_pTopic->UsesSniffer())
	{
		AppendActionButtons (str, k_BtnNext|k_BtnPPSniffing);
	}
	else
	{
		AppendActionButtons (str, k_BtnNext);
	}

	return;
}

// Helper routine for AppendProblemPage
void CInfer::AppendProblemNodes(CString & str)
{
	vector<NID> arrnidNoSequence;
	multimap<int, NID> mapSeqToNID;

	// for every node in this Belief Network (but taking action only on "problem" nodes)
	// put this nid in arrnidNoSequence if it has no sequence number or mapSeqToNID if it
	// has one.
	for(int nid = 0; nid < m_pTopic->CNode(); nid++)
	{
		if (m_pTopic->IsProblemNode(nid))
		{
			CString strSpecial = m_pTopic->GetNodePropItemStr(nid, H_PROB_SPECIAL);
			// if it's not marked as a "hidden" problem, we'll want it in the problem page
			if (strSpecial.CompareNoCase(_T("hide")) != 0)
			{
				CString str = m_pTopic->GetNodePropItemStr(nid, H_NODE_PROB_SEQUENCE);
				try
				{
					if (str.IsEmpty())
						arrnidNoSequence.push_back(nid);
					else
						mapSeqToNID.insert(pair<int, NID>(_ttoi(str), nid));
				}
				catch (exception& x)
				{
					CString str;
					// Note STL exception in event log.
					CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
					CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
											SrcLoc.GetSrcFileLineStr(), 
											CCharConversion::ConvertACharToString(x.what(), str),
											_T(""), 
											EV_GTS_STL_EXCEPTION ); 
				}
			}
		}
	}

	for (multimap<int, NID>::const_iterator ppair=mapSeqToNID.begin();
		 ppair != mapSeqToNID.end();
		 ppair++)
	 {
		// Create a radio button with "ProblemAsk" as its name & this problem
		//	as its value
		AppendRadioButtonCurrentNode(
			str, 
			NODE_PROBLEM_ASK, 
			m_pTopic->GetNodeSymName(ppair->second),
			m_pTopic->GetNodePropItemStr(ppair->second, H_PROB_TXT_STR));
	 }


	for (vector<NID>::const_iterator pnid=arrnidNoSequence.begin();
		 pnid != arrnidNoSequence.end();
		 pnid++)
	{
		// Create a radio button with "ProblemAsk" as its name & this problem
		//	as its value
		AppendRadioButtonCurrentNode(
			str, 
			NODE_PROBLEM_ASK, 
			m_pTopic->GetNodeSymName(*pnid),
			m_pTopic->GetNodePropItemStr(*pnid, H_PROB_TXT_STR));
	}
}

// Append this network's "BYE" page to str
// OUTPUT str - string to append to
void CInfer::AppendByeMsg(CString & str)
{
	str += _T("<!-- &quot;BYE&quot; (success) PAGE -->\n");

	// Write a comment in the HTML in service of automated test program
	str += _T("<!-- IDH = IDH_BYE -->\n");

	// Write this troubleshooter's "Bye" header and text
	// space after %s in next 2 lines: see note at head of file
	AppendMultilineNetProp(str, HX_BYE_HD_STR, _T("<H4> %s </H4>\n"));
	AppendMultilineNetProp(str, HX_BYE_TXT_STR, _T("%s "));
	str += _T("<P>\n");

	AppendActionButtons (str, k_BtnBack|k_BtnStartOver);

	return;
}

// Append this network's "FAIL" page to str 
// OUTPUT str - string to append to
void CInfer::AppendFailMsg(CString & str)
{
	str += _T("<!-- &quot;FAIL&quot; PAGE -->\n");

	// Write a comment in the HTML in service of automated test program
	str += _T("<!-- IDH = IDH_FAIL -->\n");

	// Write this topic's "Fail" header and text
	// space after %s in next 2 lines: see note at head of file
	AppendMultilineNetProp(str, HX_FAIL_HD_STR, _T("<H4> %s </H4>\n"));
	AppendMultilineNetProp(str, HX_FAIL_TXT_STR, _T("%s "));
	str += _T("<BR>\n<BR>\n");
	
	// Make a radio button with name = NODE_FAIL & value = SZ_ST_WORKED
	CString strTemp = m_pTopic->GetNetPropItemStr(HX_FAIL_NORM_STR);
	if (!strTemp.IsEmpty())
	{
		if (RUNNING_LOCAL_TS())
			str += "\n<TABLE>";

		AppendRadioButtonCurrentNode(str, NODE_FAIL, SZ_ST_WORKED, strTemp);

		if (RUNNING_LOCAL_TS())
			str += "</TABLE>\n";
	}

	AppendActionButtons (str, k_BtnNext|k_BtnBack|k_BtnStartOver);

	return;
}

// Append content of the "service" page to str (Offers 2 possibilities: seek help elsewhere 
//	or go back and try something you skipped)
// OUTPUT str - string to append to
void CInfer::AppendServiceMsg(CString & str)
{
	CString strTemp;

	str += _T("<!-- &quot;SERVICE&quot; PAGE -->\n");
	str += _T("<!-- Offers to seek help elsewhere or go back and try something you skipped -->\n");
	// Write a comment in the HTML in service of automated test program
	str += _T("<!-- IDH = SERVICE -->\n");

	// Write this troubleshooter's "Service" header and text
	// space after %s in next 2 lines: see note at head of file
	AppendMultilineNetProp(str, HX_SER_HD_STR, _T("<H4> %s </H4>\n"));
	AppendMultilineNetProp(str, HX_SER_TXT_STR, _T("%s "));
	str += _T("<BR>\n<BR>\n");

	if (RUNNING_LOCAL_TS())
		str += "\n<TABLE>";

	// Make a radio button with name = Service & value = SZ_ST_WORKED
	// Typical text is "I will try to get help elsewhere.";
	strTemp = m_pTopic->GetNetPropItemStr(HX_SER_NORM_STR);
	if (!strTemp.IsEmpty())
		AppendRadioButtonCurrentNode(str, NODE_SERVICE, SZ_ST_WORKED, strTemp);

	// Make a radio button with name = Service & value = SZ_ST_ANY
	// Typical text is "Retry any steps that I have skipped."
	strTemp = m_pTopic->GetNetPropItemStr(HX_SER_AB_STR);
	if (!strTemp.IsEmpty())
		AppendRadioButtonCurrentNode(str, NODE_SERVICE, SZ_ST_ANY, strTemp);

	if (RUNNING_LOCAL_TS())
		str += "</TABLE>\n";

	str += _T("<P>");

	AppendActionButtons (str, k_BtnNext|k_BtnBack|k_BtnStartOver);

	return;
}


// Depending on the value of nid, this fn can build
//	- a BYE page
//	- a FAIL page
//	- a SERVICE page
//	- a page for a normal node (fixable/observable, fixable/unobservable, unfixable, or
//		informational).
// If none of these cases apply, returns with no action taken
// INPUT nid - ID of a node
// OUTPUT str - string to append to
void CInfer::AppendNIDPage(NID nid, CString & str) 
{
	CString strTxt;

	m_nidSelected = nid;

	if (nid == nidByeNode)
		AppendByeMsg(str);
	else if (nid == nidFailNode)
		AppendFailMsg(str);
	else if (nid == nidSniffedAllCausesNormalNode)
		AppendSniffAllCausesNormalPage(str);
	else if (nid == nidService)
		AppendServiceMsg(str);
	else if (m_pTopic->IsValidNID(nid))
	{
		bool bShowManualSniffingButton = false;

		if (m_pSniff)
			if (nid != m_SniffedRecommendation.nid()) 
				// we're NOT showing sniffed node.
				bShowManualSniffingButton = m_pSniff->GetSniffController()->AllowManualSniffing(nid);

		// Write a comment in the HTML in service of automated test program
		str += _T("<!-- IDH = ");
		str += m_pTopic->GetNodeSymName(nid);
		str += _T(" -->\n");

		// Write this node's header & text
		// space after %s in next several lines: see note at head of file
		AppendMultilineNodeProp(str, nid, H_NODE_HD_STR, _T("<H4> %s </H4>\n"));
		if (bShowManualSniffingButton)
			AppendMultilineNodeProp(str, nid, H_NODE_MANUAL_SNIFF_TEXT, _T("%s "));
		if (m_SniffedRecommendation.nid() == nid)
		{
			CString tmp;
			AppendMultilineNodeProp(tmp, nid,  H_NODE_DCT_STR, _T("%s "));
			if (tmp.IsEmpty())
				AppendMultilineNodeProp(str, nid,  H_NODE_TXT_STR, _T("%s "));
			else
				str += tmp;
		}
		else
		{
			AppendMultilineNodeProp(str, nid,  H_NODE_TXT_STR, _T("%s "));
		}
		str += _T("\n<BR>\n<BR>\n");

		// Write appropriate radio buttons depending on what kind of node it is.
		if (m_pTopic->IsCauseNode(nid) || m_pTopic->IsInformationalNode(nid))
			AppendCurrentRadioButtons(nid, str);

		AppendActionButtons (
			str, 
			k_BtnNext|k_BtnBack|k_BtnStartOver|(bShowManualSniffingButton ? k_BtnManualSniffing : 0),
			nid);
	}
	// else nothing we can do with this

	return;
}


// -------------------------------------------------------------------
// BES
// -------------------------------------------------------------------

// Historically:
// Returns true if we are supposed to show the full BES page (& let the user edit the 
//	search string) vs. extracting the search string & starting the search without
//	any possible user intervention
// However, we no longer offer that option as of 981021.
bool CInfer::ShowFullBES()
{
	return false;
}

// returns true in the circumstances where we wish to show a Back End Search 
bool CInfer::TimeForBES()
{
	return (m_pTopic->HasBES() && m_bUseBackEndRedirection);
}
 
// If it is time to do a Back End Search redirection, append the "redirection" string 
//	to str and return true
// Otherwise, return false
// str should represent the header of an HTML page.
// For browsers which support redirection, this is how we overide service node (or fail node) 
//	when BES is present
bool CInfer::AppendBESRedirection(CString & str)
{
	if (m_pTopic->HasBES() && TimeForBES() && !ShowFullBES() && !m_strEncodedForm.IsEmpty()) 
	{
		str += _T("Location: ");
		str += m_strEncodedForm;
		str += _T("\r\n");
		return( true );				
	}

	return false;
}

// Append HTML representing BES to OUTPUT str and build m_strEncodedForm, 
// This is a distinct new algorithm in Ver 3.0, replacing the old "word list" approach.
void CInfer::OutputBackend(CString & str)
{
	vector<CString>arrstrSearch;

	int nNodesInBasis = m_BasisForInference.size();

	for (int i = 0; i<nNodesInBasis; i++)
	{
		NID nid = m_BasisForInference[i].nid();
		IST state = m_BasisForInference[i].state();

		CString strSearchState;

		// First account for binary nodes w/ special property names
		if (state == 0) 
			strSearchState = m_pTopic->GetNodePropItemStr(nid, H_NODE_NORM_SRCH_STR);
		else if (state == 1) 
			strSearchState = m_pTopic->GetNodePropItemStr(nid, H_NODE_AB_SRCH_STR);
		else 
			strSearchState = _T("");

		if (strSearchState.IsEmpty())
			// multistate node
			strSearchState = m_pTopic->GetNodePropItemStr(nid, MUL_ST_SRCH_STR, state);

		if (! strSearchState.IsEmpty())
		{
			try
			{
				arrstrSearch.push_back(strSearchState);
			}
			catch (exception& x)
			{
				CString str;
				// Note STL exception in event log.
				CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
				CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
										SrcLoc.GetSrcFileLineStr(), 
										CCharConversion::ConvertACharToString(x.what(), str),
										_T(""), 
										EV_GTS_STL_EXCEPTION ); 
			}
		}
	}

	// Build the full BES page
	CString strRaw;

	m_pTopic->GenerateBES(arrstrSearch,	m_strEncodedForm, strRaw);
	str += strRaw;
}


// -------------------------------------------------------------
// Logging
// -------------------------------------------------------------

  
// Return NID of page ultimately selected.  If no such page, returns nidNil.
NID CInfer::NIDSelected() const
{
	return m_nidSelected;
}

// -------------------------------------------------------------
// Effectively, a method on m_arrnidSkipped
// -------------------------------------------------------------
// INPUT nid
// RETURNS true if nid is node in the "skip list" (ST_UNKNOWN, "Try something else").
bool CInfer::IsSkipped(NID nid) const
{
	vector<NID>::const_iterator itBegin= m_arrnidSkipped.begin();
	vector<NID>::const_iterator itEnd= m_arrnidSkipped.end();

	return (find(itBegin, itEnd, nid) != itEnd);
}

// -------------------------------------------------------------
// Buttons
// -------------------------------------------------------------
// appends only <INPUT TYPE=...> clause
void CInfer::AppendNextButton(CString & str) const
{
	str += SZ_INPUT_TAG_NEXT;  // _T("<INPUT tag=next TYPE=SUBMIT VALUE=\"")
	AppendNextButtonText(str);
	str += _T("\">");
}

// For local TS, appends only <INPUT TYPE=...> clause
// For Online TS, must build a pseudo button.
void CInfer::AppendStartOverButton(CString & str) const
{
	if (RUNNING_LOCAL_TS())
	{
		str += SZ_INPUT_TAG_STARTOVER;  // _T("<INPUT tag=startover TYPE=BUTTON VALUE=\"")
		AppendStartOverButtonText(str);
		str += _T("\" onClick=\"starter()\">");
	}
	else
	{
		// Added for V3.2
		CString strLabel;		// visible label for pseudo button

		AppendStartOverButtonText(strLabel);
		
		AppendLinkAsButton(str, m_strStartOverLink, strLabel);
	}
}

// appends only <INPUT TYPE=...> clause
void CInfer::AppendBackButton(CString & str) const
{
	if (RUNNING_LOCAL_TS())
	{
		str += SZ_INPUT_TAG_BACK;  // _T("<INPUT tag=back TYPE=BUTTON VALUE=\"")
		AppendBackButtonText(str);
		str += _T("\" onClick=\"generated_previous()\">");
	}
}

// AppendManualSniffButton will generate script something like this, but this 
//	comment is not being carefully maintained, so see actual code for details.
/////////////////////////////////////////////////////////////////////////////
//	function sniffManually() {											   //
//		var stateSniffed = parent.t3.PerformSniffingJS("NodeName", "", "");//
//																		   //
//		if(stateSniffed == -1) {										   //
//			stateSniffed = parent.t3.PerformSniffingVB("NodeName", "", "");//
//		}																   //
//																		   //
//		if(stateSniffed == -1) {										   //
//			alert("Could not sniff this node");							   //
//		} else {														   //
//			if(stateSniffed > NumOfStates) {							   //
//				alert("Could not sniff this node");						   //
//			} else {													   //
//				///////////////////////////////////////////////////////	   //
//				IF IS CAUSE NODE:										   //
//				if (stateSniffed == 1)									   //
//					document.all.Sniffed_NodeName.value = 101;			   //
//				else													   //
//					document.all.Sniffed_NodeName.value = stateSniffed;	   //
//				///////////////////////////////////////////////////////	   //
//				IF IS NOT CAUSE NODE:								       //
//				document.all.Sniffed_NodeName.value = stateSniffed;		   //
//				///////////////////////////////////////////////////////	   //
//				document.all.NodeState[stateSniffed].checked = true;	   //
//				document.ButtonForm.onsubmit();							   //
//			}															   //
//		}																   //
//	}																	   //
/////////////////////////////////////////////////////////////////////////////
void CInfer::AppendManualSniffButton(CString & str, NID nid) const
{
	if (RUNNING_LOCAL_TS())
	{
		CString strNodeName;
		CString strTmp;
		SymbolicFromNID(strNodeName, nid);
		bool bIsCause = m_pTopic->IsCauseNode(nid);
		
		str += _T(
			"\n\n<script language=\"JavaScript\">\n"
			"function sniffManually() {\n"
			"    var stateSniffed = parent.t3.PerformSniffingJavaScript(\"");
		str += strNodeName;
		str += _T(
			"\", \"\", \"\");\n");

		str += _T(
			"	 if(stateSniffed == -1) {\n"
			"		 stateSniffed = parent.t3.PerformSniffingVBScript(\"");
		str += strNodeName;
		str += _T(
			"\", \"\", \"\");\n"
		    "}\n");

		str += _T(	
			"    if(stateSniffed == -1) {\n"
			"        alert(\"");
		AppendSniffFailedText(str);
		str += _T(
			"\");\n"
			"    } else {\n"
			"        if(stateSniffed >"); 

		CString strStates;
		strStates.Format(_T("%d"), m_pTopic->GetCountOfStates(nid) -1);
		str += strStates;

		str += _T(
			") {\n"
			"            alert(\"");
		AppendSniffFailedText(str);
		str += _T(
			"\");\n"
			"        } else {\n");
		if (bIsCause)
		{
			str += _T(
				"            if (stateSniffed == 1)\n"
				"			     document.all.");
			str += C_SNIFFTAG;	
			str += strNodeName;
			str += _T(".value = ");
			str += SZ_ST_WORKED;
			str += _T(";\n");
			str += _T(
				"            else\n");
		}
		str += _T(
			"            document.all.");
		str += C_SNIFFTAG;	
		str += strNodeName;
		str += _T(".value = stateSniffed;\n");

		str += _T(
			"            document.all.");
		str += C_LAST_SNIFFED_MANUALLY;	
		str += _T(".value = "); 
		str += SZ_ST_SNIFFED_MANUALLY_TRUE;
		str += _T(";\n");


		str += _T(
			"            document.all.");
		str += strNodeName;
		str += _T(	
			"[stateSniffed].checked = true;\n");

		str += _T(
			"            document.ButtonForm.onsubmit();\n");

		str += _T(
			"        }\n"
			"    }\n"
			"}\n"
			"</script>\n\n");
		
		str += _T(
			"<INPUT tag=sniff TYPE=BUTTON VALUE=\"");
		AppendManualSniffButtonText(str);
		str += _T(
			"\" onClick=\"sniffManually()\">\n");

		str += _T(
			"<INPUT type=\"HIDDEN\" name=\"");
		str += C_SNIFFTAG;
		str += strNodeName;
		str += _T("\" value=\"");
		strTmp.Format(_T("%d"), SNIFF_FAILURE_RESULT);
		str += strTmp;
		str += _T("\">\n");

		str += _T(
			"<INPUT type=\"HIDDEN\" name=\"");
		str += C_LAST_SNIFFED_MANUALLY;
		str += _T("\" value=\"");
		str += SZ_ST_SNIFFED_MANUALLY_FALSE;
		str += _T("\">\n");
	}
}

// appends only <INPUT TYPE=...> clause
void CInfer::AppendPPSnifferButton(CString & str) const
{
	str += SZ_INPUT_TAG_SNIFFER;  // _T("<INPUT tag=sniffer TYPE=BUTTON VALUE=\"")
	AppendPPSnifferButtonText(str);
	str += _T("\" onClick=\"runtest()\">");
}


void CInfer::AppendActionButtons(CString & str, ActionButtonSet btns, NID nid /*=-1*/) const
{
	// Online TS's Start Over "button" is actually a link, and will implicitly
	//	start a new line unless we do something about it.
	bool bGenerateTable = (!RUNNING_LOCAL_TS() && (btns & k_BtnStartOver));

	if (bGenerateTable)
		str += _T("<TABLE><tr><td>");

	if (btns & k_BtnNext)
	{
		AppendNextButton(str);
		str += _T("\n");
	}

	if (btns & k_BtnBack)
	{
		AppendBackButton(str);
		str += _T("\n");
	}

	if (bGenerateTable)
		str += _T("</td><td>");


	if (btns & k_BtnStartOver)
	{
		AppendStartOverButton(str);
		str += _T("\n");
	}

	if (bGenerateTable)
		str += _T("</td><td>");

	if (btns & k_BtnPPSniffing)
	{
		AppendPPSnifferButton(str);
		str += _T("\n");
	}

	if ((btns & k_BtnManualSniffing) && nid != -1)
	{
		AppendManualSniffButton(str, nid);
		str += _T("\n");
	}

	if (bGenerateTable)
		str += _T("</td></tr></TABLE>");

	str += _T("<BR><BR>");
}

// -------------------------------------------------------------
// MISCELLANY
// -------------------------------------------------------------

// RETURN true for cause (vs. informational or problem) node.
// Note that a cause may be either a fixable node or an "unfixable" node which 
//	"can be fixed with infinite effort"
/* static */ bool CInfer::IsCause (ESTDLBL lbl)
{
	return (lbl == ESTDLBL_fixobs || lbl == ESTDLBL_fixunobs || lbl == ESTDLBL_unfix);
}	


// This code can take a previously skipped node and bring it back again as a recommendation.  
// It is relevant only if the user received the service node in the previous call 
//	to the DLL and now wants to see if there is "Anything Else I Can Try".
//
// This code will remove the first node from the skip list so that it may be delivered to 
// the user again.
// 
// Of course, m_arrnidSkipped, m_arrnidVisited must be filled in before this is called.
//
void CInfer::RecycleSkippedNode()
{
	// Only should take effect once per instance of this object, because peels the first
	//	entry off of m_arrnidSkipped.  We guarantee that with the following:
	if (m_bRecyclingInitialized)
		return;

	m_bRecyclingInitialized = true;

	// Only relevant if the query asks for a previously skipped node brought back again 
	//	as a recommendation.  
	if (!m_bRecycleSkippedNode)
		return;

	// This is a safety check to bail out if there are no skipped nodes.
	// This would be a bogus query, because the Service Node should only have been
	//	offered if there were skipped recommendations to try.
	if (m_arrnidSkipped.empty())
	{
		m_bRecycleSkippedNode = false;
		return;
	}

	// OK,now down to business.

	// Get a value for m_nidRecycled from the first item skipped
	m_nidRecycled = m_arrnidSkipped.front();

	// Remove skipped item from skip table
	m_arrnidSkipped.erase(m_arrnidSkipped.begin());

	// Fix table of nodes that will be placed into the output table
	// to not include the first node skipped

	vector<NID>::const_iterator itnidBegin = m_arrnidVisited.begin();
	vector<NID>::const_iterator itnidEnd = m_arrnidVisited.end();
	vector<NID>::const_iterator itnidAnythingElse = find(itnidBegin, itnidEnd, m_nidRecycled);

	if (itnidAnythingElse != itnidEnd)
		m_arrnidVisited.erase( const_cast<vector<NID>::iterator>(itnidAnythingElse) ); 
}

bool CInfer::ManuallySniffedNodeExists() const
{
	// If last element in m_BasisForInference is sniffed,
	//  it means, that this element was set by manual sniffing
	//  function.
	if (m_BasisForInference.size() && m_SniffedStates.size())
		return m_bLastSniffedManually;
	return false;
}

bool CInfer::IsManuallySniffedNode(NID nid) const
{
	if (ManuallySniffedNodeExists())
		return nid == m_SniffedStates[m_SniffedStates.size()-1].nid();
	return false;
}

void CInfer::SetLastSniffedManually(bool set)
{
	m_bLastSniffedManually = set;
}

// -------------------------------------------------------------------
// CInfer::CArrayOrderRestorer implementation
// -------------------------------------------------------------------
//
// CInfer::CArrayOrderRestorer exists so that after re-sniffing, we can restore an array
//	of visited nodes to its original order, as saved in m_arrInitial.
//
// INPUT: nBaseLength = number of elements in fixed locations at head of array, which will 
//		never be moved (typically nodes explicitly set by user rather than sniffed).
// INPUT/OUTPUT: arrToRestore = array to restore: input dictates content of output, but 
//		(beyond nBaseLength) does not dictate the order. Order comes from m_arrInitial.
// OUTPUT: arrToRestore = array with restored order
// RETURN: true if successful
bool CInfer::CArrayOrderRestorer::Restore(long nBaseLength, vector<NID>& arrToRestore)
{
	if (nBaseLength > arrToRestore.size())
		return false;

	long i;
	vector<NID>::iterator i_base;
	vector<NID>::iterator i_additional;
	vector<NID> arrBase;
	vector<NID> arrAdditional;

	try
	{
		for (i = 0; i < nBaseLength; i++)
			arrBase.push_back(arrToRestore[i]);

		for (i = nBaseLength; i < arrToRestore.size(); i++)
			arrAdditional.push_back(arrToRestore[i]);
	}
	catch (exception& x)
	{
		CString str;
		// Note STL exception in event log.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								CCharConversion::ConvertACharToString(x.what(), str),
								_T(""), 
								EV_GTS_STL_EXCEPTION ); 
	}

	arrToRestore.clear();

	for (i = 0, i_base = arrBase.begin();
	     i < m_arrInitial.size(); 
		 i++)
	{
		if (arrBase.end() != find(arrBase.begin(), arrBase.end(), m_arrInitial[i]))
		{
			if (i_base != arrBase.end())
				i_base++;
		}
		else if (arrAdditional.end() != (i_additional = find(arrAdditional.begin(), arrAdditional.end(), m_arrInitial[i])))
		{
			i_base = arrBase.insert(i_base, m_arrInitial[i]);
			i_base++;
			arrAdditional.erase(i_additional);
		}
	}

	arrToRestore = arrBase;

	try
	{
		for (i = 0; i < arrAdditional.size(); i++)
			arrToRestore.push_back(arrAdditional[i]);
	}
	catch (exception& x)
	{
		CString str;
		// Note STL exception in event log.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								CCharConversion::ConvertACharToString(x.what(), str),
								_T(""), 
								EV_GTS_STL_EXCEPTION ); 
	}
	
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\apgtslog.h ===
//
// MODULE: APGTSLOG.H
//
// PURPOSE: User Activity Logging Utility
//	Fully implements class CHTMLLog
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Roman Mach
// 
// ORIGINAL DATE: 8-2-96
//
// NOTES: 
// 1. Based on Print Troubleshooter DLL
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V3.0		9/21/98		JM		Pulled into separate file
//

#ifndef _H_APGTSLOG
#define _H_APGTSLOG

#include "apgtsstr.h"


#define LOGFILEPREFACE			_T("gt")
#define MAXLOGSBEFOREFLUSH		5
#define MAXLOGSIZE				1000

class CPoolQueue;
//
//
class CHTMLLog 
{
public:
    static void SetUseLog(bool bUseLog);

public:
	CHTMLLog(const TCHAR *);
	~CHTMLLog();
	
	DWORD NewLog(LPCTSTR data);
	DWORD GetStatus();

	// Access function to enable the registry monitor to change the logging file directory.
	void SetLogDirectory( const CString &strNewLogDir );	

	// testing only
	DWORD WriteTestLog(LPCTSTR szAPIName, DWORD dwThreadID);

protected:
	DWORD FlushLogs();
	void Lock();
	void Unlock();

protected:
	static bool s_bUseHTMLLog;

protected:
	CRITICAL_SECTION m_csLogLock;			// must lock to write to log file

	CString *m_buffer[MAXLOGSBEFOREFLUSH];	// Array of separate strings to log, held here
											//  till we flush
											// Note this is our CString, not MFC - 10/97
	UINT m_bufindex;						// index into m_buffer, next slot to write to.
											// incremented after writing; when it reaches
											// MAXLOGSBEFOREFLUSH, we flush
	DWORD m_dwErr;							// Latest error. NOTE: once this is set nonzero, it 
											// can never be cleared & logging is effectively
											// disabled.
	CString m_strDirPath;			// directory in which we write log files.
};

#endif // _H_APGTSLOG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\apgtsinf.h ===
//
// MODULE: APGTSINF.H
//
// PURPOSE: Inference support header
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Roman Mach, Joe Mabel
// 
// ORIGINAL DATE: 8-2-96
//
// NOTES: 
// 1. Based on Print Troubleshooter DLL
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V3.0		7-21-98		JM		Major revision, deprecate IDH in favor of NID, use STL.
//

#if !defined(APGTSINF_H_INCLUDED)
#define APGTSINF_H_INCLUDED

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "propnames.h"
#include "topic.h"


using namespace std;

#define MAXBUF	256				// length of text buffers used for filenames,
								// IP adresses (this is plenty big), HTTP response ( like
								// "200 OK", again, plenty big), registry keys, 
								// and occasionally just to format an arbitrary string.

//--------------------------------------------------------------------
// Default Values for localizable text
#define SZ_UNKNOWN _T("Unknown")
#define SZ_NEXT_BTN _T("Next")
#define SZ_START_BTN _T("StartOver")
#define SZ_BACK_BTN _T("Back")
#define SZ_PP_SNIF_BTN _T("Investigate")
//#define SZ_I_NO_RESULT_PAGE _T("<HR>Not Enough Information was available to provide a useful result\n <BR>It is also possible that the information you provided is not correct, please check your entries\n <BR>Please amend your choices\n <P><INPUT TYPE=SUBMIT VALUE=\"Continue\"><BR>")
#define SZ_I_NO_RESULT_PAGE _T("<HR>This troubleshooter can't diagnose the cause of your problem based on the information you have provided.\n <BR>Either start the troubleshooter over, change your answers in the table and continue, or search for other resources.\n <P><INPUT TYPE=SUBMIT VALUE=\"Continue\"><BR>")

#define SZ_HIST_TABLE_SNIFFED_TEXT _T("INVESTIGATED")
#define SZ_ALLOW_SNIFFING_TEXT _T("I want the troubleshooter to investigate settings on this computer")
#define SZ_SNIFF_ONE_NODE _T("Investigate")
#define SZ_SNIFF_FAILED _T("The troubleshooter was unable to investigate the necessary settings.  Follow the remaining instructions on this page to complete the task manually.")

#define SZ_INPUT_TAG_NEXT		  _T("<INPUT tag=next TYPE=SUBMIT VALUE=\"")
#define SZ_INPUT_TAG_STARTOVER	  _T("<INPUT tag=startover TYPE=BUTTON VALUE=\"")
#define SZ_INPUT_TAG_BACK		  _T("<INPUT tag=back TYPE=BUTTON VALUE=\"")
#define SZ_INPUT_TAG_SNIFFER	  _T("<INPUT tag=sniffer TYPE=BUTTON VALUE=\"")

// Text forms of some special state values
#define SZ_ST_FAILED	_T("0")		// "failed" on fixable node is considered normal
// 101 - Go to "Bye" Page (User succeeded)
#define SZ_ST_WORKED	_T("101")
// 102 - Unknown (user doesn't know the correct answer here - applies to Fixable/Unfixable and 
//	Info nodes only)
#define SZ_ST_UNKNOWN	_T("102")
// 103 - "Anything Else?"  (effectively, "retry a skiped node?"
#define SZ_ST_ANY		_T("103") 
// 
#define SZ_ST_SNIFFED_MANUALLY_TRUE		_T("true") 
// 
#define SZ_ST_SNIFFED_MANUALLY_FALSE	_T("false") 


class CSniffConnector;
class CSniff;
//
class CInfer
{
	// This class is an instrument to restore m_arrInitial - like order of 
	//  elements in array, passed to its "Restore" function
	class CArrayOrderRestorer
	{
		vector<NID> m_arrInitial;
		
	public:
		CArrayOrderRestorer(const vector<NID>& initial) : m_arrInitial(initial) {}

	public:
		bool Restore(long base_length, vector<NID>& arr_to_restore);
	};
	
  public:
	CInfer(CSniffConnector* pSniffConnector);
	~CInfer();

	int INode(LPCTSTR sz) {return m_pTopic->INode(sz);};
		
	void	SetTopic(CTopic *pTopic);
	
	void	SetNodeState(NID nid, IST ist);
	void	AddToSniffed(NID nid, IST ist);

	void	IdentifyPresumptiveCause();
	void	FillInHTMLFragments(CHTMLFragmentsTS &frag);

	bool	AppendBESRedirection(CString & str);

	NID		NIDFromIDH(IDH idh) const;	
	NID		NIDSelected() const;

	CSniff* GetSniff();

	void    SetLastSniffedManually(bool);

private:
	enum ActionButtons {
		k_BtnNext = 0x01, 
		k_BtnBack = 0x02, 
		k_BtnStartOver = 0x04, 
		k_BtnPPSniffing = 0x08,		// Problem Page sniff button for expensive sniffing
									//	of multiple nodes
		k_BtnManualSniffing = 0x10,	// for manual sniffing of a single node
	};
	typedef UINT ActionButtonSet;		// should be an OR of 0 or more ActionButtons

private:
	bool	IsProblemNode(NID nid) const;
	void	AddToBasisForInference(NID nid, IST ist);
	void	GetRecommendations();
	void	RecycleSkippedNode();
	bool	AllCauseNodesNormal();
	bool    IsInSniffedArray(NID nid) const;
	bool    IsPresumptiveCause(NID nid) const;

	void	CreateUnknownButtonText(CString & strUnknown) const;
	void	AppendNextButtonText(CString & str) const;
	void	AppendBackButtonText(CString & str) const;
	void	AppendPPSnifferButtonText(CString & str) const;
	void	AppendStartOverButtonText(CString & str) const;
	void	AppendManualSniffButtonText(CString & str) const;
	void	AppendHistTableSniffedText(CString & str) const;
	void	AppendAllowSniffingText(CString & str) const;
	void	AppendSniffFailedText(CString & str) const;
	
	void	AppendActionButtons(CString & str, ActionButtonSet btns, NID nid = -1) const;
	void    AppendNextButton(CString & str) const;
	void    AppendStartOverButton(CString & str) const;
	void    AppendBackButton(CString & str) const;
	void    AppendPPSnifferButton(CString & str) const;
	void	AppendManualSniffButton(CString & str, NID nid) const;
	
	void	AppendMultilineNetProp(CString & str, LPCTSTR szPropName, LPCTSTR szFormat);
	void	AppendMultilineNodeProp(CString & str, NID nid, LPCTSTR szPropName, LPCTSTR szFormat);
	void	AppendCurrentRadioButtons(NID nid, CString & str);
	static void AppendRadioButtonCurrentNode(
				CString &str, LPCTSTR szName, LPCTSTR szValue, LPCTSTR szLabel, bool bChecked =false);
	void	AppendRadioButtonVisited(CString &str, NID nid, UINT value, bool bSet, 
				LPCTSTR szLabel, bool bShowHistory) const;
	void	CreateProblemVisitedText(CString & str, NID nidProblem, bool bShowHistory);
	bool	AppendVisitedNodeText(CString & str, NID nid, bool bShowHistory) const; 
	void	AppendStateText(CString & str, NID nid, UINT state, bool bSet, bool bSkipped, 
							bool bShowHistory, int nStateSet);
	void    AppendHiddenFieldSniffed(CString &str, NID nid) const;
	void    AddAllowAutomaticSniffingHiddenField(CString &str) const;
	void	AppendCurrentNodeText(CString & str);
	void	AppendByeMsg(CString & str);
	void	AppendFailMsg(CString & str);
	void	AppendServiceMsg(CString & str);
	void	AppendNIDPage(NID nid, CString & str);
	void	AppendImpossiblePage(CString & str);
	void	AppendSniffAllCausesNormalPage(CString & str);
	void	AppendProblemPage(CString & str);
	void	AppendProblemNodes(CString & str);
	void	AppendLinkAsButton(
				CString & str, 
				const CString & strTarget, 
				const CString & strLabel) const;

	// JSM V3.2 wrapper for AppendMultilineNetProp() used by FillInHTMLFragments()
	CString ConvertNetProp(const CString &strNetPropName);

	bool	ShowFullBES();
	bool	TimeForBES();
	void	OutputBackend(CString & str);

	static bool	HideState(LPCTSTR szStateName);
	bool	SymbolicFromNID(CString & str, NID nid) const; 
	static bool IsCause (ESTDLBL lbl);
	bool	IsSkipped(NID nid) const;

	bool    ManuallySniffedNodeExists() const;
	bool    IsManuallySniffedNode(NID nid) const;

private:

	CTopic	*m_pTopic;			// associated belief network

	CSniff  *m_pSniff;			// associated sniffing object

// History, extracted from the query from the user.
// All this is known _before_ we seek a recommendation.

	CBasisForInference m_BasisForInference;	// tie together nodes & their states; excludes
											// skipped nodes
	CBasisForInference m_SniffedStates;	// tie together successfully sniffed nodes & their states 
	vector<NID> m_arrnidSkipped;		// nodes for which the user has been unable to give
										// a yes or no answer (or, in the case of multistate,
										// any useful answer at all).
	vector<NID> m_arrnidVisited;		// node numbers of recommendations the user has visited
										// This includes skipped nodes, but excludes the selected problem
										// and excludes pseudo-nodes like the FAIL node.
	NID m_nidProblem;					// problem node indicated by user request.  
										//	set to nidNil if no problem node yet specified.
	bool	m_bDone;					// TRUE ==> we got back state ST_WORKED (better be 
										//	for the last node in the list!) so it's time to 
										//	show the BYE page

	CString m_strStartOverLink;			// For Online TS, URL of Problem page

// Recommendations
	CRecommendations m_Recommendations;  // new recommendations.  We only care about the  
							//	first recommendation not already offered and skipped.
	bool m_bRecOK;			// true ==> m_Recommendations is valid.  (Can be valid and
							//	empty if nothing to recommend).
	CNodeStatePair m_SniffedRecommendation;	// if a recommendation from a sniffer overrides normal;
							// method of getting a recommendation, here's where we store it.
							// Otherwise, nidNil.
							// Because this is always a Cause node in its abnormal state,
							// it is actually redundant (but harmless) to track state as
							// well as node ID.

// Back End Search
	bool	m_bUseBackEndRedirection;// Set true when user asks for Back End Search
	CString m_strEncodedForm;	// URL-encoded search form (like the contents of a Get-method
								//	query).  This is built as a side effect when we construct
								//	the full BES page.

// Variables related to re-offering a previously skipped node
	bool	m_bRecycleSkippedNode;	// Set TRUE if user (responding to service node) wants  
									// to revisit a previously skipped node.  May be set false
									// if we discover there is no such node to revisit.
	NID		m_nidRecycled;			// Node to use if m_bRecycleSkippedNode is TRUE
	bool	m_bRecyclingInitialized;// Protects against multiple calls to RecycleSkippedNode()

// ------------- Misc -------------

	NID		m_nidSelected;		// once we work out what node to show the user, we keep this
								//	around for logging.

	bool    m_bLastSniffedManually; // identifies that last node was sniffed manually
};

#endif // !defined(APGTSINF_H_INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\apgtslog.cpp ===
//
// MODULE: APGTSLOG.CPP
//
// PURPOSE: User Activity Logging Utility
//	Fully implements class CHTMLLog
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Roman Mach
// 
// ORIGINAL DATE: 8-2-96
//
// NOTES: 
// 1. Based on Print Troubleshooter DLL
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
//


#include "stdafx.h"
#include "apgtslog.h"
#include "event.h"
#include "apgts.h"
#include "baseexception.h"
#include "CharConv.h"
#include <vector>

using namespace std;

bool CHTMLLog::s_bUseHTMLLog = false;// Online Troubleshooter, will promptly set this 
									 //	true in DLLMain.  For Local Troubleshooter,
									 //	we leave this false.

/*static*/ void CHTMLLog::SetUseLog(bool bUseLog)
{
	s_bUseHTMLLog = bUseLog;
}

// INPUT dirpath: directory where we write log files
// If can't allocate memory, sets some m_buffer[i] values to NULL, sets m_dwErr 
//	EV_GTS_ERROR_LOG_FILE_MEM, but still returns normally.  Consequently, there's really 
//	no way for the caller to spot a problem, except by calling CHTMLLog::GetStatus after
//	_every_ call to this function.
CHTMLLog::CHTMLLog(const TCHAR *dirpath) :
	m_bufindex(0),
	m_dwErr(0),
	m_strDirPath(dirpath)
{
	::InitializeCriticalSection( &m_csLogLock );
	
	for (UINT i=0;i<MAXLOGSBEFOREFLUSH;i++)
	{
		try
		{
			m_buffer[i] = new CString();
		}
		catch (bad_alloc&)
		{
			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									_T(""), _T(""), EV_GTS_CANT_ALLOC ); 
			m_dwErr = EV_GTS_ERROR_LOG_FILE_MEM;
			// note that once this error is set we cannot log at all, not even using
			//  the previous positions in m_buffer
			break;
		}
	}
}

//
//
CHTMLLog::~CHTMLLog()
{
	FlushLogs();

	for (UINT i=0;i<MAXLOGSBEFOREFLUSH;i++) 
		if (m_buffer[i] != NULL)
			delete m_buffer[i];

	::DeleteCriticalSection( &m_csLogLock );
}

//
//
DWORD CHTMLLog::GetStatus()
{
	return m_dwErr;
}

//
// Write *data to log buffer, flush if max'd
DWORD CHTMLLog::NewLog(LPCTSTR data)
{
	DWORD dwErr = 0;

	if (m_dwErr)
		return m_dwErr;

    Lock();

	// copy data
	*m_buffer[m_bufindex] += data;
	m_bufindex++;
	if (m_bufindex == MAXLOGSBEFOREFLUSH) {

		// flush logs
		dwErr = FlushLogs();
		m_bufindex = 0;
	}
	Unlock();
	return dwErr;
}

// Flush to a log file.  Name of log file is based on date/time of write.
// RETURNS a (possibly preexisting) error status
// NOTE: does not reset m_bufindex.  Caller must do that.
DWORD CHTMLLog::FlushLogs()
{
	if (!s_bUseHTMLLog)
		return (0);
	
	if (m_dwErr)
		return m_dwErr;

	if (m_bufindex) {
		UINT i;
		FILE *fp;
		TCHAR filepath[300];
		SYSTEMTIME SysTime;

		// get time (used to be System Time, use local)
		GetLocalTime(&SysTime);

		_stprintf(filepath,_T("%s%s%02d%02d%02d.log"),
							(LPCTSTR)m_strDirPath,
							LOGFILEPREFACE,
							SysTime.wYear % 100,
							SysTime.wMonth,
							SysTime.wDay);

		fp = _tfopen(filepath,_T("a+"));
		if (fp) {
			for (i=0;i<m_bufindex;i++) 
			{
				// Don't totally understand why the following needs a GetBuffer (after all,
				//	it just reads the CString) but Bug#1204 arose when we tried 
				//	(const void*)(LPCTSTR)m_buffer[i] instead of m_buffer[i]->GetBuffer(0).
				//	Leave it this way: can't be bad.  JM/RAB 3/2/99
				fwrite( m_buffer[i]->GetBuffer(0), m_buffer[i]->GetLength(), 1, fp );
				m_buffer[i]->ReleaseBuffer();
				m_buffer[i]->Empty();
			}
			fclose(fp);
		}
		else
			return EV_GTS_ERROR_LOG_FILE_OPEN;
	}
	return (0);
}

//
// Access function to enable the registry monitor to change the logging file directory.
//
void CHTMLLog::SetLogDirectory( const CString &strNewLogDir )
{
    Lock();
	m_strDirPath= strNewLogDir;
	Unlock();
	return;
}

//
// for testing only
//
// initially place 0 into dwThreadID
//
DWORD CHTMLLog::WriteTestLog(LPCTSTR szAPIName, DWORD dwThreadID)
{
	TCHAR filepath[MAX_PATH];
	SYSTEMTIME SysTime;
	DWORD dwRetThreadID = GetCurrentThreadId();

	GetLocalTime(&SysTime);

	_stprintf(filepath,_T("%sAX%02d%02d%02d.log"),
							m_strDirPath,
							SysTime.wYear % 100,
							SysTime.wMonth,
							SysTime.wDay);


	Lock();

	FILE *fp = _tfopen(filepath, _T("a"));
	if (fp) 
	{
		if (!dwThreadID)
			fprintf(fp, "(Start %s,%d)", szAPIName, dwRetThreadID);
		else
		{
			if (dwThreadID == dwRetThreadID)
				fprintf(fp, "(%d End)\n", dwThreadID);
			else
				fprintf(fp, "(%d End FAIL)\n", dwThreadID);
		}
		fclose(fp);
	}

	Unlock();

	return dwRetThreadID;
}

void CHTMLLog::Lock()
{
	::EnterCriticalSection( &m_csLogLock );
}

void CHTMLLog::Unlock()
{
	::LeaveCriticalSection( &m_csLogLock );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\apgtslstread.cpp ===
// MODULE: APGTSLSTREAD.CPP
//
// PURPOSE: APGTS LST file reading classes
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 7-29-98
//
// NOTES: 
//	1. Prior to 11/13/98, it wasis assumed that for a given DSC/TSM file, any other associated 
//		filenames (BES, HTI) would not change over time.  This assumption is no longer good.
//		It had the unfortunate consequence that if there was a typographical error in an LST
//		file there was no way to fix it while the system was running.
//	2. While the Online Troubleshooter is running, it is possible to change the LST file in
//		order to add new troubleshooter topics, but it is not possible to remove troubleshooter
//		topics.  Thus, even if a topic which was listed in the old LST file is missing from the
//		new one, that is not a relevant difference.
//	3. Normal form of a line in this file: any of the following:
//		MODEM.DSC MODEM.HTI
//		MODEM.DSC MODEM.HTI MODEM.BES 
//		MODEM.DSC,MODEM.HTI,MODEM.BES 
//		MODEM.TSM,MODEM.HTI,MODEM.BES 
//	   Commas and spaces are both valid separators.  
//	   Order within a line is irrelevant, although for readability, it is best to put 
//		the DSC/TSM file first.  
//	   Extensions are mandatory.  The only way we know it's (say) a template file is 
//		the .HTI extension.
//	   DSC/TSM file is mandatory.  The others are optional, although if the HTI file is missing,
//		there had better be a HNetHTIOnline / HNetHTILocal property in this network.
//	4. If the same DSC/TSM file is listed more than once, the last appearance dominates the
//		earlier appearances.
//	5. For multilingual, each language goes in a subdirectory under the resource directory.
//		LST file needs to contain paths relative to	the resource directory, such as:
//		ES\MODEM.DSC ES\MODEM.HTI
//		DE\MODEM.DSC DE\MODEM.HTI
//		FR\MODEM.DSC FR\MODEM.HTI
//  
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		08-04-98	OK
// V3.0.1	12-21-98	JM		Multilingual
//

#include "stdafx.h"
#include "apgtslstread.h"
#include "sync.h"
#include <algorithm>
#include "event.h"
#include "CharConv.h"
#include "apgtsmfc.h"
#ifdef LOCAL_TROUBLESHOOTER
#include "CHMFileReader.h"
#endif

////////////////////////////////////////////////////////////////////////////////////
// static function(s)
////////////////////////////////////////////////////////////////////////////////////
CString FormFullPath(const CString& just_path, const CString& just_name)
{
#ifdef LOCAL_TROUBLESHOOTER
	if (CCHMFileReader::IsPathToCHMfile(just_path))
		return CCHMFileReader::FormCHMPath(just_path) + just_name;
	else
		return just_path + _T("\\") + just_name;
#else
	return just_path + _T("\\") + just_name;
#endif
}

////////////////////////////////////////////////////////////////////////////////////
// CTopicInfo
////////////////////////////////////////////////////////////////////////////////////
bool CTopicInfo::Init(CString & strResourcePath, vector<CString> &vecstrWords)
{
	bool bSomethingThere = false;

	for (vector<CString>::iterator i = vecstrWords.begin(); i != vecstrWords.end(); i++)
	{
		CString str_extension = CString(".") + CAbstractFileReader::GetJustExtension(*i);

		bSomethingThere = true;
		///////////////////////////////////////////
		// We require that all *.dsc etc		 //
		// files are in the same directory		 //
		// as lst file	(the resource directory) //
		// or (for multilingual) a subdirectory  //
		// of the resource directory.            // 
		///////////////////////////////////////////
		LPCTSTR extention = NULL;
		if (0 == _tcsicmp(str_extension, extention = APGTSLSTREAD_DSC) ||
			0 == _tcsicmp(str_extension, extention = APGTSLSTREAD_TSM)
		   ) 
		{
			m_DscFilePath = ::FormFullPath(strResourcePath, *i);
			m_DscFilePath.MakeLower();
			if (! m_NetworkName.GetLength()) 
			{
				// use name of DSC/TSM file, minus extension.
				m_NetworkName = *i;
				int len = m_NetworkName.GetLength()-(_tcslen(extention));
				m_NetworkName = m_NetworkName.Left(len);
				m_NetworkName.MakeLower();
			}
			continue;
		}
		if (0 == _tcsicmp(str_extension, APGTSLSTREAD_HTI)) 
		{
			m_HtiFilePath = ::FormFullPath(strResourcePath, *i);
			m_HtiFilePath.MakeLower();
			continue;
		}
		if (0 == _tcsicmp(str_extension, APGTSLSTREAD_BES)) 
		{
			m_BesFilePath = ::FormFullPath(strResourcePath, *i);
			m_BesFilePath.MakeLower();
			continue;
		}
#ifdef LOCAL_TROUBLESHOOTER
		if (0 == _tcsicmp(str_extension, APGTSLSTREAD_TSC)) 
		{
			m_TscFilePath = ::FormFullPath(strResourcePath, *i);
			m_TscFilePath.MakeLower();
			continue;
		}
#endif
		/////////////////////////////////////

		// Ignore anything unrecognized.
	}

	bool bRet = bSomethingThere && ! m_DscFilePath.IsEmpty();

	if (bRet)
	{
		CAbstractFileReader::GetFileTime(m_DscFilePath, CFileReader::eFileTimeCreated, m_DscFileCreated);
		
		if ( ! m_HtiFilePath.IsEmpty()) 
			CAbstractFileReader::GetFileTime(m_HtiFilePath, CFileReader::eFileTimeCreated, m_HtiFileCreated);

		if ( ! m_BesFilePath.IsEmpty()) 
			CAbstractFileReader::GetFileTime(m_BesFilePath, CFileReader::eFileTimeCreated, m_BesFileCreated);
	}

	return bRet;
}

								
////////////////////////////////////////////////////////////////////////////////////
// CAPGTSLSTReader
////////////////////////////////////////////////////////////////////////////////////
CAPGTSLSTReader::CAPGTSLSTReader(CPhysicalFileReader * pPhysicalFileReader)
			   : CINIReader(pPhysicalFileReader, _T("APGTS"))
{
}

CAPGTSLSTReader::~CAPGTSLSTReader()
{
}

long CAPGTSLSTReader::GetInfoCount()
{
	long ret = 0;
	LOCKOBJECT();
	ret = m_arrTopicInfo.size();
	UNLOCKOBJECT();
	return ret;
}

bool CAPGTSLSTReader::GetInfo(long index, CTopicInfo& out)
{
	LOCKOBJECT();
	if (index < m_arrTopicInfo.size()) 
	{
		out = m_arrTopicInfo[index];
		UNLOCKOBJECT();
		return true;
	}
	UNLOCKOBJECT();
	return false;
}

bool CAPGTSLSTReader::GetInfo(const CString& network_name, CTopicInfo& out)
{
	LOCKOBJECT();
	for (
		vector<CTopicInfo>::iterator i = m_arrTopicInfo.begin();
		i != m_arrTopicInfo.end(); 
		i++)
	{
		if (i->GetNetworkName() == network_name)
		{
			out = *i;
			UNLOCKOBJECT();
			return true;
		}
	}
	UNLOCKOBJECT();
	return false;
}

void CAPGTSLSTReader::GetInfo(CTopicInfoVector & arrOut)
{
	LOCKOBJECT();
	arrOut = m_arrTopicInfo;
	UNLOCKOBJECT();
}


// This will identify new troubleshooting networks, or changes to (say) the associated
//	HTI file, given the same DSC file.  Note that we can only detect additions of topics, 
//	not deletions. (see notes at head of this source file).
// If pOld is NULL, this is equivalent to GetInfo(what_is_new).
void CAPGTSLSTReader::GetDifference(const CAPGTSLSTReader * pOld, CTopicInfoVector & what_is_new)
{
	if (pOld)
	{
		CMultiMutexObj multiMutex;
		multiMutex.AddHandle(GetMutexHandle());
		multiMutex.AddHandle(pOld->GetMutexHandle());

		multiMutex.Lock(__FILE__, __LINE__);
		vector<CTopicInfo> old_arr = pOld->m_arrTopicInfo; // to avoid const
		for (vector<CTopicInfo>::iterator i = m_arrTopicInfo.begin(); i != m_arrTopicInfo.end(); i++)
		{
			vector<CTopicInfo>::const_iterator res = find(old_arr.begin(), old_arr.end(), *i);
			if (res == old_arr.end())
			{
				try
				{
					what_is_new.push_back( *i );
				}
				catch (exception& x)
				{
					CString str;
					// Note STL exception in event log.
					CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
					CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
											SrcLoc.GetSrcFileLineStr(), 
											CCharConversion::ConvertACharToString(x.what(), str), 
											_T(""), 
											EV_GTS_STL_EXCEPTION ); 
				}
			}
		}
		multiMutex.Unlock();
	}
	else 
		GetInfo(what_is_new);
}

void CAPGTSLSTReader::Parse()
{
	CINIReader::Parse();

	// parse all INI strings into something more meaningful...
	m_arrTopicInfo.clear();
	for (vector<CString>::iterator i = m_arrLines.begin(); i != m_arrLines.end(); i++)
	{
		CTopicInfo& info = *GenerateTopicInfo();
		if (ParseString(*i, info))
		{
			// if CTopicInfo with the same Network Name is found 
			//  we assign new object to what is already in the container
			vector<CTopicInfo>::iterator res;
			for (
				res = m_arrTopicInfo.begin();
				res != m_arrTopicInfo.end(); 
				res++)
			{
				if (res->GetNetworkName() == info.GetNetworkName())
					break;
			}

			if (res != m_arrTopicInfo.end())
				*res = info;
			else
			{
				try
				{
					m_arrTopicInfo.push_back(info);
				}
				catch (exception& x)
				{
					CString str;
					// Note STL exception in event log.
					CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
					CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
											SrcLoc.GetSrcFileLineStr(), 
											CCharConversion::ConvertACharToString(x.what(), str), 
											_T(""), 
											EV_GTS_STL_EXCEPTION ); 
				}
			}
		}
		delete &info;
	}
}

bool CAPGTSLSTReader::ParseString(const CString& source, CTopicInfo& out)
{
	bool ret = false;
	vector<CString> words; 
	vector<TCHAR> separators;

	try
	{
		separators.push_back(_T(' '));
		separators.push_back(_T(',')); // remove possible trailing commas
		GetWords(source, words, separators);
	}
	catch (exception& x)
	{
		CString str;
		// Note STL exception in event log.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								CCharConversion::ConvertACharToString(x.what(), str),
								_T(""), 
								EV_GTS_STL_EXCEPTION ); 
	}

	return out.Init(GetJustPath(), words);
}

CTopicInfo* CAPGTSLSTReader::GenerateTopicInfo()
{
	return new CTopicInfo;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\apgtsmfc.cpp ===
// apgtsmfc.cpp

// Equivalents of Global Afx MFC functions.
// Use the real MFC functions if you can. 

#include "stdafx.h"
#include "apgtsmfc.h"
#include "apgtsassert.h"
#include "CharConv.h"
#include <stdio.h>	// Needed for sprintf

extern HANDLE ghModule;


// This is not the name of any MFC Afx function
// This loads a string from the resource file.  It is here as a basis for CString::LoadString().
// INPUT nID - resource ID of a string resource?
// INPUT/OUTPUT lpszBuf - on input, points to a buffer.  On output, that buffer contains ???
// INPUT nMaxBuf - size of lpszBuf
int AfxLoadString(UINT nID, LPTSTR lpszBuf, UINT nMaxBuf)
{
	// convert integer value to a resource type compatible with Win32 resource-management 
	// fns. (used in place of a string containing the name of the resource.)
	// >>> Why rightshift and add 1? (Ignore in V3.0 because this is if'd out, anyway)
	LPCTSTR lpszName = MAKEINTRESOURCE((nID>>4)+1);
	HINSTANCE hInst;
	int nLen = 0;

	// Only works from the main module.
	hInst = AfxGetResourceHandle();
	if (::FindResource(hInst, lpszName, RT_STRING) != NULL)
		nLen = ::LoadString(hInst, nID, lpszBuf, nMaxBuf);
	return nLen;
}

// Return HINSTANCE handle where the default resources of the application are loaded.
HINSTANCE AfxGetResourceHandle()
{
	return (HINSTANCE) ghModule;
}


#if 0
// We've removed this because we are not using string resources.  If we revive
//	string resources, we must revive this function.

// INPUT/OUTPUT &rString-CString object (remember, not MFC CString).  On return, will 
//		contain the resultant string after the substitution is performed.
// INPUT nIDS- resource ID of template string on which the substitution will be performed.
// INPUT *lpsz1-In the MFC AfxFormatString1, a string that will replace the format 
//	characters "%1" in the template string.  In our version, will perform only a single
//	replacement & will replace '%' followed by _any_ character.
// Will be a mess if rString as pased in does not contain such an instance.
void AfxFormatString1(CString& rString, UINT nIDS, LPCTSTR lpsz1)
{
	CString str;
	str.LoadString(nIDS);
	int iInsert = str.Find('%', -1);
	rString = str.Left(iInsert);
	rString += lpsz1;
	rString += str.Right(str.GetLength() - iInsert - 2);
	return;
}
#endif

#if 0
// We've removed this because we are not using string resources.  If we revive
//	string resources, we must revive this function.

// Like AfxFormatString1, but also has an input lpsz2 to replace the format characters "%2.
// In our version, will perform only a single replacement by lpsz1 and a single replacement 
// by lpsz2, & rather than look for "%1" and "%2" will replace the first 2 instances of 
// '%' followed by _any_ character.
// Will be a mess if rString as pased in does not contain 2 such instances.
void AfxFormatString2(CString& rString, UINT nIDS, LPCTSTR lpsz1,
		LPCTSTR lpsz2)
{
	int iFirst;
	int iSecond;
	CString str;
	str.LoadString(nIDS);
	iFirst = str.Find('%', -1);
	rString = str.Left(iFirst);
	rString += lpsz1;
	iSecond = str.Find(_T('%'), iFirst);
	rString += str.Mid(iFirst + 2, iSecond - (iFirst + 2) );
	rString += lpsz2;
	rString += str.Right(str.GetLength() - iSecond - 2);
	return;
}
#endif

// Utilize this namespace for non-class related functions.
namespace APGTS_nmspace
{
	// function of convenience - has nothing to do with MFC
	bool GetServerVariable(CAbstractECB *pECB, LPCSTR var_name, CString& out)
	{
		char buf[256] = {0}; // 256 should cover all cases
		DWORD size = sizeof(buf)/sizeof(buf[0]);

		if (pECB->GetServerVariable(var_name, buf, &size)) 
		{
			out = (LPCTSTR)buf;
			return true;
		}
		return false;
	}

// >>> $MAINT - It would be preferable to use standardized encode-decoding logic rather
//				than maintaining this custom code.  RAB-19990921.
	// V3.2
	// Utility function to URL encode cookies.  
	// char, not TCHAR: cookie is always ASCII.
	void CookieEncodeURL( CString& strURL )
	{
		CString	strTemp;
		int		nURLpos;
		char	cCurByte;

		for (nURLpos= 0; nURLpos < strURL.GetLength(); nURLpos++)
		{
			cCurByte= strURL[ nURLpos ];
			if (isalnum( cCurByte ))
				strTemp+= strURL.Mid( nURLpos, 1 );
			else if (cCurByte == _T(' '))
				strTemp+= _T("+");
			else if ((cCurByte == _T('=')) || (cCurByte == _T('&')))	// Skip over name-pair delimiters.
				strTemp+= strURL.Mid( nURLpos, 1 );
			else if ((cCurByte == _T('+')) || (cCurByte == _T('%')))	// Skip over previously encoded characters.
				strTemp+= strURL.Mid( nURLpos, 1 );
			else
			{
				// Encode all other characters.
				char szBuff[5];

				sprintf( szBuff, _T("%%%02X"), (unsigned char) cCurByte );
				strTemp+= szBuff;
			}
		}
		strURL= strTemp;

		return;
	}

	// Utility function to URL decode cookies.
	// char, not TCHAR: cookie is always ASCII.
	void CookieDecodeURL( CString& strURL )
	{
		CString	strTemp;
		int		nURLpos;
		char	cCurByte;

		for (nURLpos= 0; nURLpos < strURL.GetLength(); nURLpos++)
		{
			cCurByte= strURL[ nURLpos ];
			if (cCurByte == _T('+'))
				strTemp+= _T(" ");
			else if (cCurByte == _T('%')) 
			{
				// Decode URL encoded characters.
				char szBuff[3];
				int	 nVal;

				szBuff[ 0 ]= strURL[ ++nURLpos ];
				szBuff[ 1 ]= strURL[ ++nURLpos ];
				szBuff[ 2 ]= '\0';
				sscanf( szBuff, "%02x", &nVal );
				sprintf( szBuff, "%c", nVal );
				strTemp+= szBuff;
			}
			else
				strTemp+= strURL.Mid( nURLpos, 1 );
		}
		strURL= strTemp;

		return;
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\apgtsmfc.h ===
// apgtsmfc.h

// Global Afx MFC functions.
// + WinSocks function of convenience

// Use the real MFC functions if you can - We can not. Oleg 09.01.98

#include "apgtsstr.h"
#include "apgtsECB.h"
#include "time.h"

int AfxLoadString(UINT nID, LPTSTR lpszBuf, UINT nMaxBuf);
HINSTANCE AfxGetResourceHandle();
#if 0
// We've removed these because we are not using string resources.  If we revive
//	string resources, we must revive these functions.
void AfxFormatString1(CString& rString, UINT nIDS, LPCTSTR lpsz1);
void AfxFormatString2(CString& rString, UINT nIDS, LPCTSTR lpsz1, LPCTSTR lpsz2);
#endif

namespace APGTS_nmspace
{
// functions of convenience - have nothing to do with MFC.

bool GetServerVariable(CAbstractECB *pECB, LPCSTR var_name, CString& out);

// Utility functions to URL encode and decode cookies.
void CookieEncodeURL( CString& strURL );
void CookieDecodeURL( CString& strURL );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\apgtspl.h ===
//
// MODULE: APGTSPL.H
//
// PURPOSE: Pool Queue shared variables
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Roman Mach
// 
// ORIGINAL DATE: 8-2-96
//
// NOTES: 
// 1. Based on Print Troubleshooter DLL
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V3.0		9/21/98		JM		Pull out of apgts.h to separate header file.
//								Working on encapsulation
//

#ifndef _H_APGTSPL
#define _H_APGTSPL

#include <windows.h>
#include <vector>
using namespace std;

// forward references
class CDBLoadConfiguration;
class CHTMLLog;
class CAbstractECB;

//
//
typedef struct _GTS_STATISTIC	// for gathering DLL statistics
{
	DWORD dwQueueItems;
	DWORD dwWorkItems;
	DWORD dwRollover;			// unique per request while this DLL is loaded
} GTS_STATISTIC;

//
// promoting this from a struct to a class 1/4/99 JM.  However, not fully encapsulating it.
class WORK_QUEUE_ITEM
{
	WORK_QUEUE_ITEM(); // do not instantiate.  No default constructor.
public:
	HANDLE                    hImpersonationToken;	// security thread should use while
													// processing this work item
    CAbstractECB			  *pECB;				// ISAPI uses an EXTENSION_CONTROL_BLOCK
													//	to wrap CGI data.  We have further 
													//	abstracted this.
	CDBLoadConfiguration	  *pConf;				// registry, DSC files, all that stuff
	CHTMLLog				  *pLog;				// logging
	GTS_STATISTIC			  GTSStat;				// for gathering DLL statistics

	WORK_QUEUE_ITEM(
		HANDLE                    hImpersonationTokenIn,
		CAbstractECB			  *pECBIn,
		CDBLoadConfiguration	  *pConfIn,
		CHTMLLog				  *pLogIn
		) : hImpersonationToken(hImpersonationTokenIn),
			pECB(pECBIn),
			pConf(pConfIn),
			pLog(pLogIn)
		{}
 
	~WORK_QUEUE_ITEM() 
		{}
};


class CPoolQueue {
public:
	CPoolQueue();
	~CPoolQueue();

	DWORD GetStatus();
	void Lock();
	void Unlock();
	void PushBack(WORK_QUEUE_ITEM * pwqi);
	WORK_QUEUE_ITEM * GetWorkItem();
	void DecrementWorkItems();
	DWORD WaitForWork();
	DWORD GetTotalWorkItems();
	DWORD GetTotalQueueItems();
	time_t GetTimeLastAdd();
	time_t GetTimeLastRemove();
protected:
	CRITICAL_SECTION m_csQueueLock;	// must lock to add or delete from either list or to affect
									// m_cInProcess or the various time_t variables.
	HANDLE m_hWorkSem;				// NT Semaphore handle for distributing requests to threads
									// Wait on this semaphore for a work item from this queue
	DWORD m_dwErr;					// NOTE: once this is set nonzero, it can never be cleared.
	vector<WORK_QUEUE_ITEM *> m_WorkQueue;	// vector of WORK_QUEUE_ITEMs (queued up by
									// APGTSExtension::StartRequest for working threads)
	DWORD m_cInProcess;				// # of items waiting in process (being worked on, vs.
									//	still in queue). Arbitrary, but acceptable, decision 
									//	to track m_cInProcess in this class. JM 11/30/98

	time_t m_timeLastAdd;			// time last added an item to the queue
	time_t m_timeLastRemove;		// time an item was last removed from the queue
};

#endif // _H_APGTSPL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\apgtsregconnect.h ===
//
// MODULE: APGTSREGCONNECT.H
//
// PURPOSE: read - write to the registry
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 8-24-98
//
// NOTES: 
//	1. This file is shared by Local TS and Online TS, but implemented separately in each.
//		The relevant CPP files are OnlineRegConnect.cpp and LocalRegConnect.cpp, respectively.
//	2. If we are moving toward a COM object at some point, we will probably have to establish an
//		abstract class in lieu of CAPGTSRegConnector and have Online & Local TS's each derive their
//		own version.  Meanwhile (1/99), we share a common interface (defined in APGTSRegConnect.h)
//		but implement it differently.
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		08-04-98	OK
//

#ifndef __APGTSREGCONNECT_H_
#define __APGTSREGCONNECT_H_

#include "BaseException.h"
#include "Stateless.h"
#include "regutil.h"
#include "MutexOwner.h"
#include "commonregconnect.h"

// no registry parameter can be larger than this value
#define ABS_MAX_REG_PARAM_VAL		10000

class CAPGTSRegConnectorException; // find class declaration under
								   //  CAPGTSRegConnector class declaration

////////////////////////////////////////////////////////////////////////////////////
// CAPGTSRegConnector
// 	Performs connection of APGTS project to the registry,
//	that means loading data stored in the registry, 
//  creation of keys and values if not presented in the registry,
//  detecting what kind of registry - stored data has recently been changed.
////////////////////////////////////////////////////////////////////////////////////
class CAPGTSRegConnector
{
public:
	enum ERegConnector { 	
			eIndefinite          = 0x0,
			eResourcePath        = 0x1,
			eVrootPath			 = 0x2,
			eMaxThreads			 = 0x4,
			// 0x8 is currently unassigned
			eThreadsPP			 = 0x10,
			eMaxWQItems			 = 0x20,
			eCookieLife			 = 0x40,
			eReloadDelay		 = 0x80,
			// 0x100 is currently unassigned
			eDetailedEventLogging= 0x200,
			eLogFilePath		 = 0x400,
			// only appropriate in Local Troubleshooter
			eTopicFileExtension	 = 0x800,
			// currently appropriate only in Local Troubleshooter
			eSniffAutomatic		 = 0x1000,
			eSniffManual		 = 0x2000,

			// the rest just for use in exception handling
			eProblemWithLogKey	 = 0x4000,	// problem with key to IIS area where we get log file path
			eProblemWithKey		 = 0x8000
	};

public:
	static CString & StringFromConnector(ERegConnector e, CString & str);
	static ERegConnector ConnectorFromString( const CString & str);
	static void AddBackslash(CString & str);
	static void BackslashIt(CString & str, bool bForce);
	static bool IsNumeric(ERegConnector e);
	static bool IsString(ERegConnector e);

protected:
	static bool AssignString(CString & strPersist, const CString & strNew, DWORD dwEvent);
	static bool AssignNumeric(DWORD & dwPersist, DWORD dwNew, 
					   DWORD dwEvent, DWORD dwEventDecrease =0);
	static bool ForceRangeOfNumeric(DWORD & dw, DWORD dwDefault, DWORD dwEvent, 
			DWORD dwMin=1, DWORD dwMax=ABS_MAX_REG_PARAM_VAL);

protected:
	
	struct CRegistryInfo
	{
		CString strResourcePath;		// DEF_FULLRESOURCE: resource directory 
										//	(configuration/support files)
		CString strVrootPath;		    // DEF_VROOTPATH: local web URL to the DLL

		DWORD dwMaxThreads;				// desired number of pool threads
		DWORD dwThreadsPP;				// (On Microsoft's server farm,
										//	this system runs on a 4-processor box.)
										// If dwThreadsPP * (number of processors) > dwMaxThreads,
										//	dwMaxThreads wins out as a limitation
		DWORD dwMaxWQItems;				// Maximum size of Pool Queue (number of work items
										//	not yet picked up by a pool thread)
		DWORD dwCookieLife;				// cookie life in minutes
		DWORD dwReloadDelay;			// Amount of time (in seconds) file system must settle
										//	down before we try to read from files
		DWORD dwDetailedEventLogging;	// really a boolean
		CString strLogFilePath;			// Defaults to DEF_FULLRESOURCE, but expect always to 
										// override that with the location of the IIS log.
		CString strTopicFileExtension;  // appropriate only in Local Troubleshooter

		DWORD dwSniffAutomatic;			// {1/0} control automatic sniffing
		DWORD dwSniffManual;			// {1/0} control manual sniffing

		bool  m_bIsRead;	// indicates that there has been at least one attempt to read the registry

		CRegistryInfo() {SetToDefault();}
	    void SetToDefault();
	};

	CRegistryInfo m_RegistryInfo;
	static CMutexOwner s_mx;
	CString m_strTopicName;				// This string is ignored in the Online Troubleshooter.
										// Done under the guise of binary compatibility.

public:
	CAPGTSRegConnector( const CString& strTopicName );	// strTopicName is ignored in the Online Troubleshooter.
														// Done under the guise of binary compatibility.
	~CAPGTSRegConnector();

	bool Exists(); // the root key (In Online TS, "HKEY_LOCAL_MACHINE\SOFTWARE\\ISAPITroubleShoot") exists
	bool IsRead();
	bool Read(int & maskChanged, int & maskCreated);   // pump data into m_RegistryInfo - 
					//	PLUS sets absent data in registry to default.

	DWORD GetDesiredThreadCount();
	bool GetNumericInfo(ERegConnector, DWORD&);  // returns registry data - numeric
	bool GetStringInfo(ERegConnector, CString&); // returns registry data - string
	bool SetOneValue(const CString & strName, const CString & strValue, bool &bChanged);
protected:
	void Lock();
	void Unlock();

protected:
	void ReadUpdateRegistry(int & maskChanged, int & maskCreated);
	CString ThisProgramFullKey();
	void SetNumericValue(CRegUtil &reg, ERegConnector e, DWORD dwValue);
	void SetStringValue(CRegUtil &reg, ERegConnector e, CString strValue);
	bool SetOneNumericValue(ERegConnector e, DWORD dwValue);
	bool SetOneStringValue(ERegConnector e, const CString & strValue);

private:
	void Clear();
	LPCTSTR RegSoftwareLoc();
	LPCTSTR RegThisProgram();
};

////////////////////////////////////////////////////////////////////////////////////
// CAPGTSRegConnectorException
////////////////////////////////////////////////////////////////////////////////////
class CAPGTSRegConnectorException : public CBaseException
{
public:
	CAPGTSRegConnector::ERegConnector  eVariable;
	CRegUtil& regUtil;
	// we are supposed to get WinErr (return of failed ::Reg function)
	//  from the regUtil variable

public:
	// source_file is LPCSTR rather than LPCTSTR because __FILE__ is char[35]
	CAPGTSRegConnectorException(LPCSTR source_file, 
								int line, 
								CRegUtil& reg_util, 
								CAPGTSRegConnector::ERegConnector variable =CAPGTSRegConnector::eIndefinite)
  : CBaseException(source_file, line),
    regUtil(reg_util),
	eVariable(variable)
	{}
	void Close() {regUtil.Close();}
	void Log();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\apgtsqry.cpp ===
//
// MODULE: APGTSQRY.CPP
//
// PURPOSE: Implementation file for PTS Query Parser
// Fully implements class CHttpQuery, parsing out NAME=VALUE pairs from HTTP query string
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Roman Mach
// 
// ORIGINAL DATE: 8-2-96
//
// NOTES: 
// 1. Based on Print Troubleshooter DLL
// 2. Caller is responsible to assure that all buffers passed in are large enough
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V3.1		12/17/98	JM		Major cleanup, add Push capablity
//

#pragma warning(disable:4786)

#include "stdafx.h"
#include "apgts.h"
#include "apgtscls.h"

//
//
CHttpQuery::CHttpQuery() :
	m_state(ST_GETDATA),
	m_nIndex(0)
{
}

//
//
CHttpQuery::~CHttpQuery()
{
}

//
// INPUT *szInput - this is the URL-encoded query string in which we are searching
// INPUT *pchName - must point to a buffer of size MAXBUF
// OUTPUT *pchName - Typically NAME of a NAME=VALUE pair.  Any URL-encoding stripped out.
//	Null-terminated.  Leading and trailing blanks stripped.
// INPUT *pchValue - must point to a buffer of size MAXBUF
// OUTPUT *pchValue - Typically VALUE of a NAME=VALUE pair.  Any URL-encoding stripped out.
//	Null-terminated.  Leading and trailing blanks stripped.
// RETURN - TRUE ==> more data to come
BOOL CHttpQuery::GetFirst(LPCTSTR szInput, TCHAR *pchName, TCHAR *pchValue)
{
	m_state = ST_GETDATA;
	m_strInput = szInput;
	m_nIndex = 0;
	
	BOOL status = LoopFind(pchName, pchValue);
	CleanStr(pchName);
	CleanStr(pchValue);
	return (status);
}

// Called after a call to CHttpQuery::GetFirst or to this fn has returned true
// INPUT *pchName - must point to a buffer of size MAXBUF
// OUTPUT *pchName - Typically NAME of a NAME=VALUE pair
//	Null-terminated.  Leading and trailing blanks stripped.
// INPUT *pchValue - must point to a buffer of size MAXBUF
// OUTPUT *pchValue - Typically VALUE of a NAME=VALUE pair
//	Null-terminated.  Leading and trailing blanks stripped.
// RETURN - TRUE ==> more data to come
BOOL CHttpQuery::GetNext(TCHAR *pchName, TCHAR *pchValue)
{
	BOOL status = LoopFind(pchName, pchValue);
	CleanStr(pchName);
	CleanStr(pchValue);
	return (status);
}

// put new content on the front of the unparsed portion of the query string in which we are 
//	searching.
// Typically, szPushed should consist of 1 or more NAME=VALUE pairs, each terminated by an
//	ampersand ("&").
void CHttpQuery::Push(LPCTSTR szPushed)
{
	m_state = ST_GETDATA;
	m_strInput = CString(szPushed) + m_strInput.Mid(m_nIndex);
	m_nIndex = 0;
}

//
// RETURN - TRUE ==> more data to come
// INPUT *pchName - must point to a buffer of size MAXBUF
// OUTPUT *pchName - Typically NAME of a NAME=VALUE pair.  Any URL-encoding stripped out.
//	Null-terminated.  May have leading and/or trailing blanks
// INPUT *pchValue - must point to a buffer of size MAXBUF
// OUTPUT *pchValue - Typically VALUE of a NAME=VALUE pair.  Any URL-encoding stripped out.
//	Null-terminated.  May have leading and/or trailing blanks
BOOL CHttpQuery::LoopFind(TCHAR *pchName, TCHAR *pchValue)
{
	*pchName = NULL;
	*pchValue = NULL;

	TCHAR ch;
	int val, oldval = 0;
	TCHAR temp[20];		// a way bigger buffer than we need
	TCHAR *pchPut;		// initially points to pchName but can change to point to pchValue

	int nLength = m_strInput.GetLength();

	if (m_nIndex >= nLength)
		return (FALSE);

	pchPut = pchName;
	
	while (m_nIndex < nLength)
	{
		ch = m_strInput[m_nIndex++]; // You might think something related to _tcsinc() 
					//	would be called for to advance m_nIndex.  You'd be wrong, 
					//	although the choice would be harmless.  
					// URL-encoding keeps us within the ASCII character set, so no double-
					//	byte issues should arise.  Besides that, the strings passed in to the
					//	command line of the troubleshooter controls are even further 
					//	constrained: for example, even in a Japanese-language topic, node
					//	names will be ASCII.
		switch(m_state) {
			case ST_GETDATA:
				if (ch == _T('&'))
					// expect another NAME=VALUE pair
					return (TRUE);
				else if (ch == _T('=')) {
					// Got a name, expect a value
					pchPut = pchValue;
					break;
				}
				else if (ch == _T('%')) 
					// expect to be followed by 2-digit hex
					m_state = ST_DECODEHEX1;	
				else if (ch == _T('+'))
					// encoded blank
					AddBuffer(_T(' '),pchPut);
				else
					AddBuffer(ch,pchPut);
				break;
			case ST_DECODEHEX1:
				// first of 2 hex digits
				temp[0] = ch;
				m_state = ST_DECODEHEX2;
				break;
			case ST_DECODEHEX2:
				// second of 2 hex digits; parse it into a hex value & affix it to *pchPut
				temp[1] = ch;
				temp[2] = 0;
				_stscanf(temp,_T("%02X"),&val);

				// reinterpret CR, LF, or CRLF as '\n'
				if (val == 0x0A) {
					if (oldval != 0x0D)
						AddBuffer(_T('\n'),pchPut);
				}
				else if (val == 0x0D)
					AddBuffer(_T('\n'),pchPut);
				else 
					AddBuffer( static_cast<TCHAR>(val), pchPut );

				oldval = val;
				m_state = ST_GETDATA;
				break;
			default:
				return (FALSE);
		}
	}
	return (TRUE);
}

//
// append ch to *tostr, with a few subtleties: see comments in body of routine
void CHttpQuery::AddBuffer( TCHAR ch, TCHAR *tostr)
{
	if (ch == _T('\t')) 
		// TAB -> 4 blanks
		PutStr(_T("    "),tostr);
	else if (ch == _T('\n'))
		// blank before newline
		PutStr(_T(" \n"),tostr);
	else if (ch == _T('<')) 
		// html: must encrypt left angle bracket.
		PutStr(_T("&lt"),tostr);
	else if (ch == _T('>'))
		// html: must encrypt right angle bracket.
		PutStr(_T("&gt"),tostr);
	else if (ch > 0x7E || ch < 0x20)
		// refuse DEL, NUL, and control characters
		return;
	else {
		TCHAR temp[2];
		temp[0] = ch;
		temp[1] = _T('\0');
		PutStr(temp,tostr);
	}
}

// append string *addtostr to string *instr up to a maximum size of MAXBUF-1
// INPUT/OUTPUT *instr
// INPUT *addtostr 
// NOTE that this fails silently if total lengths exceed MAXBUF-1 chars
void CHttpQuery::PutStr(LPCTSTR instr, TCHAR *addtostr)
{
	if ((_tcslen(instr)+_tcslen(addtostr)) >= (MAXBUF-1)) {
		// can't add it to buff
		return;
	}
	_tcscat(addtostr,instr);
}

// Acts upon INPUT/OUTPUT *str - strip any leading control characters and spaces, 
//	turn any other control characters and spaces into '\0's
/* static */ void CHttpQuery::CleanStr(TCHAR *str)
{
	TCHAR temp[MAXBUF], *ptr;
	int len;

	ptr = str;
	while (*ptr > _T('\0') && *ptr <= _T(' '))
		ptr = _tcsinc(ptr);
	_tcscpy(temp,ptr);
	if ((len = _tcslen(temp))!=0) {
		ptr = &temp[len-1];
		while (ptr > temp) {
			if (*ptr > _T('\0') && *ptr <= _T(' '))
				*ptr = _T('\0');
			else
				break;
			ptr = _tcsdec(temp, ptr);
		}
	}
	_tcscpy(str,temp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\apgtslstread.h ===
//
// MODULE: APGTSLSTREAD.H
//
// PURPOSE: APGTS LST file reading classes
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 7-29-98
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		08-04-98	OK
//

#ifndef __APGTSLSTREAD_H_
#define __APGTSLSTREAD_H_

#define APGTSLSTREAD_DSC   _T(".dsc")
#define APGTSLSTREAD_HTI   _T(".hti")
#define APGTSLSTREAD_BES   _T(".bes")  
#define APGTSLSTREAD_TSM   _T(".tsm") 
#ifdef LOCAL_TROUBLESHOOTER
#define APGTSLSTREAD_TSC   _T(".tsc")
#endif

#include "iniread.h"
#include "SafeTime.h"

////////////////////////////////////////////////////////////////////////////////////
// static function(s)
////////////////////////////////////////////////////////////////////////////////////
CString FormFullPath(const CString& just_path, const CString& just_name);

////////////////////////////////////////////////////////////////////////////////////
// CTopicInfo
////////////////////////////////////////////////////////////////////////////////////
class CTopicInfo
{ // each CTopicInfo contains data about one topic (belief network & associated files).
protected:
	CString m_NetworkName;	// symbolic name of network
	CString m_DscFilePath;	// full path of DSC file
	CString m_HtiFilePath;	// full path of HTI file
	CString m_BesFilePath;	// full path of BES file
	CString m_TscFilePath;	// full path of TSC file

	time_t 	m_DscFileCreated;
	time_t 	m_HtiFileCreated;
	time_t 	m_BesFileCreated;

public:
	CTopicInfo() : m_DscFileCreated(0), m_HtiFileCreated(0), m_BesFileCreated(0) {}

public:
	virtual bool Init(CString & strResourcePath, vector<CString> & vecstrWords);

public:
	// The following 4 functions are guaranteed to return lower case strings.
	const CString & GetNetworkName() const {return m_NetworkName;} 
	const CString & GetDscFilePath() const {return m_DscFilePath;}
	const CString & GetHtiFilePath() const {return m_HtiFilePath;}
	const CString & GetBesFilePath() const {return m_BesFilePath;}
	const CString & GetTscFilePath() const {return m_TscFilePath;}

	CString GetStrDscFileCreated() 
		{return CSafeTime(m_DscFileCreated).StrLocalTime();}
	CString GetStrHtiFileCreated() 
		{return CSafeTime(m_HtiFileCreated).StrLocalTime();}
	CString GetStrBesFileCreated() 
		{return CSafeTime(m_BesFileCreated).StrLocalTime();}

	inline BOOL __stdcall operator ==(const CTopicInfo& t2) const
	{
		return m_NetworkName == t2.m_NetworkName
			&& m_DscFilePath == t2.m_DscFilePath
			&& m_HtiFilePath == t2.m_HtiFilePath
			&& m_BesFilePath == t2.m_BesFilePath
			&& m_TscFilePath == t2.m_TscFilePath
			;
	}

	// this function exists solely to keep STL happy.
	inline BOOL __stdcall operator < (const CTopicInfo& t2) const
	{
		return m_NetworkName < t2.m_NetworkName;
	}
};

typedef vector<CTopicInfo> CTopicInfoVector;

////////////////////////////////////////////////////////////////////////////////////
// CAPGTSLSTReader
////////////////////////////////////////////////////////////////////////////////////
class CAPGTSLSTReader : public CINIReader
{
protected:
	CTopicInfoVector m_arrTopicInfo; // Symbolic name & file name for each topic

public:
	CAPGTSLSTReader(CPhysicalFileReader * pPhysicalFileReader);
   ~CAPGTSLSTReader();

public:
	////////////////////////////////////////////////////////
	// If multiple threads may access this object, 
	//	these functions should be wrapped by    
	//  LOCKOBJECT() - UNLOCKOBJECT()  
	//  to secure consistency of container	   
	//  if used in conjunction			
	long GetInfoCount();
	bool GetInfo(long index, CTopicInfo& out);
	bool GetInfo(const CString & network_name, CTopicInfo & out);
	////////////////////////////////////////////////////////

	void GetInfo(CTopicInfoVector& arrOut);

public:
	void GetDifference(const CAPGTSLSTReader * pOld, CTopicInfoVector & what_is_new);

protected:
	virtual void Parse();
	virtual bool ParseString(const CString& source, CTopicInfo& out);
	virtual CTopicInfo* GenerateTopicInfo();
};

#endif __APGTSLSTREAD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\apgtspl.cpp ===
//
// MODULE: APGTSPL.CPP
//
// PURPOSE: Pool Queue shared variables
//	Fully implement class PoolQueue
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Roman Mach
// 
// ORIGINAL DATE: 8-2-96
//
// NOTES: 
// 1. Based on Print Troubleshooter DLL
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V3.0		9/21/98		JM		Working on encapsulation
//

#pragma warning(disable:4786)

#include "stdafx.h"
#include "apgtspl.h"
#include "event.h"
#include "apgtscls.h"
#include "CharConv.h"

//
//
CPoolQueue::CPoolQueue() :
	m_dwErr(0),
	m_cInProcess(0),
	m_timeLastAdd(0),
	m_timeLastRemove(0)
{

	::InitializeCriticalSection( &m_csQueueLock );
	
	m_hWorkSem = CreateSemaphore(NULL,
									0,
									0x7fffffff,
									NULL );
	if (m_hWorkSem == NULL)
		m_dwErr = EV_GTS_ERROR_POOL_SEMA;
}

//
//
CPoolQueue::~CPoolQueue() 
{
	if (m_hWorkSem)
		::CloseHandle(m_hWorkSem);

    while ( !m_WorkQueue.empty() ) 
	{
        delete m_WorkQueue.back();
		m_WorkQueue.pop_back();
	}    

	::DeleteCriticalSection( &m_csQueueLock );
}

void CPoolQueue::Lock()
{
    ::EnterCriticalSection( &m_csQueueLock );
}

void CPoolQueue::Unlock()
{
    ::LeaveCriticalSection( &m_csQueueLock );
}

//
//
DWORD CPoolQueue::GetStatus()
{
	return m_dwErr;
}

// put it at the tail of the queue & Signal the pool threads there is work to be done
// OK if we're already locked when this is called; OK if we're not.
void CPoolQueue::PushBack(WORK_QUEUE_ITEM * pwqi)
{
	Lock();
	// Some data passed to thread just for statistical purposes
	// Thread can pass this info back over web; we can't.
	pwqi->GTSStat.dwQueueItems = GetTotalQueueItems();
	pwqi->GTSStat.dwWorkItems = GetTotalWorkItems();

	try
	{
		m_WorkQueue.push_back(pwqi);
		time(&m_timeLastAdd);

		//  Signal the pool threads there is work to be done only if it was
		//	successfully added to the work queue.
		::ReleaseSemaphore( m_hWorkSem, 1, NULL );
	}
	catch (exception& x)
	{
		CString str;
		// Note STL exception in event log.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								CCharConversion::ConvertACharToString(x.what(), str), 
								_T(""), 
								EV_GTS_STL_EXCEPTION ); 
	}

	Unlock();
}

// Get the item at the front of the queue in order to act on it.
WORK_QUEUE_ITEM * CPoolQueue::GetWorkItem()
{
	WORK_QUEUE_ITEM * pwqi;
    Lock();
    
	if ( !m_WorkQueue.empty() ) 
	{
		vector<WORK_QUEUE_ITEM *>::iterator it = m_WorkQueue.begin();
		pwqi = *it;
		m_WorkQueue.erase(it);
		time(&m_timeLastRemove);
		++m_cInProcess;
    }
    else
        pwqi = NULL;

    Unlock();
	return pwqi;
}

// When we are totally done with a work item, reduce the count of those which are
//	in process.
// Arbitrary, but acceptable, decision to track m_cInProcess in this class. JM 11/30/98
void CPoolQueue::DecrementWorkItems()
{
	Lock();
	--m_cInProcess;
	Unlock();
}

// Called by a pool thread to wait for there to be something in this queue.
DWORD CPoolQueue::WaitForWork()
{
	return ::WaitForSingleObject( m_hWorkSem, INFINITE );
}

// Arbitrary, but acceptable, decision to track m_cInProcess in this class. JM 11/30/98
DWORD CPoolQueue::GetTotalWorkItems()
{
	Lock();
	DWORD ret = m_cInProcess + GetTotalQueueItems();
	Unlock();
	return ret;
}

DWORD CPoolQueue::GetTotalQueueItems()
{
	Lock();
	DWORD ret = m_WorkQueue.size();
	Unlock();
	return ret;
}

time_t CPoolQueue::GetTimeLastAdd()
{
	Lock();
	time_t ret = m_timeLastAdd;
	Unlock();
	return ret;
}

time_t CPoolQueue::GetTimeLastRemove()
{
	Lock();
	time_t ret = m_timeLastRemove;
	Unlock();
	return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\apgtsstr.cpp ===
//
// MODULE: APGTSSTR.CPP
//
// PURPOSE: implements DLL Growable string object CString 
//	(pretty much a la MFC, but avoids all that MFC overhead)
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel (reworked code from Microsoft's MFC sources)
// 
// ORIGINAL DATE: 8-2-96 Roman Mach; totally re-implemented 1/15/99 Joe Mabel 
//
// NOTES: 
// 1. As of 1/99, re-implemented based on MFC's implementation.  Pared down
//	to what we use.
// 2. This file modified 5/26/01 by Davide Massarenti from MS to remove reference counting
//   from CString implementation to resolve thread safety issue discovered on dual processor
//   systems when dll compiled for WinXP by MS compiler.
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V3.0		7-24-98		JM		Abstracted this out as a separate header.
// V3.1		1-15-99		JM		Redo based on MFC implementation
//

#include "stdafx.h"
#include <stdio.h>
#include "apgtsstr.h"
#include "apgtsmfc.h"

// Windows extensions to strings
#ifdef _UNICODE
#define CHAR_FUDGE 1    // one TCHAR unused is good enough
#else
#define CHAR_FUDGE 2    // two BYTES unused for case of DBC last char
#endif

/////////////////////////////////////////////////////////////////////////////
// static class data, special inlines

// afxChNil is left for backward compatibility
TCHAR afxChNil = '\0';

// For an empty string, m_pchData will point here
// (note: avoids special case of checking for NULL m_pchData)
// empty string data (and locked)
// [BC - 20010529] - change below array from int to long and add extra 0 for padding
// to avoid problems indicated by Davide Massarenti in 64-bit environments
static long rgInitData[] = { -1, 0, 0, 0, 0 };
static CStringData* afxDataNil = (CStringData*)&rgInitData;
static LPCTSTR afxPchNil = (LPCTSTR)(((BYTE*)&rgInitData)+sizeof(CStringData));
// special function to make afxEmptyString work even during initialization
const CString& AfxGetEmptyString()
	{ return *(CString*)&afxPchNil; }

//////////////////////////////////////////////////////////////////////////////
// Construction/Destruction

CString::CString()
{
	Init();
}

CString::CString(const CString& stringSrc)
{
// REMOVING REF COUNTING: 	  ASSERT(stringSrc.GetData()->nRefs != 0);
// REMOVING REF COUNTING: 	  if (stringSrc.GetData()->nRefs >= 0)
// REMOVING REF COUNTING: 	  {
// REMOVING REF COUNTING: 		  ASSERT(stringSrc.GetData() != afxDataNil);
// REMOVING REF COUNTING: 		  m_pchData = stringSrc.m_pchData;
// REMOVING REF COUNTING: 		  InterlockedIncrement(&GetData()->nRefs);
// REMOVING REF COUNTING: 	  }
// REMOVING REF COUNTING: 	  else
// REMOVING REF COUNTING: 	  {
		Init();
		*this = stringSrc.m_pchData;
// REMOVING REF COUNTING: 	  }
}

void CString::AllocBuffer(int nLen)
// always allocate one extra character for '\0' termination
// assumes [optimistically] that data length will equal allocation length
{
	ASSERT(nLen >= 0);

	// MFC had the following assertion.  I've killed it because we
	//	don't have INT_MAX.  JM 1/15/99
	//ASSERT(nLen <= INT_MAX-1);    // max size (enough room for 1 extra)

	if (nLen == 0)
		Init();
	else
	{
		CStringData* pData =
			(CStringData*)new BYTE[sizeof(CStringData) + (nLen+1)*sizeof(TCHAR)];
		//[BC-03022001] - added check for NULL ptr to satisfy MS code analysis tool.
		if(pData)
		{
			pData->nRefs = 1;
			pData->data()[nLen] = '\0';
			pData->nDataLength = nLen;
			pData->nAllocLength = nLen;
			m_pchData = pData->data();
		}
	}
}

void CString::Release()
{
	if (GetData() != afxDataNil)
	{
// REMOVING REF COUNTING: 		  ASSERT(GetData()->nRefs != 0);
// REMOVING REF COUNTING: 		  if (InterlockedDecrement(&GetData()->nRefs) <= 0)
			delete[] (BYTE*)GetData();
		Init();
	}
}

void PASCAL CString::Release(CStringData* pData)
{
	if (pData != afxDataNil)
	{
// REMOVING REF COUNTING: 		  ASSERT(pData->nRefs != 0);
// REMOVING REF COUNTING: 		  if (InterlockedDecrement(&pData->nRefs) <= 0)
			delete[] (BYTE*)pData;
	}
}

void CString::CopyBeforeWrite()
{
// REMOVING REF COUNTING: 	  if (GetData()->nRefs > 1)
// REMOVING REF COUNTING: 	  {
// REMOVING REF COUNTING: 		  CStringData* pData = GetData();
// REMOVING REF COUNTING: 		  Release();
// REMOVING REF COUNTING: 		  AllocBuffer(pData->nDataLength);
// REMOVING REF COUNTING: 		  memcpy(m_pchData, pData->data(), (pData->nDataLength+1)*sizeof(TCHAR));
// REMOVING REF COUNTING: 	  }
// REMOVING REF COUNTING: 	  ASSERT(GetData()->nRefs <= 1);
}

void CString::AllocBeforeWrite(int nLen)
{
// REMOVING REF COUNTING: 	  if (GetData()->nRefs > 1 || nLen > GetData()->nAllocLength)
	if (nLen > GetData()->nAllocLength)
	{
		Release();
		AllocBuffer(nLen);
	}
// REMOVING REF COUNTING: 	  ASSERT(GetData()->nRefs <= 1);
}

CString::~CString()
//  free any attached data
{
	if (GetData() != afxDataNil)
	{
// REMOVING REF COUNTING: 		  if (InterlockedDecrement(&GetData()->nRefs) <= 0)
			delete[] (BYTE*)GetData();
	}
}

void CString::Empty()
{
	if (GetData()->nDataLength == 0)
		return;
// REMOVING REF COUNTING: 	  if (GetData()->nRefs >= 0)
		Release();
// REMOVING REF COUNTING: 	  else
// REMOVING REF COUNTING: 		  *this = &afxChNil;
	ASSERT(GetData()->nDataLength == 0);
// REMOVING REF COUNTING: 	  ASSERT(GetData()->nRefs < 0 || GetData()->nAllocLength == 0);
}

//////////////////////////////////////////////////////////////////////////////
// Helpers for the rest of the implementation

void CString::AllocCopy(CString& dest, int nCopyLen, int nCopyIndex,
	 int nExtraLen) const
{
	// will clone the data attached to this string
	// allocating 'nExtraLen' characters
	// Places results in uninitialized string 'dest'
	// Will copy the part or all of original data to start of new string

	int nNewLen = nCopyLen + nExtraLen;
	if (nNewLen == 0)
	{
		dest.Init();
	}
	else
	{
		dest.AllocBuffer(nNewLen);
		memcpy(dest.m_pchData, m_pchData+nCopyIndex, nCopyLen*sizeof(TCHAR));
	}
}

//////////////////////////////////////////////////////////////////////////////
// More sophisticated construction

CString::CString(LPCTSTR lpsz)
{
	Init();
	// Unlike MFC, no implicit LoadString offered - JM 1/15/99
	int nLen = SafeStrlen(lpsz);
	if (nLen != 0)
	{
		AllocBuffer(nLen);
		memcpy(m_pchData, lpsz, nLen*sizeof(TCHAR));
	}
}

//////////////////////////////////////////////////////////////////////////////
// Assignment operators
//  All assign a new value to the string
//      (a) first see if the buffer is big enough
//      (b) if enough room, copy on top of old buffer, set size and type
//      (c) otherwise free old string data, and create a new one
//
//  All routines return the new string (but as a 'const CString&' so that
//      assigning it again will cause a copy, eg: s1 = s2 = "hi there".
//

void CString::AssignCopy(int nSrcLen, LPCTSTR lpszSrcData)
{
	AllocBeforeWrite(nSrcLen);
	memcpy(m_pchData, lpszSrcData, nSrcLen*sizeof(TCHAR));
	GetData()->nDataLength = nSrcLen;
	m_pchData[nSrcLen] = '\0';
}

const CString& CString::operator=(const CString& stringSrc)
{
// REMOVING REF COUNTING: 	  if (m_pchData != stringSrc.m_pchData)
// REMOVING REF COUNTING: 	  {
// REMOVING REF COUNTING: 		  if ((GetData()->nRefs < 0 && GetData() != afxDataNil) ||
// REMOVING REF COUNTING: 			  stringSrc.GetData()->nRefs < 0)
// REMOVING REF COUNTING: 		  {
			// actual copy necessary since one of the strings is locked
			AssignCopy(stringSrc.GetData()->nDataLength, stringSrc.m_pchData);
// REMOVING REF COUNTING: 		  }
// REMOVING REF COUNTING: 		  else
// REMOVING REF COUNTING: 		  {
// REMOVING REF COUNTING: 			  // can just copy references around
// REMOVING REF COUNTING: 			  Release();
// REMOVING REF COUNTING: 			  ASSERT(stringSrc.GetData() != afxDataNil);
// REMOVING REF COUNTING: 			  m_pchData = stringSrc.m_pchData;
// REMOVING REF COUNTING: 			  InterlockedIncrement(&GetData()->nRefs);
// REMOVING REF COUNTING: 		  }
// REMOVING REF COUNTING: 	  }
	return *this;
}

const CString& CString::operator=(LPCTSTR lpsz)
{
	// Suppress the following Assert from MFC  - JM 1/15/99
	// ASSERT(lpsz == NULL || AfxIsValidString(lpsz, FALSE));
	AssignCopy(SafeStrlen(lpsz), lpsz);
	return *this;
}

const CString& CString::operator=(TCHAR ch)
{
	AssignCopy(1, &ch);
	return *this;
}

#ifdef _UNICODE
const CString& CString::operator=(LPCSTR lpsz)
{
    int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
    AllocBeforeWrite(nSrcLen);
    mbstowcs(m_pchData, lpsz, nSrcLen+1);
    ReleaseBuffer();
    return *this;
}
#else //!_UNICODE
const CString& CString::operator=(LPCWSTR lpsz)
{
    int nSrcLen = lpsz != NULL ? wcslen(lpsz) : 0;
    AllocBeforeWrite(nSrcLen*2);
    wcstombs(m_pchData, lpsz, (nSrcLen*2)+1);
    ReleaseBuffer();
    return *this;
}
#endif  //!_UNICODE

//////////////////////////////////////////////////////////////////////////////
// concatenation

// NOTE: "operator+" is done as friend functions for simplicity
//      There are three variants:
//          CString + CString
// and for ? = TCHAR, LPCTSTR
//          CString + ?
//          ? + CString

// we (Saltmine) have switched away from friend because VC 6/0 doesn't like it. - JM 1/15/99
// we (Saltmine) do LPCTSTR but not TCHAR - JM 1/15/99

void CString::ConcatCopy(int nSrc1Len, LPCTSTR lpszSrc1Data,
	int nSrc2Len, LPCTSTR lpszSrc2Data)
{
  // -- master concatenation routine
  // Concatenate two sources
  // -- assume that 'this' is a new CString object

	int nNewLen = nSrc1Len + nSrc2Len;
	if (nNewLen != 0)
	{
		AllocBuffer(nNewLen);
		memcpy(m_pchData, lpszSrc1Data, nSrc1Len*sizeof(TCHAR));
		memcpy(m_pchData+nSrc1Len, lpszSrc2Data, nSrc2Len*sizeof(TCHAR));
	}
}

CString CString::operator+(const CString& string2)
{
	CString s;
	s.ConcatCopy(GetData()->nDataLength, m_pchData,
		string2.GetData()->nDataLength, string2.m_pchData);
	return s;
}

CString CString::operator+(LPCTSTR lpsz)
{
	// Suppress the following Assert from MFC  - JM 1/15/99
	// ASSERT(lpsz == NULL || AfxIsValidString(lpsz, FALSE));
	CString s;
	s.ConcatCopy(GetData()->nDataLength, m_pchData,
		CString::SafeStrlen(lpsz), lpsz);
	return s;
}

//////////////////////////////////////////////////////////////////////////////
// concatenate in place

void CString::ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData)
{
	//  -- the main routine for += operators

	// concatenating an empty string is a no-op!
	if (nSrcLen == 0)
		return;

	// if the buffer is too small, or we have a width mis-match, just
	//   allocate a new buffer (slow but sure)
// REMOVING REF COUNTING: 	  if (GetData()->nRefs > 1 || GetData()->nDataLength + nSrcLen > GetData()->nAllocLength)
	if (GetData()->nDataLength + nSrcLen > GetData()->nAllocLength)
	{
		// we have to grow the buffer, use the ConcatCopy routine
		CStringData* pOldData = GetData();
		ConcatCopy(GetData()->nDataLength, m_pchData, nSrcLen, lpszSrcData);
		ASSERT(pOldData != NULL);
		CString::Release(pOldData);
	}
	else
	{
		// fast concatenation when buffer big enough
		memcpy(m_pchData+GetData()->nDataLength, lpszSrcData, nSrcLen*sizeof(TCHAR));
		GetData()->nDataLength += nSrcLen;
		ASSERT(GetData()->nDataLength <= GetData()->nAllocLength);
		m_pchData[GetData()->nDataLength] = '\0';
	}
}

const CString& CString::operator+=(LPCTSTR lpsz)
{
	// Suppress the following Assert from MFC  - JM 1/15/99
	// ASSERT(lpsz == NULL || AfxIsValidString(lpsz, FALSE));
	ConcatInPlace(SafeStrlen(lpsz), lpsz);
	return *this;
}

const CString& CString::operator+=(const CString& string)
{
	ConcatInPlace(string.GetData()->nDataLength, string.m_pchData);
	return *this;
}

///////////////////////////////////////////////////////////////////////////////
// Advanced direct buffer access

// CString::GetBuffer() and CString::ReleaseBuffer() calls should be matched.
LPTSTR CString::GetBuffer(int nMinBufLength)
{
	ASSERT(nMinBufLength >= 0);

// REMOVING REF COUNTING: 	  if (GetData()->nRefs > 1 || nMinBufLength > GetData()->nAllocLength)
	if (nMinBufLength > GetData()->nAllocLength)
	{
		// we have to grow the buffer
		CStringData* pOldData = GetData();
		int nOldLen = GetData()->nDataLength;   // AllocBuffer will tromp it
		if (nMinBufLength < nOldLen)
			nMinBufLength = nOldLen;
		AllocBuffer(nMinBufLength);
		memcpy(m_pchData, pOldData->data(), (nOldLen+1)*sizeof(TCHAR));
		GetData()->nDataLength = nOldLen;
		CString::Release(pOldData);
	}
// REMOVING REF COUNTING: 	  ASSERT(GetData()->nRefs <= 1);

	// return a pointer to the character storage for this string
	ASSERT(m_pchData != NULL);
	return m_pchData;
}

// CString::GetBuffer() and CString::ReleaseBuffer() calls should be matched.
void CString::ReleaseBuffer(int nNewLength /*  = -1 */)
{
	CopyBeforeWrite();  // just in case GetBuffer was not called

	if (nNewLength == -1)
		nNewLength = lstrlen(m_pchData); // zero terminated

	ASSERT(nNewLength <= GetData()->nAllocLength);
	GetData()->nDataLength = nNewLength;
	m_pchData[nNewLength] = '\0';
}

LPTSTR CString::GetBufferSetLength(int nNewLength)
{
	ASSERT(nNewLength >= 0);

	GetBuffer(nNewLength);
	GetData()->nDataLength = nNewLength;
	m_pchData[nNewLength] = '\0';
	return m_pchData;
}

///////////////////////////////////////////////////////////////////////////////
// Commonly used routines 

int CString::Find(TCHAR ch) const
{
	// find first single character
	LPTSTR lpsz = _tcschr(m_pchData, (_TUCHAR)ch);

	// return -1 if not found and index otherwise
	return (lpsz == NULL) ? CString::FIND_FAILED : (int)(lpsz - m_pchData);
}

void CString::MakeLower()
{
	CopyBeforeWrite();
	_tcslwr(m_pchData);
}

//////////////////////////////////////////////////////////////////////////////
// Very simple sub-string extraction

CString CString::Mid(int nFirst) const
{
	return Mid(nFirst, GetData()->nDataLength - nFirst);
}

CString CString::Mid(int nFirst, int nCount) const
{
	// out-of-bounds requests return sensible things
	if (nFirst < 0)
		nFirst = 0;
	if (nCount < 0)
		nCount = 0;

	if (nFirst + nCount > GetData()->nDataLength)
		nCount = GetData()->nDataLength - nFirst;
	if (nFirst > GetData()->nDataLength)
		nCount = 0;

	CString dest;
	AllocCopy(dest, nCount, nFirst, 0);
	return dest;
}

CString CString::Right(int nCount) const
{
	if (nCount < 0)
		nCount = 0;
	else if (nCount > GetData()->nDataLength)
		nCount = GetData()->nDataLength;

	CString dest;
	AllocCopy(dest, nCount, GetData()->nDataLength-nCount, 0);
	return dest;
}

CString CString::Left(int nCount) const
{
	if (nCount < 0)
		nCount = 0;
	else if (nCount > GetData()->nDataLength)
		nCount = GetData()->nDataLength;

	CString dest;
	AllocCopy(dest, nCount, 0, 0);
	return dest;
}

//////////////////////////////////////////////////////////////////////////////
// Finding

int CString::ReverseFind(TCHAR ch) const
{
	// find last single character
	LPTSTR lpsz = _tcsrchr(m_pchData, (_TUCHAR)ch);

	// return -1 if not found, distance from beginning otherwise
	return (lpsz == NULL) ? CString::FIND_FAILED : (int)(lpsz - m_pchData);
}

// find a sub-string (like strstr)
int CString::Find(LPCTSTR lpszSub) const
{
	// Suppress the following Assert from MFC  - JM 1/15/99
	// ASSERT(AfxIsValidString(lpszSub, FALSE));

	// find first matching substring
	LPTSTR lpsz = _tcsstr(m_pchData, lpszSub);

	// return -1 for not found, distance from beginning otherwise
	return (lpsz == NULL) ? CString::FIND_FAILED : (int)(lpsz - m_pchData);
}

// find a sub-string (like strstr).  Added function - RAB19991112.
int CString::Find(LPCTSTR lpszSub, int nStart) const
{
	// Suppress the following Assert from MFC - RAB19991112.
	//ASSERT(AfxIsValidString(lpszSub));

	int nLength = GetData()->nDataLength;
	if (nStart > nLength)
		return CString::FIND_FAILED;

	// find first matching substring
	LPTSTR lpsz = _tcsstr(m_pchData + nStart, lpszSub);

	// return -1 for not found, distance from beginning otherwise
	return (lpsz == NULL) ? CString::FIND_FAILED : (int)(lpsz - m_pchData);
}


/////////////////////////////////////////////////////////////////////////////
// CString formatting

#ifdef _MAC
	#define TCHAR_ARG   int
	#define WCHAR_ARG   unsigned
	#define CHAR_ARG    int
#else
	#define TCHAR_ARG   TCHAR
	#define WCHAR_ARG   WCHAR
	#define CHAR_ARG    char
#endif

#if defined(_68K_) || defined(_X86_)
	#define DOUBLE_ARG  _AFX_DOUBLE
#else
	#define DOUBLE_ARG  double
#endif

#define FORCE_ANSI      0x10000
#define FORCE_UNICODE   0x20000

void CString::FormatV(LPCTSTR lpszFormat, va_list argList)
{
	// Suppress the following Assert from MFC  - JM 1/15/99
	// ASSERT(AfxIsValidString(lpszFormat, FALSE));

	va_list argListSave = argList;

	// make a guess at the maximum length of the resulting string
	int nMaxLen = 0;
	for (LPCTSTR lpsz = lpszFormat; *lpsz != '\0'; lpsz = _tcsinc(lpsz))
	{
		// handle '%' character, but watch out for '%%'
		if (*lpsz != '%' || *(lpsz = _tcsinc(lpsz)) == '%')
		{
			nMaxLen += _tclen(lpsz);
			continue;
		}

		int nItemLen = 0;

		// handle '%' character with format
		int nWidth = 0;
		for (; *lpsz != '\0'; lpsz = _tcsinc(lpsz))
		{
			// check for valid flags
			if (*lpsz == '#')
				nMaxLen += 2;   // for '0x'
			else if (*lpsz == '*')
				nWidth = va_arg(argList, int);
			else if (*lpsz == '-' || *lpsz == '+' || *lpsz == '0' ||
				*lpsz == ' ')
				;
			else // hit non-flag character
				break;
		}
		// get width and skip it
		if (nWidth == 0)
		{
			// width indicated by
			nWidth = _ttoi(lpsz);
			for (; *lpsz != '\0' && _istdigit(*lpsz); lpsz = _tcsinc(lpsz))
				;
		}
		ASSERT(nWidth >= 0);

		int nPrecision = 0;
		if (*lpsz == '.')
		{
			// skip past '.' separator (width.precision)
			lpsz = _tcsinc(lpsz);

			// get precision and skip it
			if (*lpsz == '*')
			{
				nPrecision = va_arg(argList, int);
				lpsz = _tcsinc(lpsz);
			}
			else
			{
				nPrecision = _ttoi(lpsz);
				for (; *lpsz != '\0' && _istdigit(*lpsz); lpsz = _tcsinc(lpsz))
					;
			}
			ASSERT(nPrecision >= 0);
		}

		// should be on type modifier or specifier
		int nModifier = 0;
		switch (*lpsz)
		{
		// modifiers that affect size
		case 'h':
			nModifier = FORCE_ANSI;
			lpsz = _tcsinc(lpsz);
			break;
		case 'l':
			nModifier = FORCE_UNICODE;
			lpsz = _tcsinc(lpsz);
			break;

		// modifiers that do not affect size
		case 'F':
		case 'N':
		case 'L':
			lpsz = _tcsinc(lpsz);
			break;
		}

		// now should be on specifier
		switch (*lpsz | nModifier)
		{
		// single characters
		case 'c':
		case 'C':
			nItemLen = 2;
			va_arg(argList, TCHAR_ARG);
			break;
		case 'c'|FORCE_ANSI:
		case 'C'|FORCE_ANSI:
			nItemLen = 2;
			va_arg(argList, CHAR_ARG);
			break;
		case 'c'|FORCE_UNICODE:
		case 'C'|FORCE_UNICODE:
			nItemLen = 2;
			va_arg(argList, WCHAR_ARG);
			break;

		// strings
		case 's':
		{
			LPCTSTR pstrNextArg = va_arg(argList, LPCTSTR);
			if (pstrNextArg == NULL)
			   nItemLen = 6;  // "(null)"
			else
			{
			   nItemLen = lstrlen(pstrNextArg);
			   nItemLen = max(1, nItemLen);
			}
			break;
		}

		case 'S':
		{
#ifndef _UNICODE
			LPWSTR pstrNextArg = va_arg(argList, LPWSTR);
			if (pstrNextArg == NULL)
			   nItemLen = 6;  // "(null)"
			else
			{
			   nItemLen = wcslen(pstrNextArg);
			   nItemLen = max(1, nItemLen);
			}
#else
			LPCSTR pstrNextArg = va_arg(argList, LPCSTR);
			if (pstrNextArg == NULL)
			   nItemLen = 6; // "(null)"
			else
			{
			   nItemLen = lstrlenA(pstrNextArg);
			   nItemLen = max(1, nItemLen);
			}
#endif
			break;
		}

		case 's'|FORCE_ANSI:
		case 'S'|FORCE_ANSI:
		{
			LPCSTR pstrNextArg = va_arg(argList, LPCSTR);
			if (pstrNextArg == NULL)
			   nItemLen = 6; // "(null)"
			else
			{
			   nItemLen = lstrlenA(pstrNextArg);
			   nItemLen = max(1, nItemLen);
			}
			break;
		}

#ifndef _MAC
		case 's'|FORCE_UNICODE:
		case 'S'|FORCE_UNICODE:
		{
			LPWSTR pstrNextArg = va_arg(argList, LPWSTR);
			if (pstrNextArg == NULL)
			   nItemLen = 6; // "(null)"
			else
			{
			   nItemLen = wcslen(pstrNextArg);
			   nItemLen = max(1, nItemLen);
			}
			break;
		}
#endif
		}

		// adjust nItemLen for strings
		if (nItemLen != 0)
		{
			nItemLen = max(nItemLen, nWidth);
			if (nPrecision != 0)
				nItemLen = min(nItemLen, nPrecision);
		}
		else
		{
			switch (*lpsz)
			{
			// integers
			case 'd':
			case 'i':
			case 'u':
			case 'x':
			case 'X':
			case 'o':
				va_arg(argList, int);
				nItemLen = 32;
				nItemLen = max(nItemLen, nWidth+nPrecision);
				break;
#if 0
// We (Saltmine) are not currently supporting formatting of real numbers 1/15/99
			case 'e':
			case 'f':
			case 'g':
			case 'G':
				va_arg(argList, DOUBLE_ARG);
				nItemLen = 128;
				nItemLen = max(nItemLen, nWidth+nPrecision);
				break;
#endif

			case 'p':
				va_arg(argList, void*);
				nItemLen = 32;
				nItemLen = max(nItemLen, nWidth+nPrecision);
				break;

			// no output
			case 'n':
				va_arg(argList, int*);
				break;

			default:
				ASSERT(FALSE);  // unknown formatting option
			}
		}

		// adjust nMaxLen for output nItemLen
		nMaxLen += nItemLen;
	}

	GetBuffer(nMaxLen);

	// Got rid of MFC's VERIFY in next line - JM 1/15/99
	//VERIFY(_vstprintf(m_pchData, lpszFormat, argListSave) <= GetAllocLength());
	_vstprintf(m_pchData, lpszFormat, argListSave);
	
	ReleaseBuffer();

	va_end(argListSave);
}

// formatting (using wsprintf style formatting)
void CString::Format(LPCTSTR lpszFormat, ...)
{
	// Suppress the following Assert from MFC  - JM 1/15/99
	// ASSERT(AfxIsValidString(lpszFormat, FALSE));

	va_list argList;
	va_start(argList, lpszFormat);
	FormatV(lpszFormat, argList);
	va_end(argList);
}

void CString::TrimRight()
{
	CopyBeforeWrite();

	// find beginning of trailing spaces by starting at beginning (DBCS aware)
	LPTSTR lpsz = m_pchData;
	LPTSTR lpszLast = NULL;
	while (*lpsz != '\0')
	{
		if (_istspace(*lpsz))
		{
			if (lpszLast == NULL)
				lpszLast = lpsz;
		}
		else
			lpszLast = NULL;
		lpsz = _tcsinc(lpsz);
	}

	if (lpszLast != NULL)
	{
		// truncate at trailing space start
		*lpszLast = '\0';
		GetData()->nDataLength = static_cast<int>(lpszLast - m_pchData);
	}
}

void CString::TrimLeft()
{
	CopyBeforeWrite();

	// find first non-space character
	LPCTSTR lpsz = m_pchData;
	while (_istspace(*lpsz))
		lpsz = _tcsinc(lpsz);

	// fix up data and length
	int nDataLength = GetData()->nDataLength - static_cast<int>(lpsz - m_pchData);
	memmove(m_pchData, lpsz, (nDataLength+1)*sizeof(TCHAR));
	GetData()->nDataLength = nDataLength;
}

BOOL CString::LoadString(UINT nID)
{
    // try fixed buffer first (to avoid wasting space in the heap)
    TCHAR szTemp[256];
    int nLen = ::AfxLoadString(nID, szTemp, _countof(szTemp));
    if (_countof(szTemp) - nLen > CHAR_FUDGE)
    {
        *this = szTemp;
        return nLen > 0;
    }

    // try buffer size of 512, then larger size until entire string is retrieved
    int nSize = 256;
    do
    {
        nSize += 256;
        nLen = ::AfxLoadString(nID, GetBuffer(nSize-1), nSize);
    } while (nSize - nLen <= CHAR_FUDGE);
    ReleaseBuffer();

    return nLen > 0;
}

bool __stdcall operator ==(const CString& s1, const CString& s2)
{
	return (s1.GetLength() == s2.GetLength() && ! _tcscmp((LPCTSTR)s1, (LPCTSTR)s2) );
}

bool __stdcall operator ==(const CString& s1, LPCTSTR s2)
{
	return (! _tcscmp((LPCTSTR)s1, s2) );
}

bool __stdcall operator ==(LPCTSTR s1, const CString& s2)
{
	return (! _tcscmp(s1, (LPCTSTR)s2) );
}

bool __stdcall operator !=(const CString& s1, const CString& s2)
{
	return (s1.GetLength() != s2.GetLength() || _tcscmp((LPCTSTR)s1, (LPCTSTR)s2) );
}

bool __stdcall operator !=(const CString& s1, LPCTSTR s2)
{
	return (_tcscmp((LPCTSTR)s1, s2) ) ? true : false;
}

bool __stdcall operator !=(LPCTSTR s1, const CString& s2)
{
	return (_tcscmp(s1, (LPCTSTR)s2) ) ? true : false;
}

bool __stdcall operator < (const CString& s1, const CString& s2)
{
	return (_tcscmp((LPCTSTR)s1, (LPCTSTR)s2) <0 );
}

bool __stdcall operator < (const CString& s1, LPCTSTR s2)
{
	return (_tcscmp((LPCTSTR)s1, s2) <0 );
}

bool __stdcall operator < (LPCTSTR s1, const CString& s2)
{
	return (_tcscmp(s1, (LPCTSTR)s2) <0 );
}

CString operator+(LPCTSTR lpsz, const CString& string)
{
	return CString(lpsz) + string;
}

void CString::Init()
{ 
	m_pchData = afxDataNil->data(); 
}

CStringData* CString::GetData() const
{ 
	if(m_pchData != NULL)
		return ((CStringData*)m_pchData)-1;
	return afxDataNil;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\apgtsstr.h ===
//
// MODULE: APGTSSTR.H
//
// PURPOSE: header file for DLL Growable string object CString 
//	(pretty much a la MFC, but avoids all that MFC overhead)
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel Joe Mabel (reworked code from Microsoft's MFC sources)
// 
// ORIGINAL DATE: 8-2-96 Roman Mach; totally re-implemented 1/15/99 Joe Mabel 
//
// NOTES: 
// 1. As of 1/99, re-implemented based on MFC's implementation.  Pared down
//	to what we use.
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V3.0		7-24-98		JM		Abstracted this out as a separate header.
// V3.1		1-15-99		JM		Redo based on MFC implementation
//

#ifndef __APGTSSTR_H_
#define __APGTSSTR_H_ 1

#include <windows.h>
#include <tchar.h>

#include "apgtsassert.h"

// determine number of elements in an array (not bytes)
#define _countof(array) (sizeof(array)/sizeof(array[0]))


struct CStringData
{
	long nRefs;     // reference count
	int nDataLength;
	int nAllocLength;
	// TCHAR data[nAllocLength]

	TCHAR* data()
		{ return (TCHAR*)(this+1); }
};


class CString {
public:

// Constructors
	CString();
	CString(LPCTSTR string);
	CString(const CString &string);
	~CString();
	
// Attributes & Operations
	// as an array of characters
	int GetLength() const;
	bool IsEmpty() const;

	TCHAR GetAt(int nIndex) const; // 0 based
	TCHAR operator[](int nIndex) const; // same as GetAt
	operator LPCTSTR() const;

	// overloaded assignment
	const CString& operator=(const CString &string);
	const CString& operator=(LPCTSTR string);
	const CString& operator=(TCHAR ch);
#ifdef _UNICODE
    const CString& operator=(LPCSTR lpsz);
#else  // !_UNICODE
    const CString& operator=(LPCWSTR lpsz);
#endif // !_UNICODE

	// string concatenation
	const CString& operator+=(const CString &string);
	const CString& operator+=(LPCTSTR string);

	CString operator+(const CString& string2);
	CString operator+(LPCTSTR lpsz);

	// string comparison
	int CString::CompareNoCase(LPCTSTR lpsz) const
	{ return _tcsicmp(m_pchData, lpsz); }   // MBCS/Unicode aware

	LPTSTR GetBuffer(int);
	void Empty();

	LPTSTR GetBufferSetLength(int nNewLength);
	void ReleaseBuffer(int nNewLength = -1);

	// simple sub-string extraction
	CString Mid(int Left, int Count) const;
	CString Mid(int Left) const;
	CString Left(int amount) const;
	CString Right(int amount) const;

	// upper/lower/reverse conversion
	void MakeLower();

	// trimming whitespace (either side)
	void TrimRight();
	void TrimLeft();

	// look for a specific sub-string
	int Find(LPCTSTR lpszSub) const;
	int Find(LPCTSTR lpszSub, int nStart) const;	// Added function - RAB19991112.
	int Find(TCHAR c) const;
	int ReverseFind(TCHAR ch) const;
	enum
	{
		// Define the code returned when a find is unsuccessful.
		FIND_FAILED= -1
	} ;

	// simple formatting
	void Format( LPCTSTR lpszFormat, ... );

	// load from resource
	BOOL LoadString(UINT nID);

protected:
	LPTSTR m_pchData;   // pointer to ref counted string data

	// implementation helpers
	CStringData* GetData() const;
	void Init();
	void AllocCopy(CString& dest, int nCopyLen, int nCopyIndex, int nExtraLen) const;
	void AllocBuffer(int nLen);
	void AssignCopy(int nSrcLen, LPCTSTR lpszSrcData);
	void ConcatCopy(int nSrc1Len, LPCTSTR lpszSrc1Data, int nSrc2Len, LPCTSTR lpszSrc2Data);
	void ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData);
	void FormatV(LPCTSTR lpszFormat, va_list argList);
	void CopyBeforeWrite();
	void AllocBeforeWrite(int nL65en);
	void Release();
	static void PASCAL Release(CStringData* pData);
	static int PASCAL SafeStrlen(LPCTSTR lpsz);
};

// Compare helpers
bool __stdcall operator ==(const CString& s1, const CString& s2);
bool __stdcall operator ==(const CString& s1, LPCTSTR s2);
bool __stdcall operator ==(LPCTSTR s1, const CString& s2);

bool __stdcall operator !=(const CString& s1, const CString& s2);
bool __stdcall operator !=(const CString& s1, LPCTSTR s2);
bool __stdcall operator !=(LPCTSTR s1, const CString& s2);

bool __stdcall operator < (const CString& s1, const CString& s2);
bool __stdcall operator < (const CString& s1, LPCTSTR s2);
bool __stdcall operator < (LPCTSTR s1, const CString& s2);

CString operator+(LPCTSTR lpsz, const CString& string);

/////////////////////////////////////////////////////////////
// From Afx.inl
// These were all inlines, but some of them don't seem to happily work that way

inline CString::operator LPCTSTR() const
	{ return m_pchData; }

inline int PASCAL CString::SafeStrlen(LPCTSTR lpsz)
	{ return (lpsz == NULL) ? 0 : lstrlen(lpsz); }

inline TCHAR CString::operator[](int nIndex) const
{
	// same as GetAt
	ASSERT(nIndex >= 0);
	ASSERT(nIndex < GetData()->nDataLength);
	return m_pchData[nIndex];
}

inline int CString::GetLength() const
	{ return GetData()->nDataLength; }

inline bool CString::IsEmpty() const
	{ return GetData()->nDataLength == 0; }

inline TCHAR CString::GetAt(int nIndex) const
{
	ASSERT(nIndex >= 0);
	ASSERT(nIndex < GetData()->nDataLength);
	return m_pchData[nIndex];
}

#endif // __APGTSSTR_H_ 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\apiwraps.h ===
//
// MODULE: APIwraps.h
//
// PURPOSE: Encapsulate common blocks of API functionality within a class.
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Randy Biley
// 
// ORIGINAL DATE: 9-30-98
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		09-30-98	RAB
//

#include<windows.h>

class APIwraps
{
public:
	APIwraps();
	~APIwraps();

public:
	static bool WaitAndLogIfSlow(	
		HANDLE hndl,		// Handle of object to be waited on.
		LPCSTR srcFile,		// Calling source file (__FILE__), used for logging.
							// LPCSTR, not LPCTSTR, because __FILE__ is a char*, not a TCHAR*
		int srcLine,		// Calling source line (__LINE__), used for logging.
		DWORD TimeOutVal = 60000	// Time-out interval in milliseconds, after
									// which we log error & wait infinitely.
	);
} ;

// these must be macros, because otherwise __FILE__ and __LINE__ won't indicate the
//	calling location.
#define WAIT_INFINITE(hndl) APIwraps::WaitAndLogIfSlow(hndl, __FILE__, __LINE__)
#define WAIT_INFINITE_EX(hndl, TimeOutVal) APIwraps::WaitAndLogIfSlow(hndl, __FILE__, __LINE__, TimeOutVal)
//
// EOF.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\apiwraps.cpp ===
//
// MODULE: APIwraps.CPP
//
// PURPOSE: Encapsulate common blocks of API functionality within a class.
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Randy Biley
// 
// ORIGINAL DATE: 9-30-98
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		09-30-98	RAB
//

#include "stdafx.h"
#include "apiwraps.h"
#include "event.h"
#include "baseexception.h"


APIwraps::APIwraps()
{
}

APIwraps::~APIwraps()
{
}

// Function used to handle the situation where we wish to detect sluggish or stalled objects 
// and log this delay before going into an infinite wait. 
/*static*/ bool APIwraps::WaitAndLogIfSlow(	
					HANDLE hndl,		// Handle of object to be waited on.
					LPCSTR srcFile,		// Calling source file (__FILE__), used for logging.
										// LPCSTR, not LPCTSTR, because __FILE__ is a char*, not a TCHAR*
					int srcLine,		// Calling source line (__LINE__), used for logging.
					DWORD TimeOutVal /*=60000*/	// Time-out interval in millisecond.  After
										// this we log an error, then wait infinitely
					)
{
	bool	bRetVal= false;
	DWORD	nWaitRetVal;
	CBuildSrcFileLinenoStr SrcLoc( srcFile, srcLine );

	nWaitRetVal= ::WaitForSingleObject( hndl, TimeOutVal );
	if (nWaitRetVal == WAIT_FAILED)
	{
		// very bad news, should never happen
		DWORD dwErr = ::GetLastError();
		CString strErr;
		strErr.Format(_T("%d"), dwErr);
		CBuildSrcFileLinenoStr SrcLoc3(__FILE__, __LINE__);
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc3.GetSrcFileLineStr(), 
								_T("Thread wait failed."), 
								strErr, 
								EV_GTS_ERROR_STUCK_THREAD ); 
	}
	else if (nWaitRetVal == WAIT_TIMEOUT)
	{
		// Initial wait timed out, note in log, and wait infinitely.
		CBuildSrcFileLinenoStr SrcLoc1(__FILE__, __LINE__);
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc1.GetSrcFileLineStr(), 
								_T("Thread wait exceeded initial timeout interval."), 
								_T(""), 
								EV_GTS_STUCK_THREAD ); 

		nWaitRetVal= ::WaitForSingleObject( hndl, INFINITE );

		// If successfully got what we were waiting for (after logging an apparent
		//	problem), log the fact that it's ultimately OK.
		if (nWaitRetVal == WAIT_OBJECT_0)
		{
			CBuildSrcFileLinenoStr SrcLoc2(__FILE__, __LINE__);
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc2.GetSrcFileLineStr(), 
									_T("Thread infinite wait succeeded."), 
									_T(""), 
									EV_GTS_STUCK_THREAD ); 
			bRetVal= true;
		}
	}
	else
	{
		// We don't really care whether it's WAIT_OBJECT_0 or WAIT_ABANDONED.
		// Either way, we got what we were waiting for
		bRetVal= true;
	}

	return( bRetVal );
}

//
// EOF.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\apgtstscread.cpp ===
//
// MODULE: APGTSTSCREAD.CPP
//
// PURPOSE: TSC file reading classes
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR:	Randy Biley
// 
// ORIGINAL DATE: 01-19-1999
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		01-19-1999	RAB
//

#include "stdafx.h"
#include "apgtstscread.h"
#include "CharConv.h"
#include "event.h"


// Utilize an unnamed namespace to limit scope to this source file
namespace
{ 
const CString kstr_CacheSig=		_T("TSCACH03");
const CString kstr_MapFrom=			_T("MAPFROM ");
const CString kstr_NodeStateDelim=	_T(":");
const CString kstr_NodePairDelim=	_T(",");
const CString kstr_MapTo=			_T("MAPTO ");
const CString kstr_CacheEnd=		_T("END");
}


CAPGTSTSCReader::CAPGTSTSCReader( CPhysicalFileReader * pPhysicalFileReader, CCache *pCache )
			   : CTextFileReader( pPhysicalFileReader )
{
	m_pCache= pCache;
}

CAPGTSTSCReader::~CAPGTSTSCReader()
{
}


void CAPGTSTSCReader::Parse()
{
	long save_pos = 0;

	LOCKOBJECT();
	save_pos = GetPos();
	SetPos(0);

	try 
	{
		vector<CString> arrLines;
		

		// pump file content into array of lines.
		CString strLine;
		while (GetLine( strLine ))
			arrLines.push_back( strLine );


		// parse string-by-string.
		bool bFirstLine= true;
		for (vector<CString>::iterator iCurLine = arrLines.begin(); iCurLine < arrLines.end(); iCurLine++)
		{
			// Prepare the line for parsing.
			CString strCur= *iCurLine;
			strCur.TrimLeft();
			strCur.TrimRight();

			if (bFirstLine)
			{
				// Verify that this file has the correct signature.
				if (-1 == strCur.Find( kstr_CacheSig ))
				{
					// Unknown type of file, exit the for loop.  
					// >>>	Should there be error handling/reporting here???  RAB-19990119.
					break;
				}
				bFirstLine= false;
			}
			else if (-1 != strCur.Find( kstr_CacheEnd ))
			{
				// Located the end of file marker, exit the for loop.  
				break;
			}
			else 
			{	
				// Look for the first line of a MapFrom-MapTo pair.
				int nPos= strCur.Find( kstr_MapFrom );
				if (-1 != nPos)
				{
					CBasisForInference	BasisForInference;
					bool				bHasBasisForInference= false;

					// Move the position marker over the MapFrom key word.
					nPos+= kstr_MapFrom.GetLength();

					// Extract all of the node state pairs from the MapFrom line.
					do
					{
						CString	strNode;
						CString	strState;
						int		nNodePos;
						
						// Jump over the leading line format or the node pair delimiter.
						strCur= strCur.Mid( nPos );
						strCur.TrimLeft();
						
						// Look for the delimiter between a node-state pair.
						nNodePos= strCur.Find( kstr_NodeStateDelim );
						if (-1 != nNodePos)
						{
							// Extract the string containing the node value and 
							// then step over the node state delimiter.
							strNode= strCur.Left( nNodePos );
							strCur= strCur.Mid( nNodePos + kstr_NodeStateDelim.GetLength() );

							// Extract the string containing the state value.
							nPos= strCur.Find( kstr_NodePairDelim );
							if (-1 == nPos)
							{
								// We have found the last state value, copy the remaining string.
								strState= strCur;
							}
							else
							{
								// Extract up to the node pair delimiter and move the
								// position marker past that point.
								strState= strCur.Left( nPos );
								nPos+= kstr_NodePairDelim.GetLength();
							}

							if (strNode.GetLength() && strState.GetLength())
							{
								// It appears that we have a valid node-state pair so add
								// them to the basis for inference.
								NID nNid= atoi( strNode );
								IST nIst= atoi( strState );

								BasisForInference.push_back( CNodeStatePair( nNid, nIst )); 
								bHasBasisForInference= true;
							}
							else
							{
								// >>>	This condition should not occur, 
								//		error handling/reporting???  RAB-19990119.
								nPos= -1;
							}
						}
						else
							nPos= -1;

					} while (-1 != nPos) ;


					// Now search for recommendations if the basis for inference was okay.
					CRecommendations	Recommendations;
					bool				bHasRecommendations= false;
					if (bHasBasisForInference)
					{
						// Move to the next line to prepare for searching for a matching 
						// MapTo line.
						iCurLine++;
						if (iCurLine < arrLines.end())
						{
							// Prep the temporary string.
							strCur= *iCurLine;
							strCur.TrimLeft();
							strCur.TrimRight();

							// Look for the matching MapTo element.
							nPos= strCur.Find( kstr_MapTo );
							if (-1 != nPos)
							{
								CString strRecommend;
								
								// Extract all of the recommendations from the MapTo line.
								nPos+= kstr_MapTo.GetLength();
								do
								{
									// Jump over the leading line format or the node pair delimiter.
									strCur= strCur.Mid( nPos );
									strCur.TrimLeft();
									
									// Extract the recommendations string value.
									nPos= strCur.Find( kstr_NodePairDelim );
									if (-1 == nPos)
										strRecommend= strCur;
									else
									{
										strRecommend= strCur.Left( nPos );
										nPos+= kstr_NodePairDelim.GetLength();
									}

									if (strRecommend.GetLength())
									{
										Recommendations.push_back( atoi( strRecommend ) );
										bHasRecommendations= true;
									}
									else
									{
										// >>>	This condition should not occur, 
										//		error handling/reporting???  RAB-19990119.
										nPos= -1;
									}

								} while (-1 != nPos) ;
							}
						}
					}
				
					// We have both items so add them to the cache.
					if (bHasRecommendations && bHasBasisForInference)
						m_pCache->AddCacheItem( BasisForInference, Recommendations );
				}
			}
		}
	} 
	catch (exception& x)
	{
		SetPos(save_pos);
		UNLOCKOBJECT();

		CString str;
		// Note STL exception in event log and rethrow exception.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								CCharConversion::ConvertACharToString(x.what(), str), 
								_T(""), 
								EV_GTS_STL_EXCEPTION ); 
		throw;
	}

	SetPos(save_pos);
	UNLOCKOBJECT();

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\apgtstscread.h ===
//
// MODULE: APGTSTSCREAD.H
//
// PURPOSE: TSC file reading classes
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR:	Randy Biley
// 
// ORIGINAL DATE: 01-19-1999
//
// NOTES: 
//	Typical TSC file content might be:
//		TSCACH03
//		MAPFROM 1:1
//		MAPTO 3,5,13,9,16
//		:
//		:
//		:
//		MAPFROM 1:1,3:0
//		MAPTO 5,13,9,16
//		END
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		01-19-1999	RAB
//

#ifndef __APGTSTSCREAD_H_
#define __APGTSTSCREAD_H_

#include "fileread.h"
#include "apgtscac.h"


class CAPGTSTSCReader : public CTextFileReader
{
private:
	CCache *m_pCache;

public:
	CAPGTSTSCReader( CPhysicalFileReader * pPhysicalFileReader, CCache *pCache );
   ~CAPGTSTSCReader();

protected:
	virtual void Parse(); 
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\baseexception.h ===
//
// MODULE: BaseException.
//
// PURPOSE: interface for CBaseException class.	
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 9-24-98
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		9-24-98		RAB     Broke class out of stateless.h and now derive from STL exception.
//

#ifndef __BASEEXCEPTION_H_
#define __BASEEXCEPTION_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "apgtsstr.h"
#include <exception>



////////////////////////////////////////////////////////////////////////////////////
// utility class to strip out the path of a filename and append the line number.
/////////////////////////////////////////////////////////////////////////////////////
class CBuildSrcFileLinenoStr
{
public:
	// source_file is LPCSTR rather than LPCTSTR because __FILE__ is char[35]
	CBuildSrcFileLinenoStr( LPCSTR source_file, int line );
	virtual ~CBuildSrcFileLinenoStr() {}
	CString GetSrcFileLineStr() const; 

private:
	CString	m_strFileLine;	// source file (__FILE__) and line number (__LINE__) of code throwing exception (__FILE__)
};


////////////////////////////////////////////////////////////////////////////////////
// basic exception class
/////////////////////////////////////////////////////////////////////////////////////
class CBaseException : public exception
{
public:
	// source_file is LPCSTR rather than LPCTSTR because __FILE__ is char[35]
	CBaseException( LPCSTR source_file, int line );
	virtual ~CBaseException() {}
	CString GetSrcFileLineStr() const; 

private:
	CString	m_strFileLine;	// source file (__FILE__) and line number (__LINE__) of code throwing exception (__FILE__)
};


////////////////////////////////////////////////////////////////////////////////////
// Class to handle general exception conditions.
// Constructor takes a source file name, source file line number, and a developer-defined
// error code and error message.
class CGeneralException : public CBaseException
{
public:
	enum eErr 
	{
		eErrMemAllocFatal,
		eErrMemAllocNonFatal
	} m_eErr;

public:
	CGeneralException(	LPCSTR srcFile,		// Source file from which the exception was thrown. 
						int srcLineNo,		// Source line from which the exception was thrown.
						LPCTSTR strErrMsg,	// Developer defined error message for the exception.
						DWORD nErrCode		// Developer defined error code for the exception. 
						);;
	virtual ~CGeneralException() {}
	DWORD	GetErrorCode() const; 
	CString GetErrorMsg() const; 

private:
	CString	m_strErrMsg;	// Developer-defined exception error message.
	DWORD	m_nErrCode;		// Developer-defined exception error code.
};
////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////
// Class to handle general system call generated exception conditions.
// Constructor takes a source file name, source file line number, and a developer-defined
// error code and error message.  Automatically generates an internal string from the last
// system error code.
class CGenSysException : public CGeneralException
{
public:
	CGenSysException(	LPCSTR srcFile,	// Source file from which the exception was thrown. 
											// LPCSTR rather than LPCTSTR because __FILE__ is char[35]
						int srcLineNo,		// Source line from which the exception was thrown.
						LPCTSTR strErrMsg,	// Developer defined error message for the exception.
						DWORD nErrCode		// Developer defined error code for the exception. 
						);
	virtual ~CGenSysException() {}
	CString GetSystemErrStr() const; 

private:
	CString	m_strSystemErr;	// String generated from the last system error code.
};
////////////////////////////////////////////////////////////////////////////////////


#endif 

//
// EOF.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\bn.cpp ===
//
// MODULE: BN.cpp
//
// PURPOSE: implementation of the CBeliefNetwork class
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 8-31-98
//
// NOTES: 
// 1. Based on old apgtsdtg.cpp
// 2. all methods (except constructor/destructor) must LOCKOBJECT around code that uses BNTS.
//	BNTS has "state".  These functions are all written so that they make no assumptions about
//	state on entry, presenting the calling class with a stateless object.
// 3. In theory, we could have separate locking for the cache independent of locking 
//	CBeliefNetwork.  The idea would be that if you needed only the cache to get your 
//	inference, you wouldn't have to wait for access to BNTS.  
//	>>>(ignore for V3.0) This is one of our best bets if performance is not good enough.  JM 9/29/98
//
// Version	Date		By		Comments
//---------------------------------------------------------------------
// V3.0		8-31-98		JM		
//

#include "stdafx.h"
#include "propnames.h"
#include "BN.h"
#include "CharConv.h"
#include "event.h"
#ifdef LOCAL_TROUBLESHOOTER
#include "CHMFileReader.h"
#else
#include "fileread.h"
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CBeliefNetwork::CBeliefNetwork(LPCTSTR path)
	:
	CDSCReader( CPhysicalFileReader::makeReader( path ) ),
	m_bInitialized(false),
	m_bSnifferIntegration(false)
{
}

CBeliefNetwork::~CBeliefNetwork()
{
}

void CBeliefNetwork::Initialize()
{
	LOCKOBJECT();
	if (! m_bInitialized)
	{
		BNTS * pbnts = pBNTS();
		if (pbnts)
		{
			m_bSnifferIntegration = false;

			///////////////////////////////////////////////////////////////////
			// Does not matter for online TS (list is empty on initialization),
			//  but for local TS m_Cache can contain cache data read from file.
			//m_Cache.Clear();
			///////////////////////////////////////////////////////////////////

			m_arrnidProblem.clear();
			m_arrNodeTypeAll.clear();

			// loop through nodes looking for problem nodes and build local problem node array
			// also, determine if any node has a property which implies the intent of 
			//	integrating with a sniffer.
			int acnid= CNode();
			for (NID anid=0; anid < acnid; anid++) 
			{
				if (pbnts->BNodeSetCurrent(anid))
				{
					ESTDLBL albl = pbnts->ELblNode();	// type of node (information/problem/fixable etc)

					try
					{
						if (albl == ESTDLBL_problem)
							m_arrnidProblem.push_back(anid);
						m_arrNodeTypeAll.push_back(SNodeType(anid, albl));
					}
					catch (exception& x)
					{
						CString str;
						// Note STL exception in event log.
						CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
						CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
												SrcLoc.GetSrcFileLineStr(), 
												CCharConversion::ConvertACharToString(x.what(), str), 
												_T(""), 
												EV_GTS_STL_EXCEPTION ); 
					}


#ifdef LOCAL_TROUBLESHOOTER
					LPCTSTR psz;
					if (pbnts->BNodePropItemStr(H_NODE_DCT_STR, 0) 
					&& (psz = pbnts->SzcResult()) != NULL
					&& *psz)
					{
						// There's a non-null property which only makes sense for a sniffer 
						// integration, so we assume that's what they've got in mind.
						m_bSnifferIntegration = true;
					}
#endif
				}
			}
			m_bInitialized = true;
		}
	}
	UNLOCKOBJECT();
}

// Access the relevant BNTS
// Calling function should have a lock before calling this (although probably harmless
//	is it doesn't!)
BNTS * CBeliefNetwork::pBNTS() 
{
	if (!IsRead())
		return NULL;
	return &m_Network;
};

// clear all node states
// We can't use BNTS::Clear() because that actually throws away the model itself.
void CBeliefNetwork::ResetNodes(const CBasisForInference & BasisForInference)
{
	LOCKOBJECT();
	BNTS * pbnts = pBNTS();
	if (pbnts)
	{
		int cnid = BasisForInference.size();

		// Set all node states to NIL in BNTS storage
		for (UINT i = 0; i < cnid; i++) 
		{
			pbnts->BNodeSetCurrent(BasisForInference[i].nid());
			pbnts->BNodeSet(-1, false);	// Nil value
		}
	}
	UNLOCKOBJECT();
}

// Associate states with nodes.
// INPUT BasisForInference
// Note that all states must be valid states for the nodes, not (say) ST_UNKNOWN.  
//	Caller's responsibility.
bool CBeliefNetwork::SetNodes(const CBasisForInference & BasisForInference)
{
	LOCKOBJECT();
	BNTS * pbnts = pBNTS();
	bool bOK = true;
	if (pbnts)
	{
		int nNodes = BasisForInference.size();
		for (int i= 0; i<nNodes; i++)
		{
			pbnts->BNodeSetCurrent(BasisForInference[i].nid());
			if (!pbnts->BNodeSet(BasisForInference[i].state(), false))
				bOK = false;	// failed to set state.  This should never happen on valid
								// user query.
		}
	}
	UNLOCKOBJECT();
	return bOK;
}

// OUTPUT Recommendations: list of recommendations
// RETURN:
// RS_OK = SUCCESS.  Note that Recommendations can return empty if there is nothing to recommend.
// RS_Impossible = Recommendations will return empty.
// RS_Broken = Recommendations will return empty.
int CBeliefNetwork::GetRecommendations(
	   const CBasisForInference & BasisForInference, 
	   CRecommendations & Recommendations)
{
	int ret = RS_OK;

	LOCKOBJECT();
	Initialize();
	Recommendations.clear();

	// see if we've already cached a result for this state of the world
	if (m_Cache.FindCacheItem(BasisForInference, Recommendations))
	{
		// Great.  We have a cache hit & return values have been filled in.
		m_countCacheHit.Increment();
	}
	else
	{
		m_countCacheMiss.Increment();

		BNTS * pbnts = pBNTS();
		if (pbnts)
		{
			SetNodes(BasisForInference);

			if (pbnts->BImpossible())
				ret = RS_Impossible;
			else if ( ! pbnts->BGetRecommendations())
				ret = RS_Broken;
			else
			{
				try
				{
					const int cnid = pbnts->CInt(); // Recommendation count
					if (cnid > 0)
					{
						// At least one recommendation
						const int *pInt = pbnts->RgInt();
						for (int i=0; i<cnid; i++)
							Recommendations.push_back(pInt[i]);
					}

					// We've got our return values together, but before we return, cache them.
					m_Cache.AddCacheItem(BasisForInference, Recommendations);
				}
				catch (exception& x)
				{
					CString str;
					// Note STL exception in event log.
					CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
					CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
											SrcLoc.GetSrcFileLineStr(), 
											CCharConversion::ConvertACharToString(x.what(), str),
											_T(""), 
											EV_GTS_STL_EXCEPTION ); 
				}
			}

			ResetNodes(BasisForInference);
		}
	}


	UNLOCKOBJECT();
	return ret;
}

// return the number of nodes in the model
int CBeliefNetwork::CNode ()
{
	int ret = 0;
	LOCKOBJECT();
	BNTS * pbnts = pBNTS();
	if (pbnts)
		ret = pbnts->CNode();

	UNLOCKOBJECT();
	return ret;
}

//  Return the index of a node given its symbolic name
int CBeliefNetwork::INode (LPCTSTR szNodeName)
{
	int ret = -1;
	LOCKOBJECT();
	BNTS * pbnts = pBNTS();
	if (pbnts)
		ret = pbnts->INode(szNodeName);

	UNLOCKOBJECT();
	return ret;
}

// OUTPUT *parrnid - refernce to array of NIDs of all problem nodes
// RETURN number of values in *parrnid
int CBeliefNetwork::GetProblemArray(vector<NID>* &parrnid)
{
	int ret = 0;
	LOCKOBJECT();
	Initialize();
	parrnid = &m_arrnidProblem;
	ret = m_arrnidProblem.size();
	UNLOCKOBJECT();
	return ret;
}

// OUTPUT arrOut - refernce to array of NIDs of all nodes, that have type listed in arrTypeInclude
// RETURN number of values in arrOut
int CBeliefNetwork::GetNodeArrayIncludeType(vector<NID>& arrOut, const vector<ESTDLBL>& arrTypeInclude)
{
	int ret = 0;
	LOCKOBJECT();
	arrOut.clear();
	Initialize();
	for (vector<SNodeType>::iterator i = m_arrNodeTypeAll.begin(); i < m_arrNodeTypeAll.end(); i++)
	{
		for (vector<ESTDLBL>::const_iterator j = arrTypeInclude.begin(); j < arrTypeInclude.end(); j++)
			if (i->Type == *j)
				break;

		if (j != arrTypeInclude.end())
			arrOut.push_back(i->Nid);
	}
	ret = arrOut.size();
	UNLOCKOBJECT();
	return ret;
}

// OUTPUT arrOut - refernce to array of NIDs of all nodes, that do NOT have type listed in arrTypeExclude
// RETURN number of values in arrOut
int CBeliefNetwork::GetNodeArrayExcludeType(vector<NID>& arrOut, const vector<ESTDLBL>& arrTypeExclude)
{
	int ret = 0;
	LOCKOBJECT();
	arrOut.clear();
	Initialize();
	for (vector<SNodeType>::iterator i = m_arrNodeTypeAll.begin(); i < m_arrNodeTypeAll.end(); i++)
	{
		for (vector<ESTDLBL>::const_iterator j = arrTypeExclude.begin(); j < arrTypeExclude.end(); j++)
			if (i->Type == *j)
				break;

		if (j == arrTypeExclude.end())
			arrOut.push_back(i->Nid);
	}
	ret = arrOut.size();
	UNLOCKOBJECT();
	return ret;
}

// ----------------------------------------
// simple properties
// ----------------------------------------

// return a STRING property of the net
CString CBeliefNetwork::GetNetPropItemStr(LPCTSTR szPropName)
{
	CString strRet;
	LOCKOBJECT();
	BNTS * pbnts = pBNTS();
	if (!pbnts)
		return CString(_T(""));

	if (pbnts->BNetPropItemStr(szPropName, 0))
		strRet = pbnts->SzcResult();
	UNLOCKOBJECT();
	return strRet;
}

// return a REAL property of the net
bool CBeliefNetwork::GetNetPropItemNum(LPCTSTR szPropName, double& numOut)
{
	bool bRet = false;
	LOCKOBJECT();
	BNTS * pbnts = pBNTS();
	if (!pbnts)
		return false;

	bRet = pbnts->BNetPropItemReal(szPropName, 0, numOut) ? true : false;
	UNLOCKOBJECT();
	return bRet;
}

// return a STRING property of a node or state
// For most properties, state is irrelevant, and default of 0 is the appropriate input.
// However, if there are per-state values, passing in the appropriate state number
//	will get you the appropriate value.
CString CBeliefNetwork::GetNodePropItemStr(NID nid, LPCTSTR szPropName, IST state /*= 0 */)
{
	CString strRet;
	LOCKOBJECT();
	BNTS * pbnts = pBNTS();
	if (pbnts && pbnts->BNodeSetCurrent(nid))
	{
		if (pbnts->BNodePropItemStr(szPropName, state))
			strRet = pbnts->SzcResult();
	}
	UNLOCKOBJECT();
	return strRet;
}

// $MAINT - This function is not currently used in any of the troubleshooters.  RAB-19991103.
// return a REAL property of a node or state
// For most properties, state is irrelevant, and default of 0 is the appropriate input.
// However, if there are per-state values, passing in the appropriate state number
//	will get you the appropriate value.
bool CBeliefNetwork::GetNodePropItemNum(NID nid, LPCTSTR szPropName, double& numOut, IST state /*= 0*/)
{
	bool bRet = false;
	LOCKOBJECT();
	BNTS * pbnts = pBNTS();
	if (pbnts && pbnts->BNodeSetCurrent(nid))
	{
		bRet = pbnts->BNodePropItemReal(szPropName, state, numOut) ? true : false;
	}
	UNLOCKOBJECT();
	return bRet;
}

CString CBeliefNetwork::GetNodeSymName(NID nid)
{
	CString strRet;
	LOCKOBJECT();
	BNTS * pbnts = pBNTS();
	if (pbnts && pbnts->BNodeSetCurrent(nid))
	{
		pbnts->NodeSymName();
		strRet = pbnts->SzcResult();
	}
	UNLOCKOBJECT();
	return strRet;
}

CString CBeliefNetwork::GetNodeFullName(NID nid)
{
	CString strRet;
	LOCKOBJECT();
	BNTS * pbnts = pBNTS();
	if (pbnts && pbnts->BNodeSetCurrent(nid))
	{
		pbnts->NodeFullName();
		strRet = pbnts->SzcResult();
	}
	UNLOCKOBJECT();
	return strRet;
}

CString CBeliefNetwork::GetStateName(NID nid, IST state)
{
	CString strRet;
	LOCKOBJECT();
	BNTS * pbnts = pBNTS();
	if (pbnts && pbnts->BNodeSetCurrent(nid))
	{
		pbnts->NodeStateName(state);
		strRet = pbnts->SzcResult();
	}
	UNLOCKOBJECT();
	return strRet;
}


// ----------------------------------------
// "multiline" properties
//	these date back to when there was a 255-byte limit on STRING and longer strings
//	had to be represented by ARRAY OF STRING, later concatenated.
//	Backward compatibility still needed.
// ----------------------------------------

// Append a NET property (for Belief Network as a whole, not for one 
//	particular node) to str.
// INPUT szPropName - Property name
// INPUT szFormat - string to format each successive line.  Should contain one %s, otherwise
//	constant text.
CString CBeliefNetwork::GetMultilineNetProp(LPCTSTR szPropName, LPCTSTR szFormat)
{
	CString strRet;
	LOCKOBJECT();
	BNTS * pbnts = pBNTS();
	if (pbnts)
	{
		CString strTxt;

		for (int i = 0; pbnts->BNetPropItemStr(szPropName, i); i++)
		{
			strTxt.Format( szFormat, pbnts->SzcResult());
			strRet += strTxt;
		}
	}
	UNLOCKOBJECT();
	return strRet;
}

// Like GetMultilineNetProp, but for a NODE property item, for one particular node.
// INPUT/OUTPUT str - string to append to
// INPUT item - Property name
// INPUT szFormat - string to format each successive line.  Should contain one %s, otherwise
//	constant text.
CString CBeliefNetwork::GetMultilineNodeProp(NID nid, LPCTSTR szPropName, LPCTSTR szFormat)
{
	CString strRet;
	LOCKOBJECT();
	BNTS * pbnts = pBNTS();
	if (pbnts && pbnts->BNodeSetCurrent(nid))
	{
		CString strTxt;

		for (int i = 0; pbnts->BNodePropItemStr(szPropName, i); i++)
		{
			strTxt.Format( szFormat, pbnts->SzcResult());
			strRet += strTxt;
		}
	}
	UNLOCKOBJECT();
	return strRet;
}

int CBeliefNetwork::GetCountOfStates(NID nid)
{
	int ret = 0;
	LOCKOBJECT();
	BNTS * pbnts = pBNTS();
	if (pbnts && pbnts->BNodeSetCurrent(nid))
		ret = pbnts->INodeCst();
	UNLOCKOBJECT();
	return ret;
}

// returns true only for NIDs valid in the context of an abstract belief network.
// Doesn't know about troubleshooter-specific stuff like nidService.
bool CBeliefNetwork::IsValidNID(NID nid)
{
	return ( nid < CNode() );
}

bool CBeliefNetwork::IsCauseNode(NID nid)
{
	bool ret = false;
	LOCKOBJECT();
	BNTS * pbnts = pBNTS();
	if (pbnts && pbnts->BNodeSetCurrent(nid))
	{
		ESTDLBL lbl = pbnts->ELblNode();
		ret= (lbl == ESTDLBL_fixobs || lbl == ESTDLBL_fixunobs || lbl == ESTDLBL_unfix);
	}
	UNLOCKOBJECT();
	return ret;
}

bool CBeliefNetwork::IsProblemNode(NID nid)
{
	bool ret = false;
	LOCKOBJECT();
	BNTS * pbnts = pBNTS();
	if (pbnts && pbnts->BNodeSetCurrent(nid))
	{
		ret= (pbnts->ELblNode() == ESTDLBL_problem);
	}
	UNLOCKOBJECT();
	return ret;
}

bool CBeliefNetwork::IsInformationalNode(NID nid)
{
	bool ret = false;
	LOCKOBJECT();
	BNTS * pbnts = pBNTS();
	if (pbnts && pbnts->BNodeSetCurrent(nid))
	{
		ret= (pbnts->ELblNode() == ESTDLBL_info);
	}
	UNLOCKOBJECT();
	return ret;
}

bool CBeliefNetwork::UsesSniffer()
{
	bool ret = false;
	LOCKOBJECT();
	Initialize();
	ret = m_bSnifferIntegration;
	UNLOCKOBJECT();
	return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\baseexception.cpp ===
//
// MODULE: BaseException.CPP
//
// PURPOSE: standard exception handling classes
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Randy Biley
// 
// ORIGINAL DATE: 9-24-98
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		09-24-98	RAB
//

#include "stdafx.h"
#include "BaseException.h"
#include "fileread.h"
#include "CharConv.h"


////////////////////////////////////////////////////////////////////////////////////
// CBuildSrcFileLinenoStr
////////////////////////////////////////////////////////////////////////////////////
// srcFile is LPCSTR rather than LPCTSTR because __FILE__ is char[35]
CBuildSrcFileLinenoStr::CBuildSrcFileLinenoStr(	LPCSTR srcFile, int srcLineNo )
{
	// Reduce the source file name down the name and extension if possible.
	CString str;
	 
	CString tmp= CAbstractFileReader::GetJustName( CCharConversion::ConvertACharToString(srcFile, str) );
	CString strLineNo;

	strLineNo.Format( _T("-L%d"), srcLineNo );
	m_strFileLine= tmp + strLineNo;
}

CString CBuildSrcFileLinenoStr::GetSrcFileLineStr() const 
{
	// Return string that contains the source file name and the line number.
	return m_strFileLine;
}


////////////////////////////////////////////////////////////////////////////////////
// CBaseException
////////////////////////////////////////////////////////////////////////////////////
// srcFile is LPCSTR rather than LPCTSTR because __FILE__ is char[35]
CBaseException::CBaseException(	LPCSTR srcFile, int srcLineNo )
{
	CBuildSrcFileLinenoStr str( srcFile, srcLineNo );
	m_strFileLine= str.GetSrcFileLineStr();
}

CString CBaseException::GetSrcFileLineStr() const 
{
	// Return string that contains the source file name and the line number.
	return m_strFileLine;
}


////////////////////////////////////////////////////////////////////////////////////
// CGeneralException
////////////////////////////////////////////////////////////////////////////////////
// srcFile is LPCSTR rather than LPCTSTR because __FILE__ is char[35]
CGeneralException::CGeneralException(	LPCSTR srcFile, int srcLineNo, 
										LPCTSTR strErrMsg, DWORD nErrCode )
					: CBaseException( srcFile, srcLineNo ),
					  m_strErrMsg( strErrMsg ),
					  m_nErrCode( nErrCode )
{
}

DWORD CGeneralException::GetErrorCode() const 
{
	return m_nErrCode;
}

CString CGeneralException::GetErrorMsg() const 
{
	return m_strErrMsg;
}


////////////////////////////////////////////////////////////////////////////////////
// CGenSysException
////////////////////////////////////////////////////////////////////////////////////
// srcFile is LPCSTR rather than LPCTSTR because __FILE__ is char[35]
CGenSysException::CGenSysException(	LPCSTR srcFile, int srcLineNo, 
									LPCTSTR strErrMsg, DWORD nErrCode )
					: CGeneralException( srcFile, srcLineNo, strErrMsg, nErrCode )
{
	// Format the last system error code as a string.
	m_strSystemErr.Format( _T("%lu"), ::GetLastError() );
}

CString CGenSysException::GetSystemErrStr() const 
{
	return m_strSystemErr;
}


//
// EOF.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\charconv.h ===
// CharConv.h: interface for the CCharConversion class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_CHARCONV_H__067972E5_6CFE_11D2_9615_00C04FC22ADD__INCLUDED_)
#define AFX_CHARCONV_H__067972E5_6CFE_11D2_9615_00C04FC22ADD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <windows.h>
#include "apgtsstr.h"

class CCharConversion  
{
public:
	static CString& ConvertWCharToString(LPCWSTR wsz, CString &strRetVal);
	static CString& ConvertACharToString(LPCSTR sz, CString &strRetVal);
};

#endif // !defined(AFX_CHARCONV_H__067972E5_6CFE_11D2_9615_00C04FC22ADD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\charconv.cpp ===
//
// MODULE: CharConv.CPP
//
// PURPOSE: conversion between char & TCHAR
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 
//
// NOTES: 
// 1. ConvertWCharToString pulled out of VersionInfo.
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0				    JM
//

#include "stdafx.h"
#include "CharConv.h"

// Convert Unicode ("wide character") to CString, regardless of whether this
//	program is built Unicode.  How this program is built determines the
//	underlying character type of CString.
// As a convenience, returns a refernce to strRetVal
/*static*/ CString& CCharConversion::ConvertWCharToString(LPCWSTR wsz, CString &strRetVal)
{
#ifdef UNICODE
	strRetVal = wsz;
#else
	TCHAR * pBuf;
	int bufsize = ::WideCharToMultiByte( 
						  CP_ACP, 
						  0, 	  
						  wsz, 
						  -1, 
						  NULL, 
						  0, 
						  NULL, 
						  NULL 
						 );
	pBuf = new TCHAR[bufsize];
	//[BC-03022001] - added check for NULL ptr to satisfy MS code analysis tool.
	if(pBuf)
	{
		::WideCharToMultiByte( 
							  CP_ACP, 
							  0, 	  
							  wsz, 
							  -1, 
							  pBuf, 
							  bufsize, 
							  NULL, 
							  NULL 
							 );

		strRetVal = pBuf;
		delete[] pBuf;
	}

#endif
	return strRetVal;
}

// Convert char* (ASCII/ANSI, not "wide" character) to CString, regardless of whether this
//	program is built Unicode.  How this program is built determines the
//	underlying character type of CString.
// As a convenience, returns a refernce to strRetVal
/*static*/ CString& CCharConversion::ConvertACharToString(LPCSTR sz, CString &strRetVal)
{
#ifdef UNICODE
	TCHAR * pBuf;
	int bufsize = ::MultiByteToWideChar( 
						  CP_ACP, 
						  0, 	  
						  sz, 
						  -1, 
						  NULL, 
						  0
						 );
	pBuf = new TCHAR[bufsize];
	//[BC-03022001] - added check for NULL ptr to satisfy MS code analysis tool.
	if(pBuf)
	{
		::MultiByteToWideChar( 
							  CP_ACP, 
							  0, 	  
							  sz, 
							  -1, 
							  pBuf, 
							  bufsize
							 );

		strRetVal = pBuf;
		delete[] pBuf;
	}

#else
	strRetVal = sz;
#endif
	return strRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\bnts.h ===
//
//	bnts.h:  Definitions for the Belief Network Troubleshooting object.
//
#ifndef _BNTS_H_
#define _BNTS_H_

//  BN system inclusions
#include "enumstd.h"		// Standard enumeration declarations for the BN system

// 'BNTS_EXPORT' should only be defined in the project that builds the DLL
#ifdef	BNTS_EXPORT
	//  We're building the DLL (exporting the class)
	#define	BNTS_RESIDENT __declspec(dllexport)
#else
	//  We're using the DLL (importing the class)
	#define	BNTS_RESIDENT __declspec(dllimport)
#endif

//  Forward declaration of internal belief network class
class MBNETDSCTS;										//  the encapsulated BN class
class GNODEMBND;										//  Discrete nodes
class LTBNPROP;											//  Property list
class ZSTR;

typedef const char * SZC;								//  simple alias
typedef char * SZ;
typedef double REAL;

////////////////////////////////////////////////////////////////////////////////////////////
//
//	class BNTS: the belief network troubleshooter
//
////////////////////////////////////////////////////////////////////////////////////////////
class BNTS_RESIDENT BNTS
{	
  public:
	//  CTOR and DTOR
	BNTS ();
	~ BNTS ();

	////////////////////////////////////////////////////////////////////
	//  Model-level queries and functions
	////////////////////////////////////////////////////////////////////
		//  Load and process a DSC-based model
	BOOL BReadModel ( SZC szcFn, SZC szcFnError = NULL );
		//  Return the number of (pre-expansion) nodes in the model
	int CNode ();
		//  Return the recommended nodes and, optionally, their values
	BOOL BGetRecommendations ();
		//  Return TRUE if the state of information is impossible
	BOOL BImpossible ();
		//  Return a property item string from the network
	BOOL BNetPropItemStr ( SZC szcPropType, int index );
		//  Return a property item number from the network
	BOOL BNetPropItemReal ( SZC szcPropType, int index, double & dbl );

	////////////////////////////////////////////////////////////////////
	//  Operations involving the "Currrent Node": call NodeSetCurrent()
	////////////////////////////////////////////////////////////////////
		//  Set the current node for other calls
	BOOL BNodeSetCurrent( int inode );
		//	Get the current node
	int INodeCurrent ();
		//  Return the index of a node given its symbolic name
	int INode ( SZC szcNodeSymName );	
		//	Return the label of the current node
	ESTDLBL ELblNode ();
		//  Return the number of discrete states in the current node
	int INodeCst ();
		//  Set the state of a node; use -1 to uninstatiate
	BOOL BNodeSet ( int istate, bool bSet = true );
		//  Return the state of a node
	int  INodeState ();
		//	Return the name of a node's state
	void NodeStateName ( int istate );
		//  Return the symbolic name of the node
	void NodeSymName ();
		//  Return the full name of the node
	void NodeFullName ();
		//  Return a property item string from the node
	BOOL BNodePropItemStr ( SZC szcPropType, int index );
		//  Return a property item number from the node
	BOOL BNodePropItemReal ( SZC szcPropType, int index, double & dbl );
		//  Return the belief for a node
	void NodeBelief ();
		//  Return true if the network is loaded and correct
	bool BValidNet () const;
		//  Return true if the current node is set
	bool BValidNode () const;
		//  Discard the model and all components
	void Clear();

	////////////////////////////////////////////////////////////////////
	//  Accessors to the function result information	
	////////////////////////////////////////////////////////////////////
	SZC SzcResult () const;					//  String answer		
	const REAL * RgReal () const;			//  Array of reals		
	const int * RgInt () const;				//  Array of Integers	
	int CReal () const;						//  Count of reals		
	int CInt () const;						//  Count of integers

  protected:
	MBNETDSCTS * _pmbnet;			//  The T/S DSC belief network
	int _inodeCurrent;				//  The current node

  protected:
	MBNETDSCTS & Mbnet();
	const MBNETDSCTS & Mbnet() const;
	GNODEMBND * Pgndd ();
	BOOL BGetPropItemStr ( LTBNPROP & ltprop, 
						   SZC szcPropType, 
						   int index, 
						   ZSTR & zstr );
	BOOL BGetPropItemReal ( LTBNPROP & ltprop, 
							SZC szcPropType, 
							int index, 
							double & dbl );
	void ClearArrays ();
	void ClearString ();
	ZSTR & ZstrResult ();
};

#endif // _BNTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\chmfilereader.cpp ===
//
// MODULE: CHMFileReader.CPP
//
// PURPOSE: implement CHM file reading class CCHMFileReader
//
// PROJECT: for Local Troubleshooter; not needed in Online TS
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 01-18-99
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.1		01-18-99	JM
//

#include "stdafx.h"
#include "fs.h"
#include "CHMFileReader.h"

// Utilize an unnamed namespace to limit scope to this source file
namespace
{ 
const CString kstr_CHMfileExtension=_T("chm");
const CString kstr_CHMpathMarker=	_T("mk:@msitstore:");
const CString kstr_CHMstreamMarker=	_T("::/");
}


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CCHMFileReader::CCHMFileReader(CString strCHMPath, CString strStreamName)
	: m_strCHMPath(strCHMPath),
	  m_strStreamName(strStreamName),
	  m_pFileSystem(NULL),
	  m_pSubFileSystem(NULL)
{
}

CCHMFileReader::CCHMFileReader( CString strFullCHMname )
	: m_pFileSystem(NULL),
	  m_pSubFileSystem(NULL)
{
	int nPosPathMarker, nPosStreamMarker;

	nPosPathMarker= strFullCHMname.Find( kstr_CHMpathMarker );
	nPosStreamMarker= strFullCHMname.Find( kstr_CHMstreamMarker );
	if ((nPosPathMarker == -1) || (nPosStreamMarker == -1))
	{
		// >>>	Need to think about how to handle this condition or whether we should
		//		be checking for a 'valid' CHM path outside of a constructor.  RAB-19990120.
	}
	else
	{
		// Extract the path and string names (bounds checking is handled by the CString class).
		nPosPathMarker+= kstr_CHMpathMarker.GetLength();
		m_strCHMPath= strFullCHMname.Mid( nPosPathMarker, nPosStreamMarker - nPosPathMarker ); 
		nPosStreamMarker+= kstr_CHMstreamMarker.GetLength();
		m_strStreamName= strFullCHMname.Mid( nPosStreamMarker ); 
	}
}

CCHMFileReader::~CCHMFileReader()
{
	if (m_pSubFileSystem)
		delete m_pSubFileSystem;
	if (m_pFileSystem)
		delete m_pFileSystem;
}

// doesn't throw exception, therefore may be used by exception class.
bool CCHMFileReader::CloseHandle()
{
	if (m_pSubFileSystem)
	{
		delete m_pSubFileSystem;
		m_pSubFileSystem = NULL;
	}
	if (m_pFileSystem)
	{
		m_pFileSystem->Close();
		delete m_pFileSystem;
		m_pFileSystem = NULL;
	}

	return true;
}

void CCHMFileReader::Open()
{
	try
	{
		m_pFileSystem = new CFileSystem();
		//[BC-03022001] - added check for NULL ptr to satisfy MS code analysis tool.
		if(!m_pFileSystem)
		{
			throw bad_alloc();
		}
		
		m_pSubFileSystem = new CSubFileSystem(m_pFileSystem);
		//[BC-03022001] - added check for NULL ptr to satisfy MS code analysis tool.
		if(!m_pSubFileSystem)
		{			
			throw bad_alloc();
		}		
	}
	catch (bad_alloc&)
	{
		CloseHandle();
		throw CFileReaderException(this, CFileReaderException::eErrOpen, __FILE__, __LINE__);
	}

	HRESULT hr;
	if (RUNNING_FREE_THREADED())
		hr = ::CoInitializeEx(NULL, COINIT_MULTITHREADED); // Initialize COM library
	if (RUNNING_APARTMENT_THREADED())
		hr = ::CoInitializeEx(NULL, COINIT_APARTMENTTHREADED); // Initialize COM library

	if (SUCCEEDED(hr))
		hr = m_pFileSystem->Init();
	
	// >>> $BUG$ potential - not sure. Oleg. 02.04.99
	// Theoretically we do not need COM library after class factory
	//  was used in m_pFileSystem->Init() in order to obtain ITStorage pointer.
	// Oleg. 02.04.99
	// MS v-amitse 07.16.2001 RAID 432425 - added check for successful initialization
	if ((RUNNING_FREE_THREADED() || RUNNING_APARTMENT_THREADED()) && SUCCEEDED(hr))
		::CoUninitialize(); // Uninitialize COM library

	if (SUCCEEDED(hr))
		hr = m_pFileSystem->Open(m_strCHMPath);

	if (SUCCEEDED(hr))
		hr = m_pSubFileSystem->OpenSub(m_strStreamName);

	if (! SUCCEEDED(hr) )
	{
		CloseHandle();
		throw CFileReaderException( this, CFileReaderException::eErrOpen, __FILE__, __LINE__ );
	}
}

void CCHMFileReader::ReadData(LPTSTR * ppBuf)
{
	if (!m_pSubFileSystem)
		throw CFileReaderException(this, CFileReaderException::eErrOpen, __FILE__, __LINE__);

	ULONG cb = m_pSubFileSystem->GetUncompressedSize();
	ULONG cbRead = 0;

	try
	{
		*ppBuf = new TCHAR [cb/sizeof(TCHAR)+1];
		//[BC-03022001] - added check for NULL ptr to satisfy MS code analysis tool.
		if(!*ppBuf)
			throw bad_alloc();					
		
		memset(*ppBuf, 0, cb+sizeof(TCHAR));			
	}
	catch (bad_alloc&)
	{
		throw CFileReaderException(this, CFileReaderException::eErrAllocateToRead, __FILE__, __LINE__);
	}

	HRESULT hr = m_pSubFileSystem->ReadSub(*ppBuf, cb, &cbRead);
	if (! SUCCEEDED(hr) )
		throw CFileReaderException(this, CFileReaderException::eErrRead, __FILE__, __LINE__);
}

CString CCHMFileReader::GetPathName() const
{
	return (kstr_CHMpathMarker + m_strCHMPath + kstr_CHMstreamMarker + m_strStreamName );
}

CString CCHMFileReader::GetJustNameWithoutExtension() const
{
	return CAbstractFileReader::GetJustNameWithoutExtension(m_strStreamName);
}

CString CCHMFileReader::GetJustExtension() const
{
	return CAbstractFileReader::GetJustExtension(m_strStreamName);
}

bool CCHMFileReader::GetFileTime(CAbstractFileReader::EFileTime type, time_t& out) const
{
	return CAbstractFileReader::GetFileTime(m_strCHMPath, type, out);
}

CString CCHMFileReader::GetNameToLog() const
{
	return GetPathName();
}

// Returns true if the first few characters of the path match a given string.
/*static*/ bool CCHMFileReader::IsCHMfile( const CString& strPath )
{
	// Make a copy of the path.
	CString strTemp= strPath;

	// Check for the string that denotes the beginning of a CHM file.
	// The sequence must start in the initial byte of a left trimmed string.
	strTemp.TrimLeft();
	strTemp.MakeLower();
	if (strTemp.Find( kstr_CHMpathMarker ) == 0)
		return( true );
	else
		return( false );
}

/*static*/ bool CCHMFileReader::IsPathToCHMfile( const CString& strPath )
{
	CString strTemp = strPath;

	strTemp.TrimRight();
	strTemp.MakeLower();
	
	// New approach, test for ANY extension
	int dot_index = strTemp.ReverseFind(_T('.'));
	int back_slash_index = strTemp.ReverseFind(_T('\\'));
	int forward_slash_index = strTemp.ReverseFind(_T('/'));

	if (dot_index != -1 &&
		dot_index > back_slash_index &&
		dot_index > forward_slash_index
	   )
	{
		// Now test, if it is a real file
		WIN32_FIND_DATA find_data;
		HANDLE hFile = ::FindFirstFile(strTemp, &find_data);

		if (hFile != INVALID_HANDLE_VALUE)
		{
			::FindClose(hFile);
			return true;
		}
	}
	
	// Old approach, test for ".chm"
	//if (CString(_T(".")) + kstr_CHMfileExtension == strTemp.Right(kstr_CHMfileExtension.GetLength() + 1))
	//	return true;
	
	return false;
}

/*static*/ CString CCHMFileReader::FormCHMPath( const CString strPathToCHMfile )
{
	return kstr_CHMpathMarker + strPathToCHMfile + kstr_CHMstreamMarker;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\chmfilereader.h ===
//
// MODULE: CHMFileReader.CPP
//
// PURPOSE: interface for CHM file reading class CCHMFileReader
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 01-18-99
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.1		01-18-99	JM
//

#if !defined(AFX_CHMFILEREADER_H__1A2C05D6_AEFC_11D2_9658_00C04FC22ADD__INCLUDED_)
#define AFX_CHMFILEREADER_H__1A2C05D6_AEFC_11D2_9658_00C04FC22ADD__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "fileread.h"

class CFileSystem;
class CSubFileSystem;

class CCHMFileReader : public CPhysicalFileReader  
{
private:
	CString m_strCHMPath;		// full path and name of CHM
	CString m_strStreamName;	// name of stream within CHM
	CFileSystem*    m_pFileSystem;
	CSubFileSystem* m_pSubFileSystem;

private:
	CCHMFileReader();			// do not instantiate

public:
	CCHMFileReader(CString strCHMPath, CString strStreamName);
	CCHMFileReader( CString strFullCHMname );
	virtual ~CCHMFileReader();

protected:
	// only CFileReader can access these functions !!!
	virtual bool CloseHandle();  // doesn't throw exception, therefore may be used by exception class.
	virtual void Open();
	virtual void ReadData(LPTSTR * ppBuf);

public:
	// return full file path and its components
	CString GetPathName() const;
	CString GetJustPath() const {return m_strCHMPath;}
	CString GetJustName() const {return m_strStreamName;}
	CString GetJustNameWithoutExtension() const;
	CString GetJustExtension() const;
	bool    GetFileTime(CAbstractFileReader::EFileTime type, time_t& out) const;
	CString GetNameToLog() const;

	static bool IsCHMfile( const CString& strPath );	// Returns true if the first few
														// characters of the path specification
														// match a given sequence.
	static bool IsPathToCHMfile( const CString& strPath ); // returns true if this is
														   //  a full path to a CHM file
	static CString FormCHMPath( const CString strPathToCHMfile ); // forms mk:@msitstore:path::/stream
																  //  string
};

#endif // !defined(AFX_CHMFILEREADER_H__1A2C05D6_AEFC_11D2_9658_00C04FC22ADD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\bn.h ===
//
// MODULE: BN.h
//
// PURPOSE: interface for the CBeliefNetwork class
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 8-31-98
//
// NOTES: 
// 1. Based on Print Troubleshooter DLL
//
// Version	Date		By		Comments
//---------------------------------------------------------------------
// V3.0		8-31-98		JM		
//

#if !defined(AFX_TOPIC_H__4ACF2F73_40EB_11D2_95EE_00C04FC22ADD__INCLUDED_)
#define AFX_TOPIC_H__4ACF2F73_40EB_11D2_95EE_00C04FC22ADD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "dscread.h"
#include "apgtscac.h"
#include "counter.h"

class CBeliefNetwork : public CDSCReader  
{
	struct SNodeType
	{
		NID Nid;
		ESTDLBL Type;
		SNodeType(NID nid, ESTDLBL type) : Nid(nid), Type(type) {}
	};

protected:
	bool m_bInitialized;
	vector<NID> m_arrnidProblem;		// NIDs of problem nodes; convenience array
	vector<SNodeType> m_arrNodeTypeAll;	// NIDs of all nodes; convenience array

	CCache	m_Cache;				// cache for this topic
	CHourlyDailyCounter m_countCacheHit;
	CHourlyDailyCounter m_countCacheMiss;
	bool m_bSnifferIntegration;		// This belief network is designed to integrate with a
									// sniffer.
private:
	CBeliefNetwork();				// do not instantiate
public:
	typedef enum {RS_OK, RS_Impossible, RS_Broken} eRecStatus;
	CBeliefNetwork(LPCTSTR path);
	virtual ~CBeliefNetwork();
	int CNode();
	int INode (LPCTSTR szNodeName);
	int GetRecommendations(
	   const CBasisForInference & BasisForInference, 
	   CRecommendations & Recommendations);
	int GetProblemArray(vector<NID>* &parrnid);
	int GetNodeArrayIncludeType(vector<NID>& arrOut, const vector<ESTDLBL>& arrTypeInclude);
	int GetNodeArrayExcludeType(vector<NID>& arrOut, const vector<ESTDLBL>& arrTypeExclude);
	CString GetNetPropItemStr(LPCTSTR szPropName);
	CString GetNodePropItemStr(NID nid, LPCTSTR szPropName, IST state = 0);
	bool GetNetPropItemNum(LPCTSTR szPropName, double& numOut);
	bool GetNodePropItemNum(NID nid, LPCTSTR szPropName, double& numOut, IST state = 0);
	CString GetNodeSymName(NID nid);
	CString GetNodeFullName(NID nid);
	CString GetStateName(NID nid, IST state);
	CString GetMultilineNetProp(LPCTSTR szPropName, LPCTSTR szFormat);
	CString GetMultilineNodeProp(NID nid, LPCTSTR szPropName, LPCTSTR szFormat);
	int GetCountOfStates(NID nid);
	bool IsValidNID(NID nid);
	bool IsCauseNode(NID nid);
	bool IsProblemNode(NID nid);
	bool IsInformationalNode(NID nid);
	bool UsesSniffer();

protected:
	void Initialize();
	BNTS * pBNTS();
	void ResetNodes(const CBasisForInference & BasisForInference);
	bool SetNodes(const CBasisForInference & BasisForInference);
};

#endif // !defined(AFX_TOPIC_H__4ACF2F73_40EB_11D2_95EE_00C04FC22ADD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\countermgr.cpp ===
// CounterMgr.cpp: implementation of the CCounterMgr class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CounterMgr.h"
#include <algorithm>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif


// Using Singleton to assure initialization
CCounterMgr* Get_g_CounterMgr()
{
	static CCounterMgr g_CounterMgr;
	return &g_CounterMgr;
}

//////////////////////////////////////////////////////////////////////
// CCounterMgr class implementation
//////////////////////////////////////////////////////////////////////
CAbstractCounter* CCounterMgr::Exists(const CCounterLocation& location) const
{
	CAbstractCounter* ret = NULL;

	for (vector<CAbstractCounter*>::const_iterator i = m_arrCounterPool.begin(); i != m_arrCounterPool.end(); i++)
	{
		if ((CCounterLocation&)location == **i) {
			ret = *i;
			break;
		}
	}
	return ret;
}

bool CCounterMgr::RemoveLocation(const CCounterLocation& location)
{
	bool ret = false;
	CAbstractCounter* found = NULL;
	
	LOCKOBJECT();

	if (NULL != (found = Exists(location))) 
	{
		vector<CAbstractCounter*>::iterator i = find(m_arrCounterPool.begin(), m_arrCounterPool.end(), found);
		if (i != m_arrCounterPool.end())
		{
			m_arrCounterPool.erase(i);
			ret = true;
		}
	}

	UNLOCKOBJECT();
	return ret;
}

bool CCounterMgr::Add(const CAbstractCounter& counter)
{
	bool ret = false;
	
	LOCKOBJECT();

	if (!Exists(counter)) {
		m_arrCounterPool.push_back((CAbstractCounter*)&counter);
		ret = true;
	}

	UNLOCKOBJECT();
	return ret;
}

void CCounterMgr::AddSubstitute(const CAbstractCounter& counter)
{
	LOCKOBJECT();

	RemoveLocation(counter);
	m_arrCounterPool.push_back((CAbstractCounter*)&counter);

	UNLOCKOBJECT();
}

bool CCounterMgr::Remove(const CAbstractCounter& counter)
{
	bool ret = false;
	
	LOCKOBJECT();

	vector<CAbstractCounter*>::iterator i = find(m_arrCounterPool.begin(), m_arrCounterPool.end(), &counter);
	if (i != m_arrCounterPool.end())
	{
		m_arrCounterPool.erase(i);
		ret = true;
	}

	UNLOCKOBJECT();
	return ret;
}

CAbstractCounter* CCounterMgr::Get(const CCounterLocation& location) const
{
	CAbstractCounter* ret = NULL;
	
	LOCKOBJECT();
	ret = Exists(location);
	UNLOCKOBJECT();
	return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\counter.h ===
//
// MODULE: COUNTER.H
//
// PURPOSE: interface for the counter classes: 
//		CPeriodicTotals (utility class)
//		CAbstractCounter (abstract base class).
//		CCounter (simple counter)
//		CHourlyCounter (counter with "bins" for each hour of the day)
//		CDailyCounter (counter with "bins" for day of the week)
//		CHourlyDailyCounter (counter with "bins" for each hour of the day and each day of the week)
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// MODIFIED: Oleg Kalosha 10-20-98
// 
// ORIGINAL DATE: 7-20-1998
//
// NOTES: 
// 1. CPeriodicTotals might better be implemented using STL vectors.  We wrote this 
//	before we really started bringing STL into this application. JM 10/98
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		7-20-98		JM		Original
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_COUNTER_H__07B5ABBD_2005_11D2_95D0_00C04FC22ADD__INCLUDED_)
#define AFX_COUNTER_H__07B5ABBD_2005_11D2_95D0_00C04FC22ADD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <time.h>
#include "apgtsstr.h"

////////////////////////////////////////////////////////////////////////////////////
// a utility class to allow the expression of a series of time periods & associated counts
////////////////////////////////////////////////////////////////////////////////////
class CPeriodicTotals
{
public:
	CPeriodicTotals(long nPeriods);
	virtual ~CPeriodicTotals();

	void Reset();
	bool SetNext(time_t time, long Count);
private:
	void ReleaseMem();
protected:
	CString & DisplayPeriod(long i, CString & str) const;
public:
	virtual CString HTMLDisplay() const = 0;
protected:
	long m_nPeriods;		// number of periods, based on initialization in constructor.
							// typically 25 (hours in a day + 1) or 8 (days in a week + 1)
	long m_nPeriodsSet;		// number of periods for which we have data filled in.
	long m_iPeriod;			// index. 0 <= m_iPeriod < m_nPeriodsSet.  Zeroed by InitEnum,
							//	incremented by GetNext or SetNext.
	time_t *m_ptime;		// points to array of times: start time of relevant time period
							//	(typically beginning of a clock hour or calendar day).
	long *m_pCount;			// points to array totals, each the total for correspondingly
							//	indexed time period
};

////////////////////////////////////////////////////////////////////////////////////
// CHourlyTotals class declaration
//	CHourlyTotals intended for displaying hourly totals
////////////////////////////////////////////////////////////////////////////////////
class CHourlyTotals : public CPeriodicTotals
{
public:
	CHourlyTotals();
	~CHourlyTotals();
	virtual CString HTMLDisplay() const;
};

////////////////////////////////////////////////////////////////////////////////////
// CDailyTotals class declaration
//	CDailyTotals intended for displaying dayly totals
////////////////////////////////////////////////////////////////////////////////////
class CDailyTotals : public CPeriodicTotals
{
public:
	CDailyTotals();
	~CDailyTotals();
	virtual CString HTMLDisplay() const;
};

////////////////////////////////////////////////////////////////////////////////////
// CCounterLocation class declaration
//  CCounterLocation is a mean to identify counter within the global counter pool
////////////////////////////////////////////////////////////////////////////////////
class CCounterLocation
{
public:
	// prefixes for scope names
	static LPCTSTR m_GlobalStr;
	static LPCTSTR m_TopicStr;
	static LPCTSTR m_ThreadStr;

	// counter IDs 
	enum EId {
			eIdGeneric,
		
			// counters that are realized
			eIdProgramContemporary,
			eIdStatusAccess,
			eIdActionAccess,
			eIdTotalAccessStart,
			eIdTotalAccessFinish,
			eIdRequestUnknown,
			eIdRequestRejected,
			eIdErrorLogged,
			
			// status information that I see as counters.
			//  Oleg 10-20-98
			eIdWorkingThread,
			eIdQueueItem,
			eIdProgressItem,

			// status information that I think can be emulated as counters
			//	Oleg 10-21-98
			eIdKnownTopic,
			eIdTopicNotTriedLoad,
			eIdTopicFailedLoad,

			// topic - bound counters
			eIdTopicLoad,
			eIdTopicLoadOK,
			eIdTopicEvent,
			eIdTopicHit,
			eIdTopicHitNewCookie,
			eIdTopicHitOldCookie,
	};

private:
	const CString m_Scope;   // scope where the counter is used (i.e. "Topic start", "Thread 1" and so on)
	EId     m_Id;			 // identifier of the counter within the scope

public:
    CCounterLocation(EId id, LPCTSTR scope =m_GlobalStr);
	virtual ~CCounterLocation();

public:
	bool operator == (const CCounterLocation& sib) {return m_Scope == sib.m_Scope && m_Id == sib.m_Id;}

public:
	CString GetScope() {return m_Scope;}
	EId     GetId()    {return m_Id;}
};

////////////////////////////////////////////////////////////////////////////////////
// CAbstractCounter class declaration
//	CAbstractCounter* are saved in counter pool
////////////////////////////////////////////////////////////////////////////////////
// >>>(probably ignore for V3.0) There has been some disagreement over whether it is 
//	appropriate for CAbstractCounter to inherit from CCounterLocation.
// JM says (10/29/98): 
//	This seems to me to be the same type of thinking as when pointers to the previous and
//	next item are made part of a class that someone intends to put in a doubly linked list.
//	They are NOT inherent to the class.  They ought instead to be part of some other class
//	that manages CAbstractCounters.
// Oleg replies (11/2/98)
//	Since all counters are elements of a global pool, we have somehow to identify them
//	 in this pool. If the way, we are identifying counters, changes (from name - id to 
//	 name1 - name2 - id for example), we change only CCounterLocation part of counter classes. 
//	I see no reasons to make CCounterLocation an instance in counter class:
//	 1. we definitely have only one CCounterLocation per counter
//	 2. in case if inheritance we do not need additional interface for accessing CCounterLocation
// JM follows this up (11/5/98): 
//	There is nothing wrong with this approach as such. There is, however, an issue of design
//	philosophy that at some point we should address.  For the most part, we follow the style
//	of STL.  Classes are normally designed with no regard to the fact that they will be 
//	contained in a collection.  Here, the counter class knows about the enumeration type 
//	used to identify counters.  This is sort of as if the values in an STL map had to know
//	about the keys mapped to those values.
//	I would have designed CCounterMgr as an "object factory", providing a means to 
//	manufacture named counters much as Win32 manufactures named synchronization primitives 
//	(e.g. a named Mutex or Semaphore).  To indicate that an event has occurred, you would 
//	increment a named counter; for status reporting, you would ask for values of that 
//	named counter.  (In theory, the "names" might either be text or numbers.  The scheme
//	would have to allow for some means of manufacturing several distinct counters for
//	each topic in the catalog.)
class CAbstractCounter : public CCounterLocation
{
protected:  // we do not get instances of this class (evermore this is an abstract class)
    CAbstractCounter(EId id =eIdGeneric, CString scope =m_GlobalStr);
	virtual ~CAbstractCounter();

public:
	virtual void Increment() = 0;
	virtual void Clear() = 0;
	virtual void Init(long count) = 0; // init counter with a number - in order to emulate
									   //  counting process
};

////////////////////////////////////////////////////////////////////////////////////
// CCounter class declaration
//  A simple counter
////////////////////////////////////////////////////////////////////////////////////
class CCounter : public CAbstractCounter
{
public:
	CCounter(EId id =eIdGeneric, CString scope =m_GlobalStr);
	~CCounter();

// overrides
	void Increment();
	void Clear();
	void Init(long count);
// specific to this class
	long Get() const;

private:
	long m_Count;
};

////////////////////////////////////////////////////////////////////////////////////
// CHourlyCounter class declaration
//  CHourlyCounter is not supposed to be instantiated by user
////////////////////////////////////////////////////////////////////////////////////
class CHourlyCounter : public CAbstractCounter
{
	friend class CHourlyDailyCounter;
protected:
	CHourlyCounter();
public:
	~CHourlyCounter();

// overrides
	void Increment();
	void Clear();
	void Init(long count);
// specific to this class
	long GetDayCount();
	void GetHourlies(CHourlyTotals & totals);
private:
	void SetHour();

private:
	long m_ThisHour;			// hour of the day, 0-24.  -1 means uninitialized.
	time_t m_ThisTime;			// time corresponding to START of hour.

	CCounter m_arrCount[24];		// 24 "bins", one for each hour of the day.
	long m_nThisHourYesterday;	// maintains a whole hour count for the hour 24 hours ago.

	HANDLE m_hMutex;
};

////////////////////////////////////////////////////////////////////////////////////
// CDailyCounter class declaration
//  CDailyCounter is not supposed to be instantiated by user
////////////////////////////////////////////////////////////////////////////////////
class CDailyCounter : public CAbstractCounter
{
	friend class CHourlyDailyCounter;
protected:
	CDailyCounter();
public:
	~CDailyCounter();

// overrides
	void Increment();
	void Clear();
	void Init(long count);
// specific to this class
	long GetWeekCount();
	void GetDailies(CDailyTotals & totals);
private:
	void SetDay();

private:
	long m_ThisDay;				// day of the week, 0(Sunday)-6(Saturday).  -1 means uninitialized.
	time_t m_ThisTime;			// time corresponding to START of day.

	CCounter m_arrCount[7];		// 7 "bins", one for each day of the week.
	long m_nThisDayLastWeek;	// maintains a whole day count for the same day last week.

	HANDLE m_hMutex;
};

////////////////////////////////////////////////////////////////////////////////////
// CHourlyDailyCounter class declaration
//  CHourlyDailyCounter is an ONLY class used for counting events
////////////////////////////////////////////////////////////////////////////////////
class CHourlyDailyCounter : public CAbstractCounter
{
public:
	CHourlyDailyCounter(EId id =eIdGeneric, CString scope =m_GlobalStr);
	~CHourlyDailyCounter();

// overrides
	void Increment();
	void Clear();
	void Init(long count);
// specific to this class
	long GetDayCount();
	void GetHourlies(CHourlyTotals & totals);
	long GetWeekCount();
	void GetDailies(CDailyTotals & totals);
	long GetTotal() const;
	time_t GetTimeFirst() const;
	time_t GetTimeLast() const;
	time_t GetTimeCleared() const;
	time_t GetTimeCreated() const;
	time_t GetTimeNow() const;    // time the object is being questioned

private:
	CHourlyCounter m_hourly;
	CDailyCounter m_daily;

	long m_Total;			// total since system startup or count cleared
	time_t m_timeFirst;		// chronologically first time count was incremented
	time_t m_timeLast;		// chronologically last time count was incremented
	time_t m_timeCleared;	// last time init'd or cleared
	time_t m_timeCreated;	// time the object was instantiated

	HANDLE m_hMutex;
};

////////////////////////////////////////////////////////////////////////////////////
// DisplayCounter classes
////////////////////////////////////////////////////////////////////////////////////
class CAbstractDisplayCounter
{
protected:
	CAbstractCounter* m_pAbstractCounter;

public:
	CAbstractDisplayCounter(CAbstractCounter* counter) : m_pAbstractCounter(counter) {}
	virtual ~CAbstractDisplayCounter() {}

public:
	virtual CString Display() = 0;
};

class CDisplayCounterTotal : public CAbstractDisplayCounter
{
public:
	CDisplayCounterTotal(CHourlyDailyCounter* counter) : CAbstractDisplayCounter(counter) {}
   ~CDisplayCounterTotal() {}

public:
	virtual CString Display();
};

class CDisplayCounterCurrentDateTime : public CAbstractDisplayCounter
{
public:
	CDisplayCounterCurrentDateTime(CHourlyDailyCounter* counter) : CAbstractDisplayCounter(counter) {}
   ~CDisplayCounterCurrentDateTime() {}

public:
	virtual CString Display();
};

class CDisplayCounterCreateDateTime : public CAbstractDisplayCounter
{
public:
	CDisplayCounterCreateDateTime(CHourlyDailyCounter* counter) : CAbstractDisplayCounter(counter) {}
   ~CDisplayCounterCreateDateTime() {}

public:
	virtual CString Display();
};

class CDisplayCounterFirstDateTime : public CAbstractDisplayCounter
{
public:
	CDisplayCounterFirstDateTime(CHourlyDailyCounter* counter) : CAbstractDisplayCounter(counter) {}
   ~CDisplayCounterFirstDateTime() {}

public:
	virtual CString Display();
};

class CDisplayCounterLastDateTime : public CAbstractDisplayCounter
{
public:
	CDisplayCounterLastDateTime(CHourlyDailyCounter* counter) : CAbstractDisplayCounter(counter) {}
   ~CDisplayCounterLastDateTime() {}

public:
	virtual CString Display();
};

class CDisplayCounterDailyHourly : public CAbstractDisplayCounter
{
protected:
	CDailyTotals*  m_pDailyTotals;
	CHourlyTotals* m_pHourlyTotals;

public:
	CDisplayCounterDailyHourly(CHourlyDailyCounter* counter,
							   CDailyTotals* daily,
							   CHourlyTotals* hourly) 
	:	CAbstractDisplayCounter(counter),
		m_pDailyTotals(daily),
		m_pHourlyTotals(hourly)
		{}
   ~CDisplayCounterDailyHourly() {}

public:
	virtual CString Display();
};

#endif // !defined(AFX_COUNTER_H__07B5ABBD_2005_11D2_95D0_00C04FC22ADD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\commonregconnect.h ===
//
// MODULE: CommonREGCONNECT.H
//
// PURPOSE: read - write to the registry; common declarations for Online TS and Local TS, 
//	which differ on many functions of this class
//	
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha, Joe Mabel
// 
// ORIGINAL DATE: 8-24-98 in Online TS.  This file abstracted 1-19-98
//
// NOTES: 
//	1. This file should be included only in the .cpp files that instantiate CAPGTSRegConnector
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.1		01-19-98	JM		branch out version exclusively for Local TS

#ifndef _INCLUDE_COMMONREGCONNECT_H_ 
#define _INCLUDE_COMMONREGCONNECT_H_ 

// registry value names
//
#define FULLRESOURCE_STR			_T("FullPathToResource")
#define VROOTPATH_STR				_T("VrootPathToDLL")
#define MAX_THREADS_STR				_T("MaximumThreads")
#define THREADS_PER_PROCESSOR_STR	_T("ThreadsPerProcessor")
#define MAX_WORK_QUEUE_ITEMS_STR	_T("MaximumWorkQueueItems")
#define COOKIE_LIFE_IN_MINS_STR		_T("HTTPCookieExpirationInMins")
#define RELOAD_DELAY_STR			_T("RefreshDelay")
#define DETAILED_EVENT_LOGGING_STR	_T("DetailedEventLogging")
#define LOG_FILE_DIR_STR			_T("LogFileDirectory")
#define SNIFF_AUTOMATIC_STR			_T("AutomaticSniffing")
#define SNIFF_MANUAL_STR			_T("ManualSniffing")


#endif //_INCLUDE_COMMONREGCONNECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\commonregconnect.cpp ===
//
// MODULE: CommonREGCONNECT.CPP
//
// PURPOSE: read - write to the registry; common code for Online TS and Local TS, which differ 
//	on many functions of this class
//	
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha, Joe Mabel
// 
// ORIGINAL DATE: 8-24-98 in Online TS.  This file abstracted 1-19-98
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		08-04-98	OK
// V3.0		09-10-98	JM		backslashing; access log file info
// V3.1		01-19-98	JM		branch out version exclusively for Local TS

#pragma warning(disable:4786)

#include "stdafx.h"
#include "apgtsregconnect.h"
#include "event.h"
#include "apgtsevt.h"
#include "apgtscls.h"
#include "apgts.h"
#include "apiwraps.h"

CMutexOwner CAPGTSRegConnector::s_mx(_T("APGTSRegConnector"));

////////////////////////////////////////////////////////////////////////////////////
// CAPGTSRegConnector
////////////////////////////////////////////////////////////////////////////////////
CAPGTSRegConnector::~CAPGTSRegConnector()
{
}

// When this lock is held, it locks against not just other threads locking this object,
//	but against other threads locking any objects of class CAPGTSRegConnector.
void CAPGTSRegConnector::Lock()
{
	WAIT_INFINITE( s_mx.Handle() );
}

void CAPGTSRegConnector::Unlock()
{
	::ReleaseMutex(s_mx.Handle());
}

bool CAPGTSRegConnector::IsRead()
{
	bool ret = false;
	Lock();
	ret = m_RegistryInfo.m_bIsRead;
	Unlock();
	return ret;
}

// the root key (typically "SOFTWARE\Microsoft" in Local TS or "SOFTWARE\\ISAPITroubleShoot" in Online TS) exists
bool CAPGTSRegConnector::Exists()
{
	bool ret = false;
	CRegUtil reg;
	Lock();
	if (reg.Open(HKEY_LOCAL_MACHINE, RegSoftwareLoc(), KEY_QUERY_VALUE))
		if (reg.Open(RegThisProgram(), KEY_QUERY_VALUE))
			ret = true;
	reg.Close();
	Unlock();
	return ret;
}


/*static*/ CString & CAPGTSRegConnector::StringFromConnector(ERegConnector e, CString & str)
{
	switch (e)
	{
		case eResourcePath: str = FULLRESOURCE_STR; break;
		case eVrootPath: str = VROOTPATH_STR; break;
		case eMaxThreads: str = MAX_THREADS_STR; break;
		case eThreadsPP: str = THREADS_PER_PROCESSOR_STR; break;
		case eMaxWQItems: str = MAX_WORK_QUEUE_ITEMS_STR; break;
		case eCookieLife: str = COOKIE_LIFE_IN_MINS_STR; break;
		case eReloadDelay: str = RELOAD_DELAY_STR; break;
		case eDetailedEventLogging: str = DETAILED_EVENT_LOGGING_STR; break;
		case eLogFilePath:  str = LOG_FILE_DIR_STR; break;
		case eTopicFileExtension:  str = LOG_FILE_DIR_STR; break;
		case eSniffAutomatic:  str = SNIFF_AUTOMATIC_STR; break;
		case eSniffManual:  str = SNIFF_MANUAL_STR; break;
		default: str = _T(""); break;
	}
	return str;
}

/*static*/ CAPGTSRegConnector::ERegConnector CAPGTSRegConnector::ConnectorFromString( const CString & str)
{
	ERegConnector e = eIndefinite;

	if (str == FULLRESOURCE_STR)
		e = eResourcePath;
	else if (str == VROOTPATH_STR)
		e = eVrootPath;
	else if (str == MAX_THREADS_STR)
		e = eMaxThreads;
	else if (str == THREADS_PER_PROCESSOR_STR)
		e = eThreadsPP;
	else if (str == MAX_WORK_QUEUE_ITEMS_STR)
		e = eMaxWQItems;
	else if (str == COOKIE_LIFE_IN_MINS_STR)
		e = eCookieLife;
	else if (str == RELOAD_DELAY_STR)
		e = eReloadDelay;
	else if (str == DETAILED_EVENT_LOGGING_STR)
		e = eDetailedEventLogging;
	else if (str == LOG_FILE_DIR_STR)
		e = eLogFilePath;
	else if (str == SNIFF_AUTOMATIC_STR)
		e = eSniffAutomatic;
	else if (str == SNIFF_MANUAL_STR)
		e = eSniffManual;

	return e;
}

/*static*/ bool CAPGTSRegConnector::IsNumeric(ERegConnector e)
{
	switch (e)
	{
		case eMaxThreads: return true;
		case eThreadsPP: return true;
		case eMaxWQItems: return true;
		case eCookieLife: return true;
		case eReloadDelay: return true;
		case eDetailedEventLogging: return true;
		case eSniffAutomatic: return true;
		case eSniffManual: return true;
		default: return false;
	}
}

/*static*/ bool CAPGTSRegConnector::IsString(ERegConnector e)
{
	switch (e)
	{
		case eResourcePath: return true;
		case eVrootPath: return true;
		case eLogFilePath:  return true;
		case eTopicFileExtension:  return true;
		default: return false;
	}
}
////////////////////////////////////////////////////////
// The following 2 functions set values in the registry.  Note that they do NOT
//	maintain member values.  That must be done at a higher level.
// Like CRegUtil::SetNumericValue(), and CRegUtil::SetStringValue(),
//	these assume we already have right key open.
// These also assume we have the relevant lock.
void CAPGTSRegConnector::SetNumericValue(CRegUtil &reg, ERegConnector e, DWORD dwValue)
{
	CString str;
	if( IsNumeric(e) && reg.SetNumericValue(StringFromConnector(e, str), dwValue))
		return;

	// either inappropriate input or otherwise couldn't set value
	throw CAPGTSRegConnectorException(__FILE__, __LINE__, reg, e);
}
//
// See comments on CAPGTSRegConnector::SetNumericValue
void CAPGTSRegConnector::SetStringValue(CRegUtil &reg, ERegConnector e, CString strValue)
{
	CString str;
	if( IsString(e) && reg.SetStringValue(StringFromConnector(e, str), strValue))
		return;

	// either inappropriate input or otherwise couldn't set value
	throw CAPGTSRegConnectorException(__FILE__, __LINE__, reg, e);
}
///////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////
// The following 3 functions set values in the registry.  Note that they do NOT
//	maintain member values.  Typically, these are to be used in a CAPGTSRegConnector
//	that exists briefly for the sole purpose of setting registry values.
//
// If there is a CRegistryMonitor in existence -- whether it is this object itself
//	or a distinct object -- it will become aware of this change by monitoring
//	the registry and will behave accordingly.
//
// SetOneNumericValue() is a higher-level way to set a numeric value.
// Does not assume anything about open keys or held locks.
// Does assume value is in the usual area where APGTS stores its registry data.
bool CAPGTSRegConnector::SetOneNumericValue(ERegConnector e, DWORD dwValue)
{
	bool bRet=true;
	Lock();
	try
	{
		CRegUtil reg;
		bool was_created = false;
		if (reg.Create(HKEY_LOCAL_MACHINE, RegSoftwareLoc(), &was_created, KEY_QUERY_VALUE | KEY_WRITE))
		{
			if (reg.Create(RegThisProgram(), &was_created, KEY_READ | KEY_WRITE))
			{
				SetNumericValue(reg, e, dwValue);
			}
		}
	}
	catch(CAPGTSRegConnectorException& exception) 
	{
		exception.Log();
		exception.Close();
		bRet=false;
	}
	Unlock();
	return bRet;
}
//
// See comments on CAPGTSRegConnector::SetOneNumericValue
// SetOneStringValue() is a higher-level way to set a string value.
// Does not assume anything about open keys or held locks.
// Does assume value is in the usual area where APGTS stores its registry data.
bool CAPGTSRegConnector::SetOneStringValue(ERegConnector e, const CString & strValue)
{
	bool bRet=true;
	Lock();
	try
	{
		CRegUtil reg;
		bool was_created = false;
		if (reg.Create(HKEY_LOCAL_MACHINE, RegSoftwareLoc(), &was_created, KEY_QUERY_VALUE | KEY_WRITE))
		{
			if (reg.Create(RegThisProgram(), &was_created, KEY_READ | KEY_WRITE))
			{
				SetStringValue(reg, e, strValue);
			}
		}
	}
	catch(CAPGTSRegConnectorException& exception) 
	{
		exception.Log();
		exception.Close();
		bRet=false;
	}
	Unlock();
	return bRet;
}
//
// See comments on CAPGTSRegConnector::SetOneNumericValue.  This is the public function
// Function returns true if strName represents a value we maintain.
// bChanged returns true if the value is changed.  If the function returns false, bChanged 
//	always returns false.
bool CAPGTSRegConnector::SetOneValue(const CString & strName, const CString & strValue, bool &bChanged)
{
	ERegConnector e = ConnectorFromString(strName);
	if (IsNumeric(e))
	{
		bChanged = SetOneNumericValue(e, _ttoi(strValue));
		return true;
	}
	else if (IsString(e))
	{
		bChanged = SetOneStringValue(e, strValue);
		return true;
	}
	else
	{
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								_T(""), _T(""), 
								EV_GTS_ERROR_INVALIDREGCONNECTOR ); 
		bChanged = false;
		return false;
	}
}

//////////////////////////////////////////////////////

// Having read a string strNew from the registry & done any massaging it gets,
//	assign this string value to the appropriate variable strPersist.
// Returns true and logs dwEvent if strPersist is changed (new value differs from old).
/*static*/ bool CAPGTSRegConnector::AssignString(CString & strPersist, const CString & strNew, DWORD dwEvent)
{
	if (!(strNew == strPersist)) 
	{
		CString str = strPersist;
		str += _T(" | ");
		str += strNew;
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(SrcLoc.GetSrcFileLineStr(), 
							  SrcLoc.GetSrcFileLineStr(), 
							  str,
							  _T(""),
							  dwEvent);

		strPersist = strNew;
		return true;
	}
	return false;
}

// Having read a numeric dwNew from the registry
//	assign this value to the appropriate variable dwPersist.
// Also used a second time if we need to force the value to an acceptable number.
// Returns true and logs dwEvent if dwPersist is changed (new value differs from old).
// If dwEventDecrease is non-zero, it provides a distinct message to log if the value
//	is decreased rather than increased.
/*static*/ bool CAPGTSRegConnector::AssignNumeric(DWORD & dwPersist, DWORD dwNew, 
									   DWORD dwEvent, DWORD dwEventDecrease /* =0 */)
{
	if (dwNew != dwPersist) 
	{
		CString strOld;
		strOld.Format(_T("%d"), dwPersist );
		CString strNew;
		strNew.Format(_T("%d"), dwNew);
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(SrcLoc.GetSrcFileLineStr(), 
							  SrcLoc.GetSrcFileLineStr(), 
							  strOld,
							  strNew,
							  (dwEventDecrease != 0 && dwNew < dwPersist) ?
								dwEventDecrease : dwEvent);
		dwPersist = dwNew;
		return true;
	}
	return false;
}

/*static*/ bool CAPGTSRegConnector::ForceRangeOfNumeric(
	DWORD & dw, 
	DWORD dwDefault, 
	DWORD dwEvent, 
	DWORD dwMin,	/*=1*/
	DWORD dwMax		/*=ABS_MAX_REG_PARAM_VAL*/
	)
{
	// do limited validation; 
	if (dw > dwMax || dw < dwMin)
	{
		AssignNumeric(dw, dwDefault, dwEvent);
		return true;
	}
	return false;
}

// pump data into m_RegistryInfo - PLUS sets absent data in registry to default.
// OUTPUT maskChanged  or-ed ERegConnector-based mask of elements that have been 
//						changed since last read
// OUTPUT maskCreated  or-ed ERegConnector-based mask of elements that were created 
//						in registry (because they previously didn't exist in registry)
bool CAPGTSRegConnector::Read(int & maskChanged, int & maskCreated)
{
	bool ret = true;

	Lock();
	try {
		ReadUpdateRegistry(maskChanged, maskCreated);
		m_RegistryInfo.m_bIsRead = true;
	} 
	catch(CAPGTSRegConnectorException& exception) 
	{
		exception.Log();
		exception.Close();
		ret = false;
	}
	Unlock();

	return ret;
}

void CAPGTSRegConnector::Clear()
{
	Lock();

	// Check if our registry tree exists.
	if (!Exists())
	{
		// Rebuilds our registry tree if it has been damaged or deleted.  
		CRegUtil reg;
		bool was_created = false;

		if (reg.Create(HKEY_LOCAL_MACHINE, RegSoftwareLoc(), &was_created, KEY_QUERY_VALUE | KEY_WRITE))
			reg.Create(RegThisProgram(), &was_created, KEY_READ | KEY_WRITE);
		reg.Close();
	}

	m_RegistryInfo.SetToDefault();
	Unlock();
}

bool CAPGTSRegConnector::GetNumericInfo(ERegConnector en, DWORD& out)
{
	bool ret = true;
	Lock();
	if (en == eMaxThreads)
		out = m_RegistryInfo.dwMaxThreads;
	else if (en == eThreadsPP)
		out = m_RegistryInfo.dwThreadsPP;
	else if (en == eMaxWQItems)
		out = m_RegistryInfo.dwMaxWQItems;
	else if (en == eCookieLife)
		out = m_RegistryInfo.dwCookieLife;
	else if (en == eReloadDelay)
		out = m_RegistryInfo.dwReloadDelay;
	else if (en == eDetailedEventLogging)
		out = m_RegistryInfo.dwDetailedEventLogging;
	else if (en == eSniffAutomatic)
		out = m_RegistryInfo.dwSniffAutomatic;
	else if (en == eSniffManual)
		out = m_RegistryInfo.dwSniffManual;
	else 
		ret = false;
	Unlock();
	return ret;
}

bool CAPGTSRegConnector::GetStringInfo(ERegConnector en, CString& out)
{
	bool ret = true;
	Lock();
	if (en == eResourcePath)
		out = m_RegistryInfo.strResourcePath;
	else if (en == eVrootPath)
		out = m_RegistryInfo.strVrootPath;
	else if (en == eLogFilePath)
		out = m_RegistryInfo.strLogFilePath;	
	else if (en == eTopicFileExtension)
		out = m_RegistryInfo.strTopicFileExtension;
	else 
		ret = false;
	Unlock();
	return ret;
}


//	AddBackslash appends a backslash ('\') to CStrings that do not already end in '\'.
/* static */void CAPGTSRegConnector::AddBackslash(CString & str)
{
	int len = str.GetLength();
	if (len && str.Right(1).Find('\\') >= 0)
	{
		// do nothing, already has backslash
	}
	else
		// add backslash
		str += "\\";
	return;
}

// BackslashIt replaces all frontslashes ('/') in str with backslashes ('\')
//	and (optionally) forces termination with a backslash
/* static */void CAPGTSRegConnector::BackslashIt(CString & str, bool bForce)
{
	int loc;
	while ((loc = str.Find('/')) != -1)
	{
		str = str.Left(loc) + "\\" + str.Mid(loc+1);
	}
	if (bForce)
		AddBackslash(str);
}

// APGTS key access
CString CAPGTSRegConnector::ThisProgramFullKey()
{
	CString str;
	str.Format(_T("%s\\%s"), RegSoftwareLoc(), RegThisProgram());
	return str;
}

////////////////////////////////////////////////////////////////////////////////////
// CAPGTSRegConnectorException
////////////////////////////////////////////////////////////////////////////////////
void CAPGTSRegConnectorException::Log()
{
	CString str;
	switch (eVariable)
	{
		case CAPGTSRegConnector::eResourcePath:
		case CAPGTSRegConnector::eVrootPath:
		case CAPGTSRegConnector::eMaxThreads:
		case CAPGTSRegConnector::eThreadsPP:
		case CAPGTSRegConnector::eMaxWQItems:
		case CAPGTSRegConnector::eCookieLife:
		case CAPGTSRegConnector::eReloadDelay:
		case CAPGTSRegConnector::eDetailedEventLogging:
		case CAPGTSRegConnector::eLogFilePath:
		case CAPGTSRegConnector::eSniffAutomatic:
		case CAPGTSRegConnector::eSniffManual:
			CAPGTSRegConnector::StringFromConnector(eVariable, str); break;

		case CAPGTSRegConnector::eProblemWithKey: str = _T("Can't open reg key"); break;
		case CAPGTSRegConnector::eProblemWithLogKey: str = _T("Can't open IIS reg key"); break;

		case CAPGTSRegConnector::eIndefinite:	// falls through to default.
		default: str = _T("<Problem not specified>"); break;
	}

	CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
	CEvent::ReportWFEvent(GetSrcFileLineStr(), 
						  SrcLoc.GetSrcFileLineStr(), 
						  str,
						  _T(""),
						  TSERR_REG_READ_WRITE_PROBLEM);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\countermgr.h ===
// CounterMgr.h: interface for the CCounterMgr classes.
//
// MODULE: COUNTERMGR.H
//
// PUTPOSE: Global pool of pointers to status counters
//      These pointers can be accessed through name (string, like "Topic imsetup"
//		or "Thread 1") and counted event identifier (long).
//		There is only one instance of this class in the programm.
//      Manipulation with members of this class should be thread safe.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 10-20-98
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		10-20-98	OK		Original
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_COUNTERMGR_H__14CDE7A4_6844_11D2_8C42_00C04F949D33__INCLUDED_)
#define AFX_COUNTERMGR_H__14CDE7A4_6844_11D2_8C42_00C04F949D33__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "Stateless.h"
#include "Counter.h"
#include <vector>

using namespace std;

class CCounterMgr; // forward declaration
CCounterMgr* Get_g_CounterMgr(); // Singleton to obtain g_CounterMgr global variable

////////////////////////////////////////////////////////////////////////////////////
// CCounterMgr declaration
////////////////////////////////////////////////////////////////////////////////////
class CCounterMgr : public CStateless
{
	vector<CAbstractCounter*> m_arrCounterPool;

public:
	CCounterMgr() {}
	virtual ~CCounterMgr() {}

protected:
	CAbstractCounter* Exists(const CCounterLocation&) const;
	bool RemoveLocation(const CCounterLocation&);

public:
	// adds counter with unique location
	//  if counter with such location alredy exists, does nothing, returns false
	bool Add(const CAbstractCounter&);
	// adds counter with unique location
	//  if counter with such location alredy exists, it is substituted with new counter
	void AddSubstitute(const CAbstractCounter&);
	// removes this particular counter
	//  if the counter is not stored in the pool, returns false
	bool Remove(const CAbstractCounter&);
	CAbstractCounter* Get(const CCounterLocation&) const;
};

#endif // !defined(AFX_COUNTERMGR_H__14CDE7A4_6844_11D2_8C42_00C04F949D33__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\cptshoot.h ===
#ifndef _CPTSHOOT_H_
#define _CPTSHOOT_H_

template <class T>
class CProxy_ITSHOOTCtrlEvents : public IConnectionPointImpl<T, &DIID__ITSHOOTCtrlEvents, CComDynamicUnkArray>
{
	//Warning this class may be recreated by the wizard.
public:
	long Fire_Sniffing(BSTR strNodeName, BSTR strLaunchBasis, BSTR strAdditionalArgs)
	{
		T* pT = static_cast<T*>(this);
		VARIANT resultVariant;

		if (RUNNING_APARTMENT_THREADED())
		{
			CComVariant* pvars = new CComVariant[3];
			long result = -1;

			V_VT(&resultVariant) = VT_I4;
			resultVariant.lVal = result;
			
			pT->Lock();
			for(vector<DWORD>::iterator it = pT->m_vecCookies.begin(); it != pT->m_vecCookies.end(); it++)
			{
				IDispatch* pDispatch = NULL;
				
				pT->m_pGIT->GetInterfaceFromGlobal(*it, IID_IDispatch,
					reinterpret_cast<void**>(&pDispatch));
				
				if (pDispatch != NULL)
				{
					pvars[2] = strNodeName;
					pvars[1] = strLaunchBasis;
					pvars[0] = strAdditionalArgs;
					DISPPARAMS disp = { pvars, NULL, 3, 0 };
					HRESULT result = S_OK;
					if (SUCCEEDED(result = pDispatch->Invoke(1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &resultVariant, NULL, NULL)))
					{
						pDispatch->Release();
						break;
					}
					pDispatch->Release();
				}
			}
			pT->Unlock();
			delete[] pvars;
		}
		if (RUNNING_FREE_THREADED())
		{
			int nConnectionIndex;
			CComVariant* pvars = new CComVariant[3];
			int nConnections = m_vec.GetSize();
			long result = -1;

			V_VT(&resultVariant) = VT_I4;
			resultVariant.lVal = result;
			
			for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
			{					                                                                                                                                                                                                                                                                                                                                                                                                    
				pT->Lock();
				CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
				pT->Unlock();
				IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
				if (pDispatch != NULL)
				{
					pvars[2] = strNodeName;
					pvars[1] = strLaunchBasis;
					pvars[0] = strAdditionalArgs;
					DISPPARAMS disp = { pvars, NULL, 3, 0 };
					HRESULT hResult;
					if (SUCCEEDED(hResult = pDispatch->Invoke(1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &resultVariant, NULL, NULL)))
						break;
				}
			}
			delete[] pvars;
		}
		return resultVariant.lVal;	
	}

	void Fire_Render(BSTR strPage)
	{
		T* pT = static_cast<T*>(this);

		if (RUNNING_APARTMENT_THREADED())
		{
			CComVariant* pvars = new CComVariant[1];
			pT->Lock();
			for(vector<DWORD>::iterator it = pT->m_vecCookies.begin(); it != pT->m_vecCookies.end(); it++)
			{
				IDispatch* pDispatch = NULL;
				
				pT->m_pGIT->GetInterfaceFromGlobal(*it, IID_IDispatch,
					reinterpret_cast<void**>(&pDispatch));
				
				if (pDispatch != NULL)
				{
					pvars[0] = strPage;
					DISPPARAMS disp = { pvars, NULL, 1, 0 };
					HRESULT result = S_OK;
					if (SUCCEEDED(result = pDispatch->Invoke(2, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL)))
					{
						pDispatch->Release();
						break;
					}
					pDispatch->Release();
				}
			}
			pT->Unlock();
			delete[] pvars;
		}
		if (RUNNING_FREE_THREADED())
		{
			int nConnectionIndex;
			CComVariant* pvars = new CComVariant[1];
			int nConnections = m_vec.GetSize();
			
			for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
			{					                                                                                                                                                                                                                                                                                                                                                                                                    
				pT->Lock();
				CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
				pT->Unlock();
				IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
				if (pDispatch != NULL)
				{
					pvars[0] = strPage;
					DISPPARAMS disp = { pvars, NULL, 1, 0 };
					HRESULT hResult;
					if (SUCCEEDED(hResult = pDispatch->Invoke(2, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL)))
						break;
				}
			}
			delete[] pvars;
		}
	}
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\counter.cpp ===
//
// MODULE: COUNTER.CPP
//
// PURPOSE: implementation the counter classes: 
//		CPeriodicTotals (utility class)
//		CAbstractCounter (abstract base class).
//		CCounter (simple counter)
//		CHourlyCounter (counter with "bins" for each hour of the day)
//		CDailyCounter (counter with "bins" for day of the week)
//		CHourlyDailyCounter (counter with "bins" for each hour of the day and each day of the week)
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 7-20-1998
//
// NOTES: 
//	1. Right as daylight savings time clicks in, there will be a few anomalies.
//		Since this defines "days" to be 24-hour periods, rather than calendar days, 
//		if you have just gone from standard time to daylight time, "previous days"
//		before the switch will begin at 11pm the night before the relevant day; 
//		if you have just gone from daylight time to standard time, "previous days"
//		before the switch will begin at 1am on the relevant day.
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		7-20-98		JM		Original
//
//////////////////////////////////////////////////////////////////////


#include "stdafx.h"
#include "event.h"
#include "SafeTime.h"
#include "Counter.h"
#include "CounterMgr.h"
#include "baseexception.h"
#include <new>
#include "CharConv.h"
#include "apiwraps.h"

const long k_secsPerHour = 3600;
const long k_secsPerDay = k_secsPerHour * 24;
const long k_secsPerWeek = k_secsPerDay * 7;

//////////////////////////////////////////////////////////////////////
// CPeriodicTotals
// Utility class, returned to provide an effective table of hourly/daily
//	counts.
//////////////////////////////////////////////////////////////////////
CPeriodicTotals::CPeriodicTotals(long nPeriods) :
	m_nPeriods(nPeriods),
	m_ptime(NULL),
	m_pCount(NULL)
{
	Reset();
}

CPeriodicTotals::~CPeriodicTotals()
{
	ReleaseMem();
}

void CPeriodicTotals::Reset()
{
	ReleaseMem();

	m_nPeriodsSet = 0;
	m_iPeriod = 0;
	m_ptime = NULL;
	m_pCount = NULL;

	try
	{
		m_ptime = new time_t[m_nPeriods];

		m_pCount = new long[m_nPeriods];
	}
	catch (bad_alloc&)
	{
		// Set the number of periods to zero, release any allocated memory, and rethrow the exception.
		m_nPeriods= 0;
		ReleaseMem();
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								_T(""), _T(""), EV_GTS_CANT_ALLOC ); 
		throw;
	}
}

void CPeriodicTotals::ReleaseMem()
{
	delete [] m_ptime;
	delete [] m_pCount;
}


// Set the time & Count values at the current position and increment the position
bool CPeriodicTotals::SetNext(time_t time, long Count)
{
	if (m_iPeriod >= m_nPeriods)
		return false;
	
	m_ptime[m_iPeriod] = time;
	m_pCount[m_iPeriod++] = Count;
	m_nPeriodsSet++;
	
	return true;
}

// Format a time and count suitably for HTML or other text use.
// returns a reference of convenience to the same string passed in.
CString & CPeriodicTotals::DisplayPeriod(long i, CString & str) const
{
	CString strTime;
	{
		CSafeTime safe(m_ptime[i]);
		str = safe.StrLocalTime();
	}
	strTime.Format(_T(" %8.8d"), m_pCount[i]);
	str += strTime;
	return str;
}

//////////////////////////////////////////////////////////////////////
//	CHourlyTotals
//////////////////////////////////////////////////////////////////////
CHourlyTotals::CHourlyTotals() :
	CPeriodicTotals (24+1)
{
}

CHourlyTotals::~CHourlyTotals()
{
}

// This is strictly for display to operator, so hard-coding English is OK
// returns a reference of convenience to the same string passed in.
CString CHourlyTotals::HTMLDisplay() const
{
	CString str, strTemp;

	if (m_nPeriodsSet > 1)
	{
		str += _T("<TR>\n");
		str += _T("<TD ROWSPAN=\"24\" ALIGN=\"CENTER\" BGCOLOR=\"#CCCC99\">\n");
		str += _T("<B>Last 24 hours: </B>");
		str += _T("</TD>\n");
		for (int i=0; i<24 && i<m_nPeriodsSet-1 ; i++)
		{
			if (i!=0)
				str += _T("<TR>\n");
			str+= _T("<TD ALIGN=\"CENTER\" BGCOLOR=\"#FFFFCC\">\n");
			CPeriodicTotals::DisplayPeriod(i, strTemp);
			str += strTemp;
			str += _T("</TD>\n");
			str += _T("</TR>\n");
		}
	}

	if (m_nPeriodsSet >= 1)
	{
		str += _T("<TR>\n");
		str += _T("<TD ALIGN=\"CENTER\" BGCOLOR=\"#CCCC99\"> \n");
		str += _T("<B>Current hour:</B> ");
		str += _T("</TD>\n");
		str += _T("<TD ALIGN=\"CENTER\" BGCOLOR=\"#FFFFCC\">\n");
		CPeriodicTotals::DisplayPeriod(m_nPeriodsSet-1, strTemp);
		str += strTemp;
		str += _T("</TD>\n");
		str += _T("</TR>\n");
	}
	else
		str = _T("<BR>No hourly data.");

	return str;
}

//////////////////////////////////////////////////////////////////////
//	CDailyTotals
//////////////////////////////////////////////////////////////////////
CDailyTotals::CDailyTotals() :
	CPeriodicTotals (7+1)
{
}

CDailyTotals::~CDailyTotals()
{
}

// This is strictly for display to operator, so hard-coding English is OK
// returns a reference of convenience to the same string passed in.
CString CDailyTotals::HTMLDisplay() const
{
	CString str, strTemp;
	if (m_nPeriodsSet > 1)
	{
		str = _T("<TR>\n");
		str+= _T("<TD ROWSPAN=\"7\" ALIGN=\"CENTER\" BGCOLOR=\"#CCCC99\">\n");
		str += _T("<B>Last 7 days: </B>");
		str += _T("</TD>\n");
		for (int i=0; i<7 && i<m_nPeriodsSet-1 ; i++)
		{
			if (i!=0)
				str += _T("<TR>\n");
			str+= _T("<TD ALIGN=\"CENTER\" BGCOLOR=\"#FFFFCC\">\n");
			CPeriodicTotals::DisplayPeriod(i, strTemp);
			str += strTemp;
			str += _T("</TD>\n");
			str += _T("</TR>\n");
		}
	}

	if (m_nPeriodsSet >= 1)
	{
		str += _T("<TR>\n");
		str += _T("<TD ALIGN=\"CENTER\" BGCOLOR=\"#CCCC99\"> \n");
		str += _T("<B>Today: </B>");
		str += _T("</TD>\n");
		str += _T("<TD ALIGN=\"CENTER\" BGCOLOR=\"#FFFFCC\">\n");
		CPeriodicTotals::DisplayPeriod(m_nPeriodsSet-1, strTemp);
		str += strTemp;
		str += _T("</TD>\n");
		str += _T("</TR>\n");
	}
	else
		str = _T("<BR>No daily data.");

	return str;
}

//////////////////////////////////////////////////////////////////////
// CCounterLocation
//////////////////////////////////////////////////////////////////////
/*static*/ LPCTSTR CCounterLocation::m_GlobalStr = _T("Global");
/*static*/ LPCTSTR CCounterLocation::m_TopicStr  = _T("Topic ");
/*static*/ LPCTSTR CCounterLocation::m_ThreadStr = _T("Thread ");

CCounterLocation::CCounterLocation(EId id, LPCTSTR scope /*=m_GlobalStr*/)
				: m_Scope(scope),
				  m_Id(id)
{
}

CCounterLocation::~CCounterLocation()
{
}

//////////////////////////////////////////////////////////////////////
// CAbstractCounter
//////////////////////////////////////////////////////////////////////
CAbstractCounter::CAbstractCounter(EId id /*=eIdGeneric*/, CString scope /*=m_GlobalStr*/)
				: CCounterLocation(id, scope)
{
	::Get_g_CounterMgr()->AddSubstitute(*this);
}

CAbstractCounter::~CAbstractCounter()
{
	::Get_g_CounterMgr()->Remove(*this);
}

//////////////////////////////////////////////////////////////////////
// CCounter
// a simple counter
//////////////////////////////////////////////////////////////////////
CCounter::CCounter(EId id /*=eIdGeneric*/, CString scope /*=m_GlobalStr*/)
		: CAbstractCounter(id, scope)
{
	Clear();
}

CCounter::~CCounter()
{
}

void CCounter::Increment()
{
	::InterlockedIncrement( &m_Count );
}

void CCounter::Clear()
{
	::InterlockedExchange( &m_Count, 0);
}

void CCounter::Init(long count)
{
	::InterlockedExchange( &m_Count, count);
}

long CCounter::Get() const
{
	return m_Count;
}

//////////////////////////////////////////////////////////////////////
// CHourlyCounter
// This counter maintains bins to keep track of values on a per-hour basis.
//	The code that sets the values can treat this as a CAbstractCounter.
//	Additional public functions are available to report results.
//////////////////////////////////////////////////////////////////////

CHourlyCounter::CHourlyCounter() :
	m_ThisHour (-1), 
	m_ThisTime (0)
{
	m_hMutex = ::CreateMutex(NULL, FALSE, NULL);
	if (!m_hMutex)
	{
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								_T("Hourly"),
								_T(""),
								EV_GTS_ERROR_MUTEX ); 
	}
	Clear();
}

CHourlyCounter::~CHourlyCounter()
{
	::CloseHandle(m_hMutex);
}

void CHourlyCounter::Increment()
{
	WAIT_INFINITE( m_hMutex );
	SetHour();
	m_arrCount[m_ThisHour].Increment();
	::ReleaseMutex(m_hMutex);
}

void CHourlyCounter::Clear()
{
	WAIT_INFINITE( m_hMutex );
	for (long i = 0; i < 24; i++)
		m_arrCount[i].Clear();
	m_nThisHourYesterday = 0;
	::ReleaseMutex(m_hMutex);
}

void CHourlyCounter::Init(long count)
{
	CHourlyCounter::Clear();
	WAIT_INFINITE( m_hMutex );
	SetHour();
	m_arrCount[m_ThisHour].Init(count);
	::ReleaseMutex(m_hMutex);
}

// return a 24-hour total prior to the present hour.
// non-const because it calls SetHour()
long CHourlyCounter::GetDayCount() 
{
	long DayCount = 0;
	WAIT_INFINITE( m_hMutex );
	SetHour();
	for (long i=0; i<24; i++)
	{
		if ( i != m_ThisHour )
			DayCount += m_arrCount[i].Get();
		DayCount += m_nThisHourYesterday;
	}
	::ReleaseMutex(m_hMutex);

	return DayCount;
}

// non-const because it calls SetHour()
void CHourlyCounter::GetHourlies(CHourlyTotals & totals)
{
	WAIT_INFINITE( m_hMutex );

	totals.Reset();

	SetHour();

	time_t time = m_ThisTime - (k_secsPerDay);

	totals.SetNext(time, m_nThisHourYesterday);

	long i;
	for (i=m_ThisHour+1; i<24; i++)
	{
		time += k_secsPerHour;
		totals.SetNext(time, m_arrCount[i].Get());
	}

	for (i=0; i<=m_ThisHour; i++)
	{
		time += k_secsPerHour;
		totals.SetNext(time, m_arrCount[i].Get());
	}

	::ReleaseMutex(m_hMutex);
}

// Based on the present time, shifts to the appropriate bin.
void CHourlyCounter::SetHour()
{
	time_t timeNow;
	time_t timeStartOfHour;

	WAIT_INFINITE( m_hMutex );

	time(&timeNow);
	timeStartOfHour = (timeNow / k_secsPerHour) * k_secsPerHour;

	if (timeStartOfHour > m_ThisTime)
	{
		// If we get here, hour changed.  Typically the last action was the previous
		//	hour, but the algorithm here does not require that.
		long Hour;
		{
			// minimize how long we use CSafeTime, because it means holding a mutex.
			CSafeTime safe(timeStartOfHour);
			Hour = safe.LocalTime().tm_hour;
		}

		if (timeStartOfHour - m_ThisTime > k_secsPerDay)
			Clear();
		else
		{
			m_nThisHourYesterday = m_arrCount[Hour].Get();
			if (m_ThisHour > Hour)
			{
				long i;
				for (i=m_ThisHour+1; i<24; i++)
				{
					m_arrCount[i].Clear();
				}
				for (i=0; i<=Hour; i++)
				{
					m_arrCount[i].Clear();
				}
			}
			else
			{
				for (long i=m_ThisHour+1; i<=Hour; i++)
				{
					m_arrCount[i].Clear();
				}
			}
		}
		
		m_ThisHour = Hour;
		m_ThisTime = timeStartOfHour;
	}
	::ReleaseMutex(m_hMutex);
	return;
}


//////////////////////////////////////////////////////////////////////
// CDailyCounter
// This counter maintains bins to keep track of values on a per-day basis.
//	The code that sets the values can treat this as a CAbstractCounter.
//	Additional public functions are available to report results.
//	This could share more code with CHourlyCounter, but it would be very hard to come up 
//		with appropriate variable and function names, so we are suffering dual maintenance.
//////////////////////////////////////////////////////////////////////

CDailyCounter::CDailyCounter() :
	m_ThisDay (-1), 
	m_ThisTime (0)
{
	m_hMutex = ::CreateMutex(NULL, FALSE, NULL);
	if (!m_hMutex)
	{
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								_T("Daily"),
								_T(""),
								EV_GTS_ERROR_MUTEX ); 
	}
	Clear();
}

CDailyCounter::~CDailyCounter()
{
	::CloseHandle(m_hMutex);
}

void CDailyCounter::Increment()
{
	WAIT_INFINITE( m_hMutex );
	SetDay();
	m_arrCount[m_ThisDay].Increment();
	::ReleaseMutex(m_hMutex);
}

void CDailyCounter::Clear()
{
	WAIT_INFINITE( m_hMutex );
	for (long i = 0; i < 7; i++)
		m_arrCount[i].Clear();
	m_nThisDayLastWeek = 0;
	::ReleaseMutex(m_hMutex);
}

void CDailyCounter::Init(long count)
{
	CDailyCounter::Clear();
	WAIT_INFINITE( m_hMutex );
	SetDay();
	m_arrCount[m_ThisDay].Init(count);
	::ReleaseMutex(m_hMutex);
}

// return a 7-day total prior to the present day.
// non-const because it calls SetDay()
long CDailyCounter::GetWeekCount()
{
	long WeekCount = 0;
	WAIT_INFINITE( m_hMutex );
	SetDay();
	for (long i=0; i<7; i++)
	{
		if ( i != m_ThisDay )
			WeekCount += m_arrCount[i].Get();
		WeekCount += m_nThisDayLastWeek;
	}
	::ReleaseMutex(m_hMutex);

	return WeekCount;
}

// non-const because it calls SetDay()
void CDailyCounter::GetDailies(CDailyTotals & totals)
{
	WAIT_INFINITE( m_hMutex );

	totals.Reset();

	SetDay();

	time_t time = m_ThisTime - (k_secsPerWeek);

	totals.SetNext(time, m_nThisDayLastWeek);

	long i;
	for (i=m_ThisDay+1; i<7; i++)
	{
		time += k_secsPerDay;
		totals.SetNext(time, m_arrCount[i].Get());
	}

	for (i=0; i<=m_ThisDay; i++)
	{
		time += k_secsPerDay;
		totals.SetNext(time, m_arrCount[i].Get());
	}

	::ReleaseMutex(m_hMutex);
}

// Based on the present time, shifts to the appropriate bin.
void CDailyCounter::SetDay()
{
	time_t timeNow;
	time_t timeStartOfDay;

	WAIT_INFINITE( m_hMutex );

	time(&timeNow);

	// Want to get start of day local time.
	// Can't just set timeStartOfDay = (timeNow / k_secsPerDay) * k_secsPerDay
	// because that would be the start of the day based on GMT!
	long DayOfWeek;
	{
		// minimize how long we use CSafeTime, because it means holding a mutex.
		CSafeTime safe(timeNow);
		struct tm tmStartOfDay = safe.LocalTime();
		DayOfWeek = tmStartOfDay.tm_wday;
		tmStartOfDay.tm_sec = 0;
		tmStartOfDay.tm_min = 0;
		tmStartOfDay.tm_hour = 0;
		timeStartOfDay = mktime(&tmStartOfDay);
	}

	if (timeStartOfDay > m_ThisTime)
	{
		// If we get here, day changed.  Typically the last action was the previous
		//	hour, but the algorithm here does not require that.
		{
			// minimize how long we use CSafeTime, because it means holding a mutex.
			CSafeTime safe(timeStartOfDay);
			DayOfWeek = safe.LocalTime().tm_wday;
		}

		if (timeStartOfDay - m_ThisTime > k_secsPerWeek)
			Clear();
		else
		{
			m_nThisDayLastWeek = m_arrCount[DayOfWeek].Get();
			if (m_ThisDay > DayOfWeek)
			{
				long i;
				for (i=m_ThisDay+1; i<7; i++)
				{
					m_arrCount[i].Clear();
				}
				for (i=0; i<=DayOfWeek; i++)
				{
					m_arrCount[i].Clear();
				}
			}
			else
			{
				for (long i=m_ThisDay+1; i<=DayOfWeek; i++)
				{
					m_arrCount[i].Clear();
				}
			}
		}
		
		m_ThisDay = DayOfWeek;
		m_ThisTime = timeStartOfDay;
	}
	::ReleaseMutex(m_hMutex);
	return;
}

//////////////////////////////////////////////////////////////////////
// CHourlyDailyCounter
//////////////////////////////////////////////////////////////////////
CHourlyDailyCounter::CHourlyDailyCounter(EId id /*=eIdGeneric*/, CString scope /*=m_GlobalStr*/) 
				   : CAbstractCounter(id, scope),
					 m_Total(0), 
					 m_timeFirst(0),
					 m_timeLast(0),
					 m_timeCleared(0)
{
	m_hMutex = ::CreateMutex(NULL, FALSE, NULL);
	if (!m_hMutex)
	{
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								_T("HourlyDaily"),
								_T(""),
								EV_GTS_ERROR_MUTEX ); 
	}

	time(&m_timeCreated);
	time(&m_timeCleared);
}

CHourlyDailyCounter::~CHourlyDailyCounter()
{
	::CloseHandle(m_hMutex);
}

void CHourlyDailyCounter::Increment()
{
	WAIT_INFINITE( m_hMutex );
	m_hourly.Increment();
	m_daily.Increment();
	m_Total++;
	time(&m_timeLast);
	if (!m_timeFirst)
		m_timeFirst = m_timeLast;
	::ReleaseMutex(m_hMutex);
}

void CHourlyDailyCounter::Clear()
{
	WAIT_INFINITE( m_hMutex );
	m_hourly.Clear();
	m_daily.Clear();
	m_Total= 0;
	m_timeFirst = 0;
	m_timeLast = 0;
	time(&m_timeCleared);
	::ReleaseMutex(m_hMutex);
}

void CHourlyDailyCounter::Init(long count)
{
	CHourlyDailyCounter::Clear();
	WAIT_INFINITE( m_hMutex );
	m_hourly.Init(count);
	m_daily.Init(count);
	m_Total = count;
	time(&m_timeLast);
	if (!m_timeFirst)
		m_timeFirst = m_timeLast;
	::ReleaseMutex(m_hMutex);
}

// no need to lock here, because m_hourly does its own locking.
long CHourlyDailyCounter::GetDayCount()
{
	return m_hourly.GetDayCount();
}

// no need to lock here, because m_hourly does its own locking.
void CHourlyDailyCounter::GetHourlies(CHourlyTotals & totals)
{
	m_hourly.GetHourlies(totals);
}

// no need to lock here, because m_daily does its own locking.
long CHourlyDailyCounter::GetWeekCount()
{
	return m_daily.GetWeekCount();
}

// no need to lock here, because m_daily does its own locking.
void CHourlyDailyCounter::GetDailies(CDailyTotals & totals)
{
	m_daily.GetDailies(totals);
}

long CHourlyDailyCounter::GetTotal() const
{
	WAIT_INFINITE( m_hMutex );
	long ret = m_Total;
	::ReleaseMutex(m_hMutex);
	return ret;
};

time_t CHourlyDailyCounter::GetTimeFirst() const 
{
	WAIT_INFINITE( m_hMutex );
	time_t ret = m_timeFirst;
	::ReleaseMutex(m_hMutex);
	return ret;
};

time_t CHourlyDailyCounter::GetTimeLast() const
{
	WAIT_INFINITE( m_hMutex );
	time_t ret = m_timeLast;
	::ReleaseMutex(m_hMutex);
	return ret;
};

time_t CHourlyDailyCounter::GetTimeCleared() const
{
	WAIT_INFINITE( m_hMutex );
	time_t ret = m_timeCleared;
	::ReleaseMutex(m_hMutex);
	return ret;
};

time_t CHourlyDailyCounter::GetTimeCreated() const
{
	WAIT_INFINITE( m_hMutex );
	time_t ret = m_timeCreated;
	::ReleaseMutex(m_hMutex);
	return ret;
}

time_t CHourlyDailyCounter::GetTimeNow() const
{
	// No need to lock mutex on this call.
	time_t ret;
	time(&ret);

	return ret;
}

////////////////////////////////////////////////////////////////////////////////////
// CDisplayCounter...::Display() implementation
////////////////////////////////////////////////////////////////////////////////////
#define STATUS_INVALID_NUMBER_STR   _T("none")
#define STATUS_INVALID_TIME_STR     _T("none")

CString CDisplayCounterTotal::Display()
{
	TCHAR buf[128] = {0};
	_stprintf(buf, _T("%ld"), long(((CHourlyDailyCounter*)m_pAbstractCounter)->GetTotal()));
	return buf;
}

CString CDisplayCounterCurrentDateTime::Display()
{
	return CSafeTime(((CHourlyDailyCounter*)m_pAbstractCounter)->GetTimeNow()).StrLocalTime(STATUS_INVALID_TIME_STR);
}

CString CDisplayCounterCreateDateTime::Display()
{
	return CSafeTime(((CHourlyDailyCounter*)m_pAbstractCounter)->GetTimeCreated()).StrLocalTime(STATUS_INVALID_TIME_STR);
}

CString CDisplayCounterFirstDateTime::Display()
{
	return CSafeTime(((CHourlyDailyCounter*)m_pAbstractCounter)->GetTimeFirst()).StrLocalTime(STATUS_INVALID_TIME_STR);
}

CString CDisplayCounterLastDateTime::Display()
{
	return CSafeTime(((CHourlyDailyCounter*)m_pAbstractCounter)->GetTimeLast()).StrLocalTime(STATUS_INVALID_TIME_STR);
}

CString CDisplayCounterDailyHourly::Display() 
{
	CString ret;

	if (m_pDailyTotals) {
		((CHourlyDailyCounter*)m_pAbstractCounter)->GetDailies(*m_pDailyTotals);
		ret += m_pDailyTotals->HTMLDisplay();
	}
	if (m_pHourlyTotals) {
		((CHourlyDailyCounter*)m_pAbstractCounter)->GetHourlies(*m_pHourlyTotals);
		ret += m_pHourlyTotals->HTMLDisplay();
	}

	return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\cstd.h ===
#ifndef _CSTD_H_
#define _CSTD_H_

#include <windows.h>

#define PvCast(type,  TYPE) 	((TYPE) (type))
#define OFFSET(field, type) 	((ULONG) &(type).field - (ULONG) &(type))

#ifndef	VOID
typedef	void			VOID;
#endif
typedef TCHAR*			  SZ;
//typedef TCHAR*			 PSZ;
typedef const TCHAR*	 SZC;

#ifndef max
	#define max(a, b)	((a) >= (b) ? (a) : (b))
#endif

#ifndef TRUE
	#define	TRUE	1
  	#define FALSE 	0
#endif

typedef enum
{
	fFalse = 0,
	fTrue  = !fFalse
};

typedef enum
{
	bFalse = 0,
	bTrue  = !bFalse
};


//typedef char*			   PCH;
typedef int 			  BOOL;

#ifndef  _WINDOWS
typedef unsigned short	  WORD;
typedef unsigned long	 DWORD;
typedef long			  LONG;
#endif

typedef unsigned char	 UCHAR;
typedef short			 SHORT;
typedef unsigned char	  BYTE;
typedef BYTE*			    PB;
typedef unsigned short	USHORT;
typedef int 			   INT;
typedef unsigned int	  UINT;
typedef unsigned long	 ULONG;
typedef double			   DBL;
typedef double			  REAL;

typedef ULONG			   RVA; 		// Relative Virtual Address
typedef ULONG			   LFA; 		// Long File Address
typedef	INT				(*PFNCMP)(const VOID*, const VOID*);

#include "debug.h"

#define CelemArray(rgtype)		(sizeof(rgtype) / sizeof(rgtype[0]))

SZ		SzCopy(SZC);

#ifdef	_WINDOWS
/* BUGBUG: See if this still compiles
	void __cdecl perror(const char*);
	int  __cdecl printf(const char*, ...);
	int  __cdecl vprintf(const char*, va_list);
	void __cdecl exit(int);
 */
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\dscread.cpp ===
//
// MODULE: DSCREAD.CPP
//
// PURPOSE: dsc reading classes
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 8-19-98
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		08-04-98	OK
//

#include "stdafx.h"
#include "dscread.h"
#include "fileread.h"
#include "event.h"
#include "baseexception.h"

#ifdef LOCAL_TROUBLESHOOTER
#include "CHMfileReader.h"
#endif

////////////////////////////////////////////////////////////////////////////////////
// CDSCReaderException
////////////////////////////////////////////////////////////////////////////////////
// source_file is LPCSTR rather than LPCTSTR because __FILE__ is char[35]
CDSCReaderException::CDSCReaderException(CDSCReader* reader, eErr err, LPCSTR source_file, int line)
				   : CBaseException(source_file, line),
					 m_pDSCReader(reader),
					 m_eErr(err)
{
}

CDSCReaderException::~CDSCReaderException()
{
}

void CDSCReaderException::Clear()
{
	m_pDSCReader->Clear();
}

////////////////////////////////////////////////////////////////////////////////////
// CDSCReader
//	This handles just the reading of BNTS.  CBN packages it up for public consumption.
////////////////////////////////////////////////////////////////////////////////////
CDSCReader::CDSCReader(CPhysicalFileReader* pPhysicalFileReader)
		  : CStateless(),
			m_pPhysicalFileReader(pPhysicalFileReader),
			m_strPath(pPhysicalFileReader->GetPathName()),
			m_strName(pPhysicalFileReader->GetJustName()),
			m_bIsRead(false),
			m_bDeleteFile(false)
{
	// Arbitrary default for m_stimeLastWrite
    m_stimeLastWrite.wYear = 0;
    m_stimeLastWrite.wMonth = 0;
    m_stimeLastWrite.wDayOfWeek =0;
    m_stimeLastWrite.wDay = 1;
    m_stimeLastWrite.wHour = 0;
    m_stimeLastWrite.wMinute = 0;
    m_stimeLastWrite.wSecond = 0;
    m_stimeLastWrite.wMilliseconds = 0;
}

CDSCReader::~CDSCReader()
{
	delete m_pPhysicalFileReader;
}

bool CDSCReader::IsValid() const
{
	bool ret = false;
	LOCKOBJECT();
	ret = m_Network.BValidNet() ? true : false;
	UNLOCKOBJECT();
	return ret;
}

bool CDSCReader::IsRead() const
{
	bool ret = false;
	LOCKOBJECT();
	ret = m_bIsRead;
	UNLOCKOBJECT();
	return ret;
}

bool CDSCReader::Read()
{
	bool ret = false;

#ifdef LOCAL_TROUBLESHOOTER
	CHMfileHandler( m_strPath );
#endif

	LOCKOBJECT();
	if (m_bIsRead)
		Clear();
	if (m_Network.BReadModel(m_strPath, NULL))
	{
		m_bIsRead = true;
		ret = true;
	}
	UNLOCKOBJECT();

	if (m_bDeleteFile)
		::DeleteFile( m_strPath );

	return ret;
}

void CDSCReader::Clear()
{
	LOCKOBJECT();
	m_Network.Clear();
	m_bIsRead = false;
	UNLOCKOBJECT();
}


#ifdef LOCAL_TROUBLESHOOTER
// Function called from the ctor to handle the checking and optionally writing out
// of a CHM file to a temporary file.
bool CDSCReader::CHMfileHandler( LPCTSTR path )
{
	bool bRetVal= false;

	if (CCHMFileReader::IsCHMfile( m_strPath ))
	{
		CString strContent;
		CFileReader file_reader(m_pPhysicalFileReader, false/*don't delete physical reader*/);

		// read file from inside CHM
		if (!file_reader.Read())
			return bRetVal;

		file_reader.GetContent(strContent);

		// Build the temporary file name.
		TCHAR	szTempDir[ _MAX_DIR ];
		::GetTempPath( sizeof( szTempDir ), szTempDir );
		
		CString strTmpFName= szTempDir;
		strTmpFName+= file_reader.GetJustNameWithoutExtension();
		strTmpFName+= _T(".");
		strTmpFName+= file_reader.GetJustExtension();

		// Open the temporary file and write out the contents of the CHM file.
		HANDLE hTmpFile= ::CreateFile(	strTmpFName,
										GENERIC_WRITE,
										0,	// No Sharing.
										NULL,
										CREATE_ALWAYS,
										FILE_ATTRIBUTE_TEMPORARY,
										NULL );
		if (INVALID_HANDLE_VALUE != hTmpFile)
		{
			DWORD dwBytesWritten;
			
			if (!::WriteFile( hTmpFile, (LPCTSTR)strContent, strContent.GetLength(), &dwBytesWritten, NULL))
			{
				// >>>	Need to consider what we should do in this case.
			}
			else
			{
				bRetVal= true;
			}
			::CloseHandle( hTmpFile );
		}

		if (bRetVal)
		{
			// Reassign the path to the temporary file.
			m_strPath= strTmpFName;

			// Set the delete flag to true.
			m_bDeleteFile= true;
		}
	}
	return( bRetVal );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\enumstd.h ===
//
//	enumstd.h:  Standard global enumerations
//

#ifndef _ENUMSTD_H_
#define _ENUMSTD_H_

#include<windows.h>
////////////////////////////////////////////////////////////////////
//	Property flags
////////////////////////////////////////////////////////////////////
const UINT fPropString = 1;			//  Property is a string (!fPropString ==> real)
const UINT fPropArray = 2;			//	Property is an array (!fPropArray  ==> scalar)
const UINT fPropChoice = 4;			//	Property is an enumerated value
const UINT fPropStandard = 8;		//  Property is standard (stored in Registry)
const UINT fPropPersist = 16;		//  Property is persistent (stored in Registry)

////////////////////////////////////////////////////////////////////
//	Definitions to enable usage of "MS_" standard properties
////////////////////////////////////////////////////////////////////
enum ESTDPROP
{
	ESTDP_label,			//  Node troubleshooting label (choice)
	ESTDP_cost_fix,			//  Cost to fix	(real)
	ESTDP_cost_observe,		//  Cost to observe (real)
	ESTDP_category,			//  Category (string)
	ESTDP_normalState,		//  Index of troubleshooting "normal" state (int)
	ESTDP_max				//  End
};

enum ESTDLBL		//  VOI-relative node label
{
	ESTDLBL_other,
	ESTDLBL_hypo,
	ESTDLBL_info,
	ESTDLBL_problem,
	ESTDLBL_fixobs,
	ESTDLBL_fixunobs,
	ESTDLBL_unfix,
	ESTDLBL_config,
	ESTDLBL_max
};


#endif // _ENUMSTD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\event.h ===
//
// MODULE: Event.h
//
// PURPOSE: Interface for class CEvent: Event Logging
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Roman Mach
// 
// ORIGINAL DATE: 8-2-96
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		9/18/98		JM		Abstracted as a class.  Previously, global.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_EVENT_H__C3B8EE73_4F15_11D2_95F9_00C04FC22ADD__INCLUDED_)
#define AFX_EVENT_H__C3B8EE73_4F15_11D2_95F9_00C04FC22ADD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "apgtsevt.h"
#include "ApgtsCounters.h"

// event name (goes under application to form a registry key)
#define REG_EVT_ITEM_STR	_T("APGTS")


class CEvent  
{
friend class CRegistryMonitor;	// just so this can set m_bLogAll
private: 
	static bool s_bUseEventLog;
	static bool s_bLogAll;
	static CAbstractCounter * const s_pcountErrors;
public:
	static void SetUseEventLog(bool bUseEventLog);
	static void ReportWFEvent(
		LPCTSTR string1,
		LPCTSTR string2,
		LPCTSTR string3,
		LPCTSTR string4,
		DWORD eventID);
};

#endif // !defined(AFX_EVENT_H__C3B8EE73_4F15_11D2_95F9_00C04FC22ADD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\dscread.h ===
//
// MODULE: DSCREAD.H
//
// PURPOSE: dsc reading classes
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 8-19-98
//
// NOTES: 
//	>>> TBD: must deal with case where DSC file is in a CHM. I assume we must unpack it
//	from CHM into a normal directory, then read it with BReadModel.  Exception handling scheme
//	must cope correctly with the fact that the error may be either from the CHM file or the 
//	DSC file.  Maybe use CFileReader to read from the CHM file and write the copy
//	to disk?	JM 1/7/99
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		08-04-98	OK
//

#ifndef __DSCREAD_H_
#define __DSCREAD_H_

#include "BaseException.h"
#include "stateless.h"
#include "bnts.h"


////////////////////////////////////////////////////////////////////////////////////
// CDSCReaderException
////////////////////////////////////////////////////////////////////////////////////
class CDSCReader;
class CDSCReaderException : public CBaseException
{
public:
	enum eErr {
		eErrRead, 
		eErrGetDateTime,
		eErrUnpackCHM		// for Local Troubleshooter only
	} m_eErr;

protected:
	CDSCReader* m_pDSCReader;

public:
	// source_file is LPCSTR rather than LPCTSTR because __FILE__ is char[35]
	CDSCReaderException(CDSCReader* reader, eErr err, LPCSTR source_file, int line);
	virtual ~CDSCReaderException();

public:
	virtual void Clear();
};

////////////////////////////////////////////////////////////////////////////////////
// CDSCReader
//	This handles just the reading of BNTS.  CBN packages it up for public consumption.
////////////////////////////////////////////////////////////////////////////////////
class CPhysicalFileReader;
class CDSCReader : public CStateless
{
protected:
	CPhysicalFileReader* m_pPhysicalFileReader;
	CString m_strName;			 // network name
	CString m_strPath;			 // full path and name of dsc file
	BNTS m_Network;
	bool m_bIsRead;				 // network has been loaded
	SYSTEMTIME m_stimeLastWrite; // when the DSC file was last written to
	bool m_bDeleteFile;			// Set to true when a temporary file originating from a 
								// CHM file needs to be deleted in the destructor.

public:
	CDSCReader(CPhysicalFileReader*);
   ~CDSCReader();

public:
	bool    IsRead() const;
	bool    IsValid() const;

public:
	// These functions to be ONLY public interface.
	bool Read();
	void Clear();

#ifdef LOCAL_TROUBLESHOOTER
private:
	bool CHMfileHandler( LPCTSTR path );
#endif
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\debug.h ===
#ifndef _DEBUG_H_
#define _DEBUG_H_

#ifdef	_DEBUG
#ifdef	__cplusplus

#include "cstd.h"

class	INI
{
  public:
	static UINT 	DtgProfileString( const TCHAR *szValue,
									  const TCHAR *szDefault,
									  TCHAR *szResult,
									  INT cbResult,
									  const TCHAR *szSection = _szSection );
	
	static UINT 	DtgProfileInt( const TCHAR *szValue,
								   INT iDefault,
								   const TCHAR *szSection = _szSection );
								
	static const TCHAR*	SzDebugSection () 		{ return _szSection  ; }
	static const TCHAR*	SzToolSection () 		{ return _szSection  ; }
	
	static BOOL 	DtgProfileTestDbgFlag(UINT fDbgFlag, BOOL fOr);
	
	static BOOL		FExitOnAssert()
	{
		return DtgProfileInt(_szAssertExit, bTrue);
	}

	static UINT		CAssertToPost()
	{
		return DtgProfileInt(_szAssertCount, 10);
	}

	static BOOL		FAssertOnLeak()
	{
		return DtgProfileInt(_szAssertMemLeak, bTrue);
	}
	
	static BOOL		FDebugFlag()
	{
		return DtgProfileInt(_szActive, bFalse);
	}

	static VOID		WriteCallocStop(UINT cAlloc);

	static UINT		CallocStopRead()
	{
		return DtgProfileInt(_szCallocStop, 0);
	}
	
  private:
	static const TCHAR*		_szName;
	static const TCHAR*		_szSection;
	static const TCHAR*		_szToolSection;
	static const TCHAR*		_szActive;
	static const TCHAR*		_szAssertExit;
	static const TCHAR*		_szAssertCount;
	static const TCHAR*		_szAssertMemLeak;
	static const TCHAR*		_szDebugFlag;
	static const TCHAR*		_szCallocStop;
};
#endif
#endif

#define Assert(cond)			AssertSz(cond, #cond)

VOID	DebugAppExit();

//  Return TRUE if the given bit(s) are on in the debug flag.
//  If 'fOr', any bit returns TRUE; if !fOr all bits must match.
//extern BOOL DtgProfileTestDbgFlag ( UINT fDbgFlag, BOOL fOr = TRUE );

//  Return just the file name from a possibly full path.
extern const char * DtgDbgReduceFileName ( const char * pszFileName ) ;

#ifdef	_DEBUG
	typedef UINT LINE;

	#define	AssertData()			static SZ	__file__ = __FILE__

	extern  VOID    PrintFileLine(SZ, UINT);
	extern  VOID	 AssertFailed(SZC szFile, LINE line, SZC szCond, BOOL bFatal);
	extern  VOID    DBVPrintf(SZ, ...);
	extern  VOID	 CheckHeap();
	extern  VOID    NYI();
	extern  VOID 	 NotReached();
	extern  BOOL    fDebug;

	#if defined(MSBN)	
		#define AssertSafeAlloc(count,typnam) \
			 AssertSzFatal((long) count * sizeof(typnam) < 65535L,\
			"Attempt to allocate > 64K in block")
		#define	DebugMSBN(x)		x
	#else
		#define AssertSafeAlloc(count, typnam)
		#define	DebugMSBN(x)
	#endif
	// Assert-with-messge macro; allows continuation skipping problem
	#define AssertSz(cond, sz)\
		if (!(cond))\
			AssertFailed(__file__, __LINE__, sz, fFalse);\
		else
		
	//  Assert-with-message macro; forces program termination
	#define AssertSzFatal(cond, sz)\
		if (!(cond))\
			AssertFailed(__file__, __LINE__, sz, fTrue);\
		else

	#define Verify(x)               Assert(x)
	#define Debug(x)				x

	#define DBPrintf(fLevel, arglist)\
		((fDebug & fLevel) ? (PrintFileLine(__FILE__, __LINE__),\
               	(DBVPrintf arglist),\
				 DBVPrintf("\r\n")) : 0)\

#else		// DEBUG

	//	Null definitions for debug-message functions
	#define AssertSafeAlloc(count, typnam)
	#define	AssertData()
	#define AssertSz(cond, sz)
	#define AssertSzFatal(cond, sz)
	#define Verify(cond)			cond
	#define Debug(x)
	#define	DebugMSBN(x)
	#define DBPrintf(x, y)
	#define	CheckHeap()
	#define	NYI()
	#define	NotReached()
	#define Trace(szFunc)
	
#endif		// _DEBUG

#endif		// _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\dirmonitor.cpp ===
//
// MODULE: DirMonitor.cpp
//
// PURPOSE: Monitor changes to LST, DSC, HTI, BES files.
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 9-17-98
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		09-17-98	JM
//

#pragma warning(disable:4786)

#include "stdafx.h"
#include <algorithm>
#include "DirMonitor.h"
#include "event.h"
#include "apiwraps.h"
#include "CharConv.h"
#ifdef LOCAL_TROUBLESHOOTER
#include "LocalLSTReader.h"
#include "CHMFileReader.h"
#endif
#include "apgts.h"	// Need for Local-Online macros.

const DWORD k_secsDefaultReloadDelay = 40;	// In practice, this default should not matter, 
								//  because SetReloadDelay() should be called before 
								//	SetResourceDirectory().  However, 40 is a typical 
								//	reasonable value for m_secsReloadDelay.

/////////////////////////////////////////////////////////////////////
// CTopicFileTracker
/////////////////////////////////////////////////////////////////////

CTopicFileTracker::CTopicFileTracker() :
	CFileTracker()
{
}

CTopicFileTracker::~CTopicFileTracker()
{
}

void CTopicFileTracker::AddTopicInfo(const CTopicInfo & topicinfo)
{
	m_topicinfo = topicinfo;

	// set CFileTracker member variables accordingly for files that are present.
	// If they are not present i.e. empty strings then adding them here results in
	// unnecessary event log entries.
	AddFile(topicinfo.GetDscFilePath());

	CString strHTI = topicinfo.GetHtiFilePath();
	if (!strHTI.IsEmpty())
		AddFile(strHTI);

	CString strBES = topicinfo.GetBesFilePath();
	if (!strBES.IsEmpty())
		AddFile(strBES);
}

const CTopicInfo & CTopicFileTracker::GetTopicInfo() const
{
	return m_topicinfo;
}

/////////////////////////////////////////////////////////////////////
// CTemplateFileTracker
/////////////////////////////////////////////////////////////////////

CTemplateFileTracker::CTemplateFileTracker() :
	CFileTracker()
{
}

CTemplateFileTracker::~CTemplateFileTracker()
{
}

void CTemplateFileTracker::AddTemplateName( const CString& strTemplateName )
{
	m_strTemplateName= strTemplateName;
	AddFile( strTemplateName );
}

const CString& CTemplateFileTracker::GetTemplateName() const
{
	return m_strTemplateName;
}

//////////////////////////////////////////////////////////////////////
// CDirectoryMonitor::ThreadStatus
//////////////////////////////////////////////////////////////////////
/* static */ CString CDirectoryMonitor::ThreadStatusText(ThreadStatus ts)
{
	switch(ts)
	{
		case eBeforeInit:		return _T("Before Init");
		case eFail:				return _T("Fail");
		case eWaitDirPath:		return _T("Wait For Dir Path");
		case eWaitChange:		return _T("Wait for Change");
		case eWaitSettle:		return _T("Wait to Settle");
		case eRun:				return _T("Run");
		case eBeforeWaitChange: return _T("Before Wait Change");
		case eExiting:			return _T("Exiting");
		default:				return _T("");
	}
}

/////////////////////////////////////////////////////////////////////
// CDirectoryMonitor
// This class does the bulk of its work on a separate thread.
// The thread is created in the constructor by starting static function
//	CDirectoryMonitor::DirectoryMonitorTask
// That function, in turn does its work by calling private members of this class that
//	are specific to use on the DirectoryMonitorTask thread.
// When this goes out of scope, its own destructor calls ShutDown to stop the thread,
//	waits for the thread to shut.
// The following methods are available for other threads communicating with that thread:
//	CDirectoryMonitor::SetReloadDelay
//	CDirectoryMonitor::SetResourceDirectory
/////////////////////////////////////////////////////////////////////
CDirectoryMonitor::CDirectoryMonitor(CTopicShop & TopicShop, const CString& strTopicName) :
	m_strTopicName(strTopicName),
	m_TopicShop(TopicShop),
	m_pErrorTemplate(NULL),
	m_strDirPath(_T("")),		// Essential that this starts blank.  Getting a different
								//	value is how we start the DirectoryMonitorTask thread.
	m_bDirPathChanged(false),
	m_bShuttingDown(false),
	m_secsReloadDelay(k_secsDefaultReloadDelay),
	m_pTrackLst( NULL ),
	m_pTrackErrorTemplate( NULL ),
	m_pLst( NULL ),
	m_dwErr(0),
	m_ThreadStatus(eBeforeInit),
	m_time(0)
{
	enum {eHevMon, eHevShut, eThread, eOK} Progress = eHevMon;
	SetThreadStatus(eBeforeInit);

	m_hevMonitorRequested = ::CreateEvent( 
		NULL, 
		FALSE, // release one thread (the DirectoryMonitorTask) on signal
		FALSE, // initially non-signalled
		NULL);
	if (m_hevMonitorRequested)
	{
		Progress = eHevShut;
		m_hevThreadIsShut = ::CreateEvent( 
			NULL, 
			FALSE, // release one thread (this one) on signal
			FALSE, // initially non-signalled
			NULL);

		if (m_hevThreadIsShut)
		{
			Progress = eThread;
			DWORD dwThreadID;	// No need to hold onto dwThreadID in member variable.
								// All Win32 functions take the handle m_hThread instead.
								// The one reason you'd ever want to know this ID is for 
								//	debugging

			// Note that there is no corresponding ::CloseHandle(m_hThread).
			// That is because the thread goes out of existence on the implicit 
			//	::ExitThread() when DirectoryMonitorTask returns.  See documentation of
			//	::CreateThread for further details JM 10/22/98
			m_hThread = ::CreateThread( NULL, 
											0, 
											(LPTHREAD_START_ROUTINE)DirectoryMonitorTask, 
											this, 
											0, 
											&dwThreadID);

			if (m_hThread)
				Progress = eOK;
		}
	}

	if (Progress != eOK)
	{
		m_dwErr = GetLastError();
		CString str;
		str.Format(_T("%d"), m_dwErr);
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								(Progress == eHevMon) ?		_T("Can't create monitor event")
								: (Progress == eHevShut) ?	_T("Can't create \"shut\" event")
								:							_T("Can't create thread"),
								str, 
								EV_GTS_ERROR_DIRMONITORTHREAD );
		SetThreadStatus(eFail);

		if (m_hevMonitorRequested)
			::CloseHandle(m_hevMonitorRequested);

		if (m_hevThreadIsShut)
			::CloseHandle(m_hevThreadIsShut);
	}	
}

CDirectoryMonitor::~CDirectoryMonitor()
{
	ShutDown();
	
	if (m_hevMonitorRequested)
		::CloseHandle(m_hevMonitorRequested);

	if (m_hevThreadIsShut)
		::CloseHandle(m_hevThreadIsShut);

	if (m_pErrorTemplate)
		delete m_pErrorTemplate;

	if (m_pTrackLst)
		delete m_pTrackLst;

	if (m_pTrackErrorTemplate)
		delete m_pTrackErrorTemplate;
}

void CDirectoryMonitor::SetThreadStatus(ThreadStatus ts)
{
	LOCKOBJECT();
	m_ThreadStatus = ts;
	time(&m_time);
	UNLOCKOBJECT();
}

DWORD CDirectoryMonitor::GetStatus(ThreadStatus &ts, DWORD & seconds) const
{
	time_t timeNow;
	LOCKOBJECT();
	ts = m_ThreadStatus;
	time(&timeNow);
	seconds = timeNow - m_time;
	UNLOCKOBJECT();
	return m_dwErr;
}

// Only for use by this class's own destructor.
void CDirectoryMonitor::ShutDown()
{
	LOCKOBJECT();
	m_bShuttingDown = true;
	if (m_hThread)
	{
		::SetEvent(m_hevMonitorRequested);
		UNLOCKOBJECT();

		// Wait for a set period, if failure then log error msg and wait infinite.
		WAIT_INFINITE( m_hevThreadIsShut ); 
	}
	else
		UNLOCKOBJECT();
}

// For use by the DirectoryMonitorTask thread.
// Read LST file and add any topics that are not already in previously read LST file contents
void CDirectoryMonitor::LstFileDrivesTopics()
{
	// previous LST file contents, saved for comparison.
	CAPGTSLSTReader *pLstOld = m_pLst;

	if (! m_strLstPath.IsEmpty() )
	{
		try
		{
#ifdef LOCAL_TROUBLESHOOTER
			m_pLst = new CLocalLSTReader( CPhysicalFileReader::makeReader( m_strLstPath ), m_strTopicName);
#else
			m_pLst = new CAPGTSLSTReader( dynamic_cast<CPhysicalFileReader*>(new CNormalFileReader(m_strLstPath)) );
#endif
		}
		catch (bad_alloc&)
		{
			// Restore old LST contents.
			m_pLst = pLstOld;

			// Rethrow exception, logging handled upstream.
			throw;
		}

		if (! m_pLst->Read())
		{
			// Restore old LST contents and log error.
			delete m_pLst;
			m_pLst = pLstOld;
			
			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									_T(""), 
									_T(""), 
									EV_GTS_ERROR_LST_FILE_READ ); 
		}
		else
		{
			CTopicInfoVector arrNewTopicInfo;
			m_pLst->GetDifference(pLstOld, arrNewTopicInfo);
			if (pLstOld)
				delete pLstOld;

			for (CTopicInfoVector::iterator itNewTopicInfo = arrNewTopicInfo.begin(); 
				itNewTopicInfo != arrNewTopicInfo.end(); 
				itNewTopicInfo++
			)
			{
				// Let the Topic Shop know about the new topic
				m_TopicShop.AddTopic(*itNewTopicInfo);

				// add it to our list of files to track for changes
				CTopicFileTracker TopicFileTracker;
				TopicFileTracker.AddTopicInfo(*itNewTopicInfo);
				LOCKOBJECT();
				try
				{
					m_arrTrackTopic.push_back(TopicFileTracker);
				}
				catch (exception& x)
				{
					CString str;
					// Note STL exception in event log.
					CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
					CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
											SrcLoc.GetSrcFileLineStr(), 
											CCharConversion::ConvertACharToString(x.what(), str), 
											_T(""), 
											EV_GTS_STL_EXCEPTION ); 
				}
				UNLOCKOBJECT();
			}
		}
	}
	// if topic shop not already open, open it
	m_TopicShop.OpenShop();	
}


// Called by the topic shop to add alternate templates to track.
void CDirectoryMonitor::AddTemplateToTrack( const CString& strTemplateName )
{
	LOCKOBJECT();
	try
	{
		CTemplateFileTracker TemplateFileTracker;
		TemplateFileTracker.AddTemplateName( strTemplateName );

		m_arrTrackTemplate.push_back( TemplateFileTracker );
	}
	catch (exception& x)
	{
		CString str;
		// Note STL exception in event log.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								CCharConversion::ConvertACharToString(x.what(), str), 
								_T(""), 
								EV_GTS_STL_EXCEPTION ); 
	}
	UNLOCKOBJECT();
}


// For use by the DirectoryMonitorTask thread.
void CDirectoryMonitor::ReadErrorTemplate()
{
	LOCKOBJECT();

	if (m_pErrorTemplate)
		delete m_pErrorTemplate;

	CString str = k_strDefaultErrorTemplateBefore; 
	str += k_strErrorTemplateKey;
	str += k_strDefaultErrorTemplateAfter;

	try
	{
		m_pErrorTemplate = new CSimpleTemplate(	CPhysicalFileReader::makeReader( m_strErrorTemplatePath ), str );
	}
	catch (bad_alloc&)
	{
		UNLOCKOBJECT();

		// Rethrow the exception.
		throw;
	}

	m_pErrorTemplate->Read();

	UNLOCKOBJECT();
}

// For use by any thread.  In this class because CDirectoryMonitor needs to own
//	ErrorTemplate, since it can change during run of system.
void CDirectoryMonitor::CreateErrorPage(const CString & strError, CString& out) const
{
	LOCKOBJECT();

	if (m_pErrorTemplate)
	{
		vector<CTemplateInfo> arrTemplateInfo;
		CTemplateInfo info(k_strErrorTemplateKey, strError);
		try
		{
			arrTemplateInfo.push_back(info);
			m_pErrorTemplate->CreatePage( arrTemplateInfo, out );
		}
		catch (exception& x)
		{
			CString str;
			// Note STL exception in event log.
			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									CCharConversion::ConvertACharToString(x.what(), str), 
									_T(""), 
									EV_GTS_STL_EXCEPTION ); 

			// Generate the default error page to be safe.
			out = k_strDefaultErrorTemplateBefore + strError + k_strDefaultErrorTemplateAfter;
		}
	}
	else
		out = k_strDefaultErrorTemplateBefore + strError + k_strDefaultErrorTemplateAfter;

	UNLOCKOBJECT();
}

// Must be called on DirectoryMonitorTask thread.  
// Handles all work of monitoring the directory.  Loops till shutdown.
void CDirectoryMonitor::Monitor()
{
	enum {	
#ifndef LOCAL_TROUBLESHOOTER
			eDirChange, // file in directory changed 
#endif
			eHev,		// shutdown or change what directory 
			eNumHandles	};

	// array of handles we use when waiting for multiple events.  
	// Initialize first entry to default bad value.
	HANDLE hList[eNumHandles]= { INVALID_HANDLE_VALUE }; 

	if (m_strDirPath.GetLength() == 0)
	{
		SetThreadStatus(eWaitDirPath);

		// Block this thread until notification that the directory path has been set.
		::WaitForSingleObject( m_hevMonitorRequested, INFINITE);
	}

	SetThreadStatus(eRun);

	try 
	{
		if (RUNNING_ONLINE_TS())
		{
			// The DirPathChanged flag should be set here, enforce it if not.
			ASSERT( m_bDirPathChanged );
			if (!m_bDirPathChanged)
				m_bDirPathChanged= true;
		}

		// Wait for an explicit wakeup.
		hList[eHev] = m_hevMonitorRequested;

		while (true)
		{
			LOCKOBJECT();
			if (m_bShuttingDown)
			{
				UNLOCKOBJECT();
				break;
			}

			if (m_bDirPathChanged)
			{

#ifndef LOCAL_TROUBLESHOOTER
				// Set the directory to be monitored.
				if (hList[eDirChange] != INVALID_HANDLE_VALUE) 
					::FindCloseChangeNotification( hList[eDirChange] );
				while (true)
				{
					// handle to monitor for change in the resource directory
					hList[eDirChange] = ::FindFirstChangeNotification(m_strDirPath, 
													TRUE,	// monitor subdirectories (for multilingual)
													FILE_NOTIFY_CHANGE_LAST_WRITE 
												    );

					if (hList[eDirChange] == INVALID_HANDLE_VALUE) 
					{
						// resource directoty does not exist. 
						// Track creation of directories in upper directory 
						//  - it might be resource directory
						
						bool bFail = false;
						CString strUpperDir = m_strDirPath; // directory above resource directory (m_strDirPath)

						if (   strUpperDir[strUpperDir.GetLength()-1] == _T('\\')
						    || strUpperDir[strUpperDir.GetLength()-1] == _T('/'))
						{
							strUpperDir = strUpperDir.Left(strUpperDir.GetLength() ? strUpperDir.GetLength()-1 : 0);
						}

						int slash_last = max(strUpperDir.ReverseFind(_T('\\')), 
							                 strUpperDir.ReverseFind(_T('/')));
						
						if (-1 != slash_last)
						{
							strUpperDir = strUpperDir.Left(slash_last);

							hList[eDirChange] = ::FindFirstChangeNotification(strUpperDir, 
															TRUE,	// monitor subdirectories (for multilingual)
															FILE_NOTIFY_CHANGE_DIR_NAME
															);
							if (hList[eDirChange] == INVALID_HANDLE_VALUE) 
								bFail = true;
						}
						else
							bFail = true;
						
						if (!bFail)
						{
							// We have a valid handle, exit this loop.
							SetThreadStatus(eRun);
							break;
						}
						else
						{
							// typically would mean none of resource directory or its upper 
							//  directory is valid, log this.
							CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
							CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
													SrcLoc.GetSrcFileLineStr(), 
													m_strDirPath, _T(""), 
													EV_GTS_ERROR_CANT_FILE_NOTIFY ); 

							SetThreadStatus(eWaitDirPath);

							// Block this thread until notification that the directory path 
							// has been correctly set.  Unlock the object so that the event
							// can be set.
							UNLOCKOBJECT();
							::WaitForSingleObject( m_hevMonitorRequested, INFINITE);
							LOCKOBJECT();
						}
					}
					else
					{
						// We have a valid handle, exit this loop.
						SetThreadStatus(eRun);
						break;
					}
				}
#endif
				m_bDirPathChanged = false;
				if (m_pTrackLst)
					delete m_pTrackLst;
				m_pTrackLst = new CFileTracker;
			
				if (RUNNING_ONLINE_TS())
					m_pTrackLst->AddFile(m_strLstPath);
				
				if (m_pTrackErrorTemplate)
					delete m_pTrackErrorTemplate;
				m_pTrackErrorTemplate = new CFileTracker;

				if (RUNNING_ONLINE_TS())
					m_pTrackErrorTemplate->AddFile(m_strErrorTemplatePath);

				UNLOCKOBJECT();
				ReadErrorTemplate();
				LstFileDrivesTopics();
			}
			else
			{
				UNLOCKOBJECT();

				if (m_pTrackLst && m_pTrackLst->Changed())
					LstFileDrivesTopics();

				if (m_pTrackErrorTemplate && m_pTrackErrorTemplate->Changed( false ))
					ReadErrorTemplate();
			}

			LOCKOBJECT();
			for (vector<CTopicFileTracker>::iterator itTopicFiles = m_arrTrackTopic.begin();
				itTopicFiles != m_arrTrackTopic.end();
				itTopicFiles ++
			)
			{
#ifdef LOCAL_TROUBLESHOOTER
				if (m_bDirPathChanged)
#else
				if (itTopicFiles->Changed())
#endif
					m_TopicShop.BuildTopic(itTopicFiles->GetTopicInfo().GetNetworkName());
				if (m_bShuttingDown)
					break;
			}

			if (RUNNING_ONLINE_TS())
			{
				// Check if any of the alternate template files need to be reloaded.
				for (vector<CTemplateFileTracker>::iterator itTemplateFiles = m_arrTrackTemplate.begin();
					itTemplateFiles != m_arrTrackTemplate.end();
					itTemplateFiles ++
				)
				{
					if (itTemplateFiles->Changed())
						m_TopicShop.BuildTemplate( itTemplateFiles->GetTemplateName() );
					if (m_bShuttingDown)
						break;
				}
			}

			::ResetEvent(m_hevMonitorRequested);

			SetThreadStatus(eWaitChange);
			UNLOCKOBJECT();

			DWORD dwNotifyObj = WaitForMultipleObjects (
				eNumHandles,
				hList,
				FALSE,			// only need one object, not all
				INFINITE);

			SetThreadStatus(eBeforeWaitChange);

			// Ideally we would update files here.
			// Unfortunately, we get a notification that someone has _started_ 
			//	writing to a file, not that they've finished, so we have to put in
			//	an artificial delay.
			// We must let the system "settle down".
			while (
#ifndef LOCAL_TROUBLESHOOTER
				   dwNotifyObj == WAIT_OBJECT_0+eDirChange &&
#endif
				   !m_bShuttingDown)
			{
#ifndef LOCAL_TROUBLESHOOTER
				// wait for the next change
				if (FindNextChangeNotification( hList[eDirChange] ) == FALSE) 
				{
					// 1) we don't believe this will ever occur
					// 2) After a moderate amount of research, we have no idea how 
					//	to recover from it if it does occur.
					// SO: unless we ever actually see this, we're not going to waste
					//	more time researching a recovery strategy. Just throw an exception,
					//	effectively terminating this thread.
					throw CGenSysException( __FILE__, __LINE__, m_strDirPath, 
											EV_GTS_ERROR_WAIT_NEXT_NFT );
				}
#endif
				SetThreadStatus(eWaitSettle);

				dwNotifyObj = WaitForMultipleObjects (
					eNumHandles,
					hList,
					FALSE,			// only need one object, not all
					m_secsReloadDelay * 1000);	// convert to milliseconds
			}
			if (dwNotifyObj == WAIT_FAILED)
			{
				// 1) we don't believe this will ever occur
				// 2) After a moderate amount of research, we have no idea how 
				//	to recover from it if it does occur.
				// SO: unless we ever actually see this, we're not going to waste
				//	more time researching a recovery strategy. Just throw an exception,
				//	effectively terminating this thread.
				throw CGenSysException( __FILE__, __LINE__, _T("Unexpected Return State"), 
										EV_GTS_DEBUG );
			}
			SetThreadStatus(eRun);
		}
	}
	catch (CGenSysException& x)
	{
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	x.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								x.GetErrorMsg(), x.GetSystemErrStr(), 
								x.GetErrorCode() ); 
	}
	catch (CGeneralException& x)
	{
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	x.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								x.GetErrorMsg(), _T("General exception"), 
								x.GetErrorCode() ); 
	}
	catch (bad_alloc&)
	{
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								_T(""), _T(""), EV_GTS_CANT_ALLOC ); 
	}
	catch (exception& x)
	{
		// Catch any STL exceptions thrown so that Terminate() is not called.
		CString str;
		CString	ErrStr;
	
		// Attempt to pull any system error code.
		ErrStr.Format( _T("%ld"), ::GetLastError() );

		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								CCharConversion::ConvertACharToString(x.what(), str),
								ErrStr, 
								EV_GTS_GENERIC_PROBLEM ); 
	}
	catch (...)
	{
		// Catch any other exception thrown.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								_T(""), _T(""), 
								EV_GTS_GEN_EXCEPTION );		
	}
#ifndef LOCAL_TROUBLESHOOTER
	if (hList[eDirChange] != INVALID_HANDLE_VALUE) 
		::FindCloseChangeNotification( hList[eDirChange] );
#endif
	SetThreadStatus(eExiting);
}

// For general use (not part of DirectoryMonitorTask thread)
// Typically, first call to this comes _before_ first call to SetResourceDirectory;
// This allows caller to set reload delay before triggering any action on 
//	DirectoryMonitorTask thread.
void CDirectoryMonitor::SetReloadDelay(DWORD secsReloadDelay)
{
	LOCKOBJECT();
	m_secsReloadDelay = secsReloadDelay;
	UNLOCKOBJECT();
}

// For general use (not part of DirectoryMonitorTask thread)
// Allows indicating that the resource directory has changed
// Until this is called, the DirectoryMonitorTask thread really won't do anything
void CDirectoryMonitor::SetResourceDirectory(const CString & strDirPath)
{
	LOCKOBJECT();
	if (strDirPath != m_strDirPath)
	{
		m_strDirPath = strDirPath;
		m_strLstPath = strDirPath + LSTFILENAME;
		m_strErrorTemplatePath = strDirPath + k_strErrorTemplateFileName;
		m_bDirPathChanged = true;
		::SetEvent(m_hevMonitorRequested);
	}
	UNLOCKOBJECT();
}

// Must be called on DirectoryMonitorTask thread.  
void CDirectoryMonitor::AckShutDown()
{
	LOCKOBJECT();
	::SetEvent(m_hevThreadIsShut);
	UNLOCKOBJECT();
}

//  Main routine of a thread responsible for monitoring the directory.
//	INPUT lpParams
//	Always returns 0.
/* static */ UINT WINAPI CDirectoryMonitor::DirectoryMonitorTask(LPVOID lpParams)
{
	reinterpret_cast<CDirectoryMonitor*>(lpParams)->Monitor();
	reinterpret_cast<CDirectoryMonitor*>(lpParams)->AckShutDown();
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\event.cpp ===
//
// MODULE: Event.cpp
//
// PURPOSE: Fully implements class CEvent: Event Logging
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Roman Mach
// 
// ORIGINAL DATE: 8-2-96
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		9/18/98		JM		Abstracted as a class.  Previously, global.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "Event.h"

bool CEvent::s_bUseEventLog = false;// Online Troubleshooter, will promptly set this 
									//	true in DLLMain.  For Local Troubleshooter,
									//	we leave this false.
bool CEvent::s_bLogAll = true;		// can be changed by RegistryMonitor
CAbstractCounter * const CEvent::s_pcountErrors = &(g_ApgtsCounters.m_LoggedErrors);

inline WORD evtype(DWORD e) {return (1 << (3 - ((e >> 30))));}
inline WORD evcode(DWORD e) {return (WORD)(e & 0xFFFF);}


/*static*/ void CEvent::SetUseEventLog(bool bUseEventLog)
{
	s_bUseEventLog = bUseEventLog;
}

// ReportWFEvent (Based on Microsoft code)
//
// report an event to the NT event watcher
// pass 1, 2 or 3 strings
//
// no return value
// NOTE: inefficient: could RegisterEventSource in DLLMain code for DLL_PROCESS_ATTACH
//	& unregister in DLL_PROCESS_DETACH.  Then could use handle as a global.
/* static */ void CEvent::ReportWFEvent(
			LPCTSTR string1,	// if there is a throw, this is throw file & line
								// otherwise, file and line where ReportWFEvent is called
			LPCTSTR string2,	// always file and line where ReportWFEvent is called
			LPCTSTR string3,	// use may differ for different log entries
			LPCTSTR string4,	// use may differ for different log entries
			DWORD eventID) 
{
	if (!s_bUseEventLog)
		return;

	HANDLE hEvent;
	LPCTSTR pszaStrings[4];
	WORD cStrings;

	WORD type = evtype(eventID);
	WORD code = evcode(eventID);

	if (s_bLogAll 
	|| type == EVENTLOG_ERROR_TYPE
	|| type == EVENTLOG_WARNING_TYPE
	|| code == EV_GTS_PROCESS_START
	|| code == EV_GTS_PROCESS_STOP)
	{
		cStrings = 0;
		if ((pszaStrings[0] = string1) && (string1[0])) 
			cStrings = 1;
		if ((pszaStrings[1] = string2) && (string2[0])) 
			cStrings = 2;
		if ((pszaStrings[2] = string3) && (string3[0])) 
			cStrings = 3;
		if ((pszaStrings[3] = string4) && (string4[0])) 
			cStrings = 4;
		if (cStrings == 0)
			return;
		
		hEvent = ::RegisterEventSource(
						NULL,		// server name for source (NULL means this computer)
						REG_EVT_ITEM_STR);		// source name for registered handle  
		if (hEvent) 
		{
			::ReportEvent(hEvent,				// handle returned by RegisterEventSource 
						type,					// event type to log 
						0,						// event category 
						eventID,				// event identifier 
						0,						// user security identifier (optional) 
						cStrings,				// number of strings to merge with message  
						0,						// size of binary data, in bytes
						(LPCTSTR *)pszaStrings,	// array of strings to merge with message 
						NULL);		 			// address of binary data 
			::DeregisterEventSource(hEvent);
		}
		if (evtype(eventID) == EVENTLOG_ERROR_TYPE)
			s_pcountErrors->Increment();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\filechange.cpp ===
// FileChange.cpp: implementation of the CFileChange class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "FileChange.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CFileChange::CFileChange()
{

}

CFileChange::~CFileChange()
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\filechange.h ===
// FileChange.h: interface for the CFileChange class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_FILECHANGE_H__441362B3_4BE9_11D2_95F5_00C04FC22ADD__INCLUDED_)
#define AFX_FILECHANGE_H__441362B3_4BE9_11D2_95F5_00C04FC22ADD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CFileChange  
{
public:
	CFileChange();
	virtual ~CFileChange();

};

#endif // !defined(AFX_FILECHANGE_H__441362B3_4BE9_11D2_95F5_00C04FC22ADD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\dirmonitor.h ===
//
// MODULE: DirMonitor.h
//
// PURPOSE: Monitor changes to LST, DSC, HTI, BES files.
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 9-17-98
//
// NOTES: 
//	1.  It would be equally appropriate for CDirectoryMonitor to inherit from CTopicShop 
//		instead of having a member of type CDirectoryMonitor.  Really an arbitrary choice.
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		09-17-98	JM
//

#if !defined(AFX_DIRMONITOR_H__493CF34D_4E79_11D2_95F8_00C04FC22ADD__INCLUDED_)
#define AFX_DIRMONITOR_H__493CF34D_4E79_11D2_95F8_00C04FC22ADD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "TopicShop.h"
#include "FileTracker.h"

class CTopicFileTracker: public CFileTracker
{
private:
	CTopicInfo m_topicinfo;
public:
	CTopicFileTracker();
	~CTopicFileTracker();
	void AddTopicInfo(const CTopicInfo & topicinfo);
	const CTopicInfo & GetTopicInfo() const;
};

class CTemplateFileTracker: public CFileTracker
{
private:
	CString m_strTemplateName;
public:
	CTemplateFileTracker();
	~CTemplateFileTracker();
	void AddTemplateName( const CString & strTemplateName );
	const CString& GetTemplateName() const;
};

const CString k_strErrorTemplateFileName = _T("ErrorTemplate.hti");
const CString k_strDefaultErrorTemplateBefore = 
	_T("<HTML><HEAD><TITLE>AP GTS Error</TITLE></HEAD>")
	_T("<BODY BGCOLOR=#FFFFFF><H1>AP GTS reports an Error</H1>");
const CString k_strErrorTemplateKey =  _T("$Error");
const CString k_strDefaultErrorTemplateAfter = _T("</BODY></HTML>");

class CDirectoryMonitor : public CStateless
{
public:
	enum ThreadStatus{eBeforeInit, eFail, eWaitDirPath, eWaitChange, eWaitSettle, 
		eRun, eBeforeWaitChange, eExiting};
	static CString ThreadStatusText(ThreadStatus ts);
private:
	CTopicShop & m_TopicShop;				
	CSimpleTemplate * m_pErrorTemplate;		// template for reporting error messages (regardless
											//	of topic)
	CString m_strDirPath;					// Directory to monitor
	bool m_bDirPathChanged;
	CString m_strLstPath;					// LST file (always in directory m_strDirPath)
	CString m_strErrorTemplatePath;			// Error template file (always in directory m_strDirPath)
	CFileTracker * m_pTrackLst;				
	CFileTracker * m_pTrackErrorTemplate;				
	vector<CTopicFileTracker> m_arrTrackTopic;
	vector<CTemplateFileTracker> m_arrTrackTemplate;
	CAPGTSLSTReader * m_pLst;				// current LST file contents
	HANDLE m_hThread;
	HANDLE m_hevMonitorRequested;			// event to wake up DirectoryMonitorTask
											// this allows it to be wakened other than
											// by the directory change event.  Currently used
											// for shutdown or change of directory.
	HANDLE m_hevThreadIsShut;				// event just to indicate exit of DirectoryMonitorTask thread
	bool m_bShuttingDown;					// lets topic directory monitor thread know we're shutting down
	DWORD m_secsReloadDelay;				// number of second to let directory "settle down"
											// before we start to update topics.
	DWORD m_dwErr;							// status from starting the thread
	ThreadStatus m_ThreadStatus;
	time_t m_time;							// time last changed ThreadStatus.  Initialized
											// to zero ==> unknown
	CString m_strTopicName;					// This string is ignored in the Online Troubleshooter.
											// Done under the guise of binary compatibility.

public:
	CDirectoryMonitor(CTopicShop & TopicShop, const CString& strTopicName );	// strTopicName is ignored in the Online Troubleshooter.
																				// Done under the guise of binary compatibility.
	~CDirectoryMonitor();
	void SetReloadDelay(DWORD secsReloadDelay);
	void SetResourceDirectory(const CString & strDirPath);
	void CreateErrorPage(const CString & strError, CString& out) const;
	DWORD GetStatus(ThreadStatus &ts, DWORD & seconds) const;
	void AddTemplateToTrack( const CString& strTemplateName );
private:
	CDirectoryMonitor();		// do not instantiate

	void SetThreadStatus(ThreadStatus ts);

	// just for use by own destructor
	void ShutDown();

	// functions for use by the DirectoryMonitorTask thread.
	void Monitor();
	void LstFileDrivesTopics();
	void ReadErrorTemplate();
	void AckShutDown();

	// main function of the DirectoryMonitorTask thread.
	static UINT WINAPI DirectoryMonitorTask(LPVOID lpParams);
};

#endif // !defined(AFX_DIRMONITOR_H__493CF34D_4E79_11D2_95F8_00C04FC22ADD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\fileread.cpp ===
//
// MODULE: FILEREAD.CPP
//
// PURPOSE: file reading classes
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 7-29-98
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		08-04-98	OK
//

#include "stdafx.h"
#include <algorithm>
#include "fileread.h"
#include "event.h"
#include "CharConv.h"
#include "apgtsassert.h"
#ifdef LOCAL_TROUBLESHOOTER
#include "CHMFileReader.h"
#endif

#define STR_ALLOC_SIZE  1024
#define FORWARD_SLASH	_T('/')
#define BACK_SLASH      _T('\\')


////////////////////////////////////////////////////////////////////////////////////
// CFileReaderException
////////////////////////////////////////////////////////////////////////////////////
// source_file is LPCSTR rather than LPCTSTR because __FILE__ is char[35]
CFileReaderException::CFileReaderException(CPhysicalFileReader* reader, eErr err, LPCSTR source_file, int line)
					: CBaseException(source_file, line),
					  m_pFileReader(reader),
					  m_eErr(err)
{
}

CFileReaderException::CFileReaderException(CFileReader* reader, eErr err, LPCSTR source_file, int line)
					: CBaseException(source_file, line),
					  m_pFileReader(reader->GetPhysicalFileReader()),
					  m_eErr(err)
{
}


CFileReaderException::~CFileReaderException()
{
}

void CFileReaderException::CloseFile()
{
	if (m_eErr == eErrClose || m_eErr == eErrGetSize || m_eErr == eErrRead || m_eErr == eErrAllocateToRead)
	   m_pFileReader->CloseHandle();
}

void CFileReaderException::LogEvent() const
{
	CBuildSrcFileLinenoStr CatchLoc( __FILE__, __LINE__ );
	CString	strErr;

	// Format the error code as a string.
	switch (m_eErr)
	{
		case eErrOpen: 
				strErr= _T("Open"); 
				break;
		case eErrClose: 
				strErr= _T("Close"); 
				break;
		case eErrRead: 
				strErr= _T("Read"); 
				break;
		case eErrAllocateToRead: 
				strErr= _T("ReadAllocate"); 
				break;
		case eErrGetSize: 
				strErr= _T("GetSize"); 
				break;
		case eErrGetDateTime: 
				strErr= _T("GetDateTime"); 
				break;
		case eErrParse: 
				strErr= _T("Parse"); 
				break;
		default:
				strErr.Format( _T("Error code of %d"), m_eErr );
	}

	CEvent::ReportWFEvent(	GetSrcFileLineStr(), 
							CatchLoc.GetSrcFileLineStr(), 
							strErr, 
							m_pFileReader->GetNameToLog(), 
							EV_GTS_FILEREADER_ERROR );
}

////////////////////////////////////////////////////////////////////////////////////
// CAbstractFileReader
// This class manages a file, which is initially read into a memory buffer, then
//	copied into a stream.
// It must be further specialized to handle a file from ordinary disk storage vs. a 
//	file from a CHM
////////////////////////////////////////////////////////////////////////////////////
// we return just pure path, without <name>.<ext> and without slashes in the tail
/*static*/ CString CAbstractFileReader::GetJustPath(const CString& full_path)
{
	CString tmp = full_path;

	tmp.TrimLeft();
	tmp.TrimRight();

	int indexOfSlash = tmp.ReverseFind(BACK_SLASH);

	if (indexOfSlash == -1)
		indexOfSlash = tmp.ReverseFind(FORWARD_SLASH);

	if (indexOfSlash == -1)
		// Unable to locate the path, return an empty string.
		return _T(""); 
	else
		return tmp.Left(indexOfSlash);
}

// we return just <name>.<ext> without any path information.  If there's no slash and no dot
//	anywhere, we presume this is not a file name.
/*static*/ CString CAbstractFileReader::GetJustName(const CString& full_path)
{
	CString tmp = full_path;
	LPTSTR ptr = NULL;

	tmp.TrimLeft();
	tmp.TrimRight();

	int indexOfSlash = tmp.ReverseFind(BACK_SLASH);

	if (indexOfSlash == -1)
		indexOfSlash = tmp.ReverseFind(FORWARD_SLASH);

	if (indexOfSlash == -1)
	{
		if (tmp.Find("."))
			return tmp; // full_path is a file name
		else
			// Unable to detect a file name, return an empty string.
			return _T(""); 
	}
	else
		return tmp.Mid(indexOfSlash + 1);
}

/*static*/ CString CAbstractFileReader::GetJustNameWithoutExtension(const CString& full_path)
{
	CString tmp = GetJustName(full_path);
	int point = tmp.Find(_T('.'));

	if (-1 != point)
		return tmp.Left(point);
	return tmp;
}

/*static*/ CString CAbstractFileReader::GetJustExtension(const CString& full_path)
{
	CString tmp = GetJustName(full_path);
	int point = tmp.Find(_T('.'));

	if (-1 != point)
		return tmp.Right(tmp.GetLength() - point - 1);
	return _T("");
}

/*static*/ bool CAbstractFileReader::GetFileTime(const CString& full_path, EFileTime type, time_t& out)
{
	WIN32_FIND_DATA find_data;
	FILETIME fileTime, localTime;
    SYSTEMTIME sysTime;
    struct tm atm;
	HANDLE hLocFile;
	bool bRet= false;
	
	hLocFile= ::FindFirstFile(full_path, &find_data);
	if (INVALID_HANDLE_VALUE == hLocFile)
		return( bRet );

	if (type == eFileTimeCreated)
		fileTime = find_data.ftCreationTime;
	if (type == eFileTimeModified)
		fileTime = find_data.ftLastWriteTime;
	if (type == eFileTimeAccessed)
		fileTime = find_data.ftLastAccessTime;

    // first convert file time (UTC time) to local time
    if (::FileTimeToLocalFileTime(&fileTime, &localTime)) 
	{
	    // then convert that time to system time
		if (::FileTimeToSystemTime(&localTime, &sysTime))
		{
			if (!(sysTime.wYear < 1900))
			{
				atm.tm_sec = sysTime.wSecond;
				atm.tm_min = sysTime.wMinute;
				atm.tm_hour = sysTime.wHour;
				ASSERT(sysTime.wDay >= 1 && sysTime.wDay <= 31);
				atm.tm_mday = sysTime.wDay;
				ASSERT(sysTime.wMonth >= 1 && sysTime.wMonth <= 12);
				atm.tm_mon = sysTime.wMonth - 1; // tm_mon is 0 based
				ASSERT(sysTime.wYear >= 1900);
				atm.tm_year = sysTime.wYear - 1900; // tm_year is 1900 based
				atm.tm_isdst = -1; // automatic computation of daylight saving time
				out = mktime(&atm);
				bRet= true;
			}
		}
	}

	::FindClose( hLocFile );

	return( bRet );
}

CAbstractFileReader::CAbstractFileReader()
		   : CStateless(),
			 m_bIsValid(true),
			 m_bIsRead(false)
{
}

CAbstractFileReader::~CAbstractFileReader()
{
}

// returns true if the referenced file can be opened and closed.  
// No problem if the file is already open: it is opened with FILE_SHARE_READ access.
bool CAbstractFileReader::Exists()
{
	bool bRet= false;

	try 
	{
		LOCKOBJECT();
		Open();
		Close();
		bRet= true;
	}
	catch (CFileReaderException& exc) 
	{
		exc.CloseFile();
		exc.LogEvent();
	}
	catch (...)
	{
		// Catch any other exception thrown.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								_T(""), _T(""), 
								EV_GTS_GEN_EXCEPTION );		
	}
	UNLOCKOBJECT();

	return( bRet );
}

// go back to the file itself for data.
bool CAbstractFileReader::Read()
{
	LPTSTR pBuf= NULL;		 // if non-null, points to an allocated buffer containing
							 // an in-memory copy of this file.
	try 
	{
		LOCKOBJECT();
		Open();
		ReadData(&pBuf);
		Close();
		StreamData(&pBuf);
		Parse(); // if this parsing is OK, the parsing in all siblings is presumed to be OK
		m_bIsRead = true;
		m_bIsValid = true;
	}
	catch (CFileReaderException& exc) 
	{
		exc.CloseFile();
		m_bIsValid = false;
		try 
		{
			if (UseDefault())
			{
				Parse(); // if this parsing is OK, the parsing in all siblings is presumed to be OK
				m_bIsRead = true;		// OK, so  maybe we're lying.  Close enough to true.
				m_bIsValid = true;
			}
		}
		catch (CFileReaderException&) 
		{
			// Catch any potential exceptions from attempt to access default content.
			// This exception would be logged below so there is no need to log it here.
		}

		if (!m_bIsValid)
		{
			// Only log the event if the attempt to access default content failed.
			exc.LogEvent();
		}
	}
	catch (bad_alloc&)
	{
		// Memory allocation failure.
		m_bIsValid = false;
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								_T(""), _T(""), EV_GTS_CANT_ALLOC ); 
	}
	catch (...)
	{
		// Catch any other exception thrown.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								_T(""), _T(""), 
								EV_GTS_GEN_EXCEPTION );		
	}

	if (pBuf)
		delete [] pBuf;

	// Given the array of catch blocks above, it is assumed that this call to unlock the
	//	object will always been called prior to exiting this function.
	UNLOCKOBJECT();

	return m_bIsValid;
}

////////////////////////////////////////////////////////////////////////////////////
// CPhysicalFileReader
////////////////////////////////////////////////////////////////////////////////////
CPhysicalFileReader::CPhysicalFileReader()
{
}

CPhysicalFileReader::~CPhysicalFileReader()
{
}

/*static*/ CPhysicalFileReader * CPhysicalFileReader::makeReader( const CString& strFileName )
{
#ifdef LOCAL_TROUBLESHOOTER
	if (CCHMFileReader::IsCHMfile( strFileName ))
		return dynamic_cast<CPhysicalFileReader*>(new CCHMFileReader( strFileName ));
	else
#endif
		return dynamic_cast<CPhysicalFileReader*>(new CNormalFileReader( strFileName ));
}

////////////////////////////////////////////////////////////////////////////////////
// CNormalFileReader
// This class manages a file from ordinary storage.
// Do not use this for files within a CHM
////////////////////////////////////////////////////////////////////////////////////
CNormalFileReader::CNormalFileReader(LPCTSTR path)
		   : m_strPath(path),
			 m_hFile(NULL)
{
}

CNormalFileReader::~CNormalFileReader()
{
}

/* virtual */ void CNormalFileReader::Open()
{
	if (INVALID_HANDLE_VALUE == 
		(m_hFile = ::CreateFile( m_strPath, 
							 GENERIC_READ, 
							 FILE_SHARE_READ, 
							 NULL,
							 OPEN_EXISTING,
							 FILE_ATTRIBUTE_NORMAL,
							 NULL )) )
	{
#ifdef _DEBUG
		DWORD err = GetLastError();
#endif
		throw CFileReaderException( this, CFileReaderException::eErrOpen, __FILE__, __LINE__ );
	}
}

// returns true on success
// doesn't throw exception, therefore may be used by exception class.
/* virtual */ bool CNormalFileReader::CloseHandle()
{
	// if it's not open, say we closed successfully.
	if (!m_hFile)
		return true;

	return ::CloseHandle(m_hFile) ? true : false;
}


/* virtual */ void CNormalFileReader::ReadData(LPTSTR * ppBuf)
{
	DWORD dwSize =0, dwRead =0;

	if (*ppBuf) 
	{
		delete [] *ppBuf;
		*ppBuf = NULL;
	}

	if (0xFFFFFFFF == (dwSize = ::GetFileSize(m_hFile, NULL)))
	{
		throw CFileReaderException(this, CFileReaderException::eErrOpen, __FILE__, __LINE__);
	}

	// Handle this memory allocation like all others in the program.
	try
	{
		*ppBuf = new TCHAR[dwSize+1];
		//[BC-03022001] - addd check for NULL ptr to satisfy MS code analysis tool.
		if(!*ppBuf)
			throw bad_alloc();
	}
	catch (bad_alloc&)
	{
		throw CFileReaderException(this, CFileReaderException::eErrAllocateToRead, __FILE__, __LINE__);
	}

	if (!::ReadFile(m_hFile, *ppBuf, dwSize, &dwRead, NULL) || dwSize != dwRead)
	{
		throw CFileReaderException(this, CFileReaderException::eErrRead, __FILE__, __LINE__);
	}
		
	(*ppBuf)[dwSize] = 0;
}

CString CNormalFileReader::GetJustPath() const
{
	return CAbstractFileReader::GetJustPath(m_strPath);
}

CString CNormalFileReader::GetJustName() const
{
	return CAbstractFileReader::GetJustName(m_strPath);
}

CString CNormalFileReader::GetJustNameWithoutExtension() const
{
	return CAbstractFileReader::GetJustNameWithoutExtension(m_strPath);
}

CString CNormalFileReader::GetJustExtension() const
{
	return CAbstractFileReader::GetJustExtension(m_strPath);
}

bool CNormalFileReader::GetFileTime(CAbstractFileReader::EFileTime type, time_t& out) const
{
	return CAbstractFileReader::GetFileTime(m_strPath, type, out);
}

// name to log on exceptions.  This implementation will be correct for the normal file system,
//	but may need to be overridden for CHM.
CString CNormalFileReader::GetNameToLog() const
{
	return GetPathName();
}

////////////////////////////////////////////////////////////////////////////////////
// CFileReader
// This class manages a file, which is initially read into a memory buffer, then
//	copied into a stream.
////////////////////////////////////////////////////////////////////////////////////

CFileReader::CFileReader(CPhysicalFileReader * pPhysicalFileReader, bool bDeletePhysicalFileReader /*=true*/)
		   : CAbstractFileReader(),
			 m_pPhysicalFileReader(pPhysicalFileReader),
			 m_bDeletePhysicalFileReader(bDeletePhysicalFileReader)
{
}

CFileReader::~CFileReader()
{
	if (m_pPhysicalFileReader)
		if (m_bDeletePhysicalFileReader)
			delete m_pPhysicalFileReader;
}

// move the data out of ppBuf (which will be deleted) to m_StreamData
/* virtual */ void CFileReader::StreamData(LPTSTR * ppBuf)
{
	m_StreamData.str(*ppBuf);
	delete [] (*ppBuf);
	*ppBuf = NULL;
}

// Placeholder.  Classes that inherit from CFileReader can define parsing to happen
//	immediately after the file is read.
/* virtual */ void CFileReader::Parse()
{
	// we have no idea how to parse here
}

// Placeholder.  Classes that inherit from CFileReader can define default file contents
//	to use if file can't be read or what is read can't be parsed.
// Should return true if there's a default to use.
/* virtual */ bool CFileReader::UseDefault()
{
	// we have no default to use here
	return false;
}

void CFileReader::Close()
{
	if (!m_pPhysicalFileReader->CloseHandle())
		throw CFileReaderException(m_pPhysicalFileReader, CFileReaderException::eErrClose, __FILE__, __LINE__);
}

// Data access in form of tstring.  returns reference to its argument as a convenience.
tstring& CFileReader::GetContent(tstring& out)
{
	out = m_StreamData.rdbuf()->str();
	return out;
}

// Data access in form of CString.  returns reference to its argument as a convenience.
CString& CFileReader::GetContent(CString& out)
{
	out = m_StreamData.rdbuf()->str().c_str();
	return out;
}

////////////////////////////////////////////////////////////////////////////////////
// CTextFileReader
// Specialize CFileReader to a text file
////////////////////////////////////////////////////////////////////////////////////
/*static*/ bool CTextFileReader::IsAmongSeparators(TCHAR separatorCandidate, const vector<TCHAR>& separator_arr)
{
	vector<TCHAR>::const_iterator res = find(separator_arr.begin(), separator_arr.end(), separatorCandidate);
	return res != separator_arr.end();
}

// OUTPUT out is a vector of "words"
// NOTE: words are strings that do not contain whitespaces
/*static*/ void CTextFileReader::GetWords(const CString& text, vector<CString>& out, const vector<TCHAR>& separator_arr)
{
	LPTSTR begin =(LPTSTR)(LPCTSTR)text, end =(LPTSTR)(LPCTSTR)text;

	while (*begin)
	{
		if (!IsAmongSeparators(*begin, separator_arr))
		{
			end = begin;
			while (*end &&
				   !IsAmongSeparators(*end, separator_arr)
				  )
				end++;
			if (end != begin)
			{
				try
				{
					TCHAR* buf= new TCHAR[end-begin+1]; 
					//[BC-03022001] - added check for NULL ptr to satisfy MS code analysis tool.
					if(buf)
					{
						_tcsncpy(buf, begin, end-begin);
						buf[end-begin] = 0;
						out.push_back(buf);
						delete [] buf;
					}
					else
					{
						throw bad_alloc();
					}
				}
				catch (bad_alloc&)
				{
					// Memory allocation failure, log it and rethrow exception.
					CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
					CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
											SrcLoc.GetSrcFileLineStr(), 
											_T(""), _T(""), EV_GTS_CANT_ALLOC ); 
					throw;
				}
				catch (exception& x)
				{
					CString str;
					// Note STL exception in event log and rethrow exception.
					CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
					CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
											SrcLoc.GetSrcFileLineStr(), 
											CCharConversion::ConvertACharToString(x.what(), str), 
											_T(""), 
											EV_GTS_STL_EXCEPTION ); 
					throw;
				}
			}
			if (!*end)
				end--;
			begin = end;

		}
		begin++;
	}
}

/*static*/ long CTextFileReader::GetPos(tistream& streamData)
{
	return streamData.tellg();
}

/*static*/ bool CTextFileReader::SetPos(tistream& streamData, long pos)
{
	long eof_pos = 0;
	long old_pos = streamData.tellg();
	bool eof_state = streamData.eof();

	streamData.seekg(0, ios_base::end);
	eof_pos = streamData.tellg();

	if (pos <= eof_pos)
	{
		if (eof_state)
			streamData.clear(~ios_base::eofbit & streamData.rdstate()); // clear eof bit
		streamData.seekg(pos);
		return true;
	}
	else
	{
		streamData.seekg(old_pos);
		return false;
	}
}

// It get line of text from current position in stream until '\r' or EOF - into "str"
//  Stream is positioned to the beginning of next line or to EOF.
/*static*/ bool CTextFileReader::GetLine(tistream& streamData, CString& str)
{
	bool	bRetVal= false;
	TCHAR	buf[ STR_ALLOC_SIZE ];
	
	str= _T("");
	while (!streamData.eof())
	{
		buf[STR_ALLOC_SIZE-1] = 1; // will be NULL if buffer is completely filled up

		{	// start getline block
			long before_getline_pos = GetPos(streamData);

			streamData.getline(buf, STR_ALLOC_SIZE, _T('\r'));

			if (streamData.fail()) 
			{   // getline ran into empty line, and at this point
				//  failbit is set, and current input pointer is set to -1
				//  we are trying to recover this, since there is nothing 
				//  extraodinary to have line empty
				streamData.clear(~ios_base::failbit & streamData.rdstate());

				// Check if buffer was filled up completely.  If so, we do not want
				//	to reposition the file pointer as this is a completely valid 
				//	situation.  We will output this piece of the line and then will
				//	grab the next piece of the line only appending a newline character 
				//	once we have read in the entire line.
				if (buf[STR_ALLOC_SIZE-1] != NULL ) // buf was not filled up completely
					streamData.seekg(before_getline_pos); // we do not use SetPos, since SetPos
													  //  might clear eofbit, but in this situation
													  //  we do not want it.
			}
		}	// end getline block

		if (streamData.eof())
		{
			str += buf;
			bRetVal= true;
			break;
		}
		else 
		{	
			TCHAR element = 0;

			str += buf;

			if (streamData.peek() == _T('\n')) 
			{	// LINE FEED is next
				streamData.get(element); // just extract it from stream
				if (ios_base::eofbit & streamData.rdstate())
				{
					bRetVal= true;
					break;
				}
			}
			else
			{   // it was a standing along '\r'...
				// Check if we have a full buffer, if so do not append a newline 
				//	character as we need to grab the rest of the line before appending
				//	the newline character.
				if (buf[STR_ALLOC_SIZE-1] != NULL ) // buf was not filled up completely
					str += _T("\n");
				continue;
			}

			if (buf[STR_ALLOC_SIZE-1] != NULL ) // buf was not filled up completely
			{
				bRetVal= true;
				break;
			}
		}	
	}

	return( bRetVal );
}

// This function finds string in the stream and positions stream to the beginning 
//  of the string if found.
//  "str" should not include '\r''\n' pairs
/*static*/ bool CTextFileReader::Find(tistream& streamData, const CString& str, bool from_stream_begin /*=true*/)
{
	CString buf;
	long savePos = 0, currPos = 0;
	
	savePos = GetPos(streamData);
	if (from_stream_begin)
		SetPos(streamData, 0);

	currPos = GetPos(streamData);
	while (GetLine(streamData, buf))
	{
		long inside_pos = 0;
		if (-1 != (inside_pos = buf.Find(str)))
		{
			SetPos(streamData, currPos + inside_pos);
			return true;
		}
		currPos = GetPos(streamData);
	}
	SetPos(streamData, savePos);
	return false;
}

/*static*/ bool CTextFileReader::NextLine(tistream& streamData)
{
	CString str;
	return GetLine(streamData, str);
}

/*static*/ bool CTextFileReader::PrevLine(tistream& streamData)
{
	long savePos = 0;
	
	savePos = GetPos(streamData);
	SetAtLineBegin(streamData);
	if (GetPos(streamData) > 1)
	{
		SetPos(streamData, GetPos(streamData) - 2L); // skip '\n' and '\r'
		SetAtLineBegin(streamData);
		return true;
	}
	SetPos(streamData, savePos);
	return false;
}

// Positions stream to the beginning of current line.
//  assume that we are NEVER positioned to point to '\n' or '\r'
/*static*/ void CTextFileReader::SetAtLineBegin(tistream& streamData)
{
	while (GetPos(streamData))
	{
		SetPos(streamData, GetPos(streamData) - 1L);
		if (streamData.peek() == _T('\n'))
		{
			if (GetPos(streamData))
			{
				SetPos(streamData, GetPos(streamData) - 1L);
				if (streamData.peek() == _T('\r'))
				{
					SetPos(streamData, GetPos(streamData) + 2L);
					return;
				}
			}
		}
	}
}

CTextFileReader::CTextFileReader(CPhysicalFileReader *pPhysicalFileReader, LPCTSTR szDefaultContents /* = NULL */, bool bDeletePhysicalFileReader /*=true*/ )
			   : CFileReader(pPhysicalFileReader, bDeletePhysicalFileReader),
				 m_strDefaultContents(szDefaultContents ? szDefaultContents : _T(""))
{
}

CTextFileReader::~CTextFileReader()
{
}

long CTextFileReader::GetPos()
{
	return GetPos(m_StreamData);
}

// this function is to be used instead of seekg
//  it clears eof flag if "pos" is not the last
//  position in the file.
bool CTextFileReader::SetPos(long pos)
{
	return SetPos(m_StreamData, pos);
}

bool CTextFileReader::GetLine(CString& str)
{
	return GetLine(m_StreamData, str);
}

bool CTextFileReader::Find(const CString& str, bool from_stream_begin /*=true*/)
{
	return Find(m_StreamData, str, from_stream_begin);
}

void CTextFileReader::SetAtLineBegin()
{
	SetAtLineBegin(m_StreamData);
}

bool CTextFileReader::NextLine()
{
	return NextLine(m_StreamData);
}

bool CTextFileReader::PrevLine()
{
	return PrevLine(m_StreamData);
}

bool CTextFileReader::UseDefault()
{
	if ( ! m_strDefaultContents.IsEmpty() )
	{
		m_StreamData.str((LPCTSTR)m_strDefaultContents);
		return true;
	}
	return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\fileread.h ===
//
// MODULE: FILEREAD.H
//
// PURPOSE: file reading classes
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 7-29-98
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		08-04-98	OK
// V3.1		01-08-99	JM		improving abstraction so CHMs can be worked into this.
//

#ifndef __FILEREAD_H_
#define __FILEREAD_H_

#include "BaseException.h"
#include "stateless.h"
#include <sstream>
#include <vector>

using namespace std;

namespace std {
    typedef basic_string<TCHAR> tstring;    
    typedef basic_stringbuf<TCHAR> tstringbuf;    
    typedef basic_istream<TCHAR> tistream;    
    typedef basic_ostream<TCHAR> tostream;    
    typedef basic_iostream<TCHAR> tiostream;    
    typedef basic_istringstream<TCHAR> tistringstream;    
    typedef basic_ostringstream<TCHAR> tostringstream;    
    typedef basic_stringstream<TCHAR> tstringstream;
};

////////////////////////////////////////////////////////////////////////////////////
// CFileReaderException
////////////////////////////////////////////////////////////////////////////////////
class CPhysicalFileReader;
class CFileReader;
class CFileReaderException : public CBaseException
{
public: 
	enum eErr {eErrOpen, 
			   eErrClose, 
			   eErrRead, 
			   eErrAllocateToRead,
			   eErrGetSize,
			   eErrGetDateTime,
			   eErrParse
	} m_eErr;

protected:
	CPhysicalFileReader* m_pFileReader;

public:
	// source_file is LPCSTR rather than LPCTSTR because __FILE__ is char[35]
	CFileReaderException(CPhysicalFileReader* reader, eErr err, LPCSTR source_file, int line);
	CFileReaderException(CFileReader* reader, eErr err, LPCSTR source_file, int line);
	virtual ~CFileReaderException();

public:
	virtual void CloseFile();
	void LogEvent() const;			// Function used to write CFileReader exceptions to the event log.
};

////////////////////////////////////////////////////////////////////////////////////
// CAbstractFileReader
// This abstract class manages a file, which is initially read into a memory buffer, then
//	copied into a stream.
// It can be renewed from stream without reading file.
// It checks file for existance.
// This class is abstract, in that it doesn't consider whether the file is in normal
//	file storage or in a CHM. It must be specialized to handle those two cases.  Since
//	it must be specialized to one or the other, this class should never be directly instantiated.
////////////////////////////////////////////////////////////////////////////////////
class CAbstractFileReader : public CStateless
{
private:
	bool m_bIsValid;			 // file data is consistent - no errors arose during reading and parsing
	bool m_bIsRead;				 // file has been read

public:
	enum EFileTime {eFileTimeCreated, eFileTimeModified, eFileTimeAccessed};

	// static utilities
	static CString GetJustPath(const CString& full_path);
	static CString GetJustName(const CString& full_path);
	static CString GetJustNameWithoutExtension(const CString& full_path);
	static CString GetJustExtension(const CString& full_path);
	static bool GetFileTime(const CString& full_path, EFileTime type, time_t& out);

public:
	CAbstractFileReader();
   ~CAbstractFileReader();

public:
	virtual CString GetPathName() const =0;
	virtual CString GetJustPath() const =0;
	virtual CString GetJustName() const =0;
	virtual CString GetJustNameWithoutExtension() const =0;
	virtual CString GetJustExtension() const =0;
	virtual bool    GetFileTime(EFileTime type, time_t& out) const =0;

public:
	// I (Oleg) designed these functions to be the only way to perform file access.
	//	That is, you cannot call (say) Open or ReadData.
	// The locking is designed accordingly.
	// In inherited classes there might be function to access results
	//  of reading and parsing - in this case user is responsible for properly 
	//  locking the results while they are being used
	// These functions are NOT intended to be virtual and overridden!
	bool Exists();
	bool Read();
	 
	bool    IsRead() {return m_bIsRead;}
	bool    IsValid() {return m_bIsValid;}

protected:
	virtual void Open()=0;
	virtual void ReadData(LPTSTR * ppBuf) =0;
	virtual void StreamData(LPTSTR * ppBuf)=0;
	virtual void Parse()=0;
	virtual bool UseDefault()=0;
	virtual void Close()=0;  // unlike CPhysicalFileReader::Close(), this throws exception if
							 // it cannot close the file
};

////////////////////////////////////////////////////////////////////////////////////
// CPhysicalFileReader
// This is an abstract class.  Classes that provide physical access to a file should inherit 
//	from this class.  
// A pointer to this class can be used by CFileReader to get a physical instantiation of file 
//	access.  The idea is that CPhysicalFileReader will have one descendant 
//	(CNormalFileReader) to access files in normal directories and another 
//	(CCHMFileReader) to access files drawn from a CHM.
// CHMs don't arise in the Online Troubleshooter, but they do in the Local Troubleshooter.
////////////////////////////////////////////////////////////////////////////////////
class CPhysicalFileReader
{
public:
	CPhysicalFileReader();
	virtual ~CPhysicalFileReader();

	static CPhysicalFileReader * makeReader( const CString& strFileName );

protected:
	friend class CFileReader; 
	friend class CFileReaderException;
	//
	// only CFileReader class is meant to access these functions
	virtual void Open()=0;
	virtual void ReadData(LPTSTR * ppBuf) =0;
	virtual bool CloseHandle()=0;    // doesn't throw exception, therefore may be used by exception class.
	//

public:
	virtual CString GetPathName() const =0;
	virtual CString GetJustPath() const =0;
	virtual CString GetJustName() const =0;
	virtual CString GetJustNameWithoutExtension() const =0;
	virtual CString GetJustExtension() const =0;
	virtual bool    GetFileTime(CAbstractFileReader::EFileTime type, time_t& out) const =0;
	virtual CString GetNameToLog() const =0;
};

////////////////////////////////////////////////////////////////////////////////////
// CNormalFileReader
// This class manages a file from ordinary storage.
// Do not use this for files within a CHM
////////////////////////////////////////////////////////////////////////////////////
class CNormalFileReader : public CPhysicalFileReader
{
private:
	CString m_strPath;			 // full path and name
	HANDLE m_hFile;				 // handle corresponding to m_strPath (if open)

public:
	CNormalFileReader(LPCTSTR path);
   ~CNormalFileReader();

protected:
	//
	// only CFileReader class is meant to access these functions
    virtual bool CloseHandle();  // doesn't throw exception, therefore may be used by exception class.
	virtual void Open();
	virtual void ReadData(LPTSTR * ppBuf);
	//

public:
	// return full file path and its components
	CString GetPathName() const {return m_strPath;}
	CString GetJustPath() const;
	CString GetJustName() const;
	CString GetJustNameWithoutExtension() const;
	CString GetJustExtension() const;
	bool    GetFileTime(CAbstractFileReader::EFileTime type, time_t& out) const;
	CString GetNameToLog() const;
};

////////////////////////////////////////////////////////////////////////////////////
// CFileReader
// This class manages a file from ordinary storage, which is initially read into a memory buffer, then
//	copied into a stream.
// It can be renewed from stream without reading file.
// It checks file for existance.
// Do not use this for files within a CHM
////////////////////////////////////////////////////////////////////////////////////
class CFileReader : public CAbstractFileReader
{
private:
	CPhysicalFileReader *m_pPhysicalFileReader;
	bool m_bDeletePhysicalFileReader;

public:
	CFileReader(CPhysicalFileReader * pPhysicalFileReader, bool bDeletePhysicalFileReader =true); 
   ~CFileReader();

public:
	// This function exists only so that CFileReaderException can reinterpret a CFileReader as
	//	a CPhysicalFileReader
	CPhysicalFileReader * GetPhysicalFileReader() {return m_pPhysicalFileReader;}

public:
	// return full file path and its components
	CString GetPathName() const {return m_pPhysicalFileReader->GetPathName();}
	CString GetJustPath() const {return m_pPhysicalFileReader->GetJustPath();}
	CString GetJustName() const {return m_pPhysicalFileReader->GetJustName();}
	CString GetJustNameWithoutExtension() const {return m_pPhysicalFileReader->GetJustNameWithoutExtension();}
	CString GetJustExtension() const {return m_pPhysicalFileReader->GetJustExtension();}
	bool    GetFileTime(EFileTime type, time_t& out) const {return m_pPhysicalFileReader->GetFileTime(type, out);}

public:
	tstring& GetContent(tstring&); // Data access in form of tstring
	CString& GetContent(CString&); // Data access in form of CString

protected:
	virtual void Open() {m_pPhysicalFileReader->Open();}
	virtual void ReadData(LPTSTR * ppBuf) {m_pPhysicalFileReader->ReadData(ppBuf);}
	virtual void StreamData(LPTSTR * ppBuf);
	virtual void Parse(); // is empty for this class
	virtual bool UseDefault(); // is empty for this class
	virtual void Close();

protected:
	tistringstream m_StreamData;

};

////////////////////////////////////////////////////////////////////////////////////
// CTextFileReader
// Specialize CFileReader to a text file
////////////////////////////////////////////////////////////////////////////////////
class CTextFileReader : public CFileReader
{
protected:
	static bool IsAmongSeparators(TCHAR separatorCandidate, const vector<TCHAR>& separator_arr);
	CString	m_strDefaultContents; // default contents to use if there is no such file.

public:
	// static utilities
	static void GetWords(const CString& text, vector<CString>& out, const vector<TCHAR>& separators); // extract words from string

	static long GetPos(tistream&);
	static bool SetPos(tistream&, long pos);

	static bool GetLine(tistream&, CString&);
	static bool Find(tistream&, const CString&, bool from_stream_begin =true);
	static bool NextLine(tistream&);
	static bool PrevLine(tistream&);
	static void SetAtLineBegin(tistream&);

public:
	CTextFileReader(CPhysicalFileReader * pPhysicalFileReader, LPCTSTR szDefaultContents = NULL, bool bDeletePhysicalFileReader =true);
   ~CTextFileReader();

#ifdef __DEBUG_CUSTOM
	public:
#else
	protected:
#endif
	long GetPos();
	bool SetPos(long pos);

#ifdef __DEBUG_CUSTOM
	public:
#else
	protected:
#endif
	bool GetLine(CString&);
	bool Find(const CString&, bool from_stream_begin =true);
	bool NextLine();
	bool PrevLine();
	void SetAtLineBegin();

protected:
	bool UseDefault(); // Note: not virtual.  No further inheritance intended.

};

#endif __FILEREAD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\filetracker.cpp ===
//
// MODULE: FileTracker.cpp
//
// PURPOSE: Abstract classes in support of tracking file changes over time.
//	Completely implements CFileToTrack, CFileTracker
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 9-15-98
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		09-15-98	JM
//


#include "stdafx.h"
#include "event.h"
#include "FileTracker.h"
#include "Functions.h"
#include "baseexception.h"
#include "CharConv.h"


//////////////////////////////////////////////////////////////////////
// CFileToTrack
//////////////////////////////////////////////////////////////////////

CFileToTrack::CFileToTrack(const CString & strPathName) :
	m_strPathName(strPathName), 
	m_bFileExists(false)
{
	m_ftLastWriteTime.dwLowDateTime = 0;
	m_ftLastWriteTime.dwHighDateTime = 0;
}

CFileToTrack::~CFileToTrack()
{
}

void CFileToTrack::CheckFile(bool & bFileExists, bool & bTimeChanged, const bool bLogIfMissing )
{
	HANDLE hSearch;
	WIN32_FIND_DATA FindData;

	hSearch = ::FindFirstFile(m_strPathName, &FindData);

	bFileExists = (hSearch != INVALID_HANDLE_VALUE);

	// initialize bTimeChanged: we always consider coming into existence as a time change.
	bTimeChanged = bFileExists && ! m_bFileExists;
	m_bFileExists = bFileExists;

	if (bFileExists) 
	{
		::FindClose(hSearch);
		// for some reason, we can't compile
		// bTimeChanged |= (m_ftLastWriteTime != FindData.ftLastWriteTime);
		// so:
		bTimeChanged |= (0 != memcmp(&m_ftLastWriteTime, &(FindData.ftLastWriteTime), sizeof(m_ftLastWriteTime)));
		m_ftLastWriteTime = FindData.ftLastWriteTime;
	}
	else
	{
		// file disappeared or never existed, ignore for now
		m_bFileExists = false;
		bFileExists = false;

		if (bLogIfMissing)
		{
			CString strErr;
			FormatLastError(&strErr, ::GetLastError());

			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									m_strPathName,
									strErr,
									EV_GTS_ERROR_FILE_MISSING ); 
		}

		bTimeChanged = false;
	}
}

//////////////////////////////////////////////////////////////////////
// CFileTracker
//////////////////////////////////////////////////////////////////////
CFileTracker::CFileTracker()
{
}

CFileTracker::~CFileTracker()
{
}

void CFileTracker::AddFile(const CString & strPathName)
{
	try
	{
		m_arrFile.push_back(CFileToTrack(strPathName));
	}
	catch (exception& x)
	{
		CString str;
		// Note STL exception in event log.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								CCharConversion::ConvertACharToString(x.what(), str), 
								_T(""), 
								EV_GTS_STL_EXCEPTION ); 
	}
}

bool CFileTracker::Changed( const bool bLogIfMissing )
{
	bool bChange = false;
	bool bSomethingMissing = false;

	//
	// This try-catch block was added as a measure to handle an unexplainable problem.
	//
	// Previously this function was throwning a (...) exception in release builds but
	// not in debug builds.  Adding this try-catch block had the effect of making the
	// (...) exception in release builds disappear.  This problem was causing the 
	// directory monitor thread to die so if you change this function, please verify
	// that the directory monitor thread is still viable.
	// RAB-981112.
	try
	{
		for(vector<CFileToTrack>::iterator it = m_arrFile.begin();
		it != m_arrFile.end();
		it ++
		)
		{
			bool bFileExists;
			bool bTimeChanged;

			it->CheckFile(bFileExists, bTimeChanged, bLogIfMissing );
			bChange |= bTimeChanged;
			bSomethingMissing |= !bFileExists;
		}
	}
	catch (...)
	{
		// Catch any other exception thrown.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								_T(""), _T(""), 
								EV_GTS_GEN_EXCEPTION );		
	}

	return (bChange && !bSomethingMissing);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\fs.h ===
//
// MODULE: FS.h
//
// PURPOSE: Interface declaration needed in order to use CHM files.
//
// COMPANY: This file was created by Microsoft and should not be changed by Saltmine 
//	except for comments
//
// ORIGINAL DATE: 1997.
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.1		01-18-99	JM		This header added.
//
// Copyright  1997-1997  Microsoft Corporation.  All Rights Reserved.

#ifndef _FS_H_
#define _FS_H_

#if _MSC_VER > 1000
#pragma once
#endif

#include <unknwn.h>
#include "msitstg.h"

#ifdef ReleaseObjPtr
#undef ReleaseObjPtr
#endif
#define ReleaseObjPtr(pObj) \
{                           \
  if( pObj )                \
  {                         \
    pObj->Release();        \
    pObj= NULL;             \
  }                         \
}

//
// Sub-File System
//
class CSubFileSystem
{
protected:
	bool GetSubPos(ULARGE_INTEGER*, STREAM_SEEK =STREAM_SEEK_CUR);
	bool SetSubPos(LARGE_INTEGER, STREAM_SEEK =STREAM_SEEK_SET);

public:
   CSubFileSystem(class CFileSystem* pfs);
   ~CSubFileSystem();

   HRESULT CreateSub(PCSTR pszPathName);
   HRESULT CreateUncompressedSub(PCSTR pszPathName);
   HRESULT OpenSub(PCSTR pszPathName, DWORD dwAccess = (STGM_READ | STGM_SHARE_DENY_WRITE));
   ULONG WriteSub(const void* pData, int cb);
   ULONG SeekSub(int cb, int iOrigin);
   HRESULT CreateSystemFile(PCSTR pszPathName);
   HRESULT CreateUncompressedSystemFile(PCSTR pszPathName);
   HRESULT SetSize(unsigned uSize);
   HRESULT DeleteSub() ;
   ULONG GetUncompressedSize(void);

   inline HRESULT ReadSub(void* pData, ULONG cb, ULONG* pcbRead) {
      return m_pStream->Read(pData, cb, pcbRead);
   }

   inline HRESULT Stat(STATSTG *pstatstg, DWORD grfStatFalg)
   {
      return m_pStream->Stat(pstatstg,grfStatFalg);
   }

   inline HRESULT CopyTo(IStream* pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER* pcbWritten)
   {
      return m_pStream->CopyTo(pstm, cb, pcbRead, pcbWritten);
   }

   inline IStream * GetStream(void)
   {
      return m_pStream;
   }

   inline IStorage* GetITStorageDocObj(void) const
   {
      return m_pStorage;
   }

private:
   class CFileSystem* m_pFS;
   IStorage*          m_pStorage;
   IStream*           m_pStream;
   char               m_szPathName[MAX_PATH]; // Needed for delete.
};

//
// File System
//
class CFileSystem
{
   friend class CSubFileSystem;

public:
   CFileSystem();
   ~CFileSystem();

   HRESULT Init(void);
   HRESULT Create( PCSTR pszPathName );
   HRESULT CreateUncompressed( PCSTR pszPathName );
   HRESULT Open( PCSTR pszPathName, DWORD dwAccess = (STGM_READ | STGM_SHARE_DENY_WRITE));
   HRESULT Compact(LPCSTR lpszFileName);
   HRESULT Close(void);

   inline HRESULT GetPathName( LPSTR pszPathName ) { strcpy(pszPathName, m_szPathName); return S_OK; }

   inline IITStorage* GetITStorageObj(void) const
   {
      return m_pITStorage;
   }

   inline IStorage* GetITStorageDocObj(void) const
   {
      return m_pStorage;
   }

private:
   IITStorage*   m_pITStorage;
   IStorage*     m_pStorage;
   char          m_szPathName[MAX_PATH];

};

#endif // _FS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\filetracker.h ===
//
// MODULE: FileTracker.h
//
// PURPOSE: Abstract classes in support of tracking file changes over time.
//	Interface for CFileToTrack, CFileTracker
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 9-15-98
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		09-15-98	JM
//

#if !defined(AFX_FILETRACKER_H__3942A069_4CB5_11D2_95F6_00C04FC22ADD__INCLUDED_)
#define AFX_FILETRACKER_H__3942A069_4CB5_11D2_95F6_00C04FC22ADD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "apgtsstr.h"
#include <vector>
using namespace std;

// ideally, this would be a private class of CFileTracker, but that's incompatible with STL vector.
class CFileToTrack
{
private:
	FILETIME m_ftLastWriteTime;	// zeroed to indicate not yet read; otherwise, file time 
							//	when last checked
	CString m_strPathName;	// full pathname of file to monitor
	bool m_bFileExists;		// when we last checked for the file, did it exist
public:
	CFileToTrack();  	// do not instantiate; exists only so vector can compile

	// The only constructor you should call is:
	CFileToTrack(const CString & strPathName);

	virtual ~CFileToTrack();
	void CheckFile(bool & bFileExists, bool & bTimeChanged, const bool bLogIfMissing= true );

	// to keep vector happy
	bool operator < (const CFileToTrack & x) const {return this->m_strPathName < x.m_strPathName ;};
	bool operator == (const CFileToTrack & x) const {return this->m_strPathName == x.m_strPathName ;};
};

// abstract class. Intended as base class for distinct classes tracking LST files, DSC/BES/HTI files
//	These must provide there own overrides of TakeAction.
class CFileTracker
{
private:
	vector<CFileToTrack> m_arrFile;
public:
	CFileTracker();
	virtual ~CFileTracker();
	void AddFile(const CString & strPathName);
	bool Changed( const bool bLogIfMissing= true );

	// to keep vector happy.  Note that no two CFileTracker's will ever test equal
	//	even if their content is identical.
	bool operator < (const CFileTracker & x) const {return this < &x;};
	bool operator == (const CFileTracker & x) const {return this ==  &x;};
};

#endif // !defined(AFX_FILETRACKER_H__3942A069_4CB5_11D2_95F6_00C04FC22ADD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\fs.cpp ===
//
// MODULE: FS.cpp
//
// PURPOSE: Implementation of classes needed in order to use CHM files.
//
// COMPANY: This file was created by Microsoft and should not be changed by Saltmine 
//	except for comments
//
// ORIGINAL DATE: 1997.
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.1		01-18-99	JM		This header added. Added include of apgtsstr.h since
//								we are compiling in a non-MFC environment.
//
// Copyright (C) 1997 Microsoft Corporation. All rights reserved.

#include "stdafx.h"

// to avoid linker error related to undefined GUIDs
#include "initguid.h"
#include "fs.h"
#include "apgtsstr.h"

#pragma data_seg(".text", "CODE")

static const WCHAR txtwUncompressed[] =  L"uncompressed";

#pragma data_seg()

// returns poinder inside pszPath string that points to file name
// for example in "d:\Tshooter\http\lan.chm\lan.htm" it points
// to "lan.htm"
LPCSTR FindFilePortion(LPCSTR pszPath)
{
	int index =0;
	CString path(pszPath);

	if (-1 == (index = path.ReverseFind(_T('\\'))))
	{
		if (-1 == (index = path.ReverseFind(_T('/'))))
			index = 0;
		else
			index += sizeof(_T('/'));
	}
	else
		index += sizeof(_T('\\'));

	return pszPath + index;
}

CFileSystem::CFileSystem()
{
   m_pITStorage    = NULL;
   m_pStorage      = NULL;
   m_szPathName[0] = 0;
}

CFileSystem::~CFileSystem()
{
  ReleaseObjPtr(m_pStorage);
  ReleaseObjPtr(m_pITStorage);
}

HRESULT CFileSystem::Init(void)
{
   if (! m_pITStorage) {
      IClassFactory* pICFITStorage;

	  HRESULT hr = CoGetClassObject(CLSID_ITStorage, CLSCTX_INPROC_SERVER, NULL, IID_IClassFactory, (void **) &pICFITStorage);

      if (!SUCCEEDED(hr)) 
         return hr;
      
      hr = pICFITStorage->CreateInstance(NULL, IID_ITStorage,(void **) &m_pITStorage);
      ReleaseObjPtr( pICFITStorage );

      if (!SUCCEEDED(hr)) 
         return hr;
   }
   return S_OK;
}

typedef struct tagITSControlData
{
   UINT cdwFollowing;          // Must be 6 or 13
   DWORD cdwITFS_Control;      // Must be 5
   DWORD dwMagicITS;           // Must be MAGIC_ITSFS_CONTROL (see below)
   DWORD dwVersionITS;         // Must be 1
   DWORD cbDirectoryBlock;     // Size in bytes of directory blocks (Default is 8192)
   DWORD cMinCacheEntries;     // Least upper bound on the number of directory blocks
                               // which we'll cache in memory. (Default is 20)
   DWORD fFlags;               // Control bit flags (see below).
                               // Default value is fDefaultIsCompression.
   UINT  cdwControlData;       // Must be 6
   DWORD dwLZXMagic;           // Must be LZX_MAGIC (see below)
   DWORD dwVersion;            // Must be 2
   DWORD dwMulResetBlock;      // Number of blocks between compression resets.  (Default: 4)
   DWORD dwMulWindowSize;      // Maximum number of blocks kept in data history (Default: 4)
   DWORD dwMulSecondPartition; // Granularity in blocks of sliding history(Default: 2)
   DWORD dwOptions;            // Option flags (Default: fOptimizeCodeStreams)
} ITCD;

HRESULT CFileSystem::Create( PCSTR pszPathName )
{
   HRESULT hr;
   ITCD itcd;

   if (! m_pITStorage || m_pStorage )
      return E_FAIL;

   itcd.cdwFollowing      = 13;
   itcd.cdwITFS_Control   = 5;
   itcd.dwMagicITS        = MAGIC_ITSFS_CONTROL;
   itcd.dwVersionITS      = 1;
   itcd.cbDirectoryBlock  = 4096;     // default = 8192
   itcd.cMinCacheEntries  = 10;       // default = 20
   itcd.fFlags            = 1;        // 0 == Uncompressed, 1 == Compressed.
   itcd.cdwControlData        = 6;
   itcd.dwLZXMagic            = LZX_MAGIC;
   itcd.dwVersion             = 2;
   itcd.dwMulResetBlock       = 2;    // Default = 4
   itcd.dwMulWindowSize       = 2;    // Default = 4
   itcd.dwMulSecondPartition  = 1;    // Default = 2
   itcd.dwOptions             = 0;    // Default = fOptimizeCodeStreams

   m_pITStorage->SetControlData(PITS_Control_Data(&itcd));

   WCHAR wsz[MAX_PATH];
   MultiByteToWideChar(CP_ACP, 0, pszPathName, -1, (PWSTR) wsz, MAX_PATH);
   hr = m_pITStorage->StgCreateDocfile( (LPCWSTR) wsz, STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT, 0, &m_pStorage);

   if (!SUCCEEDED(hr)) {
      return hr;
   }

   strcpy( (LPSTR) m_szPathName, pszPathName );

   return S_OK;
}

// NOTE: The below function is required for the ITIR full-text indexer to
//     initialize.  I'm working to find out why this is and what impact
//     the below has on the file system.
//
HRESULT CFileSystem::CreateUncompressed( PCSTR pszPathName )
{
   HRESULT hr;
   ITCD itcd;

   if (! m_pITStorage || m_pStorage )
      return E_FAIL;

   itcd.cdwFollowing      = 6;
   itcd.cdwITFS_Control   = 5;
   itcd.dwMagicITS        = MAGIC_ITSFS_CONTROL;
   itcd.dwVersionITS      = 1;
   itcd.cbDirectoryBlock  = 8192;     // default = 8192
   itcd.cMinCacheEntries  = 20;        // default = 20
   itcd.fFlags            = 0;        // 0 == Uncompressed, 1 == Compressed.

   m_pITStorage->SetControlData(PITS_Control_Data(&itcd));

   WCHAR wsz[MAX_PATH];
   MultiByteToWideChar(CP_ACP, 0, pszPathName, -1, (PWSTR) wsz, MAX_PATH);
   hr = m_pITStorage->StgCreateDocfile( (LPCWSTR) wsz, STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT, 0, &m_pStorage);

   if (!SUCCEEDED(hr)) {
      return hr;
   }

   strcpy( (LPSTR) m_szPathName, pszPathName );

   return S_OK;
}

HRESULT CFileSystem::Open(PCSTR pszPathName, DWORD dwAccess)
{
   HRESULT hr = S_OK;

   if (! m_pITStorage || m_pStorage )
      return E_FAIL;

   // force access modes
   if( (dwAccess & STGM_WRITE) || (dwAccess & STGM_READWRITE) ) {
     dwAccess &= ~STGM_WRITE;
     dwAccess |= STGM_READWRITE | STGM_SHARE_EXCLUSIVE;
   }
   else
     dwAccess |= STGM_SHARE_DENY_WRITE;

   WCHAR wsz[MAX_PATH];
   MultiByteToWideChar(CP_ACP, 0, pszPathName, -1, (PWSTR) wsz, MAX_PATH);
   hr = m_pITStorage->StgOpenStorage( (LPCWSTR) wsz, NULL, dwAccess, NULL, 0, &m_pStorage);

   if (!SUCCEEDED(hr)) {
      return hr;
   }

   strcpy( (LPSTR) m_szPathName, pszPathName );

   return hr;
}

HRESULT CFileSystem::Compact(LPCSTR pszPathName)
{
   WCHAR wszPathName[MAX_PATH];
   //[BC-03022001] - changed 5th param to MultiByteToWideChar to number of chars from number of bytes.
   MultiByteToWideChar(CP_ACP, 0, pszPathName, -1, wszPathName, sizeof(wszPathName)/sizeof(WCHAR));
   m_pITStorage->Compact(wszPathName, COMPACT_DATA_AND_PATH);

   return S_OK;
}

HRESULT CFileSystem::Close()
{
   ReleaseObjPtr(m_pStorage);

   return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
// Here are a set of "sub" file I/O calls.
//
//
CSubFileSystem::CSubFileSystem(CFileSystem* pFS)
{
   m_pFS = pFS;
   m_pStorage = NULL;
   m_pStream = NULL;
   m_szPathName[0] = 0;
}

CSubFileSystem::~CSubFileSystem()
{
   if ( m_pStorage && (m_pStorage != m_pFS->m_pStorage) )
      ReleaseObjPtr(m_pStorage);

   ReleaseObjPtr(m_pStream);
}

HRESULT CSubFileSystem::CreateSub(PCSTR pszPathName)
{
   PCSTR pszFilePortion;
   HRESULT hr;

   if ( m_pStorage || m_pStream )
      return E_FAIL;

   if ((pszFilePortion = FindFilePortion(pszPathName)) && pszFilePortion > pszPathName)
   {
      CHAR szPath[MAX_PATH];
      strcpy( szPath, pszPathName );
      szPath[(pszFilePortion - 1) - pszPathName] = '\0';

      WCHAR wszStorage[MAX_PATH];
      MultiByteToWideChar(CP_ACP, 0, szPath, -1, (PWSTR) wszStorage, MAX_PATH);

      hr = m_pFS->m_pStorage->OpenStorage(wszStorage, NULL, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, NULL, 0, &m_pStorage);
      if (!SUCCEEDED(hr) || !m_pStorage) // storage didn't exist, so create it
         hr = m_pFS->m_pStorage->CreateStorage(wszStorage, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, 0, &m_pStorage);
      if (!SUCCEEDED(hr))
      {
         return hr;
      }
   }
   else // no folder, so store the file in the root
   {
      m_pStorage = m_pFS->m_pStorage;
      pszFilePortion = pszPathName;
   }
   WCHAR wszStream[MAX_PATH];
   MultiByteToWideChar(CP_ACP, 0, pszFilePortion, -1, (PWSTR) wszStream, MAX_PATH);
   hr = m_pStorage->CreateStream(wszStream, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, 0, &m_pStream);
   if (!SUCCEEDED(hr))
   {
      if (m_pStorage != m_pFS->m_pStorage)
         ReleaseObjPtr(m_pStorage);
      return hr;
   }

   // Needed for delete.
   strcpy( m_szPathName, pszFilePortion );

   return S_OK;
}

HRESULT CSubFileSystem::CreateUncompressedSub(PCSTR pszPathName)
{
   PCSTR pszFilePortion;
   HRESULT hr;
   IStorageITEx* pIStorageEx;

   if ( m_pStorage || m_pStream )
      return E_FAIL;

   if ((pszFilePortion = FindFilePortion(pszPathName)) && pszFilePortion > pszPathName)
   {
      CHAR szPath[MAX_PATH];
      strcpy( szPath, pszPathName );
      szPath[(pszFilePortion - 1) - pszPathName] = '\0';
      WCHAR wszStorage[MAX_PATH];
      MultiByteToWideChar(CP_ACP, 0, szPath, -1, (PWSTR) wszStorage, MAX_PATH);
      hr = m_pFS->m_pStorage->OpenStorage(wszStorage, NULL, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, NULL, 0, &m_pStorage);
      if (!SUCCEEDED(hr) || !m_pStorage) // storage didn't exist, so create it
         hr = m_pFS->m_pStorage->CreateStorage(wszStorage, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, 0, &m_pStorage);
      if (!SUCCEEDED(hr))
      {
         return hr;
      }
   }
   else // no folder, so store the file in the root
   {
      m_pStorage = m_pFS->m_pStorage;
      pszFilePortion = pszPathName;
   }

   if ( !(SUCCEEDED(hr = m_pStorage->QueryInterface(IID_IStorageITEx, (void**)&pIStorageEx))) )
      pIStorageEx = (IStorageITEx*)m_pStorage;  // BUGBUG the QI call above should work!

   WCHAR wszStream[MAX_PATH];
   MultiByteToWideChar(CP_ACP, 0, pszFilePortion, -1, (PWSTR) wszStream, MAX_PATH);
   hr = pIStorageEx->CreateStreamITEx(wszStream, txtwUncompressed, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, 0, (IStreamITEx**)&m_pStream);
   ReleaseObjPtr(pIStorageEx);
   if (!SUCCEEDED(hr))
   {
      if (m_pStorage != m_pFS->m_pStorage)
         ReleaseObjPtr(m_pStorage);
      return hr;
   }

   // Needed for delete.
   strcpy( m_szPathName, pszFilePortion );

   return S_OK;
}

HRESULT CSubFileSystem::CreateSystemFile(PCSTR pszPathName)
{
   m_pStorage = m_pFS->m_pStorage;
   WCHAR wszStream[MAX_PATH];
   MultiByteToWideChar(CP_ACP, 0, pszPathName, -1, (PWSTR) wszStream, MAX_PATH);
   HRESULT hr = m_pStorage->CreateStream(wszStream, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, 0, &m_pStream);
   if (!SUCCEEDED(hr))
   {
      return hr;
   }

   // Needed for delete.
   strcpy( m_szPathName, pszPathName );

   return S_OK;
}

HRESULT CSubFileSystem::CreateUncompressedSystemFile(PCSTR pszPathName)
{
   IStorageITEx* pIStorageEx;
   HRESULT hr;

   m_pStorage = m_pFS->m_pStorage;

   if ( !(SUCCEEDED(hr = m_pStorage->QueryInterface(IID_IStorageITEx, (void**)&pIStorageEx))) )
      pIStorageEx = (IStorageITEx*)m_pStorage;  // BUGBUG the QI call above should work!

   WCHAR wszStream[MAX_PATH];
   MultiByteToWideChar(CP_ACP, 0, pszPathName, -1, (PWSTR) wszStream, MAX_PATH);
   hr = pIStorageEx->CreateStreamITEx(wszStream, txtwUncompressed, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, 0, (IStreamITEx**)&m_pStream);
   ReleaseObjPtr(pIStorageEx);
   if (!SUCCEEDED(hr))
   {
      return hr;
   }

   // Needed for delete.
   strcpy( m_szPathName, pszPathName );

   return S_OK;
}

HRESULT CSubFileSystem::OpenSub(PCSTR pszPathName, DWORD dwAccess)
{
   PCSTR pszFilePortion;
   HRESULT hr;

   if ( m_pStorage || m_pStream )
      return E_FAIL;

   // force access modes
   if( (dwAccess & STGM_WRITE) || (dwAccess & STGM_READWRITE) ) {
     dwAccess &= ~STGM_WRITE;
     dwAccess |= STGM_READWRITE | STGM_SHARE_EXCLUSIVE;
   }
   else
     dwAccess |= STGM_SHARE_DENY_WRITE;

   if ((pszFilePortion = FindFilePortion(pszPathName)) &&
         pszFilePortion > pszPathName + 2) // +2 to support / && ./
   {
      CHAR szPath[MAX_PATH];
      strcpy( szPath, pszPathName );
      szPath[(pszFilePortion - 1) - pszPathName] = '\0';
      WCHAR wszStorage[MAX_PATH];
      MultiByteToWideChar(CP_ACP, 0, szPath, -1, (PWSTR) wszStorage, MAX_PATH);
      hr = m_pFS->m_pStorage->OpenStorage(wszStorage, NULL, dwAccess, NULL, 0, &m_pStorage);

      if (!SUCCEEDED(hr))
      {
         return hr;
      }
   }
   else // no folder, so store the file in the root
   {
      m_pStorage = m_pFS->m_pStorage ? m_pFS->m_pStorage : m_pFS->m_pStorage;
      pszFilePortion = pszPathName;
   }
   WCHAR wszStream[MAX_PATH];
   MultiByteToWideChar(CP_ACP, 0, pszFilePortion, -1, (PWSTR) wszStream, MAX_PATH);
   hr = m_pStorage->OpenStream(wszStream, NULL, dwAccess, 0, &m_pStream);
   if (!SUCCEEDED(hr))
   {
      if (m_pStorage != m_pFS->m_pStorage)
         ReleaseObjPtr(m_pStorage);
      return hr;
   }

   // Needed for delete.
   strcpy( m_szPathName, pszFilePortion );

   return S_OK;
}

ULONG CSubFileSystem::WriteSub(const void* pData, int cb)
{
   if ( !m_pStorage || !m_pStream )
      return (ULONG) -1;

   ULONG cbWritten;

   HRESULT hr = m_pStream->Write(pData, cb, &cbWritten);

   if (!SUCCEEDED(hr) || (cbWritten != (ULONG)cb) )
   {
      return (ULONG) -1;
   }
   // REVIEW: 30-May-1997  [ralphw] Why are we returning this? We fail if
   // we don't write cb bytes.
   return cbWritten;
}

/*
 * iOrigin:
 *    0 = Seek from beginning.
 *    1 = Seek from current.
 *    2 = Seek from end.
 */
ULONG CSubFileSystem::SeekSub(int cb, int iOrigin)
{
   HRESULT hr = S_OK;
   LARGE_INTEGER liCount = {0,0};
   ULARGE_INTEGER liNewPos = {0,0};

   if ( !m_pStorage || !m_pStream )
      return (ULONG) -1;

   liCount.LowPart = cb;
   hr = m_pStream->Seek(liCount, iOrigin, &liNewPos);
   if (!SUCCEEDED(hr) )
   {
      return (ULONG) -1;
   }

   return liNewPos.LowPart;
}

bool CSubFileSystem::GetSubPos(ULARGE_INTEGER* pliOldPos, STREAM_SEEK eDir /*=STREAM_SEEK_CUR*/)
{
   HRESULT hr = S_OK;
   LARGE_INTEGER liNull = {0,0};

   if ( !m_pStorage || !m_pStream )
      return false;

   hr = m_pStream->Seek(liNull, eDir, pliOldPos);
   if (!SUCCEEDED(hr) )
      return false;

   return true;
}

bool CSubFileSystem::SetSubPos(LARGE_INTEGER liNewPos, STREAM_SEEK eDir /*=STREAM_SEEK_SET*/)
{
   HRESULT hr = S_OK;

   if ( !m_pStorage || !m_pStream )
      return false;

   hr = m_pStream->Seek(liNewPos, eDir, NULL);
   if (!SUCCEEDED(hr) )
      return false;

   return true;
}

//
// Pre-allocate the size of the stream.
//

HRESULT CSubFileSystem::SetSize(unsigned uSize)
{
   ULARGE_INTEGER liSize = {0,0};
   HRESULT hr;

   if ( !m_pStorage || !m_pStream )
      return E_FAIL;

   liSize.LowPart = uSize;
   hr =  m_pStream->SetSize(liSize);

   if (!SUCCEEDED(hr) )
   {
      return (ULONG) -1;
   }
   return hr;
}

//
// Delete substorage.
//
HRESULT CSubFileSystem::DeleteSub()
{
    if (m_pStorage)
    {
        if (m_pStream)
        {
            // Release the stream.
            ReleaseObjPtr(m_pStream) ;
        }

        // Now delete the storage.
        WCHAR element[MAX_PATH];
        MultiByteToWideChar(CP_ACP, 0, m_szPathName, -1, (PWSTR) element, MAX_PATH);

        HRESULT hr = m_pStorage->DestroyElement(element) ;
        if (SUCCEEDED(hr))
        {
            // Get back to the constructor state.
            if ( m_pStorage && (m_pStorage != m_pFS->m_pStorage) )
            {
                ReleaseObjPtr(m_pStorage);
            }
            return S_OK ;
        }
    }
    return S_OK ;
}

ULONG CSubFileSystem::GetUncompressedSize(void) 
{ 
	ULARGE_INTEGER liOldPos ={0,0};
	LARGE_INTEGER liOldOff ={0,0};
	ULONG ret = -1;

	if (GetSubPos(&liOldPos))
	{
	   if (-1 != (ret = SeekSub(0, STREAM_SEEK_END)))
	   {
		   liOldOff.LowPart = liOldPos.LowPart;
		   liOldOff.HighPart = liOldPos.HighPart;
		   if (SetSubPos(liOldOff))
		   {
			   return ret;
		   }
	   }
	}
	return (ULONG) -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\functions.h ===
//
// MODULE: FUNCTIONS.H
//
// PURPOSE:  Decodes the the variant structures.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
/// 
// ORIGINAL DATE: 6/4/96
//
// NOTES: 
// 1.
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V0.3		3/24/98		JM		Local Version for NT5
//

#ifndef __FUNCTIONS_H_
#define __FUNCTIONS_H_ 1

inline CString GlobFormatMessage(DWORD dwLastError)
{
	CString strMessage;
	void *lpvMessage;
	FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
		NULL,
		dwLastError,
		MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
		(LPTSTR) &lpvMessage, 0, NULL);
	strMessage = (LPCTSTR) lpvMessage;
	LocalFree(lpvMessage);
	return strMessage;
}

inline CString DecodeVariantTypes(VARTYPE vt)
{
	CString str = _T("");
	if (VT_EMPTY == vt)
		str = _T("Empty  ");
	else if(VT_ILLEGAL == vt)
		str = _T("ILLEGAL  ");
	else if(VT_ILLEGALMASKED == vt)
		str = _T("ILLEGALMASKED  ");
	else
	{
		if (VT_VECTOR == (VT_VECTOR & vt))
			str += _T("VECTOR  ");
		if (VT_ARRAY == (VT_ARRAY & vt))
			str += _T("ARRAY  ");
		if (VT_BYREF == (VT_BYREF & vt))
			str += _T("BYREF  ");
		if (VT_RESERVED == (VT_RESERVED & vt))
			str += _T("RESERVED  ");
		if (VT_TYPEMASK == (VT_TYPEMASK & vt))
			str += _T("TYPEMASK  ");
		vt &= 0xFFF;
		if (VT_NULL == vt)
			str += _T("Null  ");
		if (VT_I2 == vt)
			str += _T("I2  ");
		if (VT_I4 == vt)
			str += _T("I4  ");
		if (VT_R4 == vt)
			str += _T("R4  ");
		if (VT_R8 == vt)
			str += _T("R8  ");
		if (VT_CY == vt)
			str += _T("CY  ");
		if (VT_DATE == vt)
			str += _T("DATE  ");
		if (VT_BSTR == vt)
			str += _T("BSTR  ");
		if (VT_DISPATCH == vt)
			str += _T("DISPATCH  ");
		if (VT_ERROR == vt)
			str += _T("ERROR  ");
		if (VT_BOOL == vt)
			str += _T("BOOL  ");
		if (VT_VARIANT == vt)
			str += _T("VARIANT  ");
		if (VT_UNKNOWN == vt)
			str += _T("UNKNOWN  ");
		if (VT_DECIMAL == vt)
			str += _T("DECIMAL  ");
		if (VT_I1 == vt)
			str += _T("I1  ");
		if (VT_UI1 == vt)
			str += _T("UI1  ");
		if (VT_UI2 == vt)
			str += _T("UI2  ");
		if (VT_UI4 == vt)
			str += _T("UI4  ");
		if (VT_I8 == vt)
			str += _T("I8  ");
		if (VT_UI8 == vt)
			str += _T("UI8  ");
		if (VT_INT == vt)
			str += _T("INT  ");
		if (VT_UINT == vt)
			str += _T("UINT  ");
		if (VT_VOID == vt)
			str += _T("VOID  ");
		if (VT_HRESULT == vt)
			str += _T("HRESULT  ");
		if (VT_PTR == vt)
			str += _T("PTR  ");
		if (VT_SAFEARRAY == vt)
			str += _T("SAFEARRAY  ");
		if (VT_CARRAY == vt)
			str += _T("CARRAY  ");
		if (VT_USERDEFINED == vt)
			str += _T("USERDEFINED  ");
		if (VT_LPSTR == vt)
			str += _T("LPSTR  ");
		if (VT_LPWSTR == vt)
			str += _T("LPWSTR  ");
		if (VT_FILETIME == vt)
			str += _T("FILETIME  ");
		if (VT_BLOB == vt)
			str += _T("BLOB  ");
		if (VT_STREAM == vt)
			str += _T("STREAM  ");
		if (VT_STORAGE == vt)
			str += _T("STORAGE  ");
		if (VT_STREAMED_OBJECT == vt)
			str += _T("STREAMED_OBJECT  ");
		if (VT_STORED_OBJECT == vt)
			str += _T("STORED_OBJECT  ");
		if (VT_BLOB_OBJECT == vt)
			str += _T("BLOB_OBJECT  ");
		if (VT_CF == vt)
			str += _T("CF  ");
		if (VT_CLSID == vt)
			str += _T("CLSID  ");
	}
	return str;
}

inline CString DecodeSafeArray(unsigned short Features)
{
/*
#define FADF_AUTO		0x0001	// Array is allocated on the stack.
#define FADF_STATIC		0x0002	// Array is statically allocated.
#define FADF_EMBEDDED	0x0004	// Array is embedded in a structure.
#define FADF_FIXEDSIZE	0x0010	// Array may not be resized or 
								// reallocated.
#define FADF_BSTR		0x0100	// An array of BSTRs.
#define FADF_UNKNOWN		0x0200	// An array of IUnknown*.
#define FADF_DISPATCH	0x0400	// An array of IDispatch*.
#define FADF_VARIANT		0x0800	// An array of VARIANTs.
#define FADF_RESERVED	0xF0E8	// Bits reserved for future use.
*/
	CString str = _T("");
	if (FADF_AUTO == (FADF_AUTO & Features))
		str += _T("Array is allocated on the stack.\n");
	if (FADF_STATIC == (FADF_STATIC & Features))
		str += _T("Array is statically allocated.\n");
	if (FADF_EMBEDDED == (FADF_EMBEDDED & Features))
		str += _T("Array is embedded in a structure.\n");
	if (FADF_FIXEDSIZE == (FADF_FIXEDSIZE & Features))
		str += _T("Array may not be resized of reallocated.\n");
	if (FADF_BSTR == (FADF_BSTR & Features))
		str += _T("An array of BSTRs.\n");
	if (FADF_UNKNOWN == (FADF_UNKNOWN & Features))
		str += _T("An array of IUnknown.\n");
	if (FADF_DISPATCH == (FADF_DISPATCH & Features))
		str += _T("An array of IDispatch.\n");
	if (FADF_VARIANT == (FADF_VARIANT & Features))
		str += _T("An array of VARIANTS.\n");
	if (FADF_RESERVED == (FADF_RESERVED & Features))
		str+= _T("Array is using all of the reserved bits.\n");
	return str; 
}

inline void FormatLastError(CString *pstr, DWORD dwLastError)
{
	void *lpvMessage;
	::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
		NULL,
		dwLastError,
		MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
		(LPTSTR) &lpvMessage, 
		0, 
		NULL);
	*pstr = (LPCTSTR) lpvMessage;
	::LocalFree(lpvMessage);	// slightly hideous, but Win32 FormatMessage uses LocalAlloc
								// in response to FORMAT_MESSAGE_ALLOCATE_BUFFER, so we
								// need to use LocalFree.
	return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\htmlfraglocal.cpp ===
//
// MODULE: HTMLFrag.cpp
//
// PURPOSE: implementation of the CHTMLFragmentsLocal class.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 1-19-1999
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.1		1-19-19		OK		Original
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "HTMLFragLocal.h"
#include "fileread.h"
#ifdef LOCAL_TROUBLESHOOTER
#include "CHMFileReader.h"
#include "apgtsinf.h"
#include "resource.h"
#endif


/*static*/ bool CHTMLFragmentsLocal::RemoveBackButton(CString& strCurrentNode)
{
	int left = 0, right = 0;

	if (-1 != (left = strCurrentNode.Find(SZ_INPUT_TAG_BACK)))
	{
		right = left;
		while (strCurrentNode[++right] && strCurrentNode[right] != _T('>'))
			;
		if (strCurrentNode[right])
			strCurrentNode = strCurrentNode.Left(left) + strCurrentNode.Right(strCurrentNode.GetLength() - right - 1);
		else
			return false;
		return true;
	}
	return false;
}

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
CHTMLFragmentsLocal::CHTMLFragmentsLocal( const CString & strScriptPath, bool bIncludesHistoryTable)
				   : CHTMLFragmentsTS( strScriptPath, bIncludesHistoryTable )
{
}

CString CHTMLFragmentsLocal::GetText(const FragmentIDVector & fidvec, const FragCommand fragCmd )
{
	if (!fidvec.empty())
	{
		const CString & strVariable0 = fidvec[0].VarName;	// ref of convenience
		int i0 = fidvec[0].Index;

		if (fidvec.size() == 1)
		{
			if ((fragCmd == eResource) && (strVariable0 == VAR_PREVIOUS_SCRIPT))
			{
				// Hard-coded server side include for backward compatibility.
				CString strScriptContent;
				
				strScriptContent.LoadString(IDS_PREVSCRIPT);
				return strScriptContent;
			}
			else if (strVariable0 == VAR_NOBACKBUTTON_INFO)
			{
				CString strCurrentNode = GetCurrentNodeText();
				RemoveBackButton(strCurrentNode);
				SetCurrentNodeText(strCurrentNode);
				return _T("");
			}
		}
	}
	
	return CHTMLFragmentsTS::GetText( fidvec, fragCmd );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\htmlfraglocal.h ===
//
// MODULE: HTMLFrag.h
//
// PURPOSE: interface for the CHTMLFragmentsLocal class.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 1-19-1999
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.1		1-19-19		OK		Original
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_HTMLFRAGLOCAL_H__FFDF7EB3_AFBC_11D2_8C89_00C04F949D33__INCLUDED_)
#define AFX_HTMLFRAGLOCAL_H__FFDF7EB3_AFBC_11D2_8C89_00C04F949D33__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "HTMLFrag.h"

#define VAR_PREVIOUS_SCRIPT		_T("Previous.script")
#define VAR_NOBACKBUTTON_INFO	_T("NoBackButton")
#define VAR_YESBACKBUTTON_INFO	_T("YesBackButton")

class CHTMLFragmentsLocal : public CHTMLFragmentsTS  
{
protected:
	static bool RemoveBackButton(CString& strCurrentNode);

public:
	CHTMLFragmentsLocal( const CString &strScriptPath, bool bIncludesHistoryTable );

public:
	// overridden virtual
	CString GetText( const FragmentIDVector & fidvec, const FragCommand fragCmd= eNotOfInterest );
};

#endif // !defined(AFX_HTMLFRAGLOCAL_H__FFDF7EB3_AFBC_11D2_8C89_00C04F949D33__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\iniread.h ===
//
// MODULE: INIREAD.H
//
// PURPOSE: INI file reading classes
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 7-29-98
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		08-04-98	OK
//

#ifndef __INIREAD_H_
#define __INIREAD_H_

#include "fileread.h"

////////////////////////////////////////////////////////////////////////////////////
// CINIReader
////////////////////////////////////////////////////////////////////////////////////
class CINIReader : public CTextFileReader
{
	CString m_strSection;       // section name

protected:
	vector<CString> m_arrLines; // vector of non-commented lines

public:
	CINIReader(CPhysicalFileReader * pPhysicalFileReader, LPCTSTR section);
   ~CINIReader();

protected:
	virtual void Parse();
};

#endif __INIREAD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\iniread.cpp ===
// MODULE: INIREAD.CPP
//
// PURPOSE: INI file reading classes
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 7-29-98
//
// NOTES: 
//	1. As of 1/99, needn't account for CHM file: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		08-04-98	OK
//

#include "stdafx.h"
#include "iniread.h"
#include "event.h"
#include "CharConv.h"

////////////////////////////////////////////////////////////////////////////////////
// CINIReader
////////////////////////////////////////////////////////////////////////////////////
CINIReader::CINIReader(CPhysicalFileReader * pPhysicalFileReader, LPCTSTR section)
          : CTextFileReader(pPhysicalFileReader),
			m_strSection(section)
{
}

CINIReader::~CINIReader()
{
}

void CINIReader::Parse()
{
	CString str;
	long save_pos = 0;
	CString section_with_brackets = CString(_T("[")) + m_strSection + _T("]");
	
	save_pos = GetPos();
	if (Find(section_with_brackets))
	{	// we have found section
		m_arrLines.clear();

		NextLine();
		try
		{
			while (GetLine(str))
			{
				str.TrimLeft();
				str.TrimRight();
				if (str.GetLength() == 0) // empty string
					continue;
				if (str[0] == _T('[')) // another section
					break;
				if (str[0] == _T(';')) // entry is commented
					continue;
				m_arrLines.push_back(str);
			}
		}
		catch (exception& x)
		{
			CString str;
			// Note STL exception in event log.
			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									CCharConversion::ConvertACharToString(x.what(), str),
									_T(""), 
									EV_GTS_STL_EXCEPTION ); 
		}
	}
	SetPos(save_pos);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\htmlfrag.h ===
//
// MODULE: HTMLFrag.h
//
// PURPOSE: declaration of the CHTMLFragments and CHTMLFragmentsTS classes.
//	This is how CInfer packages up fragments of HTML to be rendered in accord 
//	with a template.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 8-27-1998
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		8-27-98		JM		Original
//
//////////////////////////////////////////////////////////////////////

#ifndef __HTMLFRAG_H_
#define __HTMLFRAG_H_

#include <vector>
using namespace std;

// JSM V3.2
#include <map>
using namespace std;


#include "apgtsstr.h"

// Predefined variable names
//  They belong to DISPLAY command 
#define VAR_PROBLEM_ASK		_T("ProblemAsk")
#define VAR_RECOMMENDATIONS	_T("Recommendations")
#define VAR_STATES			_T("States")
#define VAR_QUESTIONS		_T("Questions")
#define VAR_SUCCESS			_T("Success")
#define VAR_STARTFORM		_T("StartForm")

// V3.2 Additions.
namespace
{
	const CString kstrCond_NumericCompare=	_T("NumericCompare");
}

struct FragmentID
{
	FragmentID() : Index(-1) {};
	FragmentID(const CString & v, int i) : VarName(v), Index(i) {};
	CString VarName;	// must be a known, predefined variable name
	int	Index;			// index into array associated with this variable name 
						//	OR -1 for not relevant
	bool operator < (const FragmentID & fid) const
		{ return (VarName < fid.VarName || Index < fid.Index); };
	bool operator == (const FragmentID & fid) const
		{ return (VarName == fid.VarName || Index == fid.Index); };
};


class CHTMLValue
{
	CString m_strValName;
	CString m_strValValue;

public:
	CHTMLValue() {}
	CHTMLValue(const CString& name) : m_strValName(name) {}
	CHTMLValue(const CString& name, const CString& value) : m_strValName(name), m_strValValue(value) {}
	virtual ~CHTMLValue() {}

public:
	bool operator == (const CHTMLValue& sib);

	void SetName(const CString& name) {m_strValName = name;}
	CString GetName() {return m_strValName;}

	bool SetValue(const CString& value);

	bool GetNumeric(long&);
	bool GetString(CString&);
	bool GetBoolean(bool&);

	bool IsValid() {return IsNumeric() || IsString() || IsBoolean();}
	bool IsNumeric();
	bool IsString();
	bool IsBoolean();
};


// vectors definition
typedef vector<FragmentID> FragmentIDVector;
typedef vector<CHTMLValue> HTMLValueVector;


// Template should see only a const object of this class
class CHTMLFragments
{
	HTMLValueVector m_HTMLValueVector;

public:
	enum FragCommand { eNotOfInterest, eResource };

public:
	CHTMLFragments() {};
	virtual ~CHTMLFragments()=0 {};
	// pure virtuals
	virtual int GetCount(const FragmentIDVector & fidvec) const =0;
	virtual CString GetText(const FragmentIDVector & fidvec, const FragCommand fragCmd= eNotOfInterest ) =0;
	virtual bool IsValidSeqOfVars(const FragmentIDVector & arrParents, const FragmentIDVector & arrChildren) const =0 ;
	// value handling
	virtual bool SetValue(const CString& assignment_expression);
	virtual CHTMLValue* GetValue(const CString& value_name);
	// JSM V3.2 needed by mechanism which replaces <!GTS property "netprop">
	//   w/ the corresponding BNTS network property
	virtual CString GetNetProp(const CString & strNetPropName) = 0;

	// V3.2 enhancement for the Start Over button.
	virtual void SetStartOverLink( const CString & str ) {};		
	virtual CString GetStartOverLink() {return _T("");}
};


// Implementation specific to the predefined variables above
class CHTMLFragmentsTS : public CHTMLFragments
{
#ifdef __DEBUG_CUSTOM
	protected:
#else
	private:
#endif
	const bool m_bIncludesHistoryTable;
	const bool m_bIncludesHiddenHistory;
	CString m_strStartForm;			// The fixed, initial part of the HTML form on every
									//	page that has a form.  (The FORM tag + the topic 
									//	name in a hidden field of that form)
	CString	m_strProblem;			// problem name (for history table)
	vector<CString>	m_vstrVisitedNodes;	// name of each visited node (for history table)
#pragma warning(disable:4786)
	vector< vector<CString> > m_vvstrStatesOfVisitedNodes; // text corresponding
									// to each state of each visited node (for history table).
									// This includes radio button.
	CString	m_strCurrentNode;		// full text for current node, sometimes includes
									//	hidden history
	CString	m_strCurrentNodeSimple;	// text for current node, always excludes hidden history
	CString	m_strHiddenHistory;		// If there is to be no history table, this encodes
									//	the history in hidden fields (for an HTML form)
	CString m_strNil;
	CString m_strYes;				// constant "Yes" for m_bSuccess == true
	bool m_bSuccess;				// true only is current node is BYE (success) node.
	const CString m_strScriptPath;		// path to the resource directory, used for server side logic.

	CString m_strStartOverLink;		// V3.2 - for Online TS, contains the text for the start over 
									//	link (which is disguised as a button).  Unlike other
									//	properties, this is set by APGTSContext and gotten
									//	by CInfer, not set by CInfer and gotten by CAPGTSHTIReader

	//  V3.2  map BNTS network property name to net property (value)
	//    allows us to convert <!GTS property "netprop"> when reading the HTI file 
	map<CString,CString> m_mapstrNetProps;  
private:
	CHTMLFragmentsTS();				// Do not instantiate


public:
	CHTMLFragmentsTS( const CString & strScriptPath, bool bIncludesHistoryTable );
	~CHTMLFragmentsTS();

	// inherited methods
	int GetCount(const FragmentIDVector & fidvec) const;
	CString GetText( const FragmentIDVector & fidvec, const FragCommand fragCmd= eNotOfInterest );
	virtual bool IsValidSeqOfVars(const FragmentIDVector & arrParents, const FragmentIDVector & arrChildren) const;
	void SetStartOverLink( const CString & str );		// V3.2 enhancement for the Start Over button.
	CString GetStartOverLink();		// V3.2 enhancement for the Start Over button.

	// methods specific to this class
	void SetStartForm(const CString & str);
	void SetProblemText(const CString & str);
	void SetCurrentNodeText(const CString & str);
	void SetHiddenHistoryText(const CString & str);
	void SetSuccessBool(bool bSuccess);
	CString GetCurrentNodeText();
	int PushBackVisitedNodeText(const CString & str);
	int PushBackStateText(UINT iVisitedNode, const CString & str);
	bool IncludesHistoryTable() const;
	bool IncludesHiddenHistory() const;

	// Functions which parse and evaluate numeric and string conditionals.
	bool	NumericConditionEvaluatesToTrue( const CString & str );
	bool	StringConditionEvaluatesToTrue( const CString & str );
	CString RemoveOuterParenthesis( const CString & str );
	bool	RetNumericOperands(	const CString & str, const CString & strOperator,
								long &lLeftOperand, long &lRightOperand );
	bool	RetStringOperands(	const CString & str, const CString & strOperator,
								CString & strLeftOperand, CString & strRightOperand );
	int		CleanStringOperand( CString& strOperand );

	// 	JSM V3.2 these functions used by the mechanism which replaces
	//  <!GTS property "netprop"> w/ the corresponding BNTS network property
	//
	//    CAPGTSHTIReader finds the names of the network properties and passes
	//       them in via AddNetPropName
	//    CInfer later gets the network property names, calls the BNTS
	//       to find out the network property values, and passes the values to HTMLFragmentsTS
	//    Later, CAPGTSHTIReader queries HTMLFragmentsTS for network property values
	//       during the parsing process.
	//
	//  add the name of a network property to the internal list
	void AddNetPropName(const CString & strNetPropName);
	// returns the network property, requested by name. (returns null if not avail.)
	CString GetNetProp(const CString & strNetPropName);
	 // set the value of the network property identified by strNetPropName
	BOOL SetNetProp(CString strNetPropName, CString strNetProp);
	// iterate (by name) thru the list of net props
	BOOL IterateNetProp(CString & strNameIterator);
	// end JSM V3.2
private:
	void RebuildCurrentNodeText();
};
#endif // __HTMLFRAG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\launchserv.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Mon Nov 23 13:59:17 1998
 */
/* Compiler settings for LaunchServ.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __LaunchServ_h__
#define __LaunchServ_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __ILaunchTS_FWD_DEFINED__
#define __ILaunchTS_FWD_DEFINED__
typedef interface ILaunchTS ILaunchTS;
#endif 	/* __ILaunchTS_FWD_DEFINED__ */


#ifndef __ITShootATL_FWD_DEFINED__
#define __ITShootATL_FWD_DEFINED__
typedef interface ITShootATL ITShootATL;
#endif 	/* __ITShootATL_FWD_DEFINED__ */


#ifndef __LaunchTS_FWD_DEFINED__
#define __LaunchTS_FWD_DEFINED__

#ifdef __cplusplus
typedef class LaunchTS LaunchTS;
#else
typedef struct LaunchTS LaunchTS;
#endif /* __cplusplus */

#endif 	/* __LaunchTS_FWD_DEFINED__ */


#ifndef __TShootATL_FWD_DEFINED__
#define __TShootATL_FWD_DEFINED__

#ifdef __cplusplus
typedef class TShootATL TShootATL;
#else
typedef struct TShootATL TShootATL;
#endif /* __cplusplus */

#endif 	/* __TShootATL_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __ILaunchTS_INTERFACE_DEFINED__
#define __ILaunchTS_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ILaunchTS
 * at Mon Nov 23 13:59:17 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_ILaunchTS;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("131CC2A0-7634-11D1-8B6B-0060089BD8C4")
    ILaunchTS : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetShooterStates( 
            /* [retval][out] */ DWORD __RPC_FAR *pdwResult) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetTroubleShooter( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrShooter) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetProblem( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrProblem) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetNode( 
            /* [in] */ short iNode,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrNode) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetState( 
            /* [in] */ short iNode,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrState) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetMachine( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrMachine) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetPNPDevice( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetGuidClass( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetDeviceInstance( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Test( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILaunchTSVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ILaunchTS __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ILaunchTS __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ILaunchTS __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ILaunchTS __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ILaunchTS __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ILaunchTS __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ILaunchTS __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetShooterStates )( 
            ILaunchTS __RPC_FAR * This,
            /* [retval][out] */ DWORD __RPC_FAR *pdwResult);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTroubleShooter )( 
            ILaunchTS __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrShooter);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProblem )( 
            ILaunchTS __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrProblem);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNode )( 
            ILaunchTS __RPC_FAR * This,
            /* [in] */ short iNode,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrNode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetState )( 
            ILaunchTS __RPC_FAR * This,
            /* [in] */ short iNode,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrState);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMachine )( 
            ILaunchTS __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrMachine);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPNPDevice )( 
            ILaunchTS __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetGuidClass )( 
            ILaunchTS __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDeviceInstance )( 
            ILaunchTS __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Test )( 
            ILaunchTS __RPC_FAR * This);
        
        END_INTERFACE
    } ILaunchTSVtbl;

    interface ILaunchTS
    {
        CONST_VTBL struct ILaunchTSVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILaunchTS_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ILaunchTS_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ILaunchTS_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ILaunchTS_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ILaunchTS_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ILaunchTS_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ILaunchTS_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ILaunchTS_GetShooterStates(This,pdwResult)	\
    (This)->lpVtbl -> GetShooterStates(This,pdwResult)

#define ILaunchTS_GetTroubleShooter(This,pbstrShooter)	\
    (This)->lpVtbl -> GetTroubleShooter(This,pbstrShooter)

#define ILaunchTS_GetProblem(This,pbstrProblem)	\
    (This)->lpVtbl -> GetProblem(This,pbstrProblem)

#define ILaunchTS_GetNode(This,iNode,pbstrNode)	\
    (This)->lpVtbl -> GetNode(This,iNode,pbstrNode)

#define ILaunchTS_GetState(This,iNode,pbstrState)	\
    (This)->lpVtbl -> GetState(This,iNode,pbstrState)

#define ILaunchTS_GetMachine(This,pbstrMachine)	\
    (This)->lpVtbl -> GetMachine(This,pbstrMachine)

#define ILaunchTS_GetPNPDevice(This,pbstr)	\
    (This)->lpVtbl -> GetPNPDevice(This,pbstr)

#define ILaunchTS_GetGuidClass(This,pbstr)	\
    (This)->lpVtbl -> GetGuidClass(This,pbstr)

#define ILaunchTS_GetDeviceInstance(This,pbstr)	\
    (This)->lpVtbl -> GetDeviceInstance(This,pbstr)

#define ILaunchTS_Test(This)	\
    (This)->lpVtbl -> Test(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ILaunchTS_GetShooterStates_Proxy( 
    ILaunchTS __RPC_FAR * This,
    /* [retval][out] */ DWORD __RPC_FAR *pdwResult);


void __RPC_STUB ILaunchTS_GetShooterStates_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ILaunchTS_GetTroubleShooter_Proxy( 
    ILaunchTS __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrShooter);


void __RPC_STUB ILaunchTS_GetTroubleShooter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ILaunchTS_GetProblem_Proxy( 
    ILaunchTS __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrProblem);


void __RPC_STUB ILaunchTS_GetProblem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ILaunchTS_GetNode_Proxy( 
    ILaunchTS __RPC_FAR * This,
    /* [in] */ short iNode,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrNode);


void __RPC_STUB ILaunchTS_GetNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ILaunchTS_GetState_Proxy( 
    ILaunchTS __RPC_FAR * This,
    /* [in] */ short iNode,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrState);


void __RPC_STUB ILaunchTS_GetState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ILaunchTS_GetMachine_Proxy( 
    ILaunchTS __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrMachine);


void __RPC_STUB ILaunchTS_GetMachine_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ILaunchTS_GetPNPDevice_Proxy( 
    ILaunchTS __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB ILaunchTS_GetPNPDevice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ILaunchTS_GetGuidClass_Proxy( 
    ILaunchTS __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB ILaunchTS_GetGuidClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ILaunchTS_GetDeviceInstance_Proxy( 
    ILaunchTS __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB ILaunchTS_GetDeviceInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ILaunchTS_Test_Proxy( 
    ILaunchTS __RPC_FAR * This);


void __RPC_STUB ILaunchTS_Test_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ILaunchTS_INTERFACE_DEFINED__ */


#ifndef __ITShootATL_INTERFACE_DEFINED__
#define __ITShootATL_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITShootATL
 * at Mon Nov 23 13:59:17 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_ITShootATL;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("66AC81E5-8926-11D1-8B7D-0060089BD8C4")
    ITShootATL : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SpecifyProblem( 
            /* [in] */ BSTR bstrNetwork,
            /* [in] */ BSTR bstrProblem,
            /* [retval][out] */ DWORD __RPC_FAR *pdwResult) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetNode( 
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR bstrState,
            /* [retval][out] */ DWORD __RPC_FAR *pdwResult) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Language( 
            /* [in] */ BSTR bstrLanguage,
            /* [retval][out] */ DWORD __RPC_FAR *pdwResult) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE MachineID( 
            /* [in] */ BSTR bstrMachineID,
            /* [retval][out] */ DWORD __RPC_FAR *pdwResult) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Test( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DeviceInstanceID( 
            /* [in] */ BSTR bstrDeviceInstanceID,
            /* [retval][out] */ DWORD __RPC_FAR *pdwResult) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ReInit( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE LaunchKnown( 
            /* [retval][out] */ DWORD __RPC_FAR *pdwResult) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LaunchWaitTimeOut( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_LaunchWaitTimeOut( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Launch( 
            /* [in] */ BSTR bstrCallerName,
            /* [in] */ BSTR bstrCallerVersion,
            /* [in] */ BSTR bstrAppProblem,
            /* [in] */ short bLaunch,
            /* [retval][out] */ DWORD __RPC_FAR *pdwResult) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE LaunchDevice( 
            /* [in] */ BSTR bstrCallerName,
            /* [in] */ BSTR bstrCallerVersion,
            /* [in] */ BSTR bstrPNPDeviceID,
            /* [in] */ BSTR bstrDeviceClassGUID,
            /* [in] */ BSTR bstrAppProblem,
            /* [in] */ short bLaunch,
            /* [retval][out] */ DWORD __RPC_FAR *pdwResult) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PreferOnline( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PreferOnline( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetStatus( 
            /* [retval][out] */ DWORD __RPC_FAR *pdwStatus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITShootATLVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITShootATL __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITShootATL __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITShootATL __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITShootATL __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITShootATL __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITShootATL __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITShootATL __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SpecifyProblem )( 
            ITShootATL __RPC_FAR * This,
            /* [in] */ BSTR bstrNetwork,
            /* [in] */ BSTR bstrProblem,
            /* [retval][out] */ DWORD __RPC_FAR *pdwResult);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetNode )( 
            ITShootATL __RPC_FAR * This,
            /* [in] */ BSTR bstrName,
            /* [in] */ BSTR bstrState,
            /* [retval][out] */ DWORD __RPC_FAR *pdwResult);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Language )( 
            ITShootATL __RPC_FAR * This,
            /* [in] */ BSTR bstrLanguage,
            /* [retval][out] */ DWORD __RPC_FAR *pdwResult);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MachineID )( 
            ITShootATL __RPC_FAR * This,
            /* [in] */ BSTR bstrMachineID,
            /* [retval][out] */ DWORD __RPC_FAR *pdwResult);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Test )( 
            ITShootATL __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeviceInstanceID )( 
            ITShootATL __RPC_FAR * This,
            /* [in] */ BSTR bstrDeviceInstanceID,
            /* [retval][out] */ DWORD __RPC_FAR *pdwResult);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReInit )( 
            ITShootATL __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LaunchKnown )( 
            ITShootATL __RPC_FAR * This,
            /* [retval][out] */ DWORD __RPC_FAR *pdwResult);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LaunchWaitTimeOut )( 
            ITShootATL __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_LaunchWaitTimeOut )( 
            ITShootATL __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Launch )( 
            ITShootATL __RPC_FAR * This,
            /* [in] */ BSTR bstrCallerName,
            /* [in] */ BSTR bstrCallerVersion,
            /* [in] */ BSTR bstrAppProblem,
            /* [in] */ short bLaunch,
            /* [retval][out] */ DWORD __RPC_FAR *pdwResult);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LaunchDevice )( 
            ITShootATL __RPC_FAR * This,
            /* [in] */ BSTR bstrCallerName,
            /* [in] */ BSTR bstrCallerVersion,
            /* [in] */ BSTR bstrPNPDeviceID,
            /* [in] */ BSTR bstrDeviceClassGUID,
            /* [in] */ BSTR bstrAppProblem,
            /* [in] */ short bLaunch,
            /* [retval][out] */ DWORD __RPC_FAR *pdwResult);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PreferOnline )( 
            ITShootATL __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_PreferOnline )( 
            ITShootATL __RPC_FAR * This,
            /* [in] */ BOOL newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatus )( 
            ITShootATL __RPC_FAR * This,
            /* [retval][out] */ DWORD __RPC_FAR *pdwStatus);
        
        END_INTERFACE
    } ITShootATLVtbl;

    interface ITShootATL
    {
        CONST_VTBL struct ITShootATLVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITShootATL_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITShootATL_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITShootATL_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITShootATL_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITShootATL_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITShootATL_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITShootATL_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITShootATL_SpecifyProblem(This,bstrNetwork,bstrProblem,pdwResult)	\
    (This)->lpVtbl -> SpecifyProblem(This,bstrNetwork,bstrProblem,pdwResult)

#define ITShootATL_SetNode(This,bstrName,bstrState,pdwResult)	\
    (This)->lpVtbl -> SetNode(This,bstrName,bstrState,pdwResult)

#define ITShootATL_Language(This,bstrLanguage,pdwResult)	\
    (This)->lpVtbl -> Language(This,bstrLanguage,pdwResult)

#define ITShootATL_MachineID(This,bstrMachineID,pdwResult)	\
    (This)->lpVtbl -> MachineID(This,bstrMachineID,pdwResult)

#define ITShootATL_Test(This)	\
    (This)->lpVtbl -> Test(This)

#define ITShootATL_DeviceInstanceID(This,bstrDeviceInstanceID,pdwResult)	\
    (This)->lpVtbl -> DeviceInstanceID(This,bstrDeviceInstanceID,pdwResult)

#define ITShootATL_ReInit(This)	\
    (This)->lpVtbl -> ReInit(This)

#define ITShootATL_LaunchKnown(This,pdwResult)	\
    (This)->lpVtbl -> LaunchKnown(This,pdwResult)

#define ITShootATL_get_LaunchWaitTimeOut(This,pVal)	\
    (This)->lpVtbl -> get_LaunchWaitTimeOut(This,pVal)

#define ITShootATL_put_LaunchWaitTimeOut(This,newVal)	\
    (This)->lpVtbl -> put_LaunchWaitTimeOut(This,newVal)

#define ITShootATL_Launch(This,bstrCallerName,bstrCallerVersion,bstrAppProblem,bLaunch,pdwResult)	\
    (This)->lpVtbl -> Launch(This,bstrCallerName,bstrCallerVersion,bstrAppProblem,bLaunch,pdwResult)

#define ITShootATL_LaunchDevice(This,bstrCallerName,bstrCallerVersion,bstrPNPDeviceID,bstrDeviceClassGUID,bstrAppProblem,bLaunch,pdwResult)	\
    (This)->lpVtbl -> LaunchDevice(This,bstrCallerName,bstrCallerVersion,bstrPNPDeviceID,bstrDeviceClassGUID,bstrAppProblem,bLaunch,pdwResult)

#define ITShootATL_get_PreferOnline(This,pVal)	\
    (This)->lpVtbl -> get_PreferOnline(This,pVal)

#define ITShootATL_put_PreferOnline(This,newVal)	\
    (This)->lpVtbl -> put_PreferOnline(This,newVal)

#define ITShootATL_GetStatus(This,pdwStatus)	\
    (This)->lpVtbl -> GetStatus(This,pdwStatus)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITShootATL_SpecifyProblem_Proxy( 
    ITShootATL __RPC_FAR * This,
    /* [in] */ BSTR bstrNetwork,
    /* [in] */ BSTR bstrProblem,
    /* [retval][out] */ DWORD __RPC_FAR *pdwResult);


void __RPC_STUB ITShootATL_SpecifyProblem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITShootATL_SetNode_Proxy( 
    ITShootATL __RPC_FAR * This,
    /* [in] */ BSTR bstrName,
    /* [in] */ BSTR bstrState,
    /* [retval][out] */ DWORD __RPC_FAR *pdwResult);


void __RPC_STUB ITShootATL_SetNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITShootATL_Language_Proxy( 
    ITShootATL __RPC_FAR * This,
    /* [in] */ BSTR bstrLanguage,
    /* [retval][out] */ DWORD __RPC_FAR *pdwResult);


void __RPC_STUB ITShootATL_Language_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITShootATL_MachineID_Proxy( 
    ITShootATL __RPC_FAR * This,
    /* [in] */ BSTR bstrMachineID,
    /* [retval][out] */ DWORD __RPC_FAR *pdwResult);


void __RPC_STUB ITShootATL_MachineID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITShootATL_Test_Proxy( 
    ITShootATL __RPC_FAR * This);


void __RPC_STUB ITShootATL_Test_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITShootATL_DeviceInstanceID_Proxy( 
    ITShootATL __RPC_FAR * This,
    /* [in] */ BSTR bstrDeviceInstanceID,
    /* [retval][out] */ DWORD __RPC_FAR *pdwResult);


void __RPC_STUB ITShootATL_DeviceInstanceID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITShootATL_ReInit_Proxy( 
    ITShootATL __RPC_FAR * This);


void __RPC_STUB ITShootATL_ReInit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITShootATL_LaunchKnown_Proxy( 
    ITShootATL __RPC_FAR * This,
    /* [retval][out] */ DWORD __RPC_FAR *pdwResult);


void __RPC_STUB ITShootATL_LaunchKnown_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITShootATL_get_LaunchWaitTimeOut_Proxy( 
    ITShootATL __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB ITShootATL_get_LaunchWaitTimeOut_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ITShootATL_put_LaunchWaitTimeOut_Proxy( 
    ITShootATL __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB ITShootATL_put_LaunchWaitTimeOut_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITShootATL_Launch_Proxy( 
    ITShootATL __RPC_FAR * This,
    /* [in] */ BSTR bstrCallerName,
    /* [in] */ BSTR bstrCallerVersion,
    /* [in] */ BSTR bstrAppProblem,
    /* [in] */ short bLaunch,
    /* [retval][out] */ DWORD __RPC_FAR *pdwResult);


void __RPC_STUB ITShootATL_Launch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITShootATL_LaunchDevice_Proxy( 
    ITShootATL __RPC_FAR * This,
    /* [in] */ BSTR bstrCallerName,
    /* [in] */ BSTR bstrCallerVersion,
    /* [in] */ BSTR bstrPNPDeviceID,
    /* [in] */ BSTR bstrDeviceClassGUID,
    /* [in] */ BSTR bstrAppProblem,
    /* [in] */ short bLaunch,
    /* [retval][out] */ DWORD __RPC_FAR *pdwResult);


void __RPC_STUB ITShootATL_LaunchDevice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ITShootATL_get_PreferOnline_Proxy( 
    ITShootATL __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB ITShootATL_get_PreferOnline_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE ITShootATL_put_PreferOnline_Proxy( 
    ITShootATL __RPC_FAR * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB ITShootATL_put_PreferOnline_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITShootATL_GetStatus_Proxy( 
    ITShootATL __RPC_FAR * This,
    /* [retval][out] */ DWORD __RPC_FAR *pdwStatus);


void __RPC_STUB ITShootATL_GetStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITShootATL_INTERFACE_DEFINED__ */



#ifndef __LAUNCHSERVLib_LIBRARY_DEFINED__
#define __LAUNCHSERVLib_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: LAUNCHSERVLib
 * at Mon Nov 23 13:59:17 1998
 * using MIDL 3.01.75
 ****************************************/
/* [helpstring][version][uuid] */ 



EXTERN_C const IID LIBID_LAUNCHSERVLib;

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_LaunchTS;

class DECLSPEC_UUID("131CC2A1-7634-11D1-8B6B-0060089BD8C4")
LaunchTS;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_TShootATL;

class DECLSPEC_UUID("66AC81E6-8926-11D1-8B7D-0060089BD8C4")
TShootATL;
#endif
#endif /* __LAUNCHSERVLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\htmlfrag.cpp ===
//
// MODULE: HTMLFrag.cpp
//
// PURPOSE: implementation of the CHTMLFragmentsTS class, which is how CInfer packages
//	up fragments of HTML to be rendered in accord with a template
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 8-27-1998
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		7-20-98		JM		Original
//
//////////////////////////////////////////////////////////////////////

#pragma warning(disable:4786)

#include "stdafx.h"
#include <algorithm>
#include "HTMLFrag.h"
#include "event.h"
#include "baseexception.h"
#include "CharConv.h"
#include "fileread.h"
#ifdef LOCAL_TROUBLESHOOTER
#include "CHMFileReader.h"
#endif

// V3.2 Additions.
namespace
{
	const CString kstrCond_StringCompare=		_T("StringCompare");
	const CString kstrCond_OperatorGT=		_T(".GT.");
	const CString kstrCond_OperatorGE=		_T(".GE.");
	const CString kstrCond_OperatorEQ=		_T(".EQ.");
	const CString kstrCond_OperatorNE=		_T(".NE.");
	const CString kstrCond_OperatorLE=		_T(".LE.");
	const CString kstrCond_OperatorLT=		_T(".LT.");
	const CString kstrCond_OperatorSubstring=	_T(".SubstringOf.");
}

//////////////////////////////////////////////////////////////////////
// CHTMLValue implementation
//////////////////////////////////////////////////////////////////////

bool CHTMLValue::SetValue(const CString& value)
{
	CString strOldValue = m_strValValue;
	m_strValValue = value;
	m_strValValue.TrimLeft();
	m_strValValue.TrimRight();
	if (IsValid())
		return true;
	m_strValValue = strOldValue;
	return false;
}

bool CHTMLValue::IsNumeric()
{
	for (int i = 0; i < m_strValValue.GetLength(); i++)
		if(!_ismbcdigit(m_strValValue[i]))
			return false;
	return true;
}

bool CHTMLValue::IsString()
{
	// string should be wrapped by quots
	if (m_strValValue.GetLength() >= 2 &&
		m_strValValue[0] == _T('"') &&
		m_strValValue[m_strValValue.GetLength()-1] == _T('"')
	   )
	   return true;
	return false;
}

bool CHTMLValue::IsBoolean()
{
	return 0 == _tcsicmp(_T("true"), m_strValValue) || 
		   0 == _tcsicmp(_T("false"), m_strValValue);
}

bool CHTMLValue::GetNumeric(long& out)
{
	if (IsNumeric())
	{
		out = _ttol(m_strValValue);
		return true;
	}
	return false;
}

bool CHTMLValue::GetString(CString& out)
{
	if (IsString())
	{
		out = m_strValValue.Mid(1, m_strValValue.GetLength()-2);
		return true;
	}
	return false;
}

bool CHTMLValue::GetBoolean(bool& out)
{
	if (IsBoolean())
	{
		out = (0 == _tcsicmp(_T("true"), m_strValValue)) ? true : false;
		return true;
	}
	return false;
}

bool CHTMLValue::operator == (const CHTMLValue& sib)
{
	return 0 == _tcsicmp(m_strValName, sib.m_strValName); // case insensitive
}

//////////////////////////////////////////////////////////////////////
// CHTMLFragments implementation
//////////////////////////////////////////////////////////////////////

bool CHTMLFragments::SetValue(const CString& str)
{
	int index = str.Find(_T('='));
	
	if (index == -1)
		return false;

	CString name = str.Left(index);
	name.TrimLeft();
	name.TrimRight();

	CString value= str.Right(str.GetLength() - index - 1);
	value.TrimLeft();
	value.TrimRight();

	CHTMLValue HTMLValue(name, value);
	
	HTMLValueVector::iterator found = find(m_HTMLValueVector.begin(), m_HTMLValueVector.end(), HTMLValue);
	
	if (found != m_HTMLValueVector.end())
		*found = HTMLValue;
	else
		m_HTMLValueVector.push_back(HTMLValue);

	return true;
}

CHTMLValue* CHTMLFragments::GetValue(const CString& value_name)
{
	HTMLValueVector::iterator found = find(m_HTMLValueVector.begin(), m_HTMLValueVector.end(), CHTMLValue(value_name));
	if (found != m_HTMLValueVector.end())
		return found;
	return NULL;
}

//////////////////////////////////////////////////////////////////////
// CHTMLFragmentsTS implementation
//////////////////////////////////////////////////////////////////////

CHTMLFragmentsTS::CHTMLFragmentsTS( const CString & strScriptPath, bool bIncludesHistoryTable ) :
	m_bIncludesHistoryTable(bIncludesHistoryTable),
	m_bIncludesHiddenHistory(!bIncludesHistoryTable),
	m_bSuccess(false),
	m_strYes(_T("Yes")),
    m_strScriptPath(strScriptPath)
{
}

CHTMLFragmentsTS::~CHTMLFragmentsTS()
{
}

// Obviously, a very ad hoc implementation
int CHTMLFragmentsTS::GetCount(const FragmentIDVector & fidvec) const
{
	if (fidvec.empty())
		return 0;

	if (fidvec.back().Index != -1)
		return 0;

	const CString & strVariable = fidvec[0].VarName;	// ref of convenience

	if (fidvec.size() == 1)
	{
		if (strVariable == VAR_PROBLEM_ASK)
			return 1;
		if (strVariable == VAR_RECOMMENDATIONS)
			return m_vstrVisitedNodes.size();
		if (strVariable == VAR_QUESTIONS)
			return 1;
		if (strVariable == VAR_SUCCESS)
			return m_bSuccess ? 1 : 0;
		if (strVariable == VAR_STARTFORM)
			return 1;

		return 0;
	}

	if (fidvec.size() == 2 
	&& strVariable == VAR_RECOMMENDATIONS
	&& fidvec[0].Index >= 0
	&& fidvec[0].Index < m_vvstrStatesOfVisitedNodes.size()
	&& fidvec[1].VarName == VAR_STATES)
	{
		return m_vvstrStatesOfVisitedNodes[fidvec[0].Index].size();
	}

	return 0;
}

// this function was removed from const to achieve further flexibility:
//  we might need to take some active steps in it, as for informational
//  statement we might modify current node text. Oleg. 01.05.99
CString CHTMLFragmentsTS::GetText( const FragmentIDVector & fidvec, const FragCommand fragCmd )
{
	if (fidvec.empty())
		return m_strNil;

	const CString & strVariable0 = fidvec[0].VarName;	// ref of convenience
	int i0 = fidvec[0].Index;

	if (fidvec.size() == 1)
	{
		if (strVariable0 == VAR_PROBLEM_ASK)
			return m_strProblem;

		if (strVariable0 == VAR_RECOMMENDATIONS
		&& i0 >= 0
		&& i0 < m_vstrVisitedNodes.size() )
		{
			return m_vstrVisitedNodes[i0];
		}

		if (strVariable0 == VAR_QUESTIONS)
			return m_strCurrentNode;

		if (strVariable0 == VAR_SUCCESS)
			return m_bSuccess ? m_strYes : m_strNil;

		if (strVariable0 == VAR_STARTFORM)
			return m_strStartForm;

		if (fragCmd == eResource)
		{
			// Load a server side include file.
			CString strScriptContent;
			CString strFullPath = m_strScriptPath + strVariable0;

			CFileReader fileReader(	CPhysicalFileReader::makeReader( strFullPath ) );

			if (fileReader.Read())
			{
				fileReader.GetContent(strScriptContent);
				return strScriptContent;
			}
		}

		// Check for new conditionals added in V3.2.
		CString strTemp= strVariable0.Left( kstrCond_NumericCompare.GetLength() );
		if (strTemp == kstrCond_NumericCompare)
		{
			// Evaluate the numeric expression.
			if (NumericConditionEvaluatesToTrue( strVariable0.Mid( kstrCond_NumericCompare.GetLength() )))
				return( m_strYes );
			return( m_strNil );
		}
		strTemp= strVariable0.Left( kstrCond_StringCompare.GetLength() );
		if (strTemp == kstrCond_StringCompare)
		{
			// Evaluate the string expression.
			if (StringConditionEvaluatesToTrue( strVariable0.Mid( kstrCond_StringCompare.GetLength() )))
				return( m_strYes );
			return( m_strNil );
		}

		return m_strNil;
	}


	const CString & strVariable1 = fidvec[1].VarName;	// ref of convenience
	int i1 = fidvec[1].Index;

	if (fidvec.size() == 2 
	&& strVariable0 == VAR_RECOMMENDATIONS
	&& i0 >= 0
	&& i0 < m_vvstrStatesOfVisitedNodes.size()
	&& strVariable1 == VAR_STATES
	&& i1 >= 0
	&& i1 < m_vvstrStatesOfVisitedNodes[i0].size() )
		return (m_vvstrStatesOfVisitedNodes[i0][i1]);

	// V3.2
	// The specification for the v3.2 cookies called for permitting underscores
	// in cookie names.  The HTI reader already used underscores to delimit
	// variables.  The code below detects a comparision operation that has been
	// broken up due to the presence of underscores and reassembles it.
	// RAB-19991019.
	{
		// Check for new conditionals added in V3.2.
		int nOpType= 0;
		CString strTemp= strVariable0.Left( kstrCond_NumericCompare.GetLength() );
		if (strTemp == kstrCond_NumericCompare)
			nOpType= 1;
		else
		{
			strTemp= strVariable0.Left( kstrCond_StringCompare.GetLength() );
			if (strTemp == kstrCond_StringCompare)
				nOpType= 2;
		}

		if (nOpType)
		{
			// Reassemble the comparison operation.  
			CString strCompareOp= fidvec[0].VarName;
			for (int nItem= 1; nItem < fidvec.size(); nItem++)
			{
				strCompareOp+= _T("_");	// Reinsert the delimiter that was removed during the parse.
				strCompareOp+= fidvec[ nItem ].VarName;
			}

			if (nOpType == 1)
			{
				// Evaluate the numeric expression.
				if (NumericConditionEvaluatesToTrue( strCompareOp.Mid( kstrCond_NumericCompare.GetLength() )))
					return( m_strYes );
			}
			else
			{
				// Evaluate the string expression.
				if (StringConditionEvaluatesToTrue( strCompareOp.Mid( kstrCond_StringCompare.GetLength() )))
					return( m_strYes );
			}

			return( m_strNil );
		}
	}

	return m_strNil;
}

bool CHTMLFragmentsTS::IsValidSeqOfVars(const FragmentIDVector & arrParents, const FragmentIDVector & arrChildren) const
{
	// we allow only one level of nesting
	//  that means in "forany" of $Recommendations we can have "forany" array of $States
	if (arrParents.size() == 1 && arrChildren.size() == 1)
		if (arrParents[0].VarName == VAR_RECOMMENDATIONS  && arrChildren[0].VarName == VAR_STATES)
			return true;
	return false;
}

void CHTMLFragmentsTS::SetStartForm(const CString & str)
{
	m_strStartForm = str;
}
	
void CHTMLFragmentsTS::SetProblemText(const CString & str)
{
	if (m_bIncludesHistoryTable)
		m_strProblem = str;
}
	
void CHTMLFragmentsTS::SetCurrentNodeText(const CString & str)
{
	m_strCurrentNodeSimple = str;
	RebuildCurrentNodeText();
}

void CHTMLFragmentsTS::SetHiddenHistoryText(const CString & str)
{
	if (m_bIncludesHiddenHistory)
	{
		m_strHiddenHistory = str;
		RebuildCurrentNodeText();
	}
}

// need only be called for bSuccess == true (false is default) but written more generally.
void CHTMLFragmentsTS::SetSuccessBool(bool bSuccess)
{
	m_bSuccess = bSuccess;
}
	
CString CHTMLFragmentsTS::GetCurrentNodeText()
{
	return m_strCurrentNodeSimple;
}

// must be called in order nodes were visited.  Do not call for problem node.
// return index of added node
int CHTMLFragmentsTS::PushBackVisitedNodeText(const CString & str)
{
	if (m_bIncludesHistoryTable)
	{
		try
		{
			m_vstrVisitedNodes.push_back(str);
		}
		catch (exception& x)
		{
			CString str;
			// Note STL exception in event log.
			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									CCharConversion::ConvertACharToString(x.what(), str), 
									_T(""), 
									EV_GTS_STL_EXCEPTION ); 
		}
		return m_vstrVisitedNodes.size() - 1;
	}
	return -1;
}

// For each given iVisitedNode, must be called in order of state number, 
//	with ST_UNKNOWN last
// return index of added state
int CHTMLFragmentsTS::PushBackStateText(UINT iVisitedNode, const CString & str)
{
	if (m_bIncludesHistoryTable)
	{
		try
		{
			// Check if we need to add one or more elements to the vector of nodes.
			if (m_vvstrStatesOfVisitedNodes.size() <= iVisitedNode)
			{
				// Check if we need to add more than one element to the vector of nodes.
				if (m_vvstrStatesOfVisitedNodes.size() < iVisitedNode)
				{
					// We need to add more than one element to the vector of nodes.
					// This condition should not be occurring, so log it.
					CString tmpStrCurCnt, tmpStrReqCnt;

					tmpStrCurCnt.Format( _T("%d"), m_vvstrStatesOfVisitedNodes.size() );
					tmpStrReqCnt.Format( _T("%d"), iVisitedNode );
					CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
					CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
											SrcLoc.GetSrcFileLineStr(), 
											tmpStrCurCnt, tmpStrReqCnt, 
											EV_GTS_NODE_COUNT_DISCREPANCY );  


					// Add to the vector of nodes until we have placed a total of
					// iVisitedNode elements into the vector.  We are inserting empty
					// states as the first element of the vector of states for a node.
					vector<CString> vecDummy;
					vecDummy.push_back( _T("") );
					do
					{
						m_vvstrStatesOfVisitedNodes.push_back( vecDummy );
					}
					while (m_vvstrStatesOfVisitedNodes.size() < iVisitedNode);
				}

				// Add this state string as the first element of the vector of states for a node.
				vector<CString> tmpVector;
				tmpVector.push_back( str );
				m_vvstrStatesOfVisitedNodes.push_back( tmpVector );
			}
			else
			{
				// Add this state string to the vector of states for a node.
				m_vvstrStatesOfVisitedNodes[iVisitedNode].push_back(str);
			}
		}
		catch (exception& x)
		{
			CString str;
			// Note STL exception in event log.
			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									CCharConversion::ConvertACharToString(x.what(), str), 
									_T(""),
									EV_GTS_STL_EXCEPTION ); 
		}
		return m_vvstrStatesOfVisitedNodes[iVisitedNode].size() - 1;
	}
	return -1;
}

// call this function to find out if there is any need for a history table.
// If not, calling class can save the effort of constructing one:
//	SetProblemText(), AppendVisitedNodeText(), AppendStateText()
//	becomes no-ops, so no need to construct strings and call them
bool CHTMLFragmentsTS::IncludesHistoryTable() const
{
	return m_bIncludesHistoryTable;
}

// call this function to find out if there is any need for "hidden history"
// If not, calling class can save the effort of constructing one:
//	SetHiddenHistoryText() becomes a no-op, so no need to construct a string and call it
bool CHTMLFragmentsTS::IncludesHiddenHistory() const
{
	return m_bIncludesHiddenHistory;
}

void CHTMLFragmentsTS::RebuildCurrentNodeText()
{
	m_strCurrentNode = m_strHiddenHistory;
	m_strCurrentNode += m_strCurrentNodeSimple; 
}


// Function which parses and evaluates a numeric condition.
bool CHTMLFragmentsTS::NumericConditionEvaluatesToTrue( const CString & str )
{
	bool bRetVal= false;
	CString strScratch= RemoveOuterParenthesis( str );

	if (strScratch.GetLength())
	{
		long lLeftOperand, lRightOperand;

		// Check for all supported operators.
		if (RetNumericOperands( strScratch, kstrCond_OperatorGT, lLeftOperand, lRightOperand ))
		{
			// .GT. case.
			bRetVal= (lLeftOperand > lRightOperand) ? true : false;
		}
		else if (RetNumericOperands( strScratch, kstrCond_OperatorGE, lLeftOperand, lRightOperand ))
		{
			// .GE. case.
			bRetVal= (lLeftOperand >= lRightOperand) ? true : false;
		}
		else if (RetNumericOperands( strScratch, kstrCond_OperatorEQ, lLeftOperand, lRightOperand ))
		{
			// .EQ. case.
			bRetVal= (lLeftOperand == lRightOperand) ? true : false;
		}
		else if (RetNumericOperands( strScratch, kstrCond_OperatorNE, lLeftOperand, lRightOperand ))
		{
			// .NE. case.
			bRetVal= (lLeftOperand != lRightOperand) ? true : false;
		}
		else if (RetNumericOperands( strScratch, kstrCond_OperatorLE, lLeftOperand, lRightOperand ))
		{
			// .LE. case.
			bRetVal= (lLeftOperand <= lRightOperand) ? true : false;
		}
		else if (RetNumericOperands( strScratch, kstrCond_OperatorLT, lLeftOperand, lRightOperand ))
		{
			// .LT. case.
			bRetVal= (lLeftOperand < lRightOperand) ? true : false;
		}
	}

	return( bRetVal );
}


// Function which parses and evaluates a string condition.
bool CHTMLFragmentsTS::StringConditionEvaluatesToTrue( const CString & str )
{
	bool bRetVal= false;
	CString strScratch= RemoveOuterParenthesis( str );

	if (strScratch.GetLength())
	{
		CString strLeftOperand, strRightOperand;

		// Check for all supported operators.
		if (RetStringOperands( strScratch, kstrCond_OperatorEQ, strLeftOperand, strRightOperand ))
		{
			if ((strLeftOperand.GetLength() == strRightOperand.GetLength()) &&
				(_tcsicmp( strLeftOperand, strRightOperand ) == 0))
				bRetVal= true;
		}
		else if (RetStringOperands( strScratch, kstrCond_OperatorNE, strLeftOperand, strRightOperand ))
		{
			if ((strLeftOperand.GetLength() != strRightOperand.GetLength()) ||
				(_tcsicmp( strLeftOperand, strRightOperand ) != 0))
				bRetVal= true;
		}
		else if (RetStringOperands( strScratch, kstrCond_OperatorSubstring, strLeftOperand, strRightOperand ))
		{
			int nLeftLen= strLeftOperand.GetLength();
			int nRightLen= strRightOperand.GetLength();
			if ((nLeftLen) && (nRightLen) && (nLeftLen <= nRightLen))
			{
				strLeftOperand.MakeLower();
				strRightOperand.MakeLower();
				if (_tcsstr( strRightOperand, strLeftOperand ) != NULL)
					bRetVal= true;
			}
		}
	}

	return( bRetVal );
}


// Function to peel off the outer parenthesis of a condition.
CString CHTMLFragmentsTS::RemoveOuterParenthesis( const CString & str )
{
	CString strRet;
	int	nOrigLength= str.GetLength();

	if (nOrigLength > 2)
	{
		TCHAR cFirstChar= str.GetAt( 0 );
		TCHAR cLastChar= str.GetAt( nOrigLength - 1 );

		if ((cFirstChar == _T('(')) && (cLastChar == _T(')')))
			strRet= str.Mid( 1, nOrigLength - 2 );
	}
	return( strRet );
}


// Breaks out the numeric operands from a string.
bool CHTMLFragmentsTS::RetNumericOperands(	const CString & str, const CString & strOperator,
											long &lLeftOperand, long &lRightOperand )
{
	bool	bRetVal= false;
	int		nOffset= str.Find( strOperator );

	if (nOffset != -1)
	{
		CString strScratch= str.Left( nOffset - 1 );

		strScratch.TrimRight();
		strScratch.TrimLeft();
		if (strScratch.GetLength())
		{
			lLeftOperand= atol( strScratch );

			strScratch= str.Mid( nOffset + strOperator.GetLength() );
			strScratch.TrimRight();
			strScratch.TrimLeft();
			if (strScratch.GetLength())
			{
				lRightOperand= atol( strScratch );
				bRetVal= true;
			}
		}
	}

	return( bRetVal );
}


// Breaks out the string operands from a string.
bool CHTMLFragmentsTS::RetStringOperands(	const CString & str, const CString & strOperator,
											CString & strLeftOperand, CString & strRightOperand )
{
	bool	bRetVal= false;
	int		nOffset= str.Find( strOperator );

	if (nOffset != -1)
	{
		strLeftOperand= str.Left( nOffset - 1 );
		if (CleanStringOperand( strLeftOperand ))
		{
			strRightOperand= str.Mid( nOffset + strOperator.GetLength() );
			strRightOperand.TrimRight();
			strRightOperand.TrimLeft();
			if (CleanStringOperand( strRightOperand ))
				bRetVal= true;
		}
	}

	return( bRetVal );
}

// Trims an operand string and replaces embedded characters.
int CHTMLFragmentsTS::CleanStringOperand( CString& strOperand )
{
	int nRetLength= 0;
	if (!strOperand.IsEmpty())
	{
		strOperand.TrimRight();
		strOperand.TrimLeft();
		nRetLength= strOperand.GetLength();
		if (nRetLength > 2)
		{
			if ((strOperand[ 0 ] == _T('\"')) && (strOperand[ nRetLength - 1 ] == _T('\"')))
			{
				// V3.2 Remove the surrounding double quotes.
				nRetLength-= 2;
				strOperand= strOperand.Mid( 1, nRetLength );
			}

			// V3.2  Replace embedded quotes or backslashes within the string.
			for (int nOp= 0; nOp < 2; nOp++)
			{
				// Set the search and replacement strings.
				CString strSearch, strReplace;
				if (nOp)
				{
					// Replace backslashes.
					strSearch= _T("\\\\");
					strReplace= _T("\\");
				}
				else
				{
					// Replace double quotes.
					strSearch= _T("\\\"");
					strReplace= _T("\"");
				}

				// Search and replace.
				int nStart= 0, nEnd;
				while (CString::FIND_FAILED != (nStart= strOperand.Find( strSearch, nStart )))
				{
					nEnd= nStart + strSearch.GetLength();
					strOperand= strOperand.Left( nStart ) + strReplace + strOperand.Mid( nEnd );
					nStart+= strReplace.GetLength();	// Move search past the character that was just replaced.
				}
			}
		}
	}

	return( nRetLength );
}

// JSM V3.2
// called by HTIReader in parsing stage to convert network property name, given
// in  <$GTS property "propname">, to network property (value).
//
CString CHTMLFragmentsTS::GetNetProp(const CString & strNetPropName)
{
	map<CString,CString>::iterator it = m_mapstrNetProps.find(strNetPropName);

	if (it == m_mapstrNetProps.end())
		return _T("\0"); // not found
	else 
		return (*it).second;
}

// JSM V3.2
//  add a name to the internal list (map) of Net props which are needed
//   by this Fragments object
//
//    CAPGTSHTIReader finds the names of the network properties and passes
//       them in via AddNetPropName, but it doesn't know how to get the values.
//    CInfer will later get the network property names from Fragments object, call the BNTS
//       to find out the network property values, and supply the values to Fragments
//
// 
void CHTMLFragmentsTS::AddNetPropName(const CString & strNetPropName)
{
	// don't insert a NULL key!!!
	if (!strNetPropName.IsEmpty())
		m_mapstrNetProps[strNetPropName];
}

// JSM V3.2
// SetNetProp()
//
//  For a Network Property Name in our internal map, set the
//  corresponding network property (ie, fill in the map value
//   for that key.) Called by CInfer, which is the object that knows how
//   to talk to the BNTS.
//
// returns TRUE if success
//         FALSE if we've given a NetPropName which is not in the internal map
// 
BOOL CHTMLFragmentsTS::SetNetProp(CString strNetPropName, CString strNetProp)
{
	map<CString,CString>::iterator it;

	if ((it= m_mapstrNetProps.find(strNetPropName)) == m_mapstrNetProps.end())
		return false;

	m_mapstrNetProps[strNetPropName] = strNetProp;
	return true;
}

// JSM V3.2
// IterateNetProp()
//  Called to iterate through the network properties in our internal
//  map during the setting process (see above.)
//
//     Sets strNameIterator to the name of the next net prop in the map. 
//
//     calling w/ an empty (NULL) key starts the iteration.
//     calling w/ a name that's not in the map returns false.
//     calling w/ any other name returns true, unless at end of iteration
//
//   strNameIterator is not valid if this function returns false. 
// 
BOOL CHTMLFragmentsTS::IterateNetProp(CString & strNameIterator)
{
	map<CString,CString>::iterator it;

	if (strNameIterator.IsEmpty())
	{
		// request to start iteration, if possible
		if (m_mapstrNetProps.empty())
			return false; // we're at end already
		it = m_mapstrNetProps.begin();
	}
	else if ((it= m_mapstrNetProps.find(strNameIterator)) != m_mapstrNetProps.end())
	{
		// iterate:
		if (++it == m_mapstrNetProps.end())
			return false;   // arrived at end
	}
	else
	{
		// invalid key 
		return false;
	}

	strNameIterator = (*it).first;
	return true;

}

// V3.2 enhancement for the Start Over button.
void CHTMLFragmentsTS::SetStartOverLink( const CString & str )
{
	m_strStartOverLink = str;
}

// V3.2 enhancement for the Start Over button.
CString CHTMLFragmentsTS::GetStartOverLink()
{
	return m_strStartOverLink;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\localdirmonitor.cpp ===
// LocalDirMonitor.cpp: implementation of the CLocalDirectoryMonitor class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "LocalDirMonitor.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CLocalDirectoryMonitor::CLocalDirectoryMonitor()
					  :	CLocalDirectoryMonitor()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\launchserv_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 3.01.75 */
/* at Mon Nov 23 13:59:17 1998
 */
/* Compiler settings for LaunchServ.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_ILaunchTS = {0x131CC2A0,0x7634,0x11D1,{0x8B,0x6B,0x00,0x60,0x08,0x9B,0xD8,0xC4}};


const IID IID_ITShootATL = {0x66AC81E5,0x8926,0x11D1,{0x8B,0x7D,0x00,0x60,0x08,0x9B,0xD8,0xC4}};


const IID LIBID_LAUNCHSERVLib = {0x131CC291,0x7634,0x11D1,{0x8B,0x6B,0x00,0x60,0x08,0x9B,0xD8,0xC4}};


const CLSID CLSID_LaunchTS = {0x131CC2A1,0x7634,0x11D1,{0x8B,0x6B,0x00,0x60,0x08,0x9B,0xD8,0xC4}};


const CLSID CLSID_TShootATL = {0x66AC81E6,0x8926,0x11D1,{0x8B,0x7D,0x00,0x60,0x08,0x9B,0xD8,0xC4}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\localdirmonitor.h ===
// LocalDirMonitor.h: interface for the CLocalDirectoryMonitor class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_LOCALDIRMONITOR_H__9E418C74_B256_11D2_8C8D_00C04F949D33__INCLUDED_)
#define AFX_LOCALDIRMONITOR_H__9E418C74_B256_11D2_8C8D_00C04F949D33__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "DirMonitor.h"

class CLocalDirectoryMonitor : public CDirectoryMonitor  
{
	CString m_strTopicName;

public:
	CLocalDirectoryMonitor();

public:
	void SetTopicName(const CString& strTopicName) {m_strTopicName = strTopicName;}
};

#endif // !defined(AFX_LOCALDIRMONITOR_H__9E418C74_B256_11D2_8C8D_00C04F949D33__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\locallstreader.cpp ===
//
// MODULE:	LocalLSTReader.H
//
// PURPOSE: Implementation of the CLocalLSTReader class.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint - Local TS only
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR:	Oleg Kalosha
// 
// ORIGINAL DATE: 01-22-99
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.1		01-22-99	OK		Original
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "LocalLSTReader.h"
#include "apgts.h"
#include "apgtsregconnect.h"

//////////////////////////////////////////////////////////////////////
// CLocalTopicInfo
//////////////////////////////////////////////////////////////////////

bool CLocalTopicInfo::Init(CString & strResourcePath, vector<CString> & vecstrWords)
{
	for (vector<CString>::iterator i = vecstrWords.begin(); i != vecstrWords.end(); i++)
	{
		CString str_extension = CString(_T(".")) + CAbstractFileReader::GetJustExtension(*i);

		str_extension.MakeLower();
		if (str_extension == m_TopicFileExtension)
		{
			m_DscFilePath = ::FormFullPath(strResourcePath, *i);
			m_DscFilePath.MakeLower();
			if (! m_NetworkName.GetLength()) 
			{
				m_NetworkName = *i;
				int len = m_NetworkName.GetLength()-(m_TopicFileExtension.GetLength());
				m_NetworkName = m_NetworkName.Left(len);
				m_NetworkName.MakeLower();
			}
		}
	}

	return CTopicInfo::Init(strResourcePath, vecstrWords);
}

//////////////////////////////////////////////////////////////////////
// CLocalLSTReader
//////////////////////////////////////////////////////////////////////

CLocalLSTReader::CLocalLSTReader(CPhysicalFileReader* pPhysicalFileReader, const CString& strTopicName)
			   : CAPGTSLSTReader(pPhysicalFileReader),
			     m_strTopicName(strTopicName)
{
	CAPGTSRegConnector APGTSRegConnector(m_strTopicName);
	int stub1 =0, stub2 =0;

	if (!APGTSRegConnector.Read(stub1, stub2) ||
		!APGTSRegConnector.GetStringInfo(CAPGTSRegConnector::eTopicFileExtension, m_strTopicFileExtension))
	{
		m_strTopicFileExtension = APGTSLSTREAD_DSC;
	}
	else
	{
		m_strTopicFileExtension.MakeLower();
	}
}

void CLocalLSTReader::Open()
{
}

void CLocalLSTReader::ReadData(LPTSTR * ppBuf)
{
	CString data;

	data += CFG_HEADER;
	data += _T("\r\n");
	data += m_strTopicName + m_strTopicFileExtension;
	data += _T(",");
	data += m_strTopicName + APGTSLSTREAD_HTI;
	data += _T(",");
	data += m_strTopicName + APGTSLSTREAD_TSC;
	data += _T(",");
	data += m_strTopicName;

	*ppBuf = new TCHAR[data.GetLength() + 1];
	//[BC-03022001] - added check for NULL ptr to satisfy MS code analysis tool.
	if(*ppBuf)
	{
		memcpy(*ppBuf, (LPCTSTR)data, data.GetLength());
		(*ppBuf)[data.GetLength()] = 0;
	}
}

void CLocalLSTReader::Close()
{
}

CTopicInfo* CLocalLSTReader::GenerateTopicInfo()
{
	return new CLocalTopicInfo(m_strTopicFileExtension);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\locallstreader.h ===
//
// MODULE:	LocalLSTReader.H
//
// PURPOSE: Interface of the CLocalLSTReader class.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint - Local TS only
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR:	Oleg Kalosha
// 
// ORIGINAL DATE: 01-22-99
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.1		01-22-99	OK		Original
//
//////////////////////////////////////////////////////////////////////


#if !defined(AFX_LOCALLSTREADER_H__9E418C73_B256_11D2_8C8D_00C04F949D33__INCLUDED_)
#define AFX_LOCALLSTREADER_H__9E418C73_B256_11D2_8C8D_00C04F949D33__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "apgtslstread.h"


class CLocalTopicInfo : public CTopicInfo
{
	CString m_TopicFileExtension;

public:
	CLocalTopicInfo(CString ext) : CTopicInfo(), m_TopicFileExtension(ext) {}

public:
	virtual bool Init(CString & strResourcePath, vector<CString> & vecstrWords);
};


class CLocalLSTReader : public CAPGTSLSTReader  
{
	CString m_strTopicName;
	CString	m_strTopicFileExtension;

public:
	CLocalLSTReader(CPhysicalFileReader* pPhysicalFileReader, const CString& strTopicName);

protected:
	virtual void Open();
	virtual void ReadData(LPTSTR * ppBuf);
	virtual void Close();
	virtual CTopicInfo* GenerateTopicInfo();
};

#endif // !defined(AFX_LOCALLSTREADER_H__9E418C73_B256_11D2_8C8D_00C04F949D33__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\localregconnect.cpp ===
//
// MODULE: LOCALREGCONNECT.CPP
//
// PURPOSE: read - write to the registry; simulate this in some cases where Online TS uses
//	registry, but Local TS doesn't
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha, Joe Mabel
// 
// ORIGINAL DATE: 8-24-98 in Online TS
//
// NOTES: 
//	1. This file is for Local TS only
//	2. If we are moving toward a COM object at some point, we will probably have to establish an
//		abstract class in lieu of CAPGTSRegConnector and have Online & Local TS's each derive their
//		own version.  Meanwhile (1/99), we share a common interface (defined in APGTSRegConnect.h)
//		but implement it differently.
//	3. >>> WORK IN PROGRESS !!!!  JM 1/19/98
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		08-04-98	OK
// V3.0		09-10-98	JM		backslashing; access log file info
// V3.1		01-19-98	JM		branch out version exclusively for Local TS

#pragma warning(disable:4786)

#include "stdafx.h"
#include "apgtsregconnect.h"
#include "event.h"
#include "apgtsevt.h"
#include "apgtscls.h"
#include "apgts.h"
#include "apiwraps.h"
#include "CHMFileReader.h"

#define REG_LOCAL_TS_LOC		_T("SOFTWARE\\Microsoft")
LPCTSTR CAPGTSRegConnector::RegSoftwareLoc() {return REG_LOCAL_TS_LOC;}
#define REG_LOCAL_TS_PROGRAM	_T("TShoot")
LPCTSTR CAPGTSRegConnector::RegThisProgram() {return REG_LOCAL_TS_PROGRAM;}
// subordinate key, child to the above and parent to keys for individual troubleshooter topics.
#define REG_LOCAL_TS_LIST		_T("TroubleshooterList")
// where the topic-specific resource path is located ("\TroubleshooterList\Topic_name\Path"):
#define TOPICRESOURCE_STR		_T("Path")
// where the topic-specific resource path is located ("\TroubleshooterList\Topic_name\Path"):
#define TOPICFILE_EXTENSION_STR	_T("FExtension")

// registry value defaults
// Most relevant values differ from Online TS

// (Looks like old Local TS uses the same default resource path as Online TS, so we'll
//	preserve that here >>> till we work out what's right - JM 1/19/99)
#define DEF_FULLRESOURCE			_T("c:\\inetsrv\\scripts\\apgts\\resource")

#define DEF_VROOTPATH				_T("/scripts/apgts/apgts.dll")  // (irrelevant in Local TS)
#define DEF_MAX_THREADS				1				// only 1 pool thread in Local TS
#define DEF_THREADS_PER_PROCESSOR	1				// only 1 pool thread in Local TS
#define DEF_MAX_WORK_QUEUE_ITEMS	1				// only 1 work queue item at a time in Local TS
#define DEF_COOKIE_LIFE_IN_MINS		90				// (irrelevant in Local TS)
#define DEF_RELOAD_DELAY			50				// (irrelevant in Local TS)
#define DEF_DETAILED_EVENT_LOGGING	0
#define DEF_TOPICFILE_EXTENSION		_T(".dsc")
#define DEF_SNIFF_AUTOMATIC			1
#define DEF_SNIFF_MANUAL			1

////////////////////////////////////////////////////////////////////////////////////
// CAPGTSRegConnector::CRegistryInfo
////////////////////////////////////////////////////////////////////////////////////
void CAPGTSRegConnector::CRegistryInfo::SetToDefault()
{
	// Attempt to extract a default resource path based upon the DLL name.
	// It was a deliberate decision to utilize the existing global module handle. 
	strResourcePath= _T("");
	if (INVALID_HANDLE_VALUE != ghModule)
	{
		// Build the default resource path from the module name.
		DWORD len;
		TCHAR szModulePath[MAXBUF];
		CString strModulePath;

		len = ::GetModuleFileName( reinterpret_cast<HMODULE>(ghModule), szModulePath, MAXBUF - 1 );
		if (len!=0) 
		{
			szModulePath[len] = _T('\0');
			strModulePath = szModulePath;
			strResourcePath = CAbstractFileReader::GetJustPath(strModulePath);
			if (!strResourcePath.IsEmpty())
				strResourcePath += _T("\\resource\\");
		}
	}
	if (strResourcePath.IsEmpty())
		strResourcePath = DEF_FULLRESOURCE;

	strVrootPath = DEF_VROOTPATH;
	dwMaxThreads = DEF_MAX_THREADS;
	dwThreadsPP = DEF_THREADS_PER_PROCESSOR;
	dwMaxWQItems = DEF_MAX_WORK_QUEUE_ITEMS;
	dwCookieLife = DEF_COOKIE_LIFE_IN_MINS;
	dwReloadDelay = DEF_RELOAD_DELAY;
	dwDetailedEventLogging	= DEF_DETAILED_EVENT_LOGGING;
	dwSniffAutomatic = DEF_SNIFF_AUTOMATIC;
	dwSniffManual = DEF_SNIFF_MANUAL;
	strLogFilePath = DEF_FULLRESOURCE;
	strTopicFileExtension = DEF_TOPICFILE_EXTENSION;
	m_bIsRead = false;
}

////////////////////////////////////////////////////////////////////////////////////
// CAPGTSRegConnector
////////////////////////////////////////////////////////////////////////////////////
CAPGTSRegConnector::CAPGTSRegConnector(const CString& strTopicName)
				  :	m_strTopicName(strTopicName)
{
	Clear();
}

// OUTPUT maskChanged  or-ed ERegConnector-based mask of elements that have been 
//						changed since last read
// OUTPUT maskCreated  In Online TS, this is 
//						or-ed ERegConnector-based mask of elements that were created 
//						in registry (because they previously didn't exist in registry)
//						In Local TS, it always returns 0, because we don't do this.
void CAPGTSRegConnector::ReadUpdateRegistry(int & maskChanged, int & maskCreated)
{
	CRegUtil reg;
	bool was_created = false;
	CString str_tmp;
	DWORD dw_tmp = 0;

	maskChanged = 0;
	maskCreated = 0;
	try
	{
		// [BC - 20010302] - Registry access needs to be restricted to run local TShoot
		// for certain user accts, such as WinXP built in guest acct. To minimize change
		// access only restricted for local TShoot, not online.
		REGSAM samRegistryAccess= KEY_QUERY_VALUE | KEY_NOTIFY;
		if(RUNNING_ONLINE_TS())
			samRegistryAccess= KEY_QUERY_VALUE | KEY_WRITE;
		if (reg.Create(HKEY_LOCAL_MACHINE, RegSoftwareLoc(), &was_created, samRegistryAccess))
		{
			if(RUNNING_ONLINE_TS())
				samRegistryAccess= KEY_READ | KEY_WRITE;
			if (reg.Create(RegThisProgram(), &was_created, samRegistryAccess))
			{
				/////////////////////////////////////////////////////////////////////////////
				// Working in ...\TShoot root key
				reg.GetNumericValue(SNIFF_AUTOMATIC_STR, m_RegistryInfo.dwSniffAutomatic);

				/////////////////////////////////////////////////////////////////////////////
				// Working in ...\TShoot root key
				reg.GetNumericValue(SNIFF_MANUAL_STR, m_RegistryInfo.dwSniffManual);

				/////////////////////////////////////////////////////////////////////////////
				// VROOTPATH_STR code suppressed in Local TS

				/////////////////////////////////////////////////////////////////////////////
				// MAX_THREADS_STR code suppressed in Local TS

				/////////////////////////////////////////////////////////////////////////////
				// THREADS_PER_PROCESSOR_STR code suppressed in Local TS

				/////////////////////////////////////////////////////////////////////////////
				// MAX_WORK_QUEUE_ITEMS_STR code suppressed in Local TS

				/////////////////////////////////////////////////////////////////////////////
				// COOKIE_LIFE_IN_MINS_STR code suppressed in Local TS

				/////////////////////////////////////////////////////////////////////////////
				// RELOAD_DELAY_STR code suppressed in Local TS

				/////////////////////////////////////////////////////////////////////////////
				// DETAILED_EVENT_LOGGING_STR code suppressed in Local TS

				/////////////////////////////////////////////////////////////////////////////
				// Now opening subkeys
				bool bFullResourceStrExists = reg.GetStringValue(FULLRESOURCE_STR, str_tmp);
				bool bTopicResourceExists = false;

				// check in troubleshooter list if topic-related resource path exists
				//  (it can be CHM file).
				if (reg.Create(REG_LOCAL_TS_LIST, &was_created, KEY_READ))
				{
					if (reg.Create(m_strTopicName, &was_created, KEY_READ))
					{
						if (reg.GetStringValue(TOPICRESOURCE_STR, str_tmp))
						{
							if (CCHMFileReader::IsPathToCHMfile(str_tmp))
								str_tmp = CCHMFileReader::FormCHMPath(str_tmp);
							else
								BackslashIt(str_tmp, true);
							
							if (AssignString(m_RegistryInfo.strResourcePath, str_tmp, 
								EV_GTS_SERVER_REG_CHG_DIR) )
							{
								maskChanged |= eResourcePath;
							}
							bTopicResourceExists = true;
						}
						
						reg.GetStringValue(TOPICFILE_EXTENSION_STR, m_RegistryInfo.strTopicFileExtension);
					}
				}

				if (bFullResourceStrExists && !bTopicResourceExists) 
				{
					BackslashIt(str_tmp, true);
					if (AssignString(m_RegistryInfo.strResourcePath, str_tmp, 
						EV_GTS_SERVER_REG_CHG_DIR) )
					{
						maskChanged |= eResourcePath;
					}
				}
			}
			else
				throw CAPGTSRegConnectorException(__FILE__, __LINE__, reg, eProblemWithKey);
		}
		else
			throw CAPGTSRegConnectorException(__FILE__, __LINE__, reg, eProblemWithKey);

		reg.Close();
		/* /////////////////////////////////////////////////////////////////////////
		///// >>> We are not using logging so far in the Local TS. Oleg. 02.01.99 //
		////////////////////////////////////////////////////////////////////////////
		// >>> The following may be irrelevant: I don't think we should ultimately be keeping
		//	such a log for Local TS. In any event, I've gotten rid of a bunch of certainly
		//	irrelevant code to read this from registry & make an entry in the event log. JM 1/19/99
		// Set the log file path arbitrarily to the current setting of the resource path
		m_RegistryInfo.strLogFilePath = m_RegistryInfo.strResourcePath;

		// Set m_RegistryInfo.strLogFilePath to the setting from the registry.
		// Note:	The code here should remain identical with the code in the catch block
		//			below (excluding the call to throw of course).
		BackslashIt( m_RegistryInfo.strLogFilePath, true);
		*/
	}
	catch (CAPGTSRegConnectorException&)
	{
		// Set m_RegistryInfo.strLogFilePath = m_RegistryInfo.strResourcePath in the
		// case where we could not get the log file path from the registry.
		BackslashIt( m_RegistryInfo.strLogFilePath, true );

		// Rethrow the exception upward to be logged.
		throw;
	}
}

// RETURN desired number of pool threads.  In Local TS, this is always 1!
DWORD CAPGTSRegConnector::GetDesiredThreadCount()
{
	return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\maxbuf.h ===
//
// MODULE: MAXBUF.H
//
// PURPOSE: Declare buffer size macro
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 01-06-98
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.1		01-06-98	JM		get MAXBUF into a header file of its own
//

#if !defined(MAXBUF_H_INCLUDED)
#define MAXBUF_H_INCLUDED

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define MAXBUF	256				// length of text buffers used for filenames,
								// IP adresses (this is plenty big), HTTP response ( like
								// "200 OK", again, plenty big), registry keys, 
								// and occasionally just to format an arbitrary string.

#endif // !defined(MAXBUF_H_INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\logstring.h ===
// LogString.h: interface for the CLogString class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_LOGSTRING_H__1606B935_224D_11D2_95D3_00C04FC22ADD__INCLUDED_)
#define AFX_LOGSTRING_H__1606B935_224D_11D2_95D3_00C04FC22ADD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "apgtsstr.h"	// for CString, which is NOT MFC CString.
#include "nodestate.h"

class CLogString
{
private:
	time_t m_timeStart;		// Time this CLogString object was created
	CString m_strCookie;
	CString m_strTopic;
	CString m_strStates;	// node/state (NID/IST) pairs
	CString m_strCurNode;	// current node
	bool m_bLoggedError;	// true ==> there was an error logged, in which case the next two
							//	variables are meaningful.
	DWORD m_dwError;
	DWORD m_dwSubError;
public:
	CLogString();
	~CLogString();

	CString GetStr() const;

	void AddCookie(LPCTSTR szCookie);
	void AddTopic(LPCTSTR szTopic);
	void AddNode(NID nid, IST ist);
	void AddCurrentNode(NID nid);
	void AddError(DWORD dwError=0, DWORD dwSubError=0);
private:
	void GetStartTimeString(CString& str) const;
	void GetDurationString(CString& str) const;
};

#endif // !defined(AFX_LOGSTRING_H__1606B935_224D_11D2_95D3_00C04FC22ADD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\localecb.cpp ===
//
// MODULE: LocalECB.H
//
// PURPOSE: Implementation of CLocalECB class, which implements CAbstractECB by emulating Win32's
//	EXTENSION_CONTROL_BLOCK.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint - Local TS only
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 01-07-99
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.1		01-07-99	JM		Original
//

#include "stdafx.h"
#include "LocalECB.h"
#include "RenderConnector.h"
#include "locale.h"

// >>> Warning: Possible redefinition
//  should use #include "apgtscls.h"
// Oleg 01.12.99
#define CONT_TYPE_STR	"application/x-www-form-urlencoded"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CLocalECB::CLocalECB(const VARIANT& name, const VARIANT& value, int count, 
					 HANDLE hEvent, CString* pstrWriteClient, 
					 CRenderConnector* pRenderConnector,
					 bool bSetLocale, CString& strLocaleSetting) 
		 : CTSNameValueMgr(name, value, count),
		   m_dwHttpStatusCode(500),
		   m_hEvent(hEvent),
		   m_strWriteClient(*pstrWriteClient),
		   m_pRenderConnector(pRenderConnector),
		   m_bSetLocale( bSetLocale ),
		   m_strLocaleSetting( strLocaleSetting )
{
}

CLocalECB::CLocalECB(const CArrNameValue& arr, HANDLE hEvent, 
					 CString* pstrWriteClient, CRenderConnector* pRenderConnector,
					 bool bSetLocale, CString& strLocaleSetting) 
		 : CTSNameValueMgr(arr),
		   m_dwHttpStatusCode(500),
		   m_hEvent(hEvent),
		   m_strWriteClient(*pstrWriteClient),
		   m_pRenderConnector(pRenderConnector),
		   m_bSetLocale( bSetLocale ),
		   m_strLocaleSetting( strLocaleSetting )
{
}

CLocalECB::CLocalECB(CString* pstrWriteClient)
		 : CTSNameValueMgr(),
		   m_dwHttpStatusCode(500),
		   m_hEvent(NULL),
		   m_strWriteClient(*pstrWriteClient),
		   m_pRenderConnector(NULL),
   		   m_bSetLocale( false )
{
}

CLocalECB::~CLocalECB()
{
}

// ConnID is irrelevant on Local TS, so we always return 0.
HCONN CLocalECB::GetConnID() const
{
	return 0;
}

DWORD CLocalECB::SetHttpStatusCode(DWORD dwHttpStatusCode)
{
	m_dwHttpStatusCode = dwHttpStatusCode;
	return m_dwHttpStatusCode;
}

// We act as if Method is always "POST"
LPSTR CLocalECB::GetMethod() const
{
	return "POST";
}

// Since we are always emulating "POST", there is no query string
LPSTR CLocalECB::GetQueryString() const
{
	return "";
}

DWORD CLocalECB::GetBytesAvailable() const
{
	return CTSNameValueMgr::GetData().GetLength();
}

LPBYTE CLocalECB::GetData() const
{
	return (LPBYTE)(LPCTSTR)CTSNameValueMgr::GetData();
}

// always say it's valid content ("application/x-www-form-urlencoded")
LPSTR CLocalECB::GetContentType() const
{
	return CONT_TYPE_STR;
}

// In Local TS, always return a null string.
BOOL CLocalECB::GetServerVariable
   ( /*HCONN      hConn,*/
    LPCSTR      lpszVariableName,
    LPVOID      lpvBuffer,
    LPDWORD     lpdwSize ) 
{
	if (CString(_T("SERVER_NAME")) == CString(lpszVariableName)) 
	{
		memset(lpvBuffer, 0, *lpdwSize);
		_tcsncpy((LPTSTR)lpvBuffer, _T("Local TS - no IP address"), *lpdwSize-2); // -2 in case og unicode
		return TRUE;
	}
	
	return FALSE;
}

BOOL CLocalECB::WriteClient
   ( /*HCONN      ConnID,*/
   LPCSTR	  Buffer,		// EXTENSION_CONTROL_BLOCK::WriteClient uses LPVOID, but it should
							//	only be legit to pass SBCS text, so we're enforcing that.
							// Also, we're adding const-ness.   Clearly, this really is const,
							//	but EXTENSION_CONTROL_BLOCK::WriteClient fails to declare it so.
   LPDWORD    lpdwBytes
   /* , DWORD      dwReserved */ 
   ) 
{
	if (*lpdwBytes <= 0) 
	{
		if (m_pRenderConnector)
			m_pRenderConnector->Render(_T(""));
		else
			m_strWriteClient = _T("");

		if (m_hEvent)
			::SetEvent(m_hEvent);

		return FALSE;
	}

	TCHAR* buf = new TCHAR[*lpdwBytes+1];
	//[BC-03022001] - added check for NULL ptr to satisfy MS code analysis tool.
	if(!buf)
		return FALSE;

	memcpy(buf, Buffer, *lpdwBytes);
	buf[*lpdwBytes] = 0;

	// Set the locale if requested.
	CString strOrigLocale;
	if (m_bSetLocale)
		strOrigLocale= _tsetlocale( LC_CTYPE, m_strLocaleSetting );
	
	if (m_pRenderConnector) 
	{
		m_pRenderConnector->Render(buf);
		m_pRenderConnector->SetLocked(false);
	}
	else
		m_strWriteClient = buf;

	// Restore the locale if requested.
	if (m_bSetLocale)
		strOrigLocale= _tsetlocale( LC_CTYPE, strOrigLocale );

	if (m_hEvent)
		::SetEvent(m_hEvent);
	
	delete [] buf;
	return TRUE;
}

// The 2 imaginably germane values of dwHSERRequest are:
//	HSE_REQ_SEND_RESPONSE_HEADER:Sends a complete HTTP server response header, including the 
//		status, server version, message time, and MIME version. The ISAPI extension should 
//		append other HTTP headers such as the content type and content length, followed by 
//		an extra \r\n. This option allows the function to take only text, up to the first 
//		\0 terminator. The function with this parameter should only be called once per request.  
//	HSE_REQ_DONE_WITH_SESSION: Specifies that if the server extension holds on to the session 
//		because of extended processing requirements, the server must be notified when the 
//		session is finished so the server can close it and free its related structures. 
//		The parameters lpdwSize, and lpdwDataType are ignored. 
//		The lpvBuffer parameter may optionally point to a DWORD that contains HSE_STATUS codes. 
//		IIS recognizes HSE_STATUS_SUCCESS_WITH_KEEP_CONN for keeping the IIS connection alive 
//		if the client also requests to keep the connection alive. 
//		This parameter must be sent to the server if the HSE_IO_DISCONNECT_AFTER_SEND parameter 
//		has been included in the HSE_TF_INFO structure as part of a HSE_REQ_TRANSMIT_FILE request.
//		This parameter will explicitly close the connection. 
//  >>> Have no idea how to emulate server's behavior in case of local troubleshooter.
//   Oleg 01.13.99
BOOL CLocalECB::ServerSupportFunction
   ( /*HCONN      hConn,*/
   DWORD      dwHSERRequest,
   LPVOID     lpvBuffer,
   LPDWORD    lpdwSize,
   LPDWORD    lpdwDataType ) 
{
	return FALSE;
}

const CString& CLocalECB::GetWriteClient() const
{
	return m_strWriteClient;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\localecb.h ===
//
// MODULE: LocalECB.H
//
// PURPOSE: Interface of CLocalECB class, which implements CAbstractECB by emulating Win32's
//	EXTENSION_CONTROL_BLOCK.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint - Local TS only
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 01-07-99
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.1		01-07-99	JM		Original
//

#if !defined(_AFX_LOCAL_INCLUDED_)
#define _AFX_LOCAL_INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "apgtsECB.h"
#include "TSNameValueMgr.h"
#include "apgtsstr.h"

class CRenderConnector;

class CLocalECB : public CAbstractECB, public CTSNameValueMgr 
{
	// emulating EXTENSION_CONTROL_BLOCK data members
	DWORD m_dwHttpStatusCode;		// only of relevance for debugging.
	CString& m_strWriteClient;
	HANDLE m_hEvent; // handler of event, main thread is waiting for;
					 //	 if NULL, main thread is not waiting for anything.
	CRenderConnector* m_pRenderConnector; // pointer to ATL control connector;
										  //  if NULL, write result page to m_strWriteClient,
										  //  otherwise call CRenderConnector::Render function.

public:
	CLocalECB(	const VARIANT& name, const VARIANT& value, int count, HANDLE hEvent, 
				CString* pstrWriteClient, CRenderConnector* pRenderConnector,
				bool bSetLocale, CString& strLocaleSetting );
	CLocalECB(	const CArrNameValue& arr, HANDLE hEvent, CString* pstrWriteClient, 
				CRenderConnector* pRenderConnector,
				bool bSetLocale, CString& strLocaleSetting );
	CLocalECB(CString* pstrWriteClient);
	~CLocalECB();

	// ======= inherited pure virtuals must be redefined =======
	virtual HCONN GetConnID() const;
	virtual DWORD SetHttpStatusCode(DWORD dwHttpStatusCode);
	virtual LPSTR GetMethod() const;
	virtual LPSTR GetQueryString() const;
	virtual DWORD GetBytesAvailable() const;
	virtual LPBYTE GetData() const;
	virtual LPSTR GetContentType() const;

    virtual BOOL GetServerVariable
   (  /*HCONN      hConn,*/
        LPCSTR       lpszVariableName,	// note, more const-ness than EXTENSION_CONTROL_BLOCK
        LPVOID      lpvBuffer,
        LPDWORD     lpdwSize );

    virtual BOOL WriteClient
   ( /*HCONN      ConnID,*/
	   LPCSTR	  Buffer,	// EXTENSION_CONTROL_BLOCK::WriteClient uses LPVOID, but it should
							//	only be legit to pass SBCS text, so we're enforcing that.
							// Also, we're adding const-ness.   
       LPDWORD    lpdwBytes
	   /* , DWORD      dwReserved */
       );

    virtual BOOL ServerSupportFunction
   ( /*HCONN      hConn,*/	// we always use the HCONN for this same COnlineECB
       DWORD      dwHSERRequest,
       LPVOID     lpvBuffer,
       LPDWORD    lpdwSize,
       LPDWORD    lpdwDataType );	

	// specific for CLocalECB class
public:
	const CString& GetWriteClient() const; // get data written by WriteClient()

private:
	// Specific for setting locales.
	bool	m_bSetLocale;
	CString	m_strLocaleSetting;
};

#endif // !defined(_AFX_LOCAL_INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\logstring.cpp ===
//
// MODULE: LogString.cpp
//
// PURPOSE: implementation of the CLogString class.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Roman Mach, Joe Mabel
// 
// ORIGINAL DATE: 7/24/1998
//
// NOTES: 
// 1. For public "Add" methods of this class: unless otherwise noted, if called more than once, 
//		only last call is significant
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		7-24-98		JM		Major revision, deprecate IDH.
//

#include "stdafx.h"
#include "LogString.h"
#include "SafeTime.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CLogString::CLogString()
{
	time( &m_timeStart );
	m_bLoggedError = false;
	m_dwError = 0;
	m_dwSubError = 0;
}

CLogString::~CLogString()
{
}

CString CLogString::GetStr() const
{
	CString str;
	CString strDuration;
	
	GetDurationString(strDuration);

	GetStartTimeString(str);
	str += _T(", ");
	str += m_strCookie;
	str += m_strTopic;
	str += strDuration;
	str += _T(", ");
	str += m_strStates;
	str += m_strCurNode;
	if (m_bLoggedError)
	{
		CString strError;
		strError.Format(_T(", Err=%ld(%ld)"), m_dwError, m_dwSubError);
		str +=strError;
	}
	str += _T("\n");

	return str;
}

void CLogString::AddCookie(LPCTSTR szCookie)
{
	m_strCookie = szCookie;
}

// INPUT szTopic: troubleshooter topic (a.k.a. troubleshooter symbolic name)
void CLogString::AddTopic(LPCTSTR szTopic)
{
	m_strTopic.Format(_T(" %s,"), szTopic);
}

// Must be called repeatedly for successive nodes.
// If you want to display nodes in a particular order, this must be called in that order.
void CLogString::AddNode(NID nid, IST ist)
{
	CString str;
	str.Format(_T("[%d:%d], "), nid, ist);

	m_strStates += str;
}

// Add current node (no state because we are currently visiting it)
void CLogString::AddCurrentNode(NID nid)
{
	m_strCurNode.Format(_T("Page=%d"), nid);
}

// Only logs an error if dwError != 0
// Can call with dwError == 0 to clear previous error
void CLogString::AddError(DWORD dwError/* =0 */, DWORD dwSubError/* =0 */)
{
	m_bLoggedError = dwError ? true :false;
	if (m_bLoggedError)
	{
		m_dwError = dwError;
		m_dwSubError = dwSubError;
	}
}


// OUTPUT str contains start date/time in form used in log.
void CLogString::GetStartTimeString(CString& str) const
{
	TCHAR buf[100];		// plenty big for date/time string

	{
		// minimize how long we use CSafeTime, because it means holding a mutex.
		CSafeTime safe(m_timeStart);
		_tcscpy(buf, _tasctime(&(safe.LocalTime())));
	}
	if (_tcslen(buf))
		buf[_tcslen(buf)-1] = _T('\0');// remove cr

 	str = buf;
}

// OUTPUT str contains form used in log of duration in seconds since m_timeStart.
void CLogString::GetDurationString(CString& str) const
{
	time_t timeNow;
	time( &timeNow );

	str.Format(_T(" Time=%02ds"), timeNow - m_timeStart);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\mutexowner.cpp ===
//
// MODULE: MutexOwner.cpp
//
// PURPOSE: strictly a utility class so we can properly construct & destruct a static mutex.
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha, Joe Mabel
// 
// ORIGINAL DATE: 11-04-98
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		11-04-98	JM		extracted from SafeTime
//

#include "stdafx.h"
#include "MutexOwner.h"
#include "BaseException.h"
#include "Event.h"

//////////////////////////////////////////////////////////////////////
//CMutexOwner
//////////////////////////////////////////////////////////////////////

CMutexOwner::CMutexOwner(const CString & str)
{
	m_hmutex = ::CreateMutex(NULL, FALSE, NULL);
	if (!m_hmutex)
	{
		// Shouldn't ever happen, so we're not coming up with any elaborate strategy,
		//	but at least we log it.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								str,
								_T(""),
								EV_GTS_ERROR_MUTEX ); 
	}
}

CMutexOwner::~CMutexOwner()
{
	::CloseHandle(m_hmutex);
}

HANDLE & CMutexOwner::Handle()
{
	return m_hmutex;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\msitstg.h ===
//
// MODULE: MSITStg.h
//
// PURPOSE: Interface declaration for IMSITStorage
//
// COMPANY: This file was created by Microsoft and should not be changed by Saltmine 
//	except for comments
//
// ORIGINAL DATE: unknown.
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.1		01-18-99	JM		This header added.
//

// MSITStg.h -- Interface declaration for IMSITStorage

#ifndef __MSITSTG_H__

#define __MSITSTG_H__

// Class ID for the ITSS File System:

DEFINE_GUID(CLSID_ITStorage, 
0x5d02926a, 0x212e, 0x11d0, 0x9d, 0xf9, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Inteface ID for the IITStorage interface:

DEFINE_GUID(IID_ITStorage, 
0x88cc31de, 0x27ab, 0x11d0, 0x9d, 0xf9, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface ID for the IITStorageEx interface:

DEFINE_GUID(IID_ITStorageEx, 
0xe74097b0, 0x292d, 0x11d1, 0xb6, 0x7e, 0x0, 0x0, 0xf8, 0x1, 0x49, 0xf6);

// Class ID for the FSStorage wrapper for the Win32 file system:

// {D54EEE56-AAAB-11d0-9E1D-00A0C922E6EC}
DEFINE_GUID(CLSID_IFSStorage, 
0xd54eee56, 0xaaab, 0x11d0, 0x9e, 0x1d, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface ID for the IFSStorage interface:

// {8BB2438A-A70C-11d0-9E1C-00A0C922E6EC}
DEFINE_GUID(IID_IFSStorage, 
0x8bb2438a, 0xa70c, 0x11d0, 0x9e, 0x1c, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface ID for the extended IStream interface

DEFINE_GUID(IID_IStreamITEx, 
0xeb19b681, 0x9360, 0x11d0, 0x9e, 0x16, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface ID for the extended IStorage interface

DEFINE_GUID(IID_IStorageITEx, 
0xeb19b680, 0x9360, 0x11d0, 0x9e, 0x16, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface IDs for the Data Space Manager used within an ITStorage object:

DEFINE_GUID(IID_IDataSpaceManager, 
0x7c01fd0f, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

DEFINE_GUID(IID_IDataSpace, 
0x7c01fd0e, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

DEFINE_GUID(IID_ITransformServices, 
0xa55895fc, 0x89e1, 0x11d0, 0x9e, 0x14, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

DEFINE_GUID(IID_IKeyInstance, 
0x96af35ce, 0x88ec, 0x11d0, 0x9e, 0x14, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface IDs for the plug-in data transforms:

DEFINE_GUID(IID_ITransformFactory, 
0x7c01fd0c, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

DEFINE_GUID(IID_ITransformInstance, 
0xeb19b67e, 0x9360, 0x11d0, 0x9e, 0x16, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface ID for the File Finder interface (used with URLs):

DEFINE_GUID(IID_IITFileFinder, 
0x77231260, 0x19c0, 0x11d1, 0xb6, 0x6e, 0x0, 0x0, 0xf8, 0x1, 0x49, 0xf6);

/*

The IITStorage interface parallels the API's defined for creating and
opening Docfiles. So if you have code that currently uses Docfiles for 
your storage mechanism, you can easily convert over to using ITS files 
instead. 

ITS files use a different on-disk structure to optimize them for very 
fast stream access and very low overhead. ITS files can manage thousands 
or millions of streams with very good access performance and very small 
directory space requirements. This makes ITS files ideal for CD-Roms and
for data collections that you'll download across the Internet. 

To make the conversion to ITS files you'll need to call CoCreateInstance 
with the class-id CLSID_ITStorage and the interface-id IID_ITStorage. You'll 
get back an interface pointer, say pItStg. Then you'll need to adjust the
places where your code creates or opens Docfiles. Instead of StgCreateDocfile
you'll call pItStg->StgCreateDocfile, and instead of StgOpenStorage, you'll
call pItStg->StgOpenStorage. In both cases you'll get back an IStorage 
interface pointer, say pIStg, which you can use just as you did before.

That's it. In general the rest of your code shouldn't have to change. There 
are some functional difference between ITS files and Docfiles -- ITS files
don't support STGM_TRANSACTED, for example. So if you have to have transacted 
file operations, you can't use ITS files -- at least for now. However in
almost all other respects ITS files interfaces can directly replace Docfile
interfaces.

Converting your data is also easy. Just open one of  your Docfiles using
StgOpenStorage, create a new ITS file via pItStg->StgCreateDocfile, and then
use the CopyTo interface to copy your data objects and their storage heirarchy
over to the ITS file:
    
    pStgDocfile->CopyTo(0, NULL, NULL, pStgITS);

In some cases you may want to exercise some control over the internal parameters
kept in an ITS file. You do this by calling SetControlData to give the IITStorage
interface a block of ITS control data. Then each subsequent call to StgCreateDocfile
will use that control data. The ITS control data determines, among other things,
the tradeoff between efficient random access to the stream data and minimizing the
size of an ITS file.  

The actual structure and interpretation of ITS control data is documented below.
(See the ITSFS_Control_Data data type). You can get default control data via the
DefaultControlData fuction. Note that DefaultControlData allocates the control
structure using IMalloc::Alloc as provided by CoGetMalloc and expects that your code will
deallocate the structure using the IMalloc::Free.

 */

// IID_IStreamITEx interface declaration:

DECLARE_INTERFACE_(IStreamITEx, IStream)
{
    // IStreamITEx methods
    
    STDMETHOD(SetDataSpaceName)(const WCHAR   * pwcsDataSpaceName) PURE;
    STDMETHOD(GetDataSpaceName)(       WCHAR **ppwcsDataSpaceName) PURE;

    STDMETHOD(Flush)() = 0;
};

// IID_IStorageITEx interface declaration:

DECLARE_INTERFACE_(IStorageITEx, IStorage)
{
    // IStorageITEx methods:

    STDMETHOD(GetCheckSum)(ULARGE_INTEGER *puli) PURE;
    STDMETHOD(CreateStreamITEx)(const WCHAR * pwcsName, const WCHAR *pwcsDataSpaceName, 
                            DWORD grfMode, DWORD reserved1, DWORD reserved2, 
                            IStreamITEx ** ppstm
                           ) PURE;
    STDMETHOD(OpenStreamITEx)(const WCHAR * pwcsName, void * reserved1, DWORD grfMode, 
                          DWORD reserved2, IStreamITEx ** ppstm) PURE;
};

// IStorageITEx::CreateStream lets you specify the data space in which a stream
// is to be created. Currently two dataspaces are supported:
//
//    L"Uncompressed" -- This dataspace applies no compression.
//    L"MSCompressed" -- This dataspace applies a default compression transform.


#pragma warning( disable : 4200)

// ITS_Control_Data is the generic structure of control data passed to the 
// IITStorage::SetControlData method or returned by the IITStorage::DefaultControlData
// method.

typedef struct _ITS_Control_Data
{
    UINT cdwControlData;     // Number of DWords to follow.
    UINT adwControlData[0];  // Actually this will be adwControlData[cdwControlData]

} ITS_Control_Data, *PITS_Control_Data;  


// ITSFS_Control_Data is the actual prefix structure of control data for IITStorage. 

typedef struct _ITSFS_Control_Data
{
    UINT cdwFollowing;     // Must be 6 or 13

    DWORD cdwITFS_Control; // Must be 5
    DWORD dwMagic;         // Must be MAGIC_ITSFS_CONTROL (see below)
    DWORD dwVersion;       // Must be 1
    DWORD cbDirectoryBlock;// Size in bytes of directory blocks (Default is 8192)
    DWORD cMinCacheEntries;// Least upper bound on the number of directory blocks
	                       // which we'll cache in memory. (Default is 20)
    DWORD fFlags;          // Control bit flags (see below). 
	                       // Default value is fDefaultIsCompression.

} ITSFS_Control_Data, *PITSFS_Control_Data;

// Signature value for ITSFS_Control_Data

const DWORD MAGIC_ITSFS_CONTROL    = 'I' | ('T' << 8) | ('S' << 16) | ('C' << 24);

// Bit flag definitions for ITSFS_Control_Data::fFlags

const DWORD fDefaultIsCompression  = 0x00000001;
const DWORD fDefaultIsUncompressed = 0x00000000;

// Note all other fFlags bits positions are reserved for future releases and should be 
// set to zero.

// When ITSFS_Control_Data::cdwFollowing is > 6, we assume that LZX_Control_Data follows
// immediately after. (See the XformControlData type below) LZX_Control_Data defines
// parameters which control the default compressed data space. 
//
// If ITSFS_Control_Data::cdwFollowing is 6, we use default values for the LZX
// control data.

typedef struct _LZX_Control_Data
{
    UINT  cdwControlData; // Must be 6

    DWORD dwLZXMagic;     // Must be LZX_MAGIC (see below)
    DWORD dwVersion;      // Must be 2
    DWORD dwMulResetBlock;// Number of blocks between compression resets.  (Default: 4)
    DWORD dwMulWindowSize;// Maximum number of blocks kept in data history (Default: 4)
    DWORD dwMulSecondPartition; // Granularity in blocks of sliding history(Default: 2)
    DWORD dwOptions;  // Option flags (Default: fOptimizeCodeStreams)

} LZX_Control_Data, *PLZX_Control_Data;

// Note: The block size for LZX compression is 32768 bytes.

const DWORD LZX_MAGIC           = 'L' | ('Z' << 8 ) | ('X' << 16) | ('C' << 24);

// Values for LZX_Control_Data::dwOptions

const DWORD fOptimizeCodeStreams = 0x00000001;

// Note that all other flag bit positions are reserved for future releases and should be
// set to zero.


// The second parameter for the IITStorage::Compact method below is an enueration
// which defines the level of compaction to do.

typedef enum ECompactionLev {COMPACT_DATA=0, COMPACT_DATA_AND_PATH} ;

DECLARE_INTERFACE_(IITStorage, IUnknown)
{
    // IITStorage methods

    STDMETHOD(StgCreateDocfile)(const WCHAR * pwcsName, DWORD grfMode, 
                                DWORD reserved, IStorage ** ppstgOpen
                               ) PURE;

    STDMETHOD(StgCreateDocfileOnILockBytes)(ILockBytes * plkbyt, DWORD grfMode,
                                            DWORD reserved, IStorage ** ppstgOpen
                                           ) PURE;

    STDMETHOD(StgIsStorageFile)(const WCHAR * pwcsName) PURE;

    STDMETHOD(StgIsStorageILockBytes)(ILockBytes * plkbyt) PURE;

    STDMETHOD(StgOpenStorage)(const WCHAR * pwcsName, IStorage * pstgPriority, 
                              DWORD grfMode, SNB snbExclude, DWORD reserved, 
                              IStorage ** ppstgOpen
                             ) PURE;

    STDMETHOD(StgOpenStorageOnILockBytes)
                  (ILockBytes * plkbyt, IStorage * pStgPriority, DWORD grfMode, 
                   SNB snbExclude, DWORD reserved, IStorage ** ppstgOpen
                  ) PURE;

    STDMETHOD(StgSetTimes)(WCHAR const * lpszName,  FILETIME const * pctime, 
                           FILETIME const * patime, FILETIME const * pmtime
                          ) PURE;

    STDMETHOD(SetControlData)(PITS_Control_Data pControlData) PURE;

    STDMETHOD(DefaultControlData)(PITS_Control_Data *ppControlData) PURE;
		
    STDMETHOD(Compact)(const WCHAR * pwcsName, ECompactionLev iLev) PURE;
};

DECLARE_INTERFACE_(IITStorageEx, IITStorage)
{
    STDMETHOD(StgCreateDocfileForLocale)
        (const WCHAR * pwcsName, DWORD grfMode, DWORD reserved, LCID lcid, 
         IStorage ** ppstgOpen
        ) PURE;

    STDMETHOD(StgCreateDocfileForLocaleOnILockBytes)
        (ILockBytes * plkbyt, DWORD grfMode, DWORD reserved, LCID lcid, 
         IStorage ** ppstgOpen
        ) PURE;

    STDMETHOD(QueryFileStampAndLocale)(const WCHAR *pwcsName, DWORD *pFileStamp, 
                                                              DWORD *pFileLocale) PURE;
    
    STDMETHOD(QueryLockByteStampAndLocale)(ILockBytes * plkbyt, DWORD *pFileStamp, 
                                                                DWORD *pFileLocale) PURE;
};

typedef IITStorage *PIITStorage;

DECLARE_INTERFACE_(IFSStorage, IUnknown)
{
    // IUnknown methods

    STDMETHOD(QueryInterface)  (THIS_ REFIID, VOID **) PURE;
    STDMETHOD_(ULONG, AddRef)  (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // IFSStorage methods

    STDMETHOD(FSCreateStorage)(const WCHAR * pwcsName, DWORD grfMode, IStorage **ppstgOpen) PURE;

    STDMETHOD(FSOpenStorage)(const WCHAR * pwcsName, DWORD grfMode, IStorage **ppstgOpen) PURE;

    STDMETHOD(FSCreateStream)(const WCHAR *pwcsName, DWORD grfMode, IStream **ppStrm) PURE;
    STDMETHOD(FSCreateTemporaryStream)(IStream **ppStrm) PURE;
    STDMETHOD(FSOpenStream  )(const WCHAR *pwcsName, DWORD grfMode, IStream **ppStrm) PURE;
    STDMETHOD(FSCreateLockBytes)(const WCHAR *pwcsName, DWORD grfMode, ILockBytes **ppLkb) PURE;
    STDMETHOD(FSCreateTemporaryLockBytes)(ILockBytes **ppLkb) PURE;
    STDMETHOD(FSOpenLockBytes  )(const WCHAR *pwcsName, DWORD grfMode, ILockBytes **ppLkb) PURE;

    STDMETHOD(FSStgSetTimes)(WCHAR const * lpszName,  FILETIME const * pctime, 
                             FILETIME const * patime, FILETIME const * pmtime
                            ) PURE;
};

typedef IFSStorage *PIFSStorage;

/*
**   Data Spaces -- What they are.

Within an ITS file we store information in one or more data spaces. A data space
is a container which holds the bits which represent a collection of streams. Each
data space has a name and an associated collection of transforms.

Those transforms take the raw data which you write to an ITS stream and map it into
a representation stream. When you read from an ITS stream they do the reverse mapping
to reconstruct your original data from the representation. 

When you first create an ITS file, it contains one data space named "Default_Space"
which applies the LZX data compression transform. By default all of the streams you
create will have their data representations stored in the default data space.

If LZX compression meets your needs, and you're not concerned about data enciphering,
you can skip over the following discussion. If, on the other hand, you want to 
create additional data spaces or transforms, read on.

To create a data space, you must first get a pointer to the IDataSpaceManager interface.
Just do a QueryInterface for IID_DataSpaceManager from any storage created by the 
IITStorage interface. Then you can call the CreateDataSpace function to define a new
data space. 

When you're defining a collection of data spaces, be sure that their names are distinct.
Defining two data spaces with the same name is an error. Data space names follow the
rules for stream names. That is, they must be less than 260 characters long, and may
not contain the characters '/'. '\', '|', ':', or any character less than 0x0020.

Data spaces are kept in a separate name space. So you don't have to worry about
colliding with a stream name or a storage name. As noted above, we have defined one
special data space ("Default_Space") where all data resides if you take no action.

You can redefine that default space simply by creating a new data space with the
name "Default_Space". This is the one case where a name collision is allowed. If 
you do redefine the default data space, any data in the old space will automatically
be transformed appropriately and moved into the new default data space.  

**   Importing Items

If you have defined additional data spaces, the next step is to define which streams
and storages you want to move into the new data spaces. You do that by means of the 
IDataSpace::Import function. For example suppose you've defined the dataspace 
*pMyDataSpace and you want to import the stream "Alpha" contained in the storage 
*pThatStorage:

    pMyDataSpace->Import(pThatStorage, "Alpha");

Similarly if you want to import the storage "HTML_Pages" from pThisStorage:

    pMyDataSpace->Import(pThisStorage, "HTML_Pages");

That will recursively import the "HTML_Pages" storage and all of the streams and 
storages contained within it. It also conditions those storages so that anything
you create within them will be automatically imported into pMyDataSpace. Note that
subsequent Import operations may alter that conditioning.

If you later decide that you want to move "Alpha" back into the default data
space:

    hr = pDataSpaceManager->OpenDataSpace(L"Default_Space", &pDefaultDataSpace);

    pDefaultDataSpace->Import(pThatStorage, "Alpha");

**  Data Space Transform Sets 

When you define a data space, you must specify a set of transforms to apply to 
the items you import into the space. A transform is an interface that converts
data to some other representation. For example the LZX transform converts your 
imported data into a more compact, compressed representation. Other transforms
might implement word or phrase based dictionary compression, or they might encipher 
your data, or they might just convert from one data format to another. You could, 
for example, construct a transform to store HTML data as a Rich Text stream.

When you define a data space with more than one transform, they are applied in 
order. For example let's suppose that your transform set consists of these three:

  1. A Dictionary compression transform

  2. The LXZ transform

  3. An data encryption transform

Whenever you write data into this space, it will first be compressed using the
dictionary compression methods, then LZX compression will be applied, and finally
your information will be encrypted. When you read data the process is reversed so
that the encryption transform supplies data to the LZX transform which in turn 
provides data for the dictionary compression transform.

You define the transform set via a vector of class ids (paclsidXform). Each class id
defines a location where an implementation of IID_Transform can be found. In addition
you'll supply corresponding control data for each transform (papxfcd). The number of 
transforms is defined by the cXforms parameter.

Note that it is legal to define a space with zero transforms. This is useful when
you've got items which are already compressed and which won't benefit from an
additional layer of compression overhead.

The control data for a transform defines how it will operate in a particular
data space. For example the control data for the LZX transform defines how
aggressively it will pursue compression, and it controls the tradeoff between
random access performance and the level of compression.

The actual structure and content of the control data is documented above.
(See the LZX_Control_Data data type.)

**  Transform Factories -- How they are organized; What they do

Transforms have two functional capabilities. They can return default
control data (DefaultControlData), and they can create
transform instances (CreateTransformInstance). When the ITSS code calls your 
CreateTransformInstance function, it will supply a storage medium (pXFSpan_Base)
where transformed data is to be stored along with the control data for the
instance and several other useful pieces of information. 

The CreateTransformInstance function has several parameters that you can use 
when you need to access global and/or instance data streams. They also support
the construction of encryption transforms. You can ignore those parameters if your
transform doesn't do encryption, uses only a single pass over the data, and doesn't
rely on any data beyond the data in the stream being transformed.

  -- The rclsidXForm and pwszDataSpace parameters, respectively, tell you the Class ID
  by which your code was located, and the name of the data space in which your instance
  will be working. These values are used with the ITransformServices interface.

  -- The pXformServices parameter points to an instance of the ITranformServices interface. 
  That interface gives you access to a couple of storages where you can keep global and
  instance data for your transform. It also gives you a way to contruct a temporary
  stream that is automatically deleted when you release it. That's very handy when 
  you get a seek operation into the middle of the transformed data followed by a write 
  operation.

  If you're implementing a multipass strategy, you can get access to those storages
  from code outside the transform by doing a QueryInterface from any ITS storage for 
  the interface IID_ITransformServices. You identify the storage in question by the
  transform's class id and possibly the name of the data space instance. 

  The per-transform-instance storage is also a convenient place to put the navigation
  data necessary to support fast seek operations.

  -- The pKeyManager parameter is an interface pointer used with encryption transforms.
  It supplies the read and write keys to use with your encryption transform. Those keys
  are set by the SetKeys interface of the ITransformServices interface. This allows you
  to separate your user interface code where people will enter passwords from the 
  transform implementations. This can be useful when you want the same keys to be used 
  for several different data spaces.  

**  Transform Instances -- How they are organized; What they do

A Transform Instance is an object which simulates a data medium which can be 
suballocated. Suballocated items are managed as data spans (ITransformedSpan).
You must supply a function to create a data span (CreateTransformedSpan), and
a function to open a data span (OpenTransformedSpan). Both of those functions 
return an ITransformedSpan interface when they succeed. In addition you must
supply the function SpaceSize to return the size of the entire untransformed
data image. That is, SpaceSize returns the highest limit offset (offset + size)
of any data span created within the instance. 

A span is identified by an ImageSpan structure which defines an offset and a size 
for the span. Both values are defined in untransformed space. For the Create function
this is an output parameter, while it is an input parameter for the Open function.
Note the interaction between the ImageSpan and the WriteAt member function of the
ITransformedSpan interface.

**  Transformed Data Spans -- How they are organized; What they do

A transformed Data Span (ITransformedSpan) has two member functions -- ReadAt and 
WriteAt. Those functions are very similar to the ReadAt and WriteAt functions of
the ILockBytes interface. The difference is that WriteAt includes an extra output
parameter (pImageSpan) for recording the current span parameters. The ReadAt function
doesn't include that parameter because read operations can never change the span's
size or move it to a different offset.

**  Implementation Strategies

This section describes a few scenarios that you may encounter as you construct a 
transform along with strategies for those situations. This is an open ended list 
which will expand as we gain more experience with transforms.

Many compression and encryption transforms are designed around sequential I/O. That is,
they expect to get the raw data from a sequence of write opeations with no intervening
seek operations. In many cases such transforms also write out the transformed data to 
the base stream in ascending order. Similarly they expect read requests to come to them
with no intervening seek operations. 

The key issue for those transforms is how do you implement random access and interleaved
read, write, and seek operations. 

Leaving aside write operations for the moment, let's consider a random sequence of reads
interleaved with seek operations. One solution might be to construct a table to map from
raw data offsets to transformed data offsets. You can store such a table in the instance
storage for the current data space. 

One complication is that many compression transforms use the raw data as a dictionary. 
That is, you can only start reading from the beginning of the transformed data. You can
deal with those transforms telling them to reset themselves periodically. That gives
you a collection of starting points spread fairly evenly throught the transformed 
data. When you do this you'll need to supply a control data parameter to control the
frequency of those reset points so that your clients can make an appropriate tradeoff
between compression efficiency and random access performance.

Now what about adding random write operations to the mix? The short answer here is that
you can't do this in the middle of transformed data. One strategy would be to reconstruct
the entire raw data into a temporary stream and do all your I/O to that stream until
release time. Then at release time you can transform the revised data sequentially.

A variation on that strategy is to keep track of which reset spans are modified and 
write the modified versions of those transformed spans to the end of the base stream.
This leaves a certain amount of dead space in your transformed data, but it allows
you to defer the sequential reconstruction work to a more convenient time. The down 
side  is that it requires you to manage yet more navigation data in the instance 
storage for the data space.

 */

interface IDataSpaceManager;
interface IDataSpace;
interface ITransformServices;
interface IKeyInstance;
interface ITransformFactory;
interface ITransformInstance;

typedef struct _XformControlData
{
    UINT  cdwControlData;    // Size of this structure in DWords
    UINT  adwControlData[0]; // Actually this will be UINT adwData[cdwData];

} XformControlData, *PXformControlData;

/*
// {7C01FD0F-7BAA-11d0-9E0C-00A0C922E6EC}
DEFINE_GUID(IID_IDataSpaceManager, 
0x7c01fd0f, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface IDataSpaceManager : public IUnknown
{
public:

    virtual HRESULT STDMETHODCALLTYPE CreateDataSpace
        (const WCHAR *pwszDataSpace, UINT cXforms,
         const CLSID *paclsidXform, PXformControlData paxfcd,
         IDataSpace *pITDataSpace
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE OpenDataSpace
        (const WCHAR *pwszDataSpace, 
         IDataSpace *pITDataSpace
        ) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE DiscardDataSpace
        (const WCHAR *pwszDataSpace) = 0;

    virtual HRESULT STDMETHODCALLTYPE EnumDataSpaces
        (IEnumSTATSTG ** ppenum) = 0;
};


/*
// {7C01FD0E-7BAA-11d0-9E0C-00A0C922E6EC}
DEFINE_GUID(IID_IDataSpace, 
0x7c01fd0e, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface IDataSpace : public IUnknown
{
public:

    virtual HRESULT STDMETHODCALLTYPE GetTransformInfo
        (PUINT pcXforms, PUINT pcdwXformControlData, 
         CLSID *paclsid, PXformControlData pxfcd
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Import
        (IStorage *pStg, const WCHAR * pwszElementName) = 0;

    virtual HRESULT STDMETHODCALLTYPE ImportSpace(IStorage **ppStg) = 0;
};

/*
// {7C01FD0C-7BAA-11d0-9E0C-00A0C922E6EC}
DEFINE_GUID(IID_ITransformFactory, 
0x7c01fd0c, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface ITransformFactory : public IUnknown
{
public:

    virtual HRESULT STDMETHODCALLTYPE DefaultControlData
        (XformControlData **ppXFCD) = 0;

    virtual HRESULT STDMETHODCALLTYPE CreateTransformInstance
        (ITransformInstance *pXFormMedium,        // Container data span for transformed data
		 ULARGE_INTEGER      cbUntransformedSize, // Untransformed size of data
         PXformControlData   pXFCD,               // Control data for this instance
         const CLSID        *rclsidXForm,         // Transform Class ID
         const WCHAR        *pwszDataSpaceName,   // Data space name for this instance
         ITransformServices *pXformServices,      // Utility routines
         IKeyInstance       *pKeyManager,         // Interface to get enciphering keys
         ITransformInstance **ppTransformInstance // Out: Instance transform interface
        ) = 0;
};

typedef struct _ImageSpan
{
	ULARGE_INTEGER	uliHandle;
	ULARGE_INTEGER  uliSize;

} ImageSpan;

/*
// {EB19B67E-9360-11d0-9E16-00A0C922E6EC}
DEFINE_GUID(IID_ITransformInstance, 
0xeb19b67e, 0x9360, 0x11d0, 0x9e, 0x16, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface ITransformInstance : public IUnknown
{
public:

	virtual HRESULT STDMETHODCALLTYPE ReadAt 
	                    (ULARGE_INTEGER ulOffset, void *pv, ULONG cb, ULONG *pcbRead,
						 ImageSpan *pSpan
                        ) = 0;

	virtual HRESULT STDMETHODCALLTYPE WriteAt
	                    (ULARGE_INTEGER ulOffset, const void *pv, ULONG cb, ULONG *pcbWritten, 
						 ImageSpan *pSpan
                        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Flush() = 0;

	virtual HRESULT STDMETHODCALLTYPE SpaceSize(ULARGE_INTEGER *puliSize) = 0;

	// Note: SpaceSize returns the high water mark for the space. That is, the largest
	//       limit value (uliOffset + uliSize) for any transformed lockbytes created within
	//       the base (*pXLKB).
};

/*
// {A55895FC-89E1-11d0-9E14-00A0C922E6EC}
DEFINE_GUID(IID_ITransformServices, 
0xa55895fc, 0x89e1, 0x11d0, 0x9e, 0x14, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface ITransformServices : public IUnknown
{
public:

    virtual HRESULT STDMETHODCALLTYPE PerTransformStorage
        (REFCLSID rclsidXForm, IStorage **ppStg) = 0;

    virtual HRESULT STDMETHODCALLTYPE PerTransformInstanceStorage
        (REFCLSID rclsidXForm, const WCHAR *pwszDataSpace, IStorage **ppStg) = 0;

    virtual HRESULT STDMETHODCALLTYPE SetKeys
        (REFCLSID rclsidXForm, const WCHAR *pwszDataSpace, 
         PBYTE pbReadKey,  UINT cbReadKey, 
         PBYTE pbWriteKey, UINT cbWriteKey
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE CreateTemporaryStream(IStream **ppStrm) = 0;
};

/*
// {96AF35CE-88EC-11d0-9E14-00A0C922E6EC}
DEFINE_GUID(IID_IKeyInstance, 
0x96af35ce, 0x88ec, 0x11d0, 0x9e, 0x14, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface IKeyInstance : public IUnknown
{
public:

    virtual HRESULT STDMETHODCALLTYPE GetKeys
        (PBYTE *pbReadKey,  PUINT pcbReadKey,
         PBYTE *pbWriteKey, PUINT pcbWriteKey
        ) = 0;
};

/* 

  Streams stored in an ITS file may be accessed through URLs with
  the form:

      its: <File Path> :: <Stream Path>

  where <File Path> may be either a Win32 file path or a URL, and
  <Stream Path> is the path to a stream stored in the ITS file. 
  Each <Stream Path> must begin with '/'. 

  This means that you can copy a Win32 directory tree of HTML files
  and associated files into an ITS file and get to them through ITS
  URLs. If all the URL references within those HTML files are 
  relative, they will be resolved within the containing ITS file.

  The <File Path> portion of the URL may either be a complete path
  to the ITS file, or it may be just the file name. In the later case
  you may need to install auxillary information in the registry to
  help the ITSS code locate the file. Here are the rules:

  1. If you don't supply a complete path, ITSS looks in the current
     working directory for the file. 

  2. If the file isn't found in step 1. ITSS looks for a registry
     value in the ITSS_MAP section of HKEY_LOCAL_MACHINE. The value
     name must match the file name, and the value will be a string
     giving the complete file path to be used.

  3. If the file isn't found in steps 1 and 2, ITSS isolates the file's 
     extension (beginning with the last '.' character) and looks
     for a corresponding class id value in the ITSS_FINDER section 
     of HKEY_LOCAL_MACHINE. The name for the value will match the
     extension, and the value will be the class id for an object
     which implements the IID_IITFileFinder interface.

  4. If the file isn't found in steps 1 through 3, the URL reference
     fails.

 */

#define ITSS_MAP     "Software\\Microsoft\\Windows\\ITStorage\\Maps"
#define ITSS_FINDER  "Software\\Microsoft\\Windows\\ITStorage\\Finders"

interface IITFileFinder : public IUnknown
{
public:

    virtual HRESULT STDMETHODCALLTYPE FindThisFile(const WCHAR *pFileName, WCHAR **ppFullPath,
                                                   BOOL *pfRecordPathInRegistry
                                                  ) = 0;

// The FindThisFile method maps a file name into a complete file path. The file name
// is defined by *pFileName, and a pointer to the complete path is returned in 
// *ppFullPath. The returned path will be a string allocated in the IMalloc heap.
// The *pfRecordPathInRegistry result should be TRUE when we should record this mapping
// in the ITSS_MAP registry section and FALSE otherwise.

    
};


#endif // __MSITSTG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\pointer.h ===
//
// MODULE: POINTER.H
//
// PURPOSE: Smart pointer that counts references, deletes object when no more references
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 9-8-98
//
// NOTES: 
// 1. Because these are templates, all code is in the header file.
// 2. counting_ptr is intended to be used as part of a "publishing system":
// A "publisher" creates a counting_ptr P to a heap object X.  "Clients" obtain access to X 
//	by copying P or assigning a counting_ptr to be equal to P.
// Write/copy/delete access to P should be under control of a mutex.  A single mutex may 
//	control access to multiple published objects.
// The publisher terminates the publication of *P by deleting or reassigning P. Once no client
//	is using *P, *P should go away.
// class X is expected to be an actual class.  If it is (say) an int, this will give 
//	warning C4284, because it makes no sense to use operator-> on an int.
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		9-8-98		JM		
//

#ifndef __POINTER_H_
#define __POINTER_H_ 1

#include <windows.h>


#include <windef.h>
#include <winbase.h>

template<class X> class counting_ptr
{
private:

	template<class Y> class ref_counter
	{
	private:
		long m_RefCount;
		Y* m_px;
		~ref_counter() {};	// Force this to be on the heap.
	public:
		ref_counter(Y* px = 0) :
			m_RefCount(1),
			m_px (px)
			{}

		void AddRef() {::InterlockedIncrement(&m_RefCount);}

		void RemoveRef() 
		{
			if (::InterlockedDecrement(&m_RefCount) == 0)
			{
				delete m_px;
				delete this;
			}
		}

		Y& Ref()  const { return *m_px; }	// supports counting_ptr::operator*

		Y* DumbPointer() const { return m_px; }	// supports counting_ptr::operator->
	};

	ref_counter<X> *m_pLow;

public:
	// if px != NULL, *px MUST be on the heap (created with new).
	explicit counting_ptr(X* px=0) :
		m_pLow(new ref_counter<X>(px))
		{}

	counting_ptr(const counting_ptr<X>& sib) :
		m_pLow(sib.m_pLow) 
		{m_pLow->AddRef();}

	counting_ptr<X>& operator=(const counting_ptr<X>& sib) 
	{
		if (sib.m_pLow != m_pLow)
		{
			(sib.m_pLow)->AddRef();
			m_pLow->RemoveRef();
			m_pLow = sib.m_pLow;
		}
		return *this;
	}

	counting_ptr<X>& operator=( const X *px ) 
	{
		if (px != m_pLow->DumbPointer())
		{
			m_pLow->RemoveRef();

			// This const_cast was necessary in order to compile.
			m_pLow= new ref_counter<X>(const_cast<X *>(px));
		}
		return *this;
	}

	~counting_ptr()       { m_pLow->RemoveRef(); }

	X& operator*()  const { return m_pLow->Ref(); }

	X* operator->() const { return m_pLow->DumbPointer(); }

	X* DumbPointer() const { return m_pLow->DumbPointer(); }

	bool IsNull() const {return DumbPointer() == NULL;}
};

#endif // __POINTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\mutexowner.h ===
//
// MODULE: MutexOwner.h
//
// PURPOSE: strictly a utility class so we can properly construct & destruct a static mutex.
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha, Joe Mabel
// 
// ORIGINAL DATE: 11-04-98
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		11-04-98	JM		extracted from SafeTime
//

#if !defined(AFX_MUTEXOWNER_H__7BFC10DD_741D_11D2_961D_00C04FC22ADD__INCLUDED_)
#define AFX_MUTEXOWNER_H__7BFC10DD_741D_11D2_961D_00C04FC22ADD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <windows.h>
#include "apgtsstr.h"

// strictly a utility class so we can properly construct & destruct a static mutex.
class CMutexOwner
{
private:
	HANDLE m_hmutex;
public:
	CMutexOwner(const CString & str);
	~CMutexOwner();
	HANDLE & Handle();
};


#endif // !defined(AFX_MUTEXOWNER_H__7BFC10DD_741D_11D2_961D_00C04FC22ADD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\recentuse.h ===
//
// MODULE: RecentUse.h
//
// PURPOSE: To maintain a "session" this can track whether a give value (either 
//	a cookie value or an IP address) has been "recently" used
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 11-4-98
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		11/4/98		JM		original
//

#if !defined(AFX_RECENTUSE_H__293EE757_7405_11D2_961D_00C04FC22ADD__INCLUDED_)
#define AFX_RECENTUSE_H__293EE757_7405_11D2_961D_00C04FC22ADD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#pragma warning(disable:4786)

#include <windows.h>
#include <time.h>
#include <map>
using namespace std;
#include "apgtsstr.h"

class CRecentUse  
{
private:
	typedef map<CString, time_t> TimeMap;
	DWORD m_minExpire;				// how long a value remains "recent" (in minutes)
	TimeMap m_Recent;				// for each CString we are tracking, the time 
									//  last used
public:
	CRecentUse(DWORD minExpire = 15);
	~CRecentUse();
	void Add(CString str);
	bool Validate(CString str);

private:
	bool Validate(TimeMap::iterator it);
	void Flush();
};

#endif // !defined(AFX_RECENTUSE_H__293EE757_7405_11D2_961D_00C04FC22ADD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\propnames.h ===
//
// MODULE: PROPNAMES.H
//
// PURPOSE: Declare property names
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Roman Mach, Joe Mabel
// 
// ORIGINAL DATE: 8-2-96
//
// NOTES: 
// 1. 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		8-31-98		JM		Extract this from apgtsinf.h
//

#if !defined(PROPNAMES_H_INCLUDED)
#define APGTSINF_H_INCLUDED

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

//------- property types -----------
//  These are all possible properties of nodes or net

#define H_PROB_HD_STR		_T("HProbHd")
#define H_PROB_PAGE_TXT_STR	_T("HProbPageText")	// text before list of problems
#define H_PROB_TXT_STR		_T("HProbTxt")		// text of one problem (node property)
#define H_PROB_SPECIAL		_T("HProbSpecial")			// may contain "hide" to mean
														// not to be shown on problem page
#define H_NODE_HD_STR		_T("HNodeHd")
#define H_NODE_TXT_STR		_T("HNodeTxt")

#define H_NODE_DCT_STR		_T("HNodeDct")		// replacement for HNodeTxt when a 
												//	presumptive cause is sniffed.

#if 0 // removed 8/19/99 per request from John Locke & Alex Sloley
	#define H_ST_NORM_TXT_STR	_T("HStNormTxt")
	#define H_ST_AB_TXT_STR		_T("HStAbTxt")
#endif

#define H_ST_UKN_TXT_STR	_T("HStUknTxt")
#define MUL_ST_LONG_NAME_STR _T("MulStLongName")


#define HX_DOJ_HD_STR		_T("HXDOJHd")
#define HX_SER_HD_STR		_T("HXSERHd")
#define HX_SER_TXT_STR		_T("HXSERTxt")
#define HX_SER_NORM_STR		_T("HXSERNorm")
#define HX_SER_AB_STR		_T("HXSERAb")
#define HX_FAIL_HD_STR		_T("HXFAILHd")
#define HX_FAIL_TXT_STR		_T("HXFAILTxt")
#define HX_FAIL_NORM_STR	_T("HXFAILNorm")
#define HX_BYE_HD_STR		_T("HXBYEHd")
#define HX_BYE_TXT_STR		_T("HXBYETxt")
	
// Search strings get And'd together.  The first 2 are meant for binary nodes, the
//	last for multi-state.
#define H_NODE_NORM_SRCH_STR	_T("HNodeNormSrch")		
#define H_NODE_AB_SRCH_STR		_T("HNodeAbSrch")
#define MUL_ST_SRCH_STR			_T("MulStSrch")
// Net property.  If == "yes", we actually show the BES page. Otherwise just search without
//	showing the search page.
#define H_NET_SHOW_BES		_T("HNetShowBES")	// H_NET_SHOW_BES property no longer officially supported as of 981021.
// Net properties: default contents for BES & HTI.
#define H_NET_BES			_T("HNetBES")
#define H_NET_HTI_ONLINE	_T("HNetHTIOnline")
#define H_NET_HTI_LOCAL		_T("HNetHTILocal")

#define H_NET_DATE_TIME		_T("HNetDateTime")

//--------- New network properties for localization. ----------------
#define HTK_UNKNOWN_RBTN	_T("HTKUnknownRbtn")	// Network
#define	HTK_NEXT_BTN		_T("HTKNextBtn")		// Network
#define	HTK_START_BTN		_T("HTKStartBtn")		// Network
#define	HTK_BACK_BTN		_T("HTKBackBtn")		// Network
#define HTK_SNIF_BTN		_T("HTKSnifBtn")		// Network: this is label for a 
													//	sniff button on problem page for
													//	expensive sniffing.

// Network properties for Impossible Page (pseudo node when states contradict each other)
#define HTK_IMPOSSIBLE_HEADER _T("HXIMPHd")			
#define HTK_IMPOSSIBLE_TEXT	 _T("HXIMPTxt")
#define HX_IMPOSSIBLE_NORM_STR	_T("HXIMPNorm")

// Network properties for Sniff Fail Page (pseudo node when sniffing on startup shows all
//	causes are in their Normal states).  A.k.a. Sniff All Causes Normal Page, probably 
//	a better name but doesn't match the property names MS wanted.
#define HTK_SNIFF_FAIL_HEADER _T("HNetSniffFailHd")			
#define HTK_SNIFF_FAIL_TEXT	 _T("HNetSniffFailTxt")
#define HX_SNIFF_FAIL_NORM	_T("HNetSniffFailNorm")

#define H_NET_GENERATE_RESULTS_PAGE _T("HNetGenerateResultsPage")  // Defaults to true if 
					// not present.  If set false, Troubleshooter Assembler does not 
					// generate a "results" page for this topic.  This allows us to prevent 
					// custom Results pages getting overwritten

//--------- Sniffing related network and node properties. -----------
// See Sniffing Version 3.2.doc (functional spec) for more explanation
#define H_NET_SNIFF_ACTIVEX			_T("HNetSniffActiveX")	// CLSID of sniffing ActiveX
#define H_NET_SNIFF_EXTERNAL_SCRIPT _T("HNetSniffExternalScript") // Default external 
														//	script name
#define H_NET_SNIFF_LANGUAGE		_T("HNetSniffLanguage") // Language for script in 
														// "HNetSniffExternalScript":
														// "JavaScript" or "VBScript"
#define H_NET_MAY_SNIFF_MANUALLY	_T("HNetMaySniffManually")
#define H_NET_MAY_SNIFF_ON_STARTUP	_T("HNetMaySniffOnStartup")
#define H_NET_MAY_SNIFF_ON_FLY		_T("HNetMaySniffOnFly")
#define H_NET_RESNIFF_POLICY		_T("HNetResniffPolicy") // {"No"| "Explicit"| "Implicit"| "Yes"}
#define H_NET_CHECK_SNIFFING_CHECKBOX	_T("HNetCheckSniffingCheckbox") // If true, and if 
					// an AllowSniffing checkbox is present on the Problem Page, that box 
					// should have an initial state of "checked". 

#define H_NET_HIST_TABLE_SNIFFED_TEXT _T("HNetHistTableSniffedText") // Identifies sniffed 
					// nodes in any visible history table. English version: "SNIFFED"
#define H_NET_ALLOW_SNIFFING_TEXT	 _T("HNetAllowSniffingText") // Text for "AllowSniffing" 
					// checkbox. English version: "Allow automatic sniffing."
#define H_NET_TEXT_SNIFF_ONE_NODE	 _T("HNetTextSniffOneNode")	 // Text of "Sniff" button 
					// for sniffing a single node. English version "Sniff".
#define H_NET_TEXT_SNIFF_ALERT_BOX	 _T("HNetTextSniffAlertBox") // Text of alert box, 
					// displayed any time manually requested sniffing (of a single node) 
					// fails. English version "Could not sniff this node".

#define H_NODE_SNIFF_SCRIPT		_T("HNodeSniffScript")	// Script to sniff this node
#define H_NODE_MAY_SNIFF_MANUALLY	_T("HNodeMaySniffManually")
#define H_NODE_MAY_SNIFF_ON_STARTUP	_T("HNodeMaySniffOnStartup")
#define H_NODE_MAY_SNIFF_ON_FLY		_T("HNodeMaySniffOnFly")
#define H_NODE_MAY_RESNIFF			_T("HNodeMayResniff")		// Node may be resniffed
#define H_NODE_SNIFF_EXTERNAL_SCRIPT _T("HNodeSniffExternalScript") // Node-specific 
														//	external script name
#define H_NODE_SNIFF_LANGUAGE	_T("HNodeSniffLanguage") // Language for script in 
														// "HNodeSniffExternalScript":
														// "JavaScript" or "VBScript"
#define H_NODE_CAUSE_SEQUENCE 	_T("HCauseSequence")	//Provides a sequence to use if 
					// automatic sniffing on startup produces more than one sniffable Cause 
					// node as a presumptive cause
#define H_NODE_MANUAL_SNIFF_TEXT _T("HNodeManualSniffText") // text to explain the manual 
					// sniff button offered for this node.

#define H_NODE_PROB_SEQUENCE 	_T("HProbSequence")	// Provides a sequence for problems
					// on the Problem Page.

// Properties used only by TS Assembler
#define SZ_TS_TITLE _T("HXTITLETxt")
#define SZ_TS_METATAG _T("HNetMeta")
#define SZ_TS_CHARSET _T("HNetCharSet")
#define SZ_TS_DIRTAG _T("HNetDirTag")
// END Properties used only by TS Assembler

#endif // !defined(PROPNAMES_H_INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\recentuse.cpp ===
//
// MODULE: RecentUse.cpp
//
// PURPOSE: To maintain a "session" this can track whether a give value (either 
//	a cookie value or an IP address) has been "recently" used
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 11-4-98
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		11/4/98		JM		original

#include "stdafx.h"
#include "RecentUse.h"

//////////////////////////////////////////////////////////////////////
// CRecentUse
//////////////////////////////////////////////////////////////////////

CRecentUse::CRecentUse(DWORD minExpire /* = 15 */)
{
	m_minExpire = minExpire;
}

CRecentUse::~CRecentUse()
{

}

// Start tracking a new value
// SIDE EFFECT: if there are more than 10 values being tracked, see if any of them
//	are out of date & get rid of them.  This strategy is efficient as long as m_Recent
//	never gets very big, which is the expectation in APGTS.
// Will fail silently in the very unlikely case that adding to the map throws an exception.
void CRecentUse::Add(CString str)
{
	time_t timeNow;
	time (&timeNow);
	try
	{
		m_Recent[str] = timeNow;
	}
	catch (...)
	{
	}

	// SIDE EFFECT
	if (m_Recent.size() > 10)
		Flush();
}

// If the input string value has been used within the relevant interval, return true 
//	and update the time of most recent use.
bool CRecentUse::Validate(CString str)
{
	bool bRet = false;

	TimeMap::iterator it = m_Recent.find(str);

	if ( it != m_Recent.end())
		bRet = Validate(it);

	return bRet;
}

// If the string value it->first has been used within the relevant interval, return true 
//	and update the time of most recent use (it->second).
// Before calling this, verify that it is a valid iterator, not m_Recent.end()
// SIDE EFFECT: if it->first hasn't been used within the relevant interval, remove *it
//	from m_Recent.  This side effect means that in the case of a false return, it no longer
//	will point to the same value.
bool CRecentUse::Validate(TimeMap::iterator it)
{
	bool bRet = false;

	time_t timeNow;
	time (&timeNow);

	if (timeNow - it->second < m_minExpire * 60 /* secs per min */)
	{
		bRet = true;
		it->second = timeNow;
	}
	else
		// SIDE EFFECT: it's not current, no point to keeping it around.
		m_Recent.erase(it);

	return bRet;
}

// Get rid of all elements of m_Recent that haven't been used within the relevant interval
void CRecentUse::Flush()
{
	TimeMap::iterator it = m_Recent.begin();
	while (it != m_Recent.end())
	{
		if (Validate(it))
			++it;	// on to the next
		else
			m_Recent.erase(it);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\nodestate.cpp ===
//
// MODULE: NODESTATE.CPP
//
// PURPOSE: Implement some functions relevant to CNodeState
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 10/99
//
// NOTES: 
// 1. 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		10/15/99	JM		original
//


#include "nodestate.h"
#include <algorithm>


// operator-= removes only identical node/state pairs.
// This is the appropriate behavior if lhs represents all current node states and rhs
//	represents sniffed values: if the node already deviates from a sniffed value, and
//	we are removing sniffed values, this sniffed value is irrelevant & shouldn't be
//	removed from lhs.
// this is an N-squared algorithm.  
// >>> $MAINT There might be a case for working with sorted lists and STL generic 
//	algorithms, which could reduce this to N log N
CBasisForInference& operator-=(CBasisForInference& lhs, const CBasisForInference& rhs)
{
	CBasisForInference::iterator i = lhs.begin();
	while ( i != lhs.end() )
	{
		NID inid = i->nid();
		IST istate = i->state();
		bool bMatch = false;

		for (CBasisForInference::const_iterator j = rhs.begin(); j != rhs.end(); ++j)	
		{
			if (j->nid() == inid && j->state() == istate)
			{
				bMatch = true;
				break;
			}
		}
		if (bMatch)
			i = lhs.erase(i);
		else
			++i;
	}
		
	return lhs;
}

// operator+= adds only pairs for which there is no match to any node already in lhs.
// This is the appropriate behavior if lhs represents node states obtained by means other
//	than sniffing and rhs represents re-sniffed values: if the node already has a value 
//	assigned by other means, the sniffed values are irrelevant & shouldn't be
//	added to lhs.
// this is an N-squared algorithm.  
// >>> $MAINT There might be a case for working with sorted lists and STL generic 
//	algorithms, which could reduce this to N log N
CBasisForInference& operator+=(CBasisForInference& lhs, const CBasisForInference& rhs)
{
	for (CBasisForInference::const_iterator j = rhs.begin(); j != rhs.end(); ++j)	
	{
		NID jnid = j->nid();
		bool bMatch = false;

		for (CBasisForInference::const_iterator i = lhs.begin(); i != lhs.end(); ++i)
		{
			if (i->nid() == jnid)
			{
				bMatch = true;
				break;
			}
		}
		if (!bMatch)
			lhs.push_back(*j);
	}
		
	return lhs;
}

vector<NID>& operator-=(vector<NID>& lhs, const CBasisForInference& rhs)
{
	for (long i = 0; i < rhs.size(); i++)
	{
		vector<NID>::iterator found = find(lhs.begin(), lhs.end(), rhs[i].nid());

		if (found < lhs.end())
			lhs.erase(found);
	}
	return lhs;
}

vector<NID>& operator+=(vector<NID>& lhs, const CBasisForInference& rhs)
{
	for (long i = 0; i < rhs.size(); i++)
		lhs.push_back(rhs[i].nid());

	return lhs;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\nodestate.h ===
//
// MODULE: NODESTATE.H
//
// PURPOSE: Declare types and values relevant to NID (node ID) and IST (state)
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Roman Mach, Joe Mabel
// 
// ORIGINAL DATE: 8-2-96
//
// NOTES: 
// 1. 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		7-21-98		JM		Major revision, deprecate IDH in favor of NID, use STL.
//								Extract this from apgtsinf.h, apgtscac.h
//

#if !defined(NODESTATE_H_INCLUDED)
#define APGTSINF_H_INCLUDED

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include<windows.h>
#include <vector>
using namespace std;

typedef unsigned int	   NID;		// node ID

//  Special node values
//	Please Note: nidService and nidNil are mirrored in dtguiapi.bas, please keep in sync
const NID	nidService = 12345;
const NID	nidNil     = 12346;

// newly introduced 7/1998
const NID	nidProblemPage = 12000;
const NID	nidByeNode = 12101;
const NID	nidFailNode = 12102;
const NID	nidImpossibleNode = 12103;
const NID	nidSniffedAllCausesNormalNode = 12104;

typedef vector<NID> CRecommendations;

// The IDHs are a deprecated feature provided only for backward compatibility on
//	GET method inquiries.  Most IDHs are NID + 1000; there are also several special values.
typedef	UINT	IDH;
const IDH IDH_BYE = 101;
const IDH IDH_FAIL = 102;
const IDH idhFirst = 1000;

typedef UINT   IST;		// state number
// Special state numbers
const IST ST_WORKED	= 101;	// Go to "Bye" Page (User succeeded)
const IST ST_UNKNOWN = 102; // Unknown (user doesn't know the correct answer here - applies to 
							//	Fixable/Unfixable and Info nodes only)
const IST ST_ANY = 103;		// "Anything Else?"

class CNodeStatePair
{
private:
	NID m_nid;
	IST m_state;
public:
	CNodeStatePair();  // do not instantiate; exists only so vector can compile

	// the only constructor you should call is:
	CNodeStatePair(const NID n, const IST s) :
		m_nid(n), m_state(s)
		{};

	bool operator< (const CNodeStatePair &pair) const
	{
		return (m_nid < pair.m_nid || m_state < pair.m_state);
	}

	bool operator== (const CNodeStatePair &pair) const
	{
		return (m_nid == pair.m_nid && m_state == pair.m_state);
	}

	NID nid() const {return m_nid;}
	IST state() const {return m_state;}
};

typedef vector<CNodeStatePair> CBasisForInference;


CBasisForInference& operator-=(CBasisForInference& lhs, const CBasisForInference& rhs);
CBasisForInference& operator+=(CBasisForInference& lhs, const CBasisForInference& rhs);

vector<NID>& operator-=(vector<NID>& lhs, const CBasisForInference& rhs);
vector<NID>& operator+=(vector<NID>& lhs, const CBasisForInference& rhs);


#endif // !defined(NODESTATE_H_INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\registrypasswords.cpp ===
//
// MODULE: RegistryPasswords.cpp
//
// PURPOSE: Handles the storing and retrieval of encrypted passwords in the registry.
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Randy Biley
// 
// ORIGINAL DATE: 10-23-98
//
// NOTES:	See RegistryPasswords.h
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		10-23-98	RAB
//
#include "stdafx.h"
#include "RegistryPasswords.h"
#include "BaseException.h"
#include "Event.h"
#include "regutil.h"


#ifndef CRYPT_MACHINE_KEYSET
// This flag was exposed in Windows NT 4.0 Service Pack 2.
#define CRYPT_MACHINE_KEYSET 0x00000020
// By default, keys are stored in the HKEY_CURRENT_USER portion of the registry. 
// The CRYPT_MACHINE_KEYSET flag can be combined with all of the other flags, 
// indicating that the location for the key of interest is HKEY_LOCAL_MACHINE. 
// When combined with the CRYPT_NEW_KEYSET flag, the CRYPT_MACHINE_KEYSET flag 
// is useful when access is being performed from a service or user account that 
// did not log on interactively. This combination enables access to user specific 
// keys under HKEY_LOCAL_MACHINE. 
//
// This setting is necessary in the the online troubleshooter in all 
// CryptAcquireContext() calls.
#endif


CRegistryPasswords::CRegistryPasswords( 
			LPCTSTR szRegSoftwareLoc /* =REG_SOFTWARE_LOC */,	// Registry Software Key location.
			LPCTSTR szRegThisProgram /* =REG_THIS_PROGRAM */,	// Registry Program Name.
			LPCTSTR szKeyContainer /* =REG_THIS_PROGRAM */,		// Key Container Name.
			LPCTSTR szHashString /* =HASH_SEED */				// Value used to seed the hash.
			)
	: m_hProv( NULL ), m_hHash( NULL ), m_hKey( NULL ), m_bAllValid( false )
{
	try
	{
		m_strRegSoftwareLoc= szRegSoftwareLoc;
		m_strRegThisProgram= szRegThisProgram;

		// Attempt to acquire a handle to a particular key container.
		if (::CryptAcquireContext(	&m_hProv, szKeyContainer, 
									MS_DEF_PROV,	// "Microsoft Base Cryptographic Provider v1.0"
									PROV_RSA_FULL,	// This provider type supports both digital signatures 
													// and data encryption, and is considered general purpose. 
													// The RSA public-key algorithm is used for all public-key operations. 
									CRYPT_MACHINE_KEYSET ) == FALSE)	
		{	
			// Attempt to create a particular key container and acquire handle 
			if (::CryptAcquireContext(	&m_hProv, szKeyContainer, 
										MS_DEF_PROV, 
										PROV_RSA_FULL, 
										CRYPT_NEWKEYSET | CRYPT_MACHINE_KEYSET ) == FALSE)	
			{
				throw CGenSysException( __FILE__, __LINE__, _T("AcquireContext"), ::GetLastError() );
			}
		}

		// Attempt to acquire a handle to a CSP hash object.
		/*** 
		Available hashing algorithms. 
		CALG_HMACHMAC,		a keyed hash algorithm 
		CALG_MAC			Message Authentication Code
		CALG_MD2			MD2
		CALG_MD5			MD5
		CALG_SHA			US DSA Secure Hash Algorithm
		CALG_SHA1			Same as CALG_SHA
		CALG_SSL3_SHAMD5	SSL3 client authentication 
		***/
		if (::CryptCreateHash(	m_hProv, CALG_SHA, 0, NULL, &m_hHash ) == FALSE)
			throw CGenSysException( __FILE__, __LINE__, _T("CreateHash"), ::GetLastError() );

		// Hash a string.
		if (::CryptHashData(	m_hHash, (BYTE *) szHashString, _tcslen( szHashString ), 
								NULL ) == FALSE)	
		{
			throw CGenSysException( __FILE__, __LINE__, _T("HashData"), ::GetLastError() );
		}

		// Generate a cryptographic key derived from base data.
		if (::CryptDeriveKey(	m_hProv, 
								CALG_RC4, // RC4 stream encryption algorithm
								m_hHash, NULL, &m_hKey ) == FALSE)
		{
			throw CGenSysException( __FILE__, __LINE__, _T("DeriveKey"), ::GetLastError() );
		}

		// Toggle on flag to indicate that all Crypto handles have been initialized.
		m_bAllValid= true;
	}
	catch (CGenSysException& x)
	{
		// Log the error.
		LPVOID lpErrorMsgBuf;
		CString strErrorMsg;
		::FormatMessage(	FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
							NULL, x.GetErrorCode(), 
							MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT ), 
							(LPTSTR) &lpErrorMsgBuf, 0, NULL );
		strErrorMsg.Format(_T("Encryption failure: %s"), (char *) lpErrorMsgBuf);
		
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	x.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								strErrorMsg, x.GetSystemErrStr(), 
								EV_GTS_ERROR_ENCRYPTION );
		::LocalFree(lpErrorMsgBuf);
		
		// Perform any cleanup.
		Destroy();
	}
	catch (...)
	{
		// Catch any other exceptions and do nothing.
	}
}


CRegistryPasswords::~CRegistryPasswords()
{
	// Utilize function destroy to avoid potentially throwing an exception
	// within the destructor.
	Destroy();
}


bool CRegistryPasswords::WriteKey( const CString& RegKey, const CString& RegValue )
{
	bool	bRetVal= false;

	// Verify that the constructor worked properly.
	if (!m_bAllValid)
		return( bRetVal );

	// Verify that a key and a value were passed in.
	if ((!RegValue.IsEmpty()) && (!RegKey.IsEmpty()))
	{
		TCHAR	*pBuffer;
		DWORD	dwSize;
		
		if (EncryptKey( RegValue, &pBuffer, (LONG *)&dwSize ))
		{
			// Write the encrypted string to the registry.
			CRegUtil reg;
			bool was_created = false;

			if (reg.Create( HKEY_LOCAL_MACHINE, m_strRegSoftwareLoc, &was_created, KEY_QUERY_VALUE | KEY_WRITE))
			{
				if (reg.Create( m_strRegThisProgram, &was_created, KEY_READ | KEY_WRITE ))
				{
					if (reg.SetBinaryValue( RegKey, pBuffer, dwSize ))
						bRetVal= true;
				}
			}
			delete [] pBuffer;
		}
	}

	return( bRetVal );
}

// Note that if this returns true, *ppBuf will point to a new buffer on the heap.
//	The caller of this function is responsible for deleting that.
bool CRegistryPasswords::EncryptKey( const CString& RegValue, char** ppBuf, long* plBufLen )
{
	bool bRetVal= false;

	// Verify that the constructor worked properly.
	if (!m_bAllValid)
		return( bRetVal );

	if (!RegValue.IsEmpty())
	{
		BYTE* pData= NULL;
		DWORD dwSize= 0;

		// Set variable to length of data in buffer.
		dwSize= RegValue.GetLength();

		// Have API return us the required buffer size for encryption.
		if (::CryptEncrypt(	m_hKey, 0, TRUE, NULL, NULL, &dwSize, dwSize ) == FALSE)
		{
			DWORD dwErr= ::GetLastError();
			CString strCryptErr;

			strCryptErr.Format( _T("%lu"), dwErr );
			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									RegValue, strCryptErr,
									EV_GTS_ERROR_ENCRYPTION );
			return( bRetVal );
		}

		// We now have a size for the output buffer, so create buffer.
		try
		{
			pData= new BYTE[ dwSize + 1 ];
			//[BC-03022001] - added check for NULL ptr to satisfy MS code analysis tool.
			if(!pData)
				throw bad_alloc();
		}
		catch (bad_alloc&)
		{
			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									_T("Failure to allocate"),
									_T("space to encrypt key"),
									EV_GTS_ERROR_ENCRYPTION );
			return( bRetVal );
		}
		memcpy( pData, RegValue, dwSize );
		pData[ dwSize ]= NULL;

		// Encrypt the passed in string.
		if (::CryptEncrypt(	m_hKey, 0, TRUE, NULL, (BYTE *)pData, &dwSize, dwSize + 1 ) == FALSE)
		{
			// Log failure to encrypt.  
			DWORD dwErr= ::GetLastError();
			CString strCryptErr;

			strCryptErr.Format( _T("%lu"), dwErr );
			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									RegValue, strCryptErr,
									EV_GTS_ERROR_ENCRYPTION );
			delete [] pData;
		}
		else
		{
			pData[ dwSize ]= 0;
			*ppBuf= (char*)pData;
			*plBufLen = dwSize;
			bRetVal= true;
		}
	}

	return( bRetVal );
}

bool CRegistryPasswords::KeyValidate( const CString& RegKey, const CString& RegValue )
{
	bool bRetVal= false;

	// Verify that the constructor worked properly.
	if (!m_bAllValid)
		return( bRetVal );

	// Verify that a key and a value were passed in.
	if ((!RegValue.IsEmpty()) && (!RegKey.IsEmpty()))
	{
		CRegUtil reg;

		// Open up the desired key.
		if (reg.Open( HKEY_LOCAL_MACHINE, m_strRegSoftwareLoc, KEY_QUERY_VALUE ))
		{
			if (reg.Open( m_strRegThisProgram, KEY_QUERY_VALUE ))
			{
				TCHAR	*pRegEncrypted;
				DWORD	dwRegSize;
				TCHAR	*pChkEncrypted;
				DWORD	dwChkSize;
				
				// Attempt to read the current setting from the registry.
				if (reg.GetBinaryValue( RegKey, &pRegEncrypted, (LONG *)&dwRegSize )) 
				{
					// Verify that the registry key had a previous value.
					if (dwRegSize < 1)
					{
						delete [] pRegEncrypted;
						return( bRetVal );
					}


					// Encrypt the passed in value. 
					if (EncryptKey( RegValue, &pChkEncrypted, (LONG *)&dwChkSize ))
					{
						// Compare the two unencrypted strings.
						if (dwRegSize == dwChkSize)
						{
							if (!memcmp( pRegEncrypted, pChkEncrypted, dwRegSize ))
								bRetVal= true;
						}
						delete [] pChkEncrypted;
					}

					delete [] pRegEncrypted;
				}
			}
		}
	}

	return( bRetVal );
}


// This function is used to clean up from any potential exceptions thrown within the
// ctor as well as standing in for the dtor.
void CRegistryPasswords::Destroy()
{
	try
	{
		// Toggle off flag that indicates valid Crypto handles.
		m_bAllValid= false;

		if (m_hKey)
		{
			if (::CryptDestroyKey( m_hKey ) == FALSE)
				throw CGenSysException( __FILE__, __LINE__, 
										_T("Failure to destroy key"), 
										EV_GTS_PASSWORD_EXCEPTION );
			m_hKey= NULL;
		}

		if (m_hHash)
		{
			if (::CryptDestroyHash( m_hHash ) == FALSE)
				throw CGenSysException( __FILE__, __LINE__, 
										_T("Failure to destroy hash"), 
										EV_GTS_PASSWORD_EXCEPTION );
			m_hHash= NULL;
		}

		if (m_hProv)
		{
			if (::CryptReleaseContext( m_hProv, 0 ) == FALSE)
				throw CGenSysException( __FILE__, __LINE__, 
										_T("Failure to release context"), 
										EV_GTS_PASSWORD_EXCEPTION );
			m_hProv= NULL;
		}
	}
	catch (CGenSysException& x)
	{
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	x.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								x.GetErrorMsg(), x.GetSystemErrStr(), 
								x.GetErrorCode() ); 
	}
	catch (...)
	{
		// Catch any other exceptions and do nothing.
	}

	return;
}


//
// EOF.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\regutil.cpp ===
//
// MODULE: "RegUtil.cpp"
//
// PURPOSE: class CRegUtil
//	Encapsulates access to system registry.
//	This is intended as generic access to the registry, independent of any particular
//	application.
//
// PROJECT: first developed as part of Belief Network Editing Tools ("Argon")
//	Later modified to provide more extensive features as part of version 3.0 of the
//	Online Troubleshooter (APGTS)
//
// AUTHOR: Lonnie Gerrald (LDG), Oleg Kalosha, Joe Mabel
// 
// ORIGINAL DATE: 3/25/98
//
// NOTES: 
// 1. The Create, Open, and Close functions support a model where m_hKey represents a 
//	"position" in the registry.  Successive calls to Create() or Open() migrate deeper 
//	into the registry hierarchy.  Close closes all keys encountered on the way down to 
//	the current m_hKey.
//	
//
// Version		Date		By		Comments
//--------------------------------------------------------------------
// V0.1(Argon)	3/25/98		LDG		
// V3.0			8/??/98		OK	
// V3.0			9/9/98		JM	
//
#include "stdafx.h"
#include "regutil.h"
#include "event.h"
#include "baseexception.h"
#include "CharConv.h"

//////////////////////////////////////////////////////////////////////
// CRegUtil
//////////////////////////////////////////////////////////////////////
CRegUtil::CRegUtil()
        : m_hKey(NULL),
		  m_WinError(ERROR_SUCCESS)
{
}

CRegUtil::CRegUtil(HKEY key)
        : m_hKey(key),
		  m_WinError(ERROR_SUCCESS)
{
}

CRegUtil::~CRegUtil()
{
	Close();
}


// creates the specified key. If the key already exists in the registry, the function opens it. 
// returns true on success, false otherwise.
bool CRegUtil::Create(HKEY hKeyParent, const CString& strKeyName, bool* bCreatedNew, REGSAM access /*=KEY_ALL_ACCESS*/)
{
	HKEY hRetKey = NULL;
	DWORD dwDisposition = 0;

	m_WinError = ::RegCreateKeyEx(
		hKeyParent,
		strKeyName,
		0,
		NULL,
		REG_OPTION_NON_VOLATILE,
		access,
		NULL,
		&hRetKey,
		&dwDisposition
		);

	if(m_WinError == ERROR_SUCCESS)
	{
		m_hKey = hRetKey;
		*bCreatedNew = dwDisposition == REG_CREATED_NEW_KEY ? true : false;
		
		try
		{
			m_arrKeysToClose.push_back(hRetKey);
		}
		catch (exception& x)
		{
			CString str;
			// Note STL exception in event log.
			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									CCharConversion::ConvertACharToString(x.what(), str), 
									_T(""), 
									EV_GTS_STL_EXCEPTION ); 
		}

		return true;
	}
	return false;
}

// Unlike CRegUtil::Create, CRegUtil::Open does not create the specified key if the key does not 
// exist in the registry. Thus it can be used to test whether the key exists.
// returns true on success, false otherwise.
bool CRegUtil::Open(HKEY hKeyParent, const CString& strKeyName, REGSAM access /*=KEY_ALL_ACCESS*/)
{
	HKEY hRetKey = NULL;

    m_WinError = ::RegOpenKeyEx( 
		hKeyParent,
		strKeyName,
		0,
		access,
		&hRetKey
		); 
  
	if(m_WinError == ERROR_SUCCESS)
	{
		m_hKey = hRetKey;
		try
		{
			m_arrKeysToClose.push_back(hRetKey);
		}
		catch (exception& x)
		{
			CString str;
			// Note STL exception in event log.
			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									CCharConversion::ConvertACharToString(x.what(), str), 
									_T(""), 
									EV_GTS_STL_EXCEPTION ); 
		}

		return true;
	}
	return false;
}

// creates the specified subkey of m_hKey. If the key already exists in the registry, the function opens it. 
// returns true on success, false otherwise.
bool CRegUtil::Create(const CString& strKeyName, bool* bCreatedNew, REGSAM access /*=KEY_ALL_ACCESS*/)
{
	return Create(m_hKey, strKeyName, bCreatedNew, access);
}

// opens the specified subkey of m_hKey. 
// Unlike CRegUtil::Create, CRegUtil::Open does not create the specified key if the key does not 
// exist in the registry. Thus it can be used to test whether the key exists.
// returns true on success, false otherwise.
bool CRegUtil::Open(const CString& strKeyName, REGSAM access /*=KEY_ALL_ACCESS*/)
{
	return Open(m_hKey, strKeyName, access);
}

// Close all keys encountered on the way down to the current m_hKey.
void CRegUtil::Close()
{
	for (vector<HKEY>::reverse_iterator i = m_arrKeysToClose.rbegin(); i != m_arrKeysToClose.rend(); i++)
		::RegCloseKey( *i );

	m_arrKeysToClose.clear();
}

bool CRegUtil::DeleteSubKey(const CString& strSubKey)
{
	// What does m_hKey point to after a successful deletion?  RAB-981116.
	m_WinError = ::RegDeleteKey(m_hKey, strSubKey);
	if (m_WinError == ERROR_SUCCESS)
		return true;
	return false;
}

bool CRegUtil::DeleteValue(const CString& strValue)
{
	m_WinError = ::RegDeleteValue(m_hKey, strValue);
	if (m_WinError == ERROR_SUCCESS)
		return true;
	return false;
}

bool CRegUtil::SetNumericValue(const CString& strValueName, DWORD dwValue)
{
	BYTE* pData = (BYTE*)&dwValue;
	m_WinError = ::RegSetValueEx(
		m_hKey,
		strValueName,
		0,
		REG_DWORD,
		pData,
		sizeof(DWORD)
		);

	if (m_WinError == ERROR_SUCCESS)
		return true;
	return false;
}

bool CRegUtil::SetStringValue(const CString& strValueName, const CString& strValue)
{
	BYTE* pData = (BYTE*)(LPCTSTR)strValue;
	m_WinError = ::RegSetValueEx(
		m_hKey,
		strValueName,
		0,
		REG_SZ,
		pData,
		strValue.GetLength()+sizeof(TCHAR)
		);

	if (m_WinError == ERROR_SUCCESS)
		return true;
	return false;
}

bool CRegUtil::SetBinaryValue(const CString& strValueName, char* buf, long buf_len)
{
	BYTE* pData = (BYTE*)buf;
	m_WinError = ::RegSetValueEx(
		m_hKey,
		strValueName,
		0,
		REG_BINARY,
		pData,
		buf_len
		);

	if (m_WinError == ERROR_SUCCESS)
		return true;
	return false;
}

bool CRegUtil::GetNumericValue(const CString& strValueName, DWORD& dwValue)
{
	DWORD tmp = 0;
	BYTE* pData = (BYTE*)&tmp;
	DWORD type = 0;
	DWORD size = sizeof(DWORD);

	m_WinError = ::RegQueryValueEx(
		m_hKey,
		strValueName,
		NULL,
		&type,
		pData,
		&size
		);

	if (type != REG_DWORD)
		return false;

	if (m_WinError == ERROR_SUCCESS)
	{
		dwValue = tmp;
		return true;
	}
	return false;
}

bool CRegUtil::GetStringValue(const CString& strValueName, CString& strValue)
{
	BYTE* pData = NULL;
	DWORD type = 0;
	DWORD size = 0;

	// determine data size
	m_WinError = ::RegQueryValueEx(
		m_hKey,
		strValueName,
		NULL,
		&type,
		NULL,
		&size
		);
	
	if (m_WinError != ERROR_SUCCESS)
		return false;

	if (type != REG_SZ && type != REG_EXPAND_SZ)
		return false;

	bool bRet = false;	// should be only one return from here down: we're about to
						// alloc pData and must make sure it's correctly cleaned up.

	try
	{
		pData = new BYTE[size];
	}
	catch (bad_alloc&)
	{
		return false;
	}

	memset(pData, 0, size);
	m_WinError = ::RegQueryValueEx(
		m_hKey,
		strValueName,
		NULL,
		&type,
		pData,
		&size
		);

	if (m_WinError == ERROR_SUCCESS)
	{
		if (type == REG_EXPAND_SZ )
		{
			BYTE* pDataExpanded = NULL;
			DWORD dwExpandedSize;

			// first we call ExpandEnvironmentStrings just to get the length
			// casting away unsignedness
			dwExpandedSize = ::ExpandEnvironmentStrings(
				reinterpret_cast<const TCHAR *>(pData), 
				reinterpret_cast<TCHAR *>(pDataExpanded), 
				0);
			if (dwExpandedSize > 0)
			{
				try
				{
					pDataExpanded = new BYTE[dwExpandedSize];

					// then we call ExpandEnvironmentStrings again to get the expanded value
					// casting away unsignedness
					if (::ExpandEnvironmentStrings(
						reinterpret_cast<const TCHAR *>(pData), 
						reinterpret_cast<TCHAR *>(pDataExpanded), 
						dwExpandedSize)) 
					{
						strValue = (LPTSTR)pDataExpanded;
						delete [] pDataExpanded;
						bRet = true;
					}
				}
				catch (bad_alloc&)
				{
					// Note memory failure in event log.
					CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
					CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
											SrcLoc.GetSrcFileLineStr(), 
											_T(""), _T(""), EV_GTS_CANT_ALLOC ); 
				}
			}
		}
		else
		{
			strValue = (LPTSTR)pData;
			bRet = true;
		}
	}
	
	delete [] pData;
	return bRet;
}

// The second parameter should be passed in as the address of a char *.
// Note that if this returns true, *ppBuf will point to a new buffer on the heap.
//	The caller of this function is responsible for deleting that.
bool CRegUtil::GetBinaryValue(const CString& strValueName, char** ppBuf, long* pBufLen)
{
	BYTE* pData = NULL;
	DWORD type = 0;
	DWORD size = 0;

	// determine data size
	m_WinError = ::RegQueryValueEx(
		m_hKey,
		strValueName,
		NULL,
		&type,
		NULL,
		&size
		);
	
	if (m_WinError != ERROR_SUCCESS || type != REG_BINARY)
		return false;

	try
	{
		// Increase the buffer size by one over what we need.  Small price to
		// pay for processing convenience elsewhere.
		pData = new BYTE[size+1];
	}
	catch (bad_alloc&)
	{
		return false;
	}

	memset(pData, 0, size);
	m_WinError = ::RegQueryValueEx(
		m_hKey,
		strValueName,
		NULL,
		&type,
		pData,
		&size
		);

	if (m_WinError == ERROR_SUCCESS)
	{
		// Null terminate the binary string for processing convenience elsewhere.
		pData[size]= 0;
		*ppBuf = (char*)pData;
		*pBufLen = size;
		return true;
	}
	
	delete [] pData;
	return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\registrymonitor.h ===
//
// MODULE: RegistryMonitor.h
//
// PURPOSE: Monitor changes to the registry.
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 9-16-98
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		09-16-98	JM
//

#if !defined(AFX_REGISTRYMONITOR_H__A3CFA77B_4D78_11D2_95F7_00C04FC22ADD__INCLUDED_)
#define AFX_REGISTRYMONITOR_H__A3CFA77B_4D78_11D2_95F7_00C04FC22ADD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "DirMonitor.h"
#include "apgtsregconnect.h"

class CThreadPool;		// forward reference
class CHTMLLog;			// forward reference

class CRegistryMonitor : public CAPGTSRegConnector
{
public:
	enum ThreadStatus{eBeforeInit, eInit, eFail, eDefaulting, eWait, eRun, eExiting};
	static CString ThreadStatusText(ThreadStatus ts);
private:
	CDirectoryMonitor & m_DirectoryMonitor; // Need access to this because CRegistryMonitor
											// will determine what directory needs to be monitored
											// and what the criteria are for files "settling down"
	HANDLE m_hThread;
	HANDLE m_hevMonitorRequested;			// event to wake up RegistryMonitorTask
											// this allows it to be wakened other than
											// by the registry change event.  Currently used
											// only for shutdown.
	HANDLE m_hevInitialized;				// event to be set when either:
											//	(1) CRegistryMonitor values have been initialized or
											//		from registry
											//	(2) We can't get registry access, so CRegistryMonitor
											//		default values will have to do
	bool m_bMustStartDirMonitor;			// initially true, false once we've given
											//	DirMonitor info as to what directory to
											//	monitor
	bool m_bMustStartThreadPool;			// initially true, false once we've set some size for the
											//	working-thread pool
	HANDLE m_hevThreadIsShut;				// event just to indicate exit of RegistryMonitorTask thread
	bool m_bShuttingDown;					// lets registry monitor thread know we're shutting down
	DWORD m_dwErr;							// status from starting the thread
	ThreadStatus m_ThreadStatus;
	time_t m_time;							// time last changed ThreadStatus.  Initialized
											// to zero ==> unknown
	CThreadPool * m_pThreadPool;			// pointer to pool of working threads

	CString m_strTopicName;					// This string is ignored in the Online Troubleshooter.
											// Done under the guise of binary compatibility.

	CHTMLLog *m_pLog;						// pointer to the logging object so that we can
											// change the log file directory.

public:
	CRegistryMonitor(	CDirectoryMonitor & DirectoryMonitor, CThreadPool * pThreadPool,
						const CString& strTopicName,
						CHTMLLog *pLog );	// strTopicName is ignored in the Online Troubleshooter.
											// Done under the guise of binary compatibility.
	virtual ~CRegistryMonitor();

	DWORD GetStatus(ThreadStatus &ts, DWORD & seconds);

	// NOTE that this also provides many inherited CRegistryMonitor methods
private:
	CRegistryMonitor();		// do not instantiate
	void SetThreadStatus(ThreadStatus ts);

	// just for use by own destructor
	void ShutDown();

	// functions for use by the DirectoryMonitorTask thread.
	void Monitor();
	void AckShutDown();
	void LoadChangedRegistryValues();

	// main function of the RegistryMonitorTask thread.
	static UINT WINAPI RegistryMonitorTask(LPVOID lpParams);
};

#endif // !defined(AFX_REGISTRYMONITOR_H__A3CFA77B_4D78_11D2_95F7_00C04FC22ADD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\registrypasswords.h ===
//
// MODULE: RegistryPasswords.h
//
// PURPOSE: Handles the storing and retrieval of encrypted passwords in the registry.
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Randy Biley
// 
// ORIGINAL DATE: 10-23-98
//
// NOTES:	Utilizes CryptoAPI v2.0 to store and retrieve passwords from the registry.
//
//			Here are some sample calls. 
//			{
//				// Construct a registry password object.
//				CRegistryPasswords pwd( _T("SOFTWARE\\ISAPITroubleShoot"), 
//										_T("APGTS"), _T("APGTS"), _T("Koshka8Spider") );
//				... or equivalently 	
//				CRegistryPasswords pwd( ); 
//				bool bRetVal;
//
//				pwd.WriteKey( _T("StatusAccess"), _T("2The9s") );	// Writes an encrypted password.
//				bRetVal= pwd.KeyValidate( _T("StatusAccess"), _T("2The9s1") );	// Returns false.
//				bRetVal= pwd.KeyValidate( _T("StatusAccess"), _T("2The9s") );	// Returns true.
//			}
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		10-23-98	RAB
//

#ifndef __REGISTRYPASSWORDS_19981023_H_
#define __REGISTRYPASSWORDS_19981023_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <windows.h>
#include <wincrypt.h>
#include "apgtsstr.h"
#include "apgts.h"

#define HASH_SEED _T("Koshka8Spider")

class CRegistryPasswords
{
public:
	// Assembles all of the CryptAPI components.
	CRegistryPasswords( 
			LPCTSTR szRegSoftwareLoc=REG_SOFTWARE_LOC,	// Registry Software Key location.
			LPCTSTR szRegThisProgram=REG_THIS_PROGRAM,	// Registry Program Name.
			LPCTSTR szKeyContainer=REG_THIS_PROGRAM,	// Key Container Name.
			LPCTSTR szHashString=HASH_SEED				// Value used to seed the hash.
			);	

	// Simply calls Destroy().
	~CRegistryPasswords();	

	// Function to encrypt and then write RegValue to RegKey.
	bool WriteKey( const CString& RegKey, const CString& RegValue );

	// Function to encrypt a given key.
	bool EncryptKey( const CString& RegValue, char** ppBuf, long* plBufLen );

	// Function to retrieves and then decrypt the value stored in RegKey, 
	// compares to RegValue, returns true if equal.
	bool KeyValidate( const CString& RegKey, const CString& RegValue );


private:
	void Destroy();			// Releases all of the CryptAPI components.

	HCRYPTPROV	m_hProv;		// The handle to a CSP.
	HCRYPTHASH	m_hHash;		// The handle to a hash object.
	HCRYPTKEY	m_hKey;			// The handle to a cryptographic key.
	bool		m_bAllValid;	// A flag when set to true indicates valid handles for the
								// three objects above.
	CString		m_strRegSoftwareLoc;	// Registry location e.g. _T("SOFTWARE\\ISAPITroubleShoot")
	CString		m_strRegThisProgram;	// Registry program name e.g. _T("APGTS")
} ;

#endif
//
// EOF.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\registrymonitor.cpp ===
//
// MODULE: RegistryMonitor.cpp
//
// PURPOSE: Monitor changes to the registry.
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 9-16-98
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		09-16-98	JM
//

#pragma warning(disable:4786)

#include "stdafx.h"
#include "RegistryMonitor.h"
#include "apgts.h"//Added 20010302 for RUNNING_LOCAL_TS macro
#include "event.h"
#include "apiwraps.h"	
#include "ThreadPool.h"
#include "apgtslog.h"	

//////////////////////////////////////////////////////////////////////
// CRegistryMonitor::ThreadStatus
//////////////////////////////////////////////////////////////////////
/* static */ CString CRegistryMonitor::ThreadStatusText(ThreadStatus ts)
{
	switch(ts)
	{
	 
		case eBeforeInit:		return _T("Before Init");
		case eInit:				return _T("Init");
		case eFail:				return _T("Fail");
		case eDefaulting:		return _T("Defaulting");
		case eWait:				return _T("Wait");
		case eRun:				return _T("Run");
		case eExiting:			return _T("Exiting");
		default:				return _T("");
	}
}

//////////////////////////////////////////////////////////////////////
// CRegistryMonitor
// This class does the bulk of its work on a separate thread.
// The thread is created in the constructor by starting static function
//	CDirectoryMonitor::RegistryMonitorTask
// That function, in turn does its work by calling private members of this class that
//	are specific to use on the RegistryMonitorTask thread.
// When this goes out of scope, its own destructor calls ShutDown to stop the thread,
//	waits for the thread to shut.
// Inherited methods from CRegistryMonitor are available to other threads.
//////////////////////////////////////////////////////////////////////

CRegistryMonitor::CRegistryMonitor(	CDirectoryMonitor & DirectoryMonitor, 
									CThreadPool * pThreadPool,
									const CString& strTopicName,
									CHTMLLog *pLog )
  : CAPGTSRegConnector( strTopicName ),
	m_DirectoryMonitor(DirectoryMonitor),
	m_bMustStartDirMonitor(true),
	m_bMustStartThreadPool(true),
	m_bShuttingDown(false),
	m_dwErr(0),
	m_ThreadStatus(eBeforeInit),
	m_time(0), 
	m_pThreadPool(pThreadPool),
	m_pLog( pLog )
{
	enum {eHevMon, eHevInit, eHevShut, eThread, eOK} Progress = eHevMon;

	SetThreadStatus(eBeforeInit);

	m_hevMonitorRequested = ::CreateEvent( 
		NULL, 
		FALSE, // release one thread (the RegistryMonitorTask) on signal
		FALSE, // initially non-signalled
		NULL);

	if (m_hevMonitorRequested)
	{
		Progress = eHevInit;
		m_hevInitialized =  ::CreateEvent( 
			NULL, 
			FALSE, // release one thread (this one) on signal
			FALSE, // initially non-signalled
			NULL);

		if (m_hevInitialized)
		{
			Progress = eHevShut;
			m_hevThreadIsShut = ::CreateEvent( 
				NULL, 
				FALSE, // release one thread (this one) on signal
				FALSE, // initially non-signalled
				NULL);

			if (m_hevThreadIsShut)
			{
				Progress = eThread;
				DWORD dwThreadID;	// No need to hold onto dwThreadID in member variable.
									// All Win32 functions take the handle m_hThread instead.
									// The one reason you'd ever want to know this ID is for 
									//	debugging

				// Note that there is no corresponding ::CloseHandle(m_hThread).
				// That is because the thread goes out of existence on the implicit 
				//	::ExitThread() when RegistryMonitorTask returns.  See documentation of
				//	::CreateThread for further details JM 10/22/98
				m_hThread = ::CreateThread( NULL, 
											0, 
											(LPTHREAD_START_ROUTINE)RegistryMonitorTask, 
											this, 
											0, 
											&dwThreadID);

				if (m_hThread)
					Progress = eOK;
			}
		}
	}

	if (m_hThread)
	{
		// Wait for a set period, if failure then log error msg and wait infinite.
		WAIT_INFINITE( m_hevInitialized ); 
	}
	else
	{
		m_dwErr = GetLastError();
		CString str;
		str.Format(_T("%d"), m_dwErr);
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								(Progress == eHevMon) ?		_T("Can't create monitor event")
								: (Progress == eHevInit) ?	_T("Can't create \"init\" event")
								: (Progress == eHevShut) ?	_T("Can't create \"shut\" event")
								:							_T("Can't create thread"),
								str, 
								EV_GTS_ERROR_REGMONITORTHREAD );
		SetThreadStatus(eFail);

		if (m_hevMonitorRequested)
			::CloseHandle(m_hevMonitorRequested);

		if (m_hevInitialized)
			::CloseHandle(m_hevInitialized);

		if (m_hevThreadIsShut)
			::CloseHandle(m_hevThreadIsShut);
	}
}

CRegistryMonitor::~CRegistryMonitor()
{
	ShutDown();
	
	if (m_hevMonitorRequested)
		::CloseHandle(m_hevMonitorRequested);

	if (m_hevInitialized)
		::CloseHandle(m_hevInitialized);

	if (m_hevThreadIsShut)
		::CloseHandle(m_hevThreadIsShut);
}

void CRegistryMonitor::SetThreadStatus(ThreadStatus ts)
{
	Lock();
	m_ThreadStatus = ts;
	time(&m_time);
	Unlock();
}

DWORD CRegistryMonitor::GetStatus(ThreadStatus &ts, DWORD & seconds)
{
	time_t timeNow;
	Lock();
	ts = m_ThreadStatus;
	time(&timeNow);
	seconds = timeNow - m_time;
	Unlock();
	return m_dwErr;
}

// Only for use by this class's own destructor.
void CRegistryMonitor::ShutDown()
{
	Lock();
	m_bShuttingDown = true;
	if (m_hThread)
	{
		::SetEvent(m_hevMonitorRequested);
		Unlock();

		// Wait for a set period, if failure then log error msg and wait infinite.
		WAIT_INFINITE( m_hevThreadIsShut ); 
	}
	else
		Unlock();
}

// Must be called on RegistryMonitorTask thread.  Handles all work of monitoring the directory.
void CRegistryMonitor::Monitor()
{
	enum {eRegChange, eHev /*shutdown*/, eNumHandles};
	HANDLE	hList[eNumHandles]= { NULL };	// array of handles we can use when waiting for multiple events
	HKEY	hk= NULL;						// handle to key in registry

	DWORD dwNErr = 0;
	LONG lResult = ERROR_SUCCESS + 1;	// scratch for returns of any of several
							// calls to Win32 Registry fns.  Initialize to arbitrary value
							//  != ERROR_SUCCESS so we don't close what we haven't opened.

	SetThreadStatus(eInit);
	try
	{
		// create an event for registry notification
		hList[eRegChange] = ::CreateEvent(NULL, FALSE, FALSE, NULL);
		if (hList[eRegChange] == NULL)
		{
			throw CGenSysException( __FILE__, __LINE__, 
									_T("Registry notification event"),
									EV_GTS_ERROR_REG_NFT_CEVT );
		}

		CString str = ThisProgramFullKey();

		// Technically, KEY_ALL_ACCESS is overkill, but this program should always
		//	run in an environment where this shoudl succeed, so we haven't bothered
		//	trying to limit to only the access we need.  At the very least, we need
		//	KEY_QUERY_VALUE | KEY_NOTIFY.
		// [BC - 20010302] - Registry access needs to be restricted to run local TShoot
		// for certain user accts, such as WinXP built in guest acct. To minimize change
		// access only restricted for local TShoot, not online.
		REGSAM samRegistryAccess= KEY_ALL_ACCESS;
		if(RUNNING_LOCAL_TS())
			samRegistryAccess= KEY_QUERY_VALUE | KEY_NOTIFY;
		lResult = RegOpenKeyEx(	HKEY_LOCAL_MACHINE, str, 0, samRegistryAccess, &hk );
		if (lResult != ERROR_SUCCESS)
		{
			CString strError;
			strError.Format(_T("%ld"),lResult);

			::SetEvent(m_hevInitialized);	// OK to ask this object for registry values;
											// of course, you'll just get defaults.

			SetThreadStatus(eDefaulting);

			throw CGeneralException(	__FILE__, __LINE__, strError,
										EV_GTS_ERROR_REG_NFT_OPKEY );
		}

		// ...and we also wait for an explicit wakeup
		hList[eHev] = m_hevMonitorRequested;

		while (true)
		{
			if (m_bShuttingDown)
				break;

			LoadChangedRegistryValues();

			::SetEvent(m_hevInitialized);	// OK to ask this object for registry values

			// set up to be informed of change
			lResult = ::RegNotifyChangeKeyValue(	hk,
												FALSE,
												REG_NOTIFY_CHANGE_LAST_SET,
												hList[eRegChange],
												TRUE);
			if (lResult != ERROR_SUCCESS) 
			{
				CString strError;
				strError.Format(_T("%ld"),lResult);

				throw CGeneralException(	__FILE__, __LINE__, strError,
											EV_GTS_ERROR_REG_NFT_SETNTF );
			}

			::ResetEvent(m_hevMonitorRequested);	// maybe we don't need to do this. JM 9/16/98

			SetThreadStatus(eWait);
			DWORD dwNotifyObj = WaitForMultipleObjects (
				eNumHandles,
				hList,
				FALSE,			// only need one object, not all
				INFINITE);
			SetThreadStatus(eRun);
		}
	}
	catch (CGenSysException& x)
	{
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	x.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								x.GetErrorMsg(), x.GetSystemErrStr(), 
								x.GetErrorCode() ); 
	}
	catch (CGeneralException& x)
	{
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	x.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								x.GetErrorMsg(), _T("General exception"), 
								x.GetErrorCode() ); 
	}
	catch (...)
	{
		// Catch any other exception thrown.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								_T(""), _T(""), 
								EV_GTS_GEN_EXCEPTION );		
	}

	if (hk != NULL)
		::RegCloseKey(hk);

	if (hList[eRegChange] != NULL) 
		::CloseHandle(hList[eRegChange]);

	SetThreadStatus(eExiting);

}

// Must be called on RegistryMonitorTask thread.  
void CRegistryMonitor::AckShutDown()
{
	Lock();
	::SetEvent(m_hevThreadIsShut);
	Unlock();
}

// get new registry values into our internal data structure.
void CRegistryMonitor::LoadChangedRegistryValues()
{
	int maskChanged;
	int maskCreated;
	
	Read(maskChanged, maskCreated);

	// It actually matters that we set reload delay before we set directory monitor path.
	//	The first time through here, the call to m_DirectoryMonitor.SetResourceDirectory
	//	actually sets loose the DirectoryMonitorTask 
	if ( (maskChanged & eReloadDelay) == eReloadDelay)
	{
		DWORD dwReloadDelay;
		GetNumericInfo(eReloadDelay, dwReloadDelay);
		m_DirectoryMonitor.SetReloadDelay(dwReloadDelay);
	}

	if ( m_bMustStartDirMonitor || (maskChanged & eResourcePath) == eResourcePath)
	{
		CString strResourcePath;
		GetStringInfo(eResourcePath, strResourcePath);
		m_DirectoryMonitor.SetResourceDirectory(strResourcePath);	// side effect: if the
								// directory monitor is not yet started, this tells it what
								// directory to monitor so it can start.
		m_bMustStartDirMonitor = false;
	}

	if ( (maskChanged & eDetailedEventLogging) == eDetailedEventLogging)
	{
		DWORD dw;			
		GetNumericInfo(eDetailedEventLogging, dw);
		CEvent::s_bLogAll =  dw ? true : false;
	}

	if ((maskChanged & eLogFilePath) == eLogFilePath)
	{
		// Notify the logging object about the new logging file path.
		CString strLogFilePath;

		GetStringInfo( eLogFilePath, strLogFilePath);
		m_pLog->SetLogDirectory( strLogFilePath );
	}

	if ( m_bMustStartThreadPool
	||	(maskChanged & eMaxThreads) == eMaxThreads
	||	(maskChanged & eThreadsPP) == eThreadsPP )
	{
		m_pThreadPool->ExpandPool(GetDesiredThreadCount());
		m_bMustStartThreadPool = false;
	}
	
	return;
}

//  Main routine of a thread responsible for monitoring the registry.
//	INPUT lpParams
//	Always returns 0.
/* static */ UINT WINAPI CRegistryMonitor::RegistryMonitorTask(LPVOID lpParams)
{
	reinterpret_cast<CRegistryMonitor*>(lpParams)->Monitor();
	reinterpret_cast<CRegistryMonitor*>(lpParams)->AckShutDown();
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\regweventviewer.cpp ===
//
// MODULE: RegWEventViewer.cpp
//
// PURPOSE: Fully implements class CRegisterWithEventViewer
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Roman Mach
// 
// ORIGINAL DATE: 8-2-96
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		9/16/98		JM		pulled out of APGTSCFG.CPP
//

#pragma warning(disable:4786)

#include "stdafx.h"
#include "apgts.h"
#include "apgtsinf.h"
#include "event.h"
#include "maxbuf.h"
#include "RegWEventViewer.h"
#include "baseexception.h"
#include <vector>

using namespace std;


// ------------ CRegisterWithEventViewer -------------

CRegisterWithEventViewer::CRegisterWithEventViewer(HMODULE hModule)
{
	Register( hModule );
}

CRegisterWithEventViewer::~CRegisterWithEventViewer()
{
}
	
//
// This is called only by constructor
// Note that this fn makes no use of class data
//
// Register ourselves w/ event viewer so it can call us to get error strings
VOID CRegisterWithEventViewer::Register(HMODULE hModule)
{
	HKEY hk;
	DWORD dwDisposition, dwType, dwValue, dwSize;
	TCHAR szSubkey[MAXBUF];
	DWORD dwErr;

	// 1. check if registry has valid event viewer info
	// 2. if not, create it as appropriate

	// check presence of event log info...

	_stprintf(szSubkey, _T("%s\\%s"), REG_EVT_PATH, REG_EVT_ITEM_STR);

	dwErr = ::RegCreateKeyEx(	HKEY_LOCAL_MACHINE, 
						szSubkey, 
						0, 
						TS_REG_CLASS, 
						REG_OPTION_NON_VOLATILE, 
						KEY_READ | KEY_WRITE,
						NULL, 
						&hk, 
						&dwDisposition);
	if ( dwErr == ERROR_SUCCESS ) 
	{			
		if (dwDisposition == REG_CREATED_NEW_KEY) {
			// create entire registry layout for events
			RegisterDllPath(hk, hModule);
			RegisterEventTypes(hk);	
		}
		else {
			// (REG_OPENED_EXISTING_KEY is the only other possibility)
			// now make sure all registry elements present
			TCHAR szPath[MAXBUF];
			dwSize = sizeof (szPath) - 1;
			if (::RegQueryValueEx(hk,
								REG_EVT_MF,
								0,
								&dwType,
								(LPBYTE) szPath,
								&dwSize) != ERROR_SUCCESS) 
			{
				RegisterDllPath(hk, hModule);
			}
			dwSize = sizeof (DWORD);
			if (::RegQueryValueEx(hk,
								REG_EVT_TS,
								0,
								&dwType,
								(LPBYTE) &dwValue,
								&dwSize) != ERROR_SUCCESS) 
			{
				RegisterEventTypes(hk);
			}
		}

		::RegCloseKey(hk);
	}
	else
	{

		TCHAR szMsgBuf[MAXBUF];

		::FormatMessage( 
			FORMAT_MESSAGE_FROM_SYSTEM,
			NULL,
			dwErr,
			MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
			szMsgBuf,
			MAXBUF,
			NULL 
			);

		// Logging won't be pretty here, because we just failed to register with the Event
		//	Viewer, but we'll take what we can get.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								_T("Error registering with Event Viewer"),
								szMsgBuf,
								dwErr ); 

		DWORD dwDummy= MAXBUF;
		::GetUserName( szMsgBuf, &dwDummy );
		CBuildSrcFileLinenoStr SrcLoc2( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc2.GetSrcFileLineStr(), 
								SrcLoc2.GetSrcFileLineStr(), 
								_T("User shows as:"),
								szMsgBuf,
								dwErr ); 
	}
}


//
// Note that this fn makes no use of class data
// Store a path to this DLL in registry
VOID CRegisterWithEventViewer::RegisterDllPath(HKEY hk, HMODULE hModule)
{
	TCHAR szPath[MAXBUF];
	DWORD len;
	DWORD dwErr;

	if (hModule) 
	{
		if ((len = ::GetModuleFileName(hModule, szPath, MAXBUF-1))!=0) 
		{
			szPath[len] = _T('\0');
			dwErr= ::RegSetValueEx(	hk,
								REG_EVT_MF,
								0,
								REG_EXPAND_SZ,
								(LPBYTE) szPath,
								len + sizeof(TCHAR));
			if (dwErr)
			{
				// Logging won't be pretty here, because we just failed to register with the 
				//	Event Viewer, but we'll take what we can get.
				TCHAR szMsgBuf[MAXBUF];
				DWORD dwDummy= MAXBUF;

				::GetUserName( szMsgBuf, &dwDummy );
				CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
				CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
										SrcLoc.GetSrcFileLineStr(), 
									_T("Error registering with Event Viewer"),
									szMsgBuf,
									dwErr ); 
			}
		}
	}
}

//
// Note that this fn makes no use of class data
// Register what type of event text queries (errors, warnings, info types) this DLL supports
VOID CRegisterWithEventViewer::RegisterEventTypes(HKEY hk)
{
	DWORD dwData;
	DWORD dwErr;

	dwData = EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | 
				EVENTLOG_INFORMATION_TYPE; 

	dwErr= ::RegSetValueEx(hk,
						REG_EVT_TS,
						0,
						REG_DWORD,
						(LPBYTE) &dwData,
						sizeof(DWORD));
	if (dwErr)
	{
		// Logging won't be pretty here, because we just failed to register with the 
		//	Event Viewer, but we'll take what we can get.
		TCHAR szMsgBuf[MAXBUF];
		DWORD dwDummy= MAXBUF;

		::GetUserName( szMsgBuf, &dwDummy );

		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								_T("Error registering with Event Viewer"),
								szMsgBuf,
								dwErr ); 
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\regweventviewer.h ===
//
// MODULE: RegWEventViewer.h
//
// PURPOSE: Fully implements class CRegisterWithEventViewer
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Roman Mach
// 
// ORIGINAL DATE: 8-2-96
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
//  --		11/21/97	JM		This class abstracted from CDBLoadConfiguration 
// V3.0		9/16/98		JM		This class pulled out of APGTSCFG.CPP

#if !defined(AFX_REGWEVENTVIEWER_H__A3CFA77C_4D78_11D2_95F7_00C04FC22ADD__INCLUDED_)
#define AFX_REGWEVENTVIEWER_H__A3CFA77C_4D78_11D2_95F7_00C04FC22ADD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <windows.h>

class CRegisterWithEventViewer
{
public:
	CRegisterWithEventViewer(HMODULE hModule);
	~CRegisterWithEventViewer();
private:
	static VOID Register(HMODULE hModule);
	static VOID RegisterDllPath(HKEY hk, HMODULE hModule);
	static VOID RegisterEventTypes(HKEY hk);
};


#endif // !defined(AFX_REGWEVENTVIEWER_H__A3CFA77C_4D78_11D2_95F7_00C04FC22ADD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\regutil.h ===
//
// MODULE: "RegUtil.h"
//
// PURPOSE: class CRegUtil
//	Encapsulates access to system registry.
//	This is intended as generic access to the registry, independent of any particular
//	application.
//
// PROJECT: first developed as part of Belief Network Editing Tools ("Argon")
//	Later modified to provide more extensive features as part of version 3.0 of the
//	Online Troubleshooter (APGTS)
//
// AUTHOR: Lonnie Gerrald (LDG), Oleg Kalosha, Joe Mabel
// 
// ORIGINAL DATE: 3/25/98
//
// NOTES: 
// 1. 
//
// Version		Date		By		Comments
//--------------------------------------------------------------------
// V0.1(Argon)	3/25/98		LDG		
// V3.0			8/??/98		OK	
// V3.0			9/9/98		JM	

#include <vector>
#include <algorithm>
using namespace std;

#include "apgtsstr.h"

//////////////////////////////////////////////////////////////////////
// CRegUtil
//  class for accessing registry
//  NOT multithreaded!
//////////////////////////////////////////////////////////////////////
class CRegUtil
{
private:
	long m_WinError;   // windows error listed in WINERROR.H file
	HKEY m_hKey;       // current key handle
	vector<HKEY> m_arrKeysToClose; // array of keys(subkeys) opened by the object

private:
	CRegUtil(const CRegUtil&) {} // prohibit copying since it is confusing:
								 //  one object can close handlers being used by another

public:
	CRegUtil();
	explicit CRegUtil(HKEY);
    virtual ~CRegUtil();

	operator HKEY() const {return m_hKey;}
	long GetResult() const {return m_WinError;}

	// major operations
	bool Create(HKEY hKeyParent, const CString& strKeyName, bool* bCreatedNew, REGSAM access =KEY_ALL_ACCESS);
	bool Open(HKEY hKeyParent, const CString& strKeyName, REGSAM access =KEY_ALL_ACCESS);
	bool Create(const CString& strKeyName, bool* bCreatedNew, REGSAM access =KEY_ALL_ACCESS); // migrate "this" to subkey
	bool Open(const CString& strKeyName, REGSAM access =KEY_ALL_ACCESS); // migrate "this" to subkey
	void Close();

	// sub key manipulation
	bool DeleteSubKey(const CString& strSubKey);
	bool DeleteValue(const CString& strValue);

	// set value
	bool SetNumericValue(const CString& strValueName, DWORD dwValue);
	bool SetStringValue(const CString& strValueName, const CString& strValue);
	bool SetBinaryValue(const CString& strValueName, char* buf, long buf_len);
	
	// get value
	bool GetNumericValue(const CString& strValueName, DWORD& dwValue);
	bool GetStringValue(const CString& strValueName, CString& strValue);
	bool GetBinaryValue(const CString& strValueName, char** buf, long* buf_len);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by TSHOOT.rc
//
#define IDS_PROJNAME                    100
#define IDB_TSHOOTCTRL                  101
#define IDS_PREVSCRIPT                  101
#define IDR_TSHOOTCTRL                  102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\safetime.cpp ===
//
// MODULE: SafeTime.cpp
//
// PURPOSE: threadsafe wrappers for some standard time-related calls.
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 10-12-98
//
// NOTES: 
//	1. gmtime, mktime, and localtime all use a single statically allocated tm structure 
//	for the conversion. Each call to one of these routines destroys the result of the 
//	previous call.  Obviously, that's not threadsafe.
//	2. Right now this only deals with localtime, because we're not using the other 2 fns.
//	If we need to use gmtime or mktime, they'll need to be built analogously, using the 
//	same mutex.
//	3. _tasctime uses a single, statically allocated buffer to hold its return string. 
//	Each call to this function destroys the result of the previous call.
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		10-12-98	JM
//

#include "stdafx.h"
#include "SafeTime.h"
#include "BaseException.h"
#include "Event.h"
#include "apiwraps.h"

CMutexOwner CSafeTime::s_mx(_T("SafeTime"));

//////////////////////////////////////////////////////////////////////
// CSafeTime
//////////////////////////////////////////////////////////////////////

CSafeTime::CSafeTime(time_t time) :
	m_time(time)
{
}

CSafeTime::~CSafeTime()
{
}

// return local time as a struct tm
struct tm CSafeTime::LocalTime()
{
	struct tm tmLocal;
	WAIT_INFINITE( s_mx.Handle() );
	tmLocal = *(localtime(&m_time));
	::ReleaseMutex(s_mx.Handle());
	return tmLocal;
}

// return GMT as a struct tm
struct tm CSafeTime::GMTime()
{
	struct tm tmLocal;
	WAIT_INFINITE( s_mx.Handle() );
	tmLocal = *(gmtime(&m_time));
	::ReleaseMutex(s_mx.Handle());
	return tmLocal;
}

CString CSafeTime::StrLocalTime(LPCTSTR invalid_time /*=_T("Invalid Date/Time")*/)
{
	CString str;
	WAIT_INFINITE( s_mx.Handle() );
	if (m_time)
		str = _tasctime(localtime(&m_time));
	else
		str = invalid_time;
	::ReleaseMutex(s_mx.Handle());
	return str;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\safetime.h ===
//
// MODULE: SafeTime.h
//
// PURPOSE: threadsafe wrappers for some standard time-related calls.
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 10-12-98
//
// NOTES: 
//	1. gmtime, mktime, and localtime all use a single statically allocated tm structure 
//	for the conversion. Each call to one of these routines destroys the result of the 
//	previous call.  Obviously, that's not threadsafe.
//	2. Right now this only deals with localtime, because we're not using the other 2 fns.
//	If we need to use gmtime or mktime, they'll need to be built analogously, using the 
//	same mutex.
//	3. _tasctime uses a single, statically allocated buffer to hold its return string. 
//	Each call to this function destroys the result of the previous call.
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		10-12-98	JM
//

#if !defined(AFX_SAFETIME_H__D5040393_61E9_11D2_960C_00C04FC22ADD__INCLUDED_)
#define AFX_SAFETIME_H__D5040393_61E9_11D2_960C_00C04FC22ADD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <time.h>
#include "apgtsstr.h"
#include "MutexOwner.h"

class CSafeTime
{
private:
	static CMutexOwner s_mx;
	time_t m_time;
private:
	CSafeTime();	// do not instantiate;
public:
	CSafeTime(time_t time);
	virtual ~CSafeTime();
	struct tm LocalTime();
	struct tm GMTime();
	CString StrLocalTime(LPCTSTR invalid_time =_T("Invalid Date/Time"));
};

#endif // !defined(AFX_SAFETIME_H__D5040393_61E9_11D2_960C_00C04FC22ADD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\renderconnector.h ===
// RenderConnector.h: interface for the CRenderConnector class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_RENDERCONNECTOR_H__023A75E3_A81A_11D3_8D63_00C04F949D33__INCLUDED_)
#define AFX_RENDERCONNECTOR_H__023A75E3_A81A_11D3_8D63_00C04F949D33__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "Stateless.h"


////////////////////////////////////////////////////////////////////////////////////
// CRenderConnector class declaration
////////////////////////////////////////////////////////////////////////////////////
class CRenderConnector  
{
	CStatelessPublic m_Stateless;
	bool m_bLocked;

public:
	CRenderConnector() : m_bLocked(false) {}
	virtual ~CRenderConnector() {}

public:
	void Render(CString strPage);
	bool GetLocked() {return m_bLocked;}
	void SetLocked(bool set) {m_bLocked = set;}

protected:
	// PURE virtual
	virtual void RenderInternal(CString strPage) =0;

};


inline void CRenderConnector::Render(CString strPage)
{
	m_Stateless.Lock(__FILE__, __LINE__);
	RenderInternal(strPage);
	m_Stateless.Unlock();
}

#endif // !defined(AFX_RENDERCONNECTOR_H__023A75E3_A81A_11D3_8D63_00C04F949D33__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\sniff.cpp ===
//
// MODULE: SNIFF.CPP
//
// PURPOSE: sniffing class
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 12-11-98
//
// NOTES: This is base abstract class which performs sniffing
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.2		12-11-98	OK
//

#pragma warning(disable:4786)
#include "stdafx.h"
#include "Sniff.h"
#include "SniffConnector.h"
#include "SniffController.h"
#include "Topic.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

// the problem is, that JavaScript returns 0xffffffff, but VBScript returns
//  0x0000ffff, so we define SNIFF_FAIL_MASK as 0x0000ffff and use it as mask to
//  determine if sniffing was successful. Expression 0xffffffff & SNIFF_FAIL_MASK
//  will have the same result as expression 0x0000ffff & SNIFF_FAIL_MASK.
// This define SHOULD NOT BE USED OUTSIDE THIS FILE!
#define SNIFF_FAIL_MASK		0x0000ffff

//////////////////////////////////////////////////////////////////////////////////////
// CSniff implementation

// called as public interface function when resniffing
bool CSniff::Resniff(CSniffedArr& arrSniffed)
{
	bool ret = false;
	
	LOCKOBJECT();
	
	for (CSniffedArr::iterator i = arrSniffed.begin(); i < arrSniffed.end(); i++)
	{
		IST state = SNIFF_FAILURE_RESULT;

		if (GetSniffController()->AllowResniff(i->nid()))
		{
			if (SniffNodeInternal(i->nid(), &state))
			{
				if (state != i->state())
				{
					*i = CNodeStatePair(i->nid(), state);
					ret = true;
				}
			}
			else
			{
				arrSniffed.erase(i);
				i--;
				ret = true;
			}
		}
	}

	UNLOCKOBJECT();
	return ret;
}

// called as public interface function when sniffing on start up
bool CSniff::SniffAll(CSniffedArr& arrOut)
{
	bool ret = false;
	vector<NID> arrNodes;
	vector<ESTDLBL> arrTypeExclude;

	LOCKOBJECT();

	arrTypeExclude.push_back(ESTDLBL_problem);
	arrOut.clear();

	if (GetTopic()->GetNodeArrayExcludeType(arrNodes, arrTypeExclude))
	{
		for (vector<NID>::iterator i = arrNodes.begin(); i < arrNodes.end(); i++)
		{
			if (GetSniffController()->AllowAutomaticOnStartSniffing(*i))
			{
				IST state = SNIFF_FAILURE_RESULT;
				
				if (SniffNodeInternal(*i, &state))
				{
					arrOut.push_back(CNodeStatePair(*i, state));
					ret = true;
				}
			}
		}
	}
	
	UNLOCKOBJECT();
	return ret;
}

// called as public interface function when sniffing on the fly
bool CSniff::SniffNode(NID numNodeID, IST* pnumNodeState)
{
	bool ret = false;

	LOCKOBJECT();
	
	if (GetSniffController()->AllowAutomaticOnFlySniffing(numNodeID))
		ret = SniffNodeInternal(numNodeID, pnumNodeState);
	
	UNLOCKOBJECT();
	return ret;
}

bool CSniff::SniffNodeInternal(NID numNodeID, IST* pnumNodeState)
{
	CString strNodeName;

	if (!GetTopic()->IsRead())
		return false;
	
	strNodeName = GetTopic()->GetNodeSymName(numNodeID);

	if (strNodeName.IsEmpty())
		return false;

	long res = GetSniffConnector()->PerformSniffing(strNodeName, _T(""), _T(""));

	if ((res & SNIFF_FAIL_MASK) == SNIFF_FAIL_MASK)
	{
		*pnumNodeState = SNIFF_FAILURE_RESULT;
		return false;
	}
	
	*pnumNodeState = res;
	return true;
}

void CSniff::SetAllowAutomaticSniffingPolicy(bool set)
{
	GetSniffController()->SetAllowAutomaticSniffingPolicy(set);
}

void CSniff::SetAllowManualSniffingPolicy(bool set)
{
	GetSniffController()->SetAllowManualSniffingPolicy(set);
}

bool CSniff::GetAllowAutomaticSniffingPolicy()
{
	return GetSniffController()->GetAllowAutomaticSniffingPolicy();
}

bool CSniff::GetAllowManualSniffingPolicy()
{
	return GetSniffController()->GetAllowManualSniffingPolicy();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\sniff.h ===
//
// MODULE: SNIFF.H
//
// PURPOSE: sniffing class
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 12-11-98
//
// NOTES: This is base abstract class which performs sniffing
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.2		12-11-98	OK
//

#if !defined(AFX_SNIFF_H__13D744F6_7038_11D3_8D3A_00C04F949D33__INCLUDED_)
#define AFX_SNIFF_H__13D744F6_7038_11D3_8D3A_00C04F949D33__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "Stateless.h"
#include "nodestate.h"

#define SNIFF_FAILURE_RESULT	0xffffffff  // as this is a state, and state (IST) is unsigned int


class CSniffController;
class CSniffConnector;
class CTopic;

typedef vector<CNodeStatePair> CSniffedArr;

//////////////////////////////////////////////////////////////////////////////////////
// CSniff declaration
class CSniff : public CStateless
{
public:
	CSniff() {}
	virtual ~CSniff() {}

public:
	virtual CSniffController* GetSniffController() =0;
	virtual CSniffConnector* GetSniffConnector() =0;
	virtual CTopic* GetTopic() =0;

public:
	// we can not set CSniffController here, as CSniffController
	//  is specific for CSniff... class, inherited from CSniff
	virtual void SetSniffConnector(CSniffConnector*) =0;
	virtual void SetTopic(CTopic*) =0;

public:
	virtual bool Resniff(CSniffedArr& arrSniffed);
	virtual bool SniffAll(CSniffedArr& arrOut);
	virtual bool SniffNode(NID numNodeID, IST* pnumNodeState);

public:
	void SetAllowAutomaticSniffingPolicy(bool); 
	void SetAllowManualSniffingPolicy(bool); 
	bool GetAllowAutomaticSniffingPolicy(); 
	bool GetAllowManualSniffingPolicy(); 

protected:
	virtual bool SniffNodeInternal(NID numNodeID, IST* pnumNodeState);
};

#endif // !defined(AFX_SNIFF_H__13D744F6_7038_11D3_8D3A_00C04F949D33__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\sniffconnector.h ===
//
// MODULE: SNIFFCONNECTOR.H
//
// PURPOSE: sniffing connection class
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 12-11-98
//
// NOTES: This is base abstract class which describes connection of
//         CSniff class to module(s), which are able to call sniffing
//         scripts.
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.2		12-11-98	OK
//

#if !defined(AFX_SNIFFCONNECTOR_H__49F470BA_6F6A_11D3_8D39_00C04F949D33__INCLUDED_)
#define AFX_SNIFFCONNECTOR_H__49F470BA_6F6A_11D3_8D39_00C04F949D33__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "Stateless.h"

////////////////////////////////////////////////////////////////////////////////////
// CSniffConnector
//  this class is enabling topic-related CSniff class use capabilities of programm
//  to invoke actual sniffing scripts
////////////////////////////////////////////////////////////////////////////////////
class CSniffConnector
{
	CStatelessPublic m_Stateless;

public:
	CSniffConnector() {}
	virtual ~CSniffConnector() {}

public:
	long PerformSniffing(CString strNodeName, CString strLaunchBasis, CString strAdditionalArgs);

protected:
	// PURE virtual
	virtual long PerformSniffingInternal(CString strNodeName, CString strLaunchBasis, CString strAdditionalArgs) =0;

};


inline long CSniffConnector::PerformSniffing(CString strNodeName, CString strLaunchBasis, CString strAdditionalArgs)
{
	m_Stateless.Lock(__FILE__, __LINE__);
	long ret = PerformSniffingInternal(strNodeName, strLaunchBasis, strAdditionalArgs);
	m_Stateless.Unlock();
	return ret;
}

#endif // !defined(AFX_SNIFFCONNECTOR_H__49F470BA_6F6A_11D3_8D39_00C04F949D33__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\sniffcontroller.h ===
//
// MODULE: SNIFFCONTROLLER.H
//
// PURPOSE: sniff controller class
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 12-11-98
//
// NOTES: This is base abstract class which controls sniffing on per-node base
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.2		12-11-98	OK
//

#if !defined(AFX_SNIFFCONTROLLER_H__F16A9526_7105_11D3_8D3B_00C04F949D33__INCLUDED_)
#define AFX_SNIFFCONTROLLER_H__F16A9526_7105_11D3_8D3B_00C04F949D33__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "Stateless.h"
#include "nodestate.h"
#include "Sniff.h"

class CTopic;

////////////////////////////////////////////////////////////////////////////////////
// CSniffController
//  this class carries control information from registry and topic-specific HTI
//  file; this is ABSTRACT class.
////////////////////////////////////////////////////////////////////////////////////
class CSniffController : public CStateless
{
	friend void CSniff::SetAllowAutomaticSniffingPolicy(bool); 
	friend void CSniff::SetAllowManualSniffingPolicy(bool); 
	friend bool CSniff::GetAllowAutomaticSniffingPolicy(); 
	friend bool CSniff::GetAllowManualSniffingPolicy(); 

	bool m_bAllowAutomaticSniffingPolicy;
	bool m_bAllowManualSniffingPolicy;

public:
	CSniffController() : CStateless(),
						 m_bAllowAutomaticSniffingPolicy(false),
						 m_bAllowManualSniffingPolicy(false)
	{}

	virtual ~CSniffController() 
	{}

public:
	virtual void SetTopic(CTopic* pTopic) =0;

public:
	virtual bool AllowAutomaticOnStartSniffing(NID numNodeID) =0;
	virtual bool AllowAutomaticOnFlySniffing(NID numNodeID) =0;
	virtual bool AllowManualSniffing(NID numNodeID) =0;
	virtual bool AllowResniff(NID numNodeID) =0;

private: 
	// we NEED NOT access this functions other then from 
	//  appropriate CSniff::SetAllow...SniffingPolicy() functions
	void SetAllowAutomaticSniffingPolicy(bool); 
	void SetAllowManualSniffingPolicy(bool); 

protected:
	bool GetAllowAutomaticSniffingPolicy(); 
	bool GetAllowManualSniffingPolicy(); 
};


inline void CSniffController::SetAllowAutomaticSniffingPolicy(bool set)
{
	m_bAllowAutomaticSniffingPolicy = set;
}

inline void CSniffController::SetAllowManualSniffingPolicy(bool set)
{
	m_bAllowManualSniffingPolicy = set;
}

inline bool CSniffController::GetAllowAutomaticSniffingPolicy()
{
	return m_bAllowAutomaticSniffingPolicy;
}

inline bool CSniffController::GetAllowManualSniffingPolicy()
{
	return m_bAllowManualSniffingPolicy;
}


#endif // !defined(AFX_SNIFFCONTROLLER_H__F16A9526_7105_11D3_8D3B_00C04F949D33__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\snifflocal.h ===
//
// MODULE: SNIFFLOCAL.H
//
// PURPOSE: sniffing class for local TS
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 12-11-98
//
// NOTES: This is concrete implementation of CSniff class for Local TS
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.2		12-11-98	OK
//

#if !defined(AFX_SNIFFLOCAL_H__AD9F3B66_831C_11D3_8D4B_00C04F949D33__INCLUDED_)
#define AFX_SNIFFLOCAL_H__AD9F3B66_831C_11D3_8D4B_00C04F949D33__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "Sniff.h"


class CTopic;
class CSniffControllerLocal;
class CSniffConnector;

class CSniffLocal : public CSniff  
{
	CTopic* m_pTopic;
	CSniffControllerLocal* m_pSniffControllerLocal;
	CSniffConnector* m_pSniffConnector;

public:
	CSniffLocal(CSniffConnector*, CTopic*);
   ~CSniffLocal();

protected:
	virtual CSniffController* GetSniffController();
	virtual CSniffConnector* GetSniffConnector();
	virtual CTopic* GetTopic();

public:
	virtual void SetSniffConnector(CSniffConnector*);
	virtual void SetTopic(CTopic*);
};

#endif // !defined(AFX_SNIFFLOCAL_H__AD9F3B66_831C_11D3_8D4B_00C04F949D33__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\sniffcontrollerlocal.h ===
//
// MODULE: SNIFFCONTROLLERLOCAL.H
//
// PURPOSE: sniff controller class for Local TS
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 12-11-98
//
// NOTES: Concrete implementation of CSniffController class for Local TS
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.2		12-11-98	OK
//

#if !defined(AFX_SNIFFCONTROLLERLOCAL_H__5FAF2243_8577_11D3_8D4C_00C04F949D33__INCLUDED_)
#define AFX_SNIFFCONTROLLERLOCAL_H__5FAF2243_8577_11D3_8D4C_00C04F949D33__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "SniffController.h"

class CTopic;

class CSniffControllerLocal : public CSniffController  
{
	CTopic* m_pTopic;

public:
	CSniffControllerLocal(CTopic* pTopic);
   ~CSniffControllerLocal();

public:
	virtual void SetTopic(CTopic* pTopic);

public:
	virtual bool AllowAutomaticOnStartSniffing(NID numNodeID);
	virtual bool AllowAutomaticOnFlySniffing(NID numNodeID);
	virtual bool AllowManualSniffing(NID numNodeID);
	virtual bool AllowResniff(NID numNodeID);

protected:
	virtual bool IsSniffable(NID numNodeID);

private:
	bool CheckNetNodePropBool(LPCTSTR net_prop, LPCTSTR node_prop, NID node_id);
};

#endif // !defined(AFX_SNIFFCONTROLLERLOCAL_H__5FAF2243_8577_11D3_8D4C_00C04F949D33__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\sniffcontrollerlocal.cpp ===
//
// MODULE: SNIFFCONTROLLERLOCAL.CPP
//
// PURPOSE: sniff controller class for Local TS
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 12-11-98
//
// NOTES: Concrete implementation of CSniffController class for Local TS
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.2		12-11-98	OK
//

#include "stdafx.h"
#include "tshoot.h"
#include "SniffControllerLocal.h"
#include "Topic.h"
#include "propnames.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

// Network property values from DSC/XTS file.
#define SNIFF_LOCAL_YES			_T("yes")
#define SNIFF_LOCAL_NO			_T("no")
#define SNIFF_LOCAL_IMPLICIT	_T("implicit")
#define SNIFF_LOCAL_EXPLICIT	_T("explicit")


//////////////////////////////////////////////////////////////////////
// CSniffControllerLocal implementation
//////////////////////////////////////////////////////////////////////
CSniffControllerLocal::CSniffControllerLocal(CTopic* pTopic) 
					 : m_pTopic(pTopic)
{
}

CSniffControllerLocal::~CSniffControllerLocal() 
{
}

// This function provides us with a cheap test for existence of the sniffing property, 
//	so that (for example) we don't have to fire the sniffing event for nodes where 
//	sniffing is irrelevant.
bool CSniffControllerLocal::IsSniffable(NID numNodeID)
{
	CString str = m_pTopic->GetNodePropItemStr(numNodeID, H_NODE_SNIFF_SCRIPT);
	return !str.IsEmpty();
}

void CSniffControllerLocal::SetTopic(CTopic* pTopic)
{
	m_pTopic = pTopic;
}

bool CSniffControllerLocal::AllowAutomaticOnStartSniffing(NID numNodeID)
{
	if (!IsSniffable(numNodeID))
		return false;

	return  CheckNetNodePropBool(H_NET_MAY_SNIFF_ON_STARTUP, 
			 					 H_NODE_MAY_SNIFF_ON_STARTUP, 
								 numNodeID)
			&&
			GetAllowAutomaticSniffingPolicy();		   
}

bool CSniffControllerLocal::AllowAutomaticOnFlySniffing(NID numNodeID)
{
	if (!IsSniffable(numNodeID))
		return false;

	return  CheckNetNodePropBool(H_NET_MAY_SNIFF_ON_FLY, 
			 					 H_NODE_MAY_SNIFF_ON_FLY, 
								 numNodeID)
			&&
			GetAllowAutomaticSniffingPolicy();		   
}

bool CSniffControllerLocal::AllowManualSniffing(NID numNodeID)
{
	if (!IsSniffable(numNodeID))
		return false;

	return  CheckNetNodePropBool(H_NET_MAY_SNIFF_MANUALLY, 
			 					 H_NODE_MAY_SNIFF_MANUALLY, 
								 numNodeID)
			&&
			GetAllowManualSniffingPolicy();		   
}

bool CSniffControllerLocal::AllowResniff(NID numNodeID)
{
	if (!IsSniffable(numNodeID))
		return false;

	if (!GetAllowAutomaticSniffingPolicy())
		return false;

	CString net_resniff_policy = m_pTopic->GetNetPropItemStr(H_NET_RESNIFF_POLICY);

	net_resniff_policy.TrimLeft(); 
	net_resniff_policy.TrimRight(); 
	net_resniff_policy.MakeLower();

	if (net_resniff_policy == SNIFF_LOCAL_YES)
		return true;
	
	if (net_resniff_policy == SNIFF_LOCAL_NO)
		return false;

	// If we get this far, policy is left up to the individual node, so we need to know 
	//	the node's policy.

	CString node_resniff_policy = m_pTopic->GetNodePropItemStr(numNodeID, H_NODE_MAY_RESNIFF);

	node_resniff_policy.TrimLeft(); 
	node_resniff_policy.TrimRight(); 
	node_resniff_policy.MakeLower();

	if (net_resniff_policy == SNIFF_LOCAL_IMPLICIT)
	{
		return (node_resniff_policy != SNIFF_LOCAL_NO);
	}
	
	// default net policy is "explicit"
	return (node_resniff_policy == SNIFF_LOCAL_YES);
}

bool CSniffControllerLocal::CheckNetNodePropBool(LPCTSTR net_prop, LPCTSTR node_prop, NID node_id)
{
	CString net = m_pTopic->GetNetPropItemStr(net_prop);
	CString node = m_pTopic->GetNodePropItemStr(node_id, node_prop);

	net. TrimLeft(); net .TrimRight(); net. MakeLower();
	node.TrimLeft(); node.TrimRight(); node.MakeLower();

	// Note assumption: if property is missing, default is always yes.
	if ((net.IsEmpty() || net == SNIFF_LOCAL_YES) && (node.IsEmpty() || node == SNIFF_LOCAL_YES))
		return true;

	return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\snifflocal.cpp ===
//
// MODULE: SNIFFLOCAL.CPP
//
// PURPOSE: sniffing class for local TS
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 12-11-98
//
// NOTES: This is concrete implementation of CSniff class for Local TS
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.2		12-11-98	OK
//

#include "stdafx.h"
#include "tshoot.h"
#include "SniffLocal.h"
#include "SniffControllerLocal.h"

//////////////////////////////////////////////////////////////////////
// CSniffLocal implementation
//////////////////////////////////////////////////////////////////////

CSniffLocal::CSniffLocal(CSniffConnector* pSniffConnector, CTopic* pTopic)
		   : CSniff(),
		     m_pTopic(pTopic),
			 m_pSniffConnector(pSniffConnector)
{
	m_pSniffControllerLocal = new CSniffControllerLocal(pTopic);
}

CSniffLocal::~CSniffLocal()
{
	delete m_pSniffControllerLocal;
}

CSniffController* CSniffLocal::GetSniffController()
{
	return m_pSniffControllerLocal;
}

CSniffConnector* CSniffLocal::GetSniffConnector()
{
	return m_pSniffConnector;
}

CTopic* CSniffLocal::GetTopic()
{
	return m_pTopic;
}

void CSniffLocal::SetSniffConnector(CSniffConnector* pSniffConnector)
{
	m_pSniffConnector = pSniffConnector;
}

void CSniffLocal::SetTopic(CTopic* pTopic)
{
	m_pTopic = pTopic;
	m_pSniffControllerLocal->SetTopic(pTopic);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\stateless.cpp ===
//
// MODULE: Stateless.CPP
//
// PURPOSE: CStateless is the base for a hierarchy of classes intended for stateless operation
//	in a multithreaded environment.  The idea is that each public method in any class inheriting 
//	from CStateless should be atomic. Typically, a public method will begin with Lock() and 
//	end with Unlock().  It should represent a complete process.  
//	In general, public methods should fall into two categories.  
//	1. Determine certain irreversible statuses (e.g. whether certain things are initialized).
//	2. Perform atomic operations.  For example, it is appropriate to write a method that 
//	will take a complete set of node states and return a vector of recommendations.  
//
//	It is NOT appropriate to write methods to
//	- associate a a single node and state, this method to be called repeatedly
//	- get a vector of recommendations based on previousl established node/state associations.
//	This relies on a state to be maintained across calls, but that state may be lost due to
//	other threads using the same object.
//
//	It is legitimate, but not recommended to write the following methods:
//	- associate a uniquely identified query, a node, and a state
//	- get a vector of recommendations for a uniquely identified query, based on node/state
//		associations.
//	This last approach is not truly stateless, but at least provides sufficient information to
//	allow appropriate preservation of state without denying other threads the use of the 
//	CStateless object.
//	
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 9-9-98
//
// NOTES: 
//	1. Lock() and Unlock() are const methods so that (for example) a simple "get" in a 
//	class which inherits from this can be const. E.g.:
//
//		class CFoo : public CStateless
//		{
//			int i;
//		public:
//			int GetI() const
//			{
//				Lock();
//				int ret = i;
//				Unlock();
//				retrn ret;
//			}
//			...
//		};
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		9-9-98		JM
//

#include "stdafx.h"
#include "Stateless.h"
#include "APIWraps.h"
#include "Event.h"
#include "BaseException.h"
#include <algorithm>
using namespace std;

////////////////////////////////////////////////////////////////////////////////////
// CStateless
/////////////////////////////////////////////////////////////////////////////////////
CStateless::CStateless(DWORD TimeOutVal /*= 60000 */)
{
	m_TimeOutVal = TimeOutVal;
	m_hMutex = ::CreateMutex(NULL, FALSE, NULL);
	if (!m_hMutex)
	{
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								_T("Hourly"),
								_T(""),
								EV_GTS_ERROR_MUTEX ); 
		throw bad_alloc();
	}
}

CStateless::~CStateless()
{
	::CloseHandle(m_hMutex);
}

void CStateless::Lock(
						LPCSTR srcFile,	// Calling source file (__FILE__), used for logging.
										// LPCSTR, not LPCTSTR, because __FILE__ is a char*, not a TCHAR*
						int srcLine		// Calling source line (__LINE__), used for logging.
					  ) const
{
	APIwraps::WaitAndLogIfSlow(m_hMutex, srcFile, srcLine, m_TimeOutVal);
}

void CStateless::Unlock() const
{
	::ReleaseMutex(m_hMutex);
}

// this function is needed to support multi-mutex locking.	
HANDLE CStateless::GetMutexHandle() const 
{
	return m_hMutex;
}

////////////////////////////////////////////////////////////////////////////////////
// CNameStateless
/////////////////////////////////////////////////////////////////////////////////////
CNameStateless::CNameStateless() 
			  : CStateless()
{
}

CNameStateless::CNameStateless(const CString& str) 
			  : CStateless()
{
	LOCKOBJECT(); 
	m_strName = str;
	UNLOCKOBJECT();
}

void CNameStateless::Set(const CString& str)
{
	LOCKOBJECT(); 
	m_strName = str;
	UNLOCKOBJECT();
}

CString CNameStateless::Get() const
{
	LOCKOBJECT(); 
	CString ret = m_strName;
	UNLOCKOBJECT();
	return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\stateless.h ===
//
// MODULE: Stateless.
//
// PURPOSE: interface for CStateless class.	
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 9-9-98
//
// NOTES: See CStateless.cpp for further information
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		9-9-98		JM
//

#if !defined(AFX_STATELESS_H__278584FB_47F9_11D2_95F2_00C04FC22ADD__INCLUDED_)
#define AFX_STATELESS_H__278584FB_47F9_11D2_95F2_00C04FC22ADD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <windows.h>
#include "apgtsstr.h"

////////////////////////////////////////////////////////////////////////////////////
// CStateless
/////////////////////////////////////////////////////////////////////////////////////
class CStateless  
{
private:
	HANDLE m_hMutex;
	DWORD m_TimeOutVal;		// Time-out interval in milliseconds, after which we 
							// log error & wait infinitely when waiting for m_hMutex.
protected:
	CStateless(DWORD TimeOutVal = 60000);
	virtual ~CStateless();
	void Lock(	LPCSTR srcFile,	// Calling source file (__FILE__), used for logging.
								// LPCSTR, not LPCTSTR, because __FILE__ is a char*, not a TCHAR*
				int srcLine		// Calling source line (__LINE__), used for logging.
				) const;
	void Unlock() const;
	HANDLE GetMutexHandle() const;	// provided only for the creation of a CMultiMutexObj.
									// >>> might be better to use private and friend than protected.
};

////////////////////////////////////////////////////////////////////////////////////
// CStatelessPublic
//  will be used when we can not inherit our class from CStateless,
//  but have to create member variable of CStatelessPublic to control
//  data access
/////////////////////////////////////////////////////////////////////////////////////
class CStatelessPublic : public CStateless
{
public:
	CStatelessPublic() : CStateless() {}
	~CStatelessPublic() {}

public:
	void Lock(	LPCSTR srcFile,
				int srcLine
				) const;
	void Unlock() const;
	HANDLE GetMutexHandle() const;
};


inline void CStatelessPublic::Lock(LPCSTR srcFile, int srcLine) const
{
	CStateless::Lock(srcFile, srcLine);
}

inline void CStatelessPublic::Unlock() const
{
	CStateless::Unlock();
}

inline HANDLE CStatelessPublic::GetMutexHandle() const
{
	return CStateless::GetMutexHandle();
}

////////////////////////////////////////////////////////////////////////////////////
// CNameStateless
/////////////////////////////////////////////////////////////////////////////////////
class CNameStateless : public CStateless
{
	CString m_strName;

public:
	CNameStateless();
	CNameStateless(const CString& str);

	void Set(const CString& str);
	CString Get() const;
};

// these must be macros, because otherwise __FILE__ and __LINE__ won't indicate the
//	calling location.  UNLOCKOBJECT is defined in case we ever need to determine if objects
//	are being unlocked and to provide a consistent look.
#define LOCKOBJECT() Lock(__FILE__, __LINE__)
#define UNLOCKOBJECT() Unlock()

#endif // !defined(AFX_STATELESS_H__278584FB_47F9_11D2_95F2_00C04FC22ADD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\sync.h ===
//
// MODULE: SYNC.H
//
// PURPOSE: syncronization classes
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 8-04-98
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		08-04-98	OK
//

#ifndef __SYNC_H_
#define __SYNC_H_

#include <vector>
#include <windows.h>

using namespace std;
////////////////////////////////////////////////////////////////////////////////////
// single sync object abstract class
class CSyncObj
{
protected:
	HANDLE m_handle;

public:
	CSyncObj();
   ~CSyncObj();

public:
	virtual void Lock()   =0;
	virtual void Unlock() =0;

public:
	HANDLE GetHandle() const;
};

////////////////////////////////////////////////////////////////////////////////////
// single mutex object class
// Manages a single mutex handle to facilitate waiting for the mutex.
class CMutexObj : public CSyncObj
{
public:
	CMutexObj();
   ~CMutexObj();

public:
	virtual void Lock();
	virtual void Unlock();
};

////////////////////////////////////////////////////////////////////////////////////
// multiple sync object abstract class
// Manages multiple handles (the exact type of handle will be determined by a class
//	inheriting from this) to facilitate waiting for the union of several events.
class CMultiSyncObj
{
protected:
	vector<HANDLE> m_arrHandle;

public:
	CMultiSyncObj();
   ~CMultiSyncObj();

public:
	void   AddHandle(HANDLE);
	void   RemoveHandle(HANDLE);
	void   Clear();

public:
	virtual void Lock()   =0;
	virtual void Unlock() =0;
};

////////////////////////////////////////////////////////////////////////////////////
// multiple mutex object class
// Manages multiple mutex handles to facilitate waiting for the union of several mutexes.
class CMultiMutexObj : public CMultiSyncObj
{
public:
	CMultiMutexObj();
   ~CMultiMutexObj();

public:
	virtual void Lock();
	virtual void Lock(LPCSTR srcFile, int srcLine, DWORD TimeOutVal=60000);
	virtual void Unlock();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\sync.cpp ===
//
// MODULE: SYNC.CPP
//
// PURPOSE: syncronization classes
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 8-04-98
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		08-04-98	OK
//

#include "stdafx.h"
#include <algorithm>
#include "sync.h"
#include "event.h"
#include "baseexception.h"
#include "CharConv.h"
#include "apiwraps.h"

////////////////////////////////////////////////////////////////////////////////////
// CSyncObj
// single sync object abstract class
////////////////////////////////////////////////////////////////////////////////////
CSyncObj::CSyncObj()
{
	// we are to initialize handle in specific inherited class
}

CSyncObj::~CSyncObj()
{
	::CloseHandle(m_handle);
}

HANDLE CSyncObj::GetHandle() const
{
	return m_handle;
}

////////////////////////////////////////////////////////////////////////////////////
// 			CMutexObj															  //
// single mutex object class
// Manages a single mutex handle to facilitate waiting for the mutex.
////////////////////////////////////////////////////////////////////////////////////
CMutexObj::CMutexObj()
		 : CSyncObj()
{
	m_handle = ::CreateMutex(NULL, FALSE, NULL);
}

CMutexObj::~CMutexObj()
{
	::CloseHandle(m_handle);
}

// Smarter strategy here than an infinite wait. Wait up to 60 seconds, then log to event 
//	log and wait infinitely.  If it's logged to event log & eventually gets the mutex,
//	it logs to say it finally got the mutex.
void CMutexObj::Lock()
{
	WAIT_INFINITE(m_handle);
}

void CMutexObj::Unlock()
{
	::ReleaseMutex(m_handle);
}

////////////////////////////////////////////////////////////////////////////////////
// 				CMultiSyncObj   												  //
// multiple sync object abstract class
// Manages multiple handles (the exact type of handle will be determined by a class
//	inheriting from this) to facilitate waiting for the union of several events.
////////////////////////////////////////////////////////////////////////////////////
CMultiSyncObj::CMultiSyncObj()
{
}

CMultiSyncObj::~CMultiSyncObj()
{
}

void CMultiSyncObj::AddHandle(HANDLE handle)
{
	vector<HANDLE>::iterator i = 
		find(m_arrHandle.begin(), m_arrHandle.end(), handle);
	if (i == m_arrHandle.end())
	{
		try
		{
			m_arrHandle.push_back(handle);
		}
		catch (exception& x)
		{
			CString str;
			// Note STL exception in event log.
			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									CCharConversion::ConvertACharToString(x.what(), str),
									_T(""), 
									EV_GTS_STL_EXCEPTION ); 
		}
	}	
}

void CMultiSyncObj::RemoveHandle(HANDLE handle)
{
	vector<HANDLE>::iterator i = 
		find(m_arrHandle.begin(), m_arrHandle.end(), handle);
	if (i != m_arrHandle.end())
		m_arrHandle.erase(i);
}

void CMultiSyncObj::Clear()
{
	m_arrHandle.clear();
}

////////////////////////////////////////////////////////////////////////////////////
// 				CMultiMutexObj  												  //
// Manages multiple mutex handles to facilitate waiting for the union of several mutexes.
////////////////////////////////////////////////////////////////////////////////////
CMultiMutexObj::CMultiMutexObj()
			  : CMultiSyncObj()
{
}

CMultiMutexObj::~CMultiMutexObj()
{
}

// Deprecated use, because it provides inferior logging.
void CMultiMutexObj::Lock()
{
	Lock(__FILE__, __LINE__);
}

void CMultiMutexObj::Lock(
					LPCSTR srcFile,		// Calling source file (__FILE__), used for logging.
										// LPCSTR, not LPCTSTR, because __FILE__ is a char*, not a TCHAR*
					int srcLine,		// Calling source line (__LINE__), used for logging.
					DWORD TimeOutVal /*=60000*/	// Time-out interval in milliseconds.  After
									// this we log an error, then wait infinitely
		)
{
	CBuildSrcFileLinenoStr SrcLoc( srcFile, srcLine );
	DWORD nWaitRetVal= ::WaitForMultipleObjects(
		m_arrHandle.size(), 
		m_arrHandle.begin(), 
		TRUE,		// wait for all objects, not just one.
		TimeOutVal);

	if (nWaitRetVal == WAIT_FAILED)
	{
		// very bad news, should never happen
		DWORD dwErr = ::GetLastError();
		CString strErr;
		strErr.Format(_T("%d"), dwErr);
		CBuildSrcFileLinenoStr SrcLoc3(__FILE__, __LINE__);
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc3.GetSrcFileLineStr(), 
								_T("Thread wait failed."), 
								strErr, 
								EV_GTS_ERROR_STUCK_THREAD ); 
	}
	else if (nWaitRetVal == WAIT_TIMEOUT)
	{
		// Initial wait timed out, note in log, and wait infinitely.
		CBuildSrcFileLinenoStr SrcLoc1(__FILE__, __LINE__);
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc1.GetSrcFileLineStr(), 
								_T("Thread wait exceeded initial timeout interval."), 
								_T(""), 
								EV_GTS_STUCK_THREAD ); 

		nWaitRetVal= ::WaitForMultipleObjects(
			m_arrHandle.size(), 
			m_arrHandle.begin(), 
			TRUE,		// wait for all objects, not just one.
			INFINITE);

		// If successfully got what we were waiting for (after logging an apparent
		//	problem), log the fact that it's ultimately OK.
		if (nWaitRetVal == WAIT_OBJECT_0)
		{
			CBuildSrcFileLinenoStr SrcLoc2(__FILE__, __LINE__);
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc2.GetSrcFileLineStr(), 
									_T("Thread infinite wait succeeded."), 
									_T(""), 
									EV_GTS_STUCK_THREAD ); 
		}
	}

	// Else we don't really care what else ::WaitForMultipleObjects() returns.
	// If we get here we got what we were waiting for

}

void CMultiMutexObj::Unlock()
{
	for (vector<HANDLE>::iterator i = m_arrHandle.begin(); 
			i != m_arrHandle.end(); 
			i++
	)
		::ReleaseMutex(*i);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\statuspages.cpp ===
//
// MODULE: STATUSPAGES.CPP
//
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 10-23-98
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		10-23-98	OK		Created by division of apgtsctx.cpp
//

#pragma warning(disable:4786)

#include "stdafx.h"
#include "time.h"
#include "apgtscls.h"
#include "apgtscfg.h"
#include "CounterMgr.h"
#include "SafeTime.h"
#include "apgtsmfc.h"

//Global Declaration.
const CString k_strTableBorderColor = _T("\"#000000\"");
const CString k_strBGColorOfTitle = _T( "\"#333366\"");
const CString k_strTextColorOfTitleOrSubTitle = _T("\"#FFFFFF\"");
const CString k_strTextColorOfName = _T("\"#CCCCC99\"");
const CString k_strTextColorOfValue = _T("\"#FFFFCC\"");
const CString k_strBGColorOfSubTitle = _T("\"#3333CC\"");

void AppendNameAndValueAsRow(CString &strAppend, CString strText, CString strVal)
{
	strAppend += _T("<TR>\n");
	if(strText != _T(""))
	{
		strAppend += _T("<TD BGCOLOR=");
		strAppend += k_strTextColorOfName;
		strAppend += _T(">");
		strAppend += _T("<B>");
		strAppend += strText;
		strAppend += _T("</B>\n");
		strAppend += _T("</TD>\n");
	}
	strAppend += _T("<TD ALIGN=\"CENTER\" BGCOLOR=");
	strAppend += k_strTextColorOfValue;
	strAppend += _T(">");
	strAppend += strVal;
	strAppend += _T("</TD>\n");
	strAppend += _T("</TR>\n");
}

// If bSubTitle is TRUE, the subtitle inside the table will be displayed in a
// lighter background to differentiate between the title(darker background)
// and the subtitle. 

void DisplayTextAsTable(CString &strDisplay, CString strText, bool bSubTitle)
{
	strDisplay += _T("<TABLE BORDER= \"1\" BORDERCOLOR=");
	strDisplay += k_strTableBorderColor;
	strDisplay += _T("CELLPADDING=\"2\" CELLSPACING=\"0\" WIDTH=100%>\n");
	strDisplay += _T("<TR>\n");
	strDisplay += _T("<TD COLSPAN =2 ALIGN=\"CENTER\" BGCOLOR=");
	if(bSubTitle)
		strDisplay += k_strBGColorOfTitle;
	else
		strDisplay += k_strBGColorOfSubTitle;
	strDisplay += _T(">\n");
	strDisplay += _T("<FONT SIZE=\"+1\" COLOR=");
	strDisplay += k_strTextColorOfTitleOrSubTitle;
	strDisplay += _T("<B>\n");
	strDisplay += strText;
	strDisplay += _T("</B>\n");
	strDisplay += _T("</TD>\n");
	strDisplay += _T("</TR>\n");
}

void AppendTwoNamesAndValueAsRow(CString &strAppend, CString strText1, CString strText2, CString strVal)
{
	strAppend += _T("<TR>\n");
	strAppend += _T("<TD ALIGN=\"LEFT\" BGCOLOR=");
	strAppend += k_strTextColorOfName;
	strAppend += _T(" >");
	strAppend += _T("<B>\n");
	strAppend += strText1;
	strAppend += _T("</B>\n");
	strAppend += _T("</TD>");
	strAppend += _T("<TD ALIGN=\"CENTER\" BGCOLOR=");
	strAppend += k_strTextColorOfValue;
	strAppend += _T(">\n");
	strAppend += strText2;
	strAppend += _T("</TD>\n");
	strAppend += _T("<TD ALIGN=\"CENTER\" BGCOLOR=");
	strAppend += k_strTextColorOfValue;
	strAppend += _T(">\n");
	strAppend += strVal;
	strAppend += _T("</TD>\n");
	strAppend += _T("</TR>\n");
}


// Returns true if we should show the full (rather than partial) first page.
bool APGTSContext::ShowFullFirstPage(bool bHasPwd)
{
// You can compile with the NOPWD option to suppress all password checking.
// This is intended mainly for creating test versions with this feature suppressed.
#ifdef NOPWD
	return true;
#else
	return bHasPwd;
#endif // ifndef NOPWD
}

void APGTSContext::InsertPasswordInForm()
{
	// You can compile with the NOPWD option to suppress all password checking.
	// This is intended mainly for creating test versions with this feature suppressed.
	#ifndef NOPWD
			m_strText += _T("<INPUT TYPE=hidden NAME=\"PWD\" VALUE=\"");
			m_strText += m_strTempPwd;
			m_strText += _T("\">\n");
	#endif // ifndef NOPWD
}

void APGTSContext::BeginSelfAddressingForm()
{
	m_strText += _T("<FORM ACTION=\"");
	m_strText += _T("http://");
	m_strText += m_strLocalIPAddress;
	m_strText += m_strVRoot;
	m_strText += _T("\" METHOD=POST>\n");
}

// Append to m_strText: contents of an HTML page giving:
//	- usage statistics
//	- list of available troubleshooter topics
// Not available to the end user.
// INPUT bHasPwd - if this is false, limit the info shown on this page.
void APGTSContext::DisplayFirstPage(bool bHasPwd)
{
	CHourlyDailyCounter tmp_counter;
	DWORD dwRegistryItem =0;
	CString strRegistryItem;
	const CString strRegistryItemNotFound = _T("not found");

	CRegistryMonitor& registryMonitor = m_pConf->GetRegistryMonitor();
	CThreadPool& threadPool = m_pConf->GetThreadPool();
	CPoolQueue& poolQueue = m_pConf->GetPoolQueue();
	
	m_strText += _T("<html>\n");
	m_strText += _T("<B><head><title>Welcome</title></head>\n");
	m_strText += _T("<body bgcolor=");
	m_strText += k_strTextColorOfTitleOrSubTitle;
	m_strText += _T(">\n");
	m_strText += _T("<TABLE BORDER= \"1\" BORDERCOLOR=");
	m_strText += k_strTableBorderColor;
	m_strText += _T(" CELLPADDING=\"2\" CELLSPACING=\"0\" WIDTH=100%>\n");
	m_strText += _T("<TR>\n");
	m_strText += _T("<TD COLSPAN=\"4\" ALIGN=CENTER BGCOLOR=");
	m_strText += k_strBGColorOfTitle;
	m_strText += _T(">\n");
	m_strText += _T("<FONT SIZE=\"+3\" COLOR=");
	m_strText += k_strTextColorOfTitleOrSubTitle;
	m_strText += _T(">\n");
	m_strText += _T("<B>Welcome To The Generic Troubleshooter v");
	m_strText += gstrProductVersion;
	m_strText += _T("</B></FONT> ");
	m_strText += _T("</TD>\n");
	m_strText += _T("</TR>\n");
	
	m_strText += _T("</h1></center>\n");
	m_strText += _T("</TABLE>\n");
	////////////////////////////////////////////////////////////////////////////////////
	// Display global counters
	CString strTmp;
	CHourlyDailyCounter* curr_counter = NULL;
	m_strText += _T("<TABLE BORDER= \"1\" BORDERCOLOR=");
	m_strText += k_strTableBorderColor;
	m_strText += _T(" CELLPADDING=\"2\" CELLSPACING=\"0\" WIDTH=100%>\n");
	curr_counter = (CHourlyDailyCounter*)Get_g_CounterMgr()->Get(CCounterLocation(CCounterLocation::eIdProgramContemporary));
	if (curr_counter) 
	{
		
		strTmp=  CDisplayCounterCurrentDateTime(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Current Date/Time:"), strTmp);

		strTmp =  CDisplayCounterCreateDateTime(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Date/Time program started:"), strTmp);

	}

	curr_counter = (CHourlyDailyCounter*)Get_g_CounterMgr()->Get(CCounterLocation(CCounterLocation::eIdStatusAccess));
	if (curr_counter) 
	{		
		strTmp = CDisplayCounterTotal(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Number of status accesses to system since program was started:"), strTmp);

		strTmp = CDisplayCounterLastDateTime(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Date/Time of most recent status access:"), strTmp);

	}

	curr_counter = (CHourlyDailyCounter*)Get_g_CounterMgr()->Get(CCounterLocation(CCounterLocation::eIdActionAccess));
	if (curr_counter) 
	{
		strTmp = CDisplayCounterTotal(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Number of operator action accesses to system since program was started:"), strTmp);

		strTmp = CDisplayCounterLastDateTime(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Date/Time of most recent operator action access:"), strTmp);

	}

	curr_counter = (CHourlyDailyCounter*)Get_g_CounterMgr()->Get(CCounterLocation(CCounterLocation::eIdTotalAccessStart));
	if (curr_counter) 
	{
		strTmp = CDisplayCounterTotal(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Number of total accesses to system since program was started:"), strTmp);

		strTmp = CDisplayCounterLastDateTime(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Date/Time of most recent access:"), strTmp);
	}

	if (ShowFullFirstPage(bHasPwd))
	{
		curr_counter = (CHourlyDailyCounter*)Get_g_CounterMgr()->Get(CCounterLocation(CCounterLocation::eIdRequestUnknown));
		if (curr_counter) 
		{	
			strTmp = CDisplayCounterTotal(curr_counter).Display();
			AppendNameAndValueAsRow(m_strText, _T("Number of requests to system for unknown troubleshooters topics since program was started:"), strTmp);

			strTmp = CDisplayCounterLastDateTime(curr_counter).Display();
			AppendNameAndValueAsRow(m_strText, _T("Date/Time of most recent request to system for unknown troubleshooter topic:"), strTmp);
		}

		curr_counter = (CHourlyDailyCounter*)Get_g_CounterMgr()->Get(CCounterLocation(CCounterLocation::eIdRequestRejected));
		if (curr_counter) 
		{
			strTmp = CDisplayCounterTotal(curr_counter).Display();
			AppendNameAndValueAsRow(m_strText, _T("Number of requests system has rejected because of backlog in queue since program was started:"), strTmp);

			strTmp = CDisplayCounterLastDateTime(curr_counter).Display();
			AppendNameAndValueAsRow(m_strText, _T("Date/Time of most recent request system has rejected because of backlog in queue:"), strTmp);
		}
		
		curr_counter = (CHourlyDailyCounter*)Get_g_CounterMgr()->Get(CCounterLocation(CCounterLocation::eIdErrorLogged));
		if (curr_counter) 
		{
			strTmp = CDisplayCounterTotal(curr_counter).Display();
			AppendNameAndValueAsRow(m_strText, _T("Number of errors logged to event log since program was started:"), strTmp);
			
			strTmp = CDisplayCounterLastDateTime(curr_counter).Display();
			AppendNameAndValueAsRow(m_strText, _T("Date/Time of most recent logged error:"), strTmp);
		}
		
		
		if (registryMonitor.GetNumericInfo(CAPGTSRegConnector::eMaxWQItems, dwRegistryItem)) 
		{
			strRegistryItem.Format(_T("%d"), dwRegistryItem);
			AppendNameAndValueAsRow(m_strText, _T("Current maximum size of queue:"), strRegistryItem);
		}
		else
			AppendNameAndValueAsRow(m_strText, _T("Current maximum size of queue:"), strRegistryItemNotFound);
	
		
	
		////////////////////////////////////////////////////////////////////////////////////
		// Extract and display information about threads and queue
		tmp_counter.Init(threadPool.GetWorkingThreadCount());
		strTmp = CDisplayCounterTotal(&tmp_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Current number of working threads:"), strTmp);

		tmp_counter.Init(poolQueue.GetTotalQueueItems());
		strTmp = CDisplayCounterTotal(&tmp_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Current number of work items in queue:"), strTmp);

		tmp_counter.Init(poolQueue.GetTotalWorkItems());
		strTmp = CDisplayCounterTotal(&tmp_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Current number of work items either in queue or in progress:"), strTmp);
	}
	////////////////////////////////////////////////////////////////////////////////////
	// Extract and display snapshot information about topic
	DWORD dwTotal=0, dwNoInit=0, dwFail=0;
	vector<CString> vector_placeholder;
	m_pConf->GetTopicShop().GetTopicsStatus(dwTotal, dwNoInit, dwFail, &vector_placeholder);
	tmp_counter.Init(dwTotal);
	strTmp = CDisplayCounterTotal(&tmp_counter).Display();
	AppendNameAndValueAsRow(m_strText, _T("Total number of known troubleshooter topics:"), strTmp);

	if (ShowFullFirstPage(bHasPwd))
	{
		tmp_counter.Init(dwFail);
		strTmp = CDisplayCounterTotal(&tmp_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Number of troubleshooter topics that we have tried and failed to load:"), strTmp);
	}
	
	m_strText += _T("</TABLE>\n");

	////////////////////////////////////////////////////////////////////////////////////
	    m_strText += _T("</ul><center>\n");
	////////////////////////////////////////////////////////////////////////////////////

	////////////////////////////////////////////////////////////////////////////////////
	// Display buttons to get to sibling status pages
	if (ShowFullFirstPage(bHasPwd))
	{
		BeginSelfAddressingForm();
		InsertPasswordInForm();
		m_strText += _T("<INPUT TYPE=hidden NAME=\"");
		m_strText += C_FURTHER_GLOBAL;
		// Value here is not actually relevant; effectively used as a comment.
		m_strText += _T("\" VALUE=\"Further Global Status Page\">\n");
		m_strText += _T("<INPUT TYPE=SUBMIT VALUE=\"Further Global Status Page\">\n");
		m_strText += _T("</FORM>\n");

		BeginSelfAddressingForm();
		InsertPasswordInForm();
		m_strText += _T("<INPUT TYPE=hidden NAME=\"");
		m_strText += C_THREAD_OVERVIEW;
		// Value here is not actually relevant; effectively used as a comment.
		m_strText += _T("\" VALUE=\"Thread Status Overview Page\">\n");
		m_strText += _T("<INPUT TYPE=SUBMIT VALUE=\"Thread Status Overview Page\">\n");
		m_strText += _T("</FORM>\n");
	}

	////////////////////////////////////////////////////////////////////////////////////
	// Display topics & links to status information for those topics
	vector<CString>arrstrTopic;
	m_pConf->GetListOfTopicNames(arrstrTopic);

	DWORD nTopics = arrstrTopic.size();
	
	for (DWORD i=0; i<nTopics; i++) 
	{
		m_strText += _T("<TABLE>");
		m_strText += _T("<TR>");
		m_strText += _T("<TD>");

		BeginSelfAddressingForm();
		m_strText += _T("<INPUT TYPE=hidden NAME=\"");
		m_strText += C_TOPIC;
		m_strText += _T("\" VALUE=\"");
		m_strText += arrstrTopic[i];
		m_strText += _T("\">\n");
		m_strText += _T("<INPUT TYPE=SUBMIT VALUE=\"");
		m_strText += _T("Problem Page for ");
		m_strText += arrstrTopic[i];
		m_strText += _T("\">\n");
		m_strText += _T("</FORM>\n");

		m_strText += _T("</TD>");

		if (ShowFullFirstPage(bHasPwd))
		{
			m_strText += _T("<TD>");

			BeginSelfAddressingForm();
			InsertPasswordInForm();
			m_strText += _T("<INPUT TYPE=hidden NAME=\"");
			m_strText += C_TOPIC_STATUS;
			m_strText += _T("\" VALUE=\"");
			m_strText += arrstrTopic[i];
			m_strText += _T("\">\n");
			m_strText += _T("<INPUT TYPE=SUBMIT VALUE=\"");
			m_strText += _T("Status Page for ");
			m_strText += arrstrTopic[i];
			m_strText += _T("\">\n");
			m_strText += _T("</FORM>\n");

			m_strText += _T("</TD>");
		}
		m_strText += _T("</TR>");
		m_strText += _T("</TABLE>");
	}
	if(nTopics == 0) 
	{
		m_strText += _T("<P>There are currently no troubleshooters available");
	}
	
	////////////////////////////////////////////////////////////////////////////////////
	m_strText += _T("</center>\n");
	////////////////////////////////////////////////////////////////////////////////////

	if (ShowFullFirstPage(bHasPwd))
	{
		m_strText += _T("<TABLE BORDER= \"1\" BORDERCOLOR=\"#000000\" CELLPADDING=\"2\" CELLSPACING=\"0\" WIDTH=100%>\n");
		////////////////////////////////////////////////////////////////////////////////////
		// Display registry info
		
		if (registryMonitor.GetStringInfo(CAPGTSRegConnector::eResourcePath, strRegistryItem))	
			AppendNameAndValueAsRow(m_strText, _T("Full path to resource:"), strRegistryItem);
		else
			AppendNameAndValueAsRow(m_strText, _T("Full path to resource:"), strRegistryItemNotFound);

	
		if (registryMonitor.GetNumericInfo(CAPGTSRegConnector::eCookieLife, dwRegistryItem)) 
		{
			strRegistryItem.Format(_T("%d"), dwRegistryItem);
			AppendNameAndValueAsRow(m_strText, _T("HTTP cookie expiration in minutes:"), strRegistryItem);
		}
		else
			AppendNameAndValueAsRow(m_strText, _T("HTTP cookie expiration in minutes:"), strRegistryItemNotFound);
	
		
		if (registryMonitor.GetNumericInfo(CAPGTSRegConnector::eMaxThreads, dwRegistryItem)) 
		{
			
			strRegistryItem.Format(_T("%d"), dwRegistryItem);
			AppendNameAndValueAsRow(m_strText, _T("Maximum threads:"), strRegistryItem);
		}
		else
			AppendNameAndValueAsRow(m_strText, _T("Maximum threads:"), strRegistryItemNotFound);
			
			
		if (registryMonitor.GetNumericInfo(CAPGTSRegConnector::eMaxWQItems, dwRegistryItem)) 
		{
			strRegistryItem.Format(_T("%d"), dwRegistryItem);
			AppendNameAndValueAsRow(m_strText, _T("Maximum work queue items:"), strRegistryItem);
		}
		else
			AppendNameAndValueAsRow(m_strText, _T("Maximum work queue items :"), strRegistryItemNotFound);
		
		
		if (registryMonitor.GetNumericInfo(CAPGTSRegConnector::eReloadDelay, dwRegistryItem)) 
		{
			strRegistryItem.Format(_T("%d"), dwRegistryItem);
			AppendNameAndValueAsRow(m_strText, _T("Refresh delay:"), strRegistryItem);
		}
		else
			AppendNameAndValueAsRow(m_strText, _T("Refresh delay:"), strRegistryItemNotFound);	
		
		
		if (registryMonitor.GetNumericInfo(CAPGTSRegConnector::eThreadsPP, dwRegistryItem)) 
		{
			strRegistryItem.Format(_T("%d"), dwRegistryItem);
			AppendNameAndValueAsRow(m_strText, _T("Threads per processor:"), strRegistryItem);
		}
		else
			AppendNameAndValueAsRow(m_strText, _T("Threads per processor:"), strRegistryItemNotFound);	
	

		if (registryMonitor.GetStringInfo(CAPGTSRegConnector::eVrootPath, strRegistryItem)) 
				AppendNameAndValueAsRow(m_strText, _T("VRoot path to DLL:"), strRegistryItem);	
		else
			AppendNameAndValueAsRow(m_strText, _T("VRoot path to DLL:"), strRegistryItemNotFound);	
		
		if (registryMonitor.GetNumericInfo(CAPGTSRegConnector::eDetailedEventLogging, dwRegistryItem)) 
		{
			strRegistryItem.Format(_T("%d"), dwRegistryItem);
			AppendNameAndValueAsRow(m_strText, _T("Detailed event logging:"), strRegistryItem);
		}
		else
			AppendNameAndValueAsRow(m_strText, _T("Detailed event logging:"), strRegistryItemNotFound);	
		
		if (registryMonitor.GetStringInfo(CAPGTSRegConnector::eLogFilePath, strRegistryItem)) 
			AppendNameAndValueAsRow(m_strText, _T("Log file directory:"), strRegistryItem);	
		else
			AppendNameAndValueAsRow(m_strText, _T("Log file directory:"), strRegistryItemNotFound);	
		
	}
	m_strText += _T("</TABLE>\n");
	////////////////////////////////////////////////////////////////////////////////////
	m_strText += _T("</body></html>\n");
	////////////////////////////////////////////////////////////////////////////////////
}

void APGTSContext::DisplayFurtherGlobalStatusPage()
{

	CHourlyDailyCounter tmp_counter;
	DWORD dwRegistryItem =0;
	CString strRegistryItem;
	CString strTmp;
	const CString strRegistryItemNotFound = _T("not found");
	CRegistryMonitor& registryMonitor = m_pConf->GetRegistryMonitor();
	CThreadPool& threadPool = m_pConf->GetThreadPool();
	CPoolQueue& poolQueue = m_pConf->GetPoolQueue();
	CHourlyDailyCounter* curr_counter = NULL;
	CDailyTotals daily;
	CHourlyTotals hourly;

	m_strText += _T("<html>\n");
	m_strText += _T("<B><head><title>Status</title></head>\n");
	m_strText += _T("<body bgcolor=");
	m_strText += k_strTextColorOfTitleOrSubTitle;
	m_strText += _T(">\n");
	m_strText += _T("<TABLE BORDER= \"1\" BORDERCOLOR=");
	m_strText += k_strTableBorderColor;
	m_strText += _T(" CELLPADDING=\"2\" CELLSPACING=\"0\" WIDTH=100%>\n");
	m_strText += _T("<TR>\n");
	m_strText += _T("<TD COLSPAN=\"4\" ALIGN=CENTER BGCOLOR=");
	m_strText += k_strBGColorOfTitle;
	m_strText += _T(">\n");
	m_strText += _T("<FONT SIZE=\"+3\" COLOR=");
	m_strText += k_strTextColorOfTitleOrSubTitle;
	m_strText += _T(">\n");
	m_strText += _T("<B>Further Global Status Page ");
	m_strText += _T("</B></FONT> ");
	m_strText += _T("</TD>\n");
	m_strText += _T("</TR>\n");
	
	m_strText += _T("</TABLE>\n");
	////////////////////////////////////////////////////////////////////////////////////
	// Display global counters

	m_strText += _T("<TABLE BORDER=\"1\" BORDERCOLOR=");
	m_strText += k_strTableBorderColor;
	m_strText += _T(" CELLPADDING=\"2\" CELLSPACING=\"0\" WIDTH=100%>\n");
	curr_counter = (CHourlyDailyCounter*)Get_g_CounterMgr()->Get(CCounterLocation(CCounterLocation::eIdProgramContemporary));
	if (curr_counter) 
	{
		strTmp = CDisplayCounterCurrentDateTime(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Current Date/Time:"), strTmp);		
	}

	m_strText += _T("</TABLE>\n");
	m_strText += _T("<br>\n");
	
	DisplayTextAsTable(m_strText, _T("Status Access To The System"), 1);
	curr_counter = (CHourlyDailyCounter*)Get_g_CounterMgr()->Get(CCounterLocation(CCounterLocation::eIdStatusAccess));
	if (curr_counter) 
	{
		strTmp = CDisplayCounterTotal(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Number of status accesses to system since program was started:"), strTmp);		

		strTmp = CDisplayCounterLastDateTime(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Date/Time of most recent status access:"), strTmp);	

		m_strText += _T("</TABLE>\n");
		DisplayTextAsTable(m_strText, _T("Daily/hourly count of status accesses to system since program was started"), 0);
		m_strText += CDisplayCounterDailyHourly(curr_counter, &daily, &hourly).Display();
		
	}

	m_strText += _T("</TABLE>\n");
	m_strText += _T("<br>\n");
	
	DisplayTextAsTable(m_strText, _T("Operator Access To The System"), 1);
	m_strText += _T("</TABLE>\n");
	m_strText += _T("<TABLE BORDER=\"1\" BORDERCOLOR=");
	m_strText += k_strTableBorderColor;
	m_strText += _T(" CELLPADDING=\"2\" CELLSPACING=\"0\" WIDTH=100%>\n");
	curr_counter = (CHourlyDailyCounter*)Get_g_CounterMgr()->Get(CCounterLocation(CCounterLocation::eIdActionAccess));
	if (curr_counter) 
	{
		strTmp = CDisplayCounterTotal(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Number of operator action accesses to system since program was started:"), strTmp);	

		strTmp = CDisplayCounterLastDateTime(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Date/Time of most recent operator action access:"), strTmp);	

		m_strText += _T("</TABLE>\n");
		DisplayTextAsTable(m_strText, _T("Daily/hourly count of operator action accesses to system since program was started"), 0);
		m_strText += CDisplayCounterDailyHourly(curr_counter, &daily, &hourly).Display();

	}

	m_strText += _T("</TABLE>\n");
	m_strText += _T("<br>\n");
	
	DisplayTextAsTable(m_strText, _T("Total Access To The System"), 1);
	m_strText += _T("</TABLE>\n");
	m_strText += _T("<TABLE BORDER=\"1\" BORDERCOLOR=");
	m_strText += k_strTableBorderColor;
	m_strText += _T(" CELLPADDING=\"2\" CELLSPACING=\"0\" WIDTH=100%>\n");
	curr_counter = (CHourlyDailyCounter*)Get_g_CounterMgr()->Get(CCounterLocation(CCounterLocation::eIdTotalAccessStart));
	if (curr_counter) 
	{
		strTmp = CDisplayCounterTotal(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Number of total accesses to system since program was started:"), strTmp);	

		strTmp = CDisplayCounterLastDateTime(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Date/Time of most recent access:"), strTmp);	

		m_strText += _T("</TABLE>\n");
		DisplayTextAsTable(m_strText, _T("Daily/hourly count of total accesses to system since program was started"), 0);
		m_strText += CDisplayCounterDailyHourly(curr_counter, &daily, &hourly).Display();
		
	}

	m_strText += _T("</TABLE>\n");
	m_strText += _T("<br>\n");
	DisplayTextAsTable(m_strText, _T("Request To System For UnKnown TroubleShooter Topics"), 1);
	
	m_strText += _T("</TABLE>\n");
	m_strText += _T("<TABLE BORDER=\"1\" BORDERCOLOR=");
	m_strText += k_strTableBorderColor;
	m_strText += _T(" CELLPADDING=\"2\" CELLSPACING=\"0\" WIDTH=100%>\n");
	curr_counter = (CHourlyDailyCounter*)Get_g_CounterMgr()->Get(CCounterLocation(CCounterLocation::eIdRequestUnknown));
	if (curr_counter) 
	{
		strTmp = CDisplayCounterTotal(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Number of requests to system for unknown troubleshooters topics since program was started:"), strTmp);	

		strTmp = CDisplayCounterLastDateTime(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Date/Time of most recent request to system for unknown troubleshooter topic:"), strTmp);	

		m_strText += _T("</TABLE>\n");
		DisplayTextAsTable(m_strText, _T("Daily/hourly count of  requests to system for unknown troubleshooter topics since program was started"), 0);
		m_strText += CDisplayCounterDailyHourly(curr_counter, &daily, &hourly).Display();
		
	}

	m_strText += _T("</TABLE>\n");
	m_strText += _T("<br>\n");
	
	DisplayTextAsTable(m_strText, _T("Requests System Has Rejected"), 1);
	m_strText += _T("</TABLE>\n");

	m_strText += _T("<TABLE BORDER=\"1\" BORDERCOLOR=");
	m_strText += k_strTableBorderColor;
	m_strText += _T(" CELLPADDING=\"2\" CELLSPACING=\"0\" WIDTH=100%>\n");
	curr_counter = (CHourlyDailyCounter*)Get_g_CounterMgr()->Get(CCounterLocation(CCounterLocation::eIdRequestRejected));
	if (curr_counter) 
	{
		strTmp = CDisplayCounterTotal(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Number of requests system has rejected because of backlog in queue since program was started:"), strTmp);	

		strTmp = CDisplayCounterLastDateTime(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Date/Time of most recent request system has rejected because of backlog in queue:"), strTmp);	

		m_strText += _T("</TABLE>\n");
		DisplayTextAsTable(m_strText, _T("Daily/hourly count of requests system has rejected because of backlog in queue since program was started"), 0);
		m_strText += CDisplayCounterDailyHourly(curr_counter, &daily, &hourly).Display();
		
	}
	
	m_strText += _T("</TABLE>\n");
	m_strText += _T("<br>\n");
	DisplayTextAsTable(m_strText, _T("Errors Logged To Event Log"), 1);

	m_strText += _T("</TABLE>\n");
	m_strText += _T("<TABLE BORDER=\"1\" BORDERCOLOR=");
	m_strText += k_strTableBorderColor;
	m_strText += _T(" CELLPADDING=\"2\" CELLSPACING=\"0\" WIDTH=100%>\n");
	curr_counter = (CHourlyDailyCounter*)Get_g_CounterMgr()->Get(CCounterLocation(CCounterLocation::eIdErrorLogged));
	if (curr_counter) 
	{
		strTmp = CDisplayCounterTotal(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Number of errors logged to event log since program was started:"), strTmp);	

		strTmp = CDisplayCounterLastDateTime(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Date/Time of most recent logged error:"), strTmp);

		m_strText += _T("</TABLE>\n");
		DisplayTextAsTable(m_strText, _T("Daily/hourly count of logged errors"), 0);
		m_strText += CDisplayCounterDailyHourly(curr_counter, &daily, &hourly).Display();
	}
	
	m_strText += _T("</TABLE>\n");
	m_strText += _T("<br>\n");
	
	DisplayTextAsTable(m_strText, _T("Statistics About Queue, Thread and Successful/Unsuccessful Load Of Topics"), 1);
	m_strText += _T("</TABLE>\n");
	
	m_strText += _T("<TABLE BORDER=\"1\" BORDERCOLOR=");
	m_strText += k_strTableBorderColor;
	m_strText += _T(" CELLPADDING=\"2\" CELLSPACING=\"0\" WIDTH=100%>\n");
	
	if (registryMonitor.GetNumericInfo(CAPGTSRegConnector::eMaxWQItems, dwRegistryItem)) 
	{
		strRegistryItem.Format(_T("%d"), dwRegistryItem);
		AppendNameAndValueAsRow(m_strText, _T("Current maximum size of queue:"), strRegistryItem);
	}
	else
		AppendNameAndValueAsRow(m_strText, _T("Current maximum size of queue:"), strRegistryItemNotFound);
	m_strText += _T("\n");

	////////////////////////////////////////////////////////////////////////////////////
	// Extract and display information about threads and queue

	
	tmp_counter.Init(threadPool.GetWorkingThreadCount());
	strTmp = CDisplayCounterTotal(&tmp_counter).Display();
	AppendNameAndValueAsRow(m_strText, _T("Current number of working threads:"), strTmp);

	tmp_counter.Init(poolQueue.GetTotalQueueItems());
	strTmp = CDisplayCounterTotal(&tmp_counter).Display();
	AppendNameAndValueAsRow(m_strText, _T("Current number of work items in queue :"), strTmp);
	
	tmp_counter.Init(poolQueue.GetTotalWorkItems());
	strTmp = CDisplayCounterTotal(&tmp_counter).Display();
	AppendNameAndValueAsRow(m_strText, _T("Current number of work items either in queue or in progress :"), strTmp);
	//////////////////////////////////////////////////////////////////////////////////

	strTmp = CSafeTime(poolQueue.GetTimeLastAdd()).StrLocalTime();
	AppendNameAndValueAsRow(m_strText, _T("Date/Time of most recent addition to queue :"), strTmp);
	
	strTmp = CSafeTime(poolQueue.GetTimeLastRemove()).StrLocalTime();
	AppendNameAndValueAsRow(m_strText, _T("Date/Time of most recent removal from queue :"), strTmp);
	
	////////////////////////////////////////////////////////////////////////////////////
	// Extract and display snapshot information about topic
	DWORD dwTotal=0, dwNoInit=0, dwFail=0;
	vector<CString> vector_topics_failed;
	m_pConf->GetTopicShop().GetTopicsStatus(dwTotal, dwNoInit, dwFail, &vector_topics_failed);
	tmp_counter.Init(dwTotal);
	strTmp = CDisplayCounterTotal(&tmp_counter).Display();
	AppendNameAndValueAsRow(m_strText, _T("Total number of known troubleshooter topics:"), strTmp);

	tmp_counter.Init(dwNoInit);
	strTmp = CDisplayCounterTotal(&tmp_counter).Display();
	AppendNameAndValueAsRow(m_strText, _T("Number of troubleshooter topics that we have not yet tried to load:"), strTmp);

	tmp_counter.Init(dwFail);
	strTmp = CDisplayCounterTotal(&tmp_counter).Display();
	AppendNameAndValueAsRow(m_strText, _T("Number of troubleshooter topics that we have tried and failed to load:"), strTmp);

	if (vector_topics_failed.size()) 
		for (vector<CString>::iterator i = vector_topics_failed.begin(); i != vector_topics_failed.end(); i++)
		{
			strTmp = *i;
			AppendNameAndValueAsRow(m_strText, _T("List of troubleshooter topics that we have tried and failed to load:"), strTmp);
		}
	else
	{
		strTmp = _T("No topics");
		AppendNameAndValueAsRow(m_strText, _T("List of troubleshooter topics that we have tried and failed to load:"), strTmp);
	}

	////////////////////////////////////////////////////////////////////////////////////
	// Extract and display snapshot information about alternate templates
	vector<CString> vector_templates_failed;
	vector<DWORD> vector_templatescnt_failed;
	DWORD dwTemplateCnt;
	m_pConf->GetTopicShop().GetTemplatesStatus( &vector_templates_failed, &vector_templatescnt_failed );
	dwTemplateCnt= vector_templates_failed.size();
	if (dwTemplateCnt)
	{
		// Only output if there are failed loads.
		tmp_counter.Init( dwTemplateCnt );
		strTmp = CDisplayCounterTotal(&tmp_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Total number of templates not found:"), strTmp);

		vector<DWORD>::iterator j = vector_templatescnt_failed.begin(); 
		for (vector<CString>::iterator i = vector_templates_failed.begin();
			i != vector_templates_failed.end(); i++)
		{
			strTmp = *i;
			AppendNameAndValueAsRow(m_strText, _T(""), strTmp);

			if (j != vector_templatescnt_failed.end())
			{
				// Output the counts.
				tmp_counter.Init( *j );
				strTmp = CDisplayCounterTotal(&tmp_counter).Display();
				AppendNameAndValueAsRow(m_strText, _T(": "), strTmp);
				j++;
			}
		}
	}
	m_strText += _T("</TABLE>\n");
	//////////////////////////////////////////////////////////////////////////////////
	// Link buttons
	BeginSelfAddressingForm();
	InsertPasswordInForm();
	m_strText += _T("<INPUT TYPE=hidden NAME=\"");
	m_strText += C_FIRST;
	// Value here is not actually relevant; effectively used as a comment.
	m_strText += _T("\" VALUE=\"Front Page\">\n");
	m_strText += _T("<INPUT TYPE=SUBMIT VALUE=\"Front Page\">\n");
	m_strText += _T("</FORM>\n");

	BeginSelfAddressingForm();
	InsertPasswordInForm();
	m_strText += _T("<INPUT TYPE=hidden NAME=\"");
	m_strText += C_THREAD_OVERVIEW;
	// Value here is not actually relevant; effectively used as a comment.
	m_strText += _T("\" VALUE=\"Thread Status Overview Page\">\n");
	m_strText += _T("<INPUT TYPE=SUBMIT VALUE=\"Thread Status Overview Page\">\n");
	m_strText += _T("</FORM>\n");

	//////////////////////////////////////////////////////////////////////////////////
	m_strText += _T("</body></html>\n");
	//////////////////////////////////////////////////////////////////////////////////
}

void APGTSContext::DisplayThreadStatusOverviewPage()
{
	CString strTmp;
	CString strTmp2;
	CString strTmp3;
	CString strTmp4;
	CHourlyDailyCounter tmp_counter;
	DWORD dwRegistryItem =0;
	CString strRegistryItem;
	const CString strRegistryItemNotFound = _T("not found");
	CRegistryMonitor& registryMonitor = m_pConf->GetRegistryMonitor();
	CDirectoryMonitor& directoryMonitor = m_pConf->GetDirectoryMonitor();
	CTopicShop& topicShop = m_pConf->GetTopicShop();
	CThreadPool& threadPool = m_pConf->GetThreadPool();
	CPoolQueue& poolQueue = m_pConf->GetPoolQueue();
	CHourlyDailyCounter* curr_counter = NULL;
	CDailyTotals daily;
	CHourlyTotals hourly;

	////////////////////////////////////////////////////////////////////////////////////
	// Collect status information for pool threads
	vector<CPoolThreadStatus> arrPoolThreadStatus;
	for (long i = 0; i < threadPool.GetWorkingThreadCount(); i++)
	{
		CPoolThreadStatus status;
		threadPool.ThreadStatus(i, status);
		arrPoolThreadStatus.push_back(status);
	}


	m_strText += _T("<html>\n");
	m_strText += _T("<B><head><title>Status</title></head>\n");
	m_strText += _T("<body bgcolor=");
	m_strText += k_strTextColorOfTitleOrSubTitle;
	m_strText += _T(">\n");
	m_strText += _T("<TABLE BORDER=\"1\" BORDERCOLOR=");
	m_strText += k_strTableBorderColor;
	m_strText += _T(" CELLPADDING=\"2\" CELLSPACING=\"0\" WIDTH=100%>\n");
	m_strText += _T("<TR>\n");
	m_strText += _T("<TD COLSPAN=\"4\" ALIGN=CENTER BGCOLOR=");
	m_strText += k_strBGColorOfTitle;
	m_strText += _T(">\n");
	m_strText += _T("<FONT SIZE=\"+3\" COLOR=");
	m_strText += k_strTextColorOfTitleOrSubTitle;
	m_strText += _T(">\n");
	m_strText += _T("<B>Thread Status Overview Page ");
	m_strText += _T("</B></FONT> ");
	m_strText += _T("</TD>\n");
	m_strText += _T("</TR>\n");
	m_strText += _T("</h1></center>\n");
	m_strText += _T("</TABLE>\n");
	////////////////////////////////////////////////////////////////////////////////////
	// Display global counters
	m_strText += _T("<TABLE BORDER=\"1\" BORDERCOLOR=\"#000000\" CELLPADDING=\"2\" CELLSPACING=\"0\" WIDTH=100%>\n");
	curr_counter = (CHourlyDailyCounter*)Get_g_CounterMgr()->Get(CCounterLocation(CCounterLocation::eIdProgramContemporary));
	if (curr_counter) 
	{
		strTmp = CDisplayCounterCurrentDateTime(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Current Date/Time:"), strTmp);
	}
	
	
	if (registryMonitor.GetNumericInfo(CAPGTSRegConnector::eMaxWQItems, dwRegistryItem)) 
	{
		strRegistryItem.Format(_T("%d"), dwRegistryItem);
		AppendNameAndValueAsRow(m_strText, _T("Current maximum size of queue:"), strRegistryItem);
	}
	else
		AppendNameAndValueAsRow(m_strText, _T("Current maximum size of queue:"), strRegistryItemNotFound);

	////////////////////////////////////////////////////////////////////////////////////
	// Extract and display information about threads and queue
	tmp_counter.Init(threadPool.GetWorkingThreadCount());
	strTmp = CDisplayCounterTotal(&tmp_counter).Display();
	AppendNameAndValueAsRow(m_strText, _T("Current number of working threads:"), strTmp);

	tmp_counter.Init(poolQueue.GetTotalQueueItems());
	strTmp = CDisplayCounterTotal(&tmp_counter).Display();
	AppendNameAndValueAsRow(m_strText, _T("Current number of work items in queue:"), strTmp);
		
	tmp_counter.Init(poolQueue.GetTotalWorkItems());
	strTmp = CDisplayCounterTotal(&tmp_counter).Display();
	AppendNameAndValueAsRow(m_strText, _T("Current number of work items either in queue or in progress:"), strTmp);

	strTmp = CSafeTime(poolQueue.GetTimeLastAdd()).StrLocalTime();
	AppendNameAndValueAsRow(m_strText, _T("Date/Time of most recent addition to queue:"), strTmp);

	strTmp = CSafeTime(poolQueue.GetTimeLastRemove()).StrLocalTime();
	AppendNameAndValueAsRow(m_strText, _T("Date/Time of most recent removal from queue:"), strTmp);

	//////////////////////////////////////////////////////////////////////////////////
	// thread pool status information
	long more5 = 0, more10 = 0;
	vector<CPoolThreadStatus> arrPoolThreadStatusOlder5;
	// This next is slightly klugy.  Ideally, we'd get this info into arrPoolThreadStatusOlder5
	vector<DWORD> Older5ThreadNumber;
	for (i = 0; i < arrPoolThreadStatus.size(); i++)
	{
		if (arrPoolThreadStatus[i].m_bWorking) 
		{
			if (arrPoolThreadStatus[i].m_seconds > 5)
			{
				arrPoolThreadStatusOlder5.push_back(arrPoolThreadStatus[i]);
				Older5ThreadNumber.push_back(i);
				more5++;
			}
			if (arrPoolThreadStatus[i].m_seconds > 10)
				more10++;
		}
	}

	
	strTmp.Format(_T("%ld"), more5);
	AppendNameAndValueAsRow(m_strText, _T("Number of pool threads that have been working on a task for more than 5 seconds:"), strTmp);
	
	strTmp.Format(_T("%ld"), more10);
	AppendNameAndValueAsRow(m_strText, _T("Number of pool threads that have been working on a task for more than 10 seconds:"), strTmp);

	m_strText += _T("</TABLE>\n");
	m_strText += _T("<br>\n");
	DisplayTextAsTable(m_strText, _T("Detailed information on each of the pool threads that has been working on a task for more than 5 seconds"), 1);

	for (i = 0; i < arrPoolThreadStatusOlder5.size(); i++)
	{
		strTmp.Format(_T("<B>Thread %d </B>"), Older5ThreadNumber[i]);
		strTmp2 = _T(" has been in \"working\" state for ");
		strTmp += strTmp2;
		strTmp3.Format(_T("%ld"), (long)arrPoolThreadStatusOlder5[i].m_seconds);
		strTmp3 += _T(" seconds");
		AppendNameAndValueAsRow(m_strText, strTmp, strTmp3);

		strTmp.Format( _T("Date/Time thread %d started:"), Older5ThreadNumber[i]);
		strTmp2 = CSafeTime(arrPoolThreadStatusOlder5[i].m_timeCreated).StrLocalTime();
		AppendNameAndValueAsRow(m_strText, strTmp, strTmp2);

		strTmp.Format( _T("Thread %d is working on topic:"), Older5ThreadNumber[i]);
		strTmp2 = arrPoolThreadStatusOlder5[i].m_strTopic.GetLength() 
					 ? arrPoolThreadStatusOlder5[i].m_strTopic
					 : _T("no topic");
		AppendNameAndValueAsRow(m_strText, strTmp, strTmp2);

		
		strTmp.Format (_T("Client IP address for Thread %d:"),Older5ThreadNumber[i] );
		strTmp2 = arrPoolThreadStatusOlder5[i].m_strClientIP.GetLength() 
						? arrPoolThreadStatusOlder5[i].m_strClientIP : _T("no address");
		AppendNameAndValueAsRow(m_strText, strTmp, strTmp2);

		
		strTmp.Format( _T(" Client browser for Thread %d:"), Older5ThreadNumber[i] );
		strTmp2 = arrPoolThreadStatusOlder5[i].m_strBrowser.GetLength() 
						? arrPoolThreadStatusOlder5[i].m_strBrowser : _T("no browser");

		AppendNameAndValueAsRow(m_strText, strTmp, strTmp2);

	
		
	}
	if (!i)
		AppendNameAndValueAsRow(m_strText, _T(""), _T("No threads"));
	
	//////////////////////////////////////////////////////////////////////////////////
	// registry monitor thread status information
	CRegistryMonitor::ThreadStatus registryStatus;
	DWORD registrySeconds = 0;
	CString strRegistryStatus;
	registryMonitor.GetStatus(registryStatus, registrySeconds);
	switch(registryStatus)
	{
		case CRegistryMonitor::eBeforeInit: strRegistryStatus = _T("Before Init");
			break;
		case CRegistryMonitor::eInit: strRegistryStatus = _T("Init");
			break;
		case CRegistryMonitor::eFail: strRegistryStatus = _T("Fail");
			break;
		case CRegistryMonitor::eDefaulting: strRegistryStatus = _T("Defaulting");
			break;
		case CRegistryMonitor::eWait: strRegistryStatus = _T("Wait");
			break;
		case CRegistryMonitor::eRun: strRegistryStatus = _T("Run");
			break;
		case CRegistryMonitor::eExiting: strRegistryStatus = _T("Exiting");
			break;
	}


	m_strText += _T("</TABLE>\n");
	m_strText += _T("<br>\n");
	m_strText += _T("<TABLE BORDER=\"1\" BORDERCOLOR=");
	m_strText += k_strTableBorderColor;
	m_strText += _T(" CELLPADDING=\"2\" CELLSPACING=\"0\" WIDTH=100%>\n");

	strTmp = strRegistryStatus;
	AppendNameAndValueAsRow(m_strText, _T("Current status of Registry Monitor thread:"), strTmp);

	strTmp.Format(_T("%ld"), (long)registrySeconds);
	strTmp  += _T(" seconds\n");
	AppendNameAndValueAsRow(m_strText, _T("The thread has been in this status for "), strTmp);

	//////////////////////////////////////////////////////////////////////////////////
	// directory monitor thread status information
	CDirectoryMonitor::ThreadStatus directoryStatus;
	DWORD directorySeconds = 0;
	CString strDirectoryStatus;
	directoryMonitor.GetStatus(directoryStatus, directorySeconds);
	switch(directoryStatus)
	{
		case CDirectoryMonitor::eBeforeInit: strDirectoryStatus = _T("Before Init");
			break;
		case CDirectoryMonitor::eFail: strDirectoryStatus = _T("Fail");
			break;
		case CDirectoryMonitor::eWaitDirPath: strDirectoryStatus = _T("Wait For Dir Path");
			break;
		case CDirectoryMonitor::eWaitChange: strDirectoryStatus = _T("Wait For Change");
			break;
		case CDirectoryMonitor::eWaitSettle: strDirectoryStatus = _T("Wait To Settle");
			break;
		case CDirectoryMonitor::eRun: strDirectoryStatus = _T("Run");
			break;
		case CDirectoryMonitor::eBeforeWaitChange: strDirectoryStatus = _T("Before Wait Change");
			break;
		case CDirectoryMonitor::eExiting: strDirectoryStatus = _T("Exiting");
			break;
	}

	strTmp = strDirectoryStatus;
	AppendNameAndValueAsRow(m_strText, _T("Current status of Directory Monitor thread:"), strTmp);

	strTmp.Format(_T("%ld"), (long)directorySeconds);
	strTmp += _T(" seconds\n");
	AppendNameAndValueAsRow(m_strText, _T("The thread has been in this status for "), strTmp);

	//////////////////////////////////////////////////////////////////////////////////
	// topic builder thread status information
	CTopicShop::ThreadStatus topicshopStatus;
	DWORD topicshopSeconds = 0;
	CString strTopicshopStatus;
	topicShop.GetThreadStatus(topicshopStatus, topicshopSeconds);
	switch(topicshopStatus)
	{
		case CTopicShop::eBeforeInit: strTopicshopStatus = _T("Before Init");
			break;
		case CTopicShop::eFail: strTopicshopStatus = _T("Fail");
			break;
		case CTopicShop::eWait: strTopicshopStatus = _T("Wait");
			break;
		case CTopicShop::eRun: strTopicshopStatus = _T("Run");
			break;
		case CTopicShop::eExiting: strTopicshopStatus = _T("Exiting");
			break;
	}

	strTmp = strTopicshopStatus;
	AppendNameAndValueAsRow(m_strText, _T("Current status of TopicShop Monitor thread:"), strTmp);

	strTmp.Format(_T("%ld"), (long)topicshopSeconds);
	strTmp += _T(" seconds\n");
	AppendNameAndValueAsRow(m_strText, _T("The thread has been in this status for "), strTmp);


	//////////////////////////////////////////////////////////////////////////////////
	
	m_strText += _T("</TABLE>\n");
	m_strText += _T("<br>\n");
	DisplayTextAsTable(m_strText, _T("State of each pool thread"), 1);

	for (i = 0; i < arrPoolThreadStatus.size(); i++)
	{
		strTmp.Format(_T("<B>Thread %d has been in "), i);
		strTmp2 = arrPoolThreadStatus[i].m_bWorking ? _T("\"working\"") : _T("\"waiting\"");
		strTmp3 = _T(" state for </B>");
		strTmp2 +=  strTmp3;
		strTmp +=  strTmp2;
		strTmp4.Format(_T("%ld"), (long)arrPoolThreadStatus[i].m_seconds);
		strTmp4 += _T(" seconds.");
		AppendNameAndValueAsRow(m_strText, strTmp, strTmp4);
	}
	if (!i)
		AppendNameAndValueAsRow(m_strText, _T(""),_T("No threads") );

	m_strText += _T("</TABLE>\n");
	//////////////////////////////////////////////////////////////////////////////////
	// Link buttons
	BeginSelfAddressingForm();
	InsertPasswordInForm();
	m_strText += _T("<INPUT TYPE=hidden NAME=\"");
	m_strText += C_FURTHER_GLOBAL;
	// Value here is not actually relevant; effectively used as a comment.
	m_strText += _T("\" VALUE=\"Further Global Status Page\">\n");
	m_strText += _T("<INPUT TYPE=SUBMIT VALUE=\"Further Global Status Page\">\n");
	m_strText += _T("</FORM>\n");

	BeginSelfAddressingForm();
	InsertPasswordInForm();
	m_strText += _T("<INPUT TYPE=hidden NAME=\"");
	m_strText += C_FIRST;
	// Value here is not actually relevant; effectively used as a comment.
	m_strText += _T("\" VALUE=\"Front Page\">\n");
	m_strText += _T("<INPUT TYPE=SUBMIT VALUE=\"Front Page\">\n");
	m_strText += _T("</FORM>\n");

	m_strText += _T("</body></html>\n");
}

///////////////////////////

void APGTSContext::DisplayTopicStatusPage(LPCTSTR topic_name)
{
	CHourlyDailyCounter tmp_counter, *curr_counter;
	CTopicShop& topicShop = m_pConf->GetTopicShop();
	CTopicInCatalog* pTopicInCatalog = topicShop.GetCatalogEntry(topic_name);
	CHourlyTotals hourly;
	CDailyTotals daily;
	CString strTmp;
	CString strTmp2;

	m_strText += _T("<html>\n");
	m_strText += _T("<B><head><title>Status</title></head>\n");
	m_strText += _T("<body bgcolor=");
	m_strText += k_strTextColorOfTitleOrSubTitle;
	m_strText += _T(">\n");
	m_strText += _T("<TABLE BORDER=\"1\" BORDERCOLOR=");
	m_strText += k_strTableBorderColor;
	m_strText += _T(" CELLPADDING=\"2\" CELLSPACING=\"0\" WIDTH=100%>\n");
	m_strText += _T("<TR>\n");
	m_strText += _T("<TD COLSPAN=\"4\" ALIGN=CENTER BGCOLOR=");
	m_strText += k_strBGColorOfTitle;
	m_strText += _T("> \n");
	m_strText += _T("<FONT SIZE=\"+3\" COLOR=");
	m_strText += k_strTextColorOfTitleOrSubTitle;
	m_strText += _T("> \n");
	m_strText += _T("<B>Topic Status Page for ");
	m_strText += topic_name;
	m_strText += _T("</B></FONT> ");
	m_strText += _T("</TD>\n");
	m_strText += _T("</TR>\n");
	

	if (pTopicInCatalog) 
		m_strText += _T("</h1></center>\n");
	else
	{
		m_strText += _T("No data available");
		m_strText += _T("</h1></center>\n");
		return;
	}

	CTopicInfo topicInfo = pTopicInCatalog->GetTopicInfo();
	CString strDsc = CAbstractFileReader::GetJustName(topicInfo.GetDscFilePath());
	CString strHti = CAbstractFileReader::GetJustName(topicInfo.GetHtiFilePath());
	CString strBes = CAbstractFileReader::GetJustName(topicInfo.GetBesFilePath());

	m_strText += _T("</TABLE>\n");
	m_strText += _T("<TABLE BORDER= \"1\" BORDERCOLOR=\"#000000\" CELLPADDING=\"2\" CELLSPACING=\"0\" WIDTH=100%>\n");
	curr_counter = (CHourlyDailyCounter*)Get_g_CounterMgr()->Get(CCounterLocation(CCounterLocation::eIdProgramContemporary));
	if (curr_counter) 
	{
		strTmp = CDisplayCounterCurrentDateTime(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Current Date/Time:"), strTmp);
	}

	m_strText += _T("</TABLE>\n");

	m_strText += _T("<TABLE BORDER=\"1\" BORDERCOLOR=");
	m_strText += k_strTableBorderColor;
	m_strText += _T(" CELLPADDING=\"2\" CELLSPACING=\"0\" WIDTH=100%>\n");

	strTmp = CString(_T("<BR>")) + (strDsc.GetLength() ? strDsc : _T("Unknown"));
	strTmp2 = CString(_T("<BR>")) + topicInfo.GetStrDscFileCreated();
	AppendTwoNamesAndValueAsRow(m_strText, _T("DSC file:"), strTmp, strTmp2);

	m_strText += _T("</TABLE>\n");
	m_strText += _T("<TABLE BORDER=\"1\" BORDERCOLOR=");
	m_strText += k_strTableBorderColor;
	m_strText += _T(" CELLPADDING=\"2\" CELLSPACING=\"0\" WIDTH=100%>\n");

	bool bHTIinsideOfDSC= false, bBESinsideOfDSC= false;
	{
		CP_TOPIC ptrTopic;
		pTopicInCatalog->GetTopicNoWait(ptrTopic);

		CString strTmp;
		if (!ptrTopic.IsNull())
		{
			strTmp = ptrTopic->GetNetPropItemStr( H_NET_DATE_TIME );

			// Check for HTI and BES files inside the DSC.
			CString strTmpHTI= ptrTopic->GetMultilineNetProp( H_NET_HTI_ONLINE, _T("%s\r\n") );
			if (strTmpHTI.GetLength())
				bHTIinsideOfDSC= true;
			CString strTmpBES= ptrTopic->GetNetPropItemStr( H_NET_BES );
			if (strTmpBES.GetLength())
				bBESinsideOfDSC= true;
		}

		strTmp2 = strTmp.GetLength() ? strTmp : _T("Unavailable");
		AppendNameAndValueAsRow(m_strText, _T("Last revision date/time of DSC:"), strTmp2);
	}

	m_strText += _T("</TABLE>\n");

	m_strText += _T("<TABLE BORDER=\"1\" BORDERCOLOR=");
	m_strText += k_strTableBorderColor;
	m_strText += _T(" CELLPADDING=\"2\" CELLSPACING=\"0\" WIDTH=100%>\n");

	strTmp2 = CString(_T("<BR>")) + topicInfo.GetStrHtiFileCreated();
	if (strHti.GetLength())
		strTmp= _T("<BR>") + strHti;
	else if (bHTIinsideOfDSC)
	{
		// Use DSC file settings.
		strTmp = CString(_T("<BR>")) + (strDsc.GetLength() ? strDsc : _T("Unknown"));
		strTmp2 = CString(_T("<BR>")) + topicInfo.GetStrDscFileCreated();
	}
	else
		strTmp= _T("<BR>Unknown");
	AppendTwoNamesAndValueAsRow(m_strText, _T("HTI file:"), strTmp, strTmp2);

	strTmp2 = CString(_T("<BR>")) + topicInfo.GetStrBesFileCreated();
	if (strBes.GetLength())
		strTmp= _T("<BR>") + strBes;
	else if (bBESinsideOfDSC)
	{
		// Use DSC file settings.
		strTmp = CString(_T("<BR>")) + (strDsc.GetLength() ? strDsc : _T("Unknown"));
		strTmp2 = CString(_T("<BR>")) + topicInfo.GetStrDscFileCreated();
	}
	else
		strTmp= _T("<BR>Unknown");
	AppendTwoNamesAndValueAsRow(m_strText, _T("BES file:"), strTmp, strTmp2);

	if (pTopicInCatalog->GetTopicInfoMayNotBeCurrent())
	{
		m_strText += _T("<TR>\n");    
        m_strText += _T("<TD COLSPAN=3 ALIGN=\"CENTER\" BGCOLOR=\"#CCCC99\" >\n");
		m_strText += _T("<BR>***BES or HTI may recently have changed, and data may not yet be updated.***");
		m_strText += _T("</TD>\n");
		m_strText += _T("</TR>\n");
	}
	
	m_strText += _T("</TABLE>\n");
	m_strText += _T("<TABLE BORDER=\"1\" BORDERCOLOR=");
	m_strText += k_strTableBorderColor;
	m_strText += _T(" CELLPADDING=\"2\" CELLSPACING=\"0\" WIDTH=100%>\n");
	curr_counter = (CHourlyDailyCounter*)Get_g_CounterMgr()->Get(CCounterLocation(CCounterLocation::eIdTopicEvent, topicInfo.GetNetworkName()));
	if (curr_counter) 
	{
		strTmp = CDisplayCounterFirstDateTime(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Date/time of first becoming aware of this topic:"), strTmp);
	}
	
	curr_counter = (CHourlyDailyCounter*)Get_g_CounterMgr()->Get(CCounterLocation(CCounterLocation::eIdTopicLoad, topicInfo.GetNetworkName()));
	if (curr_counter) 
	{
		strTmp = CDisplayCounterFirstDateTime(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Date/time of first attempted load of this topic:"), strTmp);
	}
	
	curr_counter = (CHourlyDailyCounter*)Get_g_CounterMgr()->Get(CCounterLocation(CCounterLocation::eIdTopicLoadOK, topicInfo.GetNetworkName()));
	if (curr_counter) 
	{
		strTmp = CDisplayCounterFirstDateTime(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Date/time of first successful load of this topic:"), strTmp);
	}
	
	curr_counter = (CHourlyDailyCounter*)Get_g_CounterMgr()->Get(CCounterLocation(CCounterLocation::eIdTopicEvent, topicInfo.GetNetworkName()));
	if (curr_counter) 
	{
		strTmp = CDisplayCounterLastDateTime(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Date/time of most recent change (detected by directory monitor) or reload request (from an operator) to this topic:"), strTmp);
	}
	
	curr_counter = (CHourlyDailyCounter*)Get_g_CounterMgr()->Get(CCounterLocation(CCounterLocation::eIdTopicLoad, topicInfo.GetNetworkName()));
	if (curr_counter) 
	{
		strTmp = CDisplayCounterTotal(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Count of attempted loads of this topic:"), strTmp);
	}
	
	curr_counter = (CHourlyDailyCounter*)Get_g_CounterMgr()->Get(CCounterLocation(CCounterLocation::eIdTopicLoad, topicInfo.GetNetworkName()));
	if (curr_counter) 
	{
		strTmp = CDisplayCounterLastDateTime(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Date/time of most recent attempted load of this topic:"), strTmp);
	}
	
	curr_counter = (CHourlyDailyCounter*)Get_g_CounterMgr()->Get(CCounterLocation(CCounterLocation::eIdTopicLoadOK, topicInfo.GetNetworkName()));
	if (curr_counter) 
	{
		strTmp = CDisplayCounterTotal(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Count of successful loads of this topic:"), strTmp);
	}
	
	curr_counter = (CHourlyDailyCounter*)Get_g_CounterMgr()->Get(CCounterLocation(CCounterLocation::eIdTopicLoadOK, topicInfo.GetNetworkName()));
	if (curr_counter) 
	{
		strTmp = CDisplayCounterLastDateTime(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Date/time of most recent successful load of this topic:"), strTmp);
	}
	
	curr_counter = (CHourlyDailyCounter*)Get_g_CounterMgr()->Get(CCounterLocation(CCounterLocation::eIdTopicHit, topicInfo.GetNetworkName()));
	if (curr_counter) 
	{
		strTmp = CDisplayCounterFirstDateTime(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Date/time of first user hit on this topic:"), strTmp);
	}
	
	curr_counter = (CHourlyDailyCounter*)Get_g_CounterMgr()->Get(CCounterLocation(CCounterLocation::eIdTopicHit, topicInfo.GetNetworkName()));
	if (curr_counter) 
	{
		strTmp = CDisplayCounterLastDateTime(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Date/time of most recent hit:"), strTmp);
	}
	
	curr_counter = (CHourlyDailyCounter*)Get_g_CounterMgr()->Get(CCounterLocation(CCounterLocation::eIdTopicHit, topicInfo.GetNetworkName()));
	if (curr_counter) 
	{
		strTmp = CDisplayCounterTotal(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Total count of hits since system startup:"), strTmp);
	}

	m_strText += _T("</TABLE>\n");
	m_strText += _T("<br>\n");

	curr_counter = (CHourlyDailyCounter*)Get_g_CounterMgr()->Get(CCounterLocation(CCounterLocation::eIdTopicHit, topicInfo.GetNetworkName()));
	if (curr_counter) 
	{
		DisplayTextAsTable(m_strText, _T("Daily/hourly count of hits"), 1);
		m_strText += CDisplayCounterDailyHourly(curr_counter, &daily, &hourly).Display();
	}

	m_strText += _T("</TABLE>\n");
	m_strText += _T("<br>\n");
	m_strText += _T("<TABLE BORDER=\"1\" BORDERCOLOR=\"#000000\" CELLPADDING=\"2\" CELLSPACING=\"0\" WIDTH=100%>\n");
	

	curr_counter = (CHourlyDailyCounter*)Get_g_CounterMgr()->Get(CCounterLocation(CCounterLocation::eIdTopicHitNewCookie, topicInfo.GetNetworkName()));
	if (curr_counter) 
	{
		strTmp = CDisplayCounterTotal(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Hits without cookie (presumably first hit by this user):"), strTmp);
	}
	
	curr_counter = (CHourlyDailyCounter*)Get_g_CounterMgr()->Get(CCounterLocation(CCounterLocation::eIdTopicHitOldCookie, topicInfo.GetNetworkName()));
	if (curr_counter) 
	{
		strTmp = CDisplayCounterTotal(curr_counter).Display();
		AppendNameAndValueAsRow(m_strText, _T("Hits with cookie (presumably not first hit by this user):"), strTmp);
	}
	m_strText += _T("</TABLE>\n");
	if (CTopicInCatalog::eFail != pTopicInCatalog->GetTopicStatus())
	{
		BeginSelfAddressingForm();
		m_strText += _T("<INPUT TYPE=hidden NAME=\"");
		m_strText += C_TOPIC;
		m_strText += _T("\" VALUE=\"");
		m_strText += topic_name;
		m_strText += _T("\">\n");
		m_strText += _T("<INPUT TYPE=SUBMIT VALUE=\"");
		m_strText += _T("Problem Page for ");
		m_strText += topic_name;
		m_strText += _T("\">\n");
		m_strText += _T("</FORM>\n");
	}

	BeginSelfAddressingForm();
	InsertPasswordInForm();
	m_strText += _T("<INPUT TYPE=hidden NAME=\"");
	m_strText += C_FURTHER_GLOBAL;
	// Value here is not actually relevant; effectively used as a comment.
	m_strText += _T("\" VALUE=\"Further Global Status Page\">\n");
	m_strText += _T("<INPUT TYPE=SUBMIT VALUE=\"Further Global Status Page\">\n");
	m_strText += _T("</FORM>\n");

	BeginSelfAddressingForm();
	InsertPasswordInForm();
	m_strText += _T("<INPUT TYPE=hidden NAME=\"");
	m_strText += C_THREAD_OVERVIEW;
	// Value here is not actually relevant; effectively used as a comment.
	m_strText += _T("\" VALUE=\"Thread Status Overview Page\">\n");
	m_strText += _T("<INPUT TYPE=SUBMIT VALUE=\"Thread Status Overview Page\">\n");
	m_strText += _T("</FORM>\n");

	BeginSelfAddressingForm();
	InsertPasswordInForm();
	m_strText += _T("<INPUT TYPE=hidden NAME=\"");
	m_strText += C_FIRST;
	// Value here is not actually relevant; effectively used as a comment.
	m_strText += _T("\" VALUE=\"Front Page\">\n");
	m_strText += _T("<INPUT TYPE=SUBMIT VALUE=\"Front Page\">\n");
	m_strText += _T("</FORM>\n");
	//m_strText += _T("</TABLE>\n");


	///////////////////////////////////////////////////////////////////////////////////
	m_strText += _T("</body></html>\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__A8F3A149_99E9_11D2_8C7E_00C04F949D33__INCLUDED_)
#define AFX_STDAFX_H__A8F3A149_99E9_11D2_8C7E_00C04F949D33__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
//#define _ATL_FREE_THREADED
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

///////////////////////////////////////////////////////////////////////////////
// Threading model of the Local Troubleshooter
#ifdef LOCAL_TROUBLESHOOTER
	#ifdef _ATL_FREE_THREADED
	#define RUNNING_FREE_THREADED()			true
	#define RUNNING_APARTMENT_THREADED()	false
	#endif
	#ifdef _ATL_APARTMENT_THREADED
	#define RUNNING_FREE_THREADED()			false
	#define RUNNING_APARTMENT_THREADED()	true
	#endif
#else
	#define RUNNING_FREE_THREADED()			false
	#define RUNNING_APARTMENT_THREADED()	false
#endif
///////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A8F3A149_99E9_11D2_8C7E_00C04F949D33__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\templateread.cpp ===
//
// MODULE: TEMPLATEREAD.CPP
//
// PURPOSE: template file reading classes
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 8-12-98
//
// NOTES: 
//	1. CTemplateReader has no public methods to apply the template.  These must be supplied
//		by classes which inherit from CTemplateReader, and these must be supplied in a
//		suitably "stateless" manner.
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		08-04-98	OK
//

#include "stdafx.h"
#include <algorithm>
#include "templateread.h"
#include "event.h"
#include "CharConv.h"

////////////////////////////////////////////////////////////////////////////////////
// CTemplateInfo
//	Manages a pair consisting of a key and a string to substitute for each occurrence of
//	that key.
////////////////////////////////////////////////////////////////////////////////////
CTemplateInfo::CTemplateInfo()
{
}

CTemplateInfo::CTemplateInfo(const CString& key, const CString& substitution)
			 : m_KeyStr(key),
			   m_SubstitutionStr(substitution)
{
}

CTemplateInfo::~CTemplateInfo()
{
}

// INPUT/OUTPUT target
//	Replace all instances of m_KeyStr in target with m_SubstitutionStr
bool CTemplateInfo::Apply(CString& target) const
{
	int start =0, end =0;
	bool bRet = false;

	while (-1 != (start = target.Find(m_KeyStr)))
	{
		end = start + m_KeyStr.GetLength();
		target = target.Left(start) + m_SubstitutionStr + target.Mid(end);
		bRet = true;
	}
	return bRet;
}

////////////////////////////////////////////////////////////////////////////////////
// CTemplateReader
////////////////////////////////////////////////////////////////////////////////////
CTemplateReader::CTemplateReader(CPhysicalFileReader * pPhysicalFileReader, LPCTSTR szDefaultContents /*= NULL */)
			   : CTextFileReader(pPhysicalFileReader, szDefaultContents)
{
}

CTemplateReader::~CTemplateReader()
{
}

// For all instances of a key, substitute the appropriate value
CTemplateReader& CTemplateReader::operator << (CTemplateInfo& info)
{
	CString str;
	vector<CString> str_arr;

	LOCKOBJECT();
	SetPos(m_StreamOutput, 0);

	try
	{
		// put whole content of m_StreamOutput, line by line, into str_arr
		while (GetLine(m_StreamOutput, str))
			str_arr.push_back(str);
	}
	catch (exception& x)
	{
		CString str;
		// Note STL exception in event log.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								CCharConversion::ConvertACharToString(x.what(), str), 
								_T(""), 
								EV_GTS_STL_EXCEPTION ); 
	}

	vector<CString>::iterator i;
	//	Replace all instances of m_KeyStr in str_arr elements with m_SubstitutionStr
	for (i = str_arr.begin(); i < str_arr.end(); i++)
		info.Apply(*i);

	m_StreamOutput.clear();

	vector<CString>::iterator iLastElement = str_arr.end();
	iLastElement--;	

	for (i = str_arr.begin(); i < str_arr.end(); i++)
	{
		m_StreamOutput << (LPCTSTR)*i;
		if (i != iLastElement)
			m_StreamOutput << _T('\r') << _T('\n');
	}
	m_StreamOutput << ends;

	SetPos(m_StreamOutput, 0);
	UNLOCKOBJECT();
	return *this;
}

// undo substitution with this argument
// As of 11/98, not used in Online Troubleshooter, hence totally untested.
CTemplateReader& CTemplateReader::operator >> (CTemplateInfo& info)
{
	LOCKOBJECT();

	// remove this element from substitution list
	vector<CTemplateInfo>::iterator res = find(m_arrTemplateInfo.begin(), m_arrTemplateInfo.end(), info);
	if (res != m_arrTemplateInfo.end())
		m_arrTemplateInfo.erase(res);
	// perform all substitutions all over again
	Parse();
	
	UNLOCKOBJECT();
	return *this;
}

// Perform all substitutions
void CTemplateReader::Parse()
{
	SetOutputToTemplate();
	for (vector<CTemplateInfo>::iterator i = m_arrTemplateInfo.begin(); i < m_arrTemplateInfo.end(); i++)
		*this << *i;
}

void CTemplateReader::GetOutput(CString& out)
{
	out = _T(""); // clear
	LOCKOBJECT();
	out = m_StreamOutput.rdbuf()->str().c_str();
	UNLOCKOBJECT();
}

// In m_StreamData we always have pure template
// This function is discarding all changes in m_StreamOutput
//  and setting it back to template
void CTemplateReader::SetOutputToTemplate()
{
	LOCKOBJECT();
	tstring tstr;
	m_StreamOutput.str(GetContent(tstr));
	UNLOCKOBJECT();
}

////////////////////////////////////////////////////////////////////////////////////
// CSimpleTemplate
////////////////////////////////////////////////////////////////////////////////////
CSimpleTemplate::CSimpleTemplate(CPhysicalFileReader * pPhysicalFileReader, LPCTSTR szDefaultContents /*= NULL*/) :
	CTemplateReader(pPhysicalFileReader, szDefaultContents)
{
}

CSimpleTemplate::~CSimpleTemplate()
{
}

// Given a vector of substitutions to make, perform them all (on the template) and return 
//	the resulting string.
void CSimpleTemplate::CreatePage(	const vector<CTemplateInfo> & arrTemplateInfo, 
									CString& out)
{
	LOCKOBJECT();
	m_arrTemplateInfo = arrTemplateInfo;
	Parse();
	out = m_StreamOutput.rdbuf()->str().c_str();
	UNLOCKOBJECT();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\threadpool.h ===
//
// MODULE: ThreadPool.h
//
// PURPOSE: interface for classes for high level of pool thread activity
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel, based on earlier (8-2-96) work by Roman Mach
// 
// ORIGINAL DATE: 9/23/98
//
// NOTES: 
// 1. 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V3.0		9/23/98		JM		better encapsulation & some chages to algorithm
//

#if !defined(AFX_THREADPOOL_H__0F43119D_5247_11D2_95FC_00C04FC22ADD__INCLUDED_)
#define AFX_THREADPOOL_H__0F43119D_5247_11D2_95FC_00C04FC22ADD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <time.h>
#include "stateless.h"

class CPoolQueue;	// forward reference
class APGTSContext;	// forward reference

// Status class for pool threads, used by both the thread pool in order to handle stuck threads
// as well as by the status page for reporting on thread status.  If time permits, we should 
// convert the member variable to private and add get-set methods in order to be consistent with
// the rest of the code. 
class CPoolThreadStatus
{
public:
	time_t m_timeCreated;	// time CThreadPool::CThreadControl object was constructed
							//	If this CPoolThreadStatusobject is the return of a thread 
							//	status request, 0 here implies there is no such
							//	CThreadPool::CThreadControl object
	DWORD m_seconds;		// time elapsed since last started or finished a request.
							// That is, how long this thread has been working on a task 
							//	(or how long since it finished its last task)
							//	If task was never started - this is time since m_timeCreated
	bool m_bWorking;		// true = currently working on a request.
	bool m_bFailed;			// true = encountered a majorly unexpected situation &
							//	chose to exit.
	CString m_strTopic;		// current topic we are working on,
							//  It is not initialized in the constructor so it can be zero length
							//  Is used to transport the current topic name back to the status page.
	CString m_strBrowser;	// Current client browser.  Used to transport the browser name back to
							//	the status page.
	CString m_strClientIP;	// Current Client IP address.  Used to transport the client IP address
							//	back to the status page.

	CPoolThreadStatus() : 
		m_timeCreated(0), m_seconds(0), m_bWorking(false), m_bFailed(false) 
		{};
	bool operator <  (const CPoolThreadStatus&) const {return false;}
	bool operator == (const CPoolThreadStatus&) const {return false;}
};


class CSniffConnector;

class CThreadPool
{
	friend class CDBLoadConfiguration;
private:
	class CThreadControl
	{
	private:
		HANDLE m_hThread;		// thread handle
		HANDLE m_hevDone;		// Thread uses this event only to say, effectively, 
								//	"outta here" as it dies.
		HANDLE m_hMutex;		// protect access to m_time, m_bWorking.
		bool m_bExit;			// set true when either a normal queued-up task or an explicit 
								//	"kill" wants the thread to break out of its loop.
		CPoolQueue *m_pPoolQueue;	// point to the one and only instance of CPoolQueue
		time_t m_timeCreated;	// time this object was constructed
		time_t m_time;			// time last started or finished a request; init'd 0, but will
								//	be non-zero if thread ever used.
		bool m_bWorking;		// true = currently working on a request.
		bool m_bFailed;			// true = encountered a majorly unexpected situation &
								//	chose to exit.
		CNameStateless m_strBrowser;	// Current client browser.  
		CNameStateless m_strClientIP;	// Current Client IP address. 
		APGTSContext *m_pContext;	// pointer to context of a request.
		CSniffConnector *m_pSniffConnector; // pointer to sniff connector base class,
											//  the only purpose of storing this pointer
											//  as member variable is to pass it to 
											//  constructor of APGTSContext
	public:
		CThreadControl(CSniffConnector*);
		~CThreadControl();

		// This function may throw an exceptions of type CGeneralException.
		DWORD Initialize(CPoolQueue * pPoolQueue);

		void Kill(DWORD milliseconds);
		bool WaitForThreadToFinish(DWORD milliseconds);
		void WorkingStatus(CPoolThreadStatus & status);
		time_t GetTimeCreated() const;

	private:
		static UINT WINAPI PoolTask( LPVOID lpParams );
		bool ProcessRequest();
		void PoolTaskLoop();
		void Lock();
		void Unlock();
		bool Exit();
	};

public:
	CThreadPool(CPoolQueue * pPoolQueue, CSniffConnector * pSniffConnector);
	~CThreadPool();
	DWORD GetStatus() const;	// get any error during construction
	DWORD GetWorkingThreadCount() const;
	void ExpandPool(DWORD dwDesiredThreadCount);
	bool ReinitializeThread(DWORD i);
	void ReinitializeStuckThreads();
	bool ThreadStatus(DWORD i, CPoolThreadStatus &status);
private:
	void DestroyThreads();
private:
	DWORD m_dwErr;
	CThreadControl **m_ppThreadCtl;	// thread management
	CSniffConnector *m_pSniffConnector; // pointer to sniff connector base class,
										//  the only purpose of storing this pointer
										//  as member variable is to pass it to 
										//  constructor of CThreadControl
	DWORD m_dwWorkingThreadCount;	// threads actually created
	CPoolQueue *m_pPoolQueue;		// Keeps track of user requests queued up to be serviced 
									//	by working threads (a.k.a. "pool threads")
};

#endif // !defined(AFX_THREADPOOL_H__0F43119D_5247_11D2_95FC_00C04FC22ADD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\topic.h ===
//
// MODULE: TOPIC.H
//
// PURPOSE: Class CTopic brings together all of the data structures that represent a 
//			troubleshooting topic.  Most importantly, this represents the belief network,
//			but it also represents the HTI template, the data derived from the BES (back 
//			end search) file, and any other persistent data.
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 9-9-98
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		09-09-98	JM
//

#if !defined(AFX_TOPIC_H__278584FE_47F9_11D2_95F2_00C04FC22ADD__INCLUDED_)
#define AFX_TOPIC_H__278584FE_47F9_11D2_95F2_00C04FC22ADD__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "BN.h"
#include "apgtsbesread.h"
#include "apgtshtiread.h"

// The bulk of the methods on this class are inherited from CBeliefNetwork
class CTopic : public CBeliefNetwork
{
private:
	CAPGTSHTIReader *m_pHTI;
	CAPGTSBESReader *m_pBES;
	CString m_pathHTI;
	CString m_pathBES;
	CString m_pathTSC;
	bool m_bTopicIsValid;
	bool m_bTopicIsRead;

private:
	CTopic();	// do not instantiate
public:
	CTopic( LPCTSTR pathDSC 
		   ,LPCTSTR pathHTI 
		   ,LPCTSTR pathBES
		   ,LPCTSTR pathTSC );
	virtual ~CTopic();

	// redefined inherited methods
	bool IsRead();
	bool Read();

	// newly introduced methods
	bool HasBES();
	void GenerateBES(
		const vector<CString> & arrstrIn,
		CString & strEncoded,
		CString & strRaw);
	void CreatePage(	const CHTMLFragments& fragments, 
						CString& out, 
						const map<CString,CString> & mapStrs,
						CString strHTTPcookies= _T("") );
	// JSM V3.2
	void ExtractNetProps(vector<CString> &arr_props);

	bool HasHistoryTable();
};

#endif // !defined(AFX_TOPIC_H__278584FE_47F9_11D2_95F2_00C04FC22ADD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\templateread.h ===
//
// MODULE: TEMPLATEREAD.H
//
// PURPOSE: template file reading classes
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 8-12-98
//
// NOTES: 
//	1. CTemplateReader has no public methods to apply the template.  These must be supplied
//		by classes which inherit from CTemplateReader, and these must be supplied in a
//		suitably "stateless" manner.
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		08-04-98	OK
//

#ifndef __TEMPLATEREAD_H_
#define __TEMPLATEREAD_H_

#include "fileread.h"

#include <map>
using namespace std;

////////////////////////////////////////////////////////////////////////////////////
// CTemplateInfo
////////////////////////////////////////////////////////////////////////////////////
class CTemplateInfo
{
	CString m_KeyStr;			// key text which we will replace with m_SubstitutionStr
	CString m_SubstitutionStr;	// text we will use to replace m_KeyStr

public:
	CTemplateInfo();
	CTemplateInfo(const CString& key, const CString& substitution);
	virtual ~CTemplateInfo();
	
	CString& GetKeyStr() {return m_KeyStr;}
	virtual bool Apply(CString& target) const;

// comparison methods are mainly to keep STL happy.  Note that they only look at
//	m_KeyStr, not m_SubstitutionStr.
inline BOOL operator == (const CTemplateInfo& two) const
{
	return m_KeyStr == two.m_KeyStr;
}

inline BOOL operator < (const CTemplateInfo& two) const 
{
	return m_KeyStr < two.m_KeyStr;
}


};

////////////////////////////////////////////////////////////////////////////////////
// CTemplateReader
// This class reads template file and provides functionality to substitute key
//   sentences with text - do it all at once, or one-by-one.
// The object of this class can be renewed with another template - in this case
//  all substitution actions will be performed on new template.
// It can roll back "n" last substitutions
////////////////////////////////////////////////////////////////////////////////////
class CTemplateReader : public CTextFileReader
{
protected:
	tstringstream m_StreamOutput; // streamed output, fully or partly substituted template
							      //  (which resides in CFileReader::m_StreamData)
	vector<CTemplateInfo> m_arrTemplateInfo; // contains key string - template info
										     //  pairs
public:
	CTemplateReader(CPhysicalFileReader * pPhysicalFileReader, LPCTSTR szDefaultContents = NULL);
   ~CTemplateReader();

protected:
	void SetOutputToTemplate();
	CTemplateReader& operator << (CTemplateInfo&); // apply
	CTemplateReader& operator >> (CTemplateInfo&); // roll back application for this CTemplateInfo

	void GetOutput(CString&);

protected:
	// overrrides of inherited functions
	virtual void Parse(); // parse here is applying ALL elements of m_arrTemplateInfo
						  //  to a virgin template

};

////////////////////////////////////////////////////////////////////////////////////
// a concrete class that just provides simple string substitution
////////////////////////////////////////////////////////////////////////////////////
class CSimpleTemplate : public CTemplateReader
{
public:
	CSimpleTemplate(CPhysicalFileReader * pPhysicalFileReader, LPCTSTR szDefaultContents = NULL);
   ~CSimpleTemplate();

   void CreatePage(	const vector<CTemplateInfo> & arrTemplateInfo, 
					CString& out );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\topic.cpp ===
//
// MODULE: TOPIC.CPP
//
// PURPOSE: Class CTopic brings together all of the data structures that represent a 
//			troubleshooting topic.  Most importantly, this represents the belief network,
//			but it also represents the HTI template, the data derived from the BES (back 
//			end search) file, and any other persistent data.
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 9-9-98
//
// NOTES: 
// 1. The bulk of the methods on this class are inherited from CBeliefNetwork
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		09-09-98	JM
//

#pragma warning(disable:4786)

#include "stdafx.h"
#include "Topic.h"
#include "propnames.h"
#include "event.h"
#include "CharConv.h"
#include "SafeTime.h"

#ifdef LOCAL_TROUBLESHOOTER
#include "CHMFileReader.h"
#include "apgtstscread.h"
#endif
#include "apgts.h"	// Need for Local-Online macros.

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CTopic::CTopic( LPCTSTR pathDSC
			   ,LPCTSTR pathHTI
			   ,LPCTSTR pathBES
			   ,LPCTSTR pathTSC ) : 
	CBeliefNetwork(pathDSC),
	m_pHTI(NULL),
	m_pBES(NULL),
	m_pathHTI(pathHTI),
	m_pathBES(pathBES),
	m_pathTSC(pathTSC),
	m_bTopicIsValid(true),
	m_bTopicIsRead(false)
{
}

CTopic::~CTopic()
{
	if (m_pHTI)
		delete m_pHTI;
	if (m_pBES)
		delete m_pBES;
}

bool CTopic::IsRead()
{
	bool ret = false;
	LOCKOBJECT();
	ret = m_bTopicIsRead;
	UNLOCKOBJECT();
	return ret;
}

bool CTopic::Read()
{
	LOCKOBJECT();
	m_bTopicIsValid = false;
	try
	{
		if (CBeliefNetwork::Read())
		{
			if (m_pHTI)
				delete m_pHTI;

			if (RUNNING_LOCAL_TS())
				m_pHTI = new CAPGTSHTIReader( CPhysicalFileReader::makeReader( m_pathHTI ), GetMultilineNetProp(H_NET_HTI_LOCAL, _T("%s\r\n")) );
			else
				m_pHTI = new CAPGTSHTIReader( new CNormalFileReader( m_pathHTI ), GetMultilineNetProp(H_NET_HTI_ONLINE, _T("%s\r\n")) );

			if (m_pHTI->Read())
			{
#ifdef LOCAL_TROUBLESHOOTER
				// it can fail reading TCS file - we don't care
				CAPGTSTSCReader( CPhysicalFileReader::makeReader( m_pathTSC ), &m_Cache ).Read();
#endif

				// at this point, we're OK, because BES is optional
				m_bTopicIsValid = true;
				
				if (m_pBES)
				{
					delete m_pBES;
					m_pBES= NULL;
				}

				CString strBESfromNet= GetMultilineNetProp( H_NET_BES, _T("%s\r\n") );
				if ((!m_pathBES.IsEmpty()) || (!strBESfromNet.IsEmpty()))
				{
					// Only allocate a BESReader for a valid filename.
					m_pBES = new CAPGTSBESReader(new CNormalFileReader(m_pathBES), strBESfromNet );
					m_pBES->Read();
				}
			}
		}
	}
	catch (bad_alloc&)
	{
		// Note memory failure in event log.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								_T(""), _T(""), EV_GTS_CANT_ALLOC ); 
	}
	m_bTopicIsRead = true;
	UNLOCKOBJECT();

	return m_bTopicIsValid;
}

// should only be called in a context where we know we have a valid topic.
// Needn't lock, because m_pBES won't change once topic is read.
bool CTopic::HasBES()
{
	return (m_pBES ? true : false);
}


// Should only be called in a context where we know we have a valid topic.
// Does not need to lock, because:
//	- CAPGTSBESReader provides its own locking
//	- m_pBES won't change once topic is read.
void CTopic::GenerateBES(
		const vector<CString> & arrstrIn,
		CString & strEncoded,
		CString & strRaw)
{
	if (m_pBES)
		m_pBES->GenerateBES(arrstrIn, strEncoded, strRaw);
}

// Should only be called in a context where we know we have a valid topic.
// Does not need to lock, because:
//	- CAPGTSHTIReader provides its own locking
//	- m_pHTI won't change once topic is read.
void CTopic::CreatePage(	const CHTMLFragments& fragments, 
							CString& out, 
							const map<CString,CString> & mapStrs,
							CString strHTTPcookies/*= _T("")*/ )
{
	if (m_pHTI)
	{
// You can compile with the SHOWPROGRESS option to get a report on the progress of this page.
#ifdef SHOWPROGRESS
		time_t timeStart = 0;
		time_t timeEnd = 0;
		time(&timeStart);
#endif // SHOWPROGRESS
		m_pHTI->CreatePage(fragments, out, mapStrs, strHTTPcookies );
#ifdef SHOWPROGRESS
		time(&timeEnd);

		CString strProgress;
		CSafeTime safetimeStart(timeStart);
		CSafeTime safetimeEnd(timeEnd);
		
		strProgress = _T("\n<BR>-----------------------------");
		strProgress += _T("\n<BR>Start CTopic::CreatePage ");
		strProgress += safetimeStart.StrLocalTime();
		strProgress += _T("\n<BR>End CTopic::CreatePage ");
		strProgress += safetimeEnd.StrLocalTime();

		int i = out.Find(_T("<BODY"));
		i = out.Find(_T('>'), i);		// end of BODY tag
		if (i>=0)
		{
			out = out.Left(i+1) 
					 + strProgress 
					 + out.Mid(i+1);
		}
#endif // SHOWPROGRESS
	}
}

// JSM V3.2
// Should only be called in a context where we know we have a valid topic.
// Does not need to lock, because:
//	- CAPGTSHTIReader provides its own locking
//	- m_pHTI won't change once topic is read.
void CTopic::ExtractNetProps(vector <CString> &arr_props)
{
	if (m_pHTI)
		m_pHTI->ExtractNetProps(arr_props);

}


// Should only be called in a context where we know we have a valid topic.
// Does not need to lock, because:
//	- CAPGTSHTIReader provides its own locking
//	- m_pHTI won't change once topic is read.
bool CTopic::HasHistoryTable()
{
	bool ret = false;
	if (m_pHTI)
		ret = m_pHTI->HasHistoryTable();
	return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\tshoot.cpp ===
//
// MODULE: TSHOOT.cpp
//
// PURPOSE: Implementation of DLL Exports
//
// PROJECT: Troubleshooter 99
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 12.23.98
//
// NOTES: 
//	Proxy/Stub Information
//	To build a separate proxy/stub DLL, 
//	run nmake -f TSHOOTps.mk in the project directory.
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		12/23/98	OK	    

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "TSHOOT.h"

#include "TSHOOT_i.c"
#include "TSHOOTCtrl.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_TSHOOTCtrl, CTSHOOTCtrl)
END_OBJECT_MAP()

HANDLE ghModule = INVALID_HANDLE_VALUE;
//
//
/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (INVALID_HANDLE_VALUE == ghModule)
		ghModule = hInstance;

    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_TSHOOTLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\threadpool.cpp ===
//
// MODULE: ThreadPool.CPP
//
// PURPOSE: Fully implement classes for high level of pool thread activity
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel, based on earlier (8-2-96) work by Roman Mach
// 
// ORIGINAL DATE: 9/23/98
//
// NOTES: 
// 1. 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V3.0		9/23/98		JM		better encapsulation & some chages to algorithm
//

#pragma warning(disable:4786)

#include "stdafx.h"
#include "ThreadPool.h"
#include "event.h"
#include "apgtscls.h"
#include "baseexception.h"
#include "CharConv.h"
#include "apgtsMFC.h"


//////////////////////////////////////////////////////////////////////
// CThreadPool::CThreadControl
// POOL/WORKING THREAD
//////////////////////////////////////////////////////////////////////
CThreadPool::CThreadControl::CThreadControl(CSniffConnector* pSniffConnector) :
	m_hThread (NULL),
	m_hevDone (NULL),
	m_hMutex (NULL),
	m_bExit (false),
	m_pPoolQueue (NULL),
	m_timeCreated(0),
	m_time (0),
	m_bWorking (false),
	m_bFailed (false),
	m_strBrowser( _T("") ),
	m_strClientIP( _T("") ),
	m_pContext( NULL ),
	m_pSniffConnector(pSniffConnector)
{
	time(&m_timeCreated);
}

CThreadPool::CThreadControl::~CThreadControl()
{
	if (m_hThread)
		::CloseHandle(m_hThread);
	if (m_hevDone)  
		::CloseHandle(m_hevDone);
	if (m_hMutex)  
		::CloseHandle(m_hMutex);
}

// create a "pool" thread to handle user requests, one request at a time per thread
// returns error code; 0 if OK
// NOTE:	This function throws exceptions so the caller should be catching exceptions
//			rather than checking return values.
DWORD CThreadPool::CThreadControl::Initialize(CPoolQueue * pPoolQueue)
{
	DWORD dwThreadID;

	CString strErr;
	CString strErrNum;

	m_pPoolQueue = pPoolQueue;

	m_hevDone= NULL;
	m_hMutex= NULL;
	m_hThread= NULL;
	try
	{
		m_hevDone = ::CreateEvent(NULL, true /* manual reset*/, false /* init non-signaled*/, NULL);
		if (!m_hevDone) 
		{
			strErrNum.Format(_T("%d"), ::GetLastError());
			strErr = _T( "Failure creating hevDone(GetLastError=" );
			strErr += strErrNum; 
			strErr += _T( ")" );

			throw CGeneralException(	__FILE__, __LINE__, 
										strErr , 
										EV_GTS_ERROR_THREAD );
		}

		m_hMutex = ::CreateMutex(NULL, false, NULL);
		if (!m_hMutex) 
		{
			strErrNum.Format(_T("%d"), ::GetLastError());
			strErr = _T( "Failure creating hMutex (GetLastError=" );
			strErr += strErrNum; 
			strErr += _T( ")" );

			throw CGeneralException(	__FILE__, __LINE__, 
										strErr , 
										EV_GTS_ERROR_THREAD );
		}

		// create the thread 
		// Note although the destructor has a corresponding ::CloseHandle(m_hThread),
		//	it's probably not needed.  However, it should be harmless: we don't tear down
		//	this object until after the thread has exited.
		// That is because the thread goes out of existence on the implicit 
		//	::ExitThread() when PoolTask returns.  See documentation of
		//	::CreateThread for further details JM 10/22/98
		m_hThread = ::CreateThread( NULL, 
									0, 
									(LPTHREAD_START_ROUTINE)PoolTask, 
									this, 
									0, 
									&dwThreadID);

		if (!m_hThread) 
		{
			strErrNum.Format(_T("%d"), ::GetLastError());
			strErr = _T( "Failure creating hThread (GetLastError=" );
			strErr += strErrNum; 
			strErr += _T( ")" );

			throw CGeneralException(	__FILE__, __LINE__, 
										strErr , 
										EV_GTS_ERROR_THREAD );
		}
	}
	catch (CGeneralException&)
	{
		// Clean up any open handles.
		if (m_hevDone)
		{
			::CloseHandle(m_hevDone);
			m_hevDone = NULL;
		}

		if (m_hMutex)
		{
			::CloseHandle(m_hMutex);
			m_hMutex = NULL;
		}

		// Rethrow the exception.
		throw;
	}

	return 0;
}

void CThreadPool::CThreadControl::Lock()
{
	::WaitForSingleObject(m_hMutex, INFINITE);
}

void CThreadPool::CThreadControl::Unlock()
{
	::ReleaseMutex(m_hMutex);
}

time_t CThreadPool::CThreadControl::GetTimeCreated() const
{
	return m_timeCreated;
}

// OUTPUT status
void CThreadPool::CThreadControl::WorkingStatus(CPoolThreadStatus & status)
{
	Lock();
	status.m_timeCreated = m_timeCreated;
	time_t timeNow;
	status.m_bWorking = m_bWorking;
	status.m_bFailed = m_bFailed;
	time(&timeNow);
	status.m_seconds = timeNow - (m_time ? m_time : m_timeCreated);
	if (m_pContext)
		status.m_strTopic = m_pContext->RetCurrentTopic();
	status.m_strBrowser= m_strBrowser.Get();
	status.m_strClientIP= m_strClientIP.Get();
	Unlock();
}

// This should only be called as a result of an operator request to kill the thread.
// This is not the normal way to stop a thread.
// INPUT milliseconds - how long to wait for normal exit before a TerminateThread
// NOTE: Because this Kill function gets a lock, it is very important that no function
//	ever hold this lock more than briefly.
void CThreadPool::CThreadControl::Kill(DWORD milliseconds)
{
	Lock();
	m_bExit = true;
	Unlock();
	WaitForThreadToFinish(milliseconds);
}

// After a pool task thread has been signaled to finish, this is how main thread waits for it
// to finish.
// returns true if terminates OK.
bool CThreadPool::CThreadControl::WaitForThreadToFinish(DWORD milliseconds)
{
	bool bTermOK = true;
	if (m_hevDone != NULL) 
	{
		DWORD dwStatus = ::WaitForSingleObject(m_hevDone, milliseconds);

		// terminate thread as last resort if it didn't exit properly
		// this may cause memory leak, but shouldn't normally happen
		// then close thread handle
		if (dwStatus != WAIT_OBJECT_0) 
		{
			// We ignore the return of ::TerminateThread(). If we got here at all, there
			//	was a problem witht th thread terminating.  We don't care about distinguishing
			//	how severe a problem.
			::TerminateThread(m_hThread,0);
			bTermOK = false;
		}
	}
	return bTermOK;
}

// To be called on PoolTask thread
// Return true if this initiates shutdown, false otherwise.
// This is what handles healthy HTTP requests (many errors already filtered out before we
//		get here.)
bool CThreadPool::CThreadControl::ProcessRequest()
{
	WORK_QUEUE_ITEM * pwqi;
	bool bShutdown = false;
    
    pwqi = m_pPoolQueue->GetWorkItem();
    
    if ( !pwqi )
	{
		// no task.  We shouldn't have been awakened.
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								_T(""),
								_T(""),
								EV_GTS_ERROR_NO_QUEUE_ITEM ); 
	}

	if (pwqi->pECB != NULL) 
	{

		// a normal user request

		// set privileges, etc. to those of a particular user
		if (pwqi->hImpersonationToken)
			::ImpersonateLoggedOnUser( pwqi->hImpersonationToken );


		try
		{
			CString strBrowser;
			CString strClientIP;

			// Acquire the browser and IP address for status pages.
			APGTS_nmspace::GetServerVariable( pwqi->pECB, "HTTP_USER_AGENT", strBrowser );
			APGTS_nmspace::GetServerVariable( pwqi->pECB, "REMOTE_ADDR", strClientIP );
			m_strBrowser.Set( strBrowser );
			m_strClientIP.Set( strClientIP );
		
			m_pContext = new APGTSContext(	pwqi->pECB, 
											pwqi->pConf,
											pwqi->pLog,
											&pwqi->GTSStat,
											m_pSniffConnector);

			m_pContext->ProcessQuery();
			
			// Release the context and set the point to null.
			Lock();
			delete m_pContext;
			m_pContext= NULL;
			Unlock();

			// Clear the browser and IP address as this request is over.
			m_strBrowser.Set( _T("") );
			m_strClientIP.Set( _T("") );
		}
		catch (bad_alloc&)
		{
			// A memory allocation failure occurred during processing of query, log it.
			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									_T(""),	_T(""), EV_GTS_CANT_ALLOC ); 
		}
		catch (...)
		{
			// Catch any other exception thrown.
			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									_T(""), _T(""), 
									EV_GTS_GEN_EXCEPTION );		
		}

		::RevertToSelf();
	
		//	Terminate HTTP request
		pwqi->pECB->ServerSupportFunction(	HSE_REQ_DONE_WITH_SESSION,
											NULL,
											NULL,
											NULL );

		::CloseHandle( pwqi->hImpersonationToken );
	}

	
	if (pwqi->pECB) 
		delete pwqi->pECB;
	else
		// exit thread if null (we're shutting down)
		bShutdown = true;
		
    delete pwqi;
	
	return bShutdown;
}

// To be called on PoolTask thread
bool CThreadPool::CThreadControl::Exit()
{
	Lock();
	bool bExit = m_bExit;
	Unlock();
	return bExit;
}


// To be called on PoolTask thread
//  Main loop of a worker thread.
void CThreadPool::CThreadControl::PoolTaskLoop()
{
    DWORD	res;
	bool	bBad = false;

    while ( !Exit() )
    {
        res = m_pPoolQueue->WaitForWork();

        if ( res == WAIT_OBJECT_0 ) 
		{
			bBad = false;

			Lock();
			m_bWorking = true;
			time(&m_time);
			Unlock();

			bool bExit = ProcessRequest();
			Lock();
			m_bExit = bExit;
			Unlock();
			m_pPoolQueue->DecrementWorkItems();

			Lock();
			m_bWorking = false;
			time(&m_time);
			Unlock();
		}
		else 
		{
			// utterly unexpected event, like a WAIT_FAILED.
			// There's no obvious way to recover from this sort of thing.  Fortunately,
			//	we've never seen it happen.  Obviously we want to log to the event log.
			// Our variable bBad is a way of deciding that if this happens twice
			//	in a row, this thread will just exit and give up totally.  , 
			// If we ever see this in a real live system, it's
			//	time to give this issue some thought.
			CString str;

			str.Format(_T("%d/%d"), res, GetLastError());
			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									str,
									_T(""),
									EV_GTS_ERROR_UNEXPECTED_WT ); 

			if (bBad)
			{
				m_bFailed = true;
				break;		// out of while loop & implicitly out of thread.
			}
			else
				bBad = true;
		}
	}

	// signal shutdown code that we are finished
	::SetEvent(m_hevDone);
}

//  Main routine of a worker thread.
//	INPUT lpParams
//	Always returns 0.
/* static */ UINT WINAPI CThreadPool::CThreadControl::PoolTask( LPVOID lpParams )
{
	CThreadControl	* pThreadControl;

#ifdef LOCAL_TROUBLESHOOTER
	if (RUNNING_FREE_THREADED())
		::CoInitializeEx(NULL, COINIT_MULTITHREADED);
	if (RUNNING_APARTMENT_THREADED())
		::CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
#endif
	
	pThreadControl = (CThreadControl *)lpParams;

	pThreadControl->PoolTaskLoop();

#ifdef LOCAL_TROUBLESHOOTER
	if (RUNNING_FREE_THREADED() || RUNNING_APARTMENT_THREADED())
		::CoUninitialize();
#endif
	return 0;
}

//////////////////////////////////////////////////////////////////////
// CThreadPool
//////////////////////////////////////////////////////////////////////

CThreadPool::CThreadPool(CPoolQueue * pPoolQueue, CSniffConnector* pSniffConnector) :
	m_dwErr(0),
	m_ppThreadCtl(NULL),
	m_dwWorkingThreadCount(0),
	m_pPoolQueue(pPoolQueue),
	m_pSniffConnector(pSniffConnector)
{
}

CThreadPool::~CThreadPool()
{
	DestroyThreads();

	if (m_ppThreadCtl) 
	{
		for ( DWORD i = 0; i < m_dwWorkingThreadCount; i++ ) 
			if (m_ppThreadCtl[i])
				delete m_ppThreadCtl[i];

		delete [] m_ppThreadCtl;
	}
}

// get any error during construction
DWORD CThreadPool::GetStatus() const
{
	return m_dwErr;
}

DWORD CThreadPool::GetWorkingThreadCount() const
{
	return m_dwWorkingThreadCount;
}

//
// Call only from destructor
void CThreadPool::DestroyThreads()
{
	int BadTerm = 0;
	bool bFirst = true;
	DWORD i;

	// APGTSExtension should have already signaled the threads to quit.
	//	>>>(ignore for V3.0) Doing that in APGTSExtension is lousy encapsulation, but 
	//	so far we don't see a clean way to do this.
	// Wait for them all to terminate unless we had a problem.
	// Because this is called from the dll's process detach, we can't
	// signal on thread termination, just when threads have exited their
	// infinite while loops

	if (m_dwWorkingThreadCount && m_ppThreadCtl) 
	{
		// We will wait longer for the first thread: 10 seconds for processing to finish.
		// After that, we clip right along, since this has also been time for all the
		//	other threads to finish.
		for ( i = 0; i < m_dwWorkingThreadCount; i++ )
		{
			if ( m_ppThreadCtl[i] )
			{
				if ( ! m_ppThreadCtl[i]->WaitForThreadToFinish((bFirst) ? 20000 : 100) )
					++BadTerm;

				bFirst = false;
			}
		}

		if (BadTerm != 0) 
		{
			CString str;
			str.Format(_T("%d"), BadTerm);
			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									str,
									_T(""),
									EV_GTS_USER_THRD_KILL ); 
		}
	}
}

// create the "pool" threads which handle user requests, one request at a time per thread
// if there are less than dwDesiredThreadCount existing threads, expand the thread pool
//	to that size.
// (We cannot shrink the thread pool while we are running).
void CThreadPool::ExpandPool(DWORD dwDesiredThreadCount)
{
	CString strErr;

	if (dwDesiredThreadCount > m_dwWorkingThreadCount)
	{
		CThreadControl **ppThreadCtl = NULL;
		const DWORD dwOldCount = m_dwWorkingThreadCount;
		bool	bExceptionThrown = false;		// Flag used in cleanup.

		// Attempt to allocate additional threads.
		try
		{
			// Allocate new thread block.
			ppThreadCtl = new CThreadControl* [dwDesiredThreadCount];
			//[BC-03022001] - added check for NULL ptr to satisfy MS code analysis tool.
			if(!ppThreadCtl)
			{
				throw bad_alloc();
			}

			DWORD i;
			// Initialize before adding threads
			for (i = 0; i < dwDesiredThreadCount; i++)
				ppThreadCtl[i] = NULL;

			// Transfer any existing threads.
			for (i = 0; i < dwOldCount; i++)
				ppThreadCtl[i] = m_ppThreadCtl[i];

			// Allocate additional threads.
			for (i = dwOldCount; i < dwDesiredThreadCount; i++)
			{
				ppThreadCtl[i] = new CThreadControl(m_pSniffConnector);
				//[BC-03022001] - added check for NULL ptr to satisfy MS code analysis tool.
				if(!ppThreadCtl[i])
				{
					throw bad_alloc();
				}

				// This function may throw exceptions of type CGeneralException.
				m_dwErr = ppThreadCtl[i]->Initialize(m_pPoolQueue);

				m_dwWorkingThreadCount++;
			}
		}
		catch (CGeneralException& x)
		{
			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	x.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									x.GetErrorMsg(), _T("General exception"), 
									x.GetErrorCode() ); 
			bExceptionThrown= true;
		}
		catch (bad_alloc&)
		{	
			// Note memory failure in event log.
			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									_T(""), _T(""), EV_GTS_CANT_ALLOC ); 
			bExceptionThrown= true;
		}

		if ((bExceptionThrown) && (dwOldCount))
		{
			// Restore previous settings.
			// Clean up any allocated memory and reset the working thread count.
			for (DWORD i = dwOldCount; i < dwDesiredThreadCount; i++)
			{
				if (ppThreadCtl[i])
					delete ppThreadCtl[i];
			}
			if (ppThreadCtl)
				delete [] ppThreadCtl;
			m_dwWorkingThreadCount= dwOldCount;
		}
		else if (ppThreadCtl)
		{
			// Move thread block to member variable.
			CThreadControl **pp = m_ppThreadCtl;
			m_ppThreadCtl = ppThreadCtl;

			// Release any previous thread block.
			if (pp)
				delete[] pp;
		}
		else
		{
			// this is a very unlikely situation, but it would mean we have no pool
			//	threads.  We don't want to terminate the program (it's possible that 
			//	we want to run in support of status queries). 
			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									_T(""), _T(""), EV_GTS_ERROR_NOPOOLTHREADS ); 
		}
	}
}

// input i is thread index.
bool CThreadPool::ReinitializeThread(DWORD i)
{
	if (i <m_dwWorkingThreadCount && m_ppThreadCtl && m_ppThreadCtl[i])
	{
		m_ppThreadCtl[i]->Kill(2000L); // 2 seconds to exit normally

		try
		{
			delete m_ppThreadCtl[i];
			m_ppThreadCtl[i] = new CThreadControl(m_pSniffConnector);

			// This function may throw exceptions of type CGeneralException.
			m_dwErr = m_ppThreadCtl[i]->Initialize(m_pPoolQueue);
		}
		catch (CGeneralException& x)
		{
			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	x.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									x.GetErrorMsg(), _T("General exception"), 
									x.GetErrorCode() ); 

			// Initialization has failed, delete the newly allocated thread.  
			if (m_ppThreadCtl[i])
				delete m_ppThreadCtl[i];
		}
		catch (bad_alloc&)
		{
			// A memory allocation failure occurred during processing of query, log it.
			CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
			CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
									SrcLoc.GetSrcFileLineStr(), 
									_T(""), _T(""), EV_GTS_CANT_ALLOC ); 

			// Set the thread to a known state.
			m_ppThreadCtl[i]= NULL;
		}
		return true;
	}
	else
		return false;
}

// Reinitialize any threads that have been "working" more than 10 seconds on a single request
void CThreadPool::ReinitializeStuckThreads()
{	
	if (!m_ppThreadCtl) 
		return;

	for (DWORD i=0; i<m_dwWorkingThreadCount;i++)
	{
		if (m_ppThreadCtl[i])
		{
			CPoolThreadStatus status;
			m_ppThreadCtl[i]->WorkingStatus(status);
			if ( status.m_bFailed || (status.m_bWorking && status.m_seconds > 10) )
				ReinitializeThread(i);
		}
	}
}

// input i is thread index.
bool CThreadPool::ThreadStatus(DWORD i, CPoolThreadStatus &status)
{
	if (i <m_dwWorkingThreadCount && m_ppThreadCtl && m_ppThreadCtl[i])
	{
		m_ppThreadCtl[i]->WorkingStatus(status);
		return true;
	}
	else
		return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\tshoot\topicshop.cpp ===
//
// MODULE: TOPICSHOP.CPP
//
// PURPOSE: Provide a means of "publishing" troubleshooter topics.  This is where a 
//	working thread goes to obtain a CTopic to use.
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 9-10-98
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V3.0		09-10-98	JM
//

#pragma warning(disable:4786)

#include "stdafx.h"
#include <algorithm>
#include "TopicShop.h"
#include "event.h"
#include "apiwraps.h"
#include "CharConv.h"
#include "bn.h"
#include "propnames.h"

#ifdef LOCAL_TROUBLESHOOTER
#include "CHMFileReader.h"
#endif

//////////////////////////////////////////////////////////////////////
// CTopicInCatalog
//////////////////////////////////////////////////////////////////////

CTopicInCatalog::CTopicInCatalog(const CTopicInfo & topicinfo) :
	m_topicinfo(topicinfo),
	m_bTopicInfoMayNotBeCurrent(false),
	m_bInited(false),
	m_countLoad(CCounterLocation::eIdTopicLoad, topicinfo.GetNetworkName()),
	m_countLoadOK(CCounterLocation::eIdTopicLoadOK, topicinfo.GetNetworkName()),
	m_countEvent(CCounterLocation::eIdTopicEvent, topicinfo.GetNetworkName()),
	m_countHit(CCounterLocation::eIdTopicHit, topicinfo.GetNetworkName()),
	m_countHitNewCookie(CCounterLocation::eIdTopicHitNewCookie, topicinfo.GetNetworkName()),
	m_countHitOldCookie(CCounterLocation::eIdTopicHitOldCookie, topicinfo.GetNetworkName())
{ 

	::InitializeCriticalSection( &m_csTopicinfo);
	m_hev = ::CreateEvent( 
		NULL, 
		TRUE,  // any number of (working) threads may be released on signal
		FALSE, // initially non-signalled
		NULL);
	if (! m_hev)
	{
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								_T(""),
								_T(""),
								EV_GTS_ERROR_EVENT );

		// Simulate a bad alloc exception in this case.
		// This exception will be caught by the caller if the new call has been
		// properly wrapped in a try...catch() block.  Only known caller is 
		// CTopicShop::AddTopic() which handles this properly.
		throw bad_alloc();
	}

	m_countEvent.Increment();
}

CTopicInCatalog::~CTopicInCatalog()
{ 
	if (m_hev)
		::CloseHandle(m_hev);
	::DeleteCriticalSection( &m_csTopicinfo);
}

CTopicInfo CTopicInCatalog::GetTopicInfo() const
{
	
	::EnterCriticalSection(&m_csTopicinfo);
	CTopicInfo ret(m_topicinfo);
	::LeaveCriticalSection(&m_csTopicinfo);
	return ret;
}

void CTopicInCatalog::SetTopicInfo(const CTopicInfo &topicinfo)
{
	::EnterCriticalSection(&m_csTopicinfo);
	m_topicinfo = topicinfo;
	m_bTopicInfoMayNotBeCurrent = true;
	::LeaveCriticalSection(&m_csTopicinfo);
}


// Just let this object know to increment the hit count
void CTopicInCatalog::CountHit(bool bNewCookie)
{
	m_countHit.Increment();
	if (bNewCookie)
		m_countHitNewCookie.Increment();
	else
		m_countHitOldCookie.Increment();
}

// Obtain a CP_TOPIC as a pointer to the topic, if that topic is already built. 
// As long as a CP_TOPIC remains undeleted, the associated CTopic is guaranteed to 
//	remain undeleted.
// Warning: this function will return with a null topic if topic is not yet built.
//	Must test for null with CP_TOPIC::IsNull().  Can't test a smart pointer for null
//	with ==.
CP_TOPIC & CTopicInCatalog::GetTopicNoWait(CP_TOPIC &cpTopic) const
{
	cpTopic = m_cpTopic;
	return cpTopic;
}

// Obtain a CP_TOPIC as a pointer to the topic.  
// Wait as necessary for that topic to be built. 
// Warning: this function will return with a null topic if topic cannot be built.
// As long as a CP_TOPIC remains undeleted, the associated CTopic is guaranteed to 
//	remain undeleted.
// Warning: this function may have to wait for TopicInCatalog.m_cpTopic to be built.
CP_TOPIC & CTopicInCatalog::GetTopic(CP_TOPIC &cpTopic) const
{
	if (!m_bInited)
	{
		// Wait for a set period, if failure then log error msg and wait infinite.
		WAIT_INFINITE( m_hev ); 
	}
	return GetTopicNoWait(cpTopic);
}

// to be called by the TopicBuilderTask thread
void CTopicInCatalog::Init(const CTopic* pTopic)
{
	m_countLoad.Increment();
	if(pTopic)
	{
		m_cpTopic = pTopic;
		m_countLoadOK.Increment();
	}
	if(pTopic || m_cpTopic.IsNull())
		m_bInited = true;

	::SetEvent(m_hev);
}

// Just let this object know to increment the count of changes detected.
void CTopicInCatalog::CountChange()
{
	m_countEvent.Increment();
}

CTopicInCatalog::TopicStatus CTopicInCatalog::GetTopicStatus() const
{
	if (!m_bInited)
		return eNotInited;
	else if(m_cpTopic.IsNull())
		return eFail;
	else
		return eOK;
}

bool CTopicInCatalog::GetTopicInfoMayNotBeCurrent() const
{
	::EnterCriticalSection(&m_csTopicinfo);
	bool bRet= m_bTopicInfoMayNotBeCurrent;
	::LeaveCriticalSection(&m_csTopicinfo);
	return bRet;
}

void CTopicInCatalog::TopicInfoIsCurrent()
{
	::EnterCriticalSection(&m_csTopicinfo);
	m_bTopicInfoMayNotBeCurrent = false;
	::LeaveCriticalSection(&m_csTopicinfo);
}


//////////////////////////////////////////////////////////////////////
// CTemplateInCatalog
//////////////////////////////////////////////////////////////////////

CTemplateInCatalog::CTemplateInCatalog( const CString & strTemplate ) :
	m_strTemplate( strTemplate ),
	m_countLoad(CCounterLocation::eIdTopicLoad, strTemplate),
	m_countLoadOK(CCounterLocation::eIdTopicLoadOK, strTemplate),
	m_countEvent(CCounterLocation::eIdTopicEvent, strTemplate),
	m_countHit(CCounterLocation::eIdTopicHit, strTemplate),
	m_bInited( false )
{ 
	m_hev = ::CreateEvent( 
		NULL, 
		TRUE,  // any number of (working) threads may be released on signal
		FALSE, // initially non-signalled
		NULL);
	if (! m_hev)
	{
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								_T(""),
								_T(""),
								EV_GTS_ERROR_EVENT );

		// Simulate a bad alloc exception in this case.
		// This exception will be caught by the caller if the new call has been
		// properly wrapped in a try...catch() block.  
		throw bad_alloc();
	}

	m_countEvent.Increment();
}

CTemplateInCatalog::~CTemplateInCatalog()
{ 
	if (m_hev)
		::CloseHandle(m_hev);
}

const CString & CTemplateInCatalog::GetTemplateInfo() const
{
	return m_strTemplate;
}

// Just let this object know to increment the hit count
void CTemplateInCatalog::CountHit( bool bNewCookie )
{
	m_countHit.Increment();
}

// Obtain a CP_TEMPLATE as a pointer to the template, if that template is already built. 
// As long as a CP_TEMPLATE remains undeleted, the associated CAPGTSHTIReader is guaranteed to 
//	remain undeleted.
// Warning: this function will return with a null template if template is not yet built.
//	Must test for null with CP_TEMPLATE::IsNull().  Can't test a smart pointer for null
//	with ==.
CP_TEMPLATE & CTemplateInCatalog::GetTemplateNoWait( CP_TEMPLATE &cpTemplate ) const
{
	cpTemplate= m_cpTemplate;
	return cpTemplate;
}

// Obtain a CP_TEMPLATE as a pointer to the template.  
// Wait as necessary for that template to be built. 
// Warning: this function will return with a null template if template cannot be built.
// As long as a CP_TEMPLATE remains undeleted, the associated CAPGTSHTIReader is guaranteed to 
//	remain undeleted.
// Warning: this function may have to wait for TopicInCatalog.m_cpTemplate to be built.
CP_TEMPLATE & CTemplateInCatalog::GetTemplate( CP_TEMPLATE &cpTemplate ) const
{
	if (!m_bInited)
	{
		// Wait for a set period, if failure then log error msg and wait infinite.
		WAIT_INFINITE( m_hev ); 
	}
	return GetTemplateNoWait( cpTemplate );
}

// to be called by the TopicBuilderTask thread
void CTemplateInCatalog::Init( const CAPGTSHTIReader* pTemplate )
{
	m_countLoad.Increment();
	if (pTemplate)
	{
		m_cpTemplate= pTemplate;
		m_countLoadOK.Increment();
	}
	if (pTemplate || m_cpTemplate.IsNull())
		m_bInited = true;

	::SetEvent(m_hev);
}

// Just let this object know to increment the count of changes detected.
void CTemplateInCatalog::CountChange()
{
	m_countEvent.Increment();
}

// Just let this object know to increment the count of failures detected.
void CTemplateInCatalog::CountFailed()
{
	// The load failed so increment the count of attempted loads.
	m_countLoad.Increment();
}

CTemplateInCatalog::TemplateStatus CTemplateInCatalog::GetTemplateStatus() const
{
	if (!m_bInited)
		return eNotInited;
	else if(m_cpTemplate.IsNull())
		return eFail;
	else
		return eOK;
}

DWORD CTemplateInCatalog::CountOfFailedLoads() const
{
	return( m_countLoad.GetTotal() - m_countLoadOK.GetTotal() );
}


/////////////////////////////////////////////////////////////////////
// CTopicShop::CTopicBuildQueue
// This class does the bulk of its work on a separate thread.
// The thread is created in the constructor by starting static function
//	CTopicShop::CTopicBuildQueue::TopicBuilderTask.
// That function, in turn does its work by calling private members of this class that
//	are specific to use on the TopicBuilderTask thread.
// When this goes out of scope, its own destructor calls ShutDown to stop the thread,
//	waits for the thread to shut.
// The following method is available for other threads communicating with that thread:
//	CTopicShop::CTopicBuildQueue::RequestBuild
//////////////////////////////////////////////////////////////////////
CTopicShop::CTopicBuildQueue::CTopicBuildQueue(	CTopicCatalog & TopicCatalog, 
												CTemplateCatalog & TemplateCatalog) 
:	m_TopicCatalog (TopicCatalog),
	m_TemplateCatalog( TemplateCatalog ),
	m_eCurrentlyBuilding(eUnknown),
	m_bShuttingDown (false),
	m_dwErr(0),
	m_ThreadStatus(eBeforeInit),
	m_time(0)
{
	enum {eHevBuildReq, eHevShut, eThread, eOK} Progress = eHevBuildReq;

	SetThreadStatus(eBeforeInit);

	m_hevBuildRequested = ::CreateEvent( 
		NULL, 
		FALSE, // release one thread (the TopicBuilderTask) on signal
		FALSE, // initially non-signalled
		NULL);

	if (m_hevBuildRequested)
	{
		Progress = eHevShut;
		m_hevThreadIsShut = ::CreateEvent( 
			NULL, 
			FALSE, // release one thread (this one) on signal
			FALSE, // initially non-signalled
			NULL);

		if (m_hevThreadIsShut)
		{
			Progress = eThread;
			DWORD dwThreadID;	// No need to hold onto dwThreadID in member variable.
								// All Win32 functions take the handle m_hThread instead.
								// The one reason you'd ever want to know this ID is for 
								//	debugging

			// Note that there is no corresponding ::CloseHandle(m_hThread).
			// That is because the thread goes out of existence on the implicit 
			//	::ExitThread() when TopicBuilderTask returns.  See documentation of
			//	::CreateThread for further details JM 10/22/98
			m_hThread = ::CreateThread( NULL, 
										0, 
										(LPTHREAD_START_ROUTINE)TopicBuilderTask, 
										this, 
										0, 
										&dwThreadID);

			if (m_hThread)
				Progress = eOK;
		}
	}

	if (Progress != eOK)
	{
		m_dwErr = GetLastError();
		CString str;
		str.Format(_T("%d"), m_dwErr);
		CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
		CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
								SrcLoc.GetSrcFileLineStr(), 
								(Progress == eHevBuildReq) ?_T("Can't create \"request build\" event")
								: (Progress == eHevShut) ?	_T("Can't create \"shut\" event")
								:							_T("Can't create thread"),
								str, 
								EV_GTS_ERROR_TOPICBUILDERTHREAD );
		SetThreadStatus(eFail);

		if (m_hevBuildRequested)
			::CloseHandle(m_hevBuildRequested);

		if (m_hevThreadIsShut)
			::CloseHandle(m_hevThreadIsShut);
	}
}

CTopicShop::CTopicBuildQueue::~CTopicBuildQueue()
{
	ShutDown();

	if (m_hevBuildRequested)
		::CloseHandle(m_hevBuildRequested);

	if (m_hevThreadIsShut)
		::CloseHandle(m_hevThreadIsShut);
}

void CTopicShop::CTopicBuildQueue::SetThreadStatus(ThreadStatus ts)
{
	LOCKOBJECT();
	m_ThreadStatus = ts;
	time(&m_time);
	UNLOCKOBJECT();
}

DWORD CTopicShop::CTopicBuildQueue::GetStatus(ThreadStatus &ts, DWORD & seconds) const
{
	time_t timeNow;
	LOCKOBJECT();
	ts = m_ThreadStatus;
	time(&timeNow);
	seconds = timeNow - m_time;
	UNLOCKOBJECT();
	return m_dwErr;
}

// report status of topics in m_TopicCatalog
// OUTPUT Total: number of topics
// OUTPUT NoInit: number of uninitialized topics (never built)
// OUTPUT Fail: number of topics we tried to build, but could never build
// INPUT parrstrFail NULL == don't care to get this output
// OUTPUT *parrstrFail: names of the topics that couldn't be built
void CTopicShop::CTopicBuildQueue::GetTopicsStatus(
	DWORD &Total, DWORD &NoInit, DWORD &Fail, vector<CString>*parrstrFail) const
{
	LOCKOBJECT();
	Total = m_TopicCatalog.size();
	NoInit = 0;
	Fail = 0;
	if (parrstrFail)
		parrstrFail->clear();
	for (CTopicCatalog::const_iterator it = m_TopicCatalog.begin(); it != m_TopicCatalog.end(); ++it)
	{
		CTopicInCatalog::TopicStatus status = it->second->GetTopicStatus();
		switch (status)
		{
			case CTopicInCatalog::eNotInited:
				++NoInit;
				break;
			case CTopicInCatalog::eFail:
				++Fail;
				if (parrstrFail)
				{
					try
					{
						parrstrFail->push_back(it->second->GetTopicInfo().GetNetworkName());
					}
					catch (exception& x)
					{
						CString str;
						// Note STL exception in event log.
						CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
						CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
												SrcLoc.GetSrcFileLineStr(), 
												CCharConversion::ConvertACharToString(x.what(), str), 
												_T(""), 
												EV_GTS_STL_EXCEPTION ); 
					}
				}
				break;
			default:
				break;
		}

	}
	UNLOCKOBJECT();
}

// report status of template in m_TemplateCatalog
// INPUT parrstrFail NULL == don't care to get this output
// OUTPUT *parrstrFail: names of the topics that couldn't be built
// INPUT parrcntFail NULL == don't care to get this output
// OUTPUT *parrcntFail: count of failures of the topics that couldn't be built.
//						one to one correspondence with parrstrFail.
void CTopicShop::CTopicBuildQueue::GetTemplatesStatus(
	vector<CString>*parrstrFail, vector<DWORD>*parrcntFail ) const
{
	LOCKOBJECT();
	if (parrstrFail)
		parrstrFail->clear();
	if (parrcntFail)
		parrcntFail->clear();

	for (CTemplateCatalog::const_iterator it = m_TemplateCatalog.begin(); it != m_TemplateCatalog.end(); ++it)
	{
		if (it->second->GetTemplateStatus() == CTemplateInCatalog::eFail)
		{
			if (parrstrFail)
			{
				// Currently we only care about failures and their related count.
				try
				{
					parrstrFail->push_back(it->second->GetTemplateInfo());
					if (parrcntFail)
						parrcntFail->push_back( it->second->CountOfFailedLoads() );
				}
				catch (exception& x)
				{
					CString str;
					// Note STL exception in event log.
					CBuildSrcFileLinenoStr SrcLoc( __FILE__, __LINE__ );
					CEvent::ReportWFEvent(	SrcLoc.GetSrcFileLineStr(), 
											SrcLoc.GetSrcFileLineStr(