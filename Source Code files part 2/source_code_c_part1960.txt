  return ((string)(curObj["Realm"]));
            }
            set {
                curObj["Realm"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsRelayForAuthNull {
            get {
                if ((curObj["RelayForAuth"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int RelayForAuth {
            get {
                if ((curObj["RelayForAuth"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["RelayForAuth"]));
            }
            set {
                curObj["RelayForAuth"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public System.Byte[] RelayIpList {
            get {
                return ((System.Byte[])(curObj["RelayIpList"]));
            }
            set {
                curObj["RelayIpList"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsRemoteRetryAttemptsNull {
            get {
                if ((curObj["RemoteRetryAttempts"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int RemoteRetryAttempts {
            get {
                if ((curObj["RemoteRetryAttempts"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["RemoteRetryAttempts"]));
            }
            set {
                curObj["RemoteRetryAttempts"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsRemoteRetryIntervalNull {
            get {
                if ((curObj["RemoteRetryInterval"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int RemoteRetryInterval {
            get {
                if ((curObj["RemoteRetryInterval"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["RemoteRetryInterval"]));
            }
            set {
                curObj["RemoteRetryInterval"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsRemoteSmtpPortNull {
            get {
                if ((curObj["RemoteSmtpPort"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int RemoteSmtpPort {
            get {
                if ((curObj["RemoteSmtpPort"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["RemoteSmtpPort"]));
            }
            set {
                curObj["RemoteSmtpPort"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsRemoteSmtpSecurePortNull {
            get {
                if ((curObj["RemoteSmtpSecurePort"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int RemoteSmtpSecurePort {
            get {
                if ((curObj["RemoteSmtpSecurePort"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["RemoteSmtpSecurePort"]));
            }
            set {
                curObj["RemoteSmtpSecurePort"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsRemoteTimeoutNull {
            get {
                if ((curObj["RemoteTimeout"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int RemoteTimeout {
            get {
                if ((curObj["RemoteTimeout"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["RemoteTimeout"]));
            }
            set {
                curObj["RemoteTimeout"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsRouteActionNull {
            get {
                if ((curObj["RouteAction"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int RouteAction {
            get {
                if ((curObj["RouteAction"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["RouteAction"]));
            }
            set {
                curObj["RouteAction"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string RoutePassword {
            get {
                return ((string)(curObj["RoutePassword"]));
            }
            set {
                curObj["RoutePassword"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string RouteUserName {
            get {
                return ((string)(curObj["RouteUserName"]));
            }
            set {
                curObj["RouteUserName"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string RoutingDll {
            get {
                return ((string)(curObj["RoutingDll"]));
            }
            set {
                curObj["RoutingDll"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string SaslLogonDomain {
            get {
                return ((string)(curObj["SaslLogonDomain"]));
            }
            set {
                curObj["SaslLogonDomain"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public System.Management.ManagementBaseObject[] SecureBindings {
            get {
                return ((System.Management.ManagementBaseObject[])(curObj["SecureBindings"]));
            }
            set {
                curObj["SecureBindings"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string SendBadTo {
            get {
                return ((string)(curObj["SendBadTo"]));
            }
            set {
                curObj["SendBadTo"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string SendNdrTo {
            get {
                return ((string)(curObj["SendNdrTo"]));
            }
            set {
                curObj["SendNdrTo"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsServerAutoStartNull {
            get {
                if ((curObj["ServerAutoStart"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool ServerAutoStart {
            get {
                if ((curObj["ServerAutoStart"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["ServerAutoStart"]));
            }
            set {
                curObj["ServerAutoStart"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public System.Management.ManagementBaseObject[] ServerBindings {
            get {
                return ((System.Management.ManagementBaseObject[])(curObj["ServerBindings"]));
            }
            set {
                curObj["ServerBindings"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string ServerComment {
            get {
                return ((string)(curObj["ServerComment"]));
            }
            set {
                curObj["ServerComment"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsServerListenBacklogNull {
            get {
                if ((curObj["ServerListenBacklog"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int ServerListenBacklog {
            get {
                if ((curObj["ServerListenBacklog"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["ServerListenBacklog"]));
            }
            set {
                curObj["ServerListenBacklog"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsServerListenTimeoutNull {
            get {
                if ((curObj["ServerListenTimeout"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int ServerListenTimeout {
            get {
                if ((curObj["ServerListenTimeout"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["ServerListenTimeout"]));
            }
            set {
                curObj["ServerListenTimeout"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string SettingID {
            get {
                return ((string)(curObj["SettingID"]));
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsShouldDeliverNull {
            get {
                if ((curObj["ShouldDeliver"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool ShouldDeliver {
            get {
                if ((curObj["ShouldDeliver"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["ShouldDeliver"]));
            }
            set {
                curObj["ShouldDeliver"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsShouldPickupMailNull {
            get {
                if ((curObj["ShouldPickupMail"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool ShouldPickupMail {
            get {
                if ((curObj["ShouldPickupMail"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["ShouldPickupMail"]));
            }
            set {
                curObj["ShouldPickupMail"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsShouldPipelineInNull {
            get {
                if ((curObj["ShouldPipelineIn"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool ShouldPipelineIn {
            get {
                if ((curObj["ShouldPipelineIn"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["ShouldPipelineIn"]));
            }
            set {
                curObj["ShouldPipelineIn"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsShouldPipelineOutNull {
            get {
                if ((curObj["ShouldPipelineOut"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool ShouldPipelineOut {
            get {
                if ((curObj["ShouldPipelineOut"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["ShouldPipelineOut"]));
            }
            set {
                curObj["ShouldPipelineOut"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string SmartHost {
            get {
                return ((string)(curObj["SmartHost"]));
            }
            set {
                curObj["SmartHost"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsSmartHostTypeNull {
            get {
                if ((curObj["SmartHostType"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int SmartHostType {
            get {
                if ((curObj["SmartHostType"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["SmartHostType"]));
            }
            set {
                curObj["SmartHostType"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsSmtpAqueueWaitNull {
            get {
                if ((curObj["SmtpAqueueWait"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int SmtpAqueueWait {
            get {
                if ((curObj["SmtpAqueueWait"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["SmtpAqueueWait"]));
            }
            set {
                curObj["SmtpAqueueWait"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsSmtpAuthTimeoutNull {
            get {
                if ((curObj["SmtpAuthTimeout"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int SmtpAuthTimeout {
            get {
                if ((curObj["SmtpAuthTimeout"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["SmtpAuthTimeout"]));
            }
            set {
                curObj["SmtpAuthTimeout"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsSmtpBdatTimeoutNull {
            get {
                if ((curObj["SmtpBdatTimeout"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int SmtpBdatTimeout {
            get {
                if ((curObj["SmtpBdatTimeout"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["SmtpBdatTimeout"]));
            }
            set {
                curObj["SmtpBdatTimeout"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string SmtpClearTextProvider {
            get {
                return ((string)(curObj["SmtpClearTextProvider"]));
            }
            set {
                curObj["SmtpClearTextProvider"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsSmtpConnectTimeoutNull {
            get {
                if ((curObj["SmtpConnectTimeout"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int SmtpConnectTimeout {
            get {
                if ((curObj["SmtpConnectTimeout"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["SmtpConnectTimeout"]));
            }
            set {
                curObj["SmtpConnectTimeout"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsSmtpDataTimeoutNull {
            get {
                if ((curObj["SmtpDataTimeout"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int SmtpDataTimeout {
            get {
                if ((curObj["SmtpDataTimeout"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["SmtpDataTimeout"]));
            }
            set {
                curObj["SmtpDataTimeout"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsSmtpDisableRelayNull {
            get {
                if ((curObj["SmtpDisableRelay"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool SmtpDisableRelay {
            get {
                if ((curObj["SmtpDisableRelay"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["SmtpDisableRelay"]));
            }
            set {
                curObj["SmtpDisableRelay"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsSmtpDomainValidationFlagsNull {
            get {
                if ((curObj["SmtpDomainValidationFlags"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int SmtpDomainValidationFlags {
            get {
                if ((curObj["SmtpDomainValidationFlags"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["SmtpDomainValidationFlags"]));
            }
            set {
                curObj["SmtpDomainValidationFlags"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsSmtpDotStuffPickupDirFilesNull {
            get {
                if ((curObj["SmtpDotStuffPickupDirFiles"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool SmtpDotStuffPickupDirFiles {
            get {
                if ((curObj["SmtpDotStuffPickupDirFiles"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["SmtpDotStuffPickupDirFiles"]));
            }
            set {
                curObj["SmtpDotStuffPickupDirFiles"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsSmtpDSNLanguageIDNull {
            get {
                if ((curObj["SmtpDSNLanguageID"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int SmtpDSNLanguageID {
            get {
                if ((curObj["SmtpDSNLanguageID"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["SmtpDSNLanguageID"]));
            }
            set {
                curObj["SmtpDSNLanguageID"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsSmtpDSNOptionsNull {
            get {
                if ((curObj["SmtpDSNOptions"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int SmtpDSNOptions {
            get {
                if ((curObj["SmtpDSNOptions"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["SmtpDSNOptions"]));
            }
            set {
                curObj["SmtpDSNOptions"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsSmtpEventlogLevelNull {
            get {
                if ((curObj["SmtpEventlogLevel"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int SmtpEventlogLevel {
            get {
                if ((curObj["SmtpEventlogLevel"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["SmtpEventlogLevel"]));
            }
            set {
                curObj["SmtpEventlogLevel"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsSmtpHeloNoDomainNull {
            get {
                if ((curObj["SmtpHeloNoDomain"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool SmtpHeloNoDomain {
            get {
                if ((curObj["SmtpHeloNoDomain"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["SmtpHeloNoDomain"]));
            }
            set {
                curObj["SmtpHeloNoDomain"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsSmtpHeloTimeoutNull {
            get {
                if ((curObj["SmtpHeloTimeout"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int SmtpHeloTimeout {
            get {
                if ((curObj["SmtpHeloTimeout"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["SmtpHeloTimeout"]));
            }
            set {
                curObj["SmtpHeloTimeout"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsSmtpInboundCommandSupportOptionsNull {
            get {
                if ((curObj["SmtpInboundCommandSupportOptions"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int SmtpInboundCommandSupportOptions {
            get {
                if ((curObj["SmtpInboundCommandSupportOptions"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["SmtpInboundCommandSupportOptions"]));
            }
            set {
                curObj["SmtpInboundCommandSupportOptions"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsSmtpIpRestrictionFlagNull {
            get {
                if ((curObj["SmtpIpRestrictionFlag"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int SmtpIpRestrictionFlag {
            get {
                if ((curObj["SmtpIpRestrictionFlag"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["SmtpIpRestrictionFlag"]));
            }
            set {
                curObj["SmtpIpRestrictionFlag"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsSmtpLocalDelayExpireMinutesNull {
            get {
                if ((curObj["SmtpLocalDelayExpireMinutes"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int SmtpLocalDelayExpireMinutes {
            get {
                if ((curObj["SmtpLocalDelayExpireMinutes"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["SmtpLocalDelayExpireMinutes"]));
            }
            set {
                curObj["SmtpLocalDelayExpireMinutes"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsSmtpLocalNDRExpireMinutesNull {
            get {
                if ((curObj["SmtpLocalNDRExpireMinutes"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int SmtpLocalNDRExpireMinutes {
            get {
                if ((curObj["SmtpLocalNDRExpireMinutes"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["SmtpLocalNDRExpireMinutes"]));
            }
            set {
                curObj["SmtpLocalNDRExpireMinutes"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsSmtpMailFromTimeoutNull {
            get {
                if ((curObj["SmtpMailFromTimeout"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int SmtpMailFromTimeout {
            get {
                if ((curObj["SmtpMailFromTimeout"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["SmtpMailFromTimeout"]));
            }
            set {
                curObj["SmtpMailFromTimeout"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsSmtpMailNoHeloNull {
            get {
                if ((curObj["SmtpMailNoHelo"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool SmtpMailNoHelo {
            get {
                if ((curObj["SmtpMailNoHelo"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["SmtpMailNoHelo"]));
            }
            set {
                curObj["SmtpMailNoHelo"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsSmtpMaxRemoteQThreadsNull {
            get {
                if ((curObj["SmtpMaxRemoteQThreads"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int SmtpMaxRemoteQThreads {
            get {
                if ((curObj["SmtpMaxRemoteQThreads"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["SmtpMaxRemoteQThreads"]));
            }
            set {
                curObj["SmtpMaxRemoteQThreads"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsSmtpOutboundCommandSupportOptionsNull {
            get {
                if ((curObj["SmtpOutboundCommandSupportOptions"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int SmtpOutboundCommandSupportOptions {
            get {
                if ((curObj["SmtpOutboundCommandSupportOptions"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["SmtpOutboundCommandSupportOptions"]));
            }
            set {
                curObj["SmtpOutboundCommandSupportOptions"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsSmtpRcptToTimeoutNull {
            get {
                if ((curObj["SmtpRcptToTimeout"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int SmtpRcptToTimeout {
            get {
                if ((curObj["SmtpRcptToTimeout"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["SmtpRcptToTimeout"]));
            }
            set {
                curObj["SmtpRcptToTimeout"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsSmtpRemoteDelayExpireMinutesNull {
            get {
                if ((curObj["SmtpRemoteDelayExpireMinutes"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int SmtpRemoteDelayExpireMinutes {
            get {
                if ((curObj["SmtpRemoteDelayExpireMinutes"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["SmtpRemoteDelayExpireMinutes"]));
            }
            set {
                curObj["SmtpRemoteDelayExpireMinutes"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsSmtpRemoteNDRExpireMinutesNull {
            get {
                if ((curObj["SmtpRemoteNDRExpireMinutes"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int SmtpRemoteNDRExpireMinutes {
            get {
                if ((curObj["SmtpRemoteNDRExpireMinutes"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["SmtpRemoteNDRExpireMinutes"]));
            }
            set {
                curObj["SmtpRemoteNDRExpireMinutes"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string SmtpRemoteProgressiveRetry {
            get {
                return ((string)(curObj["SmtpRemoteProgressiveRetry"]));
            }
            set {
                curObj["SmtpRemoteProgressiveRetry"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsSmtpRemoteRetryThresholdNull {
            get {
                if ((curObj["SmtpRemoteRetryThreshold"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int SmtpRemoteRetryThreshold {
            get {
                if ((curObj["SmtpRemoteRetryThreshold"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["SmtpRemoteRetryThreshold"]));
            }
            set {
                curObj["SmtpRemoteRetryThreshold"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsSmtpRsetTimeoutNull {
            get {
                if ((curObj["SmtpRsetTimeout"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int SmtpRsetTimeout {
            get {
                if ((curObj["SmtpRsetTimeout"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["SmtpRsetTimeout"]));
            }
            set {
                curObj["SmtpRsetTimeout"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsSmtpSaslTimeoutNull {
            get {
                if ((curObj["SmtpSaslTimeout"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int SmtpSaslTimeout {
            get {
                if ((curObj["SmtpSaslTimeout"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["SmtpSaslTimeout"]));
            }
            set {
                curObj["SmtpSaslTimeout"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsSmtpSSLCertHostnameValidationNull {
            get {
                if ((curObj["SmtpSSLCertHostnameValidation"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool SmtpSSLCertHostnameValidation {
            get {
                if ((curObj["SmtpSSLCertHostnameValidation"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["SmtpSSLCertHostnameValidation"]));
            }
            set {
                curObj["SmtpSSLCertHostnameValidation"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsSmtpSSLRequireTrustedCANull {
            get {
                if ((curObj["SmtpSSLRequireTrustedCA"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool SmtpSSLRequireTrustedCA {
            get {
                if ((curObj["SmtpSSLRequireTrustedCA"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["SmtpSSLRequireTrustedCA"]));
            }
            set {
                curObj["SmtpSSLRequireTrustedCA"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsSmtpTurnTimeoutNull {
            get {
                if ((curObj["SmtpTurnTimeout"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int SmtpTurnTimeout {
            get {
                if ((curObj["SmtpTurnTimeout"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["SmtpTurnTimeout"]));
            }
            set {
                curObj["SmtpTurnTimeout"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsSmtpUseTcpDnsNull {
            get {
                if ((curObj["SmtpUseTcpDns"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int SmtpUseTcpDns {
            get {
                if ((curObj["SmtpUseTcpDns"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["SmtpUseTcpDns"]));
            }
            set {
                curObj["SmtpUseTcpDns"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsUpdatedDefaultDomainNull {
            get {
                if ((curObj["UpdatedDefaultDomain"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool UpdatedDefaultDomain {
            get {
                if ((curObj["UpdatedDefaultDomain"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["UpdatedDefaultDomain"]));
            }
            set {
                curObj["UpdatedDefaultDomain"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsUpdatedFQDNNull {
            get {
                if ((curObj["UpdatedFQDN"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool UpdatedFQDN {
            get {
                if ((curObj["UpdatedFQDN"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["UpdatedFQDN"]));
            }
            set {
                curObj["UpdatedFQDN"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsWin32ErrorNull {
            get {
                if ((curObj["Win32Error"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int Win32Error {
            get {
                if ((curObj["Win32Error"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["Win32Error"]));
            }
            set {
                curObj["Win32Error"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        private bool CheckIfProperClass(System.Management.ManagementScope mgmtScope, System.Management.ManagementPath path, System.Management.ObjectGetOptions OptionsParam) {
            if (((path != null) 
                        && (System.String.Compare(path.ClassName, ManagementClassName, true, CultureInfo.InvariantCulture) == 0))) {
                return true;
            }
            else {
                return CheckIfProperClass(new System.Management.ManagementObject(mgmtScope, path, OptionsParam));
            }
        }
        
        private bool CheckIfProperClass(System.Management.ManagementBaseObject theObj) {
            if (((theObj != null) 
                        && (System.String.Compare(((string)(theObj["__CLASS"])), ManagementClassName, true, CultureInfo.InvariantCulture) == 0))) {
                return true;
            }
            else {
                System.Array parentClasses = ((System.Array)(theObj["__DERIVATION"]));
                if ((parentClasses != null)) {
                    Int32 count = 0;
                    for (count = 0; (count < parentClasses.Length); count = (count + 1)) {
                        if ((System.String.Compare(((string)(parentClasses.GetValue(count))), ManagementClassName, true, CultureInfo.InvariantCulture) == 0)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        
        private bool ShouldSerializeAccessExecute() {
            if ((IsAccessExecuteNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessExecute() {
            curObj["AccessExecute"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessFlags() {
            if ((IsAccessFlagsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessFlags() {
            curObj["AccessFlags"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessNoPhysicalDir() {
            if ((IsAccessNoPhysicalDirNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessNoPhysicalDir() {
            curObj["AccessNoPhysicalDir"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessNoRemoteExecute() {
            if ((IsAccessNoRemoteExecuteNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessNoRemoteExecute() {
            curObj["AccessNoRemoteExecute"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessNoRemoteRead() {
            if ((IsAccessNoRemoteReadNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessNoRemoteRead() {
            curObj["AccessNoRemoteRead"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessNoRemoteScript() {
            if ((IsAccessNoRemoteScriptNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessNoRemoteScript() {
            curObj["AccessNoRemoteScript"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessNoRemoteWrite() {
            if ((IsAccessNoRemoteWriteNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessNoRemoteWrite() {
            curObj["AccessNoRemoteWrite"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessRead() {
            if ((IsAccessReadNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessRead() {
            curObj["AccessRead"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessScript() {
            if ((IsAccessScriptNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessScript() {
            curObj["AccessScript"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessSource() {
            if ((IsAccessSourceNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessSource() {
            curObj["AccessSource"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessSSL() {
            if ((IsAccessSSLNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessSSL() {
            curObj["AccessSSL"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessSSL128() {
            if ((IsAccessSSL128Null == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessSSL128() {
            curObj["AccessSSL128"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessSSLFlags() {
            if ((IsAccessSSLFlagsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessSSLFlags() {
            curObj["AccessSSLFlags"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessSSLMapCert() {
            if ((IsAccessSSLMapCertNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessSSLMapCert() {
            curObj["AccessSSLMapCert"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessSSLNegotiateCert() {
            if ((IsAccessSSLNegotiateCertNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessSSLNegotiateCert() {
            curObj["AccessSSLNegotiateCert"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessSSLRequireCert() {
            if ((IsAccessSSLRequireCertNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessSSLRequireCert() {
            curObj["AccessSSLRequireCert"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessWrite() {
            if ((IsAccessWriteNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessWrite() {
            curObj["AccessWrite"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAddNoHeaders() {
            if ((IsAddNoHeadersNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAddNoHeaders() {
            curObj["AddNoHeaders"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAdminACLBin() {
            curObj["AdminACLBin"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAllowAnonymous() {
            if ((IsAllowAnonymousNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAllowAnonymous() {
            curObj["AllowAnonymous"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAlwaysUseSsl() {
            if ((IsAlwaysUseSslNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAlwaysUseSsl() {
            curObj["AlwaysUseSsl"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAnonymousOnly() {
            if ((IsAnonymousOnlyNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAnonymousOnly() {
            curObj["AnonymousOnly"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAnonymousPasswordSync() {
            if ((IsAnonymousPasswordSyncNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAnonymousPasswordSync() {
            curObj["AnonymousPasswordSync"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAnonymousUserName() {
            curObj["AnonymousUserName"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAuthAnonymous() {
            if ((IsAuthAnonymousNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAuthAnonymous() {
            curObj["AuthAnonymous"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAuthBasic() {
            if ((IsAuthBasicNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAuthBasic() {
            curObj["AuthBasic"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAuthFlags() {
            if ((IsAuthFlagsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAuthFlags() {
            curObj["AuthFlags"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAuthMD5() {
            if ((IsAuthMD5Null == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAuthMD5() {
            curObj["AuthMD5"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAuthNTLM() {
            if ((IsAuthNTLMNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAuthNTLM() {
            curObj["AuthNTLM"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAuthPassport() {
            if ((IsAuthPassportNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAuthPassport() {
            curObj["AuthPassport"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAzEnable() {
            if ((IsAzEnableNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAzEnable() {
            curObj["AzEnable"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAzScopeName() {
            curObj["AzScopeName"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAzStoreName() {
            curObj["AzStoreName"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetBadMailDirectory() {
            curObj["BadMailDirectory"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeClusterEnabled() {
            if ((IsClusterEnabledNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetClusterEnabled() {
            curObj["ClusterEnabled"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeConnectionTimeout() {
            if ((IsConnectionTimeoutNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetConnectionTimeout() {
            curObj["ConnectionTimeout"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetConnectResponse() {
            curObj["ConnectResponse"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetDefaultDomain() {
            curObj["DefaultDomain"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetDefaultLogonDomain() {
            curObj["DefaultLogonDomain"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeDisableSocketPooling() {
            if ((IsDisableSocketPoolingNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetDisableSocketPooling() {
            curObj["DisableSocketPooling"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeDoMasquerade() {
            if ((IsDoMasqueradeNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetDoMasquerade() {
            curObj["DoMasquerade"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeDontLog() {
            if ((IsDontLogNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetDontLog() {
            curObj["DontLog"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetDropDirectory() {
            curObj["DropDirectory"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeEnableReverseDnsLookup() {
            if ((IsEnableReverseDnsLookupNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetEnableReverseDnsLookup() {
            curObj["EnableReverseDnsLookup"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeEtrnDays() {
            if ((IsEtrnDaysNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetEtrnDays() {
            curObj["EtrnDays"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeEtrnSubdomains() {
            if ((IsEtrnSubdomainsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetEtrnSubdomains() {
            curObj["EtrnSubdomains"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetFullyQualifiedDomainName() {
            curObj["FullyQualifiedDomainName"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeHopCount() {
            if ((IsHopCountNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetHopCount() {
            curObj["HopCount"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLimitRemoteConnections() {
            if ((IsLimitRemoteConnectionsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLimitRemoteConnections() {
            curObj["LimitRemoteConnections"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLocalRetryAttempts() {
            if ((IsLocalRetryAttemptsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLocalRetryAttempts() {
            curObj["LocalRetryAttempts"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLocalRetryInterval() {
            if ((IsLocalRetryIntervalNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLocalRetryInterval() {
            curObj["LocalRetryInterval"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileBytesRecv() {
            if ((IsLogExtFileBytesRecvNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileBytesRecv() {
            curObj["LogExtFileBytesRecv"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileBytesSent() {
            if ((IsLogExtFileBytesSentNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileBytesSent() {
            curObj["LogExtFileBytesSent"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileClientIp() {
            if ((IsLogExtFileClientIpNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileClientIp() {
            curObj["LogExtFileClientIp"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileComputerName() {
            if ((IsLogExtFileComputerNameNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileComputerName() {
            curObj["LogExtFileComputerName"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileCookie() {
            if ((IsLogExtFileCookieNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileCookie() {
            curObj["LogExtFileCookie"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileDate() {
            if ((IsLogExtFileDateNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileDate() {
            curObj["LogExtFileDate"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileFlags() {
            if ((IsLogExtFileFlagsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileFlags() {
            curObj["LogExtFileFlags"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileHost() {
            if ((IsLogExtFileHostNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileHost() {
            curObj["LogExtFileHost"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileHttpStatus() {
            if ((IsLogExtFileHttpStatusNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileHttpStatus() {
            curObj["LogExtFileHttpStatus"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileHttpSubStatus() {
            if ((IsLogExtFileHttpSubStatusNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileHttpSubStatus() {
            curObj["LogExtFileHttpSubStatus"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileMethod() {
            if ((IsLogExtFileMethodNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileMethod() {
            curObj["LogExtFileMethod"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileProtocolVersion() {
            if ((IsLogExtFileProtocolVersionNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileProtocolVersion() {
            curObj["LogExtFileProtocolVersion"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileReferer() {
            if ((IsLogExtFileRefererNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileReferer() {
            curObj["LogExtFileReferer"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileServerIp() {
            if ((IsLogExtFileServerIpNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileServerIp() {
            curObj["LogExtFileServerIp"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileServerPort() {
            if ((IsLogExtFileServerPortNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileServerPort() {
            curObj["LogExtFileServerPort"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileSiteName() {
            if ((IsLogExtFileSiteNameNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileSiteName() {
            curObj["LogExtFileSiteName"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileTime() {
            if ((IsLogExtFileTimeNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileTime() {
            curObj["LogExtFileTime"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileTimeTaken() {
            if ((IsLogExtFileTimeTakenNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileTimeTaken() {
            curObj["LogExtFileTimeTaken"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileUriQuery() {
            if ((IsLogExtFileUriQueryNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileUriQuery() {
            curObj["LogExtFileUriQuery"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileUriStem() {
            if ((IsLogExtFileUriStemNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileUriStem() {
            curObj["LogExtFileUriStem"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileUserAgent() {
            if ((IsLogExtFileUserAgentNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileUserAgent() {
            curObj["LogExtFileUserAgent"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileUserName() {
            if ((IsLogExtFileUserNameNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileUserName() {
            curObj["LogExtFileUserName"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileWin32Status() {
            if ((IsLogExtFileWin32StatusNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileWin32Status() {
            curObj["LogExtFileWin32Status"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetLogFileDirectory() {
            curObj["LogFileDirectory"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogFilePeriod() {
            if ((IsLogFilePeriodNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogFilePeriod() {
            curObj["LogFilePeriod"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogFileTruncateSize() {
            if ((IsLogFileTruncateSizeNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogFileTruncateSize() {
            curObj["LogFileTruncateSize"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetLogOdbcDataSource() {
            curObj["LogOdbcDataSource"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetLogOdbcPassword() {
            curObj["LogOdbcPassword"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetLogOdbcTableName() {
            curObj["LogOdbcTableName"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetLogOdbcUserName() {
            curObj["LogOdbcUserName"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetLogPluginClsid() {
            curObj["LogPluginClsid"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogType() {
            if ((IsLogTypeNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogType() {
            curObj["LogType"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetMasqueradeDomain() {
            curObj["MasqueradeDomain"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeMaxBandwidth() {
            if ((IsMaxBandwidthNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetMaxBandwidth() {
            curObj["MaxBandwidth"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeMaxBatchedMessages() {
            if ((IsMaxBatchedMessagesNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetMaxBatchedMessages() {
            curObj["MaxBatchedMessages"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeMaxConnections() {
            if ((IsMaxConnectionsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetMaxConnections() {
            curObj["MaxConnections"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeMaxDirChangeIOSize() {
            if ((IsMaxDirChangeIOSizeNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetMaxDirChangeIOSize() {
            curObj["MaxDirChangeIOSize"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeMaxEndpointConnections() {
            if ((IsMaxEndpointConnectionsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetMaxEndpointConnections() {
            curObj["MaxEndpointConnections"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeMaxMailObjects() {
            if ((IsMaxMailObjectsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetMaxMailObjects() {
            curObj["MaxMailObjects"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeMaxMessageSize() {
            if ((IsMaxMessageSizeNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetMaxMessageSize() {
            curObj["MaxMessageSize"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeMaxOutConnections() {
            if ((IsMaxOutConnectionsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetMaxOutConnections() {
            curObj["MaxOutConnections"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeMaxOutConnectionsPerDomain() {
            if ((IsMaxOutConnectionsPerDomainNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetMaxOutConnectionsPerDomain() {
            curObj["MaxOutConnectionsPerDomain"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeMaxRecipients() {
            if ((IsMaxRecipientsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetMaxRecipients() {
            curObj["MaxRecipients"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeMaxSessionSize() {
            if ((IsMaxSessionSizeNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetMaxSessionSize() {
            curObj["MaxSessionSize"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeMaxSmtpErrors() {
            if ((IsMaxSmtpErrorsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetMaxSmtpErrors() {
            curObj["MaxSmtpErrors"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeNameResolutionType() {
            if ((IsNameResolutionTypeNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetNameResolutionType() {
            curObj["NameResolutionType"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetNTAuthenticationProviders() {
            curObj["NTAuthenticationProviders"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetPickupDirectory() {
            curObj["PickupDirectory"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetQueueDirectory() {
            curObj["QueueDirectory"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetRealm() {
            curObj["Realm"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeRelayForAuth() {
            if ((IsRelayForAuthNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetRelayForAuth() {
            curObj["RelayForAuth"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetRelayIpList() {
            curObj["RelayIpList"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeRemoteRetryAttempts() {
            if ((IsRemoteRetryAttemptsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetRemoteRetryAttempts() {
            curObj["RemoteRetryAttempts"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeRemoteRetryInterval() {
            if ((IsRemoteRetryIntervalNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetRemoteRetryInterval() {
            curObj["RemoteRetryInterval"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeRemoteSmtpPort() {
            if ((IsRemoteSmtpPortNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetRemoteSmtpPort() {
            curObj["RemoteSmtpPort"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeRemoteSmtpSecurePort() {
            if ((IsRemoteSmtpSecurePortNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetRemoteSmtpSecurePort() {
            curObj["RemoteSmtpSecurePort"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeRemoteTimeout() {
            if ((IsRemoteTimeoutNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetRemoteTimeout() {
            curObj["RemoteTimeout"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeRouteAction() {
            if ((IsRouteActionNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetRouteAction() {
            curObj["RouteAction"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetRoutePassword() {
            curObj["RoutePassword"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetRouteUserName() {
            curObj["RouteUserName"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetRoutingDll() {
            curObj["RoutingDll"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetSaslLogonDomain() {
            curObj["SaslLogonDomain"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetSecureBindings() {
            curObj["SecureBindings"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetSendBadTo() {
            curObj["SendBadTo"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetSendNdrTo() {
            curObj["SendNdrTo"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeServerAutoStart() {
            if ((IsServerAutoStartNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetServerAutoStart() {
            curObj["ServerAutoStart"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetServerBindings() {
            curObj["ServerBindings"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetServerComment() {
            curObj["ServerComment"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeServerListenBacklog() {
            if ((IsServerListenBacklogNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetServerListenBacklog() {
            curObj["ServerListenBacklog"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeServerListenTimeout() {
            if ((IsServerListenTimeoutNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetServerListenTimeout() {
            curObj["ServerListenTimeout"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeShouldDeliver() {
            if ((IsShouldDeliverNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetShouldDeliver() {
            curObj["ShouldDeliver"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeShouldPickupMail() {
            if ((IsShouldPickupMailNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetShouldPickupMail() {
            curObj["ShouldPickupMail"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeShouldPipelineIn() {
            if ((IsShouldPipelineInNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetShouldPipelineIn() {
            curObj["ShouldPipelineIn"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeShouldPipelineOut() {
            if ((IsShouldPipelineOutNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetShouldPipelineOut() {
            curObj["ShouldPipelineOut"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetSmartHost() {
            curObj["SmartHost"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeSmartHostType() {
            if ((IsSmartHostTypeNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetSmartHostType() {
            curObj["SmartHostType"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeSmtpAqueueWait() {
            if ((IsSmtpAqueueWaitNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetSmtpAqueueWait() {
            curObj["SmtpAqueueWait"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeSmtpAuthTimeout() {
            if ((IsSmtpAuthTimeoutNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetSmtpAuthTimeout() {
            curObj["SmtpAuthTimeout"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeSmtpBdatTimeout() {
            if ((IsSmtpBdatTimeoutNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetSmtpBdatTimeout() {
            curObj["SmtpBdatTimeout"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetSmtpClearTextProvider() {
            curObj["SmtpClearTextProvider"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeSmtpConnectTimeout() {
            if ((IsSmtpConnectTimeoutNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetSmtpConnectTimeout() {
            curObj["SmtpConnectTimeout"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeSmtpDataTimeout() {
            if ((IsSmtpDataTimeoutNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetSmtpDataTimeout() {
            curObj["SmtpDataTimeout"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeSmtpDisableRelay() {
            if ((IsSmtpDisableRelayNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetSmtpDisableRelay() {
            curObj["SmtpDisableRelay"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeSmtpDomainValidationFlags() {
            if ((IsSmtpDomainValidationFlagsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetSmtpDomainValidationFlags() {
            curObj["SmtpDomainValidationFlags"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeSmtpDotStuffPickupDirFiles() {
            if ((IsSmtpDotStuffPickupDirFilesNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetSmtpDotStuffPickupDirFiles() {
            curObj["SmtpDotStuffPickupDirFiles"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeSmtpDSNLanguageID() {
            if ((IsSmtpDSNLanguageIDNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetSmtpDSNLanguageID() {
            curObj["SmtpDSNLanguageID"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeSmtpDSNOptions() {
            if ((IsSmtpDSNOptionsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetSmtpDSNOptions() {
            curObj["SmtpDSNOptions"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeSmtpEventlogLevel() {
            if ((IsSmtpEventlogLevelNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetSmtpEventlogLevel() {
            curObj["SmtpEventlogLevel"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeSmtpHeloNoDomain() {
            if ((IsSmtpHeloNoDomainNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetSmtpHeloNoDomain() {
            curObj["SmtpHeloNoDomain"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeSmtpHeloTimeout() {
            if ((IsSmtpHeloTimeoutNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetSmtpHeloTimeout() {
            curObj["SmtpHeloTimeout"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeSmtpInboundCommandSupportOptions() {
            if ((IsSmtpInboundCommandSupportOptionsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetSmtpInboundCommandSupportOptions() {
            curObj["SmtpInboundCommandSupportOptions"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeSmtpIpRestrictionFlag() {
            if ((IsSmtpIpRestrictionFlagNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetSmtpIpRestrictionFlag() {
            curObj["SmtpIpRestrictionFlag"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeSmtpLocalDelayExpireMinutes() {
            if ((IsSmtpLocalDelayExpireMinutesNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetSmtpLocalDelayExpireMinutes() {
            curObj["SmtpLocalDelayExpireMinutes"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeSmtpLocalNDRExpireMinutes() {
            if ((IsSmtpLocalNDRExpireMinutesNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetSmtpLocalNDRExpireMinutes() {
            curObj["SmtpLocalNDRExpireMinutes"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeSmtpMailFromTimeout() {
            if ((IsSmtpMailFromTimeoutNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetSmtpMailFromTimeout() {
            curObj["SmtpMailFromTimeout"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeSmtpMailNoHelo() {
            if ((IsSmtpMailNoHeloNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetSmtpMailNoHelo() {
            curObj["SmtpMailNoHelo"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeSmtpMaxRemoteQThreads() {
            if ((IsSmtpMaxRemoteQThreadsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetSmtpMaxRemoteQThreads() {
            curObj["SmtpMaxRemoteQThreads"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeSmtpOutboundCommandSupportOptions() {
            if ((IsSmtpOutboundCommandSupportOptionsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetSmtpOutboundCommandSupportOptions() {
            curObj["SmtpOutboundCommandSupportOptions"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeSmtpRcptToTimeout() {
            if ((IsSmtpRcptToTimeoutNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetSmtpRcptToTimeout() {
            curObj["SmtpRcptToTimeout"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeSmtpRemoteDelayExpireMinutes() {
            if ((IsSmtpRemoteDelayExpireMinutesNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetSmtpRemoteDelayExpireMinutes() {
            curObj["SmtpRemoteDelayExpireMinutes"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeSmtpRemoteNDRExpireMinutes() {
            if ((IsSmtpRemoteNDRExpireMinutesNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetSmtpRemoteNDRExpireMinutes() {
            curObj["SmtpRemoteNDRExpireMinutes"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetSmtpRemoteProgressiveRetry() {
            curObj["SmtpRemoteProgressiveRetry"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeSmtpRemoteRetryThreshold() {
            if ((IsSmtpRemoteRetryThresholdNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetSmtpRemoteRetryThreshold() {
            curObj["SmtpRemoteRetryThreshold"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeSmtpRsetTimeout() {
            if ((IsSmtpRsetTimeoutNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetSmtpRsetTimeout() {
            curObj["SmtpRsetTimeout"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeSmtpSaslTimeout() {
            if ((IsSmtpSaslTimeoutNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetSmtpSaslTimeout() {
            curObj["SmtpSaslTimeout"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeSmtpSSLCertHostnameValidation() {
            if ((IsSmtpSSLCertHostnameValidationNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetSmtpSSLCertHostnameValidation() {
            curObj["SmtpSSLCertHostnameValidation"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeSmtpSSLRequireTrustedCA() {
            if ((IsSmtpSSLRequireTrustedCANull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetSmtpSSLRequireTrustedCA() {
            curObj["SmtpSSLRequireTrustedCA"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeSmtpTurnTimeout() {
            if ((IsSmtpTurnTimeoutNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetSmtpTurnTimeout() {
            curObj["SmtpTurnTimeout"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeSmtpUseTcpDns() {
            if ((IsSmtpUseTcpDnsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetSmtpUseTcpDns() {
            curObj["SmtpUseTcpDns"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeUpdatedDefaultDomain() {
            if ((IsUpdatedDefaultDomainNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetUpdatedDefaultDomain() {
            curObj["UpdatedDefaultDomain"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeUpdatedFQDN() {
            if ((IsUpdatedFQDNNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetUpdatedFQDN() {
            curObj["UpdatedFQDN"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeWin32Error() {
            if ((IsWin32ErrorNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetWin32Error() {
            curObj["Win32Error"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        [Browsable(true)]
        public void CommitObject() {
            if ((isEmbedded == false)) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private static string ConstructPath(string keyName) {
            string strPath = "ROOT\\MicrosoftIISv2:IIsSmtpServerSetting";
            strPath = (strPath 
                        + (".Name=" 
                        + ("\"" 
                        + (keyName + "\""))));
            return strPath;
        }
        
        // Different overloads of GetInstances() help in enumerating instances of the WMI class.
        public static IIsSmtpServerSettingCollection GetInstances() {
            return GetInstances(((System.Management.ManagementScope)(null)), ((System.Management.EnumerationOptions)(null)));
        }
        
        public static IIsSmtpServerSettingCollection GetInstances(string condition) {
            return GetInstances(null, condition, null);
        }
        
        public static IIsSmtpServerSettingCollection GetInstances(System.String [] selectedProperties) {
            return GetInstances(null, null, selectedProperties);
        }
        
        public static IIsSmtpServerSettingCollection GetInstances(string condition, System.String [] selectedProperties) {
            return GetInstances(null, condition, selectedProperties);
        }
        
        public static IIsSmtpServerSettingCollection GetInstances(System.Management.ManagementScope mgmtScope, System.Management.EnumerationOptions enumOptions) {
            if ((mgmtScope == null)) {
                if ((statMgmtScope == null)) {
                    mgmtScope = new System.Management.ManagementScope();
                    mgmtScope.Path.NamespacePath = "root\\MicrosoftIISv2";
                }
                else {
                    mgmtScope = statMgmtScope;
                }
            }
            System.Management.ManagementPath pathObj = new System.Management.ManagementPath();
            pathObj.ClassName = "IIsSmtpServerSetting";
            pathObj.NamespacePath = "root\\MicrosoftIISv2";
            System.Management.ManagementClass clsObject = new System.Management.ManagementClass(mgmtScope, pathObj, null);
            if ((enumOptions == null)) {
                enumOptions = new System.Management.EnumerationOptions();
                enumOptions.EnsureLocatable = true;
            }
            return new IIsSmtpServerSettingCollection(clsObject.GetInstances(enumOptions));
        }
        
        public static IIsSmtpServerSettingCollection GetInstances(System.Management.ManagementScope mgmtScope, string condition) {
            return GetInstances(mgmtScope, condition, null);
        }
        
        public static IIsSmtpServerSettingCollection GetInstances(System.Management.ManagementScope mgmtScope, System.String [] selectedProperties) {
            return GetInstances(mgmtScope, null, selectedProperties);
        }
        
        public static IIsSmtpServerSettingCollection GetInstances(System.Management.ManagementScope mgmtScope, string condition, System.String [] selectedProperties) {
            if ((mgmtScope == null)) {
                if ((statMgmtScope == null)) {
                    mgmtScope = new System.Management.ManagementScope();
                    mgmtScope.Path.NamespacePath = "root\\MicrosoftIISv2";
                }
                else {
                    mgmtScope = statMgmtScope;
                }
            }
            System.Management.ManagementObjectSearcher ObjectSearcher = new System.Management.ManagementObjectSearcher(mgmtScope, new SelectQuery("IIsSmtpServerSetting", condition, selectedProperties));
            System.Management.EnumerationOptions enumOptions = new System.Management.EnumerationOptions();
            enumOptions.EnsureLocatable = true;
            ObjectSearcher.Options = enumOptions;
            return new IIsSmtpServerSettingCollection(ObjectSearcher.Get());
        }
        
        [Browsable(true)]
        public static IIsSmtpServerSetting CreateInstance() {
            System.Management.ManagementScope mgmtScope = null;
            if ((statMgmtScope == null)) {
                mgmtScope = new System.Management.ManagementScope();
                mgmtScope.Path.NamespacePath = CreatedWmiNamespace;
            }
            else {
                mgmtScope = statMgmtScope;
            }
            System.Management.ManagementPath mgmtPath = new System.Management.ManagementPath(CreatedClassName);
            return new IIsSmtpServerSetting(new System.Management.ManagementClass(mgmtScope, mgmtPath, null).CreateInstance());
        }
        
        [Browsable(true)]
        public void Delete() {
            PrivateLateBoundObject.Delete();
        }
        
        // Enumerator implementation for enumerating instances of the class.
        public class IIsSmtpServerSettingCollection : object, ICollection {
            
            private ManagementObjectCollection ObjectCollection;
            
            public IIsSmtpServerSettingCollection(ManagementObjectCollection objCollection) {
                ObjectCollection = objCollection;
            }
            
            public int Count {
                get {
                    return ObjectCollection.Count;
                }
            }
            
            public bool IsSynchronized {
                get {
                    return ObjectCollection.IsSynchronized;
                }
            }
            
            public object SyncRoot {
                get {
                    return this;
                }
            }
            
            public void CopyTo(System.Array array, int index) {
                ObjectCollection.CopyTo(array, index);
                int nCtr;
                for (nCtr = 0; (nCtr < array.Length); nCtr = (nCtr + 1)) {
                    array.SetValue(new IIsSmtpServerSetting(((System.Management.ManagementObject)(array.GetValue(nCtr)))), nCtr);
                }
            }
            
            public System.Collections.IEnumerator GetEnumerator() {
                return new IIsSmtpServerSettingEnumerator(ObjectCollection.GetEnumerator());
            }
            
            public class IIsSmtpServerSettingEnumerator : object, System.Collections.IEnumerator {
                
                private ManagementObjectCollection.ManagementObjectEnumerator ObjectEnumerator;
                
                public IIsSmtpServerSettingEnumerator(ManagementObjectCollection.ManagementObjectEnumerator objEnum) {
                    ObjectEnumerator = objEnum;
                }
                
                public object Current {
                    get {
                        return new IIsSmtpServerSetting(((System.Management.ManagementObject)(ObjectEnumerator.Current)));
                    }
                }
                
                public bool MoveNext() {
                    return ObjectEnumerator.MoveNext();
                }
                
                public void Reset() {
                    ObjectEnumerator.Reset();
                }
            }
        }
        
        // TypeConverter to handle null values for ValueType properties
        public class WMIValueTypeConverter : TypeConverter {
            
            private TypeConverter baseConverter;
            
            public WMIValueTypeConverter(System.Type baseType) {
                baseConverter = TypeDescriptor.GetConverter(baseType);
            }
            
            public override bool CanConvertFrom(System.ComponentModel.ITypeDescriptorContext context, System.Type srcType) {
                return baseConverter.CanConvertFrom(context, srcType);
            }
            
            public override bool CanConvertTo(System.ComponentModel.ITypeDescriptorContext context, System.Type destinationType) {
                return baseConverter.CanConvertTo(context, destinationType);
            }
            
            public override object ConvertFrom(System.ComponentModel.ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value) {
                return baseConverter.ConvertFrom(context, culture, value);
            }
            
            public override object CreateInstance(System.ComponentModel.ITypeDescriptorContext context, System.Collections.IDictionary dictionary) {
                return baseConverter.CreateInstance(context, dictionary);
            }
            
            public override bool GetCreateInstanceSupported(System.ComponentModel.ITypeDescriptorContext context) {
                return baseConverter.GetCreateInstanceSupported(context);
            }
            
            public override PropertyDescriptorCollection GetProperties(System.ComponentModel.ITypeDescriptorContext context, object value, System.Attribute[] attributeVar) {
                return baseConverter.GetProperties(context, value, attributeVar);
            }
            
            public override bool GetPropertiesSupported(System.ComponentModel.ITypeDescriptorContext context) {
                return baseConverter.GetPropertiesSupported(context);
            }
            
            public override System.ComponentModel.TypeConverter.StandardValuesCollection GetStandardValues(System.ComponentModel.ITypeDescriptorContext context) {
                return baseConverter.GetStandardValues(context);
            }
            
            public override bool GetStandardValuesExclusive(System.ComponentModel.ITypeDescriptorContext context) {
                return baseConverter.GetStandardValuesExclusive(context);
            }
            
            public override bool GetStandardValuesSupported(System.ComponentModel.ITypeDescriptorContext context) {
                return baseConverter.GetStandardValuesSupported(context);
            }
            
            public override object ConvertTo(System.ComponentModel.ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value, System.Type destinationType) {
                if ((context != null)) {
                    if ((context.PropertyDescriptor.ShouldSerializeValue(context.Instance) == false)) {
                        return "";
                    }
                }
                return baseConverter.ConvertTo(context, culture, value, destinationType);
            }
        }
        
        // Embedded class to represent WMI system Properties.
        [TypeConverter(typeof(System.ComponentModel.ExpandableObjectConverter))]
        public class ManagementSystemProperties {
            
            private System.Management.ManagementBaseObject PrivateLateBoundObject;
            
            public ManagementSystemProperties(System.Management.ManagementBaseObject ManagedObject) {
                PrivateLateBoundObject = ManagedObject;
            }
            
            [Browsable(true)]
            public int GENUS {
                get {
                    return ((int)(PrivateLateBoundObject["__GENUS"]));
                }
            }
            
            [Browsable(true)]
            public string CLASS {
                get {
                    return ((string)(PrivateLateBoundObject["__CLASS"]));
                }
            }
            
            [Browsable(true)]
            public string SUPERCLASS {
                get {
                    return ((string)(PrivateLateBoundObject["__SUPERCLASS"]));
                }
            }
            
            [Browsable(true)]
            public string DYNASTY {
                get {
                    return ((string)(PrivateLateBoundObject["__DYNASTY"]));
                }
            }
            
            [Browsable(true)]
            public string RELPATH {
                get {
                    return ((string)(PrivateLateBoundObject["__RELPATH"]));
                }
            }
            
            [Browsable(true)]
            public int PROPERTY_COUNT {
                get {
                    return ((int)(PrivateLateBoundObject["__PROPERTY_COUNT"]));
                }
            }
            
            [Browsable(true)]
            public string[] DERIVATION {
                get {
                    return ((string[])(PrivateLateBoundObject["__DERIVATION"]));
                }
            }
            
            [Browsable(true)]
            public string SERVER {
                get {
                    return ((string)(PrivateLateBoundObject["__SERVER"]));
                }
            }
            
            [Browsable(true)]
            public string NAMESPACE {
                get {
                    return ((string)(PrivateLateBoundObject["__NAMESPACE"]));
                }
            }
            
            [Browsable(true)]
            public string PATH {
                get {
                    return ((string)(PrivateLateBoundObject["__PATH"]));
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\errlookup\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__errlookup_1_none_12.4.56.0_none_bd915165ebb3d586
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__errlookup_1_no-public-key_12.4.56.0_x-ww_60db5368
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_errlookup_1
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__errlookup_1_no-public-key_12.4.56.0_x-ww_60db5368
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__errlookup_1_no-public-key_12.4.56.0_x-ww_60db5368.manifest
XP_MANIFEST_PATH=manifests\x86__errlookup_1_no-public-key_12.4.56.0_x-ww_60db5368.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__errlookup_1_no-public-key_12.4.56.0_x-ww_60db5368.cat
XP_CATALOG_PATH=manifests\x86__errlookup_1_no-public-key_12.4.56.0_x-ww_60db5368.cat
XP_PAYLOAD_PATH=x86__errlookup_1_no-public-key_12.4.56.0_x-ww_60db5368
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_errlookup_1,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\errlookup\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__errlookup_1_none_12.4.56.0_none_bd915165ebb3d586
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__errlookup_1_no-public-key_12.4.56.0_x-ww_60db5368
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_errlookup_1
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__errlookup_1_no-public-key_12.4.56.0_x-ww_60db5368
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__errlookup_1_no-public-key_12.4.56.0_x-ww_60db5368.manifest
XP_MANIFEST_PATH=manifests\x86__errlookup_1_no-public-key_12.4.56.0_x-ww_60db5368.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__errlookup_1_no-public-key_12.4.56.0_x-ww_60db5368.cat
XP_CATALOG_PATH=manifests\x86__errlookup_1_no-public-key_12.4.56.0_x-ww_60db5368.cat
XP_PAYLOAD_PATH=x86__errlookup_1_no-public-key_12.4.56.0_x-ww_60db5368
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_errlookup_1,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\health\dll\Block_AbchCheck.cs ===
//
// Block_AbchCheck.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Healthcheck Module
// Xbox Online Service
//
// Common healthblock implementation.
//


using System;
using System.Collections.Specialized;

using xonline.common.config;
using xonline.common.metro;
using xonline.common.mgmt;
using xonline.common.service;

namespace xonline.common.health
{
    // --------------------------------------------------------------------------------------
    // AbchHealthBlock - initialize and check health of the ABCH web services.
    //
    // PARAMETERS:
    //
    // "puid" : 1 or more puids that exist in the Passport INT environment to perform a profile
    //          query on verify.
    //
    // "prodnetPuid" : 1 or more puids that exist in the Passport Production environment to
    //          perform a profile query on verify.
    //
    // --------------------------------------------------------------------------------------
    internal class AbchHealthBlock : IHealthBlock
    {
        public ResourceTypeEnum ResourceType
        {
            get { return ResourceTypeEnum.Remote; }
        }

        public void DoCheck(HealthBlockManager blockManager, NameValueCollection blockParams, HealthReport report)
        {
            // set output param immediately
            AbchReport myReport = new AbchReport();
            report.ExtendedReport = myReport;

            myReport.ABServiceUrl = Config.GetSetting(Setting.abch_abserviceUrl);
            myReport.SharingServiceUrl = Config.GetSetting(Setting.abch_sharingServiceUrl);
            myReport.BillingProxy = Config.GetSetting(Setting.billing_proxy);
            myReport.ConnectionPoolSize = Config.GetIntSetting(Setting.abch_getSoapConnectionPoolSize);
            myReport.GetMessengerBuddiesTimeout = Config.GetIntSetting(Setting.abch_getMessengerBuddiesTimeoutSeconds);

            string environment = Config.Environment;

            string[] puids = blockParams.GetValues(environment + "Puid");

            ulong puid = 0;

            if ( puids == null || puids.Length == 0 )
            {
                puids = blockParams.GetValues("puid");

                if ( puids == null || puids.Length == 0 )
                {
                    // no checks were able to be performed
                    report.HealthStatus = HealthStatusEnum.Yellow;
                    report.ErrorDetails = "No value specified for puid parameter.  Health status is unknown.";
                    return;
                }
            }

            Xom.Trace(XomAreaName.metro, LogLevel.L_HIGH, "AbchCheck: DoCheck: puids[0] = " + puids[0] );

            try
            {
                ABCHWrapper abch = new ABCHWrapper(1);

                puid = SafeConvert.ToUInt64(puids[0]);

                myReport.Puid = puid;

                Xom.Trace(XomAreaName.metro, LogLevel.L_HIGH, "AbchCheck.DoCheck: calling GetMessengerBuddiesAndGamertags for puid: 0x" + puid.ToString("x") );

                ushort gamertagCount = 0;
                ABCHContact[] contacts = abch.GetMessengerBuddiesAndGamertags((long) puid, ref gamertagCount);
                if ( contacts != null && contacts.Length > 0 )
                {
                    string[] buddyList = new string[contacts.Length];
                    for (int i=0; i < contacts.Length; i++)
                    {
                        buddyList[i] = "WLID: 0x" + contacts[i].PassportPuid.ToString("x");

                        if ( contacts[i].LivePuid != 0 )
                        {
                            buddyList[i] += "(userPuid: 0x" + contacts[i].LivePuid.ToString("x") + ")";
                        }
                        if ( !string.IsNullOrEmpty(contacts[i].GamerTag) )
                        {
                            buddyList[i] += " (gamertag: " + contacts[i].GamerTag + ")";
                        }
                        if ( !string.IsNullOrEmpty(contacts[i].ABCHDisplayName) )
                        {
                            buddyList[i] += " (displayName: " + contacts[i].ABCHDisplayName + ")";
                        }
                    }
                    myReport.BuddyList = buddyList;
                }
                else
                {
                    myReport.BuddyList = new string[] { };
                }
            }
            catch (Exception e)
            {
                report.HealthStatus = HealthStatusEnum.Red;
                report.ErrorDetails = string.Format("Failed to obtain Messenger buddy list for user: 0x{0:x}.\r\nException: {1}", puid, e.ToString());
                return;
            }

            // if we made it this far, things are good to go
            report.HealthStatus = HealthStatusEnum.Green;
        }
    }

    // --------------------------------------------------------------------------------------
    // AbchReport - health report
    // --------------------------------------------------------------------------------------
    public class AbchReport : IExtendedHealthReport
    {
        public string ABServiceUrl;
        public string SharingServiceUrl;
        public string BillingProxy;
        public int ConnectionPoolSize;
        public int GetMessengerBuddiesTimeout;
        public ulong Puid;
        public string[] BuddyList;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\health\dll\Block_AccelerationInfo.cs ===
using System;
using System.Collections.Specialized;

using xonline.common.config;
using xonline.common.service;

namespace xonline.common.health
{
    /// <summary>
    /// Summary description for AccelerationInfo
    /// </summary>
    public class AccelerationInfoHealthBlock : IHealthBlock
    {
        private readonly ResourceTypeEnum resourceType = ResourceTypeEnum.Remote;

        public ResourceTypeEnum ResourceType
        {
            get { return resourceType; }
        }

        public void DoCheck(HealthBlockManager blockManager, NameValueCollection blockParams, HealthReport report)
        {
            try
            {
                report.HealthStatus = HealthStatusEnum.Green;
                
                string[] clusters = blockParams.GetValues("cluster");

                foreach (string cluster in clusters)
                {
                    string[] servers = Config.GetServerListByInterface(cluster);

                    Acceleration xb = new Acceleration(cluster);
                    uint[] hrs = xb.Health();

                    if (servers.Length != hrs.Length)
                    {
                        throw new ApplicationException("AccelerationInfoHealthBlock: config server list does not match Acceleration server list for cluster: " + cluster);
                    }

                    uint cFailed = 0;
                   
                    for (uint iServer = 0; iServer < hrs.Length; iServer++)
                    {
                        if (HResult.Failed(hrs[iServer]))
                        {
                            cFailed++;
                            report.ErrorDetails += string.Format("\r\n{0} server {1} returned hr = {2}.", cluster, servers[iServer], (HResult)hrs[iServer]);
                        }
                    }

                    HealthStatusEnum clusterStatus = (cFailed >= hrs.Length) ? HealthStatusEnum.Red : (cFailed > 0) ? HealthStatusEnum.Yellow : HealthStatusEnum.Green;

                    report.ErrorDetails += string.Format("\r\n\r\n{0} cluster reports status {1}.\r\n", cluster, clusterStatus);
                    
                    report.HealthStatus = HealthReport.DowngradeStatus(report.HealthStatus, clusterStatus);
                }                    
            }
            catch (Exception e) 
            {
                report.HealthStatus = HealthStatusEnum.Red;
                report.ErrorDetails = e.ToString();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\health\dll\Block_CTPTransaction.cs ===
using System;
using System.Collections.Specialized;

using xonline.common.billing;
using xonline.common.config;
using System.Xml.Serialization;


namespace xonline.common.health
{
    internal class CTPTransaction : IHealthBlock
    {
        public ResourceTypeEnum ResourceType
        {
            get { return ResourceTypeEnum.Remote; }
        }
        /// <summary>
        /// Does the health check
        /// </summary>
        /// <param name="blockManager"></param>
        /// <param name="blockParams"></param>
        /// <param name="report"></param>
        public void DoCheck(HealthBlockManager blockManager, NameValueCollection blockParams, HealthReport report)
        {

            CTPTransactionReport myReport = new CTPTransactionReport();

            report.ExtendedReport = myReport;

            
            if (CTPTransactionServiceWrapper.CTPConnecttoBilling == false)
            {
                myReport.HealthStatus = HealthStatusEnum.Yellow;

                myReport.ErrorDetails = "CTP Billing connectivity is disabled -- if a billing 1-box is present, check the value of the billing_ctpconnectbilling setting!";
                
                return;
            }

            CTPTransactionServiceWrapper.Init();

            CTPTransactionServiceWrapper ctp = new CTPTransactionServiceWrapper();

            myReport.ClientCertSubject = Config.GetSetting(Setting.dmp_clientCertSubject);

            myReport.WebServiceUrl = CTPTransactionServiceWrapper.CTPPurchaseTransactionServiceUrl;

            // first, perform a TestConnection request to initialize connectivity
            try
            {
                string testConnection=ctp.TestConnection("healthcheck");
            }
            catch (Exception e)
            {
                myReport.HealthStatus = HealthStatusEnum.Red;

                myReport.ErrorDetails = "TestConnection failed!  Exception: " + e.Message;
                
                return;
            }

            report.HealthStatus = HealthStatusEnum.Green;
        }
    }
    // --------------------------------------------------------------------------------------
    // CTPTransactionReport - health report
    // --------------------------------------------------------------------------------------
    public class CTPTransactionReport : IExtendedHealthReport
    {
        public string WebServiceUrl;

        public string ClientCertSubject;

        public string ErrorDetails;

        [XmlAttribute]
        public string Name;

        [XmlAttribute]
        public HealthStatusEnum HealthStatus = HealthStatusEnum.Green;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\health\dll\Block_DatabaseInfo.cs ===
using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Data;
using System.Data.SqlClient;
using System.Xml.Serialization;

using Microsoft.Webstore.WstClient;

using xonline.common.config;
using xonline.common.sql.sqlclient;

namespace xonline.common.health
{
    /// <summary>
    /// Summary description for DatabaseInfo
    /// </summary>
    public class DatabaseInfoHealthBlock : IHealthBlock
    {
        internal class TitleBucket
        {
            private uint _titleId;
            private uint _bucket;

            internal TitleBucket(uint titleId, uint bucket)
            {
                _titleId = titleId;
                _bucket  = bucket;
            }

            internal uint TitleId
            {
                get { return _titleId; }
            }

            internal uint Bucket
            {
                get { return _bucket; }
            }
        }

        private readonly ResourceTypeEnum resourceType = ResourceTypeEnum.Remote;

        public ResourceTypeEnum ResourceType
        {
            get { return resourceType; }
        }

        private DatabaseInfo.Status CheckStatus(IDataReader reader)
        {
            DatabaseInfo.Status status = new DatabaseInfo.Status();

            try
            {
                if (! reader.Read())
                {
                    status.HealthStatus = HealthStatusEnum.Red;
                    status.ErrorDetails = "No results returned from query";
                }

                else
                {
                    status.Size = reader.GetString(reader.GetOrdinal("db_size")).Trim();

                    // parse the status column which looks like Name=Value,Name=Value,...
                    string[] nameValues = reader.GetString(reader.GetOrdinal("status")).Split(',');

                    foreach (string nameValue in nameValues)
                    {
                        int index = nameValue.IndexOf('=');
                        string name  = index == -1 ? nameValue.Trim() : nameValue.Substring(0, index).Trim();
                        string value = index == -1 ? null : nameValue.Substring(index + 1).Trim();

                        if (string.Compare(name, "Status", true) == 0)
                            status.Online = string.Compare(value, "ONLINE", true) == 0;
                        else if (string.Compare(name, "Version", true) == 0)
                            status.Version = value;
                        else if (string.Compare(name, "UserAccess") == 0)
                            status.Access = status.Access == null ? value : status.Access + ", " + value;
                        else if (string.Compare(name, "Updateability", true) == 0)
                        {
                            status.Access = status.Access == null ? value : status.Access + ", " + value;
                            if (value.Contains("READ_ONLY")) status.HealthStatus = HealthStatusEnum.Yellow;
                        }
                    }
                }
            }

            catch (Exception e)
            {
                status.HealthStatus = HealthStatusEnum.Red;
                status.ErrorDetails = e.ToString();
            }

            return status;
        }

        private DatabaseInfo.Partition CheckPartition(
            string databaseName, string name, object o
        )
        {
            DatabaseInfo.Partition partition = new DatabaseInfo.Partition(name);
            TitleBucket titleBucket = (TitleBucket) o;

            // Fix up the database name. Convert things like int\npdb to just npdb
            if (databaseName.Contains("\\"))
            {
                string[] splitDatabaseName = databaseName.Split('\\');

                // The database name is the last entry in the list
                databaseName = splitDatabaseName[ splitDatabaseName.Length - 1 ];
            }

            try
            {
                using (SqlClient command = new SqlClient(databaseName, titleBucket.TitleId, titleBucket.Bucket))
                {
                    command.StoredProc = "sp_helpdb";
                    command.AddParameter("@dbname", databaseName);

                    using (SqlDataReader reader = command.Execute())
                    {
                        partition.Status = CheckStatus(reader);
                    }
                }
            }

            catch (Exception e)
            {
                partition.HealthStatus = HealthStatusEnum.Red;
                partition.ErrorDetails = e.ToString();
            }

            return partition;
        }

        private DatabaseInfo.Partition CheckWebstorePartition(
            string databaseName, string name, object o
        )
        {
            DatabaseInfo.Partition partition = new DatabaseInfo.Partition(name);
            uint number = (uint) o;

            try
            {
                using (WstConnection connection = new WstConnection(ConfigUtil.GetWebstoreApp(databaseName)))
                {
                    connection.Open();

                    using (WstCommand command = new WstCommand(string.Empty, connection, (int) WstFailoverMode.PrimaryThenSecondary))
                    {
                        command.PartitionType = WstPartitionType.Physical;
                        command.Partition = (int) number;
                        command.CommandText = "DECLARE @dbname NVARCHAR(128) SET @dbname = DB_NAME() exec sp_helpdb @dbname";

                        using (WstDataReader reader = command.ExecuteReader())
                        {
                            partition.Status = CheckStatus(reader);
                        }
                    }
                }

                partition.HealthStatus = partition.Status.HealthStatus;
            }

            catch (Exception e)
            {
                partition.ErrorDetails = e.ToString();
                partition.HealthStatus = HealthStatusEnum.Red;
            }

            return partition;
        }


        private void CheckPartitions(
            CheckPartitionDelegate           checkDelegate,
            DatabaseInfo.Database            database,
            SortedDictionary<string, object> dictionary
        )
        {
            string version = null;

            foreach (KeyValuePair<string, object> keyValuePair in dictionary)
            {
                DatabaseInfo.Partition partition = checkDelegate(
                    database.Name, keyValuePair.Key, keyValuePair.Value
                );

                // check for version mismatches but do not overwrite any
                // existing errors from the partition check we did above

                if (partition.HealthStatus == HealthStatusEnum.Green)
                {
                    if (version == null)
                        version = partition.Status.Version;
                    else if (partition.Status.Version != version)
                    {
                        if (partition.HealthStatus == HealthStatusEnum.Green)
                        {
                            partition.HealthStatus = HealthStatusEnum.Yellow;
                            partition.ErrorDetails = "Database version mismatch";
                        }
                    }
                }

                // add partition and track most severe partition error
                database.AddPartition(partition);
                database.HealthStatus = HealthReport.DowngradeStatus(database.HealthStatus, partition.HealthStatus);
            }
        }

        private DatabaseInfo.Database CheckNonPartitionedDatabase(IVirtualInterfaceInfo viInfo)
        {
            return CheckNonPartitionedDatabase(viInfo.VirtualInterface, viInfo.WebstoreApp, true);
        }
        private DatabaseInfo.Database CheckNonPartitionedDatabase(IInterfaceInfo iInfo)
        {
            return CheckNonPartitionedDatabase(iInfo.Interface, iInfo.DBName, false);
        }

        private DatabaseInfo.Database CheckNonPartitionedDatabase(
            string interfaceName,
            string databaseName,
            bool   isVirtual
        )
        {
            DatabaseInfo.Database database = new DatabaseInfo.Database(databaseName);
            database.HasVirtualInterface = isVirtual;

            try
            {
                using (SqlClient command = new SqlClient(interfaceName, isVirtual))
                {
                    database.ConnectionString = command.Command.Connection.ConnectionString;

                    command.StoredProc = "sp_helpdb";
                    command.AddParameter("@dbname", databaseName);

                    using (SqlDataReader reader = command.Execute())
                    {
                        database.Status = CheckStatus(reader);
                    }
                }

                database.HealthStatus = database.Status.HealthStatus;
            }

            catch (Exception e)
            {
                database.HealthStatus = HealthStatusEnum.Red;
                database.ErrorDetails = e.ToString();
            }

            return database;
        }

        private SortedDictionary<string, object> GetBucketServers(
            string databaseName
        )
        {
            SortedDictionary<string, object> dictionary = new SortedDictionary<string, object>();

            using (SqlClient cmd = new SqlClient(Interface.npdb))
            {
                // there is no good config sproc for getting the
                // servers and buckets for  a  database,  select

                cmd.StoredProc = "p_config_get_interface_all_buckets";
                cmd.AddParameter("@vc_environment", Config.Environment);
                cmd.AddParameter("@vc_interface", databaseName);

                using (SqlDataReader reader = cmd.Execute())
                {
                    int titleIdOrdinal  = reader.GetOrdinal("i_title_id");
                    int bucketOrdinal   = reader.GetOrdinal("i_bucket");
                    int serverOrdinal   = reader.GetOrdinal("vc_server");

                    while (reader.Read())
                    {
                        string serverName = reader.GetString(serverOrdinal);
                        if (dictionary.ContainsKey(serverName)) continue;

                        dictionary.Add(
                            reader.GetString(serverOrdinal),

                            new TitleBucket(
                                (uint) reader.GetInt32(titleIdOrdinal),
                                (uint) reader.GetInt32(bucketOrdinal)
                            )
                        );
                    }
                }
            }

            return dictionary;
        }


        private DatabaseInfo.Database CheckPartitionedDatabase(
            string databaseName
        )
        {
            DatabaseInfo.Database database = new DatabaseInfo.Database(databaseName);
            database.IsPartitioned = true;

            try
            {
                // create list of the partitions we will check  and
                // pass that to common code that  spins  partitions

                SortedDictionary<string, object> dictionary = GetBucketServers(databaseName);

                database.NumPartitions = dictionary.Count;
                CheckPartitions(CheckPartition, database, dictionary);
            }

            catch (Exception e)
            {
                database.HealthStatus = HealthStatusEnum.Red;
                database.ErrorDetails = e.ToString();
            }

            return database;
        }

        private DatabaseInfo.Database CheckWebstoreDatabase(
            string databaseName
        ) {
            DatabaseInfo.Database database = new DatabaseInfo.Database(databaseName);
            database.IsWebstore = database.IsPartitioned = database.HasVirtualInterface = true;

            try
            {
                using (WstConnection connection = new WstConnection(ConfigUtil.GetWebstoreApp(databaseName)))
                {
                    connection.Open();
                    database.NumPartitions = connection.SqlPartitions.Count;
                    connection.Close();
                }

                // create list of the partitions we will check  and
                // pass that to common code that  spins  partitions

                SortedDictionary<string, object> dictionary = new SortedDictionary<string, object>();
                for (uint i = 0; i < database.NumPartitions; i++) dictionary.Add(i.ToString(), i);
                CheckPartitions(CheckWebstorePartition, database, dictionary);
            }

            catch (Exception e)
            {
                database.ErrorDetails = e.ToString();
                database.HealthStatus = HealthStatusEnum.Red;
            }

            return database;
        }

        public void DoCheck(HealthBlockManager blockManager, NameValueCollection blockParams, HealthReport report)
        {

            // get ourselves an extended report right up  front  so
            // they can see something if we  die  on  an  exception

            // no databases listed in the  parameter  means  a  bad
            // health check config,  no necessarily a bad component

            string[] databaseNames = blockParams.GetValues("database");

            if ( databaseNames == null )
            {
                report.ErrorDetails = "No databases specified in the health mapping parameters";
                report.HealthStatus = HealthStatusEnum.Yellow;
                return;
            }

            DatabaseInfo.Database database = null;
            DatabaseInfo databaseInfo = new DatabaseInfo();
            HealthStatusEnum blockStatus = HealthStatusEnum.Green;

            // spin through databases.  check each for connectivity
            // and then see if we can execute  a  stored  procedure

            if (databaseNames != null)
            {
                foreach (string databaseName in databaseNames)
                {
                    // try to determine the type of database we are
                    // going to check using the ndpb config  params

                    IVirtualInterfaceInfo virtualInterfaceInfo;

                    bool isVirtual   = Config.TryGetVirtualInterface(databaseName, out virtualInterfaceInfo);
                    bool isWebstore  = isVirtual ? virtualInterfaceInfo.Protocol == "webstore" : false;
                    uint bucketCount = 0;

                    if (isWebstore)
                        database = CheckWebstoreDatabase(databaseName);
                    else if ((! isVirtual) && Config.TryGetBucketCount(databaseName, out bucketCount))
                        database = CheckPartitionedDatabase(databaseName);
                    else
                    {
                        if ( isVirtual )
                        {
                            database = CheckNonPartitionedDatabase(virtualInterfaceInfo);
                        }
                        else
                        {
                            IInterfaceInfo interfaceInfo = Config.GetSingleInterface(databaseName);
                            database = CheckNonPartitionedDatabase(interfaceInfo);
                        }
                    }

                    blockStatus = HealthReport.DowngradeStatus(blockStatus, database.HealthStatus);
                    databaseInfo.AddDatabase(database);

                    if (database.HealthStatus != HealthStatusEnum.Green)
                    {
                        if (! string.IsNullOrEmpty(report.ErrorDetails)) report.ErrorDetails += "\r\n";
                        report.ErrorDetails += string.Format("Database '{0}' has reported an error", database.Name);

                        if (database.IsPartitioned)
                        {
                            report.ErrorDetails += " on partition(s):";

                            if (database.Partitions == null)
                            {
                                report.ErrorDetails += " (null)";
                            }
                            else
                            {
                                foreach (DatabaseInfo.Partition partition in database.Partitions)
                                {
                                    if (partition.HealthStatus == HealthStatusEnum.Green) continue;
                                    report.ErrorDetails += " " + partition.Name;
                                }
                            }
                        }
                    }
                }
            }

            report.HealthStatus = blockStatus;
            report.ExtendedReport = databaseInfo;

            if (report.HealthStatus != HealthStatusEnum.Green)
            {
                report.ErrorDetails += "\r\nRun healthcheck and check extended healthcheck information for details";
            }
        }

        private delegate DatabaseInfo.Partition CheckPartitionDelegate (string databaseName, string name, object o);
    }

    /// <summary>
    /// Placeholder for future extended health report information.
    /// </summary>
    ///


    public class DatabaseInfo : IExtendedHealthReport
    {
        public class Status {
            public bool   Online;
            public string Access;
            public string Version;
            public string Size;
            public string ErrorDetails;

            [XmlIgnore]
            public HealthStatusEnum HealthStatus = HealthStatusEnum.Green;
        }

        public class Partition
        {
            public Partition() {}
            public Partition(string name) { Name = name; }

            [XmlAttribute]
            public string Name;
            [XmlAttribute]
            public HealthStatusEnum HealthStatus = HealthStatusEnum.Green;

            public Status Status;
            public string ErrorDetails;
        }

        public class Database
        {
            public Database() : base() { }
            public Database(string name) { Name = name; }

            [XmlAttribute]
            public string Name;
            [XmlAttribute]
            public HealthStatusEnum HealthStatus = HealthStatusEnum.Green;

            public bool IsWebstore;
            public string ConnectionString;
            public bool IsPartitioned;
            public bool HasVirtualInterface;
            public int  NumPartitions;

            public List<Partition> Partitions = null;
            public Status Status;
            public string ErrorDetails;

            public void AddPartition(Partition partition)
            {
                if (Partitions == null) Partitions = new List<Partition>();
                Partitions.Add(partition);
            }
        }

        public List<DatabaseInfo.Database> Databases;

        public void AddDatabase(Database database)
        {
            if (Databases == null) Databases = new List<DatabaseInfo.Database>();
            Databases.Add(database);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\health\dll\Block_CertInfo.cs ===
// 
// CertInfo.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Healthcheck Module
// Xbox Online Service
//
// This module implements a certificate common healthblock
// All the checks in the module are *local*
//
// Notes:
//  One could have used a X509CertificateValidator class. Unfortunately
//  none of the existing functionality provided by that class is readily
//  usable for our purposes. It is probably worth looking at it again if
//  implementing a network health check on proper certificate chaining.
//
//  The internal certificate member is of type X509Certificate2 as this
//  allows better access to certain properties (such as DateTime).
//
//  A note on how to treat non existance on checks that assume existence
//  of the certificate. There are two choices:
//    - treat existence as a prerequisite, so if the cert is not there
//    it's considered expired :-). This allows to effectively skip
//    existence blocks if other blocks are present. One could argue
//    this check should be hardcoded.
//    - arguably someone can make expiry mustpass, but existance CouldFail
//    trying to capture the semantics of requring a valid cert only if it
//    exists.
//
//  The code implements the later, mostly due to programmer preference.
//  The thinking was that all checks must be explicit, hence the former
//  argument was not seen as a strong one. In addition, checks can return
//  a fatal result which will stop further processing. Currently the
//  existence check does so. There is no guarantee that the existence check
//  comes first. Upon further review we decided to add defaults (and the 
//  ability to skip checks that might come from defaults with that) as a
//  mechanism to allow developers to easily use this blocks. That doesn't
//  change the requirement to account for non existence of the cert in
//  other checks.
//
//  Notes on validators:
//    - PrivateKey - the original scope for this check was to catch the
//    case where the key file is improperly ACL'ed or missing. Basic
//    testing has revelead that existence check fails too. The code
//    is still useful as a Report feature for troubleshooting though.
//
//    - Verify - this allows a modicum of local chain validation. Normally
//    we use certificates for authentication. Hence the validation
//    should really run on the *other party*, so local validation is not
//    really full proof. But X508Certificate2.Validate() makes it so
//    easily done so, given that arguably one can rely on the fact that
//    all of our servers are usually built similarly, a validation
//    failure on the client can indicate indicates a potential problem on
//    the server as well. However, experience has shown that chain
//    validations problems occur when [intermediate] trust roots are
//    not properly installed. This problem can potentially be solved better
//    by checking existence for known roots.
//
//

using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Reflection;
using System.Security.Cryptography.X509Certificates;
using System.Text;
using System.Xml;
using System.Xml.Serialization;

using xonline.common.config;
using xonline.common.utilities2;

namespace xonline.common.health
{
    // ------------------------------------------------------------------------------------
    // Parameter description 
    // A certinfo health block requires a certificate ID, a list of certificate properties
    // and a list of certificate checks
    // A certificate ID can be one of the following:
    //      - SubjectName - this is the name in the Subject field of the certificate
    //      - SubjectNameSetting - this is the NPDB setting that contains the subject name
    //
    // The only certificate property supported as of now is the store location:
    //      - Store - User/Machine
    // 
    // A check can be defined as
    //      - MustPass - the health check will fail if this fails
    //      - CouldFail - the health check will show yellow if this fails
    //      - Report - this is for reporting purposes only
    // 
    // The list of checks we support are
    //      - UserStore - the cert exists in the User Store
    //      - MachineStore - the cert exists in the Machine Store
    //      - Expiry - the cert has a valid date
    //      - PrivateKey - the cert has a private key attached and accessible
    //
    // Here are the two XML simplified formats
    // 
    // <vc_params>SubjectName = int-rps.xboxlive.com, Store = Machine, Existence = MustPass, Expiry = CouldFail, PrivateKey = Report</vc_params>
    // <vc_params>SubjectNameSetting = ups_clientCertName, Store = User, Existence = MustPass, Expiry = MustPass, PrivateKey = CouldFail</vc_params>
    // 
    // ------------------------------------------------------------------------------------
    static class CertificateCheckFactory
    {
        public static List<CertificateCheck> CreateCertificateChecks(X509Certificate2 Certificate)
        {
            //
            // in normal cases we don't have more than 4 checks
            //
            List<CertificateCheck> checkList = new List<CertificateCheck>(4);

            //
            // The defaults for the checks are described below
            //
            checkList.Add(new ExistenceCertificateCheck(Certificate, CertificateCheck.CheckTypeEnum.MustPass));
            checkList.Add(new ExpiryCertificateCheck(Certificate, CertificateCheck.CheckTypeEnum.MustPass));
            checkList.Add(new VerifyCertificateCheck(Certificate, CertificateCheck.CheckTypeEnum.MustPass));
            checkList.Add(new PrivateKeyCertificateCheck(Certificate, CertificateCheck.CheckTypeEnum.CouldFail));

            return checkList;
        }

        public static void UpdateCertificateChecks(List<CertificateCheck> checkList,
                                                   string Type,
                                                   string[] Parameters)
        {
            CertificateCheck check = null;
            string Parameter = null;
            CertificateCheck.CheckTypeEnum checkType = CertificateCheck.CheckTypeEnum.Undefined;

            //
            // if there is more than one Parameter this is an error
            //
            if (Parameters.Length != 1)
            {
                //
                // This will result in an invalid paramter error
                //
                Parameter = String.Format("Duplicated parameters: {0}",
                                          EnumerableFormatter.FormatEnumerable(Parameters));
            }
            else
            {
                Parameter = Parameters[0];
            }

            switch (Parameter.Trim().ToLower())
            { 
                case Value_MustPass:
                    checkType = CertificateCheck.CheckTypeEnum.MustPass;
                    break;

                case Value_CouldFail:
                    checkType = CertificateCheck.CheckTypeEnum.CouldFail;
                    break;

                case Value_ReportOnly:
                    checkType = CertificateCheck.CheckTypeEnum.ReportOnly;
                    break;

                case Value_Skip:
                    checkType = CertificateCheck.CheckTypeEnum.Skip;
                    break;

                default:
                    //
                    // could leave the default, but don't want silent failures
                    //
                    checkType = CertificateCheck.CheckTypeEnum.Undefined;
                    break;
            }

            //
            // if we decide to increase the number of checks, having a
            // mapping from name to objects may be better. Seems overkill
            // for now.
            //
            if (checkType != CertificateCheck.CheckTypeEnum.Undefined)
            {
                switch (Type.Trim().ToLower())
                {
                    case Value_Existence:
                        check = checkList.Find(delegate(CertificateCheck c)
                                                { return Object.ReferenceEquals(c.GetType(), typeof(ExistenceCertificateCheck)); });
                        break;
                    case Value_Expiry:
                        check = checkList.Find(delegate(CertificateCheck c)
                                                { return Object.ReferenceEquals(c.GetType(), typeof(ExpiryCertificateCheck)); });
                        break;
                    case Value_Verify:
                        check = checkList.Find(delegate(CertificateCheck c)
                                                { return Object.ReferenceEquals(c.GetType(), typeof(VerifyCertificateCheck)); });
                        break;
                    case Value_PrivateKey:
                        check = checkList.Find(delegate(CertificateCheck c)
                                                { return Object.ReferenceEquals(c.GetType(), typeof(PrivateKeyCertificateCheck)); });
                        break;
                    default:
                        // check is null;
                        break;
                }
            }

            if (check != null)
            {
                //
                // Update the check type
                //
                check.CheckType = checkType;
            }
            else
            {
                //
                // add an invalid block check type so we report the failure
                //
                check = new InvalidBlockCertificateCheck(Type, Parameter);
                checkList.Add(check);
            }
        }

        //
        // values - note they are lowercased to match the checks.
        //
        private const string Value_MustPass = "mustpass";
        private const string Value_CouldFail = "couldfail";
        private const string Value_ReportOnly = "reportonly";
        private const string Value_Skip = "skip";

        private const string Value_Existence = "existence";
        private const string Value_Expiry = "expiry";
        private const string Value_PrivateKey = "privatekey";
        private const string Value_Verify = "verify";
    }

    public class CertInfo : IHealthBlock
    {
        public ResourceTypeEnum ResourceType
        {
            get { return ResourceTypeEnum.Local; }
        }

        public void DoCheck(HealthBlockManager blockManager,
                            NameValueCollection blockParams,
                            HealthReport report)
        {
            string SubjectName = null;
            bool userStore = false;
            X509Certificate certificate = null;
            Exception certificateException = null;

            CertInfoReport myReport = new CertInfoReport();
        
            report.ExtendedReport = myReport;

            //
            // we trim the subject names, even if this means potential
            // loss of functionality. Names with leading or trailing spaces
            // are totally uncommon. If it happens, remove the trim call.
            //
            if (blockParams[Keyword_SubjectName] != null)
            {
                SubjectName = blockParams[Keyword_SubjectName].Trim();
            }
            else if (blockParams[Keyword_SubjectNameSetting] != null)
            {
                try
                {
                    SubjectName = Config.GetSetting(blockParams[Keyword_SubjectNameSetting].Trim()).Trim();
                }
                catch (Exception e)
                {
                    report.ErrorDetails = String.Format("Cannot retrieve SubjectName from {0}\n. Exception: {1}",
                                                        blockParams[Keyword_SubjectNameSetting],
                                                        e);
                    SubjectName = null;
                }
            }

            if (SubjectName == null)
            {
                //
                // Taking servers out of production because of an operator error
                // seems too harsh.
                //
                report.ErrorDetails += "SubjectName is not specified";
                report.HealthStatus = HealthStatusEnum.Yellow;
                return;
            }

            //
            // Future improvement: Ideally we should have a store enumaration here.
            // When the CertUtil gets upgraded this should be too.
            //
            if (blockParams[Keyword_Store] != null)
            {
                if (String.Equals(blockParams[Keyword_Store].Trim().ToLower(), Value_User, StringComparison.OrdinalIgnoreCase))
                {
                    userStore = true;
                }
                else if (String.Equals(blockParams[Keyword_Store].Trim().ToLower(), Value_Machine, StringComparison.OrdinalIgnoreCase))
                {
                    userStore = false;
                }
                else
                {
                    report.ErrorDetails = "Cannot retrieve Store type from the block parameters.\n";
                    report.HealthStatus = HealthStatusEnum.Yellow;
                    return;
                }
            }


            //
            // start with a known good values - Green is optimistic, but
            // helps bootstrapping.
            //
            StringBuilder sb = new StringBuilder();
            report.HealthStatus = HealthStatusEnum.Green;

            //
            // get the certificate (defaults to machine for now if none specified)
            //
            try
            {
                if( userStore )
                {
                    certificate = CertUtil.GetCurrentUserCertificate(SubjectName);
                }
                else
                {
                    certificate = CertUtil.GetLocalMachineCertificate(SubjectName);
                }
            }
            catch (Exception e)
            {
                //
                // the validators need do their part on a null certificate
                //
                certificate = null;
                certificateException = e;
            }

            myReport.SerializableCertificate = new SerializableX509Certificate2();
            myReport.HealthBlockId = SubjectName;
            myReport.HealthBlockStore = blockParams[Keyword_Store];

            if (certificate != null)
            {
                myReport.SerializableCertificate.Certificate = new X509Certificate2(certificate);
            }

            if (certificateException != null)
            {
                myReport.SerializableCertificate.CertificateException = certificateException;
            }

            List<CertificateCheck> checkList = 
                CertificateCheckFactory.CreateCertificateChecks(myReport.SerializableCertificate.Certificate);

            for(int i = 0; i < blockParams.Count; i++)
            {
                if (String.Equals(blockParams.GetKey(i), Keyword_SubjectName, StringComparison.OrdinalIgnoreCase) ||
                    String.Equals(blockParams.GetKey(i), Keyword_SubjectNameSetting, StringComparison.OrdinalIgnoreCase) ||
                    String.Equals(blockParams.GetKey(i), Keyword_Store, StringComparison.OrdinalIgnoreCase))
                {
                    //
                    // these keywords do not correspond to validators
                    //
                    continue;
                }
                CertificateCheckFactory.UpdateCertificateChecks(checkList,
                                                                blockParams.GetKey(i),
                                                                blockParams.GetValues(i));
            }

            foreach(CertificateCheck check in checkList)
            {
                string ErrorDetails = null;

                CertificateCheck.CheckResultEnum result = check.PerformCheck(out ErrorDetails,
                                                                             myReport);

                report.HealthStatus = check.UpdateHealthStatus(report.HealthStatus, result);

                if (ErrorDetails != null)
                {
                    sb.AppendLine(ErrorDetails);
                }
            }

            report.ErrorDetails = sb.ToString();
        }

        //
        // keywords
        //
        private const string Keyword_SubjectName          = "SubjectName";
        private const string Keyword_SubjectNameSetting   = "SubjectNameSetting";
        private const string Keyword_Store                = "Store";

        private const string Value_Machine                = "machine";
        private const string Value_User                   = "user";
    }

    abstract class CertificateCheck
    {
        public enum CheckTypeEnum
        {
            Undefined,
            MustPass,
            CouldFail,
            ReportOnly,
            Skip
        }

        public enum CheckResultEnum
        {
            Success,
            Warning,
            Failure
        }

        public CheckTypeEnum CheckType
        {
            get
            {
                return _checkType;
            }
            set
            {
                _checkType = value;
            }
        }

        public CertificateCheck(X509Certificate2 Certificate, CheckTypeEnum CheckType)
        {
            _certificate = Certificate;

            _checkType = CheckType;
        }

        public abstract CheckResultEnum PerformCheck(out string ErrorDetailsString,
                                                     CertInfoReport CIReport);


        public HealthStatusEnum UpdateHealthStatus(HealthStatusEnum CurrentHealthStatus,
                                                   CheckResultEnum Result)
        {
            HealthStatusEnum newStatus = CurrentHealthStatus;

            //
            // This logic is global
            //  Failure -> Red if Must Pass or otherwise Yellow if not already Red
            //  Warning -> if MustPuss/CouldFail Yellow if not already Red
            //  Success -> Preserve current status
            //
            if (Result == CheckResultEnum.Failure)
            {
                if (_checkType == CheckTypeEnum.MustPass)
                {
                    newStatus = HealthStatusEnum.Red;
                }

                if (_checkType == CheckTypeEnum.CouldFail)
                {
                    if (CurrentHealthStatus == HealthStatusEnum.Green)
                    {
                        newStatus = HealthStatusEnum.Yellow;
                    }
                }
            }
            else if (Result == CheckResultEnum.Warning)
            {
                if ((_checkType == CheckTypeEnum.CouldFail) ||
                     (_checkType == CheckTypeEnum.MustPass))
                {
                    if (CurrentHealthStatus == HealthStatusEnum.Green)
                    {
                        newStatus = HealthStatusEnum.Yellow;
                    }
                }
            }
            // else nothing

            return newStatus;
        }

        protected X509Certificate2 _certificate;
        protected CheckTypeEnum    _checkType;
    }

    class ExistenceCertificateCheck : CertificateCheck
    {
        public ExistenceCertificateCheck(X509Certificate2 Certificate,
                                         CheckTypeEnum CheckType) : base(Certificate, CheckType) { }

        public override CheckResultEnum PerformCheck(out string ErrorDetailsString,
                                                     CertInfoReport CIReport)
        {
            ErrorDetailsString = null;
            CheckResultEnum result = CheckResultEnum.Success;

            if (_checkType == CheckTypeEnum.Skip)
            {
                return result;
            }

            if (_certificate == null)
            {
                ErrorDetailsString = "Existence check: Certificate is not present.";
                result = CheckResultEnum.Failure;
            }

            return result;
        }
    }

    class ExpiryCertificateCheck : CertificateCheck
    {
        public ExpiryCertificateCheck(X509Certificate2 Certificate,
                                      CheckTypeEnum CheckType) : base(Certificate, CheckType) { }

        public override CheckResultEnum PerformCheck(out string ErrorDetailsString,
                                                     CertInfoReport CIReport)
        {
            ErrorDetailsString = null;
            CheckResultEnum result = CheckResultEnum.Success;

            if (_checkType == CheckTypeEnum.Skip)
            {
                return result;
            }

            if (_certificate != null)
            {
                DateTime current = DateTime.Now;
                DateTime notAfter = _certificate.NotAfter;
                DateTime notBefore = _certificate.NotBefore;

                if ((current < notBefore) || (current > notAfter))
                {
                    result = CheckResultEnum.Failure;

                    StringBuilder sb = new StringBuilder("Expiry check: Valid from: ");
                    sb.Append(notBefore.ToString());
                    sb.Append(". Valid to: ");
                    sb.Append(notAfter.ToString());
                    sb.AppendLine(".");
                    ErrorDetailsString = sb.ToString();
                }
                else
                {
                    TimeSpan ExpiryGracePeriod = new TimeSpan(30, 0, 0, 0); // 30 days 
                    DateTime delta = current.Add(ExpiryGracePeriod);

                    if (delta > notAfter)
                    {
                        result = CheckResultEnum.Warning;

                        StringBuilder sb = new StringBuilder("Expiry check: Expiry date ");
                        sb.Append(notAfter.ToString());
                        sb.Append(" is less than ");
                        sb.Append(ExpiryGracePeriod.Days.ToString());
                        sb.AppendLine(" days in the future.");
                        ErrorDetailsString = sb.ToString();
                    }
                }
            }
            // else nothing

            return result;
        }
    }

    class VerifyCertificateCheck : CertificateCheck
    {
        public VerifyCertificateCheck(X509Certificate2 Certificate,
                                      CheckTypeEnum CheckType)
            : base(Certificate, CheckType) { }

        public override CheckResultEnum PerformCheck(out string ErrorDetailsString,
                                                     CertInfoReport CIReport)
        {
            ErrorDetailsString = null;
            CheckResultEnum result = CheckResultEnum.Success;

            if (_checkType == CheckTypeEnum.Skip)
            {
                return result;
            }

            if (_certificate != null)
            {
                try
                {
                    if (!_certificate.Verify())
                    {
                        //
                        // unfortunately this is the best we get apparently.
                        //
                        result = CheckResultEnum.Failure;
                        ErrorDetailsString = "Verify check: Certificate verification failed.";
                    }
                }
                catch (Exception e)
                {
                    result = CheckResultEnum.Failure;

                    ErrorDetailsString = "Verify check: Certificate verification threw an exception.";
                    CIReport.SerializableCertificate.VerificationException = e;
                }

            }
            // else nothing

            if (result != CheckResultEnum.Success)
            {
                CIReport.VerifyResult = false;
            }
            else
            {
                CIReport.VerifyResult = true;
            }

            return result;
        }
    }


    class PrivateKeyCertificateCheck : CertificateCheck
    {
        public PrivateKeyCertificateCheck(X509Certificate2 Certificate,
                                          CheckTypeEnum CheckType) : base(Certificate, CheckType) { }

        public override CheckResultEnum PerformCheck(out string ErrorDetailsString,
                                                     CertInfoReport CIReport)
        {
            ErrorDetailsString = null;
            CheckResultEnum result = CheckResultEnum.Success;

            if ( CheckTypeEnum.Skip == _checkType || null == _certificate )
            {
                return result;
            }

            if ( !_certificate.HasPrivateKey )
            {
                result = CheckResultEnum.Failure;

                ErrorDetailsString = "Private Key check: Private Key is not present.";
            }

            // Try to acquire the private key 
            try
            {
                string keyfileName = CertUtil.GetKeyFileName(_certificate);

                CIReport.KeyFileName = keyfileName;
            }
            catch( Exception e )
            {
                CIReport.KeyFileName = e.Message;
            }

            return result;
        }
    }

    class InvalidBlockCertificateCheck : CertificateCheck
    {
        public InvalidBlockCertificateCheck(string Type, string Parameter) :
                    base(null, CheckTypeEnum.CouldFail)
        {
            //
            // Use CouldFail as we don't want to take servers out of VIP
            // due to wrong configuration
            //
            _type = Type;
            _parameter = Parameter;
        }

        public override CheckResultEnum PerformCheck(out string ErrorDetailsString,
                                                     CertInfoReport CIReport)
        {
            //
            // if we get here it means we failed to parse the check
            //
            ErrorDetailsString = String.Format("Incorrect block - Type: {0}, Parameter: {1}\n",
                                               _type,
                                               _parameter);

            //
            // return fail to allow others to continue, even if one check is wrong
            //
            return CheckResultEnum.Failure;
        }

        private string _type;
        private string _parameter;
    }

    //
    // X509Certificate* cannot be serialized by itself -- so we cheat
    // Same goes for System.Exception
    //
    public class SerializableX509Certificate2 : IXmlSerializable
    {
        public SerializableX509Certificate2()
        {
            _certificate = null;
            _certificateException = null;
            _verificationException = null;
        }

        public X509Certificate2 Certificate
        {
            get
            {
                return _certificate;
            }
            set
            {
                _certificate = value;
            }
        }

        public Exception CertificateException
        {
            get
            {
                return _certificateException;
            }
            set
            {
                _certificateException = value;
            }
        }

        public Exception VerificationException
        {
            get
            {
                return _verificationException;
            }
            set
            {
                _verificationException = value;
            }
        }

        public System.Xml.Schema.XmlSchema GetSchema()
        {
            return null;
        }

        public void ReadXml(XmlReader reader)
        {
            // we don't support deserialization
            throw new NotSupportedException();
        }

        public void WriteXml(System.Xml.XmlWriter writer)
        {
            if (_certificate != null)
            {
                string[] properties = {
                        "Archived",
                        "FriendlyName",
                        "HasPrivateKey",
                        "Issuer",
                        "NotAfter",
                        "NotBefore",
                        "SerialNumber",
                        "Subject",
                        "Thumbprint",
                        "Version"
                        };

                foreach (string property in properties)
                {
                    try
                    {
                        PropertyInfo propInfo = _certificate.GetType().GetProperty(property);

                        writer.WriteElementString(property, propInfo.GetGetMethod().Invoke(_certificate, null).ToString());
                    }
                    catch (Exception e)
                    {
                        writer.WriteElementString("Error", e.ToString());
                    }
                }
            }

            if (_certificateException != null)
            {
                writer.WriteElementString("CertificateException", _certificateException.ToString());
            }

            if (_verificationException != null)
            {
                writer.WriteElementString("VerificationException", _verificationException.ToString());
            }
        }

        //
        // We need not xml serialize the fields (they can't be really)
        // Programmer preference for simplyfing the code results in
        // the exceptions being bundled with the cert (implement WriteXml
        // once).
        //
        [XmlIgnore]
        private X509Certificate2 _certificate;

        [XmlIgnore]
        private Exception _certificateException;

        [XmlIgnore]
        private Exception _verificationException;

    }

    public class CertInfoReport : IExtendedHealthReport
    {
        //
        // this is for reporting cert parameters
        //
        public string HealthBlockId;
        public string HealthBlockStore;

        //
        // this is for the cert (and bundled exceptions)
        //
        public SerializableX509Certificate2 SerializableCertificate;

        //
        // private key file (not path!)
        //
        public string KeyFileName;

        //
        // X509Certificate.Veirfy() result
        //
        public bool VerifyResult;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\health\dll\Block_DmpTransaction.cs ===
//
// NpdbSettings.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Healthcheck Module
// Xbox Online Service
//
// Common healthblock implementation.
//
// Author: kgoodier 3/2008
//

using System;
using System.Collections.Specialized;

using xonline.common.billing;
using xonline.common.config;

namespace xonline.common.health
{
    // --------------------------------------------------------------------------------------
    // DmpTransaction - initialize and check health of the DMP web service.
    //
    // PARAMETERS:
    //
    // "prefix" : 1 or more setting prefix for this component. Example: "prefix=lspfd" will
    // load all npdb settings matching "lspfd*".
    //
    // "setting" : 1 or more exact setting names to retrieve the value of. Example:
    // "setting=xuacs_passportName,setting=xbos_passportName"
    //
    // --------------------------------------------------------------------------------------
    internal class DmpTransaction : IHealthBlock
    {
        public ResourceTypeEnum ResourceType
        {
            get { return ResourceTypeEnum.Remote; }
        }

        public void DoCheck(HealthBlockManager blockManager, NameValueCollection blockParams, HealthReport report)
        {
            // set output param immediately
            DmpTransactionReport myReport = new DmpTransactionReport();
            report.ExtendedReport = myReport;

            try
            {
                myReport.BillingProxy = Config.GetSetting(Setting.billing_proxy);
                myReport.WebServiceUrl = DMPTransactionWrapper.TransactionUrl;

                // initialize the DMPTransactionWrapper class
                DMPTransactionWrapper dmp = new DMPTransactionWrapper();

                myReport.ClientCertSubject = dmp.ClientCertSubject;

                string echoIn = "healthcheck";
                string echoOut;
                DateTime dt;
                dmp.TestConnection(echoIn, out dt, out echoOut);
            }
            catch (Exception e)
            {
                report.ErrorDetails = e.ToString();
                report.HealthStatus = HealthStatusEnum.Red;
                return;
            }

            // if we made it this far, things are good to go
            report.HealthStatus = HealthStatusEnum.Green;
        }
    }

    // --------------------------------------------------------------------------------------
    // DmpTransactionReport - health report
    // --------------------------------------------------------------------------------------
    public class DmpTransactionReport : IExtendedHealthReport
    {
        public string WebServiceUrl;
        public string ClientCertSubject;
        public string BillingProxy;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\health\dll\Block_DtcStatus.cs ===
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Reflection;

namespace xonline.common.health
{
    public class DtcStatusHealthBlock : IHealthBlock
    {
        public ResourceTypeEnum ResourceType
        {
            get { return ResourceTypeEnum.Local; }
        }

        public void DoCheck(HealthBlockManager blockManager, NameValueCollection blockParams, HealthReport report)
        {
            DtcStatus dtc = new DtcStatus();

            report.ExtendedReport = new DtcStatusHealthReport(dtc);
            report.HealthStatus = dtc.NetworkDtcEnabled && dtc.NetworkOutboundAccessEnabled ? HealthStatusEnum.Green : HealthStatusEnum.Red;
            if (report.HealthStatus == HealthStatusEnum.Red)
            {
                report.ErrorDetails = "Outbound Network Transaction Communication is not enabled.\r\n" +
                    "To enable manually, go to Component Services -> Computers -> My Computer -> Distributed Transaction Coodinator -> Local DTC (right click: Properties)\r\n" +
                    "Security Tab: Enable \"Network DTC Access\" and \"Transaction Manager Communication: Allow Outbound\"";
            }
        }
    }

    public class DtcStatusHealthReport : IExtendedHealthReport
    {
        public List<NameValuePair> DtcSettings;

        public DtcStatusHealthReport()
        {
        }

        internal DtcStatusHealthReport(DtcStatus dtc)
        {
            DtcSettings = new List<NameValuePair>();

            foreach (PropertyInfo p in dtc.GetType().GetProperties())
            {
                NameValuePair nv = new NameValuePair();

                nv.Name = p.Name;
                nv.Value = p.GetValue(dtc, null).ToString();
                DtcSettings.Add(nv);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\health\dll\Block_FileShareAccessCheck.cs ===
﻿// 
// FileShareAccessCheck.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Healthcheck Module
// Xbox Online Service
//
// This module implements a file share access common healthblock
// All the checks in the module are *local*
//
// Notes:
//
//

using System;
using System.Collections.Specialized;
using System.Text;

using xonline.common.config;

namespace xonline.common.health
{

    // ------------------------------------------------------------------------------------
    // Parameter description 
    // A FileShareAccessCheck health block requires a share location
    //
    // A access can be 
    //      - ReadOnly 
    //      - ReadWrite 
    // 
    // Here are the two XML simplified formats
    // 
    // <vc_params>FileSharePath = \\servername\sharedfolder, Access = ReadOnly </vc_params>
    // <vc_params>FileSharePathSetting = ups_sharedfoldername, Access = ReadWrite</vc_params>
    // 
    // ------------------------------------------------------------------------------------
    public class FileShareAccessCheck : IHealthBlock
    {
        //
        // keywords
        //
        private const string Keyword_FileSharePath = "FileSharePath";
        private const string Keyword_FileSharePathSetting = "FileSharePathSetting";
        private const string Keyword_Access = "Access";
        private const string Value_Access_ReadOnly = "readonly";
        private const string Value_Access_ReadWrite = "readwrite";

        public ResourceTypeEnum ResourceType
        {
            get { return ResourceTypeEnum.Local; }
        }

        public void DoCheck(HealthBlockManager blockManager,
                            NameValueCollection blockParams,
                            HealthReport report)
        {
            string FileSharePath = null;

            FileShareAccessCheckReport myReport = new FileShareAccessCheckReport();
            bool writeAccess = false;
            bool readAccess = false;
            report.ExtendedReport = myReport;

            //
            // we trim the fileshare path names, even if this means potential
            // loss of functionality. Names with leading or trailing spaces
            // are totally uncommon. If it happens, remove the trim call.
            //
            if (!(string.IsNullOrEmpty(blockParams[Keyword_FileSharePath])))
            {
                FileSharePath = blockParams[Keyword_FileSharePath].Trim();
            }
            else if (!string.IsNullOrEmpty(blockParams[Keyword_FileSharePathSetting]))
            {
                try
                {
                    FileSharePath = Config.GetSetting(blockParams[Keyword_FileSharePathSetting].Trim()).Trim();
                }
                catch 
                {
                    report.ErrorDetails = String.Format("\nCannot retrieve FileSharePath from {0} NPDB Settings.\n",
                                                        blockParams[Keyword_FileSharePathSetting]);
                    FileSharePath = null;
                }
            }

            // set the attributes for the report
            myReport.FileSharePath = FileSharePath;
            myReport.FileShareAccessMode = blockParams[Keyword_Access];

            if (string.IsNullOrEmpty(FileSharePath))
            {
                //
                // Take servers out of production because of an operator error
                // seems too harsh.
                //
                report.ErrorDetails += "\nFileSharePath is not specified.";
                report.HealthStatus = HealthStatusEnum.Yellow;
                return;
            }

            //
            // Future improvement: Ideally we should have a access enumaration here.
            //
            if (blockParams[Keyword_Access] != null)
            {
                if (String.Equals(blockParams[Keyword_Access].Trim(), Value_Access_ReadWrite, StringComparison.OrdinalIgnoreCase))
                {
                    writeAccess = true;
                }
                else if (String.Equals(blockParams[Keyword_Access].Trim(), Value_Access_ReadOnly, StringComparison.OrdinalIgnoreCase))
                {
                    readAccess = true;
                }
                else
                {
                    report.ErrorDetails = "Cannot retrieve Access type from the block parameters.\n";
                    report.HealthStatus = HealthStatusEnum.Yellow;
                    return;
                }
            }

            report.HealthStatus = HealthStatusEnum.Yellow;
            StringBuilder sb = new StringBuilder();
            string error = string.Format("\nCannot access {0}.\n", FileSharePath);

            // check for write if requested
            try
            {
                bool access = false;
                if (writeAccess)
                {
                    access = FileUtils.CheckWriteFileAccess(FileSharePath, out error);
                    if (access)
                    {
                        report.HealthStatus = HealthStatusEnum.Green;
                    }
                    else
                    {
                        error = string.Format("\nCannot access {0} for write.\n", FileSharePath);
                    }
                }
                // check the read access 
                else if (readAccess)
                {
                    access = FileUtils.CheckReadFileAccess(FileSharePath, out error);
                    if (access)
                    {
                        report.HealthStatus = HealthStatusEnum.Green;
                    }
                    else
                    {
                        error = string.Format("\nCannot access {0} for read.\n", FileSharePath);
                    }
                }

                if (!access)
                {
                    sb.Append(error);
                    report.ErrorDetails = sb.ToString();
                    report.HealthStatus = HealthStatusEnum.Red;
                }
            }
            catch (Exception e)
            {
                report.HealthStatus = HealthStatusEnum.Red;
                report.ErrorDetails = e.Message;
            }
        }
    }

    public class FileShareAccessCheckReport : IExtendedHealthReport
    {
        //
        // this is for reporting file share parameters
        //
        public string FileSharePath;
        public string FileShareAccessMode;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\wmi\iisv2\IIsWebServerSetting.CS ===
﻿namespace xonline.common.wmi.iisv2 {
    using System;
    using System.ComponentModel;
    using System.Management;
    using System.Collections;
    using System.Globalization;
    using System.ComponentModel.Design.Serialization;
    using System.Reflection;
    
    
    // Functions ShouldSerialize<PropertyName> are functions used by VS property browser to check if a particular property has to be serialized. These functions are added for all ValueType properties ( properties of type Int32, BOOL etc.. which cannot be set to null). These functions use Is<PropertyName>Null function. These functions are also used in the TypeConverter implementation for the properties to check for NULL value of property so that an empty value can be shown in Property browser in case of Drag and Drop in Visual studio.
    // Functions Is<PropertyName>Null() are used to check if a property is NULL.
    // Functions Reset<PropertyName> are added for Nullable Read/Write properties. These functions are used by VS designer in property browser to set a property to NULL.
    // Every property added to the class for WMI property has attributes set to define its behavior in Visual Studio designer and also to define a TypeConverter to be used.
    // 
    // 
    // 
    // 
    // If the embedded property is strongly typed then, to strongly type the property to the type of
    // the embedded object, you have to do the following things.
    // 	1. Generate Managed class for the WMI class of the embedded property. This can be done with MgmtClassGen.exe tool or from Server Explorer.
    // 	2. Include the namespace of the generated class.
    // 	3. Change the property get/set functions so as return the instance of the Managed class.
    // Below is a sample code.
    // 
    // VB Code
    // Public Property <PropertyName>() As <ManagedClassName of Embedded property>
    // 	Get
    // 		Return New <ManagedClassName of Embedded Property>(CType(curObj("<PropertyName>"),System.Management.ManagementBaseObject))
    // 	End Get
    // 	Set(ByVal Value As <ManagedClassName of Embedded property>)
    // 		curObj("EObject") = Value.LateBoundObject
    // 		If (AutoCommitProp = True And isEmbedded = False) Then
    // 			PrivateLateBoundObject.Put()
    // 		End If
    // 	End Set
    // 
    // C# Code
    // public <ManagedClassName of Embedded property> <PropertyName>
    // {
    // 	get
    // 	{
    // 		return new <ManagedClassName of Embedded property>((System.Management.ManagementBaseObject)(curObj["<PropertyName>"]));
    // 	}
    // 	set
    // 	{
    // 		curObj["<PropertyName>"] = value.LateBoundObject;
    // 		If (AutoCommitProp == true && isEmbedded == false)
    // 		{
    // 			PrivateLateBoundObject.Put();
    // 		}
    // 	}
    // }
    // An Early Bound class generated for the WMI class.IIsWebServerSetting
    public class IIsWebServerSetting : System.ComponentModel.Component {
        
        // Private property to hold the WMI namespace in which the class resides.
        private static string CreatedWmiNamespace = "ROOT\\MicrosoftIISv2";
        
        // Private property to hold the name of WMI class which created this class.
        private static string CreatedClassName = "IIsWebServerSetting";
        
        // Private member variable to hold the ManagementScope which is used by the various methods.
        private static System.Management.ManagementScope statMgmtScope = null;
        
        private ManagementSystemProperties PrivateSystemProperties;
        
        // Underlying lateBound WMI object.
        private System.Management.ManagementObject PrivateLateBoundObject;
        
        // Member variable to store the 'automatic commit' behavior for the class.
        private bool AutoCommitProp = true;
        
        // Private variable to hold the embedded property representing the instance.
        private System.Management.ManagementBaseObject embeddedObj;
        
        // The current WMI object used
        private System.Management.ManagementBaseObject curObj;
        
        // Flag to indicate if the instance is an embedded object.
        private bool isEmbedded = false;
        
        // Below are different overloads of constructors to initialize an instance of the class with a WMI object.
        public IIsWebServerSetting() : 
                this(((System.Management.ManagementScope)(null)), ((System.Management.ManagementPath)(null)), ((System.Management.ObjectGetOptions)(null))) {
        }
        
        public IIsWebServerSetting(string keyName) : 
                this(((System.Management.ManagementScope)(null)), ((System.Management.ManagementPath)(new System.Management.ManagementPath(IIsWebServerSetting.ConstructPath(keyName)))), ((System.Management.ObjectGetOptions)(null))) {
        }
        
        public IIsWebServerSetting(System.Management.ManagementScope mgmtScope, string keyName) : 
                this(((System.Management.ManagementScope)(mgmtScope)), ((System.Management.ManagementPath)(new System.Management.ManagementPath(IIsWebServerSetting.ConstructPath(keyName)))), ((System.Management.ObjectGetOptions)(null))) {
        }
        
        public IIsWebServerSetting(System.Management.ManagementPath path, System.Management.ObjectGetOptions getOptions) : 
                this(((System.Management.ManagementScope)(null)), ((System.Management.ManagementPath)(path)), ((System.Management.ObjectGetOptions)(getOptions))) {
        }
        
        public IIsWebServerSetting(System.Management.ManagementScope mgmtScope, System.Management.ManagementPath path) : 
                this(((System.Management.ManagementScope)(mgmtScope)), ((System.Management.ManagementPath)(path)), ((System.Management.ObjectGetOptions)(null))) {
        }
        
        public IIsWebServerSetting(System.Management.ManagementPath path) : 
                this(((System.Management.ManagementScope)(null)), ((System.Management.ManagementPath)(path)), ((System.Management.ObjectGetOptions)(null))) {
        }
        
        public IIsWebServerSetting(System.Management.ManagementScope mgmtScope, System.Management.ManagementPath path, System.Management.ObjectGetOptions getOptions) {
            if ((path != null)) {
                if ((CheckIfProperClass(mgmtScope, path, getOptions) != true)) {
                    throw new System.ArgumentException("Class name does not match.");
                }
            }
            PrivateLateBoundObject = new System.Management.ManagementObject(mgmtScope, path, getOptions);
            PrivateSystemProperties = new ManagementSystemProperties(PrivateLateBoundObject);
            curObj = PrivateLateBoundObject;
        }
        
        public IIsWebServerSetting(System.Management.ManagementObject theObject) {
            if ((CheckIfProperClass(theObject) == true)) {
                PrivateLateBoundObject = theObject;
                PrivateSystemProperties = new ManagementSystemProperties(PrivateLateBoundObject);
                curObj = PrivateLateBoundObject;
            }
            else {
                throw new System.ArgumentException("Class name does not match.");
            }
        }
        
        public IIsWebServerSetting(System.Management.ManagementBaseObject theObject) {
            if ((CheckIfProperClass(theObject) == true)) {
                embeddedObj = theObject;
                PrivateSystemProperties = new ManagementSystemProperties(theObject);
                curObj = embeddedObj;
                isEmbedded = true;
            }
            else {
                throw new System.ArgumentException("Class name does not match.");
            }
        }
        
        // Property returns the namespace of the WMI class.
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string OriginatingNamespace {
            get {
                return "ROOT\\MicrosoftIISv2";
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string ManagementClassName {
            get {
                string strRet = CreatedClassName;
                if ((curObj != null)) {
                    if ((curObj.ClassPath != null)) {
                        strRet = ((string)(curObj["__CLASS"]));
                        if (((strRet == null) 
                                    || (strRet == System.String.Empty))) {
                            strRet = CreatedClassName;
                        }
                    }
                }
                return strRet;
            }
        }
        
        // Property pointing to an embedded object to get System properties of the WMI object.
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public ManagementSystemProperties SystemProperties {
            get {
                return PrivateSystemProperties;
            }
        }
        
        // Property returning the underlying lateBound object.
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public System.Management.ManagementBaseObject LateBoundObject {
            get {
                return curObj;
            }
        }
        
        // ManagementScope of the object.
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public System.Management.ManagementScope Scope {
            get {
                if ((isEmbedded == false)) {
                    return PrivateLateBoundObject.Scope;
                }
                else {
                    return null;
                }
            }
            set {
                if ((isEmbedded == false)) {
                    PrivateLateBoundObject.Scope = value;
                }
            }
        }
        
        // Property to show the commit behavior for the WMI object. If true, WMI object will be automatically saved after each property modification.(ie. Put() is called after modification of a property).
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool AutoCommit {
            get {
                return AutoCommitProp;
            }
            set {
                AutoCommitProp = value;
            }
        }
        
        // The ManagementPath of the underlying WMI object.
        [Browsable(true)]
        public System.Management.ManagementPath Path {
            get {
                if ((isEmbedded == false)) {
                    return PrivateLateBoundObject.Path;
                }
                else {
                    return null;
                }
            }
            set {
                if ((isEmbedded == false)) {
                    if ((CheckIfProperClass(null, value, null) != true)) {
                        throw new System.ArgumentException("Class name does not match.");
                    }
                    PrivateLateBoundObject.Path = value;
                }
            }
        }
        
        // Public static scope property which is used by the various methods.
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public static System.Management.ManagementScope StaticScope {
            get {
                return statMgmtScope;
            }
            set {
                statMgmtScope = value;
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAccessExecuteNull {
            get {
                if ((curObj["AccessExecute"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AccessExecute {
            get {
                if ((curObj["AccessExecute"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AccessExecute"]));
            }
            set {
                curObj["AccessExecute"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAccessFlagsNull {
            get {
                if ((curObj["AccessFlags"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AccessFlags {
            get {
                if ((curObj["AccessFlags"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AccessFlags"]));
            }
            set {
                curObj["AccessFlags"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAccessNoPhysicalDirNull {
            get {
                if ((curObj["AccessNoPhysicalDir"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AccessNoPhysicalDir {
            get {
                if ((curObj["AccessNoPhysicalDir"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AccessNoPhysicalDir"]));
            }
            set {
                curObj["AccessNoPhysicalDir"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAccessNoRemoteExecuteNull {
            get {
                if ((curObj["AccessNoRemoteExecute"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AccessNoRemoteExecute {
            get {
                if ((curObj["AccessNoRemoteExecute"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AccessNoRemoteExecute"]));
            }
            set {
                curObj["AccessNoRemoteExecute"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAccessNoRemoteReadNull {
            get {
                if ((curObj["AccessNoRemoteRead"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AccessNoRemoteRead {
            get {
                if ((curObj["AccessNoRemoteRead"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AccessNoRemoteRead"]));
            }
            set {
                curObj["AccessNoRemoteRead"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAccessNoRemoteScriptNull {
            get {
                if ((curObj["AccessNoRemoteScript"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AccessNoRemoteScript {
            get {
                if ((curObj["AccessNoRemoteScript"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AccessNoRemoteScript"]));
            }
            set {
                curObj["AccessNoRemoteScript"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAccessNoRemoteWriteNull {
            get {
                if ((curObj["AccessNoRemoteWrite"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AccessNoRemoteWrite {
            get {
                if ((curObj["AccessNoRemoteWrite"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AccessNoRemoteWrite"]));
            }
            set {
                curObj["AccessNoRemoteWrite"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAccessReadNull {
            get {
                if ((curObj["AccessRead"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AccessRead {
            get {
                if ((curObj["AccessRead"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AccessRead"]));
            }
            set {
                curObj["AccessRead"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAccessScriptNull {
            get {
                if ((curObj["AccessScript"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AccessScript {
            get {
                if ((curObj["AccessScript"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AccessScript"]));
            }
            set {
                curObj["AccessScript"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAccessSourceNull {
            get {
                if ((curObj["AccessSource"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AccessSource {
            get {
                if ((curObj["AccessSource"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AccessSource"]));
            }
            set {
                curObj["AccessSource"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAccessSSLNull {
            get {
                if ((curObj["AccessSSL"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AccessSSL {
            get {
                if ((curObj["AccessSSL"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AccessSSL"]));
            }
            set {
                curObj["AccessSSL"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAccessSSL128Null {
            get {
                if ((curObj["AccessSSL128"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AccessSSL128 {
            get {
                if ((curObj["AccessSSL128"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AccessSSL128"]));
            }
            set {
                curObj["AccessSSL128"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAccessSSLFlagsNull {
            get {
                if ((curObj["AccessSSLFlags"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AccessSSLFlags {
            get {
                if ((curObj["AccessSSLFlags"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AccessSSLFlags"]));
            }
            set {
                curObj["AccessSSLFlags"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAccessSSLMapCertNull {
            get {
                if ((curObj["AccessSSLMapCert"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AccessSSLMapCert {
            get {
                if ((curObj["AccessSSLMapCert"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AccessSSLMapCert"]));
            }
            set {
                curObj["AccessSSLMapCert"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAccessSSLNegotiateCertNull {
            get {
                if ((curObj["AccessSSLNegotiateCert"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AccessSSLNegotiateCert {
            get {
                if ((curObj["AccessSSLNegotiateCert"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AccessSSLNegotiateCert"]));
            }
            set {
                curObj["AccessSSLNegotiateCert"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAccessSSLRequireCertNull {
            get {
                if ((curObj["AccessSSLRequireCert"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AccessSSLRequireCert {
            get {
                if ((curObj["AccessSSLRequireCert"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AccessSSLRequireCert"]));
            }
            set {
                curObj["AccessSSLRequireCert"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAccessWriteNull {
            get {
                if ((curObj["AccessWrite"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AccessWrite {
            get {
                if ((curObj["AccessWrite"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AccessWrite"]));
            }
            set {
                curObj["AccessWrite"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public System.Byte[] AdminACLBin {
            get {
                return ((System.Byte[])(curObj["AdminACLBin"]));
            }
            set {
                curObj["AdminACLBin"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAllowKeepAliveNull {
            get {
                if ((curObj["AllowKeepAlive"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AllowKeepAlive {
            get {
                if ((curObj["AllowKeepAlive"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AllowKeepAlive"]));
            }
            set {
                curObj["AllowKeepAlive"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAllowPathInfoForScriptMappingsNull {
            get {
                if ((curObj["AllowPathInfoForScriptMappings"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AllowPathInfoForScriptMappings {
            get {
                if ((curObj["AllowPathInfoForScriptMappings"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AllowPathInfoForScriptMappings"]));
            }
            set {
                curObj["AllowPathInfoForScriptMappings"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAnonymousPasswordSyncNull {
            get {
                if ((curObj["AnonymousPasswordSync"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AnonymousPasswordSync {
            get {
                if ((curObj["AnonymousPasswordSync"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AnonymousPasswordSync"]));
            }
            set {
                curObj["AnonymousPasswordSync"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string AnonymousUserName {
            get {
                return ((string)(curObj["AnonymousUserName"]));
            }
            set {
                curObj["AnonymousUserName"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string AnonymousUserPass {
            get {
                return ((string)(curObj["AnonymousUserPass"]));
            }
            set {
                curObj["AnonymousUserPass"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAppAllowClientDebugNull {
            get {
                if ((curObj["AppAllowClientDebug"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AppAllowClientDebug {
            get {
                if ((curObj["AppAllowClientDebug"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AppAllowClientDebug"]));
            }
            set {
                curObj["AppAllowClientDebug"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAppAllowDebuggingNull {
            get {
                if ((curObj["AppAllowDebugging"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AppAllowDebugging {
            get {
                if ((curObj["AppAllowDebugging"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AppAllowDebugging"]));
            }
            set {
                curObj["AppAllowDebugging"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string AppFriendlyName {
            get {
                return ((string)(curObj["AppFriendlyName"]));
            }
            set {
                curObj["AppFriendlyName"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAppOopRecoverLimitNull {
            get {
                if ((curObj["AppOopRecoverLimit"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AppOopRecoverLimit {
            get {
                if ((curObj["AppOopRecoverLimit"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AppOopRecoverLimit"]));
            }
            set {
                curObj["AppOopRecoverLimit"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string AppPoolId {
            get {
                return ((string)(curObj["AppPoolId"]));
            }
            set {
                curObj["AppPoolId"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string AppWamClsid {
            get {
                return ((string)(curObj["AppWamClsid"]));
            }
            set {
                curObj["AppWamClsid"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspAllowOutOfProcComponentsNull {
            get {
                if ((curObj["AspAllowOutOfProcComponents"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AspAllowOutOfProcComponents {
            get {
                if ((curObj["AspAllowOutOfProcComponents"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AspAllowOutOfProcComponents"]));
            }
            set {
                curObj["AspAllowOutOfProcComponents"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspAllowSessionStateNull {
            get {
                if ((curObj["AspAllowSessionState"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AspAllowSessionState {
            get {
                if ((curObj["AspAllowSessionState"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AspAllowSessionState"]));
            }
            set {
                curObj["AspAllowSessionState"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspAppServiceFlagsNull {
            get {
                if ((curObj["AspAppServiceFlags"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AspAppServiceFlags {
            get {
                if ((curObj["AspAppServiceFlags"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AspAppServiceFlags"]));
            }
            set {
                curObj["AspAppServiceFlags"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspBufferingLimitNull {
            get {
                if ((curObj["AspBufferingLimit"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AspBufferingLimit {
            get {
                if ((curObj["AspBufferingLimit"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AspBufferingLimit"]));
            }
            set {
                curObj["AspBufferingLimit"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspBufferingOnNull {
            get {
                if ((curObj["AspBufferingOn"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AspBufferingOn {
            get {
                if ((curObj["AspBufferingOn"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AspBufferingOn"]));
            }
            set {
                curObj["AspBufferingOn"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspCalcLineNumberNull {
            get {
                if ((curObj["AspCalcLineNumber"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AspCalcLineNumber {
            get {
                if ((curObj["AspCalcLineNumber"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AspCalcLineNumber"]));
            }
            set {
                curObj["AspCalcLineNumber"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspCodepageNull {
            get {
                if ((curObj["AspCodepage"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AspCodepage {
            get {
                if ((curObj["AspCodepage"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AspCodepage"]));
            }
            set {
                curObj["AspCodepage"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string AspDiskTemplateCacheDirectory {
            get {
                return ((string)(curObj["AspDiskTemplateCacheDirectory"]));
            }
            set {
                curObj["AspDiskTemplateCacheDirectory"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspEnableApplicationRestartNull {
            get {
                if ((curObj["AspEnableApplicationRestart"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AspEnableApplicationRestart {
            get {
                if ((curObj["AspEnableApplicationRestart"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AspEnableApplicationRestart"]));
            }
            set {
                curObj["AspEnableApplicationRestart"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspEnableAspHtmlFallbackNull {
            get {
                if ((curObj["AspEnableAspHtmlFallback"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AspEnableAspHtmlFallback {
            get {
                if ((curObj["AspEnableAspHtmlFallback"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AspEnableAspHtmlFallback"]));
            }
            set {
                curObj["AspEnableAspHtmlFallback"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspEnableChunkedEncodingNull {
            get {
                if ((curObj["AspEnableChunkedEncoding"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AspEnableChunkedEncoding {
            get {
                if ((curObj["AspEnableChunkedEncoding"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AspEnableChunkedEncoding"]));
            }
            set {
                curObj["AspEnableChunkedEncoding"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspEnableParentPathsNull {
            get {
                if ((curObj["AspEnableParentPaths"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AspEnableParentPaths {
            get {
                if ((curObj["AspEnableParentPaths"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AspEnableParentPaths"]));
            }
            set {
                curObj["AspEnableParentPaths"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspEnableSxsNull {
            get {
                if ((curObj["AspEnableSxs"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AspEnableSxs {
            get {
                if ((curObj["AspEnableSxs"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AspEnableSxs"]));
            }
            set {
                curObj["AspEnableSxs"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspEnableTrackerNull {
            get {
                if ((curObj["AspEnableTracker"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AspEnableTracker {
            get {
                if ((curObj["AspEnableTracker"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AspEnableTracker"]));
            }
            set {
                curObj["AspEnableTracker"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspEnableTypelibCacheNull {
            get {
                if ((curObj["AspEnableTypelibCache"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AspEnableTypelibCache {
            get {
                if ((curObj["AspEnableTypelibCache"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AspEnableTypelibCache"]));
            }
            set {
                curObj["AspEnableTypelibCache"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspErrorsToNTLogNull {
            get {
                if ((curObj["AspErrorsToNTLog"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AspErrorsToNTLog {
            get {
                if ((curObj["AspErrorsToNTLog"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AspErrorsToNTLog"]));
            }
            set {
                curObj["AspErrorsToNTLog"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspExceptionCatchEnableNull {
            get {
                if ((curObj["AspExceptionCatchEnable"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AspExceptionCatchEnable {
            get {
                if ((curObj["AspExceptionCatchEnable"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AspExceptionCatchEnable"]));
            }
            set {
                curObj["AspExceptionCatchEnable"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspExecuteInMTANull {
            get {
                if ((curObj["AspExecuteInMTA"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AspExecuteInMTA {
            get {
                if ((curObj["AspExecuteInMTA"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AspExecuteInMTA"]));
            }
            set {
                curObj["AspExecuteInMTA"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspKeepSessionIDSecureNull {
            get {
                if ((curObj["AspKeepSessionIDSecure"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AspKeepSessionIDSecure {
            get {
                if ((curObj["AspKeepSessionIDSecure"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AspKeepSessionIDSecure"]));
            }
            set {
                curObj["AspKeepSessionIDSecure"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspLCIDNull {
            get {
                if ((curObj["AspLCID"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AspLCID {
            get {
                if ((curObj["AspLCID"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AspLCID"]));
            }
            set {
                curObj["AspLCID"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspLogErrorRequestsNull {
            get {
                if ((curObj["AspLogErrorRequests"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AspLogErrorRequests {
            get {
                if ((curObj["AspLogErrorRequests"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AspLogErrorRequests"]));
            }
            set {
                curObj["AspLogErrorRequests"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspMaxDiskTemplateCacheFilesNull {
            get {
                if ((curObj["AspMaxDiskTemplateCacheFiles"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AspMaxDiskTemplateCacheFiles {
            get {
                if ((curObj["AspMaxDiskTemplateCacheFiles"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AspMaxDiskTemplateCacheFiles"]));
            }
            set {
                curObj["AspMaxDiskTemplateCacheFiles"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspMaxRequestEntityAllowedNull {
            get {
                if ((curObj["AspMaxRequestEntityAllowed"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AspMaxRequestEntityAllowed {
            get {
                if ((curObj["AspMaxRequestEntityAllowed"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AspMaxRequestEntityAllowed"]));
            }
            set {
                curObj["AspMaxRequestEntityAllowed"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string AspPartitionID {
            get {
                return ((string)(curObj["AspPartitionID"]));
            }
            set {
                curObj["AspPartitionID"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspProcessorThreadMaxNull {
            get {
                if ((curObj["AspProcessorThreadMax"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AspProcessorThreadMax {
            get {
                if ((curObj["AspProcessorThreadMax"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AspProcessorThreadMax"]));
            }
            set {
                curObj["AspProcessorThreadMax"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspQueueConnectionTestTimeNull {
            get {
                if ((curObj["AspQueueConnectionTestTime"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AspQueueConnectionTestTime {
            get {
                if ((curObj["AspQueueConnectionTestTime"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AspQueueConnectionTestTime"]));
            }
            set {
                curObj["AspQueueConnectionTestTime"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspQueueTimeoutNull {
            get {
                if ((curObj["AspQueueTimeout"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AspQueueTimeout {
            get {
                if ((curObj["AspQueueTimeout"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AspQueueTimeout"]));
            }
            set {
                curObj["AspQueueTimeout"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspRequestQueueMaxNull {
            get {
                if ((curObj["AspRequestQueueMax"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AspRequestQueueMax {
            get {
                if ((curObj["AspRequestQueueMax"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AspRequestQueueMax"]));
            }
            set {
                curObj["AspRequestQueueMax"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspRunOnEndAnonymouslyNull {
            get {
                if ((curObj["AspRunOnEndAnonymously"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AspRunOnEndAnonymously {
            get {
                if ((curObj["AspRunOnEndAnonymously"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AspRunOnEndAnonymously"]));
            }
            set {
                curObj["AspRunOnEndAnonymously"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspScriptEngineCacheMaxNull {
            get {
                if ((curObj["AspScriptEngineCacheMax"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AspScriptEngineCacheMax {
            get {
                if ((curObj["AspScriptEngineCacheMax"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AspScriptEngineCacheMax"]));
            }
            set {
                curObj["AspScriptEngineCacheMax"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string AspScriptErrorMessage {
            get {
                return ((string)(curObj["AspScriptErrorMessage"]));
            }
            set {
                curObj["AspScriptErrorMessage"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspScriptErrorSentToBrowserNull {
            get {
                if ((curObj["AspScriptErrorSentToBrowser"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AspScriptErrorSentToBrowser {
            get {
                if ((curObj["AspScriptErrorSentToBrowser"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AspScriptErrorSentToBrowser"]));
            }
            set {
                curObj["AspScriptErrorSentToBrowser"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspScriptFileCacheSizeNull {
            get {
                if ((curObj["AspScriptFileCacheSize"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AspScriptFileCacheSize {
            get {
                if ((curObj["AspScriptFileCacheSize"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AspScriptFileCacheSize"]));
            }
            set {
                curObj["AspScriptFileCacheSize"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string AspScriptLanguage {
            get {
                return ((string)(curObj["AspScriptLanguage"]));
            }
            set {
                curObj["AspScriptLanguage"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspScriptTimeoutNull {
            get {
                if ((curObj["AspScriptTimeout"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AspScriptTimeout {
            get {
                if ((curObj["AspScriptTimeout"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AspScriptTimeout"]));
            }
            set {
                curObj["AspScriptTimeout"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspSessionMaxNull {
            get {
                if ((curObj["AspSessionMax"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AspSessionMax {
            get {
                if ((curObj["AspSessionMax"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AspSessionMax"]));
            }
            set {
                curObj["AspSessionMax"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspSessionTimeoutNull {
            get {
                if ((curObj["AspSessionTimeout"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AspSessionTimeout {
            get {
                if ((curObj["AspSessionTimeout"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AspSessionTimeout"]));
            }
            set {
                curObj["AspSessionTimeout"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string AspSxsName {
            get {
                return ((string)(curObj["AspSxsName"]));
            }
            set {
                curObj["AspSxsName"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspTrackThreadingModelNull {
            get {
                if ((curObj["AspTrackThreadingModel"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AspTrackThreadingModel {
            get {
                if ((curObj["AspTrackThreadingModel"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AspTrackThreadingModel"]));
            }
            set {
                curObj["AspTrackThreadingModel"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspUsePartitionNull {
            get {
                if ((curObj["AspUsePartition"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AspUsePartition {
            get {
                if ((curObj["AspUsePartition"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AspUsePartition"]));
            }
            set {
                curObj["AspUsePartition"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAuthAdvNotifyDisableNull {
            get {
                if ((curObj["AuthAdvNotifyDisable"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AuthAdvNotifyDisable {
            get {
                if ((curObj["AuthAdvNotifyDisable"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AuthAdvNotifyDisable"]));
            }
            set {
                curObj["AuthAdvNotifyDisable"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAuthAnonymousNull {
            get {
                if ((curObj["AuthAnonymous"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AuthAnonymous {
            get {
                if ((curObj["AuthAnonymous"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AuthAnonymous"]));
            }
            set {
                curObj["AuthAnonymous"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAuthBasicNull {
            get {
                if ((curObj["AuthBasic"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AuthBasic {
            get {
                if ((curObj["AuthBasic"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AuthBasic"]));
            }
            set {
                curObj["AuthBasic"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAuthChangeDisableNull {
            get {
                if ((curObj["AuthChangeDisable"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AuthChangeDisable {
            get {
                if ((curObj["AuthChangeDisable"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AuthChangeDisable"]));
            }
            set {
                curObj["AuthChangeDisable"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAuthChangeUnsecureNull {
            get {
                if ((curObj["AuthChangeUnsecure"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AuthChangeUnsecure {
            get {
                if ((curObj["AuthChangeUnsecure"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AuthChangeUnsecure"]));
            }
            set {
                curObj["AuthChangeUnsecure"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAuthFlagsNull {
            get {
                if ((curObj["AuthFlags"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AuthFlags {
            get {
                if ((curObj["AuthFlags"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AuthFlags"]));
            }
            set {
                curObj["AuthFlags"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAuthMD5Null {
            get {
                if ((curObj["AuthMD5"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AuthMD5 {
            get {
                if ((curObj["AuthMD5"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AuthMD5"]));
            }
            set {
                curObj["AuthMD5"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAuthNTLMNull {
            get {
                if ((curObj["AuthNTLM"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AuthNTLM {
            get {
                if ((curObj["AuthNTLM"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AuthNTLM"]));
            }
            set {
                curObj["AuthNTLM"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAuthPassportNull {
            get {
                if ((curObj["AuthPassport"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AuthPassport {
            get {
                if ((curObj["AuthPassport"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AuthPassport"]));
            }
            set {
                curObj["AuthPassport"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAuthPersistenceNull {
            get {
                if ((curObj["AuthPersistence"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AuthPersistence {
            get {
                if ((curObj["AuthPersistence"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AuthPersistence"]));
            }
            set {
                curObj["AuthPersistence"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAuthPersistSingleRequestNull {
            get {
                if ((curObj["AuthPersistSingleRequest"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AuthPersistSingleRequest {
            get {
                if ((curObj["AuthPersistSingleRequest"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AuthPersistSingleRequest"]));
            }
            set {
                curObj["AuthPersistSingleRequest"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAzEnableNull {
            get {
                if ((curObj["AzEnable"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AzEnable {
            get {
                if ((curObj["AzEnable"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AzEnable"]));
            }
            set {
                curObj["AzEnable"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAzImpersonationLevelNull {
            get {
                if ((curObj["AzImpersonationLevel"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AzImpersonationLevel {
            get {
                if ((curObj["AzImpersonationLevel"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AzImpersonationLevel"]));
            }
            set {
                curObj["AzImpersonationLevel"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string AzScopeName {
            get {
                return ((string)(curObj["AzScopeName"]));
            }
            set {
                curObj["AzScopeName"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string AzStoreName {
            get {
                return ((string)(curObj["AzStoreName"]));
            }
            set {
                curObj["AzStoreName"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string CacheControlCustom {
            get {
                return ((string)(curObj["CacheControlCustom"]));
            }
            set {
                curObj["CacheControlCustom"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsCacheControlMaxAgeNull {
            get {
                if ((curObj["CacheControlMaxAge"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int CacheControlMaxAge {
            get {
                if ((curObj["CacheControlMaxAge"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["CacheControlMaxAge"]));
            }
            set {
                curObj["CacheControlMaxAge"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsCacheControlNoCacheNull {
            get {
                if ((curObj["CacheControlNoCache"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool CacheControlNoCache {
            get {
                if ((curObj["CacheControlNoCache"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["CacheControlNoCache"]));
            }
            set {
                curObj["CacheControlNoCache"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsCacheISAPINull {
            get {
                if ((curObj["CacheISAPI"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool CacheISAPI {
            get {
                if ((curObj["CacheISAPI"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["CacheISAPI"]));
            }
            set {
                curObj["CacheISAPI"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string Caption {
            get {
                return ((string)(curObj["Caption"]));
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsCertCheckModeNull {
            get {
                if ((curObj["CertCheckMode"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int CertCheckMode {
            get {
                if ((curObj["CertCheckMode"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["CertCheckMode"]));
            }
            set {
                curObj["CertCheckMode"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsCGITimeoutNull {
            get {
                if ((curObj["CGITimeout"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int CGITimeout {
            get {
                if ((curObj["CGITimeout"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["CGITimeout"]));
            }
            set {
                curObj["CGITimeout"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsClusterEnabledNull {
            get {
                if ((curObj["ClusterEnabled"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool ClusterEnabled {
            get {
                if ((curObj["ClusterEnabled"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["ClusterEnabled"]));
            }
            set {
                curObj["ClusterEnabled"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsConnectionTimeoutNull {
            get {
                if ((curObj["ConnectionTimeout"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int ConnectionTimeout {
            get {
                if ((curObj["ConnectionTimeout"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["ConnectionTimeout"]));
            }
            set {
                curObj["ConnectionTimeout"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsContentIndexedNull {
            get {
                if ((curObj["ContentIndexed"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool ContentIndexed {
            get {
                if ((curObj["ContentIndexed"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["ContentIndexed"]));
            }
            set {
                curObj["ContentIndexed"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsCreateCGIWithNewConsoleNull {
            get {
                if ((curObj["CreateCGIWithNewConsole"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool CreateCGIWithNewConsole {
            get {
                if ((curObj["CreateCGIWithNewConsole"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["CreateCGIWithNewConsole"]));
            }
            set {
                curObj["CreateCGIWithNewConsole"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsCreateProcessAsUserNull {
            get {
                if ((curObj["CreateProcessAsUser"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool CreateProcessAsUser {
            get {
                if ((curObj["CreateProcessAsUser"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["CreateProcessAsUser"]));
            }
            set {
                curObj["CreateProcessAsUser"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string DefaultDoc {
            get {
                return ((string)(curObj["DefaultDoc"]));
            }
            set {
                curObj["DefaultDoc"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string DefaultDocFooter {
            get {
                return ((string)(curObj["DefaultDocFooter"]));
            }
            set {
                curObj["DefaultDocFooter"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string DefaultLogonDomain {
            get {
                return ((string)(curObj["DefaultLogonDomain"]));
            }
            set {
                curObj["DefaultLogonDomain"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string Description {
            get {
                return ((string)(curObj["Description"]));
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsDirBrowseFlagsNull {
            get {
                if ((curObj["DirBrowseFlags"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int DirBrowseFlags {
            get {
                if ((curObj["DirBrowseFlags"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["DirBrowseFlags"]));
            }
            set {
                curObj["DirBrowseFlags"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsDirBrowseShowDateNull {
            get {
                if ((curObj["DirBrowseShowDate"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool DirBrowseShowDate {
            get {
                if ((curObj["DirBrowseShowDate"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["DirBrowseShowDate"]));
            }
            set {
                curObj["DirBrowseShowDate"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsDirBrowseShowExtensionNull {
            get {
                if ((curObj["DirBrowseShowExtension"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool DirBrowseShowExtension {
            get {
                if ((curObj["DirBrowseShowExtension"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["DirBrowseShowExtension"]));
            }
            set {
                curObj["DirBrowseShowExtension"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsDirBrowseShowLongDateNull {
            get {
                if ((curObj["DirBrowseShowLongDate"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool DirBrowseShowLongDate {
            get {
                if ((curObj["DirBrowseShowLongDate"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["DirBrowseShowLongDate"]));
            }
            set {
                curObj["DirBrowseShowLongDate"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsDirBrowseShowSizeNull {
            get {
                if ((curObj["DirBrowseShowSize"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool DirBrowseShowSize {
            get {
                if ((curObj["DirBrowseShowSize"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["DirBrowseShowSize"]));
            }
            set {
                curObj["DirBrowseShowSize"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsDirBrowseShowTimeNull {
            get {
                if ((curObj["DirBrowseShowTime"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool DirBrowseShowTime {
            get {
                if ((curObj["DirBrowseShowTime"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["DirBrowseShowTime"]));
            }
            set {
                curObj["DirBrowseShowTime"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsDisableSocketPoolingNull {
            get {
                if ((curObj["DisableSocketPooling"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool DisableSocketPooling {
            get {
                if ((curObj["DisableSocketPooling"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["DisableSocketPooling"]));
            }
            set {
                curObj["DisableSocketPooling"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsDisableStaticFileCacheNull {
            get {
                if ((curObj["DisableStaticFileCache"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool DisableStaticFileCache {
            get {
                if ((curObj["DisableStaticFileCache"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["DisableStaticFileCache"]));
            }
            set {
                curObj["DisableStaticFileCache"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsDoDynamicCompressionNull {
            get {
                if ((curObj["DoDynamicCompression"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool DoDynamicCompression {
            get {
                if ((curObj["DoDynamicCompression"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["DoDynamicCompression"]));
            }
            set {
                curObj["DoDynamicCompression"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsDontLogNull {
            get {
                if ((curObj["DontLog"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool DontLog {
            get {
                if ((curObj["DontLog"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["DontLog"]));
            }
            set {
                curObj["DontLog"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsDoStaticCompressionNull {
            get {
                if ((curObj["DoStaticCompression"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool DoStaticCompression {
            get {
                if ((curObj["DoStaticCompression"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["DoStaticCompression"]));
            }
            set {
                curObj["DoStaticCompression"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsEnableDefaultDocNull {
            get {
                if ((curObj["EnableDefaultDoc"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool EnableDefaultDoc {
            get {
                if ((curObj["EnableDefaultDoc"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["EnableDefaultDoc"]));
            }
            set {
                curObj["EnableDefaultDoc"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsEnableDirBrowsingNull {
            get {
                if ((curObj["EnableDirBrowsing"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool EnableDirBrowsing {
            get {
                if ((curObj["EnableDirBrowsing"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["EnableDirBrowsing"]));
            }
            set {
                curObj["EnableDirBrowsing"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsEnableDocFooterNull {
            get {
                if ((curObj["EnableDocFooter"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool EnableDocFooter {
            get {
                if ((curObj["EnableDocFooter"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["EnableDocFooter"]));
            }
            set {
                curObj["EnableDocFooter"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsEnableReverseDnsNull {
            get {
                if ((curObj["EnableReverseDns"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool EnableReverseDns {
            get {
                if ((curObj["EnableReverseDns"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["EnableReverseDns"]));
            }
            set {
                curObj["EnableReverseDns"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsFrontPageWebNull {
            get {
                if ((curObj["FrontPageWeb"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool FrontPageWeb {
            get {
                if ((curObj["FrontPageWeb"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["FrontPageWeb"]));
            }
            set {
                curObj["FrontPageWeb"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public System.Management.ManagementBaseObject[] HttpCustomHeaders {
            get {
                return ((System.Management.ManagementBaseObject[])(curObj["HttpCustomHeaders"]));
            }
            set {
                curObj["HttpCustomHeaders"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public System.Management.ManagementBaseObject[] HttpErrors {
            get {
                return ((System.Management.ManagementBaseObject[])(curObj["HttpErrors"]));
            }
            set {
                curObj["HttpErrors"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string HttpExpires {
            get {
                return ((string)(curObj["HttpExpires"]));
            }
            set {
                curObj["HttpExpires"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string[] HttpPics {
            get {
                return ((string[])(curObj["HttpPics"]));
            }
            set {
                curObj["HttpPics"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileBytesRecvNull {
            get {
                if ((curObj["LogExtFileBytesRecv"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileBytesRecv {
            get {
                if ((curObj["LogExtFileBytesRecv"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileBytesRecv"]));
            }
            set {
                curObj["LogExtFileBytesRecv"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileBytesSentNull {
            get {
                if ((curObj["LogExtFileBytesSent"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileBytesSent {
            get {
                if ((curObj["LogExtFileBytesSent"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileBytesSent"]));
            }
            set {
                curObj["LogExtFileBytesSent"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileClientIpNull {
            get {
                if ((curObj["LogExtFileClientIp"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileClientIp {
            get {
                if ((curObj["LogExtFileClientIp"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileClientIp"]));
            }
            set {
                curObj["LogExtFileClientIp"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileComputerNameNull {
            get {
                if ((curObj["LogExtFileComputerName"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileComputerName {
            get {
                if ((curObj["LogExtFileComputerName"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileComputerName"]));
            }
            set {
                curObj["LogExtFileComputerName"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileCookieNull {
            get {
                if ((curObj["LogExtFileCookie"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileCookie {
            get {
                if ((curObj["LogExtFileCookie"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileCookie"]));
            }
            set {
                curObj["LogExtFileCookie"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileDateNull {
            get {
                if ((curObj["LogExtFileDate"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileDate {
            get {
                if ((curObj["LogExtFileDate"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileDate"]));
            }
            set {
                curObj["LogExtFileDate"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileFlagsNull {
            get {
                if ((curObj["LogExtFileFlags"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int LogExtFileFlags {
            get {
                if ((curObj["LogExtFileFlags"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["LogExtFileFlags"]));
            }
            set {
                curObj["LogExtFileFlags"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileHostNull {
            get {
                if ((curObj["LogExtFileHost"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileHost {
            get {
                if ((curObj["LogExtFileHost"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileHost"]));
            }
            set {
                curObj["LogExtFileHost"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileHttpStatusNull {
            get {
                if ((curObj["LogExtFileHttpStatus"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileHttpStatus {
            get {
                if ((curObj["LogExtFileHttpStatus"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileHttpStatus"]));
            }
            set {
                curObj["LogExtFileHttpStatus"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileHttpSubStatusNull {
            get {
                if ((curObj["LogExtFileHttpSubStatus"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileHttpSubStatus {
            get {
                if ((curObj["LogExtFileHttpSubStatus"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileHttpSubStatus"]));
            }
            set {
                curObj["LogExtFileHttpSubStatus"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileMethodNull {
            get {
                if ((curObj["LogExtFileMethod"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileMethod {
            get {
                if ((curObj["LogExtFileMethod"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileMethod"]));
            }
            set {
                curObj["LogExtFileMethod"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileProtocolVersionNull {
            get {
                if ((curObj["LogExtFileProtocolVersion"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileProtocolVersion {
            get {
                if ((curObj["LogExtFileProtocolVersion"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileProtocolVersion"]));
            }
            set {
                curObj["LogExtFileProtocolVersion"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileRefererNull {
            get {
                if ((curObj["LogExtFileReferer"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileReferer {
            get {
                if ((curObj["LogExtFileReferer"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileReferer"]));
            }
            set {
                curObj["LogExtFileReferer"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileServerIpNull {
            get {
                if ((curObj["LogExtFileServerIp"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileServerIp {
            get {
                if ((curObj["LogExtFileServerIp"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileServerIp"]));
            }
            set {
                curObj["LogExtFileServerIp"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileServerPortNull {
            get {
                if ((curObj["LogExtFileServerPort"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileServerPort {
            get {
                if ((curObj["LogExtFileServerPort"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileServerPort"]));
            }
            set {
                curObj["LogExtFileServerPort"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileSiteNameNull {
            get {
                if ((curObj["LogExtFileSiteName"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileSiteName {
            get {
                if ((curObj["LogExtFileSiteName"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileSiteName"]));
            }
            set {
                curObj["LogExtFileSiteName"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileTimeNull {
            get {
                if ((curObj["LogExtFileTime"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileTime {
            get {
                if ((curObj["LogExtFileTime"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileTime"]));
            }
            set {
                curObj["LogExtFileTime"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileTimeTakenNull {
            get {
                if ((curObj["LogExtFileTimeTaken"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileTimeTaken {
            get {
                if ((curObj["LogExtFileTimeTaken"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileTimeTaken"]));
            }
            set {
                curObj["LogExtFileTimeTaken"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileUriQueryNull {
            get {
                if ((curObj["LogExtFileUriQuery"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileUriQuery {
            get {
                if ((curObj["LogExtFileUriQuery"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileUriQuery"]));
            }
            set {
                curObj["LogExtFileUriQuery"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileUriStemNull {
            get {
                if ((curObj["LogExtFileUriStem"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileUriStem {
            get {
                if ((curObj["LogExtFileUriStem"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileUriStem"]));
            }
            set {
                curObj["LogExtFileUriStem"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileUserAgentNull {
            get {
                if ((curObj["LogExtFileUserAgent"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileUserAgent {
            get {
                if ((curObj["LogExtFileUserAgent"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileUserAgent"]));
            }
            set {
                curObj["LogExtFileUserAgent"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileUserNameNull {
            get {
                if ((curObj["LogExtFileUserName"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileUserName {
            get {
                if ((curObj["LogExtFileUserName"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileUserName"]));
            }
            set {
                curObj["LogExtFileUserName"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileWin32StatusNull {
            get {
                if ((curObj["LogExtFileWin32Status"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileWin32Status {
            get {
                if ((curObj["LogExtFileWin32Status"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileWin32Status"]));
            }
            set {
                curObj["LogExtFileWin32Status"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string LogFileDirectory {
            get {
                return ((string)(curObj["LogFileDirectory"]));
            }
            set {
                curObj["LogFileDirectory"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogFileLocaltimeRolloverNull {
            get {
                if ((curObj["LogFileLocaltimeRollover"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogFileLocaltimeRollover {
            get {
                if ((curObj["LogFileLocaltimeRollover"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogFileLocaltimeRollover"]));
            }
            set {
                curObj["LogFileLocaltimeRollover"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogFilePeriodNull {
            get {
                if ((curObj["LogFilePeriod"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int LogFilePeriod {
            get {
                if ((curObj["LogFilePeriod"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["LogFilePeriod"]));
            }
            set {
                curObj["LogFilePeriod"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogFileTruncateSizeNull {
            get {
                if ((curObj["LogFileTruncateSize"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int LogFileTruncateSize {
            get {
                if ((curObj["LogFileTruncateSize"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["LogFileTruncateSize"]));
            }
            set {
                curObj["LogFileTruncateSize"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string LogOdbcDataSource {
            get {
                return ((string)(curObj["LogOdbcDataSource"]));
            }
            set {
                curObj["LogOdbcDataSource"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string LogOdbcPassword {
            get {
                return ((string)(curObj["LogOdbcPassword"]));
            }
            set {
                curObj["LogOdbcPassword"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string LogOdbcTableName {
            get {
                return ((string)(curObj["LogOdbcTableName"]));
            }
            set {
                curObj["LogOdbcTableName"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string LogOdbcUserName {
            get {
                return ((string)(curObj["LogOdbcUserName"]));
            }
            set {
                curObj["LogOdbcUserName"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogonMethodNull {
            get {
                if ((curObj["LogonMethod"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int LogonMethod {
            get {
                if ((curObj["LogonMethod"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["LogonMethod"]));
            }
            set {
                curObj["LogonMethod"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string LogPluginClsid {
            get {
                return ((string)(curObj["LogPluginClsid"]));
            }
            set {
                curObj["LogPluginClsid"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogTypeNull {
            get {
                if ((curObj["LogType"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int LogType {
            get {
                if ((curObj["LogType"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["LogType"]));
            }
            set {
                curObj["LogType"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsMaxBandwidthNull {
            get {
                if ((curObj["MaxBandwidth"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int MaxBandwidth {
            get {
                if ((curObj["MaxBandwidth"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["MaxBandwidth"]));
            }
            set {
                curObj["MaxBandwidth"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsMaxBandwidthBlockedNull {
            get {
                if ((curObj["MaxBandwidthBlocked"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int MaxBandwidthBlocked {
            get {
                if ((curObj["MaxBandwidthBlocked"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["MaxBandwidthBlocked"]));
            }
            set {
                curObj["MaxBandwidthBlocked"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsMaxConnectionsNull {
            get {
                if ((curObj["MaxConnections"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int MaxConnections {
            get {
                if ((curObj["MaxConnections"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["MaxConnections"]));
            }
            set {
                curObj["MaxConnections"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsMaxEndpointConnectionsNull {
            get {
                if ((curObj["MaxEndpointConnections"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int MaxEndpointConnections {
            get {
                if ((curObj["MaxEndpointConnections"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["MaxEndpointConnections"]));
            }
            set {
                curObj["MaxEndpointConnections"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsMaxRequestEntityAllowedNull {
            get {
                if ((curObj["MaxRequestEntityAllowed"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int MaxRequestEntityAllowed {
            get {
                if ((curObj["MaxRequestEntityAllowed"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["MaxRequestEntityAllowed"]));
            }
            set {
                curObj["MaxRequestEntityAllowed"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public System.Management.ManagementBaseObject[] MimeMap {
            get {
                return ((System.Management.ManagementBaseObject[])(curObj["MimeMap"]));
            }
            set {
                curObj["MimeMap"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string Name {
            get {
                return ((string)(curObj["Name"]));
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string NTAuthenticationProviders {
            get {
                return ((string)(curObj["NTAuthenticationProviders"]));
            }
            set {
                curObj["NTAuthenticationProviders"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsPassportRequireADMappingNull {
            get {
                if ((curObj["PassportRequireADMapping"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int PassportRequireADMapping {
            get {
                if ((curObj["PassportRequireADMapping"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["PassportRequireADMapping"]));
            }
            set {
                curObj["PassportRequireADMapping"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsPasswordCacheTTLNull {
            get {
                if ((curObj["PasswordCacheTTL"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int PasswordCacheTTL {
            get {
                if ((curObj["PasswordCacheTTL"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["PasswordCacheTTL"]));
            }
            set {
                curObj["PasswordCacheTTL"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsPasswordChangeFlagsNull {
            get {
                if ((curObj["PasswordChangeFlags"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int PasswordChangeFlags {
            get {
                if ((curObj["PasswordChangeFlags"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["PasswordChangeFlags"]));
            }
            set {
                curObj["PasswordChangeFlags"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsPasswordExpirePrenotifyDaysNull {
            get {
                if ((curObj["PasswordExpirePrenotifyDays"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int PasswordExpirePrenotifyDays {
            get {
                if ((curObj["PasswordExpirePrenotifyDays"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["PasswordExpirePrenotifyDays"]));
            }
            set {
                curObj["PasswordExpirePrenotifyDays"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsPoolIdcTimeoutNull {
            get {
                if ((curObj["PoolIdcTimeout"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int PoolIdcTimeout {
            get {
                if ((curObj["PoolIdcTimeout"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["PoolIdcTimeout"]));
            }
            set {
                curObj["PoolIdcTimeout"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsProcessNTCRIfLoggedOnNull {
            get {
                if ((curObj["ProcessNTCRIfLoggedOn"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool ProcessNTCRIfLoggedOn {
            get {
                if ((curObj["ProcessNTCRIfLoggedOn"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["ProcessNTCRIfLoggedOn"]));
            }
            set {
                curObj["ProcessNTCRIfLoggedOn"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string Realm {
            get {
                return ((string)(curObj["Realm"]));
            }
            set {
                curObj["Realm"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string[] RedirectHeaders {
            get {
                return ((string[])(curObj["RedirectHeaders"]));
            }
            set {
                curObj["RedirectHeaders"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsRevocationFreshnessTimeNull {
            get {
                if ((curObj["RevocationFreshnessTime"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int RevocationFreshnessTime {
            get {
                if ((curObj["RevocationFreshnessTime"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["RevocationFreshnessTime"]));
            }
            set {
                curObj["RevocationFreshnessTime"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsRevocationURLRetrievalTimeoutNull {
            get {
                if ((curObj["RevocationURLRetrievalTimeout"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int RevocationURLRetrievalTimeout {
            get {
                if ((curObj["RevocationURLRetrievalTimeout"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["RevocationURLRetrievalTimeout"]));
            }
            set {
                curObj["RevocationURLRetrievalTimeout"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public System.Management.ManagementBaseObject[] ScriptMaps {
            get {
                return ((System.Management.ManagementBaseObject[])(curObj["ScriptMaps"]));
            }
            set {
                curObj["ScriptMaps"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public System.Management.ManagementBaseObject[] SecureBindings {
            get {
                return ((System.Management.ManagementBaseObject[])(curObj["SecureBindings"]));
            }
            set {
                curObj["SecureBindings"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsServerAutoStartNull {
            get {
                if ((curObj["ServerAutoStart"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool ServerAutoStart {
            get {
                if ((curObj["ServerAutoStart"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["ServerAutoStart"]));
            }
            set {
                curObj["ServerAutoStart"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public System.Management.ManagementBaseObject[] ServerBindings {
            get {
                return ((System.Management.ManagementBaseObject[])(curObj["ServerBindings"]));
            }
            set {
                curObj["ServerBindings"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsServerCommandNull {
            get {
                if ((curObj["ServerCommand"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int ServerCommand {
            get {
                if ((curObj["ServerCommand"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["ServerCommand"]));
            }
            set {
                curObj["ServerCommand"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string ServerComment {
            get {
                return ((string)(curObj["ServerComment"]));
            }
            set {
                curObj["ServerComment"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string ServerID {
            get {
                return ((string)(curObj["ServerID"]));
            }
            set {
                curObj["ServerID"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsServerListenBacklogNull {
            get {
                if ((curObj["ServerListenBacklog"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int ServerListenBacklog {
            get {
                if ((curObj["ServerListenBacklog"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["ServerListenBacklog"]));
            }
            set {
                curObj["ServerListenBacklog"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsServerListenTimeoutNull {
            get {
                if ((curObj["ServerListenTimeout"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int ServerListenTimeout {
            get {
                if ((curObj["ServerListenTimeout"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["ServerListenTimeout"]));
            }
            set {
                curObj["ServerListenTimeout"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsServerSizeNull {
            get {
                if ((curObj["ServerSize"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int ServerSize {
            get {
                if ((curObj["ServerSize"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["ServerSize"]));
            }
            set {
                curObj["ServerSize"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string SetHostName {
            get {
                return ((string)(curObj["SetHostName"]));
            }
            set {
                curObj["SetHostName"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string SettingID {
            get {
                return ((string)(curObj["SettingID"]));
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsShutdownTimeLimitNull {
            get {
                if ((curObj["ShutdownTimeLimit"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int ShutdownTimeLimit {
            get {
                if ((curObj["ShutdownTimeLimit"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["ShutdownTimeLimit"]));
            }
            set {
                curObj["ShutdownTimeLimit"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsSSIExecDisableNull {
            get {
                if ((curObj["SSIExecDisable"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool SSIExecDisable {
            get {
                if ((curObj["SSIExecDisable"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["SSIExecDisable"]));
            }
            set {
                curObj["SSIExecDisable"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsSSLAlwaysNegoClientCertNull {
            get {
                if ((curObj["SSLAlwaysNegoClientCert"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool SSLAlwaysNegoClientCert {
            get {
                if ((curObj["SSLAlwaysNegoClientCert"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["SSLAlwaysNegoClientCert"]));
            }
            set {
                curObj["SSLAlwaysNegoClientCert"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string SslCtlIdentifier {
            get {
                return ((string)(curObj["SslCtlIdentifier"]));
            }
            set {
                curObj["SslCtlIdentifier"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string SslCtlStoreName {
            get {
                return ((string)(curObj["SslCtlStoreName"]));
            }
            set {
                curObj["SslCtlStoreName"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string SSLStoreName {
            get {
                return ((string)(curObj["SSLStoreName"]));
            }
            set {
                curObj["SSLStoreName"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string[] TraceUriPrefix {
            get {
                return ((string[])(curObj["TraceUriPrefix"]));
            }
            set {
                curObj["TraceUriPrefix"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsUploadReadAheadSizeNull {
            get {
                if ((curObj["UploadReadAheadSize"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int UploadReadAheadSize {
            get {
                if ((curObj["UploadReadAheadSize"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["UploadReadAheadSize"]));
            }
            set {
                curObj["UploadReadAheadSize"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsUseDigestSSPNull {
            get {
                if ((curObj["UseDigestSSP"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool UseDigestSSP {
            get {
                if ((curObj["UseDigestSSP"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["UseDigestSSP"]));
            }
            set {
                curObj["UseDigestSSP"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsUseHostNameNull {
            get {
                if ((curObj["UseHostName"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool UseHostName {
            get {
                if ((curObj["UseHostName"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["UseHostName"]));
            }
            set {
                curObj["UseHostName"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsWebDAVMaxAttributesPerElementNull {
            get {
                if ((curObj["WebDAVMaxAttributesPerElement"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int WebDAVMaxAttributesPerElement {
            get {
                if ((curObj["WebDAVMaxAttributesPerElement"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["WebDAVMaxAttributesPerElement"]));
            }
            set {
                curObj["WebDAVMaxAttributesPerElement"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsWin32ErrorNull {
            get {
                if ((curObj["Win32Error"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int Win32Error {
            get {
                if ((curObj["Win32Error"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["Win32Error"]));
            }
            set {
                curObj["Win32Error"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        private bool CheckIfProperClass(System.Management.ManagementScope mgmtScope, System.Management.ManagementPath path, System.Management.ObjectGetOptions OptionsParam) {
            if (((path != null) 
                        && (System.String.Compare(path.ClassName, ManagementClassName, true, CultureInfo.InvariantCulture) == 0))) {
                return true;
            }
            else {
                return CheckIfProperClass(new System.Management.ManagementObject(mgmtScope, path, OptionsParam));
            }
        }
        
        private bool CheckIfProperClass(System.Management.ManagementBaseObject theObj) {
            if (((theObj != null) 
                        && (System.String.Compare(((string)(theObj["__CLASS"])), ManagementClassName, true, CultureInfo.InvariantCulture) == 0))) {
                return true;
            }
            else {
                System.Array parentClasses = ((System.Array)(theObj["__DERIVATION"]));
                if ((parentClasses != null)) {
                    Int32 count = 0;
                    for (count = 0; (count < parentClasses.Length); count = (count + 1)) {
                        if ((System.String.Compare(((string)(parentClasses.GetValue(count))), ManagementClassName, true, CultureInfo.InvariantCulture) == 0)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        
        private bool ShouldSerializeAccessExecute() {
            if ((IsAccessExecuteNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessExecute() {
            curObj["AccessExecute"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessFlags() {
            if ((IsAccessFlagsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessFlags() {
            curObj["AccessFlags"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessNoPhysicalDir() {
            if ((IsAccessNoPhysicalDirNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessNoPhysicalDir() {
            curObj["AccessNoPhysicalDir"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessNoRemoteExecute() {
            if ((IsAccessNoRemoteExecuteNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessNoRemoteExecute() {
            curObj["AccessNoRemoteExecute"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessNoRemoteRead() {
            if ((IsAccessNoRemoteReadNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessNoRemoteRead() {
            curObj["AccessNoRemoteRead"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessNoRemoteScript() {
            if ((IsAccessNoRemoteScriptNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessNoRemoteScript() {
            curObj["AccessNoRemoteScript"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessNoRemoteWrite() {
            if ((IsAccessNoRemoteWriteNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessNoRemoteWrite() {
            curObj["AccessNoRemoteWrite"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessRead() {
            if ((IsAccessReadNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessRead() {
            curObj["AccessRead"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessScript() {
            if ((IsAccessScriptNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessScript() {
            curObj["AccessScript"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessSource() {
            if ((IsAccessSourceNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessSource() {
            curObj["AccessSource"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessSSL() {
            if ((IsAccessSSLNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessSSL() {
            curObj["AccessSSL"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessSSL128() {
            if ((IsAccessSSL128Null == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessSSL128() {
            curObj["AccessSSL128"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessSSLFlags() {
            if ((IsAccessSSLFlagsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessSSLFlags() {
            curObj["AccessSSLFlags"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessSSLMapCert() {
            if ((IsAccessSSLMapCertNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessSSLMapCert() {
            curObj["AccessSSLMapCert"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessSSLNegotiateCert() {
            if ((IsAccessSSLNegotiateCertNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessSSLNegotiateCert() {
            curObj["AccessSSLNegotiateCert"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessSSLRequireCert() {
            if ((IsAccessSSLRequireCertNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessSSLRequireCert() {
            curObj["AccessSSLRequireCert"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessWrite() {
            if ((IsAccessWriteNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessWrite() {
            curObj["AccessWrite"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAdminACLBin() {
            curObj["AdminACLBin"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAllowKeepAlive() {
            if ((IsAllowKeepAliveNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAllowKeepAlive() {
            curObj["AllowKeepAlive"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAllowPathInfoForScriptMappings() {
            if ((IsAllowPathInfoForScriptMappingsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAllowPathInfoForScriptMappings() {
            curObj["AllowPathInfoForScriptMappings"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAnonymousPasswordSync() {
            if ((IsAnonymousPasswordSyncNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAnonymousPasswordSync() {
            curObj["AnonymousPasswordSync"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAnonymousUserName() {
            curObj["AnonymousUserName"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAnonymousUserPass() {
            curObj["AnonymousUserPass"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAppAllowClientDebug() {
            if ((IsAppAllowClientDebugNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAppAllowClientDebug() {
            curObj["AppAllowClientDebug"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAppAllowDebugging() {
            if ((IsAppAllowDebuggingNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAppAllowDebugging() {
            curObj["AppAllowDebugging"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAppFriendlyName() {
            curObj["AppFriendlyName"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAppOopRecoverLimit() {
            if ((IsAppOopRecoverLimitNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAppOopRecoverLimit() {
            curObj["AppOopRecoverLimit"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAppPoolId() {
            curObj["AppPoolId"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAppWamClsid() {
            curObj["AppWamClsid"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspAllowOutOfProcComponents() {
            if ((IsAspAllowOutOfProcComponentsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspAllowOutOfProcComponents() {
            curObj["AspAllowOutOfProcComponents"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspAllowSessionState() {
            if ((IsAspAllowSessionStateNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspAllowSessionState() {
            curObj["AspAllowSessionState"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspAppServiceFlags() {
            if ((IsAspAppServiceFlagsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspAppServiceFlags() {
            curObj["AspAppServiceFlags"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspBufferingLimit() {
            if ((IsAspBufferingLimitNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspBufferingLimit() {
            curObj["AspBufferingLimit"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspBufferingOn() {
            if ((IsAspBufferingOnNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspBufferingOn() {
            curObj["AspBufferingOn"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspCalcLineNumber() {
            if ((IsAspCalcLineNumberNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspCalcLineNumber() {
            curObj["AspCalcLineNumber"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspCodepage() {
            if ((IsAspCodepageNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspCodepage() {
            curObj["AspCodepage"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAspDiskTemplateCacheDirectory() {
            curObj["AspDiskTemplateCacheDirectory"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspEnableApplicationRestart() {
            if ((IsAspEnableApplicationRestartNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspEnableApplicationRestart() {
            curObj["AspEnableApplicationRestart"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspEnableAspHtmlFallback() {
            if ((IsAspEnableAspHtmlFallbackNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspEnableAspHtmlFallback() {
            curObj["AspEnableAspHtmlFallback"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspEnableChunkedEncoding() {
            if ((IsAspEnableChunkedEncodingNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspEnableChunkedEncoding() {
            curObj["AspEnableChunkedEncoding"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspEnableParentPaths() {
            if ((IsAspEnableParentPathsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspEnableParentPaths() {
            curObj["AspEnableParentPaths"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspEnableSxs() {
            if ((IsAspEnableSxsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspEnableSxs() {
            curObj["AspEnableSxs"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspEnableTracker() {
            if ((IsAspEnableTrackerNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspEnableTracker() {
            curObj["AspEnableTracker"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspEnableTypelibCache() {
            if ((IsAspEnableTypelibCacheNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspEnableTypelibCache() {
            curObj["AspEnableTypelibCache"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspErrorsToNTLog() {
            if ((IsAspErrorsToNTLogNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspErrorsToNTLog() {
            curObj["AspErrorsToNTLog"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspExceptionCatchEnable() {
            if ((IsAspExceptionCatchEnableNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspExceptionCatchEnable() {
            curObj["AspExceptionCatchEnable"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspExecuteInMTA() {
            if ((IsAspExecuteInMTANull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspExecuteInMTA() {
            curObj["AspExecuteInMTA"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspKeepSessionIDSecure() {
            if ((IsAspKeepSessionIDSecureNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspKeepSessionIDSecure() {
            curObj["AspKeepSessionIDSecure"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspLCID() {
            if ((IsAspLCIDNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspLCID() {
            curObj["AspLCID"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspLogErrorRequests() {
            if ((IsAspLogErrorRequestsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspLogErrorRequests() {
            curObj["AspLogErrorRequests"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspMaxDiskTemplateCacheFiles() {
            if ((IsAspMaxDiskTemplateCacheFilesNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspMaxDiskTemplateCacheFiles() {
            curObj["AspMaxDiskTemplateCacheFiles"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspMaxRequestEntityAllowed() {
            if ((IsAspMaxRequestEntityAllowedNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspMaxRequestEntityAllowed() {
            curObj["AspMaxRequestEntityAllowed"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAspPartitionID() {
            curObj["AspPartitionID"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspProcessorThreadMax() {
            if ((IsAspProcessorThreadMaxNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspProcessorThreadMax() {
            curObj["AspProcessorThreadMax"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspQueueConnectionTestTime() {
            if ((IsAspQueueConnectionTestTimeNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspQueueConnectionTestTime() {
            curObj["AspQueueConnectionTestTime"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspQueueTimeout() {
            if ((IsAspQueueTimeoutNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspQueueTimeout() {
            curObj["AspQueueTimeout"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspRequestQueueMax() {
            if ((IsAspRequestQueueMaxNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspRequestQueueMax() {
            curObj["AspRequestQueueMax"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspRunOnEndAnonymously() {
            if ((IsAspRunOnEndAnonymouslyNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspRunOnEndAnonymously() {
            curObj["AspRunOnEndAnonymously"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspScriptEngineCacheMax() {
            if ((IsAspScriptEngineCacheMaxNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspScriptEngineCacheMax() {
            curObj["AspScriptEngineCacheMax"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAspScriptErrorMessage() {
            curObj["AspScriptErrorMessage"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspScriptErrorSentToBrowser() {
            if ((IsAspScriptErrorSentToBrowserNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspScriptErrorSentToBrowser() {
            curObj["AspScriptErrorSentToBrowser"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspScriptFileCacheSize() {
            if ((IsAspScriptFileCacheSizeNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspScriptFileCacheSize() {
            curObj["AspScriptFileCacheSize"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAspScriptLanguage() {
            curObj["AspScriptLanguage"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspScriptTimeout() {
            if ((IsAspScriptTimeoutNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspScriptTimeout() {
            curObj["AspScriptTimeout"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspSessionMax() {
            if ((IsAspSessionMaxNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspSessionMax() {
            curObj["AspSessionMax"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspSessionTimeout() {
            if ((IsAspSessionTimeoutNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspSessionTimeout() {
            curObj["AspSessionTimeout"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAspSxsName() {
            curObj["AspSxsName"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspTrackThreadingModel() {
            if ((IsAspTrackThreadingModelNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspTrackThreadingModel() {
            curObj["AspTrackThreadingModel"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspUsePartition() {
            if ((IsAspUsePartitionNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspUsePartition() {
            curObj["AspUsePartition"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAuthAdvNotifyDisable() {
            if ((IsAuthAdvNotifyDisableNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAuthAdvNotifyDisable() {
            curObj["AuthAdvNotifyDisable"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAuthAnonymous() {
            if ((IsAuthAnonymousNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAuthAnonymous() {
            curObj["AuthAnonymous"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAuthBasic() {
            if ((IsAuthBasicNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAuthBasic() {
            curObj["AuthBasic"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAuthChangeDisable() {
            if ((IsAuthChangeDisableNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAuthChangeDisable() {
            curObj["AuthChangeDisable"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAuthChangeUnsecure() {
            if ((IsAuthChangeUnsecureNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAuthChangeUnsecure() {
            curObj["AuthChangeUnsecure"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAuthFlags() {
            if ((IsAuthFlagsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAuthFlags() {
            curObj["AuthFlags"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAuthMD5() {
            if ((IsAuthMD5Null == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAuthMD5() {
            curObj["AuthMD5"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAuthNTLM() {
            if ((IsAuthNTLMNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAuthNTLM() {
            curObj["AuthNTLM"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAuthPassport() {
            if ((IsAuthPassportNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAuthPassport() {
            curObj["AuthPassport"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAuthPersistence() {
            if ((IsAuthPersistenceNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAuthPersistence() {
            curObj["AuthPersistence"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAuthPersistSingleRequest() {
            if ((IsAuthPersistSingleRequestNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAuthPersistSingleRequest() {
            curObj["AuthPersistSingleRequest"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAzEnable() {
            if ((IsAzEnableNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAzEnable() {
            curObj["AzEnable"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAzImpersonationLevel() {
            if ((IsAzImpersonationLevelNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAzImpersonationLevel() {
            curObj["AzImpersonationLevel"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAzScopeName() {
            curObj["AzScopeName"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAzStoreName() {
            curObj["AzStoreName"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetCacheControlCustom() {
            curObj["CacheControlCustom"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeCacheControlMaxAge() {
            if ((IsCacheControlMaxAgeNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetCacheControlMaxAge() {
            curObj["CacheControlMaxAge"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeCacheControlNoCache() {
            if ((IsCacheControlNoCacheNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetCacheControlNoCache() {
            curObj["CacheControlNoCache"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeCacheISAPI() {
            if ((IsCacheISAPINull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetCacheISAPI() {
            curObj["CacheISAPI"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeCertCheckMode() {
            if ((IsCertCheckModeNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetCertCheckMode() {
            curObj["CertCheckMode"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeCGITimeout() {
            if ((IsCGITimeoutNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetCGITimeout() {
            curObj["CGITimeout"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeClusterEnabled() {
            if ((IsClusterEnabledNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetClusterEnabled() {
            curObj["ClusterEnabled"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeConnectionTimeout() {
            if ((IsConnectionTimeoutNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetConnectionTimeout() {
            curObj["ConnectionTimeout"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeContentIndexed() {
            if ((IsContentIndexedNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetContentIndexed() {
            curObj["ContentIndexed"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeCreateCGIWithNewConsole() {
            if ((IsCreateCGIWithNewConsoleNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetCreateCGIWithNewConsole() {
            curObj["CreateCGIWithNewConsole"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeCreateProcessAsUser() {
            if ((IsCreateProcessAsUserNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetCreateProcessAsUser() {
            curObj["CreateProcessAsUser"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetDefaultDoc() {
            curObj["DefaultDoc"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetDefaultDocFooter() {
            curObj["DefaultDocFooter"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetDefaultLogonDomain() {
            curObj["DefaultLogonDomain"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeDirBrowseFlags() {
            if ((IsDirBrowseFlagsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetDirBrowseFlags() {
            curObj["DirBrowseFlags"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeDirBrowseShowDate() {
            if ((IsDirBrowseShowDateNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetDirBrowseShowDate() {
            curObj["DirBrowseShowDate"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeDirBrowseShowExtension() {
            if ((IsDirBrowseShowExtensionNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetDirBrowseShowExtension() {
            curObj["DirBrowseShowExtension"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeDirBrowseShowLongDate() {
            if ((IsDirBrowseShowLongDateNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetDirBrowseShowLongDate() {
            curObj["DirBrowseShowLongDate"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeDirBrowseShowSize() {
            if ((IsDirBrowseShowSizeNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetDirBrowseShowSize() {
            curObj["DirBrowseShowSize"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeDirBrowseShowTime() {
            if ((IsDirBrowseShowTimeNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetDirBrowseShowTime() {
            curObj["DirBrowseShowTime"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeDisableSocketPooling() {
            if ((IsDisableSocketPoolingNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetDisableSocketPooling() {
            curObj["DisableSocketPooling"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeDisableStaticFileCache() {
            if ((IsDisableStaticFileCacheNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetDisableStaticFileCache() {
            curObj["DisableStaticFileCache"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeDoDynamicCompression() {
            if ((IsDoDynamicCompressionNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetDoDynamicCompression() {
            curObj["DoDynamicCompression"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeDontLog() {
            if ((IsDontLogNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetDontLog() {
            curObj["DontLog"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeDoStaticCompression() {
            if ((IsDoStaticCompressionNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetDoStaticCompression() {
            curObj["DoStaticCompression"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeEnableDefaultDoc() {
            if ((IsEnableDefaultDocNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetEnableDefaultDoc() {
            curObj["EnableDefaultDoc"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeEnableDirBrowsing() {
            if ((IsEnableDirBrowsingNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetEnableDirBrowsing() {
            curObj["EnableDirBrowsing"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeEnableDocFooter() {
            if ((IsEnableDocFooterNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetEnableDocFooter() {
            curObj["EnableDocFooter"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeEnableReverseDns() {
            if ((IsEnableReverseDnsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetEnableReverseDns() {
            curObj["EnableReverseDns"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeFrontPageWeb() {
            if ((IsFrontPageWebNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetFrontPageWeb() {
            curObj["FrontPageWeb"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetHttpCustomHeaders() {
            curObj["HttpCustomHeaders"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetHttpErrors() {
            curObj["HttpErrors"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetHttpExpires() {
            curObj["HttpExpires"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetHttpPics() {
            curObj["HttpPics"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileBytesRecv() {
            if ((IsLogExtFileBytesRecvNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileBytesRecv() {
            curObj["LogExtFileBytesRecv"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileBytesSent() {
            if ((IsLogExtFileBytesSentNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileBytesSent() {
            curObj["LogExtFileBytesSent"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileClientIp() {
            if ((IsLogExtFileClientIpNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileClientIp() {
            curObj["LogExtFileClientIp"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileComputerName() {
            if ((IsLogExtFileComputerNameNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileComputerName() {
            curObj["LogExtFileComputerName"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileCookie() {
            if ((IsLogExtFileCookieNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileCookie() {
            curObj["LogExtFileCookie"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileDate() {
            if ((IsLogExtFileDateNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileDate() {
            curObj["LogExtFileDate"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileFlags() {
            if ((IsLogExtFileFlagsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileFlags() {
            curObj["LogExtFileFlags"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileHost() {
            if ((IsLogExtFileHostNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileHost() {
            curObj["LogExtFileHost"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileHttpStatus() {
            if ((IsLogExtFileHttpStatusNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileHttpStatus() {
            curObj["LogExtFileHttpStatus"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileHttpSubStatus() {
            if ((IsLogExtFileHttpSubStatusNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileHttpSubStatus() {
            curObj["LogExtFileHttpSubStatus"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileMethod() {
            if ((IsLogExtFileMethodNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileMethod() {
            curObj["LogExtFileMethod"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileProtocolVersion() {
            if ((IsLogExtFileProtocolVersionNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileProtocolVersion() {
            curObj["LogExtFileProtocolVersion"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileReferer() {
            if ((IsLogExtFileRefererNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileReferer() {
            curObj["LogExtFileReferer"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileServerIp() {
            if ((IsLogExtFileServerIpNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileServerIp() {
            curObj["LogExtFileServerIp"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileServerPort() {
            if ((IsLogExtFileServerPortNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileServerPort() {
            curObj["LogExtFileServerPort"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileSiteName() {
            if ((IsLogExtFileSiteNameNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileSiteName() {
            curObj["LogExtFileSiteName"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileTime() {
            if ((IsLogExtFileTimeNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileTime() {
            curObj["LogExtFileTime"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileTimeTaken() {
            if ((IsLogExtFileTimeTakenNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileTimeTaken() {
            curObj["LogExtFileTimeTaken"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileUriQuery() {
            if ((IsLogExtFileUriQueryNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileUriQuery() {
            curObj["LogExtFileUriQuery"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileUriStem() {
            if ((IsLogExtFileUriStemNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileUriStem() {
            curObj["LogExtFileUriStem"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileUserAgent() {
            if ((IsLogExtFileUserAgentNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileUserAgent() {
            curObj["LogExtFileUserAgent"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileUserName() {
            if ((IsLogExtFileUserNameNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileUserName() {
            curObj["LogExtFileUserName"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileWin32Status() {
            if ((IsLogExtFileWin32StatusNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileWin32Status() {
            curObj["LogExtFileWin32Status"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetLogFileDirectory() {
            curObj["LogFileDirectory"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogFileLocaltimeRollover() {
            if ((IsLogFileLocaltimeRolloverNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogFileLocaltimeRollover() {
            curObj["LogFileLocaltimeRollover"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogFilePeriod() {
            if ((IsLogFilePeriodNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogFilePeriod() {
            curObj["LogFilePeriod"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogFileTruncateSize() {
            if ((IsLogFileTruncateSizeNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogFileTruncateSize() {
            curObj["LogFileTruncateSize"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetLogOdbcDataSource() {
            curObj["LogOdbcDataSource"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetLogOdbcPassword() {
            curObj["LogOdbcPassword"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetLogOdbcTableName() {
            curObj["LogOdbcTableName"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetLogOdbcUserName() {
            curObj["LogOdbcUserName"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogonMethod() {
            if ((IsLogonMethodNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogonMethod() {
            curObj["LogonMethod"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetLogPluginClsid() {
            curObj["LogPluginClsid"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogType() {
            if ((IsLogTypeNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogType() {
            curObj["LogType"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeMaxBandwidth() {
            if ((IsMaxBandwidthNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetMaxBandwidth() {
            curObj["MaxBandwidth"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeMaxBandwidthBlocked() {
            if ((IsMaxBandwidthBlockedNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetMaxBandwidthBlocked() {
            curObj["MaxBandwidthBlocked"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeMaxConnections() {
            if ((IsMaxConnectionsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetMaxConnections() {
            curObj["MaxConnections"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeMaxEndpointConnections() {
            if ((IsMaxEndpointConnectionsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetMaxEndpointConnections() {
            curObj["MaxEndpointConnections"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeMaxRequestEntityAllowed() {
            if ((IsMaxRequestEntityAllowedNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetMaxRequestEntityAllowed() {
            curObj["MaxRequestEntityAllowed"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetMimeMap() {
            curObj["MimeMap"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetNTAuthenticationProviders() {
            curObj["NTAuthenticationProviders"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializePassportRequireADMapping() {
            if ((IsPassportRequireADMappingNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetPassportRequireADMapping() {
            curObj["PassportRequireADMapping"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializePasswordCacheTTL() {
            if ((IsPasswordCacheTTLNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetPasswordCacheTTL() {
            curObj["PasswordCacheTTL"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializePasswordChangeFlags() {
            if ((IsPasswordChangeFlagsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetPasswordChangeFlags() {
            curObj["PasswordChangeFlags"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializePasswordExpirePrenotifyDays() {
            if ((IsPasswordExpirePrenotifyDaysNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetPasswordExpirePrenotifyDays() {
            curObj["PasswordExpirePrenotifyDays"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializePoolIdcTimeout() {
            if ((IsPoolIdcTimeoutNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetPoolIdcTimeout() {
            curObj["PoolIdcTimeout"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeProcessNTCRIfLoggedOn() {
            if ((IsProcessNTCRIfLoggedOnNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetProcessNTCRIfLoggedOn() {
            curObj["ProcessNTCRIfLoggedOn"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetRealm() {
            curObj["Realm"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetRedirectHeaders() {
            curObj["RedirectHeaders"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeRevocationFreshnessTime() {
            if ((IsRevocationFreshnessTimeNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetRevocationFreshnessTime() {
            curObj["RevocationFreshnessTime"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeRevocationURLRetrievalTimeout() {
            if ((IsRevocationURLRetrievalTimeoutNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetRevocationURLRetrievalTimeout() {
            curObj["RevocationURLRetrievalTimeout"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetScriptMaps() {
            curObj["ScriptMaps"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetSecureBindings() {
            curObj["SecureBindings"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeServerAutoStart() {
            if ((IsServerAutoStartNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetServerAutoStart() {
            curObj["ServerAutoStart"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetServerBindings() {
            curObj["ServerBindings"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeServerCommand() {
            if ((IsServerCommandNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetServerCommand() {
            curObj["ServerCommand"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetServerComment() {
            curObj["ServerComment"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetServerID() {
            curObj["ServerID"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeServerListenBacklog() {
            if ((IsServerListenBacklogNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetServerListenBacklog() {
            curObj["ServerListenBacklog"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeServerListenTimeout() {
            if ((IsServerListenTimeoutNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetServerListenTimeout() {
            curObj["ServerListenTimeout"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeServerSize() {
            if ((IsServerSizeNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetServerSize() {
            curObj["ServerSize"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetSetHostName() {
            curObj["SetHostName"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeShutdownTimeLimit() {
            if ((IsShutdownTimeLimitNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetShutdownTimeLimit() {
            curObj["ShutdownTimeLimit"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeSSIExecDisable() {
            if ((IsSSIExecDisableNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetSSIExecDisable() {
            curObj["SSIExecDisable"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeSSLAlwaysNegoClientCert() {
            if ((IsSSLAlwaysNegoClientCertNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetSSLAlwaysNegoClientCert() {
            curObj["SSLAlwaysNegoClientCert"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetSslCtlIdentifier() {
            curObj["SslCtlIdentifier"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetSslCtlStoreName() {
            curObj["SslCtlStoreName"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetSSLStoreName() {
            curObj["SSLStoreName"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetTraceUriPrefix() {
            curObj["TraceUriPrefix"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeUploadReadAheadSize() {
            if ((IsUploadReadAheadSizeNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetUploadReadAheadSize() {
            curObj["UploadReadAheadSize"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeUseDigestSSP() {
            if ((IsUseDigestSSPNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetUseDigestSSP() {
            curObj["UseDigestSSP"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeUseHostName() {
            if ((IsUseHostNameNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetUseHostName() {
            curObj["UseHostName"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeWebDAVMaxAttributesPerElement() {
            if ((IsWebDAVMaxAttributesPerElementNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetWebDAVMaxAttributesPerElement() {
            curObj["WebDAVMaxAttributesPerElement"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeWin32Error() {
            if ((IsWin32ErrorNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetWin32Error() {
            curObj["Win32Error"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        [Browsable(true)]
        public void CommitObject() {
            if ((isEmbedded == false)) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private static string ConstructPath(string keyName) {
            string strPath = "ROOT\\MicrosoftIISv2:IIsWebServerSetting";
            strPath = (strPath 
                        + (".Name=" 
                        + ("\"" 
                        + (keyName + "\""))));
            return strPath;
        }
        
        // Different overloads of GetInstances() help in enumerating instances of the WMI class.
        public static IIsWebServerSettingCollection GetInstances() {
            return GetInstances(((System.Management.ManagementScope)(null)), ((System.Management.EnumerationOptions)(null)));
        }
        
        public static IIsWebServerSettingCollection GetInstances(string condition) {
            return GetInstances(null, condition, null);
        }
        
        public static IIsWebServerSettingCollection GetInstances(System.String [] selectedProperties) {
            return GetInstances(null, null, selectedProperties);
        }
        
        public static IIsWebServerSettingCollection GetInstances(string condition, System.String [] selectedProperties) {
            return GetInstances(null, condition, selectedProperties);
        }
        
        public static IIsWebServerSettingCollection GetInstances(System.Management.ManagementScope mgmtScope, System.Management.EnumerationOptions enumOptions) {
            if ((mgmtScope == null)) {
                if ((statMgmtScope == null)) {
                    mgmtScope = new System.Management.ManagementScope();
                    mgmtScope.Path.NamespacePath = "root\\MicrosoftIISv2";
                }
                else {
                    mgmtScope = statMgmtScope;
                }
            }
            System.Management.ManagementPath pathObj = new System.Management.ManagementPath();
            pathObj.ClassName = "IIsWebServerSetting";
            pathObj.NamespacePath = "root\\MicrosoftIISv2";
            System.Management.ManagementClass clsObject = new System.Management.ManagementClass(mgmtScope, pathObj, null);
            if ((enumOptions == null)) {
                enumOptions = new System.Management.EnumerationOptions();
                enumOptions.EnsureLocatable = true;
            }
            return new IIsWebServerSettingCollection(clsObject.GetInstances(enumOptions));
        }
        
        public static IIsWebServerSettingCollection GetInstances(System.Management.ManagementScope mgmtScope, string condition) {
            return GetInstances(mgmtScope, condition, null);
        }
        
        public static IIsWebServerSettingCollection GetInstances(System.Management.ManagementScope mgmtScope, System.String [] selectedProperties) {
            return GetInstances(mgmtScope, null, selectedProperties);
        }
        
        public static IIsWebServerSettingCollection GetInstances(System.Management.ManagementScope mgmtScope, string condition, System.String [] selectedProperties) {
            if ((mgmtScope == null)) {
                if ((statMgmtScope == null)) {
                    mgmtScope = new System.Management.ManagementScope();
                    mgmtScope.Path.NamespacePath = "root\\MicrosoftIISv2";
                }
                else {
                    mgmtScope = statMgmtScope;
                }
            }
            System.Management.ManagementObjectSearcher ObjectSearcher = new System.Management.ManagementObjectSearcher(mgmtScope, new SelectQuery("IIsWebServerSetting", condition, selectedProperties));
            System.Management.EnumerationOptions enumOptions = new System.Management.EnumerationOptions();
            enumOptions.EnsureLocatable = true;
            ObjectSearcher.Options = enumOptions;
            return new IIsWebServerSettingCollection(ObjectSearcher.Get());
        }
        
        [Browsable(true)]
        public static IIsWebServerSetting CreateInstance() {
            System.Management.ManagementScope mgmtScope = null;
            if ((statMgmtScope == null)) {
                mgmtScope = new System.Management.ManagementScope();
                mgmtScope.Path.NamespacePath = CreatedWmiNamespace;
            }
            else {
                mgmtScope = statMgmtScope;
            }
            System.Management.ManagementPath mgmtPath = new System.Management.ManagementPath(CreatedClassName);
            return new IIsWebServerSetting(new System.Management.ManagementClass(mgmtScope, mgmtPath, null).CreateInstance());
        }
        
        [Browsable(true)]
        public void Delete() {
            PrivateLateBoundObject.Delete();
        }
        
        // Enumerator implementation for enumerating instances of the class.
        public class IIsWebServerSettingCollection : object, ICollection {
            
            private ManagementObjectCollection ObjectCollection;
            
            public IIsWebServerSettingCollection(ManagementObjectCollection objCollection) {
                ObjectCollection = objCollection;
            }
            
            public int Count {
                get {
                    return ObjectCollection.Count;
                }
            }
            
            public bool IsSynchronized {
                get {
                    return ObjectCollection.IsSynchronized;
                }
            }
            
            public object SyncRoot {
                get {
                    return this;
                }
            }
            
            public void CopyTo(System.Array array, int index) {
                ObjectCollection.CopyTo(array, index);
                int nCtr;
                for (nCtr = 0; (nCtr < array.Length); nCtr = (nCtr + 1)) {
                    array.SetValue(new IIsWebServerSetting(((System.Management.ManagementObject)(array.GetValue(nCtr)))), nCtr);
                }
            }
            
            public System.Collections.IEnumerator GetEnumerator() {
                return new IIsWebServerSettingEnumerator(ObjectCollection.GetEnumerator());
            }
            
            public class IIsWebServerSettingEnumerator : object, System.Collections.IEnumerator {
                
                private ManagementObjectCollection.ManagementObjectEnumerator ObjectEnumerator;
                
                public IIsWebServerSettingEnumerator(ManagementObjectCollection.ManagementObjectEnumerator objEnum) {
                    ObjectEnumerator = objEnum;
                }
                
                public object Current {
                    get {
                        return new IIsWebServerSetting(((System.Management.ManagementObject)(ObjectEnumerator.Current)));
                    }
                }
                
                public bool MoveNext() {
                    return ObjectEnumerator.MoveNext();
                }
                
                public void Reset() {
                    ObjectEnumerator.Reset();
                }
            }
        }
        
        // TypeConverter to handle null values for ValueType properties
        public class WMIValueTypeConverter : TypeConverter {
            
            private TypeConverter baseConverter;
            
            public WMIValueTypeConverter(System.Type baseType) {
                baseConverter = TypeDescriptor.GetConverter(baseType);
            }
            
            public override bool CanConvertFrom(System.ComponentModel.ITypeDescriptorContext context, System.Type srcType) {
                return baseConverter.CanConvertFrom(context, srcType);
            }
            
            public override bool CanConvertTo(System.ComponentModel.ITypeDescriptorContext context, System.Type destinationType) {
                return baseConverter.CanConvertTo(context, destinationType);
            }
            
            public override object ConvertFrom(System.ComponentModel.ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value) {
                return baseConverter.ConvertFrom(context, culture, value);
            }
            
            public override object CreateInstance(System.ComponentModel.ITypeDescriptorContext context, System.Collections.IDictionary dictionary) {
                return baseConverter.CreateInstance(context, dictionary);
            }
            
            public override bool GetCreateInstanceSupported(System.ComponentModel.ITypeDescriptorContext context) {
                return baseConverter.GetCreateInstanceSupported(context);
            }
            
            public override PropertyDescriptorCollection GetProperties(System.ComponentModel.ITypeDescriptorContext context, object value, System.Attribute[] attributeVar) {
                return baseConverter.GetProperties(context, value, attributeVar);
            }
            
            public override bool GetPropertiesSupported(System.ComponentModel.ITypeDescriptorContext context) {
                return baseConverter.GetPropertiesSupported(context);
            }
            
            public override System.ComponentModel.TypeConverter.StandardValuesCollection GetStandardValues(System.ComponentModel.ITypeDescriptorContext context) {
                return baseConverter.GetStandardValues(context);
            }
            
            public override bool GetStandardValuesExclusive(System.ComponentModel.ITypeDescriptorContext context) {
                return baseConverter.GetStandardValuesExclusive(context);
            }
            
            public override bool GetStandardValuesSupported(System.ComponentModel.ITypeDescriptorContext context) {
                return baseConverter.GetStandardValuesSupported(context);
            }
            
            public override object ConvertTo(System.ComponentModel.ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value, System.Type destinationType) {
                if ((context != null)) {
                    if ((context.PropertyDescriptor.ShouldSerializeValue(context.Instance) == false)) {
                        return "";
                    }
                }
                return baseConverter.ConvertTo(context, culture, value, destinationType);
            }
        }
        
        // Embedded class to represent WMI system Properties.
        [TypeConverter(typeof(System.ComponentModel.ExpandableObjectConverter))]
        public class ManagementSystemProperties {
            
            private System.Management.ManagementBaseObject PrivateLateBoundObject;
            
            public ManagementSystemProperties(System.Management.ManagementBaseObject ManagedObject) {
                PrivateLateBoundObject = ManagedObject;
            }
            
            [Browsable(true)]
            public int GENUS {
                get {
                    return ((int)(PrivateLateBoundObject["__GENUS"]));
                }
            }
            
            [Browsable(true)]
            public string CLASS {
                get {
                    return ((string)(PrivateLateBoundObject["__CLASS"]));
                }
            }
            
            [Browsable(true)]
            public string SUPERCLASS {
                get {
                    return ((string)(PrivateLateBoundObject["__SUPERCLASS"]));
                }
            }
            
            [Browsable(true)]
            public string DYNASTY {
                get {
                    return ((string)(PrivateLateBoundObject["__DYNASTY"]));
                }
            }
            
            [Browsable(true)]
            public string RELPATH {
                get {
                    return ((string)(PrivateLateBoundObject["__RELPATH"]));
                }
            }
            
            [Browsable(true)]
            public int PROPERTY_COUNT {
                get {
                    return ((int)(PrivateLateBoundObject["__PROPERTY_COUNT"]));
                }
            }
            
            [Browsable(true)]
            public string[] DERIVATION {
                get {
                    return ((string[])(PrivateLateBoundObject["__DERIVATION"]));
                }
            }
            
            [Browsable(true)]
            public string SERVER {
                get {
                    return ((string)(PrivateLateBoundObject["__SERVER"]));
                }
            }
            
            [Browsable(true)]
            public string NAMESPACE {
                get {
                    return ((string)(PrivateLateBoundObject["__NAMESPACE"]));
                }
            }
            
            [Browsable(true)]
            public string PATH {
                get {
                    return ((string)(PrivateLateBoundObject["__PATH"]));
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\health\dll\Block_FrontEndAppHealth.cs ===
// 
// Block_FrontEndApp.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Common healthblock implementation for verifying the Health of an FEApp derived application.
// To start with, that health just means checked whether the app is initialized.
// 
// Author: TheoM - 07/2008
//

using System;
using System.Collections.Specialized;
using System.Reflection;

using xonline.common.config;

namespace xonline.common.health
{

// --------------------------------------------------------------------------------------
// FrontEndApp - checks that a FEApp-derived service's configuration is loaded, 
//                       based on the fInitialized member.
//
// PARAMETERS:
//
// "type" : the full type name of the derived class. This must match exactly, and is a required param.
//
// Example: "xonline.server.stats.fd.StatsFrontEndApp"
//
// --------------------------------------------------------------------------------------
    public class FrontEndAppHealth : IHealthBlock
    {
        public ResourceTypeEnum ResourceType 
        { 
            get { return ResourceTypeEnum.Local; }
        }

        public void DoCheck(
            HealthBlockManager  blockManager,
            NameValueCollection blockParams,
            HealthReport        report)
        {
            // for almost all front end apps, the assembly where the
            // "FrontEndApp" class is located is the same as the app

            Assembly assembly = Config.Assembly;
            Type oType = assembly.GetType("xonline.common.service.FrontEndApp");

            // if it isn't there,  then we  go  after  the internal
            // version of the  class  which  is  always  in XblCore

            if (oType == null)
            {
                oType = Type.GetType("xonline.common.service.FrontEndAppInternal, XblCore");
            }

            FrontEndAppHealthReport myReport = new FrontEndAppHealthReport();
            report.ExtendedReport = myReport;

            // if we don't have a type at this point then something
            // is seriously wrong  with  the  installed  assemblies

            if (oType == null)
            {
                myReport.fInitialized = false;
                report.ErrorDetails = "Error finding type, xonline.common.service.FrontEndApp, within assemblies";
                report.HealthStatus = HealthStatusEnum.Red;
            }

            else
            {
                // binding flags to make reflection find our properties.
                // Necessary because the  defaults  are  not  intuitive.

                BindingFlags customBindingFlags = BindingFlags.Public | BindingFlags.Static | BindingFlags.FlattenHierarchy;

                PropertyInfo pi = oType.GetProperty("fInitialized", customBindingFlags);
                myReport.fInitialized = (bool) pi.GetValue(null, null); // null, null for static with no params

                if (myReport.fInitialized)
                    report.HealthStatus = HealthStatusEnum.Green;

                // if we didn't properly initialize, see if we can find
                // out the reason why.  get last error string from init

                else
                {
                    pi = oType.GetProperty("strLastInitError", customBindingFlags);
                    report.ErrorDetails = (string)pi.GetValue(null, null); // null, null for static with no params
                    report.HealthStatus = HealthStatusEnum.Red;
                }
            }
        }
    }

    public class FrontEndAppHealthReport : IExtendedHealthReport
    {
        public bool fInitialized;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\health\dll\Block_Geofence.cs ===
using System;
using System.Collections.Specialized;
using System.IO;

using xonline.common.config;
using xonline.common.geofence;


namespace xonline.common.health
{
    internal class Geofence : IHealthBlock
    {
        public ResourceTypeEnum ResourceType { get { return ResourceTypeEnum.Local; } }

        public void DoCheck(HealthBlockManager blockManager, NameValueCollection blockParams, HealthReport report)
        {
            if (GeoFenceClient.AnyGeoFencingEnabled)
            {
                // One more test would cross the "make an array of delegates" threshold.
                TestGeoFenceCall(report);
                if (report.HealthStatus == HealthStatusEnum.Green)
                {
                    TestGeoInfoFile(report);
                }
            }
            else
            {
                report.HealthStatus = HealthStatusEnum.Green;
            }
        }

        private static void TestGeoFenceCall(HealthReport report)
        {
            try
            {
                if (!MSCOMGeoAPIWrapper.CallGetGeoInfoFromIPAddress())
                {
                    throw new Exception("CallGetGeoInfoFromIPAddress return null. Geofencing is not installed correctly.");
                }
                report.HealthStatus = HealthStatusEnum.Green;
            }
            catch (Exception e)
            {
                report.HealthStatus = HealthStatusEnum.Red;
                report.ErrorDetails = e.ToString();
            }
        }

        private static void TestGeoInfoFile(HealthReport report)
        {
            // Get the time the Geo Db file was last written.
            string geoDbPath = Config.GetSetting(Setting.geofencing_pathToGeoDb);
            DateTime geoDbPathChanged = File.GetLastWriteTime(geoDbPath);

            // If it's older than allowed, fail. Note however that we don't want to be pulled 
            // out of the vip, and in general things will work. So we return yellow, meaning
            // that we need a human's attention.
            int maxAge = Config.GetIntSetting(Setting.geofencing_maximumDaysBetweenGeoDbUpdate);
            DateTime earliestAllowedDate = DateTime.Now.AddDays(-maxAge);
            if (geoDbPathChanged < earliestAllowedDate)
            {
                report.HealthStatus = HealthStatusEnum.Yellow;
                report.ErrorDetails = String.Format("Geofencing file, located at {0} is older than {1} days.", geoDbPath, maxAge);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\health\dll\Block_FseInfo.cs ===
using System;
using System.Collections;
using System.Collections.Specialized;
using System.Data.SqlClient;

using xonline.common.sql.sqlclient;


namespace xonline.common.health
{
    /// <summary>
    /// Summary description for FseInfo
    /// </summary>
    public class FseInfoHealthBlock : IHealthBlock
    {
        private readonly ResourceTypeEnum resourceType = ResourceTypeEnum.Remote;

        public ResourceTypeEnum ResourceType
        {
            get { return resourceType; }
        }

        private void DoCheck(HealthBlockManager blockManager, string api, string database) {

            Hashtable databases = new Hashtable();
            
            using (SqlClient cmd = new SqlClient(database))
            {
                // get a list of all the methods for the specific api

                cmd.StoredProc = "p_fse_get_methods";
                cmd.AddParameter("@vc_api_name", api);

                using (SqlDataReader reader = cmd.Execute())
                {
                    while (reader.Read())
                    {
                        bool isVirtual;

                        int ord = reader.GetOrdinal("vc_method_name");
                        string methodName = reader.GetString(ord);

                        ord = reader.GetOrdinal("vc_interface");
                        string interfaceName;

                        if (! (isVirtual = reader.IsDBNull(ord)))
                            interfaceName = reader.GetString(ord);
                        else
                        {
                            ord = reader.GetOrdinal("vc_virtual_interface");

                            if (reader.IsDBNull(ord))
                            {
                                throw new Exception(string.Format("Method '{0}' for api '{1}' has no interface", methodName, api));
                            }

                            interfaceName = reader.GetString(ord);
                        }

                        databases[interfaceName] = "database";
                    }
                }
            }

            if (databases.Count == 0) {
                throw new Exception(string.Format("No methods found for api '{0}'", api));
            }

            // construct a dynamic health block parameter  string

            string blockParams = string.Empty;

            foreach (string name in databases.Keys) {
                if (blockParams.Length > 0) blockParams += ",";
                blockParams += string.Format("{0}={1}", databases[name], name);
            }

            // add the health block to the health block manager
            if (blockParams.Length > 0)
            {
                blockManager.AddBlockToRun(
                    "DatabaseInfo", "xonline.common.health.DatabaseInfoHealthBlock", blockParams, true
                );
            }
        }
    
        public void DoCheck(HealthBlockManager blockManager, NameValueCollection blockParams, HealthReport report)
        {
            try
            {
                string[] apis = blockParams.GetValues("api");
                string[] databases = blockParams.GetValues("database");

                // expect one database.  more or less is not  red
                // as much as the health mapping is misconfigured

                if (databases == null || databases.Length != 1) {
                    report.ErrorDetails = string.Format("Expected exactly one database, {0} provided", databases == null ? 0 : databases.Length);
                    report.HealthStatus = HealthStatusEnum.Yellow;
                }

                // expect one or more apis. zero doesn't mean red
                // as much as the health mapping is misconfigured

                else if (apis == null || apis.Length < 1) {
                    report.ErrorDetails = string.Format("Expected exactly one or more apis, {0} provided", apis == null ? 0 : apis.Length);
                    report.HealthStatus = HealthStatusEnum.Yellow;
                }

                else {

                    // this doesn't really do the health check.  it
                    // reads the config and  adds  database  checks

                    string s = string.Empty;

                    foreach (string api in apis) {
                        s += (s.Length == 0) ? api : ", " + api;
                        DoCheck(blockManager, api, databases[0]);
                    }

                    report.HealthStatus = HealthStatusEnum.Green;
                }
            }

            catch (Exception e) 
            {
                report.HealthStatus = HealthStatusEnum.Red;
                report.ErrorDetails = e.ToString();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\health\dll\Block_ForbiddenNamesHealthBlock.cs ===
using System;
using System.Collections.Specialized;

using xonline.common.user;

namespace xonline.common.health
{
    /// <summary>
    /// Summary description for ForbiddenNamesHealthBlock
    /// </summary>
    public class ForbiddenNamesHealthBlock : IHealthBlock
    {
        public ResourceTypeEnum ResourceType
        {
            get { return ResourceTypeEnum.Local; }
        }

        public void DoCheck(HealthBlockManager blockManager, NameValueCollection blockParams, HealthReport report)
        {
            ForbiddenNamesReport myReport = new ForbiddenNamesReport();
            report.ExtendedReport = myReport;

            // force the ForbiddenNameList class to initialize if it has not already
            try
            {
                string[] vetnames = blockParams.GetValues("vetNames");
                report.HealthStatus = HealthStatusEnum.Green;

                foreach (string name in vetnames)
                {
                    string exact = string.Empty;
                    string substr = string.Empty;

                    if (ForbiddenNameList.VetName(name, ref exact, ref substr))
                    {
                        report.HealthStatus = HealthStatusEnum.Yellow;
                        report.ErrorDetails = "ForbiddenNameList.VetName failed to reject '" + name + "' as a forbidden name.";
                    }
                }

                // report the size of the CurseMgr table
                if (ForbiddenNameList.CurseMgr != null)
                {
                    myReport.CurseMgrTableSize = ForbiddenNameList.CurseMgr.TableSize;
                }

                if (ForbiddenNameList.ExactMatchTable != null)
                {
                    myReport.ExactMatchCount = ForbiddenNameList.ExactMatchTable.Count;
                }
            }
            catch (Exception e)
            {
                report.HealthStatus = HealthStatusEnum.Red;
                report.ErrorDetails = e.Message;
                return;
            }
        }
    }

    public class ForbiddenNamesReport : IExtendedHealthReport
    {
        public ulong CurseMgrTableSize;
        public int ExactMatchCount;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\wmi\iisv2\IIsWebVirtualDirSetting.CS ===
﻿namespace xonline.common.wmi.iisv2 {
    using System;
    using System.ComponentModel;
    using System.Management;
    using System.Collections;
    using System.Globalization;
    using System.ComponentModel.Design.Serialization;
    using System.Reflection;
    
    
    // Functions ShouldSerialize<PropertyName> are functions used by VS property browser to check if a particular property has to be serialized. These functions are added for all ValueType properties ( properties of type Int32, BOOL etc.. which cannot be set to null). These functions use Is<PropertyName>Null function. These functions are also used in the TypeConverter implementation for the properties to check for NULL value of property so that an empty value can be shown in Property browser in case of Drag and Drop in Visual studio.
    // Functions Is<PropertyName>Null() are used to check if a property is NULL.
    // Functions Reset<PropertyName> are added for Nullable Read/Write properties. These functions are used by VS designer in property browser to set a property to NULL.
    // Every property added to the class for WMI property has attributes set to define its behavior in Visual Studio designer and also to define a TypeConverter to be used.
    // 
    // 
    // 
    // 
    // If the embedded property is strongly typed then, to strongly type the property to the type of
    // the embedded object, you have to do the following things.
    // 	1. Generate Managed class for the WMI class of the embedded property. This can be done with MgmtClassGen.exe tool or from Server Explorer.
    // 	2. Include the namespace of the generated class.
    // 	3. Change the property get/set functions so as return the instance of the Managed class.
    // Below is a sample code.
    // 
    // VB Code
    // Public Property <PropertyName>() As <ManagedClassName of Embedded property>
    // 	Get
    // 		Return New <ManagedClassName of Embedded Property>(CType(curObj("<PropertyName>"),System.Management.ManagementBaseObject))
    // 	End Get
    // 	Set(ByVal Value As <ManagedClassName of Embedded property>)
    // 		curObj("EObject") = Value.LateBoundObject
    // 		If (AutoCommitProp = True And isEmbedded = False) Then
    // 			PrivateLateBoundObject.Put()
    // 		End If
    // 	End Set
    // 
    // C# Code
    // public <ManagedClassName of Embedded property> <PropertyName>
    // {
    // 	get
    // 	{
    // 		return new <ManagedClassName of Embedded property>((System.Management.ManagementBaseObject)(curObj["<PropertyName>"]));
    // 	}
    // 	set
    // 	{
    // 		curObj["<PropertyName>"] = value.LateBoundObject;
    // 		If (AutoCommitProp == true && isEmbedded == false)
    // 		{
    // 			PrivateLateBoundObject.Put();
    // 		}
    // 	}
    // }
    // An Early Bound class generated for the WMI class.IIsWebVirtualDirSetting
    public class IIsWebVirtualDirSetting : System.ComponentModel.Component {
        
        // Private property to hold the WMI namespace in which the class resides.
        private static string CreatedWmiNamespace = "ROOT\\MicrosoftIISv2";
        
        // Private property to hold the name of WMI class which created this class.
        private static string CreatedClassName = "IIsWebVirtualDirSetting";
        
        // Private member variable to hold the ManagementScope which is used by the various methods.
        private static System.Management.ManagementScope statMgmtScope = null;
        
        private ManagementSystemProperties PrivateSystemProperties;
        
        // Underlying lateBound WMI object.
        private System.Management.ManagementObject PrivateLateBoundObject;
        
        // Member variable to store the 'automatic commit' behavior for the class.
        private bool AutoCommitProp = true;
        
        // Private variable to hold the embedded property representing the instance.
        private System.Management.ManagementBaseObject embeddedObj;
        
        // The current WMI object used
        private System.Management.ManagementBaseObject curObj;
        
        // Flag to indicate if the instance is an embedded object.
        private bool isEmbedded = false;
        
        // Below are different overloads of constructors to initialize an instance of the class with a WMI object.
        public IIsWebVirtualDirSetting() : 
                this(((System.Management.ManagementScope)(null)), ((System.Management.ManagementPath)(null)), ((System.Management.ObjectGetOptions)(null))) {
        }
        
        public IIsWebVirtualDirSetting(string keyName) : 
                this(((System.Management.ManagementScope)(null)), ((System.Management.ManagementPath)(new System.Management.ManagementPath(IIsWebVirtualDirSetting.ConstructPath(keyName)))), ((System.Management.ObjectGetOptions)(null))) {
        }
        
        public IIsWebVirtualDirSetting(System.Management.ManagementScope mgmtScope, string keyName) : 
                this(((System.Management.ManagementScope)(mgmtScope)), ((System.Management.ManagementPath)(new System.Management.ManagementPath(IIsWebVirtualDirSetting.ConstructPath(keyName)))), ((System.Management.ObjectGetOptions)(null))) {
        }
        
        public IIsWebVirtualDirSetting(System.Management.ManagementPath path, System.Management.ObjectGetOptions getOptions) : 
                this(((System.Management.ManagementScope)(null)), ((System.Management.ManagementPath)(path)), ((System.Management.ObjectGetOptions)(getOptions))) {
        }
        
        public IIsWebVirtualDirSetting(System.Management.ManagementScope mgmtScope, System.Management.ManagementPath path) : 
                this(((System.Management.ManagementScope)(mgmtScope)), ((System.Management.ManagementPath)(path)), ((System.Management.ObjectGetOptions)(null))) {
        }
        
        public IIsWebVirtualDirSetting(System.Management.ManagementPath path) : 
                this(((System.Management.ManagementScope)(null)), ((System.Management.ManagementPath)(path)), ((System.Management.ObjectGetOptions)(null))) {
        }
        
        public IIsWebVirtualDirSetting(System.Management.ManagementScope mgmtScope, System.Management.ManagementPath path, System.Management.ObjectGetOptions getOptions) {
            if ((path != null)) {
                if ((CheckIfProperClass(mgmtScope, path, getOptions) != true)) {
                    throw new System.ArgumentException("Class name does not match.");
                }
            }
            PrivateLateBoundObject = new System.Management.ManagementObject(mgmtScope, path, getOptions);
            PrivateSystemProperties = new ManagementSystemProperties(PrivateLateBoundObject);
            curObj = PrivateLateBoundObject;
        }
        
        public IIsWebVirtualDirSetting(System.Management.ManagementObject theObject) {
            if ((CheckIfProperClass(theObject) == true)) {
                PrivateLateBoundObject = theObject;
                PrivateSystemProperties = new ManagementSystemProperties(PrivateLateBoundObject);
                curObj = PrivateLateBoundObject;
            }
            else {
                throw new System.ArgumentException("Class name does not match.");
            }
        }
        
        public IIsWebVirtualDirSetting(System.Management.ManagementBaseObject theObject) {
            if ((CheckIfProperClass(theObject) == true)) {
                embeddedObj = theObject;
                PrivateSystemProperties = new ManagementSystemProperties(theObject);
                curObj = embeddedObj;
                isEmbedded = true;
            }
            else {
                throw new System.ArgumentException("Class name does not match.");
            }
        }
        
        // Property returns the namespace of the WMI class.
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string OriginatingNamespace {
            get {
                return "ROOT\\MicrosoftIISv2";
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string ManagementClassName {
            get {
                string strRet = CreatedClassName;
                if ((curObj != null)) {
                    if ((curObj.ClassPath != null)) {
                        strRet = ((string)(curObj["__CLASS"]));
                        if (((strRet == null) 
                                    || (strRet == System.String.Empty))) {
                            strRet = CreatedClassName;
                        }
                    }
                }
                return strRet;
            }
        }
        
        // Property pointing to an embedded object to get System properties of the WMI object.
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public ManagementSystemProperties SystemProperties {
            get {
                return PrivateSystemProperties;
            }
        }
        
        // Property returning the underlying lateBound object.
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public System.Management.ManagementBaseObject LateBoundObject {
            get {
                return curObj;
            }
        }
        
        // ManagementScope of the object.
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public System.Management.ManagementScope Scope {
            get {
                if ((isEmbedded == false)) {
                    return PrivateLateBoundObject.Scope;
                }
                else {
                    return null;
                }
            }
            set {
                if ((isEmbedded == false)) {
                    PrivateLateBoundObject.Scope = value;
                }
            }
        }
        
        // Property to show the commit behavior for the WMI object. If true, WMI object will be automatically saved after each property modification.(ie. Put() is called after modification of a property).
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool AutoCommit {
            get {
                return AutoCommitProp;
            }
            set {
                AutoCommitProp = value;
            }
        }
        
        // The ManagementPath of the underlying WMI object.
        [Browsable(true)]
        public System.Management.ManagementPath Path {
            get {
                if ((isEmbedded == false)) {
                    return PrivateLateBoundObject.Path;
                }
                else {
                    return null;
                }
            }
            set {
                if ((isEmbedded == false)) {
                    if ((CheckIfProperClass(null, value, null) != true)) {
                        throw new System.ArgumentException("Class name does not match.");
                    }
                    PrivateLateBoundObject.Path = value;
                }
            }
        }
        
        // Public static scope property which is used by the various methods.
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public static System.Management.ManagementScope StaticScope {
            get {
                return statMgmtScope;
            }
            set {
                statMgmtScope = value;
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAccessExecuteNull {
            get {
                if ((curObj["AccessExecute"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AccessExecute {
            get {
                if ((curObj["AccessExecute"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AccessExecute"]));
            }
            set {
                curObj["AccessExecute"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAccessFlagsNull {
            get {
                if ((curObj["AccessFlags"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AccessFlags {
            get {
                if ((curObj["AccessFlags"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AccessFlags"]));
            }
            set {
                curObj["AccessFlags"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAccessNoPhysicalDirNull {
            get {
                if ((curObj["AccessNoPhysicalDir"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AccessNoPhysicalDir {
            get {
                if ((curObj["AccessNoPhysicalDir"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AccessNoPhysicalDir"]));
            }
            set {
                curObj["AccessNoPhysicalDir"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAccessNoRemoteExecuteNull {
            get {
                if ((curObj["AccessNoRemoteExecute"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AccessNoRemoteExecute {
            get {
                if ((curObj["AccessNoRemoteExecute"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AccessNoRemoteExecute"]));
            }
            set {
                curObj["AccessNoRemoteExecute"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAccessNoRemoteReadNull {
            get {
                if ((curObj["AccessNoRemoteRead"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AccessNoRemoteRead {
            get {
                if ((curObj["AccessNoRemoteRead"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AccessNoRemoteRead"]));
            }
            set {
                curObj["AccessNoRemoteRead"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAccessNoRemoteScriptNull {
            get {
                if ((curObj["AccessNoRemoteScript"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AccessNoRemoteScript {
            get {
                if ((curObj["AccessNoRemoteScript"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AccessNoRemoteScript"]));
            }
            set {
                curObj["AccessNoRemoteScript"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAccessNoRemoteWriteNull {
            get {
                if ((curObj["AccessNoRemoteWrite"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AccessNoRemoteWrite {
            get {
                if ((curObj["AccessNoRemoteWrite"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AccessNoRemoteWrite"]));
            }
            set {
                curObj["AccessNoRemoteWrite"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAccessReadNull {
            get {
                if ((curObj["AccessRead"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AccessRead {
            get {
                if ((curObj["AccessRead"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AccessRead"]));
            }
            set {
                curObj["AccessRead"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAccessScriptNull {
            get {
                if ((curObj["AccessScript"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AccessScript {
            get {
                if ((curObj["AccessScript"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AccessScript"]));
            }
            set {
                curObj["AccessScript"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAccessSourceNull {
            get {
                if ((curObj["AccessSource"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AccessSource {
            get {
                if ((curObj["AccessSource"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AccessSource"]));
            }
            set {
                curObj["AccessSource"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAccessSSLNull {
            get {
                if ((curObj["AccessSSL"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AccessSSL {
            get {
                if ((curObj["AccessSSL"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AccessSSL"]));
            }
            set {
                curObj["AccessSSL"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAccessSSL128Null {
            get {
                if ((curObj["AccessSSL128"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AccessSSL128 {
            get {
                if ((curObj["AccessSSL128"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AccessSSL128"]));
            }
            set {
                curObj["AccessSSL128"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAccessSSLFlagsNull {
            get {
                if ((curObj["AccessSSLFlags"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AccessSSLFlags {
            get {
                if ((curObj["AccessSSLFlags"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AccessSSLFlags"]));
            }
            set {
                curObj["AccessSSLFlags"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAccessSSLMapCertNull {
            get {
                if ((curObj["AccessSSLMapCert"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AccessSSLMapCert {
            get {
                if ((curObj["AccessSSLMapCert"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AccessSSLMapCert"]));
            }
            set {
                curObj["AccessSSLMapCert"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAccessSSLNegotiateCertNull {
            get {
                if ((curObj["AccessSSLNegotiateCert"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AccessSSLNegotiateCert {
            get {
                if ((curObj["AccessSSLNegotiateCert"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AccessSSLNegotiateCert"]));
            }
            set {
                curObj["AccessSSLNegotiateCert"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAccessSSLRequireCertNull {
            get {
                if ((curObj["AccessSSLRequireCert"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AccessSSLRequireCert {
            get {
                if ((curObj["AccessSSLRequireCert"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AccessSSLRequireCert"]));
            }
            set {
                curObj["AccessSSLRequireCert"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAccessWriteNull {
            get {
                if ((curObj["AccessWrite"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AccessWrite {
            get {
                if ((curObj["AccessWrite"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AccessWrite"]));
            }
            set {
                curObj["AccessWrite"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public System.Byte[] AdminACLBin {
            get {
                return ((System.Byte[])(curObj["AdminACLBin"]));
            }
            set {
                curObj["AdminACLBin"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAnonymousPasswordSyncNull {
            get {
                if ((curObj["AnonymousPasswordSync"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AnonymousPasswordSync {
            get {
                if ((curObj["AnonymousPasswordSync"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AnonymousPasswordSync"]));
            }
            set {
                curObj["AnonymousPasswordSync"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string AnonymousUserName {
            get {
                return ((string)(curObj["AnonymousUserName"]));
            }
            set {
                curObj["AnonymousUserName"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string AnonymousUserPass {
            get {
                return ((string)(curObj["AnonymousUserPass"]));
            }
            set {
                curObj["AnonymousUserPass"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAppAllowClientDebugNull {
            get {
                if ((curObj["AppAllowClientDebug"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AppAllowClientDebug {
            get {
                if ((curObj["AppAllowClientDebug"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AppAllowClientDebug"]));
            }
            set {
                curObj["AppAllowClientDebug"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAppAllowDebuggingNull {
            get {
                if ((curObj["AppAllowDebugging"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AppAllowDebugging {
            get {
                if ((curObj["AppAllowDebugging"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AppAllowDebugging"]));
            }
            set {
                curObj["AppAllowDebugging"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string AppFriendlyName {
            get {
                return ((string)(curObj["AppFriendlyName"]));
            }
            set {
                curObj["AppFriendlyName"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAppOopRecoverLimitNull {
            get {
                if ((curObj["AppOopRecoverLimit"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AppOopRecoverLimit {
            get {
                if ((curObj["AppOopRecoverLimit"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AppOopRecoverLimit"]));
            }
            set {
                curObj["AppOopRecoverLimit"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string AppPoolId {
            get {
                return ((string)(curObj["AppPoolId"]));
            }
            set {
                curObj["AppPoolId"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string AppWamClsid {
            get {
                return ((string)(curObj["AppWamClsid"]));
            }
            set {
                curObj["AppWamClsid"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspAllowOutOfProcComponentsNull {
            get {
                if ((curObj["AspAllowOutOfProcComponents"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AspAllowOutOfProcComponents {
            get {
                if ((curObj["AspAllowOutOfProcComponents"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AspAllowOutOfProcComponents"]));
            }
            set {
                curObj["AspAllowOutOfProcComponents"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspAllowSessionStateNull {
            get {
                if ((curObj["AspAllowSessionState"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AspAllowSessionState {
            get {
                if ((curObj["AspAllowSessionState"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AspAllowSessionState"]));
            }
            set {
                curObj["AspAllowSessionState"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspAppServiceFlagsNull {
            get {
                if ((curObj["AspAppServiceFlags"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AspAppServiceFlags {
            get {
                if ((curObj["AspAppServiceFlags"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AspAppServiceFlags"]));
            }
            set {
                curObj["AspAppServiceFlags"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspBufferingLimitNull {
            get {
                if ((curObj["AspBufferingLimit"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AspBufferingLimit {
            get {
                if ((curObj["AspBufferingLimit"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AspBufferingLimit"]));
            }
            set {
                curObj["AspBufferingLimit"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspBufferingOnNull {
            get {
                if ((curObj["AspBufferingOn"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AspBufferingOn {
            get {
                if ((curObj["AspBufferingOn"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AspBufferingOn"]));
            }
            set {
                curObj["AspBufferingOn"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspCalcLineNumberNull {
            get {
                if ((curObj["AspCalcLineNumber"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AspCalcLineNumber {
            get {
                if ((curObj["AspCalcLineNumber"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AspCalcLineNumber"]));
            }
            set {
                curObj["AspCalcLineNumber"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspCodepageNull {
            get {
                if ((curObj["AspCodepage"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AspCodepage {
            get {
                if ((curObj["AspCodepage"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AspCodepage"]));
            }
            set {
                curObj["AspCodepage"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string AspDiskTemplateCacheDirectory {
            get {
                return ((string)(curObj["AspDiskTemplateCacheDirectory"]));
            }
            set {
                curObj["AspDiskTemplateCacheDirectory"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspEnableApplicationRestartNull {
            get {
                if ((curObj["AspEnableApplicationRestart"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AspEnableApplicationRestart {
            get {
                if ((curObj["AspEnableApplicationRestart"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AspEnableApplicationRestart"]));
            }
            set {
                curObj["AspEnableApplicationRestart"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspEnableAspHtmlFallbackNull {
            get {
                if ((curObj["AspEnableAspHtmlFallback"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AspEnableAspHtmlFallback {
            get {
                if ((curObj["AspEnableAspHtmlFallback"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AspEnableAspHtmlFallback"]));
            }
            set {
                curObj["AspEnableAspHtmlFallback"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspEnableChunkedEncodingNull {
            get {
                if ((curObj["AspEnableChunkedEncoding"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AspEnableChunkedEncoding {
            get {
                if ((curObj["AspEnableChunkedEncoding"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AspEnableChunkedEncoding"]));
            }
            set {
                curObj["AspEnableChunkedEncoding"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspEnableParentPathsNull {
            get {
                if ((curObj["AspEnableParentPaths"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AspEnableParentPaths {
            get {
                if ((curObj["AspEnableParentPaths"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AspEnableParentPaths"]));
            }
            set {
                curObj["AspEnableParentPaths"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspEnableSxsNull {
            get {
                if ((curObj["AspEnableSxs"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AspEnableSxs {
            get {
                if ((curObj["AspEnableSxs"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AspEnableSxs"]));
            }
            set {
                curObj["AspEnableSxs"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspEnableTrackerNull {
            get {
                if ((curObj["AspEnableTracker"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AspEnableTracker {
            get {
                if ((curObj["AspEnableTracker"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AspEnableTracker"]));
            }
            set {
                curObj["AspEnableTracker"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspEnableTypelibCacheNull {
            get {
                if ((curObj["AspEnableTypelibCache"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AspEnableTypelibCache {
            get {
                if ((curObj["AspEnableTypelibCache"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AspEnableTypelibCache"]));
            }
            set {
                curObj["AspEnableTypelibCache"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspErrorsToNTLogNull {
            get {
                if ((curObj["AspErrorsToNTLog"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AspErrorsToNTLog {
            get {
                if ((curObj["AspErrorsToNTLog"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AspErrorsToNTLog"]));
            }
            set {
                curObj["AspErrorsToNTLog"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspExceptionCatchEnableNull {
            get {
                if ((curObj["AspExceptionCatchEnable"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AspExceptionCatchEnable {
            get {
                if ((curObj["AspExceptionCatchEnable"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AspExceptionCatchEnable"]));
            }
            set {
                curObj["AspExceptionCatchEnable"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspExecuteInMTANull {
            get {
                if ((curObj["AspExecuteInMTA"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AspExecuteInMTA {
            get {
                if ((curObj["AspExecuteInMTA"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AspExecuteInMTA"]));
            }
            set {
                curObj["AspExecuteInMTA"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspKeepSessionIDSecureNull {
            get {
                if ((curObj["AspKeepSessionIDSecure"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AspKeepSessionIDSecure {
            get {
                if ((curObj["AspKeepSessionIDSecure"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AspKeepSessionIDSecure"]));
            }
            set {
                curObj["AspKeepSessionIDSecure"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspLCIDNull {
            get {
                if ((curObj["AspLCID"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AspLCID {
            get {
                if ((curObj["AspLCID"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AspLCID"]));
            }
            set {
                curObj["AspLCID"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspLogErrorRequestsNull {
            get {
                if ((curObj["AspLogErrorRequests"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AspLogErrorRequests {
            get {
                if ((curObj["AspLogErrorRequests"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AspLogErrorRequests"]));
            }
            set {
                curObj["AspLogErrorRequests"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspMaxDiskTemplateCacheFilesNull {
            get {
                if ((curObj["AspMaxDiskTemplateCacheFiles"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AspMaxDiskTemplateCacheFiles {
            get {
                if ((curObj["AspMaxDiskTemplateCacheFiles"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AspMaxDiskTemplateCacheFiles"]));
            }
            set {
                curObj["AspMaxDiskTemplateCacheFiles"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspMaxRequestEntityAllowedNull {
            get {
                if ((curObj["AspMaxRequestEntityAllowed"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AspMaxRequestEntityAllowed {
            get {
                if ((curObj["AspMaxRequestEntityAllowed"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AspMaxRequestEntityAllowed"]));
            }
            set {
                curObj["AspMaxRequestEntityAllowed"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string AspPartitionID {
            get {
                return ((string)(curObj["AspPartitionID"]));
            }
            set {
                curObj["AspPartitionID"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspProcessorThreadMaxNull {
            get {
                if ((curObj["AspProcessorThreadMax"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AspProcessorThreadMax {
            get {
                if ((curObj["AspProcessorThreadMax"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AspProcessorThreadMax"]));
            }
            set {
                curObj["AspProcessorThreadMax"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspQueueConnectionTestTimeNull {
            get {
                if ((curObj["AspQueueConnectionTestTime"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AspQueueConnectionTestTime {
            get {
                if ((curObj["AspQueueConnectionTestTime"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AspQueueConnectionTestTime"]));
            }
            set {
                curObj["AspQueueConnectionTestTime"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspQueueTimeoutNull {
            get {
                if ((curObj["AspQueueTimeout"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AspQueueTimeout {
            get {
                if ((curObj["AspQueueTimeout"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AspQueueTimeout"]));
            }
            set {
                curObj["AspQueueTimeout"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspRequestQueueMaxNull {
            get {
                if ((curObj["AspRequestQueueMax"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AspRequestQueueMax {
            get {
                if ((curObj["AspRequestQueueMax"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AspRequestQueueMax"]));
            }
            set {
                curObj["AspRequestQueueMax"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspRunOnEndAnonymouslyNull {
            get {
                if ((curObj["AspRunOnEndAnonymously"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AspRunOnEndAnonymously {
            get {
                if ((curObj["AspRunOnEndAnonymously"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AspRunOnEndAnonymously"]));
            }
            set {
                curObj["AspRunOnEndAnonymously"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspScriptEngineCacheMaxNull {
            get {
                if ((curObj["AspScriptEngineCacheMax"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AspScriptEngineCacheMax {
            get {
                if ((curObj["AspScriptEngineCacheMax"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AspScriptEngineCacheMax"]));
            }
            set {
                curObj["AspScriptEngineCacheMax"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string AspScriptErrorMessage {
            get {
                return ((string)(curObj["AspScriptErrorMessage"]));
            }
            set {
                curObj["AspScriptErrorMessage"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspScriptErrorSentToBrowserNull {
            get {
                if ((curObj["AspScriptErrorSentToBrowser"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AspScriptErrorSentToBrowser {
            get {
                if ((curObj["AspScriptErrorSentToBrowser"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AspScriptErrorSentToBrowser"]));
            }
            set {
                curObj["AspScriptErrorSentToBrowser"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspScriptFileCacheSizeNull {
            get {
                if ((curObj["AspScriptFileCacheSize"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AspScriptFileCacheSize {
            get {
                if ((curObj["AspScriptFileCacheSize"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AspScriptFileCacheSize"]));
            }
            set {
                curObj["AspScriptFileCacheSize"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string AspScriptLanguage {
            get {
                return ((string)(curObj["AspScriptLanguage"]));
            }
            set {
                curObj["AspScriptLanguage"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspScriptTimeoutNull {
            get {
                if ((curObj["AspScriptTimeout"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AspScriptTimeout {
            get {
                if ((curObj["AspScriptTimeout"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AspScriptTimeout"]));
            }
            set {
                curObj["AspScriptTimeout"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspSessionMaxNull {
            get {
                if ((curObj["AspSessionMax"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AspSessionMax {
            get {
                if ((curObj["AspSessionMax"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AspSessionMax"]));
            }
            set {
                curObj["AspSessionMax"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspSessionTimeoutNull {
            get {
                if ((curObj["AspSessionTimeout"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AspSessionTimeout {
            get {
                if ((curObj["AspSessionTimeout"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AspSessionTimeout"]));
            }
            set {
                curObj["AspSessionTimeout"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string AspSxsName {
            get {
                return ((string)(curObj["AspSxsName"]));
            }
            set {
                curObj["AspSxsName"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspTrackThreadingModelNull {
            get {
                if ((curObj["AspTrackThreadingModel"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AspTrackThreadingModel {
            get {
                if ((curObj["AspTrackThreadingModel"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AspTrackThreadingModel"]));
            }
            set {
                curObj["AspTrackThreadingModel"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspUsePartitionNull {
            get {
                if ((curObj["AspUsePartition"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AspUsePartition {
            get {
                if ((curObj["AspUsePartition"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AspUsePartition"]));
            }
            set {
                curObj["AspUsePartition"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAuthAnonymousNull {
            get {
                if ((curObj["AuthAnonymous"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AuthAnonymous {
            get {
                if ((curObj["AuthAnonymous"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AuthAnonymous"]));
            }
            set {
                curObj["AuthAnonymous"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAuthBasicNull {
            get {
                if ((curObj["AuthBasic"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AuthBasic {
            get {
                if ((curObj["AuthBasic"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AuthBasic"]));
            }
            set {
                curObj["AuthBasic"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAuthFlagsNull {
            get {
                if ((curObj["AuthFlags"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AuthFlags {
            get {
                if ((curObj["AuthFlags"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AuthFlags"]));
            }
            set {
                curObj["AuthFlags"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAuthMD5Null {
            get {
                if ((curObj["AuthMD5"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AuthMD5 {
            get {
                if ((curObj["AuthMD5"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AuthMD5"]));
            }
            set {
                curObj["AuthMD5"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAuthNTLMNull {
            get {
                if ((curObj["AuthNTLM"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AuthNTLM {
            get {
                if ((curObj["AuthNTLM"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AuthNTLM"]));
            }
            set {
                curObj["AuthNTLM"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAuthPassportNull {
            get {
                if ((curObj["AuthPassport"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AuthPassport {
            get {
                if ((curObj["AuthPassport"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AuthPassport"]));
            }
            set {
                curObj["AuthPassport"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAuthPersistenceNull {
            get {
                if ((curObj["AuthPersistence"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AuthPersistence {
            get {
                if ((curObj["AuthPersistence"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AuthPersistence"]));
            }
            set {
                curObj["AuthPersistence"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAuthPersistSingleRequestNull {
            get {
                if ((curObj["AuthPersistSingleRequest"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AuthPersistSingleRequest {
            get {
                if ((curObj["AuthPersistSingleRequest"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AuthPersistSingleRequest"]));
            }
            set {
                curObj["AuthPersistSingleRequest"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAzEnableNull {
            get {
                if ((curObj["AzEnable"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AzEnable {
            get {
                if ((curObj["AzEnable"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AzEnable"]));
            }
            set {
                curObj["AzEnable"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAzImpersonationLevelNull {
            get {
                if ((curObj["AzImpersonationLevel"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AzImpersonationLevel {
            get {
                if ((curObj["AzImpersonationLevel"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AzImpersonationLevel"]));
            }
            set {
                curObj["AzImpersonationLevel"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string AzScopeName {
            get {
                return ((string)(curObj["AzScopeName"]));
            }
            set {
                curObj["AzScopeName"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string AzStoreName {
            get {
                return ((string)(curObj["AzStoreName"]));
            }
            set {
                curObj["AzStoreName"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string CacheControlCustom {
            get {
                return ((string)(curObj["CacheControlCustom"]));
            }
            set {
                curObj["CacheControlCustom"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsCacheControlMaxAgeNull {
            get {
                if ((curObj["CacheControlMaxAge"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int CacheControlMaxAge {
            get {
                if ((curObj["CacheControlMaxAge"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["CacheControlMaxAge"]));
            }
            set {
                curObj["CacheControlMaxAge"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsCacheControlNoCacheNull {
            get {
                if ((curObj["CacheControlNoCache"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool CacheControlNoCache {
            get {
                if ((curObj["CacheControlNoCache"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["CacheControlNoCache"]));
            }
            set {
                curObj["CacheControlNoCache"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsCacheISAPINull {
            get {
                if ((curObj["CacheISAPI"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool CacheISAPI {
            get {
                if ((curObj["CacheISAPI"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["CacheISAPI"]));
            }
            set {
                curObj["CacheISAPI"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string Caption {
            get {
                return ((string)(curObj["Caption"]));
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsCGITimeoutNull {
            get {
                if ((curObj["CGITimeout"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int CGITimeout {
            get {
                if ((curObj["CGITimeout"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["CGITimeout"]));
            }
            set {
                curObj["CGITimeout"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsContentIndexedNull {
            get {
                if ((curObj["ContentIndexed"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool ContentIndexed {
            get {
                if ((curObj["ContentIndexed"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["ContentIndexed"]));
            }
            set {
                curObj["ContentIndexed"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsCreateCGIWithNewConsoleNull {
            get {
                if ((curObj["CreateCGIWithNewConsole"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool CreateCGIWithNewConsole {
            get {
                if ((curObj["CreateCGIWithNewConsole"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["CreateCGIWithNewConsole"]));
            }
            set {
                curObj["CreateCGIWithNewConsole"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsCreateProcessAsUserNull {
            get {
                if ((curObj["CreateProcessAsUser"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool CreateProcessAsUser {
            get {
                if ((curObj["CreateProcessAsUser"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["CreateProcessAsUser"]));
            }
            set {
                curObj["CreateProcessAsUser"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string DefaultDoc {
            get {
                return ((string)(curObj["DefaultDoc"]));
            }
            set {
                curObj["DefaultDoc"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string DefaultDocFooter {
            get {
                return ((string)(curObj["DefaultDocFooter"]));
            }
            set {
                curObj["DefaultDocFooter"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string DefaultLogonDomain {
            get {
                return ((string)(curObj["DefaultLogonDomain"]));
            }
            set {
                curObj["DefaultLogonDomain"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string Description {
            get {
                return ((string)(curObj["Description"]));
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsDirBrowseFlagsNull {
            get {
                if ((curObj["DirBrowseFlags"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int DirBrowseFlags {
            get {
                if ((curObj["DirBrowseFlags"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["DirBrowseFlags"]));
            }
            set {
                curObj["DirBrowseFlags"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsDirBrowseShowDateNull {
            get {
                if ((curObj["DirBrowseShowDate"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool DirBrowseShowDate {
            get {
                if ((curObj["DirBrowseShowDate"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["DirBrowseShowDate"]));
            }
            set {
                curObj["DirBrowseShowDate"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsDirBrowseShowExtensionNull {
            get {
                if ((curObj["DirBrowseShowExtension"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool DirBrowseShowExtension {
            get {
                if ((curObj["DirBrowseShowExtension"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["DirBrowseShowExtension"]));
            }
            set {
                curObj["DirBrowseShowExtension"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsDirBrowseShowLongDateNull {
            get {
                if ((curObj["DirBrowseShowLongDate"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool DirBrowseShowLongDate {
            get {
                if ((curObj["DirBrowseShowLongDate"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["DirBrowseShowLongDate"]));
            }
            set {
                curObj["DirBrowseShowLongDate"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsDirBrowseShowSizeNull {
            get {
                if ((curObj["DirBrowseShowSize"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool DirBrowseShowSize {
            get {
                if ((curObj["DirBrowseShowSize"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["DirBrowseShowSize"]));
            }
            set {
                curObj["DirBrowseShowSize"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsDirBrowseShowTimeNull {
            get {
                if ((curObj["DirBrowseShowTime"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool DirBrowseShowTime {
            get {
                if ((curObj["DirBrowseShowTime"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["DirBrowseShowTime"]));
            }
            set {
                curObj["DirBrowseShowTime"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsDisableStaticFileCacheNull {
            get {
                if ((curObj["DisableStaticFileCache"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool DisableStaticFileCache {
            get {
                if ((curObj["DisableStaticFileCache"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["DisableStaticFileCache"]));
            }
            set {
                curObj["DisableStaticFileCache"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsDoDynamicCompressionNull {
            get {
                if ((curObj["DoDynamicCompression"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool DoDynamicCompression {
            get {
                if ((curObj["DoDynamicCompression"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["DoDynamicCompression"]));
            }
            set {
                curObj["DoDynamicCompression"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsDontLogNull {
            get {
                if ((curObj["DontLog"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool DontLog {
            get {
                if ((curObj["DontLog"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["DontLog"]));
            }
            set {
                curObj["DontLog"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsDoStaticCompressionNull {
            get {
                if ((curObj["DoStaticCompression"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool DoStaticCompression {
            get {
                if ((curObj["DoStaticCompression"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["DoStaticCompression"]));
            }
            set {
                curObj["DoStaticCompression"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsEnableDefaultDocNull {
            get {
                if ((curObj["EnableDefaultDoc"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool EnableDefaultDoc {
            get {
                if ((curObj["EnableDefaultDoc"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["EnableDefaultDoc"]));
            }
            set {
                curObj["EnableDefaultDoc"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsEnableDirBrowsingNull {
            get {
                if ((curObj["EnableDirBrowsing"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool EnableDirBrowsing {
            get {
                if ((curObj["EnableDirBrowsing"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["EnableDirBrowsing"]));
            }
            set {
                curObj["EnableDirBrowsing"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsEnableDocFooterNull {
            get {
                if ((curObj["EnableDocFooter"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool EnableDocFooter {
            get {
                if ((curObj["EnableDocFooter"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["EnableDocFooter"]));
            }
            set {
                curObj["EnableDocFooter"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsEnableReverseDnsNull {
            get {
                if ((curObj["EnableReverseDns"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool EnableReverseDns {
            get {
                if ((curObj["EnableReverseDns"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["EnableReverseDns"]));
            }
            set {
                curObj["EnableReverseDns"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsFrontPageWebNull {
            get {
                if ((curObj["FrontPageWeb"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool FrontPageWeb {
            get {
                if ((curObj["FrontPageWeb"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["FrontPageWeb"]));
            }
            set {
                curObj["FrontPageWeb"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public System.Management.ManagementBaseObject[] HttpCustomHeaders {
            get {
                return ((System.Management.ManagementBaseObject[])(curObj["HttpCustomHeaders"]));
            }
            set {
                curObj["HttpCustomHeaders"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public System.Management.ManagementBaseObject[] HttpErrors {
            get {
                return ((System.Management.ManagementBaseObject[])(curObj["HttpErrors"]));
            }
            set {
                curObj["HttpErrors"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string HttpExpires {
            get {
                return ((string)(curObj["HttpExpires"]));
            }
            set {
                curObj["HttpExpires"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string[] HttpPics {
            get {
                return ((string[])(curObj["HttpPics"]));
            }
            set {
                curObj["HttpPics"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string HttpRedirect {
            get {
                return ((string)(curObj["HttpRedirect"]));
            }
            set {
                curObj["HttpRedirect"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogonMethodNull {
            get {
                if ((curObj["LogonMethod"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int LogonMethod {
            get {
                if ((curObj["LogonMethod"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["LogonMethod"]));
            }
            set {
                curObj["LogonMethod"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsMaxRequestEntityAllowedNull {
            get {
                if ((curObj["MaxRequestEntityAllowed"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int MaxRequestEntityAllowed {
            get {
                if ((curObj["MaxRequestEntityAllowed"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["MaxRequestEntityAllowed"]));
            }
            set {
                curObj["MaxRequestEntityAllowed"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public System.Management.ManagementBaseObject[] MimeMap {
            get {
                return ((System.Management.ManagementBaseObject[])(curObj["MimeMap"]));
            }
            set {
                curObj["MimeMap"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string Name {
            get {
                return ((string)(curObj["Name"]));
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string NTAuthenticationProviders {
            get {
                return ((string)(curObj["NTAuthenticationProviders"]));
            }
            set {
                curObj["NTAuthenticationProviders"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsPassportRequireADMappingNull {
            get {
                if ((curObj["PassportRequireADMapping"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int PassportRequireADMapping {
            get {
                if ((curObj["PassportRequireADMapping"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["PassportRequireADMapping"]));
            }
            set {
                curObj["PassportRequireADMapping"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string Path0 {
            get {
                return ((string)(curObj["Path"]));
            }
            set {
                curObj["Path"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsPoolIdcTimeoutNull {
            get {
                if ((curObj["PoolIdcTimeout"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int PoolIdcTimeout {
            get {
                if ((curObj["PoolIdcTimeout"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["PoolIdcTimeout"]));
            }
            set {
                curObj["PoolIdcTimeout"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string Realm {
            get {
                return ((string)(curObj["Realm"]));
            }
            set {
                curObj["Realm"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string[] RedirectHeaders {
            get {
                return ((string[])(curObj["RedirectHeaders"]));
            }
            set {
                curObj["RedirectHeaders"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public System.Management.ManagementBaseObject[] ScriptMaps {
            get {
                return ((System.Management.ManagementBaseObject[])(curObj["ScriptMaps"]));
            }
            set {
                curObj["ScriptMaps"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string SettingID {
            get {
                return ((string)(curObj["SettingID"]));
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsShutdownTimeLimitNull {
            get {
                if ((curObj["ShutdownTimeLimit"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int ShutdownTimeLimit {
            get {
                if ((curObj["ShutdownTimeLimit"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["ShutdownTimeLimit"]));
            }
            set {
                curObj["ShutdownTimeLimit"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsSSIExecDisableNull {
            get {
                if ((curObj["SSIExecDisable"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool SSIExecDisable {
            get {
                if ((curObj["SSIExecDisable"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["SSIExecDisable"]));
            }
            set {
                curObj["SSIExecDisable"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string UNCPassword {
            get {
                return ((string)(curObj["UNCPassword"]));
            }
            set {
                curObj["UNCPassword"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string UNCUserName {
            get {
                return ((string)(curObj["UNCUserName"]));
            }
            set {
                curObj["UNCUserName"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsUploadReadAheadSizeNull {
            get {
                if ((curObj["UploadReadAheadSize"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int UploadReadAheadSize {
            get {
                if ((curObj["UploadReadAheadSize"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["UploadReadAheadSize"]));
            }
            set {
                curObj["UploadReadAheadSize"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsUseDigestSSPNull {
            get {
                if ((curObj["UseDigestSSP"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool UseDigestSSP {
            get {
                if ((curObj["UseDigestSSP"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["UseDigestSSP"]));
            }
            set {
                curObj["UseDigestSSP"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsWebDAVMaxAttributesPerElementNull {
            get {
                if ((curObj["WebDAVMaxAttributesPerElement"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int WebDAVMaxAttributesPerElement {
            get {
                if ((curObj["WebDAVMaxAttributesPerElement"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["WebDAVMaxAttributesPerElement"]));
            }
            set {
                curObj["WebDAVMaxAttributesPerElement"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsWin32ErrorNull {
            get {
                if ((curObj["Win32Error"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int Win32Error {
            get {
                if ((curObj["Win32Error"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["Win32Error"]));
            }
            set {
                curObj["Win32Error"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        private bool CheckIfProperClass(System.Management.ManagementScope mgmtScope, System.Management.ManagementPath path, System.Management.ObjectGetOptions OptionsParam) {
            if (((path != null) 
                        && (System.String.Compare(path.ClassName, ManagementClassName, true, CultureInfo.InvariantCulture) == 0))) {
                return true;
            }
            else {
                return CheckIfProperClass(new System.Management.ManagementObject(mgmtScope, path, OptionsParam));
            }
        }
        
        private bool CheckIfProperClass(System.Management.ManagementBaseObject theObj) {
            if (((theObj != null) 
                        && (System.String.Compare(((string)(theObj["__CLASS"])), ManagementClassName, true, CultureInfo.InvariantCulture) == 0))) {
                return true;
            }
            else {
                System.Array parentClasses = ((System.Array)(theObj["__DERIVATION"]));
                if ((parentClasses != null)) {
                    Int32 count = 0;
                    for (count = 0; (count < parentClasses.Length); count = (count + 1)) {
                        if ((System.String.Compare(((string)(parentClasses.GetValue(count))), ManagementClassName, true, CultureInfo.InvariantCulture) == 0)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        
        private bool ShouldSerializeAccessExecute() {
            if ((IsAccessExecuteNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessExecute() {
            curObj["AccessExecute"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessFlags() {
            if ((IsAccessFlagsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessFlags() {
            curObj["AccessFlags"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessNoPhysicalDir() {
            if ((IsAccessNoPhysicalDirNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessNoPhysicalDir() {
            curObj["AccessNoPhysicalDir"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessNoRemoteExecute() {
            if ((IsAccessNoRemoteExecuteNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessNoRemoteExecute() {
            curObj["AccessNoRemoteExecute"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessNoRemoteRead() {
            if ((IsAccessNoRemoteReadNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessNoRemoteRead() {
            curObj["AccessNoRemoteRead"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessNoRemoteScript() {
            if ((IsAccessNoRemoteScriptNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessNoRemoteScript() {
            curObj["AccessNoRemoteScript"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessNoRemoteWrite() {
            if ((IsAccessNoRemoteWriteNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessNoRemoteWrite() {
            curObj["AccessNoRemoteWrite"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessRead() {
            if ((IsAccessReadNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessRead() {
            curObj["AccessRead"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessScript() {
            if ((IsAccessScriptNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessScript() {
            curObj["AccessScript"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessSource() {
            if ((IsAccessSourceNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessSource() {
            curObj["AccessSource"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessSSL() {
            if ((IsAccessSSLNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessSSL() {
            curObj["AccessSSL"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessSSL128() {
            if ((IsAccessSSL128Null == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessSSL128() {
            curObj["AccessSSL128"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessSSLFlags() {
            if ((IsAccessSSLFlagsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessSSLFlags() {
            curObj["AccessSSLFlags"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessSSLMapCert() {
            if ((IsAccessSSLMapCertNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessSSLMapCert() {
            curObj["AccessSSLMapCert"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessSSLNegotiateCert() {
            if ((IsAccessSSLNegotiateCertNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessSSLNegotiateCert() {
            curObj["AccessSSLNegotiateCert"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessSSLRequireCert() {
            if ((IsAccessSSLRequireCertNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessSSLRequireCert() {
            curObj["AccessSSLRequireCert"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessWrite() {
            if ((IsAccessWriteNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessWrite() {
            curObj["AccessWrite"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAdminACLBin() {
            curObj["AdminACLBin"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAnonymousPasswordSync() {
            if ((IsAnonymousPasswordSyncNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAnonymousPasswordSync() {
            curObj["AnonymousPasswordSync"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAnonymousUserName() {
            curObj["AnonymousUserName"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAnonymousUserPass() {
            curObj["AnonymousUserPass"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAppAllowClientDebug() {
            if ((IsAppAllowClientDebugNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAppAllowClientDebug() {
            curObj["AppAllowClientDebug"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAppAllowDebugging() {
            if ((IsAppAllowDebuggingNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAppAllowDebugging() {
            curObj["AppAllowDebugging"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAppFriendlyName() {
            curObj["AppFriendlyName"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAppOopRecoverLimit() {
            if ((IsAppOopRecoverLimitNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAppOopRecoverLimit() {
            curObj["AppOopRecoverLimit"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAppPoolId() {
            curObj["AppPoolId"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAppWamClsid() {
            curObj["AppWamClsid"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspAllowOutOfProcComponents() {
            if ((IsAspAllowOutOfProcComponentsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspAllowOutOfProcComponents() {
            curObj["AspAllowOutOfProcComponents"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspAllowSessionState() {
            if ((IsAspAllowSessionStateNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspAllowSessionState() {
            curObj["AspAllowSessionState"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspAppServiceFlags() {
            if ((IsAspAppServiceFlagsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspAppServiceFlags() {
            curObj["AspAppServiceFlags"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspBufferingLimit() {
            if ((IsAspBufferingLimitNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspBufferingLimit() {
            curObj["AspBufferingLimit"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspBufferingOn() {
            if ((IsAspBufferingOnNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspBufferingOn() {
            curObj["AspBufferingOn"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspCalcLineNumber() {
            if ((IsAspCalcLineNumberNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspCalcLineNumber() {
            curObj["AspCalcLineNumber"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspCodepage() {
            if ((IsAspCodepageNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspCodepage() {
            curObj["AspCodepage"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAspDiskTemplateCacheDirectory() {
            curObj["AspDiskTemplateCacheDirectory"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspEnableApplicationRestart() {
            if ((IsAspEnableApplicationRestartNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspEnableApplicationRestart() {
            curObj["AspEnableApplicationRestart"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspEnableAspHtmlFallback() {
            if ((IsAspEnableAspHtmlFallbackNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspEnableAspHtmlFallback() {
            curObj["AspEnableAspHtmlFallback"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspEnableChunkedEncoding() {
            if ((IsAspEnableChunkedEncodingNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspEnableChunkedEncoding() {
            curObj["AspEnableChunkedEncoding"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspEnableParentPaths() {
            if ((IsAspEnableParentPathsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspEnableParentPaths() {
            curObj["AspEnableParentPaths"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspEnableSxs() {
            if ((IsAspEnableSxsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspEnableSxs() {
            curObj["AspEnableSxs"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspEnableTracker() {
            if ((IsAspEnableTrackerNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspEnableTracker() {
            curObj["AspEnableTracker"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspEnableTypelibCache() {
            if ((IsAspEnableTypelibCacheNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspEnableTypelibCache() {
            curObj["AspEnableTypelibCache"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspErrorsToNTLog() {
            if ((IsAspErrorsToNTLogNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspErrorsToNTLog() {
            curObj["AspErrorsToNTLog"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspExceptionCatchEnable() {
            if ((IsAspExceptionCatchEnableNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspExceptionCatchEnable() {
            curObj["AspExceptionCatchEnable"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspExecuteInMTA() {
            if ((IsAspExecuteInMTANull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspExecuteInMTA() {
            curObj["AspExecuteInMTA"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspKeepSessionIDSecure() {
            if ((IsAspKeepSessionIDSecureNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspKeepSessionIDSecure() {
            curObj["AspKeepSessionIDSecure"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspLCID() {
            if ((IsAspLCIDNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspLCID() {
            curObj["AspLCID"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspLogErrorRequests() {
            if ((IsAspLogErrorRequestsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspLogErrorRequests() {
            curObj["AspLogErrorRequests"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspMaxDiskTemplateCacheFiles() {
            if ((IsAspMaxDiskTemplateCacheFilesNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspMaxDiskTemplateCacheFiles() {
            curObj["AspMaxDiskTemplateCacheFiles"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspMaxRequestEntityAllowed() {
            if ((IsAspMaxRequestEntityAllowedNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspMaxRequestEntityAllowed() {
            curObj["AspMaxRequestEntityAllowed"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAspPartitionID() {
            curObj["AspPartitionID"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspProcessorThreadMax() {
            if ((IsAspProcessorThreadMaxNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspProcessorThreadMax() {
            curObj["AspProcessorThreadMax"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspQueueConnectionTestTime() {
            if ((IsAspQueueConnectionTestTimeNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspQueueConnectionTestTime() {
            curObj["AspQueueConnectionTestTime"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspQueueTimeout() {
            if ((IsAspQueueTimeoutNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspQueueTimeout() {
            curObj["AspQueueTimeout"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspRequestQueueMax() {
            if ((IsAspRequestQueueMaxNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspRequestQueueMax() {
            curObj["AspRequestQueueMax"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspRunOnEndAnonymously() {
            if ((IsAspRunOnEndAnonymouslyNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspRunOnEndAnonymously() {
            curObj["AspRunOnEndAnonymously"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspScriptEngineCacheMax() {
            if ((IsAspScriptEngineCacheMaxNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspScriptEngineCacheMax() {
            curObj["AspScriptEngineCacheMax"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAspScriptErrorMessage() {
            curObj["AspScriptErrorMessage"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspScriptErrorSentToBrowser() {
            if ((IsAspScriptErrorSentToBrowserNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspScriptErrorSentToBrowser() {
            curObj["AspScriptErrorSentToBrowser"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspScriptFileCacheSize() {
            if ((IsAspScriptFileCacheSizeNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspScriptFileCacheSize() {
            curObj["AspScriptFileCacheSize"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAspScriptLanguage() {
            curObj["AspScriptLanguage"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspScriptTimeout() {
            if ((IsAspScriptTimeoutNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspScriptTimeout() {
            curObj["AspScriptTimeout"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspSessionMax() {
            if ((IsAspSessionMaxNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspSessionMax() {
            curObj["AspSessionMax"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspSessionTimeout() {
            if ((IsAspSessionTimeoutNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspSessionTimeout() {
            curObj["AspSessionTimeout"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAspSxsName() {
            curObj["AspSxsName"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspTrackThreadingModel() {
            if ((IsAspTrackThreadingModelNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspTrackThreadingModel() {
            curObj["AspTrackThreadingModel"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspUsePartition() {
            if ((IsAspUsePartitionNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspUsePartition() {
            curObj["AspUsePartition"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAuthAnonymous() {
            if ((IsAuthAnonymousNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAuthAnonymous() {
            curObj["AuthAnonymous"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAuthBasic() {
            if ((IsAuthBasicNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAuthBasic() {
            curObj["AuthBasic"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAuthFlags() {
            if ((IsAuthFlagsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAuthFlags() {
            curObj["AuthFlags"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAuthMD5() {
            if ((IsAuthMD5Null == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAuthMD5() {
            curObj["AuthMD5"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAuthNTLM() {
            if ((IsAuthNTLMNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAuthNTLM() {
            curObj["AuthNTLM"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAuthPassport() {
            if ((IsAuthPassportNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAuthPassport() {
            curObj["AuthPassport"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAuthPersistence() {
            if ((IsAuthPersistenceNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAuthPersistence() {
            curObj["AuthPersistence"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAuthPersistSingleRequest() {
            if ((IsAuthPersistSingleRequestNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAuthPersistSingleRequest() {
            curObj["AuthPersistSingleRequest"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAzEnable() {
            if ((IsAzEnableNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAzEnable() {
            curObj["AzEnable"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAzImpersonationLevel() {
            if ((IsAzImpersonationLevelNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAzImpersonationLevel() {
            curObj["AzImpersonationLevel"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAzScopeName() {
            curObj["AzScopeName"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAzStoreName() {
            curObj["AzStoreName"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetCacheControlCustom() {
            curObj["CacheControlCustom"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeCacheControlMaxAge() {
            if ((IsCacheControlMaxAgeNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetCacheControlMaxAge() {
            curObj["CacheControlMaxAge"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeCacheControlNoCache() {
            if ((IsCacheControlNoCacheNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetCacheControlNoCache() {
            curObj["CacheControlNoCache"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeCacheISAPI() {
            if ((IsCacheISAPINull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetCacheISAPI() {
            curObj["CacheISAPI"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeCGITimeout() {
            if ((IsCGITimeoutNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetCGITimeout() {
            curObj["CGITimeout"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeContentIndexed() {
            if ((IsContentIndexedNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetContentIndexed() {
            curObj["ContentIndexed"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeCreateCGIWithNewConsole() {
            if ((IsCreateCGIWithNewConsoleNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetCreateCGIWithNewConsole() {
            curObj["CreateCGIWithNewConsole"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeCreateProcessAsUser() {
            if ((IsCreateProcessAsUserNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetCreateProcessAsUser() {
            curObj["CreateProcessAsUser"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetDefaultDoc() {
            curObj["DefaultDoc"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetDefaultDocFooter() {
            curObj["DefaultDocFooter"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetDefaultLogonDomain() {
            curObj["DefaultLogonDomain"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeDirBrowseFlags() {
            if ((IsDirBrowseFlagsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetDirBrowseFlags() {
            curObj["DirBrowseFlags"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeDirBrowseShowDate() {
            if ((IsDirBrowseShowDateNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetDirBrowseShowDate() {
            curObj["DirBrowseShowDate"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeDirBrowseShowExtension() {
            if ((IsDirBrowseShowExtensionNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetDirBrowseShowExtension() {
            curObj["DirBrowseShowExtension"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeDirBrowseShowLongDate() {
            if ((IsDirBrowseShowLongDateNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetDirBrowseShowLongDate() {
            curObj["DirBrowseShowLongDate"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeDirBrowseShowSize() {
            if ((IsDirBrowseShowSizeNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetDirBrowseShowSize() {
            curObj["DirBrowseShowSize"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeDirBrowseShowTime() {
            if ((IsDirBrowseShowTimeNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetDirBrowseShowTime() {
            curObj["DirBrowseShowTime"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeDisableStaticFileCache() {
            if ((IsDisableStaticFileCacheNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetDisableStaticFileCache() {
            curObj["DisableStaticFileCache"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeDoDynamicCompression() {
            if ((IsDoDynamicCompressionNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetDoDynamicCompression() {
            curObj["DoDynamicCompression"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeDontLog() {
            if ((IsDontLogNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetDontLog() {
            curObj["DontLog"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeDoStaticCompression() {
            if ((IsDoStaticCompressionNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetDoStaticCompression() {
            curObj["DoStaticCompression"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeEnableDefaultDoc() {
            if ((IsEnableDefaultDocNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetEnableDefaultDoc() {
            curObj["EnableDefaultDoc"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeEnableDirBrowsing() {
            if ((IsEnableDirBrowsingNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetEnableDirBrowsing() {
            curObj["EnableDirBrowsing"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeEnableDocFooter() {
            if ((IsEnableDocFooterNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetEnableDocFooter() {
            curObj["EnableDocFooter"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeEnableReverseDns() {
            if ((IsEnableReverseDnsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetEnableReverseDns() {
            curObj["EnableReverseDns"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeFrontPageWeb() {
            if ((IsFrontPageWebNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetFrontPageWeb() {
            curObj["FrontPageWeb"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetHttpCustomHeaders() {
            curObj["HttpCustomHeaders"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetHttpErrors() {
            curObj["HttpErrors"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetHttpExpires() {
            curObj["HttpExpires"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetHttpPics() {
            curObj["HttpPics"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetHttpRedirect() {
            curObj["HttpRedirect"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogonMethod() {
            if ((IsLogonMethodNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogonMethod() {
            curObj["LogonMethod"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeMaxRequestEntityAllowed() {
            if ((IsMaxRequestEntityAllowedNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetMaxRequestEntityAllowed() {
            curObj["MaxRequestEntityAllowed"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetMimeMap() {
            curObj["MimeMap"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetNTAuthenticationProviders() {
            curObj["NTAuthenticationProviders"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializePassportRequireADMapping() {
            if ((IsPassportRequireADMappingNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetPassportRequireADMapping() {
            curObj["PassportRequireADMapping"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetPath0() {
            curObj["Path"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializePoolIdcTimeout() {
            if ((IsPoolIdcTimeoutNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetPoolIdcTimeout() {
            curObj["PoolIdcTimeout"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetRealm() {
            curObj["Realm"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetRedirectHeaders() {
            curObj["RedirectHeaders"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetScriptMaps() {
            curObj["ScriptMaps"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeShutdownTimeLimit() {
            if ((IsShutdownTimeLimitNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetShutdownTimeLimit() {
            curObj["ShutdownTimeLimit"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeSSIExecDisable() {
            if ((IsSSIExecDisableNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetSSIExecDisable() {
            curObj["SSIExecDisable"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetUNCPassword() {
            curObj["UNCPassword"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetUNCUserName() {
            curObj["UNCUserName"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeUploadReadAheadSize() {
            if ((IsUploadReadAheadSizeNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetUploadReadAheadSize() {
            curObj["UploadReadAheadSize"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeUseDigestSSP() {
            if ((IsUseDigestSSPNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetUseDigestSSP() {
            curObj["UseDigestSSP"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeWebDAVMaxAttributesPerElement() {
            if ((IsWebDAVMaxAttributesPerElementNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetWebDAVMaxAttributesPerElement() {
            curObj["WebDAVMaxAttributesPerElement"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeWin32Error() {
            if ((IsWin32ErrorNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetWin32Error() {
            curObj["Win32Error"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        [Browsable(true)]
        public void CommitObject() {
            if ((isEmbedded == false)) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private static string ConstructPath(string keyName) {
            string strPath = "ROOT\\MicrosoftIISv2:IIsWebVirtualDirSetting";
            strPath = (strPath 
                        + (".Name=" 
                        + ("\"" 
                        + (keyName + "\""))));
            return strPath;
        }
        
        // Different overloads of GetInstances() help in enumerating instances of the WMI class.
        public static IIsWebVirtualDirSettingCollection GetInstances() {
            return GetInstances(((System.Management.ManagementScope)(null)), ((System.Management.EnumerationOptions)(null)));
        }
        
        public static IIsWebVirtualDirSettingCollection GetInstances(string condition) {
            return GetInstances(null, condition, null);
        }
        
        public static IIsWebVirtualDirSettingCollection GetInstances(System.String [] selectedProperties) {
            return GetInstances(null, null, selectedProperties);
        }
        
        public static IIsWebVirtualDirSettingCollection GetInstances(string condition, System.String [] selectedProperties) {
            return GetInstances(null, condition, selectedProperties);
        }
        
        public static IIsWebVirtualDirSettingCollection GetInstances(System.Management.ManagementScope mgmtScope, System.Management.EnumerationOptions enumOptions) {
            if ((mgmtScope == null)) {
                if ((statMgmtScope == null)) {
                    mgmtScope = new System.Management.ManagementScope();
                    mgmtScope.Path.NamespacePath = "root\\MicrosoftIISv2";
                }
                else {
                    mgmtScope = statMgmtScope;
                }
            }
            System.Management.ManagementPath pathObj = new System.Management.ManagementPath();
            pathObj.ClassName = "IIsWebVirtualDirSetting";
            pathObj.NamespacePath = "root\\MicrosoftIISv2";
            System.Management.ManagementClass clsObject = new System.Management.ManagementClass(mgmtScope, pathObj, null);
            if ((enumOptions == null)) {
                enumOptions = new System.Management.EnumerationOptions();
                enumOptions.EnsureLocatable = true;
            }
            return new IIsWebVirtualDirSettingCollection(clsObject.GetInstances(enumOptions));
        }
        
        public static IIsWebVirtualDirSettingCollection GetInstances(System.Management.ManagementScope mgmtScope, string condition) {
            return GetInstances(mgmtScope, condition, null);
        }
        
        public static IIsWebVirtualDirSettingCollection GetInstances(System.Management.ManagementScope mgmtScope, System.String [] selectedProperties) {
            return GetInstances(mgmtScope, null, selectedProperties);
        }
        
        public static IIsWebVirtualDirSettingCollection GetInstances(System.Management.ManagementScope mgmtScope, string condition, System.String [] selectedProperties) {
            if ((mgmtScope == null)) {
                if ((statMgmtScope == null)) {
                    mgmtScope = new System.Management.ManagementScope();
                    mgmtScope.Path.NamespacePath = "root\\MicrosoftIISv2";
                }
                else {
                    mgmtScope = statMgmtScope;
                }
            }
            System.Management.ManagementObjectSearcher ObjectSearcher = new System.Management.ManagementObjectSearcher(mgmtScope, new SelectQuery("IIsWebVirtualDirSetting", condition, selectedProperties));
            System.Management.EnumerationOptions enumOptions = new System.Management.EnumerationOptions();
            enumOptions.EnsureLocatable = true;
            ObjectSearcher.Options = enumOptions;
            return new IIsWebVirtualDirSettingCollection(ObjectSearcher.Get());
        }
        
        [Browsable(true)]
        public static IIsWebVirtualDirSetting CreateInstance() {
            System.Management.ManagementScope mgmtScope = null;
            if ((statMgmtScope == null)) {
                mgmtScope = new System.Management.ManagementScope();
                mgmtScope.Path.NamespacePath = CreatedWmiNamespace;
            }
            else {
                mgmtScope = statMgmtScope;
            }
            System.Management.ManagementPath mgmtPath = new System.Management.ManagementPath(CreatedClassName);
            return new IIsWebVirtualDirSetting(new System.Management.ManagementClass(mgmtScope, mgmtPath, null).CreateInstance());
        }
        
        [Browsable(true)]
        public void Delete() {
            PrivateLateBoundObject.Delete();
        }
        
        // Enumerator implementation for enumerating instances of the class.
        public class IIsWebVirtualDirSettingCollection : object, ICollection {
            
            private ManagementObjectCollection ObjectCollection;
            
            public IIsWebVirtualDirSettingCollection(ManagementObjectCollection objCollection) {
                ObjectCollection = objCollection;
            }
            
            public int Count {
                get {
                    return ObjectCollection.Count;
                }
            }
            
            public bool IsSynchronized {
                get {
                    return ObjectCollection.IsSynchronized;
                }
            }
            
            public object SyncRoot {
                get {
                    return this;
                }
            }
            
            public void CopyTo(System.Array array, int index) {
                ObjectCollection.CopyTo(array, index);
                int nCtr;
                for (nCtr = 0; (nCtr < array.Length); nCtr = (nCtr + 1)) {
                    array.SetValue(new IIsWebVirtualDirSetting(((System.Management.ManagementObject)(array.GetValue(nCtr)))), nCtr);
                }
            }
            
            public System.Collections.IEnumerator GetEnumerator() {
                return new IIsWebVirtualDirSettingEnumerator(ObjectCollection.GetEnumerator());
            }
            
            public class IIsWebVirtualDirSettingEnumerator : object, System.Collections.IEnumerator {
                
                private ManagementObjectCollection.ManagementObjectEnumerator ObjectEnumerator;
                
                public IIsWebVirtualDirSettingEnumerator(ManagementObjectCollection.ManagementObjectEnumerator objEnum) {
                    ObjectEnumerator = objEnum;
                }
                
                public object Current {
                    get {
                        return new IIsWebVirtualDirSetting(((System.Management.ManagementObject)(ObjectEnumerator.Current)));
                    }
                }
                
                public bool MoveNext() {
                    return ObjectEnumerator.MoveNext();
                }
                
                public void Reset() {
                    ObjectEnumerator.Reset();
                }
            }
        }
        
        // TypeConverter to handle null values for ValueType properties
        public class WMIValueTypeConverter : TypeConverter {
            
            private TypeConverter baseConverter;
            
            public WMIValueTypeConverter(System.Type baseType) {
                baseConverter = TypeDescriptor.GetConverter(baseType);
            }
            
            public override bool CanConvertFrom(System.ComponentModel.ITypeDescriptorContext context, System.Type srcType) {
                return baseConverter.CanConvertFrom(context, srcType);
            }
            
            public override bool CanConvertTo(System.ComponentModel.ITypeDescriptorContext context, System.Type destinationType) {
                return baseConverter.CanConvertTo(context, destinationType);
            }
            
            public override object ConvertFrom(System.ComponentModel.ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value) {
                return baseConverter.ConvertFrom(context, culture, value);
            }
            
            public override object CreateInstance(System.ComponentModel.ITypeDescriptorContext context, System.Collections.IDictionary dictionary) {
                return baseConverter.CreateInstance(context, dictionary);
            }
            
            public override bool GetCreateInstanceSupported(System.ComponentModel.ITypeDescriptorContext context) {
                return baseConverter.GetCreateInstanceSupported(context);
            }
            
            public override PropertyDescriptorCollection GetProperties(System.ComponentModel.ITypeDescriptorContext context, object value, System.Attribute[] attributeVar) {
                return baseConverter.GetProperties(context, value, attributeVar);
            }
            
            public override bool GetPropertiesSupported(System.ComponentModel.ITypeDescriptorContext context) {
                return baseConverter.GetPropertiesSupported(context);
            }
            
            public override System.ComponentModel.TypeConverter.StandardValuesCollection GetStandardValues(System.ComponentModel.ITypeDescriptorContext context) {
                return baseConverter.GetStandardValues(context);
            }
            
            public override bool GetStandardValuesExclusive(System.ComponentModel.ITypeDescriptorContext context) {
                return baseConverter.GetStandardValuesExclusive(context);
            }
            
            public override bool GetStandardValuesSupported(System.ComponentModel.ITypeDescriptorContext context) {
                return baseConverter.GetStandardValuesSupported(context);
            }
            
            public override object ConvertTo(System.ComponentModel.ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value, System.Type destinationType) {
                if ((context != null)) {
                    if ((context.PropertyDescriptor.ShouldSerializeValue(context.Instance) == false)) {
                        return "";
                    }
                }
                return baseConverter.ConvertTo(context, culture, value, destinationType);
            }
        }
        
        // Embedded class to represent WMI system Properties.
        [TypeConverter(typeof(System.ComponentModel.ExpandableObjectConverter))]
        public class ManagementSystemProperties {
            
            private System.Management.ManagementBaseObject PrivateLateBoundObject;
            
            public ManagementSystemProperties(System.Management.ManagementBaseObject ManagedObject) {
                PrivateLateBoundObject = ManagedObject;
            }
            
            [Browsable(true)]
            public int GENUS {
                get {
                    return ((int)(PrivateLateBoundObject["__GENUS"]));
                }
            }
            
            [Browsable(true)]
            public string CLASS {
                get {
                    return ((string)(PrivateLateBoundObject["__CLASS"]));
                }
            }
            
            [Browsable(true)]
            public string SUPERCLASS {
                get {
                    return ((string)(PrivateLateBoundObject["__SUPERCLASS"]));
                }
            }
            
            [Browsable(true)]
            public string DYNASTY {
                get {
                    return ((string)(PrivateLateBoundObject["__DYNASTY"]));
                }
            }
            
            [Browsable(true)]
            public string RELPATH {
                get {
                    return ((string)(PrivateLateBoundObject["__RELPATH"]));
                }
            }
            
            [Browsable(true)]
            public int PROPERTY_COUNT {
                get {
                    return ((int)(PrivateLateBoundObject["__PROPERTY_COUNT"]));
                }
            }
            
            [Browsable(true)]
            public string[] DERIVATION {
                get {
                    return ((string[])(PrivateLateBoundObject["__DERIVATION"]));
                }
            }
            
            [Browsable(true)]
            public string SERVER {
                get {
                    return ((string)(PrivateLateBoundObject["__SERVER"]));
                }
            }
            
            [Browsable(true)]
            public string NAMESPACE {
                get {
                    return ((string)(PrivateLateBoundObject["__NAMESPACE"]));
                }
            }
            
            [Browsable(true)]
            public string PATH {
                get {
                    return ((string)(PrivateLateBoundObject["__PATH"]));
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\health\dll\Block_MaxConcurrency.cs ===
using System;
using System.Collections.Specialized;
using System.Text;

using Microsoft.Win32;


namespace xonline.common.health
{
   public class MaxConcurrencyHealthBlock : IHealthBlock
   {
      private const string RegistryKey = "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\ASP.NET\\2.0.50727.0";
      private const string RegistryValue = "maxConcurrentRequestsPerCPU";

      public ResourceTypeEnum ResourceType
      {
         get { return ResourceTypeEnum.Local; }
      }

      public void DoCheck(HealthBlockManager blockManager, NameValueCollection blockParams, HealthReport report)
      {
         StringBuilder detail = new StringBuilder();
         
         report.HealthStatus = HealthStatusEnum.Red;

         try 
         {
            object   configuration;       // Registry value
            string   expectedString;      // Block Parameter[max]
            int      expectedValue = 0;   // Parsed Block Parameter[max]

            expectedString = blockParams["max"];

            // Verify at most 1 value is specified
            if (null != expectedString && expectedString.Contains(","))
               throw new ArgumentException("more than one value specified", "max");
            if (null != expectedString && !int.TryParse(expectedString, out expectedValue))
               throw new ArgumentException("specified value is not a valid decimal int", "max");

            detail.AppendLine("Examining ASP.Net concurrency configuration:");
            detail.AppendLine("   " + RegistryKey + ":" + RegistryValue);

            // Attempt to get the setting
            configuration = Registry.GetValue(RegistryKey, RegistryValue, null);

            // Print the value or null
            detail.AppendLine("Value = " + (null == configuration ? "(null)" : configuration.ToString()));

            // Validated the value
            if (null == configuration) 
            {
               // Fail setting not found
               detail.AppendLine("The ASP.Net concurrency configuration registry value is not present on this machine.");
               return;
            }
            else if (configuration.GetType() != typeof(int)) 
            {
               // Fail setting not a dword
               detail.AppendLine("The ASP.Net concurrency configuration registry value is present but not the expected dword type.");
               detail.AppendLine("   Actual type = " + configuration.GetType().Name); 
               return;
            }
            else if (expectedString != null && (int)configuration != expectedValue)
            {
               // Fail configuration and expectation does not match
               detail.AppendLine("The expected ASP.Net concurrency configuration registry value does not match the actual setting.");
               detail.AppendLine("   Expected value = " + expectedValue);
               return;
            }

            report.HealthStatus = HealthStatusEnum.Green;   
         }
         catch (Exception e)
         {
            detail.AppendLine("Unexpected exception:");
            detail.AppendLine(e.ToString());
         }
         finally {
            report.ErrorDetails = detail.ToString();
         }
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\health\dll\Block_MusicnetEcommerceB2B.cs ===
//
// Block_MusicnetEcommerceB2B.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Healthcheck Module
// Xbox Online Service
//
// Common healthblock implementation.
//

using System;
using System.Collections.Generic;
using System.Collections.Specialized;

using xonline.common.config;
using xonline.common.musicnet;
using xonline.common.offer;
using xonline.common.service;

namespace xonline.common.health
{
    // --------------------------------------------------------------------------------------
    // MusicnetEcommerceB2B - initialize and check health of the Musicnet EcommerceB2B web
    // service
    // PARAMETERS:
    //
    // "customerId" : customerId of an existing Musicnet account.  Because the EcommerceB2B
    // service has no TestConnection or other no-op API, we will test the availability by
    // calling the CreateAccount API for a known, existing account and verify we receive the
    // "already exists" error.
    //
    // Example:
    // "customerId=9009c145d861b"
    //
    // --------------------------------------------------------------------------------------
    internal class MusicnetEcommerceB2B : IHealthBlock
    {
        public ResourceTypeEnum ResourceType
        {
            get { return ResourceTypeEnum.Remote; }
        }

        public void DoCheck(HealthBlockManager blockManager, NameValueCollection blockParams, HealthReport report)
        {
            // set output param immediately
            MusicnetEcommerceB2BReport myReport = new MusicnetEcommerceB2BReport();
            report.ExtendedReport = myReport;

            try
            {
                myReport.ServiceConfigurationUrl = Config.GetSetting(Setting.musicnet_getServiceConfigurationUrl);
                myReport.RetailerId = Config.GetSetting(Setting.musicnet_retailerID);
                myReport.ProxyUrl = Config.GetSetting(Setting.billing_proxy);

                myReport.SubscriptionSku = Config.GetSetting(Setting.musicnet_subscriptionSku);
                myReport.TrialSubscriptionSku = Config.GetSetting(Setting.musicnet_trialSubscriptionSku);
                myReport.UseMusicNetForProvisioning = Config.GetBoolSetting(Setting.crux_useMusicNetForProvisioning);

                if ( Offer.MusicNetSkuOverrides != null && Offer.MusicNetSkuOverrides.Count > 0 )
                {
                    int count = 0;
                    string overrideText = "( ";
                    foreach ( KeyValuePair<ulong,string> kvp in Offer.MusicNetSkuOverrides )
                    {
                        overrideText += (count++ > 0 ? ", " : "") + "0x" + kvp.Key.ToString("x") + "=" + kvp.Value;
                    }
                    overrideText += " )";

                    myReport.MusicnetSkuOverrides = overrideText;
                }


                // fetch the various service URLs from the Musicnet discovery service
                MNServiceWrapper.UpdateServiceConfiguration();

                MNServiceWrapper mnsw = new MNServiceWrapper();

                //
                // If a known existing account is specified, try creating it now and verify
                // that it fails with a DUPLICATE_USER error.  Sounds kludgy, eh?  Well, Musicnet
                // didn't provide a no-op "ping" type API that could be used to check so this is
                // what we are left with.
                //
                string[] customerIds = null;

                customerIds = blockParams.GetValues(Config.Environment + "CustomerId");

                if ( customerIds == null || customerIds.Length == 0 )
                {
                    customerIds = blockParams.GetValues("customerId");
                }

                bool foundAccount = false;

                foreach (string customerId in customerIds)
                {
                    Guid orderId = Guid.NewGuid();

                    //
                    // If only MusicNet had exposed a TestConnection API... *sigh*
                    //
                    // If MusicNet has been disabled, CreateAccount is no longer used so
                    // instead, attempt to call CancelSubscriptionOffer to verify that the
                    // ZEST proxy will receive the request and return successfully.
                    //
                    if ( false == Config.GetBoolSetting(Setting.crux_useMusicNetForProvisioning) )
                    {
                        // customerId is the hex representation of the userPuid minus leading 0x
                        ulong userPuid = SafeConvert.ToUInt64("0x" + customerId);

                        mnsw.CancelSubscriptionOffer(userPuid, customerId, orderId.ToString(), true);
                        foundAccount = true;
                        myReport.VerifiedCustomerId = "n/a";
                        break;
                    }
                    else
                    {
                        try
                        {
                            mnsw.CreateAccount(customerId, orderId.ToString());

                        }
                        catch (MusicnetException mne)
                        {
                            if ( mne.HResult == HResult.XONLINE_E_MUSICNET_DUPLICATE_USER_NAME )
                            {
                                foundAccount = true;
                                myReport.VerifiedCustomerId = customerId;
                            }
                        }
                    }
                }

                if ( customerIds.Length > 0 && !foundAccount )
                {
                    report.HealthStatus = HealthStatusEnum.Yellow;
                    report.ErrorDetails = "No existing MusicNet accounts found!  Verify Musicnet connectivity for the EcommerceB2B service.";
                    return;
                }

                myReport.EcommerceB2BServiceUrl = MNServiceWrapper.MusicnetEcommerceUrl;
            }
            catch (Exception e)
            {
                report.HealthStatus = HealthStatusEnum.Yellow;
                report.ErrorDetails = "Failed to call Musicnet CreateAccount API.  Exception: " + e.ToString();
                return;
            }

            // if we made it this far, things are good to go
            report.HealthStatus = HealthStatusEnum.Green;
        }
    }

    // --------------------------------------------------------------------------------------
    // MusicnetEcommerceB2BReport - health report
    // --------------------------------------------------------------------------------------
    public class MusicnetEcommerceB2BReport : IExtendedHealthReport
    {
        public string ServiceConfigurationUrl;
        public string EcommerceB2BServiceUrl;
        public string RetailerId;
        public string ProxyUrl;
        public string VerifiedCustomerId;
        public string SubscriptionSku;
        public string TrialSubscriptionSku;
        public string MusicnetSkuOverrides;
        public bool   UseMusicNetForProvisioning;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\health\dll\Block_MasterPrivateKey.cs ===
using System;
using System.Collections.Specialized;
using System.IO;
using System.Security.Cryptography;

using xonline.common.crypto;

// Healthblock: MasterPrivateKey
// Verifies presence of the master key on this machine.
//
// Param: MasterKeyVersion=n [required]
// where n is the expected version of the master key. You probably want "1". 
//
// Param: PublicKeyFile=file [optional]
// where file is the full path to the public key master file, if you want to verify its 
// presence. 
// 

namespace xonline.common.health
{
    internal class MasterPrivateKey : IHealthBlock
    {
        public ResourceTypeEnum ResourceType { get { return ResourceTypeEnum.Local; } }

        public void DoCheck(HealthBlockManager blockManager, NameValueCollection blockParams, HealthReport report)
        {
            report.HealthStatus = HealthStatusEnum.Green;

            // Check parameters. Bad parameters doesn't mean we should be taken out of the VIP, it just means that
            // the check is misconfigured and should be fixed in npdb.
            string paramError;

            uint masterKeyVersion;
            if (!TryGetMasterKeyVersion(blockParams, out masterKeyVersion, out paramError))
            {
                report.HealthStatus = HealthStatusEnum.Yellow;
                report.ErrorDetails = paramError ?? String.Empty;
                return;
            }

            byte[] publicKey;
            bool doEncryptDecryptTest = TryGetPublicKeyParameter(blockParams, masterKeyVersion, out publicKey, out paramError);
            if (!doEncryptDecryptTest && !String.IsNullOrEmpty(paramError))
            {
                report.HealthStatus = HealthStatusEnum.Yellow;
                report.ErrorDetails = paramError;
                return;
            }

            // Do the actual tests.
            try
            {
                TestMasterPrivateKeyExistance(masterKeyVersion, report);
                if (report.HealthStatus == HealthStatusEnum.Green && doEncryptDecryptTest)
                {
                    TestEncryptionAndDecryption(masterKeyVersion, publicKey, report);
                }
            }
            catch (Exception)
            {
                report.HealthStatus = HealthStatusEnum.Red;
                throw;
            }
        }

        private static bool TryGetMasterKeyVersion(NameValueCollection blockParams, out uint masterKeyVersion, out string error)
        {
            error = String.Empty;
            string masterKeyVersionString = blockParams[VERSION_KEY];

            if (String.IsNullOrEmpty(masterKeyVersionString))
            {
                error = String.Format("Parameter {0} must be present for this health check to work.", VERSION_KEY);
                masterKeyVersion = 0;
                return false;
            }
            else if (!UInt32.TryParse(masterKeyVersionString, out masterKeyVersion))
            {
                error = String.Format("Parameter {0} of {1} does not parse to an unsigned int.", VERSION_KEY, masterKeyVersionString);
                return false;
            }
            else
            {
                return true;
            }
        }

        private static bool TryGetPublicKeyParameter(NameValueCollection blockParams, uint expectedMasterKeyVersion, out byte[] publicKey, out string error)
        {
            error = String.Empty;
            publicKey = null;

            string publicKeyFile = blockParams[PUBLIC_KEY_FILE_KEY];
            if (String.IsNullOrEmpty(publicKeyFile))
            {
                return false;
            }
            else if (!File.Exists(publicKeyFile))
            {
                error = String.Format(
                    "File {1} does not exist. If parameter {0} is present, it must be the full path of the binary file containing the master public key.",
                    PUBLIC_KEY_FILE_KEY, publicKeyFile);
                return false;
            }
            else {
                FileInfo fileInfo = new FileInfo(publicKeyFile);
                using (BinaryReader reader = new BinaryReader(new FileStream(publicKeyFile, FileMode.Open)))
                {
                    // The first four bytes are the version, which must match the expected version. The rest is the real key.
                    byte[] publicKeyTemp = reader.ReadBytes((int)fileInfo.Length);
                    uint masterKeyVersionFromPublicKey = BitConverter.ToUInt32(publicKeyTemp, 0);
                    if (expectedMasterKeyVersion != masterKeyVersionFromPublicKey)
                    {
                        error = String.Format("The master key version in the parameters ({0}) must machine the one from the master public key file ({1}).",
                            expectedMasterKeyVersion, masterKeyVersionFromPublicKey);
                        return false;
                    }

                    publicKey = new byte[publicKeyTemp.Length - 4];
                    Array.ConstrainedCopy(publicKeyTemp, 4, publicKey, 0, publicKey.Length);
                    return true;
                }
           }
        }

        private static void TestMasterPrivateKeyExistance(uint masterKeyVersion, HealthReport report)
        {
            // These are the same parameters we use in the native code version. If we can create
            // a crypto provider, we should be good to go.
            CspParameters cspParams = new CspParameters();
            cspParams.KeyContainerName = FormatMasterKeyContainerName(masterKeyVersion);
            cspParams.ProviderName = "Microsoft Enhanced Cryptographic Provider v1.0"; // MS_ENHANCED_PROV
            cspParams.ProviderType = 1; // PROV_RSA_FULL
            cspParams.Flags = CspProviderFlags.UseMachineKeyStore | CspProviderFlags.UseExistingKey;

            RSACryptoServiceProvider provider = new RSACryptoServiceProvider(cspParams);
            provider.Clear();

            report.HealthStatus = HealthStatusEnum.Green;
        }

        private static void TestEncryptionAndDecryption(uint masterKeyVersion, byte[] publicKey, HealthReport report)
        {
            string test = "Testing the master private key.";
            byte[] testBytes = System.Text.Encoding.ASCII.GetBytes(test);

            XoCryptoWrapperClass cryptoWrap = new XoCryptoWrapperClass();
            byte[] testEncrypted = cryptoWrap.EncryptWithMasterKeyWrp(
                masterKeyVersion,
                (uint)publicKey.Length, publicKey,
                (uint)testBytes.Length, testBytes);

            string testDecrypted = System.Text.Encoding.ASCII.GetString(cryptoWrap.DecryptWithMasterKeyWrp(masterKeyVersion, (uint)testEncrypted.Length, testEncrypted));

            if (test != testDecrypted)
            {
                report.HealthStatus = HealthStatusEnum.Red;
                report.ErrorDetails = String.Format(
                    "The test string \"{0}\" encrypted and then decrypted with master key version {1} results in \"{2}\". This does not make sense.",
                    test, masterKeyVersion, testDecrypted);
            }
            else
            {
                report.HealthStatus = HealthStatusEnum.Green;
            }
        }

        private static string FormatMasterKeyContainerName(uint masterKeyVersion)
        {
            return String.Format("XOMasterKey{0}", masterKeyVersion);
        }

        private const string VERSION_KEY = "MasterKeyVersion";
        private const string PUBLIC_KEY_FILE_KEY = "PublicKeyFile";

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\health\dll\Block_Interface.cs ===
//
// interface.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Healthcheck Module
// Xbox Online Service
//
// Common healthblock implementation.
//

using System;
using System.Collections.Generic;
using System.Collections.Specialized;

using xonline.common.config;

namespace xonline.common.health
{

// -----------------------------------------------------------------------------
// InterfaceSettings - checks dependent Interface settings. Returns their value.
//                     No validation.
//
// PARAMETERS:
//
// "interface" : 1 or more exact interface names to retrieve the value of.
//               Example: "interface=uodb,interface=npdb"
//
// -----------------------------------------------------------------------------
internal class InterfaceSettings : IHealthBlock
{
    public ResourceTypeEnum ResourceType
    {
        get { return ResourceTypeEnum.Local; }
    }

    public void DoCheck(
        HealthBlockManager  blockManager,
        NameValueCollection blockParams,
        HealthReport        report)
    {
        string                  sqlConnectionString;
        IInterfaceInfo          iinfo;
        IVirtualInterfaceInfo   viinfo;

        // Set output param immediately
        InterfaceSettingsReport myReport = new InterfaceSettingsReport();
        report.ExtendedReport = myReport;

        // we always succeed
        report.HealthStatus   = HealthStatusEnum.Green;

        // Fill out report
        myReport.Component = Config.ComponentName;
        myReport.Server = Config.Server;
        myReport.Site = Config.SiteId;

        // Parse params
        string[] interfaces = blockParams.GetValues("interface");

        // Try to find those interfaces
        if (interfaces != null)
        {
            foreach (string iface in interfaces)
            {
                try
                {
                    iinfo = Config.GetInterface( iface );

                    // Prevent users from specifying an interface that doesn't
                    // have a SQL connection string
                    if (iinfo.Protocol == "sql")
                    {
                        sqlConnectionString = iinfo.SqlConnectionString;
                    }
                    else
                    {
                        continue;
                    }

                    string [] sqlParams = sqlConnectionString.Split(
                        new char[] { ';' }
                        );
                    foreach (string s in sqlParams)
                    {
                        string [] sqlSettings = s.Split( new char[] { '=' } );
                        if (sqlSettings.Length == 2)
                        {
                            myReport.AddSetting(
                                iface + "." + sqlSettings[0],
                                sqlSettings[1]
                                );
                        }
                    }
                }
                catch (ApplicationException)
                {
                    // For whatever reason, this interface cannot be loaded
                    continue;
                }
            }
        }

        // Parse params
        string[] vinterfaces = blockParams.GetValues("virtualinterface");

        // Try to find those interfaces
        if (vinterfaces != null)
        {
            foreach (string viface in vinterfaces)
            {
                try
                {
                    viinfo = Config.GetVirtualInterface( viface );

                    // Prevent users from specifying an interface that doesn't
                    // have a SQL connection string
                    if (viinfo.Protocol == "sql")
                    {
                        sqlConnectionString = viinfo.SqlConnectionString;
                    }
                    else
                    {
                        continue;
                    }

                    string [] sqlParams = sqlConnectionString.Split(
                        new char[] { ';' }
                        );
                    foreach (string s in sqlParams)
                    {
                        string [] sqlSettings = s.Split( new char[] { '=' } );
                        if (sqlSettings.Length == 2)
                        {
                            myReport.AddSetting(
                                viface + "." + sqlSettings[0],
                                sqlSettings[1]
                                );
                        }
                    }
                }
                catch (ApplicationException)
                {
                    // For whatever reason, this interface cannot be loaded
                    continue;
                }
            }
        }

    }
}

// --------------------------------------------------------------------------------------
// NpdbSettingsReport - health report
// --------------------------------------------------------------------------------------
public class InterfaceSettingsReport : IExtendedHealthReport
{
    public string Component;
    public string Server;
    public int Site;

    public List<NameValuePair> InterfaceSettings;

    public InterfaceSettingsReport()
    {
        InterfaceSettings = new List<NameValuePair>();
    }

    public void AddSetting(string n, string v)
    {
        NameValuePair info = new NameValuePair();
        info.Name = n;
        info.Value = v;

        InterfaceSettings.Add(info);
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\core\wmi\iisv2\IIsWebServiceSetting.CS ===
﻿namespace xonline.common.wmi.iisv2 {
    using System;
    using System.ComponentModel;
    using System.Management;
    using System.Collections;
    using System.Globalization;
    using System.ComponentModel.Design.Serialization;
    using System.Reflection;
    
    
    // Functions ShouldSerialize<PropertyName> are functions used by VS property browser to check if a particular property has to be serialized. These functions are added for all ValueType properties ( properties of type Int32, BOOL etc.. which cannot be set to null). These functions use Is<PropertyName>Null function. These functions are also used in the TypeConverter implementation for the properties to check for NULL value of property so that an empty value can be shown in Property browser in case of Drag and Drop in Visual studio.
    // Functions Is<PropertyName>Null() are used to check if a property is NULL.
    // Functions Reset<PropertyName> are added for Nullable Read/Write properties. These functions are used by VS designer in property browser to set a property to NULL.
    // Every property added to the class for WMI property has attributes set to define its behavior in Visual Studio designer and also to define a TypeConverter to be used.
    // 
    // 
    // 
    // 
    // If the embedded property is strongly typed then, to strongly type the property to the type of
    // the embedded object, you have to do the following things.
    // 	1. Generate Managed class for the WMI class of the embedded property. This can be done with MgmtClassGen.exe tool or from Server Explorer.
    // 	2. Include the namespace of the generated class.
    // 	3. Change the property get/set functions so as return the instance of the Managed class.
    // Below is a sample code.
    // 
    // VB Code
    // Public Property <PropertyName>() As <ManagedClassName of Embedded property>
    // 	Get
    // 		Return New <ManagedClassName of Embedded Property>(CType(curObj("<PropertyName>"),System.Management.ManagementBaseObject))
    // 	End Get
    // 	Set(ByVal Value As <ManagedClassName of Embedded property>)
    // 		curObj("EObject") = Value.LateBoundObject
    // 		If (AutoCommitProp = True And isEmbedded = False) Then
    // 			PrivateLateBoundObject.Put()
    // 		End If
    // 	End Set
    // 
    // C# Code
    // public <ManagedClassName of Embedded property> <PropertyName>
    // {
    // 	get
    // 	{
    // 		return new <ManagedClassName of Embedded property>((System.Management.ManagementBaseObject)(curObj["<PropertyName>"]));
    // 	}
    // 	set
    // 	{
    // 		curObj["<PropertyName>"] = value.LateBoundObject;
    // 		If (AutoCommitProp == true && isEmbedded == false)
    // 		{
    // 			PrivateLateBoundObject.Put();
    // 		}
    // 	}
    // }
    // An Early Bound class generated for the WMI class.IIsWebServiceSetting
    public class IIsWebServiceSetting : System.ComponentModel.Component {
        
        // Private property to hold the WMI namespace in which the class resides.
        private static string CreatedWmiNamespace = "ROOT\\MicrosoftIISv2";
        
        // Private property to hold the name of WMI class which created this class.
        private static string CreatedClassName = "IIsWebServiceSetting";
        
        // Private member variable to hold the ManagementScope which is used by the various methods.
        private static System.Management.ManagementScope statMgmtScope = null;
        
        private ManagementSystemProperties PrivateSystemProperties;
        
        // Underlying lateBound WMI object.
        private System.Management.ManagementObject PrivateLateBoundObject;
        
        // Member variable to store the 'automatic commit' behavior for the class.
        private bool AutoCommitProp = true;
        
        // Private variable to hold the embedded property representing the instance.
        private System.Management.ManagementBaseObject embeddedObj;
        
        // The current WMI object used
        private System.Management.ManagementBaseObject curObj;
        
        // Flag to indicate if the instance is an embedded object.
        private bool isEmbedded = false;
        
        // Below are different overloads of constructors to initialize an instance of the class with a WMI object.
        public IIsWebServiceSetting() : 
                this(((System.Management.ManagementScope)(null)), ((System.Management.ManagementPath)(null)), ((System.Management.ObjectGetOptions)(null))) {
        }
        
        public IIsWebServiceSetting(string keyName) : 
                this(((System.Management.ManagementScope)(null)), ((System.Management.ManagementPath)(new System.Management.ManagementPath(IIsWebServiceSetting.ConstructPath(keyName)))), ((System.Management.ObjectGetOptions)(null))) {
        }
        
        public IIsWebServiceSetting(System.Management.ManagementScope mgmtScope, string keyName) : 
                this(((System.Management.ManagementScope)(mgmtScope)), ((System.Management.ManagementPath)(new System.Management.ManagementPath(IIsWebServiceSetting.ConstructPath(keyName)))), ((System.Management.ObjectGetOptions)(null))) {
        }
        
        public IIsWebServiceSetting(System.Management.ManagementPath path, System.Management.ObjectGetOptions getOptions) : 
                this(((System.Management.ManagementScope)(null)), ((System.Management.ManagementPath)(path)), ((System.Management.ObjectGetOptions)(getOptions))) {
        }
        
        public IIsWebServiceSetting(System.Management.ManagementScope mgmtScope, System.Management.ManagementPath path) : 
                this(((System.Management.ManagementScope)(mgmtScope)), ((System.Management.ManagementPath)(path)), ((System.Management.ObjectGetOptions)(null))) {
        }
        
        public IIsWebServiceSetting(System.Management.ManagementPath path) : 
                this(((System.Management.ManagementScope)(null)), ((System.Management.ManagementPath)(path)), ((System.Management.ObjectGetOptions)(null))) {
        }
        
        public IIsWebServiceSetting(System.Management.ManagementScope mgmtScope, System.Management.ManagementPath path, System.Management.ObjectGetOptions getOptions) {
            if ((path != null)) {
                if ((CheckIfProperClass(mgmtScope, path, getOptions) != true)) {
                    throw new System.ArgumentException("Class name does not match.");
                }
            }
            PrivateLateBoundObject = new System.Management.ManagementObject(mgmtScope, path, getOptions);
            PrivateSystemProperties = new ManagementSystemProperties(PrivateLateBoundObject);
            curObj = PrivateLateBoundObject;
        }
        
        public IIsWebServiceSetting(System.Management.ManagementObject theObject) {
            if ((CheckIfProperClass(theObject) == true)) {
                PrivateLateBoundObject = theObject;
                PrivateSystemProperties = new ManagementSystemProperties(PrivateLateBoundObject);
                curObj = PrivateLateBoundObject;
            }
            else {
                throw new System.ArgumentException("Class name does not match.");
            }
        }
        
        public IIsWebServiceSetting(System.Management.ManagementBaseObject theObject) {
            if ((CheckIfProperClass(theObject) == true)) {
                embeddedObj = theObject;
                PrivateSystemProperties = new ManagementSystemProperties(theObject);
                curObj = embeddedObj;
                isEmbedded = true;
            }
            else {
                throw new System.ArgumentException("Class name does not match.");
            }
        }
        
        // Property returns the namespace of the WMI class.
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string OriginatingNamespace {
            get {
                return "ROOT\\MicrosoftIISv2";
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string ManagementClassName {
            get {
                string strRet = CreatedClassName;
                if ((curObj != null)) {
                    if ((curObj.ClassPath != null)) {
                        strRet = ((string)(curObj["__CLASS"]));
                        if (((strRet == null) 
                                    || (strRet == System.String.Empty))) {
                            strRet = CreatedClassName;
                        }
                    }
                }
                return strRet;
            }
        }
        
        // Property pointing to an embedded object to get System properties of the WMI object.
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public ManagementSystemProperties SystemProperties {
            get {
                return PrivateSystemProperties;
            }
        }
        
        // Property returning the underlying lateBound object.
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public System.Management.ManagementBaseObject LateBoundObject {
            get {
                return curObj;
            }
        }
        
        // ManagementScope of the object.
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public System.Management.ManagementScope Scope {
            get {
                if ((isEmbedded == false)) {
                    return PrivateLateBoundObject.Scope;
                }
                else {
                    return null;
                }
            }
            set {
                if ((isEmbedded == false)) {
                    PrivateLateBoundObject.Scope = value;
                }
            }
        }
        
        // Property to show the commit behavior for the WMI object. If true, WMI object will be automatically saved after each property modification.(ie. Put() is called after modification of a property).
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool AutoCommit {
            get {
                return AutoCommitProp;
            }
            set {
                AutoCommitProp = value;
            }
        }
        
        // The ManagementPath of the underlying WMI object.
        [Browsable(true)]
        public System.Management.ManagementPath Path {
            get {
                if ((isEmbedded == false)) {
                    return PrivateLateBoundObject.Path;
                }
                else {
                    return null;
                }
            }
            set {
                if ((isEmbedded == false)) {
                    if ((CheckIfProperClass(null, value, null) != true)) {
                        throw new System.ArgumentException("Class name does not match.");
                    }
                    PrivateLateBoundObject.Path = value;
                }
            }
        }
        
        // Public static scope property which is used by the various methods.
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public static System.Management.ManagementScope StaticScope {
            get {
                return statMgmtScope;
            }
            set {
                statMgmtScope = value;
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAccessExecuteNull {
            get {
                if ((curObj["AccessExecute"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AccessExecute {
            get {
                if ((curObj["AccessExecute"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AccessExecute"]));
            }
            set {
                curObj["AccessExecute"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAccessFlagsNull {
            get {
                if ((curObj["AccessFlags"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AccessFlags {
            get {
                if ((curObj["AccessFlags"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AccessFlags"]));
            }
            set {
                curObj["AccessFlags"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAccessNoPhysicalDirNull {
            get {
                if ((curObj["AccessNoPhysicalDir"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AccessNoPhysicalDir {
            get {
                if ((curObj["AccessNoPhysicalDir"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AccessNoPhysicalDir"]));
            }
            set {
                curObj["AccessNoPhysicalDir"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAccessNoRemoteExecuteNull {
            get {
                if ((curObj["AccessNoRemoteExecute"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AccessNoRemoteExecute {
            get {
                if ((curObj["AccessNoRemoteExecute"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AccessNoRemoteExecute"]));
            }
            set {
                curObj["AccessNoRemoteExecute"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAccessNoRemoteReadNull {
            get {
                if ((curObj["AccessNoRemoteRead"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AccessNoRemoteRead {
            get {
                if ((curObj["AccessNoRemoteRead"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AccessNoRemoteRead"]));
            }
            set {
                curObj["AccessNoRemoteRead"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAccessNoRemoteScriptNull {
            get {
                if ((curObj["AccessNoRemoteScript"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AccessNoRemoteScript {
            get {
                if ((curObj["AccessNoRemoteScript"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AccessNoRemoteScript"]));
            }
            set {
                curObj["AccessNoRemoteScript"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAccessNoRemoteWriteNull {
            get {
                if ((curObj["AccessNoRemoteWrite"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AccessNoRemoteWrite {
            get {
                if ((curObj["AccessNoRemoteWrite"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AccessNoRemoteWrite"]));
            }
            set {
                curObj["AccessNoRemoteWrite"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAccessReadNull {
            get {
                if ((curObj["AccessRead"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AccessRead {
            get {
                if ((curObj["AccessRead"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AccessRead"]));
            }
            set {
                curObj["AccessRead"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAccessScriptNull {
            get {
                if ((curObj["AccessScript"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AccessScript {
            get {
                if ((curObj["AccessScript"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AccessScript"]));
            }
            set {
                curObj["AccessScript"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAccessSourceNull {
            get {
                if ((curObj["AccessSource"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AccessSource {
            get {
                if ((curObj["AccessSource"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AccessSource"]));
            }
            set {
                curObj["AccessSource"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAccessSSLNull {
            get {
                if ((curObj["AccessSSL"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AccessSSL {
            get {
                if ((curObj["AccessSSL"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AccessSSL"]));
            }
            set {
                curObj["AccessSSL"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAccessSSL128Null {
            get {
                if ((curObj["AccessSSL128"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AccessSSL128 {
            get {
                if ((curObj["AccessSSL128"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AccessSSL128"]));
            }
            set {
                curObj["AccessSSL128"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAccessSSLFlagsNull {
            get {
                if ((curObj["AccessSSLFlags"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AccessSSLFlags {
            get {
                if ((curObj["AccessSSLFlags"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AccessSSLFlags"]));
            }
            set {
                curObj["AccessSSLFlags"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAccessSSLMapCertNull {
            get {
                if ((curObj["AccessSSLMapCert"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AccessSSLMapCert {
            get {
                if ((curObj["AccessSSLMapCert"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AccessSSLMapCert"]));
            }
            set {
                curObj["AccessSSLMapCert"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAccessSSLNegotiateCertNull {
            get {
                if ((curObj["AccessSSLNegotiateCert"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AccessSSLNegotiateCert {
            get {
                if ((curObj["AccessSSLNegotiateCert"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AccessSSLNegotiateCert"]));
            }
            set {
                curObj["AccessSSLNegotiateCert"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAccessSSLRequireCertNull {
            get {
                if ((curObj["AccessSSLRequireCert"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AccessSSLRequireCert {
            get {
                if ((curObj["AccessSSLRequireCert"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AccessSSLRequireCert"]));
            }
            set {
                curObj["AccessSSLRequireCert"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAccessWriteNull {
            get {
                if ((curObj["AccessWrite"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AccessWrite {
            get {
                if ((curObj["AccessWrite"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AccessWrite"]));
            }
            set {
                curObj["AccessWrite"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public System.Byte[] AdminACLBin {
            get {
                return ((System.Byte[])(curObj["AdminACLBin"]));
            }
            set {
                curObj["AdminACLBin"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string AdminServer {
            get {
                return ((string)(curObj["AdminServer"]));
            }
            set {
                curObj["AdminServer"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAllowKeepAliveNull {
            get {
                if ((curObj["AllowKeepAlive"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AllowKeepAlive {
            get {
                if ((curObj["AllowKeepAlive"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AllowKeepAlive"]));
            }
            set {
                curObj["AllowKeepAlive"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAllowPathInfoForScriptMappingsNull {
            get {
                if ((curObj["AllowPathInfoForScriptMappings"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AllowPathInfoForScriptMappings {
            get {
                if ((curObj["AllowPathInfoForScriptMappings"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AllowPathInfoForScriptMappings"]));
            }
            set {
                curObj["AllowPathInfoForScriptMappings"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAnonymousPasswordSyncNull {
            get {
                if ((curObj["AnonymousPasswordSync"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AnonymousPasswordSync {
            get {
                if ((curObj["AnonymousPasswordSync"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AnonymousPasswordSync"]));
            }
            set {
                curObj["AnonymousPasswordSync"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string AnonymousUserName {
            get {
                return ((string)(curObj["AnonymousUserName"]));
            }
            set {
                curObj["AnonymousUserName"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string AnonymousUserPass {
            get {
                return ((string)(curObj["AnonymousUserPass"]));
            }
            set {
                curObj["AnonymousUserPass"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAppAllowClientDebugNull {
            get {
                if ((curObj["AppAllowClientDebug"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AppAllowClientDebug {
            get {
                if ((curObj["AppAllowClientDebug"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AppAllowClientDebug"]));
            }
            set {
                curObj["AppAllowClientDebug"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAppAllowDebuggingNull {
            get {
                if ((curObj["AppAllowDebugging"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AppAllowDebugging {
            get {
                if ((curObj["AppAllowDebugging"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AppAllowDebugging"]));
            }
            set {
                curObj["AppAllowDebugging"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string AppFriendlyName {
            get {
                return ((string)(curObj["AppFriendlyName"]));
            }
            set {
                curObj["AppFriendlyName"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public System.Management.ManagementBaseObject[] ApplicationDependencies {
            get {
                return ((System.Management.ManagementBaseObject[])(curObj["ApplicationDependencies"]));
            }
            set {
                curObj["ApplicationDependencies"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string AppPoolId {
            get {
                return ((string)(curObj["AppPoolId"]));
            }
            set {
                curObj["AppPoolId"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string AppWamClsid {
            get {
                return ((string)(curObj["AppWamClsid"]));
            }
            set {
                curObj["AppWamClsid"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspAllowOutOfProcComponentsNull {
            get {
                if ((curObj["AspAllowOutOfProcComponents"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AspAllowOutOfProcComponents {
            get {
                if ((curObj["AspAllowOutOfProcComponents"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AspAllowOutOfProcComponents"]));
            }
            set {
                curObj["AspAllowOutOfProcComponents"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspAllowSessionStateNull {
            get {
                if ((curObj["AspAllowSessionState"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AspAllowSessionState {
            get {
                if ((curObj["AspAllowSessionState"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AspAllowSessionState"]));
            }
            set {
                curObj["AspAllowSessionState"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspAppServiceFlagsNull {
            get {
                if ((curObj["AspAppServiceFlags"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AspAppServiceFlags {
            get {
                if ((curObj["AspAppServiceFlags"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AspAppServiceFlags"]));
            }
            set {
                curObj["AspAppServiceFlags"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspBufferingLimitNull {
            get {
                if ((curObj["AspBufferingLimit"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AspBufferingLimit {
            get {
                if ((curObj["AspBufferingLimit"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AspBufferingLimit"]));
            }
            set {
                curObj["AspBufferingLimit"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspBufferingOnNull {
            get {
                if ((curObj["AspBufferingOn"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AspBufferingOn {
            get {
                if ((curObj["AspBufferingOn"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AspBufferingOn"]));
            }
            set {
                curObj["AspBufferingOn"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspCalcLineNumberNull {
            get {
                if ((curObj["AspCalcLineNumber"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AspCalcLineNumber {
            get {
                if ((curObj["AspCalcLineNumber"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AspCalcLineNumber"]));
            }
            set {
                curObj["AspCalcLineNumber"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspCodepageNull {
            get {
                if ((curObj["AspCodepage"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AspCodepage {
            get {
                if ((curObj["AspCodepage"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AspCodepage"]));
            }
            set {
                curObj["AspCodepage"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string AspDiskTemplateCacheDirectory {
            get {
                return ((string)(curObj["AspDiskTemplateCacheDirectory"]));
            }
            set {
                curObj["AspDiskTemplateCacheDirectory"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspEnableApplicationRestartNull {
            get {
                if ((curObj["AspEnableApplicationRestart"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AspEnableApplicationRestart {
            get {
                if ((curObj["AspEnableApplicationRestart"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AspEnableApplicationRestart"]));
            }
            set {
                curObj["AspEnableApplicationRestart"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspEnableAspHtmlFallbackNull {
            get {
                if ((curObj["AspEnableAspHtmlFallback"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AspEnableAspHtmlFallback {
            get {
                if ((curObj["AspEnableAspHtmlFallback"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AspEnableAspHtmlFallback"]));
            }
            set {
                curObj["AspEnableAspHtmlFallback"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspEnableChunkedEncodingNull {
            get {
                if ((curObj["AspEnableChunkedEncoding"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AspEnableChunkedEncoding {
            get {
                if ((curObj["AspEnableChunkedEncoding"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AspEnableChunkedEncoding"]));
            }
            set {
                curObj["AspEnableChunkedEncoding"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspEnableParentPathsNull {
            get {
                if ((curObj["AspEnableParentPaths"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AspEnableParentPaths {
            get {
                if ((curObj["AspEnableParentPaths"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AspEnableParentPaths"]));
            }
            set {
                curObj["AspEnableParentPaths"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspEnableSxsNull {
            get {
                if ((curObj["AspEnableSxs"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AspEnableSxs {
            get {
                if ((curObj["AspEnableSxs"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AspEnableSxs"]));
            }
            set {
                curObj["AspEnableSxs"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspEnableTrackerNull {
            get {
                if ((curObj["AspEnableTracker"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AspEnableTracker {
            get {
                if ((curObj["AspEnableTracker"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AspEnableTracker"]));
            }
            set {
                curObj["AspEnableTracker"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspEnableTypelibCacheNull {
            get {
                if ((curObj["AspEnableTypelibCache"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AspEnableTypelibCache {
            get {
                if ((curObj["AspEnableTypelibCache"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AspEnableTypelibCache"]));
            }
            set {
                curObj["AspEnableTypelibCache"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspErrorsToNTLogNull {
            get {
                if ((curObj["AspErrorsToNTLog"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AspErrorsToNTLog {
            get {
                if ((curObj["AspErrorsToNTLog"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AspErrorsToNTLog"]));
            }
            set {
                curObj["AspErrorsToNTLog"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspExceptionCatchEnableNull {
            get {
                if ((curObj["AspExceptionCatchEnable"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AspExceptionCatchEnable {
            get {
                if ((curObj["AspExceptionCatchEnable"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AspExceptionCatchEnable"]));
            }
            set {
                curObj["AspExceptionCatchEnable"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspExecuteInMTANull {
            get {
                if ((curObj["AspExecuteInMTA"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AspExecuteInMTA {
            get {
                if ((curObj["AspExecuteInMTA"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AspExecuteInMTA"]));
            }
            set {
                curObj["AspExecuteInMTA"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspKeepSessionIDSecureNull {
            get {
                if ((curObj["AspKeepSessionIDSecure"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AspKeepSessionIDSecure {
            get {
                if ((curObj["AspKeepSessionIDSecure"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AspKeepSessionIDSecure"]));
            }
            set {
                curObj["AspKeepSessionIDSecure"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspLCIDNull {
            get {
                if ((curObj["AspLCID"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AspLCID {
            get {
                if ((curObj["AspLCID"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AspLCID"]));
            }
            set {
                curObj["AspLCID"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspLogErrorRequestsNull {
            get {
                if ((curObj["AspLogErrorRequests"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AspLogErrorRequests {
            get {
                if ((curObj["AspLogErrorRequests"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AspLogErrorRequests"]));
            }
            set {
                curObj["AspLogErrorRequests"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspMaxDiskTemplateCacheFilesNull {
            get {
                if ((curObj["AspMaxDiskTemplateCacheFiles"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AspMaxDiskTemplateCacheFiles {
            get {
                if ((curObj["AspMaxDiskTemplateCacheFiles"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AspMaxDiskTemplateCacheFiles"]));
            }
            set {
                curObj["AspMaxDiskTemplateCacheFiles"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspMaxRequestEntityAllowedNull {
            get {
                if ((curObj["AspMaxRequestEntityAllowed"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AspMaxRequestEntityAllowed {
            get {
                if ((curObj["AspMaxRequestEntityAllowed"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AspMaxRequestEntityAllowed"]));
            }
            set {
                curObj["AspMaxRequestEntityAllowed"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string AspPartitionID {
            get {
                return ((string)(curObj["AspPartitionID"]));
            }
            set {
                curObj["AspPartitionID"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspProcessorThreadMaxNull {
            get {
                if ((curObj["AspProcessorThreadMax"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AspProcessorThreadMax {
            get {
                if ((curObj["AspProcessorThreadMax"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AspProcessorThreadMax"]));
            }
            set {
                curObj["AspProcessorThreadMax"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspQueueConnectionTestTimeNull {
            get {
                if ((curObj["AspQueueConnectionTestTime"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AspQueueConnectionTestTime {
            get {
                if ((curObj["AspQueueConnectionTestTime"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AspQueueConnectionTestTime"]));
            }
            set {
                curObj["AspQueueConnectionTestTime"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspQueueTimeoutNull {
            get {
                if ((curObj["AspQueueTimeout"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AspQueueTimeout {
            get {
                if ((curObj["AspQueueTimeout"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AspQueueTimeout"]));
            }
            set {
                curObj["AspQueueTimeout"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspRequestQueueMaxNull {
            get {
                if ((curObj["AspRequestQueueMax"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AspRequestQueueMax {
            get {
                if ((curObj["AspRequestQueueMax"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AspRequestQueueMax"]));
            }
            set {
                curObj["AspRequestQueueMax"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspRunOnEndAnonymouslyNull {
            get {
                if ((curObj["AspRunOnEndAnonymously"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AspRunOnEndAnonymously {
            get {
                if ((curObj["AspRunOnEndAnonymously"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AspRunOnEndAnonymously"]));
            }
            set {
                curObj["AspRunOnEndAnonymously"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspScriptEngineCacheMaxNull {
            get {
                if ((curObj["AspScriptEngineCacheMax"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AspScriptEngineCacheMax {
            get {
                if ((curObj["AspScriptEngineCacheMax"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AspScriptEngineCacheMax"]));
            }
            set {
                curObj["AspScriptEngineCacheMax"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string AspScriptErrorMessage {
            get {
                return ((string)(curObj["AspScriptErrorMessage"]));
            }
            set {
                curObj["AspScriptErrorMessage"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspScriptErrorSentToBrowserNull {
            get {
                if ((curObj["AspScriptErrorSentToBrowser"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AspScriptErrorSentToBrowser {
            get {
                if ((curObj["AspScriptErrorSentToBrowser"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AspScriptErrorSentToBrowser"]));
            }
            set {
                curObj["AspScriptErrorSentToBrowser"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspScriptFileCacheSizeNull {
            get {
                if ((curObj["AspScriptFileCacheSize"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AspScriptFileCacheSize {
            get {
                if ((curObj["AspScriptFileCacheSize"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AspScriptFileCacheSize"]));
            }
            set {
                curObj["AspScriptFileCacheSize"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string AspScriptLanguage {
            get {
                return ((string)(curObj["AspScriptLanguage"]));
            }
            set {
                curObj["AspScriptLanguage"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspScriptTimeoutNull {
            get {
                if ((curObj["AspScriptTimeout"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AspScriptTimeout {
            get {
                if ((curObj["AspScriptTimeout"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AspScriptTimeout"]));
            }
            set {
                curObj["AspScriptTimeout"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspSessionMaxNull {
            get {
                if ((curObj["AspSessionMax"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AspSessionMax {
            get {
                if ((curObj["AspSessionMax"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AspSessionMax"]));
            }
            set {
                curObj["AspSessionMax"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspSessionTimeoutNull {
            get {
                if ((curObj["AspSessionTimeout"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AspSessionTimeout {
            get {
                if ((curObj["AspSessionTimeout"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AspSessionTimeout"]));
            }
            set {
                curObj["AspSessionTimeout"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string AspSxsName {
            get {
                return ((string)(curObj["AspSxsName"]));
            }
            set {
                curObj["AspSxsName"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspTrackThreadingModelNull {
            get {
                if ((curObj["AspTrackThreadingModel"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AspTrackThreadingModel {
            get {
                if ((curObj["AspTrackThreadingModel"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AspTrackThreadingModel"]));
            }
            set {
                curObj["AspTrackThreadingModel"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAspUsePartitionNull {
            get {
                if ((curObj["AspUsePartition"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AspUsePartition {
            get {
                if ((curObj["AspUsePartition"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AspUsePartition"]));
            }
            set {
                curObj["AspUsePartition"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAuthAdvNotifyDisableNull {
            get {
                if ((curObj["AuthAdvNotifyDisable"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AuthAdvNotifyDisable {
            get {
                if ((curObj["AuthAdvNotifyDisable"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AuthAdvNotifyDisable"]));
            }
            set {
                curObj["AuthAdvNotifyDisable"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAuthAnonymousNull {
            get {
                if ((curObj["AuthAnonymous"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AuthAnonymous {
            get {
                if ((curObj["AuthAnonymous"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AuthAnonymous"]));
            }
            set {
                curObj["AuthAnonymous"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAuthBasicNull {
            get {
                if ((curObj["AuthBasic"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AuthBasic {
            get {
                if ((curObj["AuthBasic"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AuthBasic"]));
            }
            set {
                curObj["AuthBasic"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAuthChangeDisableNull {
            get {
                if ((curObj["AuthChangeDisable"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AuthChangeDisable {
            get {
                if ((curObj["AuthChangeDisable"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AuthChangeDisable"]));
            }
            set {
                curObj["AuthChangeDisable"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAuthChangeUnsecureNull {
            get {
                if ((curObj["AuthChangeUnsecure"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AuthChangeUnsecure {
            get {
                if ((curObj["AuthChangeUnsecure"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AuthChangeUnsecure"]));
            }
            set {
                curObj["AuthChangeUnsecure"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string AuthChangeURL {
            get {
                return ((string)(curObj["AuthChangeURL"]));
            }
            set {
                curObj["AuthChangeURL"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string AuthExpiredUnsecureURL {
            get {
                return ((string)(curObj["AuthExpiredUnsecureURL"]));
            }
            set {
                curObj["AuthExpiredUnsecureURL"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string AuthExpiredURL {
            get {
                return ((string)(curObj["AuthExpiredURL"]));
            }
            set {
                curObj["AuthExpiredURL"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAuthFlagsNull {
            get {
                if ((curObj["AuthFlags"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AuthFlags {
            get {
                if ((curObj["AuthFlags"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AuthFlags"]));
            }
            set {
                curObj["AuthFlags"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAuthMD5Null {
            get {
                if ((curObj["AuthMD5"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AuthMD5 {
            get {
                if ((curObj["AuthMD5"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AuthMD5"]));
            }
            set {
                curObj["AuthMD5"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string AuthNotifyPwdExpUnsecureURL {
            get {
                return ((string)(curObj["AuthNotifyPwdExpUnsecureURL"]));
            }
            set {
                curObj["AuthNotifyPwdExpUnsecureURL"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string AuthNotifyPwdExpURL {
            get {
                return ((string)(curObj["AuthNotifyPwdExpURL"]));
            }
            set {
                curObj["AuthNotifyPwdExpURL"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAuthNTLMNull {
            get {
                if ((curObj["AuthNTLM"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AuthNTLM {
            get {
                if ((curObj["AuthNTLM"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AuthNTLM"]));
            }
            set {
                curObj["AuthNTLM"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAuthPassportNull {
            get {
                if ((curObj["AuthPassport"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AuthPassport {
            get {
                if ((curObj["AuthPassport"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AuthPassport"]));
            }
            set {
                curObj["AuthPassport"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAuthPersistenceNull {
            get {
                if ((curObj["AuthPersistence"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AuthPersistence {
            get {
                if ((curObj["AuthPersistence"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AuthPersistence"]));
            }
            set {
                curObj["AuthPersistence"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAuthPersistSingleRequestNull {
            get {
                if ((curObj["AuthPersistSingleRequest"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AuthPersistSingleRequest {
            get {
                if ((curObj["AuthPersistSingleRequest"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AuthPersistSingleRequest"]));
            }
            set {
                curObj["AuthPersistSingleRequest"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAzEnableNull {
            get {
                if ((curObj["AzEnable"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool AzEnable {
            get {
                if ((curObj["AzEnable"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["AzEnable"]));
            }
            set {
                curObj["AzEnable"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsAzImpersonationLevelNull {
            get {
                if ((curObj["AzImpersonationLevel"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int AzImpersonationLevel {
            get {
                if ((curObj["AzImpersonationLevel"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["AzImpersonationLevel"]));
            }
            set {
                curObj["AzImpersonationLevel"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string AzScopeName {
            get {
                return ((string)(curObj["AzScopeName"]));
            }
            set {
                curObj["AzScopeName"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string AzStoreName {
            get {
                return ((string)(curObj["AzStoreName"]));
            }
            set {
                curObj["AzStoreName"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string CacheControlCustom {
            get {
                return ((string)(curObj["CacheControlCustom"]));
            }
            set {
                curObj["CacheControlCustom"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsCacheControlMaxAgeNull {
            get {
                if ((curObj["CacheControlMaxAge"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int CacheControlMaxAge {
            get {
                if ((curObj["CacheControlMaxAge"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["CacheControlMaxAge"]));
            }
            set {
                curObj["CacheControlMaxAge"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsCacheControlNoCacheNull {
            get {
                if ((curObj["CacheControlNoCache"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool CacheControlNoCache {
            get {
                if ((curObj["CacheControlNoCache"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["CacheControlNoCache"]));
            }
            set {
                curObj["CacheControlNoCache"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsCacheISAPINull {
            get {
                if ((curObj["CacheISAPI"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool CacheISAPI {
            get {
                if ((curObj["CacheISAPI"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["CacheISAPI"]));
            }
            set {
                curObj["CacheISAPI"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string Caption {
            get {
                return ((string)(curObj["Caption"]));
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsCentralBinaryLoggingEnabledNull {
            get {
                if ((curObj["CentralBinaryLoggingEnabled"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool CentralBinaryLoggingEnabled {
            get {
                if ((curObj["CentralBinaryLoggingEnabled"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["CentralBinaryLoggingEnabled"]));
            }
            set {
                curObj["CentralBinaryLoggingEnabled"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsCertCheckModeNull {
            get {
                if ((curObj["CertCheckMode"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int CertCheckMode {
            get {
                if ((curObj["CertCheckMode"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["CertCheckMode"]));
            }
            set {
                curObj["CertCheckMode"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsCGITimeoutNull {
            get {
                if ((curObj["CGITimeout"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int CGITimeout {
            get {
                if ((curObj["CGITimeout"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["CGITimeout"]));
            }
            set {
                curObj["CGITimeout"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsConnectionTimeoutNull {
            get {
                if ((curObj["ConnectionTimeout"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int ConnectionTimeout {
            get {
                if ((curObj["ConnectionTimeout"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["ConnectionTimeout"]));
            }
            set {
                curObj["ConnectionTimeout"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsContentIndexedNull {
            get {
                if ((curObj["ContentIndexed"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool ContentIndexed {
            get {
                if ((curObj["ContentIndexed"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["ContentIndexed"]));
            }
            set {
                curObj["ContentIndexed"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsCreateCGIWithNewConsoleNull {
            get {
                if ((curObj["CreateCGIWithNewConsole"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool CreateCGIWithNewConsole {
            get {
                if ((curObj["CreateCGIWithNewConsole"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["CreateCGIWithNewConsole"]));
            }
            set {
                curObj["CreateCGIWithNewConsole"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsCreateProcessAsUserNull {
            get {
                if ((curObj["CreateProcessAsUser"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool CreateProcessAsUser {
            get {
                if ((curObj["CreateProcessAsUser"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["CreateProcessAsUser"]));
            }
            set {
                curObj["CreateProcessAsUser"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string DefaultDoc {
            get {
                return ((string)(curObj["DefaultDoc"]));
            }
            set {
                curObj["DefaultDoc"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string DefaultDocFooter {
            get {
                return ((string)(curObj["DefaultDocFooter"]));
            }
            set {
                curObj["DefaultDocFooter"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string DefaultLogonDomain {
            get {
                return ((string)(curObj["DefaultLogonDomain"]));
            }
            set {
                curObj["DefaultLogonDomain"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsDemandStartThresholdNull {
            get {
                if ((curObj["DemandStartThreshold"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int DemandStartThreshold {
            get {
                if ((curObj["DemandStartThreshold"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["DemandStartThreshold"]));
            }
            set {
                curObj["DemandStartThreshold"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string Description {
            get {
                return ((string)(curObj["Description"]));
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsDirBrowseFlagsNull {
            get {
                if ((curObj["DirBrowseFlags"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int DirBrowseFlags {
            get {
                if ((curObj["DirBrowseFlags"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["DirBrowseFlags"]));
            }
            set {
                curObj["DirBrowseFlags"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsDirBrowseShowDateNull {
            get {
                if ((curObj["DirBrowseShowDate"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool DirBrowseShowDate {
            get {
                if ((curObj["DirBrowseShowDate"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["DirBrowseShowDate"]));
            }
            set {
                curObj["DirBrowseShowDate"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsDirBrowseShowExtensionNull {
            get {
                if ((curObj["DirBrowseShowExtension"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool DirBrowseShowExtension {
            get {
                if ((curObj["DirBrowseShowExtension"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["DirBrowseShowExtension"]));
            }
            set {
                curObj["DirBrowseShowExtension"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsDirBrowseShowLongDateNull {
            get {
                if ((curObj["DirBrowseShowLongDate"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool DirBrowseShowLongDate {
            get {
                if ((curObj["DirBrowseShowLongDate"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["DirBrowseShowLongDate"]));
            }
            set {
                curObj["DirBrowseShowLongDate"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsDirBrowseShowSizeNull {
            get {
                if ((curObj["DirBrowseShowSize"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool DirBrowseShowSize {
            get {
                if ((curObj["DirBrowseShowSize"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["DirBrowseShowSize"]));
            }
            set {
                curObj["DirBrowseShowSize"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsDirBrowseShowTimeNull {
            get {
                if ((curObj["DirBrowseShowTime"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool DirBrowseShowTime {
            get {
                if ((curObj["DirBrowseShowTime"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["DirBrowseShowTime"]));
            }
            set {
                curObj["DirBrowseShowTime"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsDirectoryLevelsToScanNull {
            get {
                if ((curObj["DirectoryLevelsToScan"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int DirectoryLevelsToScan {
            get {
                if ((curObj["DirectoryLevelsToScan"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["DirectoryLevelsToScan"]));
            }
            set {
                curObj["DirectoryLevelsToScan"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsDisableSocketPoolingNull {
            get {
                if ((curObj["DisableSocketPooling"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool DisableSocketPooling {
            get {
                if ((curObj["DisableSocketPooling"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["DisableSocketPooling"]));
            }
            set {
                curObj["DisableSocketPooling"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsDisableStaticFileCacheNull {
            get {
                if ((curObj["DisableStaticFileCache"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool DisableStaticFileCache {
            get {
                if ((curObj["DisableStaticFileCache"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["DisableStaticFileCache"]));
            }
            set {
                curObj["DisableStaticFileCache"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsDoDynamicCompressionNull {
            get {
                if ((curObj["DoDynamicCompression"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool DoDynamicCompression {
            get {
                if ((curObj["DoDynamicCompression"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["DoDynamicCompression"]));
            }
            set {
                curObj["DoDynamicCompression"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsDontLogNull {
            get {
                if ((curObj["DontLog"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool DontLog {
            get {
                if ((curObj["DontLog"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["DontLog"]));
            }
            set {
                curObj["DontLog"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsDoStaticCompressionNull {
            get {
                if ((curObj["DoStaticCompression"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool DoStaticCompression {
            get {
                if ((curObj["DoStaticCompression"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["DoStaticCompression"]));
            }
            set {
                curObj["DoStaticCompression"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsDownlevelAdminInstanceNull {
            get {
                if ((curObj["DownlevelAdminInstance"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int DownlevelAdminInstance {
            get {
                if ((curObj["DownlevelAdminInstance"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["DownlevelAdminInstance"]));
            }
            set {
                curObj["DownlevelAdminInstance"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsEnableDefaultDocNull {
            get {
                if ((curObj["EnableDefaultDoc"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool EnableDefaultDoc {
            get {
                if ((curObj["EnableDefaultDoc"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["EnableDefaultDoc"]));
            }
            set {
                curObj["EnableDefaultDoc"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsEnableDirBrowsingNull {
            get {
                if ((curObj["EnableDirBrowsing"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool EnableDirBrowsing {
            get {
                if ((curObj["EnableDirBrowsing"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["EnableDirBrowsing"]));
            }
            set {
                curObj["EnableDirBrowsing"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsEnableDocFooterNull {
            get {
                if ((curObj["EnableDocFooter"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool EnableDocFooter {
            get {
                if ((curObj["EnableDocFooter"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["EnableDocFooter"]));
            }
            set {
                curObj["EnableDocFooter"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsEnableReverseDnsNull {
            get {
                if ((curObj["EnableReverseDns"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool EnableReverseDns {
            get {
                if ((curObj["EnableReverseDns"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["EnableReverseDns"]));
            }
            set {
                curObj["EnableReverseDns"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsHeaderWaitTimeoutNull {
            get {
                if ((curObj["HeaderWaitTimeout"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int HeaderWaitTimeout {
            get {
                if ((curObj["HeaderWaitTimeout"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["HeaderWaitTimeout"]));
            }
            set {
                curObj["HeaderWaitTimeout"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public System.Management.ManagementBaseObject[] HttpCustomHeaders {
            get {
                return ((System.Management.ManagementBaseObject[])(curObj["HttpCustomHeaders"]));
            }
            set {
                curObj["HttpCustomHeaders"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public System.Management.ManagementBaseObject[] HttpErrors {
            get {
                return ((System.Management.ManagementBaseObject[])(curObj["HttpErrors"]));
            }
            set {
                curObj["HttpErrors"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string HttpExpires {
            get {
                return ((string)(curObj["HttpExpires"]));
            }
            set {
                curObj["HttpExpires"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string[] HttpPics {
            get {
                return ((string[])(curObj["HttpPics"]));
            }
            set {
                curObj["HttpPics"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsIIs5IsolationModeEnabledNull {
            get {
                if ((curObj["IIs5IsolationModeEnabled"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool IIs5IsolationModeEnabled {
            get {
                if ((curObj["IIs5IsolationModeEnabled"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["IIs5IsolationModeEnabled"]));
            }
            set {
                curObj["IIs5IsolationModeEnabled"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string[] InProcessIsapiApps {
            get {
                return ((string[])(curObj["InProcessIsapiApps"]));
            }
            set {
                curObj["InProcessIsapiApps"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileBytesRecvNull {
            get {
                if ((curObj["LogExtFileBytesRecv"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileBytesRecv {
            get {
                if ((curObj["LogExtFileBytesRecv"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileBytesRecv"]));
            }
            set {
                curObj["LogExtFileBytesRecv"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileBytesSentNull {
            get {
                if ((curObj["LogExtFileBytesSent"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileBytesSent {
            get {
                if ((curObj["LogExtFileBytesSent"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileBytesSent"]));
            }
            set {
                curObj["LogExtFileBytesSent"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileClientIpNull {
            get {
                if ((curObj["LogExtFileClientIp"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileClientIp {
            get {
                if ((curObj["LogExtFileClientIp"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileClientIp"]));
            }
            set {
                curObj["LogExtFileClientIp"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileComputerNameNull {
            get {
                if ((curObj["LogExtFileComputerName"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileComputerName {
            get {
                if ((curObj["LogExtFileComputerName"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileComputerName"]));
            }
            set {
                curObj["LogExtFileComputerName"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileCookieNull {
            get {
                if ((curObj["LogExtFileCookie"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileCookie {
            get {
                if ((curObj["LogExtFileCookie"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileCookie"]));
            }
            set {
                curObj["LogExtFileCookie"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileDateNull {
            get {
                if ((curObj["LogExtFileDate"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileDate {
            get {
                if ((curObj["LogExtFileDate"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileDate"]));
            }
            set {
                curObj["LogExtFileDate"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileFlagsNull {
            get {
                if ((curObj["LogExtFileFlags"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int LogExtFileFlags {
            get {
                if ((curObj["LogExtFileFlags"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["LogExtFileFlags"]));
            }
            set {
                curObj["LogExtFileFlags"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileHostNull {
            get {
                if ((curObj["LogExtFileHost"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileHost {
            get {
                if ((curObj["LogExtFileHost"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileHost"]));
            }
            set {
                curObj["LogExtFileHost"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileHttpStatusNull {
            get {
                if ((curObj["LogExtFileHttpStatus"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileHttpStatus {
            get {
                if ((curObj["LogExtFileHttpStatus"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileHttpStatus"]));
            }
            set {
                curObj["LogExtFileHttpStatus"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileHttpSubStatusNull {
            get {
                if ((curObj["LogExtFileHttpSubStatus"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileHttpSubStatus {
            get {
                if ((curObj["LogExtFileHttpSubStatus"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileHttpSubStatus"]));
            }
            set {
                curObj["LogExtFileHttpSubStatus"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileMethodNull {
            get {
                if ((curObj["LogExtFileMethod"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileMethod {
            get {
                if ((curObj["LogExtFileMethod"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileMethod"]));
            }
            set {
                curObj["LogExtFileMethod"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileProtocolVersionNull {
            get {
                if ((curObj["LogExtFileProtocolVersion"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileProtocolVersion {
            get {
                if ((curObj["LogExtFileProtocolVersion"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileProtocolVersion"]));
            }
            set {
                curObj["LogExtFileProtocolVersion"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileRefererNull {
            get {
                if ((curObj["LogExtFileReferer"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileReferer {
            get {
                if ((curObj["LogExtFileReferer"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileReferer"]));
            }
            set {
                curObj["LogExtFileReferer"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileServerIpNull {
            get {
                if ((curObj["LogExtFileServerIp"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileServerIp {
            get {
                if ((curObj["LogExtFileServerIp"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileServerIp"]));
            }
            set {
                curObj["LogExtFileServerIp"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileServerPortNull {
            get {
                if ((curObj["LogExtFileServerPort"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileServerPort {
            get {
                if ((curObj["LogExtFileServerPort"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileServerPort"]));
            }
            set {
                curObj["LogExtFileServerPort"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileSiteNameNull {
            get {
                if ((curObj["LogExtFileSiteName"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileSiteName {
            get {
                if ((curObj["LogExtFileSiteName"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileSiteName"]));
            }
            set {
                curObj["LogExtFileSiteName"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileTimeNull {
            get {
                if ((curObj["LogExtFileTime"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileTime {
            get {
                if ((curObj["LogExtFileTime"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileTime"]));
            }
            set {
                curObj["LogExtFileTime"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileTimeTakenNull {
            get {
                if ((curObj["LogExtFileTimeTaken"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileTimeTaken {
            get {
                if ((curObj["LogExtFileTimeTaken"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileTimeTaken"]));
            }
            set {
                curObj["LogExtFileTimeTaken"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileUriQueryNull {
            get {
                if ((curObj["LogExtFileUriQuery"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileUriQuery {
            get {
                if ((curObj["LogExtFileUriQuery"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileUriQuery"]));
            }
            set {
                curObj["LogExtFileUriQuery"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileUriStemNull {
            get {
                if ((curObj["LogExtFileUriStem"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileUriStem {
            get {
                if ((curObj["LogExtFileUriStem"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileUriStem"]));
            }
            set {
                curObj["LogExtFileUriStem"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileUserAgentNull {
            get {
                if ((curObj["LogExtFileUserAgent"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileUserAgent {
            get {
                if ((curObj["LogExtFileUserAgent"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileUserAgent"]));
            }
            set {
                curObj["LogExtFileUserAgent"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileUserNameNull {
            get {
                if ((curObj["LogExtFileUserName"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileUserName {
            get {
                if ((curObj["LogExtFileUserName"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileUserName"]));
            }
            set {
                curObj["LogExtFileUserName"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogExtFileWin32StatusNull {
            get {
                if ((curObj["LogExtFileWin32Status"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogExtFileWin32Status {
            get {
                if ((curObj["LogExtFileWin32Status"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogExtFileWin32Status"]));
            }
            set {
                curObj["LogExtFileWin32Status"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string LogFileDirectory {
            get {
                return ((string)(curObj["LogFileDirectory"]));
            }
            set {
                curObj["LogFileDirectory"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogFileLocaltimeRolloverNull {
            get {
                if ((curObj["LogFileLocaltimeRollover"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogFileLocaltimeRollover {
            get {
                if ((curObj["LogFileLocaltimeRollover"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogFileLocaltimeRollover"]));
            }
            set {
                curObj["LogFileLocaltimeRollover"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogFilePeriodNull {
            get {
                if ((curObj["LogFilePeriod"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int LogFilePeriod {
            get {
                if ((curObj["LogFilePeriod"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["LogFilePeriod"]));
            }
            set {
                curObj["LogFilePeriod"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogFileTruncateSizeNull {
            get {
                if ((curObj["LogFileTruncateSize"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int LogFileTruncateSize {
            get {
                if ((curObj["LogFileTruncateSize"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["LogFileTruncateSize"]));
            }
            set {
                curObj["LogFileTruncateSize"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogInUTF8Null {
            get {
                if ((curObj["LogInUTF8"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool LogInUTF8 {
            get {
                if ((curObj["LogInUTF8"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["LogInUTF8"]));
            }
            set {
                curObj["LogInUTF8"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string LogModuleList {
            get {
                return ((string)(curObj["LogModuleList"]));
            }
            set {
                curObj["LogModuleList"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string LogOdbcDataSource {
            get {
                return ((string)(curObj["LogOdbcDataSource"]));
            }
            set {
                curObj["LogOdbcDataSource"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string LogOdbcPassword {
            get {
                return ((string)(curObj["LogOdbcPassword"]));
            }
            set {
                curObj["LogOdbcPassword"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string LogOdbcTableName {
            get {
                return ((string)(curObj["LogOdbcTableName"]));
            }
            set {
                curObj["LogOdbcTableName"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string LogOdbcUserName {
            get {
                return ((string)(curObj["LogOdbcUserName"]));
            }
            set {
                curObj["LogOdbcUserName"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogonMethodNull {
            get {
                if ((curObj["LogonMethod"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int LogonMethod {
            get {
                if ((curObj["LogonMethod"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["LogonMethod"]));
            }
            set {
                curObj["LogonMethod"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string LogPluginClsid {
            get {
                return ((string)(curObj["LogPluginClsid"]));
            }
            set {
                curObj["LogPluginClsid"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsLogTypeNull {
            get {
                if ((curObj["LogType"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int LogType {
            get {
                if ((curObj["LogType"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["LogType"]));
            }
            set {
                curObj["LogType"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsMaxBandwidthNull {
            get {
                if ((curObj["MaxBandwidth"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int MaxBandwidth {
            get {
                if ((curObj["MaxBandwidth"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["MaxBandwidth"]));
            }
            set {
                curObj["MaxBandwidth"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsMaxConnectionsNull {
            get {
                if ((curObj["MaxConnections"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int MaxConnections {
            get {
                if ((curObj["MaxConnections"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["MaxConnections"]));
            }
            set {
                curObj["MaxConnections"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsMaxEndpointConnectionsNull {
            get {
                if ((curObj["MaxEndpointConnections"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int MaxEndpointConnections {
            get {
                if ((curObj["MaxEndpointConnections"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["MaxEndpointConnections"]));
            }
            set {
                curObj["MaxEndpointConnections"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsMaxGlobalBandwidthNull {
            get {
                if ((curObj["MaxGlobalBandwidth"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int MaxGlobalBandwidth {
            get {
                if ((curObj["MaxGlobalBandwidth"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["MaxGlobalBandwidth"]));
            }
            set {
                curObj["MaxGlobalBandwidth"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsMaxRequestEntityAllowedNull {
            get {
                if ((curObj["MaxRequestEntityAllowed"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int MaxRequestEntityAllowed {
            get {
                if ((curObj["MaxRequestEntityAllowed"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["MaxRequestEntityAllowed"]));
            }
            set {
                curObj["MaxRequestEntityAllowed"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public System.Management.ManagementBaseObject[] MimeMap {
            get {
                return ((System.Management.ManagementBaseObject[])(curObj["MimeMap"]));
            }
            set {
                curObj["MimeMap"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsMinFileBytesPerSecNull {
            get {
                if ((curObj["MinFileBytesPerSec"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int MinFileBytesPerSec {
            get {
                if ((curObj["MinFileBytesPerSec"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["MinFileBytesPerSec"]));
            }
            set {
                curObj["MinFileBytesPerSec"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string Name {
            get {
                return ((string)(curObj["Name"]));
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string NTAuthenticationProviders {
            get {
                return ((string)(curObj["NTAuthenticationProviders"]));
            }
            set {
                curObj["NTAuthenticationProviders"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsPassportRequireADMappingNull {
            get {
                if ((curObj["PassportRequireADMapping"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int PassportRequireADMapping {
            get {
                if ((curObj["PassportRequireADMapping"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["PassportRequireADMapping"]));
            }
            set {
                curObj["PassportRequireADMapping"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsPasswordCacheTTLNull {
            get {
                if ((curObj["PasswordCacheTTL"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int PasswordCacheTTL {
            get {
                if ((curObj["PasswordCacheTTL"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["PasswordCacheTTL"]));
            }
            set {
                curObj["PasswordCacheTTL"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsPasswordChangeFlagsNull {
            get {
                if ((curObj["PasswordChangeFlags"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int PasswordChangeFlags {
            get {
                if ((curObj["PasswordChangeFlags"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["PasswordChangeFlags"]));
            }
            set {
                curObj["PasswordChangeFlags"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsPasswordExpirePrenotifyDaysNull {
            get {
                if ((curObj["PasswordExpirePrenotifyDays"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int PasswordExpirePrenotifyDays {
            get {
                if ((curObj["PasswordExpirePrenotifyDays"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["PasswordExpirePrenotifyDays"]));
            }
            set {
                curObj["PasswordExpirePrenotifyDays"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsPoolIdcTimeoutNull {
            get {
                if ((curObj["PoolIdcTimeout"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int PoolIdcTimeout {
            get {
                if ((curObj["PoolIdcTimeout"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["PoolIdcTimeout"]));
            }
            set {
                curObj["PoolIdcTimeout"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsProcessNTCRIfLoggedOnNull {
            get {
                if ((curObj["ProcessNTCRIfLoggedOn"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool ProcessNTCRIfLoggedOn {
            get {
                if ((curObj["ProcessNTCRIfLoggedOn"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["ProcessNTCRIfLoggedOn"]));
            }
            set {
                curObj["ProcessNTCRIfLoggedOn"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsRapidFailProtectionIntervalNull {
            get {
                if ((curObj["RapidFailProtectionInterval"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int RapidFailProtectionInterval {
            get {
                if ((curObj["RapidFailProtectionInterval"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["RapidFailProtectionInterval"]));
            }
            set {
                curObj["RapidFailProtectionInterval"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsRapidFailProtectionMaxCrashesNull {
            get {
                if ((curObj["RapidFailProtectionMaxCrashes"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int RapidFailProtectionMaxCrashes {
            get {
                if ((curObj["RapidFailProtectionMaxCrashes"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["RapidFailProtectionMaxCrashes"]));
            }
            set {
                curObj["RapidFailProtectionMaxCrashes"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string Realm {
            get {
                return ((string)(curObj["Realm"]));
            }
            set {
                curObj["Realm"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string[] RedirectHeaders {
            get {
                return ((string[])(curObj["RedirectHeaders"]));
            }
            set {
                curObj["RedirectHeaders"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsRevocationFreshnessTimeNull {
            get {
                if ((curObj["RevocationFreshnessTime"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int RevocationFreshnessTime {
            get {
                if ((curObj["RevocationFreshnessTime"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["RevocationFreshnessTime"]));
            }
            set {
                curObj["RevocationFreshnessTime"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsRevocationURLRetrievalTimeoutNull {
            get {
                if ((curObj["RevocationURLRetrievalTimeout"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int RevocationURLRetrievalTimeout {
            get {
                if ((curObj["RevocationURLRetrievalTimeout"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["RevocationURLRetrievalTimeout"]));
            }
            set {
                curObj["RevocationURLRetrievalTimeout"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public System.Management.ManagementBaseObject[] ScriptMaps {
            get {
                return ((System.Management.ManagementBaseObject[])(curObj["ScriptMaps"]));
            }
            set {
                curObj["ScriptMaps"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsServerAutoStartNull {
            get {
                if ((curObj["ServerAutoStart"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool ServerAutoStart {
            get {
                if ((curObj["ServerAutoStart"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["ServerAutoStart"]));
            }
            set {
                curObj["ServerAutoStart"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public System.Management.ManagementBaseObject[] ServerBindings {
            get {
                return ((System.Management.ManagementBaseObject[])(curObj["ServerBindings"]));
            }
            set {
                curObj["ServerBindings"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string ServerComment {
            get {
                return ((string)(curObj["ServerComment"]));
            }
            set {
                curObj["ServerComment"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsServerListenBacklogNull {
            get {
                if ((curObj["ServerListenBacklog"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int ServerListenBacklog {
            get {
                if ((curObj["ServerListenBacklog"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["ServerListenBacklog"]));
            }
            set {
                curObj["ServerListenBacklog"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsServerListenTimeoutNull {
            get {
                if ((curObj["ServerListenTimeout"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int ServerListenTimeout {
            get {
                if ((curObj["ServerListenTimeout"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["ServerListenTimeout"]));
            }
            set {
                curObj["ServerListenTimeout"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsServerSizeNull {
            get {
                if ((curObj["ServerSize"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int ServerSize {
            get {
                if ((curObj["ServerSize"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["ServerSize"]));
            }
            set {
                curObj["ServerSize"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string SettingID {
            get {
                return ((string)(curObj["SettingID"]));
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsShutdownTimeLimitNull {
            get {
                if ((curObj["ShutdownTimeLimit"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int ShutdownTimeLimit {
            get {
                if ((curObj["ShutdownTimeLimit"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["ShutdownTimeLimit"]));
            }
            set {
                curObj["ShutdownTimeLimit"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsSSIExecDisableNull {
            get {
                if ((curObj["SSIExecDisable"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool SSIExecDisable {
            get {
                if ((curObj["SSIExecDisable"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["SSIExecDisable"]));
            }
            set {
                curObj["SSIExecDisable"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsSSLAlwaysNegoClientCertNull {
            get {
                if ((curObj["SSLAlwaysNegoClientCert"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool SSLAlwaysNegoClientCert {
            get {
                if ((curObj["SSLAlwaysNegoClientCert"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["SSLAlwaysNegoClientCert"]));
            }
            set {
                curObj["SSLAlwaysNegoClientCert"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string SSLStoreName {
            get {
                return ((string)(curObj["SSLStoreName"]));
            }
            set {
                curObj["SSLStoreName"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsSslUseDsMapperNull {
            get {
                if ((curObj["SslUseDsMapper"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool SslUseDsMapper {
            get {
                if ((curObj["SslUseDsMapper"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["SslUseDsMapper"]));
            }
            set {
                curObj["SslUseDsMapper"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsUploadReadAheadSizeNull {
            get {
                if ((curObj["UploadReadAheadSize"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int UploadReadAheadSize {
            get {
                if ((curObj["UploadReadAheadSize"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["UploadReadAheadSize"]));
            }
            set {
                curObj["UploadReadAheadSize"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsUseDigestSSPNull {
            get {
                if ((curObj["UseDigestSSP"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public bool UseDigestSSP {
            get {
                if ((curObj["UseDigestSSP"] == null)) {
                    return System.Convert.ToBoolean(0);
                }
                return ((bool)(curObj["UseDigestSSP"]));
            }
            set {
                curObj["UseDigestSSP"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string WAMUserName {
            get {
                return ((string)(curObj["WAMUserName"]));
            }
            set {
                curObj["WAMUserName"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public string WAMUserPass {
            get {
                return ((string)(curObj["WAMUserPass"]));
            }
            set {
                curObj["WAMUserPass"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(false)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public bool IsWebDAVMaxAttributesPerElementNull {
            get {
                if ((curObj["WebDAVMaxAttributesPerElement"] == null)) {
                    return true;
                }
                else {
                    return false;
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [TypeConverter(typeof(WMIValueTypeConverter))]
        public int WebDAVMaxAttributesPerElement {
            get {
                if ((curObj["WebDAVMaxAttributesPerElement"] == null)) {
                    return System.Convert.ToInt32(0);
                }
                return ((int)(curObj["WebDAVMaxAttributesPerElement"]));
            }
            set {
                curObj["WebDAVMaxAttributesPerElement"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        [Browsable(true)]
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public System.Management.ManagementBaseObject[] WebSvcExtRestrictionList {
            get {
                return ((System.Management.ManagementBaseObject[])(curObj["WebSvcExtRestrictionList"]));
            }
            set {
                curObj["WebSvcExtRestrictionList"] = value;
                if (((isEmbedded == false) 
                            && (AutoCommitProp == true))) {
                    PrivateLateBoundObject.Put();
                }
            }
        }
        
        private bool CheckIfProperClass(System.Management.ManagementScope mgmtScope, System.Management.ManagementPath path, System.Management.ObjectGetOptions OptionsParam) {
            if (((path != null) 
                        && (System.String.Compare(path.ClassName, ManagementClassName, true, CultureInfo.InvariantCulture) == 0))) {
                return true;
            }
            else {
                return CheckIfProperClass(new System.Management.ManagementObject(mgmtScope, path, OptionsParam));
            }
        }
        
        private bool CheckIfProperClass(System.Management.ManagementBaseObject theObj) {
            if (((theObj != null) 
                        && (System.String.Compare(((string)(theObj["__CLASS"])), ManagementClassName, true, CultureInfo.InvariantCulture) == 0))) {
                return true;
            }
            else {
                System.Array parentClasses = ((System.Array)(theObj["__DERIVATION"]));
                if ((parentClasses != null)) {
                    Int32 count = 0;
                    for (count = 0; (count < parentClasses.Length); count = (count + 1)) {
                        if ((System.String.Compare(((string)(parentClasses.GetValue(count))), ManagementClassName, true, CultureInfo.InvariantCulture) == 0)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        
        private bool ShouldSerializeAccessExecute() {
            if ((IsAccessExecuteNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessExecute() {
            curObj["AccessExecute"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessFlags() {
            if ((IsAccessFlagsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessFlags() {
            curObj["AccessFlags"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessNoPhysicalDir() {
            if ((IsAccessNoPhysicalDirNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessNoPhysicalDir() {
            curObj["AccessNoPhysicalDir"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessNoRemoteExecute() {
            if ((IsAccessNoRemoteExecuteNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessNoRemoteExecute() {
            curObj["AccessNoRemoteExecute"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessNoRemoteRead() {
            if ((IsAccessNoRemoteReadNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessNoRemoteRead() {
            curObj["AccessNoRemoteRead"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessNoRemoteScript() {
            if ((IsAccessNoRemoteScriptNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessNoRemoteScript() {
            curObj["AccessNoRemoteScript"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessNoRemoteWrite() {
            if ((IsAccessNoRemoteWriteNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessNoRemoteWrite() {
            curObj["AccessNoRemoteWrite"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessRead() {
            if ((IsAccessReadNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessRead() {
            curObj["AccessRead"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessScript() {
            if ((IsAccessScriptNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessScript() {
            curObj["AccessScript"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessSource() {
            if ((IsAccessSourceNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessSource() {
            curObj["AccessSource"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessSSL() {
            if ((IsAccessSSLNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessSSL() {
            curObj["AccessSSL"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessSSL128() {
            if ((IsAccessSSL128Null == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessSSL128() {
            curObj["AccessSSL128"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessSSLFlags() {
            if ((IsAccessSSLFlagsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessSSLFlags() {
            curObj["AccessSSLFlags"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessSSLMapCert() {
            if ((IsAccessSSLMapCertNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessSSLMapCert() {
            curObj["AccessSSLMapCert"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessSSLNegotiateCert() {
            if ((IsAccessSSLNegotiateCertNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessSSLNegotiateCert() {
            curObj["AccessSSLNegotiateCert"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessSSLRequireCert() {
            if ((IsAccessSSLRequireCertNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessSSLRequireCert() {
            curObj["AccessSSLRequireCert"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAccessWrite() {
            if ((IsAccessWriteNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAccessWrite() {
            curObj["AccessWrite"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAdminACLBin() {
            curObj["AdminACLBin"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAdminServer() {
            curObj["AdminServer"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAllowKeepAlive() {
            if ((IsAllowKeepAliveNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAllowKeepAlive() {
            curObj["AllowKeepAlive"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAllowPathInfoForScriptMappings() {
            if ((IsAllowPathInfoForScriptMappingsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAllowPathInfoForScriptMappings() {
            curObj["AllowPathInfoForScriptMappings"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAnonymousPasswordSync() {
            if ((IsAnonymousPasswordSyncNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAnonymousPasswordSync() {
            curObj["AnonymousPasswordSync"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAnonymousUserName() {
            curObj["AnonymousUserName"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAnonymousUserPass() {
            curObj["AnonymousUserPass"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAppAllowClientDebug() {
            if ((IsAppAllowClientDebugNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAppAllowClientDebug() {
            curObj["AppAllowClientDebug"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAppAllowDebugging() {
            if ((IsAppAllowDebuggingNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAppAllowDebugging() {
            curObj["AppAllowDebugging"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAppFriendlyName() {
            curObj["AppFriendlyName"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetApplicationDependencies() {
            curObj["ApplicationDependencies"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAppPoolId() {
            curObj["AppPoolId"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAppWamClsid() {
            curObj["AppWamClsid"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspAllowOutOfProcComponents() {
            if ((IsAspAllowOutOfProcComponentsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspAllowOutOfProcComponents() {
            curObj["AspAllowOutOfProcComponents"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspAllowSessionState() {
            if ((IsAspAllowSessionStateNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspAllowSessionState() {
            curObj["AspAllowSessionState"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspAppServiceFlags() {
            if ((IsAspAppServiceFlagsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspAppServiceFlags() {
            curObj["AspAppServiceFlags"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspBufferingLimit() {
            if ((IsAspBufferingLimitNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspBufferingLimit() {
            curObj["AspBufferingLimit"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspBufferingOn() {
            if ((IsAspBufferingOnNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspBufferingOn() {
            curObj["AspBufferingOn"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspCalcLineNumber() {
            if ((IsAspCalcLineNumberNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspCalcLineNumber() {
            curObj["AspCalcLineNumber"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspCodepage() {
            if ((IsAspCodepageNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspCodepage() {
            curObj["AspCodepage"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAspDiskTemplateCacheDirectory() {
            curObj["AspDiskTemplateCacheDirectory"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspEnableApplicationRestart() {
            if ((IsAspEnableApplicationRestartNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspEnableApplicationRestart() {
            curObj["AspEnableApplicationRestart"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspEnableAspHtmlFallback() {
            if ((IsAspEnableAspHtmlFallbackNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspEnableAspHtmlFallback() {
            curObj["AspEnableAspHtmlFallback"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspEnableChunkedEncoding() {
            if ((IsAspEnableChunkedEncodingNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspEnableChunkedEncoding() {
            curObj["AspEnableChunkedEncoding"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspEnableParentPaths() {
            if ((IsAspEnableParentPathsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspEnableParentPaths() {
            curObj["AspEnableParentPaths"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspEnableSxs() {
            if ((IsAspEnableSxsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspEnableSxs() {
            curObj["AspEnableSxs"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspEnableTracker() {
            if ((IsAspEnableTrackerNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspEnableTracker() {
            curObj["AspEnableTracker"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspEnableTypelibCache() {
            if ((IsAspEnableTypelibCacheNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspEnableTypelibCache() {
            curObj["AspEnableTypelibCache"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspErrorsToNTLog() {
            if ((IsAspErrorsToNTLogNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspErrorsToNTLog() {
            curObj["AspErrorsToNTLog"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspExceptionCatchEnable() {
            if ((IsAspExceptionCatchEnableNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspExceptionCatchEnable() {
            curObj["AspExceptionCatchEnable"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspExecuteInMTA() {
            if ((IsAspExecuteInMTANull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspExecuteInMTA() {
            curObj["AspExecuteInMTA"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspKeepSessionIDSecure() {
            if ((IsAspKeepSessionIDSecureNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspKeepSessionIDSecure() {
            curObj["AspKeepSessionIDSecure"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspLCID() {
            if ((IsAspLCIDNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspLCID() {
            curObj["AspLCID"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspLogErrorRequests() {
            if ((IsAspLogErrorRequestsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspLogErrorRequests() {
            curObj["AspLogErrorRequests"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspMaxDiskTemplateCacheFiles() {
            if ((IsAspMaxDiskTemplateCacheFilesNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspMaxDiskTemplateCacheFiles() {
            curObj["AspMaxDiskTemplateCacheFiles"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspMaxRequestEntityAllowed() {
            if ((IsAspMaxRequestEntityAllowedNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspMaxRequestEntityAllowed() {
            curObj["AspMaxRequestEntityAllowed"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAspPartitionID() {
            curObj["AspPartitionID"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspProcessorThreadMax() {
            if ((IsAspProcessorThreadMaxNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspProcessorThreadMax() {
            curObj["AspProcessorThreadMax"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspQueueConnectionTestTime() {
            if ((IsAspQueueConnectionTestTimeNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspQueueConnectionTestTime() {
            curObj["AspQueueConnectionTestTime"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspQueueTimeout() {
            if ((IsAspQueueTimeoutNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspQueueTimeout() {
            curObj["AspQueueTimeout"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspRequestQueueMax() {
            if ((IsAspRequestQueueMaxNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspRequestQueueMax() {
            curObj["AspRequestQueueMax"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspRunOnEndAnonymously() {
            if ((IsAspRunOnEndAnonymouslyNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspRunOnEndAnonymously() {
            curObj["AspRunOnEndAnonymously"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspScriptEngineCacheMax() {
            if ((IsAspScriptEngineCacheMaxNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspScriptEngineCacheMax() {
            curObj["AspScriptEngineCacheMax"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAspScriptErrorMessage() {
            curObj["AspScriptErrorMessage"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspScriptErrorSentToBrowser() {
            if ((IsAspScriptErrorSentToBrowserNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspScriptErrorSentToBrowser() {
            curObj["AspScriptErrorSentToBrowser"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspScriptFileCacheSize() {
            if ((IsAspScriptFileCacheSizeNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspScriptFileCacheSize() {
            curObj["AspScriptFileCacheSize"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAspScriptLanguage() {
            curObj["AspScriptLanguage"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspScriptTimeout() {
            if ((IsAspScriptTimeoutNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspScriptTimeout() {
            curObj["AspScriptTimeout"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspSessionMax() {
            if ((IsAspSessionMaxNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspSessionMax() {
            curObj["AspSessionMax"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspSessionTimeout() {
            if ((IsAspSessionTimeoutNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspSessionTimeout() {
            curObj["AspSessionTimeout"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAspSxsName() {
            curObj["AspSxsName"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspTrackThreadingModel() {
            if ((IsAspTrackThreadingModelNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspTrackThreadingModel() {
            curObj["AspTrackThreadingModel"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAspUsePartition() {
            if ((IsAspUsePartitionNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAspUsePartition() {
            curObj["AspUsePartition"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAuthAdvNotifyDisable() {
            if ((IsAuthAdvNotifyDisableNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAuthAdvNotifyDisable() {
            curObj["AuthAdvNotifyDisable"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAuthAnonymous() {
            if ((IsAuthAnonymousNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAuthAnonymous() {
            curObj["AuthAnonymous"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAuthBasic() {
            if ((IsAuthBasicNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAuthBasic() {
            curObj["AuthBasic"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAuthChangeDisable() {
            if ((IsAuthChangeDisableNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAuthChangeDisable() {
            curObj["AuthChangeDisable"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAuthChangeUnsecure() {
            if ((IsAuthChangeUnsecureNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAuthChangeUnsecure() {
            curObj["AuthChangeUnsecure"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAuthChangeURL() {
            curObj["AuthChangeURL"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAuthExpiredUnsecureURL() {
            curObj["AuthExpiredUnsecureURL"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAuthExpiredURL() {
            curObj["AuthExpiredURL"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAuthFlags() {
            if ((IsAuthFlagsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAuthFlags() {
            curObj["AuthFlags"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAuthMD5() {
            if ((IsAuthMD5Null == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAuthMD5() {
            curObj["AuthMD5"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAuthNotifyPwdExpUnsecureURL() {
            curObj["AuthNotifyPwdExpUnsecureURL"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAuthNotifyPwdExpURL() {
            curObj["AuthNotifyPwdExpURL"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAuthNTLM() {
            if ((IsAuthNTLMNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAuthNTLM() {
            curObj["AuthNTLM"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAuthPassport() {
            if ((IsAuthPassportNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAuthPassport() {
            curObj["AuthPassport"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAuthPersistence() {
            if ((IsAuthPersistenceNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAuthPersistence() {
            curObj["AuthPersistence"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAuthPersistSingleRequest() {
            if ((IsAuthPersistSingleRequestNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAuthPersistSingleRequest() {
            curObj["AuthPersistSingleRequest"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAzEnable() {
            if ((IsAzEnableNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAzEnable() {
            curObj["AzEnable"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeAzImpersonationLevel() {
            if ((IsAzImpersonationLevelNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetAzImpersonationLevel() {
            curObj["AzImpersonationLevel"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAzScopeName() {
            curObj["AzScopeName"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetAzStoreName() {
            curObj["AzStoreName"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetCacheControlCustom() {
            curObj["CacheControlCustom"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeCacheControlMaxAge() {
            if ((IsCacheControlMaxAgeNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetCacheControlMaxAge() {
            curObj["CacheControlMaxAge"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeCacheControlNoCache() {
            if ((IsCacheControlNoCacheNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetCacheControlNoCache() {
            curObj["CacheControlNoCache"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeCacheISAPI() {
            if ((IsCacheISAPINull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetCacheISAPI() {
            curObj["CacheISAPI"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeCentralBinaryLoggingEnabled() {
            if ((IsCentralBinaryLoggingEnabledNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetCentralBinaryLoggingEnabled() {
            curObj["CentralBinaryLoggingEnabled"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeCertCheckMode() {
            if ((IsCertCheckModeNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetCertCheckMode() {
            curObj["CertCheckMode"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeCGITimeout() {
            if ((IsCGITimeoutNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetCGITimeout() {
            curObj["CGITimeout"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeConnectionTimeout() {
            if ((IsConnectionTimeoutNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetConnectionTimeout() {
            curObj["ConnectionTimeout"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeContentIndexed() {
            if ((IsContentIndexedNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetContentIndexed() {
            curObj["ContentIndexed"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeCreateCGIWithNewConsole() {
            if ((IsCreateCGIWithNewConsoleNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetCreateCGIWithNewConsole() {
            curObj["CreateCGIWithNewConsole"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeCreateProcessAsUser() {
            if ((IsCreateProcessAsUserNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetCreateProcessAsUser() {
            curObj["CreateProcessAsUser"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetDefaultDoc() {
            curObj["DefaultDoc"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetDefaultDocFooter() {
            curObj["DefaultDocFooter"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetDefaultLogonDomain() {
            curObj["DefaultLogonDomain"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeDemandStartThreshold() {
            if ((IsDemandStartThresholdNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetDemandStartThreshold() {
            curObj["DemandStartThreshold"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeDirBrowseFlags() {
            if ((IsDirBrowseFlagsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetDirBrowseFlags() {
            curObj["DirBrowseFlags"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeDirBrowseShowDate() {
            if ((IsDirBrowseShowDateNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetDirBrowseShowDate() {
            curObj["DirBrowseShowDate"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeDirBrowseShowExtension() {
            if ((IsDirBrowseShowExtensionNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetDirBrowseShowExtension() {
            curObj["DirBrowseShowExtension"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeDirBrowseShowLongDate() {
            if ((IsDirBrowseShowLongDateNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetDirBrowseShowLongDate() {
            curObj["DirBrowseShowLongDate"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeDirBrowseShowSize() {
            if ((IsDirBrowseShowSizeNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetDirBrowseShowSize() {
            curObj["DirBrowseShowSize"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeDirBrowseShowTime() {
            if ((IsDirBrowseShowTimeNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetDirBrowseShowTime() {
            curObj["DirBrowseShowTime"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeDirectoryLevelsToScan() {
            if ((IsDirectoryLevelsToScanNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetDirectoryLevelsToScan() {
            curObj["DirectoryLevelsToScan"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeDisableSocketPooling() {
            if ((IsDisableSocketPoolingNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetDisableSocketPooling() {
            curObj["DisableSocketPooling"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeDisableStaticFileCache() {
            if ((IsDisableStaticFileCacheNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetDisableStaticFileCache() {
            curObj["DisableStaticFileCache"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeDoDynamicCompression() {
            if ((IsDoDynamicCompressionNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetDoDynamicCompression() {
            curObj["DoDynamicCompression"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeDontLog() {
            if ((IsDontLogNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetDontLog() {
            curObj["DontLog"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeDoStaticCompression() {
            if ((IsDoStaticCompressionNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetDoStaticCompression() {
            curObj["DoStaticCompression"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeDownlevelAdminInstance() {
            if ((IsDownlevelAdminInstanceNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetDownlevelAdminInstance() {
            curObj["DownlevelAdminInstance"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeEnableDefaultDoc() {
            if ((IsEnableDefaultDocNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetEnableDefaultDoc() {
            curObj["EnableDefaultDoc"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeEnableDirBrowsing() {
            if ((IsEnableDirBrowsingNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetEnableDirBrowsing() {
            curObj["EnableDirBrowsing"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeEnableDocFooter() {
            if ((IsEnableDocFooterNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetEnableDocFooter() {
            curObj["EnableDocFooter"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeEnableReverseDns() {
            if ((IsEnableReverseDnsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetEnableReverseDns() {
            curObj["EnableReverseDns"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeHeaderWaitTimeout() {
            if ((IsHeaderWaitTimeoutNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetHeaderWaitTimeout() {
            curObj["HeaderWaitTimeout"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetHttpCustomHeaders() {
            curObj["HttpCustomHeaders"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetHttpErrors() {
            curObj["HttpErrors"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetHttpExpires() {
            curObj["HttpExpires"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetHttpPics() {
            curObj["HttpPics"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeIIs5IsolationModeEnabled() {
            if ((IsIIs5IsolationModeEnabledNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetIIs5IsolationModeEnabled() {
            curObj["IIs5IsolationModeEnabled"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetInProcessIsapiApps() {
            curObj["InProcessIsapiApps"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileBytesRecv() {
            if ((IsLogExtFileBytesRecvNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileBytesRecv() {
            curObj["LogExtFileBytesRecv"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileBytesSent() {
            if ((IsLogExtFileBytesSentNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileBytesSent() {
            curObj["LogExtFileBytesSent"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileClientIp() {
            if ((IsLogExtFileClientIpNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileClientIp() {
            curObj["LogExtFileClientIp"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileComputerName() {
            if ((IsLogExtFileComputerNameNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileComputerName() {
            curObj["LogExtFileComputerName"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileCookie() {
            if ((IsLogExtFileCookieNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileCookie() {
            curObj["LogExtFileCookie"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileDate() {
            if ((IsLogExtFileDateNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileDate() {
            curObj["LogExtFileDate"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileFlags() {
            if ((IsLogExtFileFlagsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileFlags() {
            curObj["LogExtFileFlags"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileHost() {
            if ((IsLogExtFileHostNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileHost() {
            curObj["LogExtFileHost"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileHttpStatus() {
            if ((IsLogExtFileHttpStatusNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileHttpStatus() {
            curObj["LogExtFileHttpStatus"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileHttpSubStatus() {
            if ((IsLogExtFileHttpSubStatusNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileHttpSubStatus() {
            curObj["LogExtFileHttpSubStatus"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileMethod() {
            if ((IsLogExtFileMethodNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileMethod() {
            curObj["LogExtFileMethod"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileProtocolVersion() {
            if ((IsLogExtFileProtocolVersionNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileProtocolVersion() {
            curObj["LogExtFileProtocolVersion"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileReferer() {
            if ((IsLogExtFileRefererNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileReferer() {
            curObj["LogExtFileReferer"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileServerIp() {
            if ((IsLogExtFileServerIpNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileServerIp() {
            curObj["LogExtFileServerIp"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileServerPort() {
            if ((IsLogExtFileServerPortNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileServerPort() {
            curObj["LogExtFileServerPort"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileSiteName() {
            if ((IsLogExtFileSiteNameNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileSiteName() {
            curObj["LogExtFileSiteName"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileTime() {
            if ((IsLogExtFileTimeNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileTime() {
            curObj["LogExtFileTime"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileTimeTaken() {
            if ((IsLogExtFileTimeTakenNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileTimeTaken() {
            curObj["LogExtFileTimeTaken"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileUriQuery() {
            if ((IsLogExtFileUriQueryNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileUriQuery() {
            curObj["LogExtFileUriQuery"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileUriStem() {
            if ((IsLogExtFileUriStemNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileUriStem() {
            curObj["LogExtFileUriStem"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileUserAgent() {
            if ((IsLogExtFileUserAgentNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileUserAgent() {
            curObj["LogExtFileUserAgent"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileUserName() {
            if ((IsLogExtFileUserNameNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileUserName() {
            curObj["LogExtFileUserName"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogExtFileWin32Status() {
            if ((IsLogExtFileWin32StatusNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogExtFileWin32Status() {
            curObj["LogExtFileWin32Status"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetLogFileDirectory() {
            curObj["LogFileDirectory"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogFileLocaltimeRollover() {
            if ((IsLogFileLocaltimeRolloverNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogFileLocaltimeRollover() {
            curObj["LogFileLocaltimeRollover"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogFilePeriod() {
            if ((IsLogFilePeriodNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogFilePeriod() {
            curObj["LogFilePeriod"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogFileTruncateSize() {
            if ((IsLogFileTruncateSizeNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogFileTruncateSize() {
            curObj["LogFileTruncateSize"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogInUTF8() {
            if ((IsLogInUTF8Null == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogInUTF8() {
            curObj["LogInUTF8"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetLogModuleList() {
            curObj["LogModuleList"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetLogOdbcDataSource() {
            curObj["LogOdbcDataSource"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetLogOdbcPassword() {
            curObj["LogOdbcPassword"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetLogOdbcTableName() {
            curObj["LogOdbcTableName"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetLogOdbcUserName() {
            curObj["LogOdbcUserName"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogonMethod() {
            if ((IsLogonMethodNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogonMethod() {
            curObj["LogonMethod"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetLogPluginClsid() {
            curObj["LogPluginClsid"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeLogType() {
            if ((IsLogTypeNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetLogType() {
            curObj["LogType"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeMaxBandwidth() {
            if ((IsMaxBandwidthNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetMaxBandwidth() {
            curObj["MaxBandwidth"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeMaxConnections() {
            if ((IsMaxConnectionsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetMaxConnections() {
            curObj["MaxConnections"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeMaxEndpointConnections() {
            if ((IsMaxEndpointConnectionsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetMaxEndpointConnections() {
            curObj["MaxEndpointConnections"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeMaxGlobalBandwidth() {
            if ((IsMaxGlobalBandwidthNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetMaxGlobalBandwidth() {
            curObj["MaxGlobalBandwidth"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeMaxRequestEntityAllowed() {
            if ((IsMaxRequestEntityAllowedNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetMaxRequestEntityAllowed() {
            curObj["MaxRequestEntityAllowed"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetMimeMap() {
            curObj["MimeMap"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeMinFileBytesPerSec() {
            if ((IsMinFileBytesPerSecNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetMinFileBytesPerSec() {
            curObj["MinFileBytesPerSec"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetNTAuthenticationProviders() {
            curObj["NTAuthenticationProviders"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializePassportRequireADMapping() {
            if ((IsPassportRequireADMappingNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetPassportRequireADMapping() {
            curObj["PassportRequireADMapping"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializePasswordCacheTTL() {
            if ((IsPasswordCacheTTLNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetPasswordCacheTTL() {
            curObj["PasswordCacheTTL"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializePasswordChangeFlags() {
            if ((IsPasswordChangeFlagsNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetPasswordChangeFlags() {
            curObj["PasswordChangeFlags"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializePasswordExpirePrenotifyDays() {
            if ((IsPasswordExpirePrenotifyDaysNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetPasswordExpirePrenotifyDays() {
            curObj["PasswordExpirePrenotifyDays"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializePoolIdcTimeout() {
            if ((IsPoolIdcTimeoutNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetPoolIdcTimeout() {
            curObj["PoolIdcTimeout"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeProcessNTCRIfLoggedOn() {
            if ((IsProcessNTCRIfLoggedOnNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetProcessNTCRIfLoggedOn() {
            curObj["ProcessNTCRIfLoggedOn"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeRapidFailProtectionInterval() {
            if ((IsRapidFailProtectionIntervalNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetRapidFailProtectionInterval() {
            curObj["RapidFailProtectionInterval"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeRapidFailProtectionMaxCrashes() {
            if ((IsRapidFailProtectionMaxCrashesNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetRapidFailProtectionMaxCrashes() {
            curObj["RapidFailProtectionMaxCrashes"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetRealm() {
            curObj["Realm"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetRedirectHeaders() {
            curObj["RedirectHeaders"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeRevocationFreshnessTime() {
            if ((IsRevocationFreshnessTimeNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetRevocationFreshnessTime() {
            curObj["RevocationFreshnessTime"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeRevocationURLRetrievalTimeout() {
            if ((IsRevocationURLRetrievalTimeoutNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetRevocationURLRetrievalTimeout() {
            curObj["RevocationURLRetrievalTimeout"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetScriptMaps() {
            curObj["ScriptMaps"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeServerAutoStart() {
            if ((IsServerAutoStartNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetServerAutoStart() {
            curObj["ServerAutoStart"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetServerBindings() {
            curObj["ServerBindings"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetServerComment() {
            curObj["ServerComment"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeServerListenBacklog() {
            if ((IsServerListenBacklogNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetServerListenBacklog() {
            curObj["ServerListenBacklog"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeServerListenTimeout() {
            if ((IsServerListenTimeoutNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetServerListenTimeout() {
            curObj["ServerListenTimeout"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeServerSize() {
            if ((IsServerSizeNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetServerSize() {
            curObj["ServerSize"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeShutdownTimeLimit() {
            if ((IsShutdownTimeLimitNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetShutdownTimeLimit() {
            curObj["ShutdownTimeLimit"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeSSIExecDisable() {
            if ((IsSSIExecDisableNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetSSIExecDisable() {
            curObj["SSIExecDisable"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeSSLAlwaysNegoClientCert() {
            if ((IsSSLAlwaysNegoClientCertNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetSSLAlwaysNegoClientCert() {
            curObj["SSLAlwaysNegoClientCert"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetSSLStoreName() {
            curObj["SSLStoreName"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeSslUseDsMapper() {
            if ((IsSslUseDsMapperNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetSslUseDsMapper() {
            curObj["SslUseDsMapper"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeUploadReadAheadSize() {
            if ((IsUploadReadAheadSizeNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetUploadReadAheadSize() {
            curObj["UploadReadAheadSize"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeUseDigestSSP() {
            if ((IsUseDigestSSPNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetUseDigestSSP() {
            curObj["UseDigestSSP"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetWAMUserName() {
            curObj["WAMUserName"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetWAMUserPass() {
            curObj["WAMUserPass"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private bool ShouldSerializeWebDAVMaxAttributesPerElement() {
            if ((IsWebDAVMaxAttributesPerElementNull == false)) {
                return true;
            }
            return false;
        }
        
        private void ResetWebDAVMaxAttributesPerElement() {
            curObj["WebDAVMaxAttributesPerElement"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private void ResetWebSvcExtRestrictionList() {
            curObj["WebSvcExtRestrictionList"] = null;
            if (((isEmbedded == false) 
                        && (AutoCommitProp == true))) {
                PrivateLateBoundObject.Put();
            }
        }
        
        [Browsable(true)]
        public void CommitObject() {
            if ((isEmbedded == false)) {
                PrivateLateBoundObject.Put();
            }
        }
        
        private static string ConstructPath(string keyName) {
            string strPath = "ROOT\\MicrosoftIISv2:IIsWebServiceSetting";
            strPath = (strPath 
                        + (".Name=" 
                        + ("\"" 
                        + (keyName + "\""))));
            return strPath;
        }
        
        // Different overloads of GetInstances() help in enumerating instances of the WMI class.
        public static IIsWebServiceSettingCollection GetInstances() {
            return GetInstances(((System.Management.ManagementScope)(null)), ((System.Management.EnumerationOptions)(null)));
        }
        
        public static IIsWebServiceSettingCollection GetInstances(string condition) {
            return GetInstances(null, condition, null);
        }
        
        public static IIsWebServiceSettingCollection GetInstances(System.String [] selectedProperties) {
            return GetInstances(null, null, selectedProperties);
        }
        
        public static IIsWebServiceSettingCollection GetInstances(string condition, System.String [] selectedProperties) {
            return GetInstances(null, condition, selectedProperties);
        }
        
        public static IIsWebServiceSettingCollection GetInstances(System.Management.ManagementScope mgmtScope, System.Management.EnumerationOptions enumOptions) {
            if ((mgmtScope == null)) {
                if ((statMgmtScope == null)) {
                    mgmtScope = new System.Management.ManagementScope();
                    mgmtScope.Path.NamespacePath = "root\\MicrosoftIISv2";
                }
                else {
                    mgmtScope = statMgmtScope;
                }
            }
            System.Management.ManagementPath pathObj = new System.Management.ManagementPath();
            pathObj.ClassName = "IIsWebServiceSetting";
            pathObj.NamespacePath = "root\\MicrosoftIISv2";
            System.Management.ManagementClass clsObject = new System.Management.ManagementClass(mgmtScope, pathObj, null);
            if ((enumOptions == null)) {
                enumOptions = new System.Management.EnumerationOptions();
                enumOptions.EnsureLocatable = true;
            }
            return new IIsWebServiceSettingCollection(clsObject.GetInstances(enumOptions));
        }
        
        public static IIsWebServiceSettingCollection GetInstances(System.Management.ManagementScope mgmtScope, string condition) {
            return GetInstances(mgmtScope, condition, null);
        }
        
        public static IIsWebServiceSettingCollection GetInstances(System.Management.ManagementScope mgmtScope, System.String [] selectedProperties) {
            return GetInstances(mgmtScope, null, selectedProperties);
        }
        
        public static IIsWebServiceSettingCollection GetInstances(System.Management.ManagementScope mgmtScope, string condition, System.String [] selectedProperties) {
            if ((mgmtScope == null)) {
                if ((statMgmtScope == null)) {
                    mgmtScope = new System.Management.ManagementScope();
                    mgmtScope.Path.NamespacePath = "root\\MicrosoftIISv2";
                }
                else {
                    mgmtScope = statMgmtScope;
                }
            }
            System.Management.ManagementObjectSearcher ObjectSearcher = new System.Management.ManagementObjectSearcher(mgmtScope, new SelectQuery("IIsWebServiceSetting", condition, selectedProperties));
            System.Management.EnumerationOptions enumOptions = new System.Management.EnumerationOptions();
            enumOptions.EnsureLocatable = true;
            ObjectSearcher.Options = enumOptions;
            return new IIsWebServiceSettingCollection(ObjectSearcher.Get());
        }
        
        [Browsable(true)]
        public static IIsWebServiceSetting CreateInstance() {
            System.Management.ManagementScope mgmtScope = null;
            if ((statMgmtScope == null)) {
                mgmtScope = new System.Management.ManagementScope();
                mgmtScope.Path.NamespacePath = CreatedWmiNamespace;
            }
            else {
                mgmtScope = statMgmtScope;
            }
            System.Management.ManagementPath mgmtPath = new System.Management.ManagementPath(CreatedClassName);
            return new IIsWebServiceSetting(new System.Management.ManagementClass(mgmtScope, mgmtPath, null).CreateInstance());
        }
        
        [Browsable(true)]
        public void Delete() {
            PrivateLateBoundObject.Delete();
        }
        
        // Enumerator implementation for enumerating instances of the class.
        public class IIsWebServiceSettingCollection : object, ICollection {
            
            private ManagementObjectCollection ObjectCollection;
            
            public IIsWebServiceSettingCollection(ManagementObjectCollection objCollection) {
                ObjectCollection = objCollection;
            }
            
            public int Count {
                get {
                    return ObjectCollection.Count;
                }
            }
            
            public bool IsSynchronized {
                get {
                    return ObjectCollection.IsSynchronized;
                }
            }
            
            public object SyncRoot {
                get {
                    return this;
                }
            }
            
            public void CopyTo(System.Array array, int index) {
                ObjectCollection.CopyTo(array, index);
                int nCtr;
                for (nCtr = 0; (nCtr < array.Length); nCtr = (nCtr + 1)) {
                    array.SetValue(new IIsWebServiceSetting(((System.Management.ManagementObject)(array.GetValue(nCtr)))), nCtr);
                }
            }
            
            public System.Collections.IEnumerator GetEnumerator() {
                return new IIsWebServiceSettingEnumerator(ObjectCollection.GetEnumerator());
            }
            
            public class IIsWebServiceSettingEnumerator : object, System.Collections.IEnumerator {
                
                private ManagementObjectCollection.ManagementObjectEnumerator ObjectEnumerator;
                
                public IIsWebServiceSettingEnumerator(ManagementObjectCollection.ManagementObjectEnumerator objEnum) {
                    ObjectEnumerator = objEnum;
                }
                
                public object Current {
                    get {
                        return new IIsWebServiceSetting(((System.Management.ManagementObject)(ObjectEnumerator.Current)));
                    }
                }
                
                public bool MoveNext() {
                    return ObjectEnumerator.MoveNext();
                }
                
                public void Reset() {
                    ObjectEnumerator.Reset();
                }
            }
        }
        
        // TypeConverter to handle null values for ValueType properties
        public class WMIValueTypeConverter : TypeConverter {
            
            private TypeConverter baseConverter;
            
            public WMIValueTypeConverter(System.Type baseType) {
                baseConverter = TypeDescriptor.GetConverter(baseType);
            }
            
            public override bool CanConvertFrom(System.ComponentModel.ITypeDescriptorContext context, System.Type srcType) {
                return baseConverter.CanConvertFrom(context, srcType);
            }
            
            public override bool CanConvertTo(System.ComponentModel.ITypeDescriptorContext context, System.Type destinationType) {
                return baseConverter.CanConvertTo(context, destinationType);
            }
            
            public override object ConvertFrom(System.ComponentModel.ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value) {
                return baseConverter.ConvertFrom(context, culture, value);
            }
            
            public override object CreateInstance(System.ComponentModel.ITypeDescriptorContext context, System.Collections.IDictionary dictionary) {
                return baseConverter.CreateInstance(context, dictionary);
            }
            
            public override bool GetCreateInstanceSupported(System.ComponentModel.ITypeDescriptorContext context) {
                return baseConverter.GetCreateInstanceSupported(context);
            }
            
            public override PropertyDescriptorCollection GetProperties(System.ComponentModel.ITypeDescriptorContext context, object value, System.Attribute[] attributeVar) {
                return baseConverter.GetProperties(context, value, attributeVar);
            }
            
            public override bool GetPropertiesSupported(System.ComponentModel.ITypeDescriptorContext context) {
                return baseConverter.GetPropertiesSupported(context);
            }
            
            public override System.ComponentModel.TypeConverter.StandardValuesCollection GetStandardValues(System.ComponentModel.ITypeDescriptorContext context) {
                return baseConverter.GetStandardValues(context);
            }
            
            public override bool GetStandardValuesExclusive(System.ComponentModel.ITypeDescriptorContext context) {
                return baseConverter.GetStandardValuesExclusive(context);
            }
            
            public override bool GetStandardValuesSupported(System.ComponentModel.ITypeDescriptorContext context) {
                return baseConverter.GetStandardValuesSupported(context);
            }
            
            public override object ConvertTo(System.ComponentModel.ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value, System.Type destinationType) {
                if ((context != null)) {
                    if ((context.PropertyDescriptor.ShouldSerializeValue(context.Instance) == false)) {
                        return "";
                    }
                }
                return baseConverter.ConvertTo(context, culture, value, destinationType);
            }
        }
        
        // Embedded class to represent WMI system Properties.
        [TypeConverter(typeof(System.ComponentModel.ExpandableObjectConverter))]
        public class ManagementSystemProperties {
            
            private System.Management.ManagementBaseObject PrivateLateBoundObject;
            
            public ManagementSystemProperties(System.Management.ManagementBaseObject ManagedObject) {
                PrivateLateBoundObject = ManagedObject;
            }
            
            [Browsable(true)]
            public int GENUS {
                get {
                    return ((int)(PrivateLateBoundObject["__GENUS"]));
                }
            }
            
            [Browsable(true)]
            public string CLASS {
                get {
                    return ((string)(PrivateLateBoundObject["__CLASS"]));
                }
            }
            
            [Browsable(true)]
            public string SUPERCLASS {
                get {
                    return ((string)(PrivateLateBoundObject["__SUPERCLASS"]));
                }
            }
            
            [Browsable(true)]
            public string DYNASTY {
                get {
                    return ((string)(PrivateLateBoundObject["__DYNASTY"]));
                }
            }
            
            [Browsable(true)]
            public string RELPATH {
                get {
                    return ((string)(PrivateLateBoundObject["__RELPATH"]));
                }
            }
            
            [Browsable(true)]
            public int PROPERTY_COUNT {
                get {
                    return ((int)(PrivateLateBoundObject["__PROPERTY_COUNT"]));
                }
            }
            
            [Browsable(true)]
            public string[] DERIVATION {
                get {
                    return ((string[])(PrivateLateBoundObject["__DERIVATION"]));
                }
            }
            
            [Browsable(true)]
            public string SERVER {
                get {
                    return ((string)(PrivateLateBoundObject["__SERVER"]));
                }
            }
            
            [Browsable(true)]
            public string NAMESPACE {
                get {
                    return ((string)(PrivateLateBoundObject["__NAMESPACE"]));
                }
            }
            
            [Browsable(true)]
            public string PATH {
                get {
                    return ((string)(PrivateLateBoundObject["__PATH"]));
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\health\dll\Block_NpdbSettings.cs ===
//
// NpdbSettings.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Healthcheck Module
// Xbox Online Service
//
// Common healthblock implementation.
//
// Author: kgoodier 3/2008
//

using System;
using System.Collections.Generic;
using System.Collections.Specialized;

using xonline.common.config;

namespace xonline.common.health
{

// --------------------------------------------------------------------------------------
// NpdbSettings - checks dependent NPDB settings. Returns their value. No validation.
//
// PARAMETERS:
//
// "prefix" : 1 or more setting prefix for this component. Example: "prefix=lspfd" will
// load all npdb settings matching "lspfd*".
//
// "setting" : 1 or more exact setting names to retrieve the value of. Example:
// "setting=xuacs_passportName,setting=xbos_passportName"
//
// --------------------------------------------------------------------------------------
internal class NpdbSettings : IHealthBlock
{
    public static string NpdbSettingsPrefix = null;

    public ResourceTypeEnum ResourceType
    {
        get { return ResourceTypeEnum.Local; }
    }

    public void DoCheck(
        HealthBlockManager  blockManager,
        NameValueCollection blockParams,
        HealthReport        report)
    {
        // Set output param immediately
        NpdbSettingsReport myReport = new NpdbSettingsReport();
        report.ExtendedReport = myReport;

        // Parse params
        string[] npdbSettingPrefixes = blockParams.GetValues("prefix");
        string[] extraSettings = blockParams.GetValues("setting");

        // Fill out report
        myReport.Component = Config.ComponentName;
        myReport.Server = Config.Server;
        myReport.Site = Config.SiteId;

        // First do all settings found by searching for the setting prefix
        if (npdbSettingPrefixes != null)
        {
            string[] settings;

            // Dynamic settings
            settings = Array.FindAll(
                Setting.DynamicSettings,
                delegate(string s)
                {
                    return Array.Exists(
                           npdbSettingPrefixes,
                           delegate(string prefix) { return s.StartsWith(prefix, StringComparison.CurrentCultureIgnoreCase); });
                });
            Config.TryCacheSettings(settings);
            foreach (string setting in settings)
            {
                myReport.AddSetting(setting, true);
            }

            // Static settings
            settings = Array.FindAll(
                Setting.StaticSettings,
                delegate(string s)
                {
                    return Array.Exists(
                           npdbSettingPrefixes,
                           delegate(string prefix) { return s.StartsWith(prefix, StringComparison.CurrentCultureIgnoreCase); });
                });
            Config.TryCacheSettings(settings);
            foreach (string setting in settings)
            {
                myReport.AddSetting(setting, false);
            }

            // multisettings
            settings = Array.FindAll(
                MultiSetting.Settings,
                delegate(string s)
                {
                    return Array.Exists(
                           npdbSettingPrefixes,
                           delegate(string prefix) { return s.StartsWith(prefix, StringComparison.CurrentCultureIgnoreCase); });
                });
            foreach (string setting in settings)
            {
                myReport.AddMultiSetting(setting);
            }
        }

        // Now do any other settings specified in the params
        if (extraSettings != null)
        {
            string[] settings;

            // Dynamic settings
            settings = Array.FindAll(
                Setting.DynamicSettings,
                delegate(string s)
                {
                    return Array.Exists(
                           extraSettings,
                           delegate(string extraSetting) { return String.Compare(s, extraSetting, true) == 0; });
                });
            Config.TryCacheSettings(settings);
            foreach (string setting in settings)
            {
                myReport.AddSetting(setting, false);
            }

            // Static settings
            settings = Array.FindAll(
                Setting.StaticSettings,
                delegate(string s)
                {
                    return Array.Exists(
                           extraSettings,
                           delegate(string extraSetting) { return String.Compare(s, extraSetting, true) == 0; });
                });
            Config.TryCacheSettings(settings);
            foreach (string setting in settings)
            {
                myReport.AddSetting(setting, false);
            }

            // multisettings
            settings = Array.FindAll(
                MultiSetting.Settings,
                delegate(string s)
                {
                    return Array.Exists(
                           extraSettings,
                           delegate(string extraSetting) { return String.Compare(s, extraSetting, true) == 0; });
                });
            foreach (string setting in settings)
            {
                myReport.AddMultiSetting(setting);
            }
        }

        // Wrap it up
        if (myReport.ErrorWhileReadingSettings)
        {
            // Something happened. Missing setting? NPDB connectivity? Don't know if it is 
            // fatal or not, though.
            report.HealthStatus = HealthStatusEnum.Red; 
        }
        else
        {
            report.HealthStatus = HealthStatusEnum.Green;
        }
    }
}

// --------------------------------------------------------------------------------------
// NpdbSettingsReport - health report
// --------------------------------------------------------------------------------------
public class NpdbSettingsReport : IExtendedHealthReport
{
    public string Component;
    public string Server;
    public int Site;
    public bool ErrorWhileReadingSettings;

    public List<NameValuePair> DynamicSettings;
    public List<NameValuePair> StaticSettings;
    public List<NameValuePair> MultiSettings;

    public NpdbSettingsReport()
    {
        ErrorWhileReadingSettings = false;
        DynamicSettings = new List<NameValuePair>();
        StaticSettings = new List<NameValuePair>();
        MultiSettings = new List<NameValuePair>();
    }

    public void AddSetting(string settingName, bool isDynamic)
    {
        try
        {
            AddSetting(settingName, Config.GetSetting(settingName), isDynamic);
        }
        catch (Exception e)
        {
            ErrorWhileReadingSettings = true;
            AddSetting(settingName, e.Message, isDynamic);
        }
    }

    public void AddMultiSetting(string multiSettingName)
    {
        try
        {
            AddMultiSetting(multiSettingName, Config.GetMultiSetting(multiSettingName));
        }
        catch (Exception e)
        {
            ErrorWhileReadingSettings = true;
            AddMultiSetting(multiSettingName, new string[] { e.Message });
        }
    }

    private void AddSetting(string n, string v, bool isDynamic)
    {
        NameValuePair info = new NameValuePair();
        info.Name = n;
        info.Value = v;

        if (isDynamic)
            DynamicSettings.Add(info);
        else
            StaticSettings.Add(info);
    }

    private void AddMultiSetting(string n, string[] vs)
    {
        if (vs == null || vs.Length == 0)
        {
            NameValuePair info = new NameValuePair();
            info.Name = n;
            info.Value = "(null)";
            MultiSettings.Add(info);
            return;
        }
        foreach (string v in vs)
        {
            NameValuePair info = new NameValuePair();
            info.Name = n;
            info.Value = v;

            MultiSettings.Add(info);
        }
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\health\dll\Block_JobInfo.cs ===
using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Data.SqlClient;
using System.Xml.Serialization;
using System.Text;


using xonline.common.config;
using xonline.common.sql.sqlclient;

namespace xonline.common.health
{
    /// <summary>
    /// Summary description for Job Status. The block helps monitoring the health of key jobs.
    /// </summary>
    public class JobStatusInfoHealthBlock : IHealthBlock
    {
        private readonly ResourceTypeEnum resourceType = ResourceTypeEnum.Remote;
        public ResourceTypeEnum ResourceType
        {
            get { return resourceType; }
        }
        /// <summary>
        /// DoCheck implemtation
        /// </summary>
        /// <param name="blockManager"></param>
        /// <param name="blockParams"></param>
        /// <param name="report"></param>
        public void DoCheck(HealthBlockManager blockManager, NameValueCollection blockParams, HealthReport report)
        {
            DatabaseJobInfo jobInfo = null;
            StringBuilder errorMessage = null;
            StringBuilder jobList = null;
            IVirtualInterfaceInfo virtualInterfaceInfo=null;
            bool isVirtual = false;
            string interfaceName;
            try
            {
                string[] databaseNames = blockParams.GetValues("database");
                string[] jobNames = blockParams.GetValues("job");

                errorMessage = new StringBuilder(string.Empty);
                jobList = new StringBuilder(string.Empty);

                jobInfo = new DatabaseJobInfo();
                //check if there are any jobs assigned for validation
                if (jobNames == null)
                {
                    report.ErrorDetails = "No Jobs defined in health mappings.";
                    report.HealthStatus = HealthStatusEnum.Yellow;
                    return;
                }
                //check if there is any database/interface defined.
                if (databaseNames == null)
                {
                    report.ErrorDetails = "No Databases defined";
                    report.HealthStatus = HealthStatusEnum.Yellow;
                    return;
                }
                //check if there is more than one database assigned
                if (databaseNames.Length > 1)
                {
                    report.ErrorDetails = "More than one Databases defined";
                    report.HealthStatus = HealthStatusEnum.Yellow;
                    return;
                }
                //Get the info on interfacetype
                isVirtual = Config.TryGetVirtualInterface(databaseNames[0], out virtualInterfaceInfo);
                if (isVirtual)
                {
                    interfaceName = virtualInterfaceInfo.VirtualInterface;
                }
                else
                {
                    interfaceName = databaseNames[0];
                }
                DatabaseJobInfo.JobDetail jobDetail = null;


                foreach (string job in jobNames)
                {
                    jobDetail = GetJobDetail(job, isVirtual, interfaceName);
                    jobInfo.AddJobDetail(jobDetail);
                }
            }
            catch (Exception e)
            {
                report.ErrorDetails = e.ToString();
                report.HealthStatus = HealthStatusEnum.Red;
                return;
            }
            //Green if the execution has come this far
            report.ExtendedReport = jobInfo;
            report.HealthStatus = jobInfo.GetHealthStatus();
        }
        /// <summary>
        /// Gets the job details for specific job name
        /// </summary>
        /// <param name="jobName"></param>
        /// <returns></returns>
        private DatabaseJobInfo.JobDetail GetJobDetail(string jobName, bool isVirtual, string interfaceName)
        {
            DatabaseJobInfo.JobDetail jobDetail = null;
            using (SqlClient command = new SqlClient(interfaceName, isVirtual))
            {
                command.ClearParameters();
                command.StoredProc = "msdb.dbo.sp_help_jobhistory";
                command.AddParameter("@job_name", jobName);
                command.AddParameter("@start_run_date", DateTime.Now.ToString("yyyMMdd"));

                jobDetail = new DatabaseJobInfo.JobDetail();
                jobDetail.Name = jobName;
                using (SqlDataReader reader = command.Execute())
                {
                    //check if there is any job execution history for the day.If no then it is a possible indication of an issue.
                    if (!reader.Read())
                    {
                        jobDetail.HealthStatus = HealthStatusEnum.Yellow;
                        jobDetail.ErrorDetails = String.Format("No successful job runs {0}.", jobName);
                    }
                    else
                    {
                        //If there is a job history then read the first record(records retrieved by latest first) and check the status,if it is any thing other than success/inprogress then it is a error.
                        while (reader.Read())
                        {
                            if (reader.GetInt32(2) != 1 && reader.GetInt32(2) != 4)
                            {
                                jobDetail.HealthStatus = HealthStatusEnum.Red;
                                jobDetail.ErrorDetails = String.Format("Last run of {0} not successful.", jobName);
                                break;
                            }
                        }
                    }
                }
            }
            if (jobDetail==null)
            {
                jobDetail = new DatabaseJobInfo.JobDetail();
                jobDetail.HealthStatus = HealthStatusEnum.Yellow;
                jobDetail.ErrorDetails=String.Format("No job found with name {0}",jobName);
            }
            return jobDetail;
        }
    }
    /// <summary>
    /// Extended health report class
    /// </summary>
    public class DatabaseJobInfo : IExtendedHealthReport
    {
        public List<DatabaseJobInfo.JobDetail> Jobs = null;
        public class JobDetail
        {
            public JobDetail() : base() { }
            public JobDetail(string name) { Name = name; }

            public string ErrorDetails;

            [XmlAttribute]
            public string Name;

            [XmlAttribute]
            public HealthStatusEnum HealthStatus = HealthStatusEnum.Green;
        }
        /// <summary>
        /// Adds jobdetails to the in memory list
        /// </summary>
        /// <param name="jobDetails"></param>
        public void AddJobDetail(JobDetail jobDetail)
        {
            if (Jobs == null) Jobs = new List<DatabaseJobInfo.JobDetail>();
            Jobs.Add(jobDetail);
        }
        /// <summary>
        /// Gets the overall healthstatus based on health of individual jobs
        /// </summary>
        /// <returns></returns>
        public HealthStatusEnum GetHealthStatus()
        {
            HealthStatusEnum healthStatus = HealthStatusEnum.Green;
            if (Jobs != null)
            {
                //Start with Red and return an overall status of Red, if there is atleast one red.
                JobDetail jobDetailWithError = Array.Find<JobDetail>(Jobs.ToArray(), delegate(JobDetail jobDetail) { return jobDetail.HealthStatus == HealthStatusEnum.Red; });
                if (jobDetailWithError != null)
                {
                    healthStatus= HealthStatusEnum.Red;
                }
                //If there is no Red but there are Yellows then return an overall status of Yellow.
                JobDetail jobDetailWithWarnings = Array.Find<JobDetail>(Jobs.ToArray(), delegate(JobDetail jobDetail) { return jobDetail.HealthStatus == HealthStatusEnum.Yellow; });
                if (jobDetailWithWarnings != null)
                {
                    healthStatus= HealthStatusEnum.Yellow;
                }
                //Green if the execution has come till this point
            }
            return healthStatus;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\health\dll\Block_HttpModule.cs ===
// 
// Block_HttpModule.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Healthcheck Module
// Xbox Online Service
//
// Common healthblock implementation for verifying the presence and health of an arbitrary 
// HttpModule, like the AAModule.
// 
// Author: kgoodier 5/2008
//

using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Xml.Serialization;

using Microsoft.Web.Administration;

using xonline.common.config;

namespace xonline.common.health
{

// --------------------------------------------------------------------------------------
// HttpModule - checks for proper configuration and existence of an HttpModule.
//
// PARAMETERS:
//
// "name" : the friendly name of the module to look for. This is configured in the 
// web.config.
//
// Example: "ActiveAuthModule"
// 
// "type" : the full type name of the module. This is a partial string match.
//
// Example: "xonline.server.activeauth.module.ActiveAuthModule"
// Example: "Version=7.0.0.0"
// Example: "aamodule, Version=7.0.0.0"
//
// You must specify either "name" or "type" or both. "name" is a strict, case-insensitive 
// match. "type" is a partial substring, case-insensitive, match.
//
// If no parameters are supplied, this simply generates a report of all dependent modules 
// without performing any validation.
// 
// --------------------------------------------------------------------------------------
internal class HttpModule : IHealthBlock
{
    public ResourceTypeEnum ResourceType 
    { 
        get { return ResourceTypeEnum.Local; }
    }

    public void DoCheck(
        HealthBlockManager  blockManager,
        NameValueCollection blockParams,
        HealthReport        report)
    {
        string[] p;
        p = blockParams.GetValues("name");
        string paramName = p != null ? p[0] : null;
        p = blockParams.GetValues("type");
        string paramType = p != null ? p[0] : null;
        string[] paramAppliesToAuthSGInstances = blockParams.GetValues("appliesToAuthSGInstance");
        
        HttpModuleReport myReport = new HttpModuleReport(paramName, paramType);
        report.ExtendedReport = myReport;

        string name, type;
        ConfigurationElement cfgElem ;

        // We need Config info to navigate Microsoft.Web.Administration
        // Using the component name here because it works for all (catalog, authsg) cases that use this healhcheck
        // To be really correct there probably needs to be a way to enumerate the interfaces for a component 
        // and then we would have to pick (the first?) one of the interfaces for the check.
        IInterfaceInfo iInfo = Config.GetInterface( Config.ComponentName );

        // Get the application configuration
        string currentAuthSGInstance = String.Empty;
        if (paramAppliesToAuthSGInstances != null)
        { // Get the AuthSG instance
            System.Configuration.Configuration webcfg = 
            System.Web.Configuration.WebConfigurationManager.OpenWebConfiguration(NormalizedRelativeUrlPath(iInfo.VDir), iInfo.VSite);
            if (webcfg.AppSettings.Settings["AuthSGInstance"] != null)
            {
                currentAuthSGInstance = webcfg.AppSettings.Settings["AuthSGInstance"].Value;
            }
            
            //Does the current authSG instance exist in the applies to list or is the current authSG instance a compressed instance?
            bool matchFound = false;
            if (currentAuthSGInstance == "all")
            {
                matchFound = true;
            }
            else
            {
                foreach(string appliesToAuthSGInstance in paramAppliesToAuthSGInstances)
                {
                    if (appliesToAuthSGInstance == currentAuthSGInstance)
                    {
                        matchFound = true;
                        break;
                    }                
                }
            }
                        
            if (!matchFound)
            {
                report.HealthStatus = HealthStatusEnum.Green;
                report.ErrorDetails = "HttpModule check does not apply to current instance";
                return;
            }
        }
        
        ServerManager sm = new ServerManager();
        Configuration cfg = sm.GetWebConfiguration( iInfo.VSite, iInfo.VDir );        
        ConfigurationSection cfgSect = cfg.GetSection( "system.webServer/modules" );
        ConfigurationElementCollection cfgElems = cfgSect.GetCollection();

        // Expecting something like:
        // Name: ActiveAuthModule
        // Type: xonline.server.activeauth.module.ActiveAuthModule, aamodule, Version=7.0.0.0, Culture=neutral, PublicKeyToken=1c793896f4718871

        for ( int i = 0; i < cfgElems.Count; i ++ )
        {
            cfgElem = cfgElems[i]; 
            Object obj = cfgElem.GetAttributeValue( "name" );
            name = obj.ToString();
            obj = cfgElem.GetAttributeValue( "type" );
            type = obj.ToString();
            myReport.AddModule( name, type );
        }

        if (!myReport.Validating || myReport.FoundMatch)
        {
            report.HealthStatus = HealthStatusEnum.Green;
        }
        else
        {
            report.HealthStatus = HealthStatusEnum.Red;
            report.ErrorDetails = "No matching HttpModule found";
        }
    }
    
    private static string NormalizedRelativeUrlPath(string vDir)
    {        
        string temp = vDir ?? string.Empty;
        return (temp.StartsWith("/")) ? temp : "/" + temp;
    }
}

public class HttpModuleReport : IExtendedHealthReport
{
    public class HttpModuleInfo 
    {
        [XmlAttribute]
        public string Name;
        [XmlAttribute]
        public string Type;

        public HttpModuleInfo(string n, string t)
        {
            Name = n;
            Type = t;
        }

        public HttpModuleInfo()
        {
            Name = null;
            Type = null;
        }
    }

    public bool     Validating;
    public string   ValidatingName;
    public string   ValidatingType;
    public bool     FoundMatch;
    public List<HttpModuleInfo> HttpModules;

    public HttpModuleReport(string paramName, string paramType)
    {
        ValidatingName = paramName;
        ValidatingType = paramType;
        Validating = paramName != null || paramType != null;
        FoundMatch = false;
        HttpModules = new List<HttpModuleInfo>();
    }

    public HttpModuleReport()
    {
    }

    public void AddModule(string moduleName, string moduleType)
    {
        HttpModules.Add(new HttpModuleInfo(moduleName, moduleType));
            
        if (!FoundMatch && Validating)
        {
            bool bFoundName = ValidatingName != null ? false : true; 
            bool bFoundType = ValidatingType != null ? false : true; 
            if (!bFoundName)
            {
                bFoundName = String.Compare(ValidatingName, moduleName, true) == 0;
            }
            if (!bFoundType)
            {
                bFoundType = moduleType.IndexOf(ValidatingType, StringComparison.OrdinalIgnoreCase) != -1;
            }
            FoundMatch = bFoundName && bFoundType;
        }

    }
}





}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\health\dll\Block_ServiceKey.cs ===
using System;
using System.Collections.Specialized;

using xonline.common.config;
using xonline.common.crypto;

namespace xonline.common.health
{
    public class ServiceKeyHealthcheckReport : IExtendedHealthReport
    {
        public string ServiceKeyName;
        public int ServiceKeyType;
        public int ServiceKeyVersion;
        public int ServiceKeyLength;
    }

    internal class ServiceKey : IHealthBlock
    {
        public ResourceTypeEnum ResourceType { get { return ResourceTypeEnum.Remote; } }

        public void DoCheck(HealthBlockManager blockManager, NameValueCollection blockParams, HealthReport report)
        {
            ServiceKeyHealthcheckReport serviceKeyReport = new ServiceKeyHealthcheckReport();
            report.ExtendedReport = serviceKeyReport;
            report.HealthStatus = HealthStatusEnum.Green;

            int serviceKeyType = 0;
            int serviceKeyVersion = 0;
            string serviceKeyName = blockParams["Name"]; // Not required.

            try
            {
                serviceKeyType = GetIntParam(blockParams, "Type");
                serviceKeyVersion = GetIntParam(blockParams, "Version");
            }
            catch (Exception e)
            {
                report.HealthStatus = HealthStatusEnum.Yellow;
                report.ErrorDetails = String.Format("Parameter parsing for ServiceKey health check failed with exception: {0}.", e);
                return;
            }

            serviceKeyReport.ServiceKeyName = serviceKeyName;
            serviceKeyReport.ServiceKeyType = serviceKeyType;
            serviceKeyReport.ServiceKeyVersion = serviceKeyVersion;

            byte[] key = null;
            try
            {
                key = CryptoReader.GetKey(serviceKeyType, serviceKeyVersion);
                serviceKeyReport.ServiceKeyLength = key == null ? 0 : key.Length;
            }
            catch (Exception e)
            {
                report.HealthStatus = HealthStatusEnum.Red;
                report.ErrorDetails = String.Format("The service key {0}, with keyType={1} and keyVersion={2} could not be loaded.  Verify this key exists in NPDB in t_service_keys.  If not, install it with XKEYMGR.\nException: {3}",
                    serviceKeyName, serviceKeyType, serviceKeyVersion, e);
                return;
            }

        }

        private static int GetIntParam(NameValueCollection blockParams, string baseParamName)
        {
            // We only allow exactly one service key type to be specified.
            string[] keyTypes = CallGetValues(blockParams, baseParamName);
            string[] keyTypeSettings = CallGetValues(blockParams, String.Format("{0}Setting", baseParamName));
            if ((keyTypes.Length + keyTypeSettings.Length) != 1)
            {
                throw new ArgumentException("Only one key type parameter may be set, either as a raw number or as a setting.");
            }

            if (keyTypes.Length == 1)
            {
                return Int32.Parse(keyTypes[0]);
            }
            else // if (keyTypeSettings == 1)
            {
                return Config.GetIntSetting(keyTypeSettings[0]);
            }
        }

        private static string[] CallGetValues(NameValueCollection blockParams, string key)
        {
            return blockParams.GetValues(key) ?? new string[0];
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\health\dll\Block_PassportIdSapi.cs ===
//
// NpdbSettings.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Healthcheck Module
// Xbox Online Service
//
// Common healthblock implementation.
//
// Author: kgoodier 3/2008
//

using System;
using System.Collections.Specialized;

using xonline.common.billing;
using xonline.common.config;
using xonline.common.service;

namespace xonline.common.health
{
    // --------------------------------------------------------------------------------------
    // PassportIdSapi - initialize and check health of the Passport ID SAPI web services.
    //
    // PARAMETERS:
    //
    // "puid" : 1 or more puids that exist in the Passport INT environment to perform a member
    //          name lookup on verify.  Passport exposes a discovery service but just because
    //          that responds does not mean the actual services are healthy.
    //
    // "prodnetPuid" : 1 or more puids that exist in the Passport INT environment to perform
    //          a member name lookup on verify.  Passport exposes a discovery service but just
    //          because that responds does not mean the actual services are healthy.
    //
    // --------------------------------------------------------------------------------------
    internal class PassportIdSapi : IHealthBlock
    {
        public ResourceTypeEnum ResourceType
        {
            get { return ResourceTypeEnum.Remote; }
        }

        public void DoCheck(HealthBlockManager blockManager, NameValueCollection blockParams, HealthReport report)
        {
            // set output param immediately
            PassportIdSapiReport myReport = new PassportIdSapiReport();
            report.ExtendedReport = myReport;

            myReport.PartnerUrl = Config.GetSetting(Setting.passport_partnerUrl);
            myReport.SiteId = Config.GetSetting(Setting.passport_siteId);
            myReport.SiteAddress = Config.GetSetting(Setting.passport_siteAddress);
            myReport.SitePolicy = Config.GetSetting(Setting.passport_sitePolicy);
            myReport.SiteAddressMsn = Config.GetSetting(Setting.passport_siteAddressMsn);
            myReport.SitePolicyMsn  = Config.GetSetting(Setting.passport_sitePolicyMsn);
            myReport.ClientCertSubject = Config.GetSetting(Setting.passport_clientCertName);
            myReport.BillingProxy = Config.GetSetting(Setting.billing_proxy);

            string environment = Config.Environment;

            string[] puids = blockParams.GetValues(environment + "Puid");
            string[] passwds = blockParams.GetValues(environment + "Password");

            if ( puids == null || puids.Length == 0 )
            {
                puids = blockParams.GetValues("puid");
                passwds = blockParams.GetValues("password");

                if ( puids == null || puids.Length == 0 )
                {
                    // no checks were able to be performed
                    report.HealthStatus = HealthStatusEnum.Yellow;
                    report.ErrorDetails = "No value specified for puid parameter.  Health status is unknown.";
                    return;
                }
            }

            // instantiate the PassportClientGlobal singleton and resolve the member names
            // for any puids in the parameter block
            try
            {
                // hack to make sure alternate handler hash table is instantiated before reload
                PassportClientGlobal.ResetSessionAlternateUrl();

                // get the global client.  this creates one,
                // using partner.xml file, if it isn't there

                PassportClientBase pp = PassportClientGlobal.Global;

                if ( pp is PassportClient )
                {
                    PassportClient ppc = (PassportClient) pp;

                    myReport.DefaultProfileServiceUrl = ppc.GetDomainConfig("default").serviceAPIProfileServerPK;
                    myReport.DefaultCredentialServiceUrl = ppc.GetDomainConfig("default").serviceAPICredentialServerPK;
                    myReport.DefaultEncryptedProxiedAuthUrl = ppc.GetDomainConfig("default").encryptedProxiedAuth;
                }

                for (int i=0; i < puids.Length; i++)
                {
                    ulong puid = UInt64.Parse(puids[i]);
                    string userCid;
                    string memberName;

                    try
                    {
                        memberName = PassportHelper.GetPassportMemberNameAndCID(puid, out userCid);
                    }
                    catch (Exception ex)
                    {
                        report.HealthStatus = HealthStatusEnum.Yellow;
                        report.ErrorDetails = "Failed to resolve member name of puid 0x" + puid.ToString("x") + ".  Verify Passport connectivity!  Exception: " + ex.Message;
                        return;
                    }

                    myReport.MemberName = memberName;

                    // if a password is provided, attempt a login
                    if ( passwds != null && passwds.Length >= i )
                    {
                        string passwd = passwds[i];

                        try
                        {
                            PassportClient pc = (PassportClient) PassportClientGlobal.Global;

                            byte[] encSesKey;
                            byte[] encPasswd;
                            byte[] encReq;
                            pc.TestGenerateEncryptedLoginParts( passwd, out encSesKey, out encPasswd, out encReq );

                            int serviceId = XOn.XONLINE_PASSPORT_LOGIN_XBOXLIVE_SERVICE_ID;
                            UInt64 passportPuid;
                            byte[] nonce;
                            byte[] cipherValue;

                            pc.Login(memberName, serviceId, encSesKey, encPasswd, encReq, out passportPuid, out nonce, out cipherValue);
                        }
                        catch (Exception ex)
                        {
                            report.HealthStatus = HealthStatusEnum.Yellow;
                            report.ErrorDetails = "Failed to login for membername: " + memberName + ", password: " + passwd + ".  Verify Passport connectivity!  Exception: " + ex.Message;
                            return;

                        }
                    }
                }
            }
            catch (Exception e)
            {
                report.HealthStatus = HealthStatusEnum.Yellow;
                report.ErrorDetails = e.Message;
                return;
            }

            // if we made it this far, things are good to go
            report.HealthStatus = HealthStatusEnum.Green;
        }
    }

    // --------------------------------------------------------------------------------------
    // PassportIdSapiReport - health report
    // --------------------------------------------------------------------------------------
    public class PassportIdSapiReport : IExtendedHealthReport
    {
        public string PartnerUrl;
        public string SiteId;
        public string SiteAddress;
        public string SitePolicy;
        public string SiteAddressMsn;
        public string SitePolicyMsn;
        public string ClientCertSubject;
        public string BillingProxy;
        public string DefaultProfileServiceUrl;
        public string DefaultCredentialServiceUrl;
        public string DefaultEncryptedProxiedAuthUrl;
        public string MemberName;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\health\dll\Block_ServerGC.cs ===
using System;
using System.Collections.Specialized;


namespace xonline.common.health
{
    /// <summary>
    /// Summary description for XCacheInfo
    /// </summary>
    public class ServerGCHealthBlock : IHealthBlock
    {
        private readonly ResourceTypeEnum resourceType = ResourceTypeEnum.Local;

        public ResourceTypeEnum ResourceType
        {
            get { return resourceType; }
        }

        public void DoCheck(HealthBlockManager blockManager, NameValueCollection blockParams, HealthReport report)
        {
            try
            {
                report.ErrorDetails = "";
                report.ErrorDetails += "Number of processors: " + System.Environment.ProcessorCount.ToString();
                report.ErrorDetails += "\r\nServerGC: " + (System.Runtime.GCSettings.IsServerGC ? "enbaled\r\n" : "disabled\r\n");
                
                report.HealthStatus = (System.Runtime.GCSettings.IsServerGC || (System.Environment.ProcessorCount == 1))
                    ? HealthStatusEnum.Green : HealthStatusEnum.Red;
            }
            catch (Exception e) 
            {
                report.HealthStatus = HealthStatusEnum.Red;
                report.ErrorDetails += e.ToString();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\health\dll\Block_PerformanceCounterAccess.cs ===
namespace xonline.common.health {
   using System;
   using System.Collections.Specialized;
    using System.Diagnostics;

   using xonline.common.config;
   using xonline.common.mgmt;

    public class PerformanceCounterAccessHealthBlock : IHealthBlock {
      public ResourceTypeEnum ResourceType {
         get { return ResourceTypeEnum.Local; }
      }

      private PerformanceCounter GetHealthPerformanceCounter(string instance) {
         return new PerformanceCounter("XBL HealthCheck", "HealthChecks", instance, false);
      }

      public void DoCheck(HealthBlockManager blockManager, NameValueCollection blockParams, HealthReport report) {
         try {
            PerformanceCounter ComponentHealthChecks;
            PerformanceCounter TotalHealthChecks;

            ComponentHealthChecks = GetHealthPerformanceCounter(XomPerformanceCounterCategory.DEFAULT_INSTANCE);
            TotalHealthChecks = GetHealthPerformanceCounter(Config.ComponentName);

            ComponentHealthChecks.Increment();
            TotalHealthChecks.Increment();

            report.HealthStatus = HealthStatusEnum.Green;
         }
         catch (Exception e) {
            report.HealthStatus = HealthStatusEnum.Red;
            report.ErrorDetails+= string.Format(
               "Failed to write to the HealthChecks performance counter " +
               "in the XblHealthCategory performance counter category. " +
               "Verify that the service account is a member of the " +
               "'Performance Monitor Users' group. details:\n{0}",
               e);
         } 
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\health\dll\Block_ServiceCheck.cs ===
// 
// ServiceCheck.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Healthcheck Module
// Xbox Online Service
//
// This module implements a service common healthblock
// All the checks in the module are *remote*
//
// Notes:
//
using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Data.SqlClient;
using System.Net;
using System.Text;
using System.IO;
using System.Xml;
using System.Xml.Serialization;

using xonline.common.config;
using xonline.common.service;
using xonline.common.sql.sqlclient;


namespace xonline.common.health {
   public class ComponentWebRequest {
      public ComponentWebRequest(string component) {
         this.component = component;
         this.targetUrl = null;
         this.path = null;
      }

      public uint Send() {
         string Result = "";

         return Send(ref Result);
      }

      public uint Send(ref string response) {
         HttpWebRequest Request;
         HttpWebResponse Response;
         StreamReader ResponseReader;
         Stream ResponseStream;
       
         try {
            Request = (HttpWebRequest)WebRequest.Create(Url);
         
            using(Response = (HttpWebResponse)Request.GetResponse()) {
               using (ResponseStream = Response.GetResponseStream()) {
                  using (ResponseReader = new StreamReader(Response.GetResponseStream(), Encoding.UTF8)) {
                     response = ResponseReader.ReadToEnd();
                  }
               }
            }

            return GetResultFromResponse(response);
         }
         catch (Exception e) {
            throw new Exception(string.Format("Request failed for Url: '{0}'.", Url), e);
         }
      }

      private uint GetResultFromResponse(string response) {
         XmlDocument Response = new XmlDocument();
         bool Result = false;

         //Assumption: XmlLoad failures are caused by old text health checks
         try { Response.LoadXml(response); }
         catch (XmlException) { return HResult.S_FALSE; }

         if (Response.DocumentElement.HasAttribute("ReadyForService")) {
            bool.TryParse(
               Response.DocumentElement.GetAttribute("ReadyForService").Trim(),
               out Result);
         }

         return Result ? 
            HResult.S_OK : 
            HResult.XONLINE_E_HEALTH_ERROR;
      }

      public string Component { 
         get { return component; }
         set { component = value; }
      }

      public Uri TargetUrl {
         get { return targetUrl; }
         set { targetUrl = value; }
      }

      public string Path {
         get { return path; }
         set { path = value; }
      }

      public string Url {
         get { return TargetUrl.ToString() + Path; }
      }

      private string component;
      private Uri targetUrl;
      private string path;
   }

   public class ServiceCheckHealthBlock : IHealthBlock {
      public ResourceTypeEnum ResourceType {
         get { return ResourceTypeEnum.Remote; }
      }

      public virtual void DoCheck(
         HealthBlockManager blockManager, 
         NameValueCollection parameters, 
         HealthReport report)
      {
         ReportCollection Reports = new ReportCollection();

         report.HealthStatus = HealthStatusEnum.Green;

         foreach (ComponentWebRequest request in GetRequests(parameters)) {
            ServiceCheckReport Report = new ServiceCheckReport(request);
            
            Reports.Add(Report);
            if (!Report.Succeeded) {
               report.ErrorDetails += string.Format("[FAILED] {0}|{1}|{2}.\r\n",
                  Report.Component, Report.Url, Report.Result);

               report.HealthStatus = HealthStatusEnum.Red;
            }
         }

         report.ExtendedReport = Reports;
      }

        private ComponentWebRequest GetVirtualInterfaceRequest(string virtualInterface) 
        {
            ComponentWebRequest Request;

            Request = new ComponentWebRequest(virtualInterface);
            using (SqlClient cmd = new SqlClient(Interface.npdb))
            {
                cmd.StoredProc = "p_config_get_virtual_interface_healthchecks";
                cmd.AddParameter("@vc_virtual_interface", virtualInterface);

                using (SqlDataReader reader = cmd.Execute())
                {
                    if (reader.Read())
                    {   // New way
                        Request.TargetUrl = new Uri( reader.GetString( reader.GetOrdinal( "vc_healthcheck_url" )));
                    }
                }
            }

            return Request;
      }

      private static Dictionary<string, uint> CurrentBucketForInterface = new Dictionary<string, uint>();
      private static Dictionary<string, uint> CurrentServerForInterface = new Dictionary<string, uint>();
      private static uint MaxInterfaceRequests = 10;
      
      private ComponentWebRequest GetBucketRequest(string iface, uint count) {
         ComponentWebRequest Request;
         IBucketServer BucketServer;
         uint Bucket;
         
         if (!CurrentBucketForInterface.ContainsKey(iface))
            CurrentBucketForInterface[iface] = 0;

         Bucket = CurrentBucketForInterface[iface] % count;
         CurrentBucketForInterface[iface] = (Bucket+1) % count;

         BucketServer = Config.GetBucketServer(iface, Bucket);

         Request = new ComponentWebRequest(string.Format("{0}:{1}", iface, Bucket));
         Request.TargetUrl = BucketServer.CurrentServer.Url;
         Request.Path = string.Format("{0}/health.ashx", BucketServer.CurrentServer.VDir);

         return Request;
      }

      private ComponentWebRequest GetInterfaceRequest(string iface, string[] servers) {
         ComponentWebRequest Request;
         IInterfaceInfo Interface;
         uint Server;

         if (!CurrentServerForInterface.ContainsKey(iface))
            CurrentServerForInterface[iface] = 0;

         Server = (uint)(CurrentServerForInterface[iface] % servers.Length);
         CurrentServerForInterface[iface] = (uint)((Server+1) % servers.Length);

         Interface = Config.GetInterface(servers[Server], iface);

         Request = new ComponentWebRequest(string.Format("{0}:{1}", iface, Server));
         Request.TargetUrl = Interface.Url;
         Request.Path = string.Format("{0}/health.ashx", Interface.VDir);

         return Request;
      }

      protected virtual IEnumerable<ComponentWebRequest> GetRequests(NameValueCollection parameters) {
         string [] VirtualInterfaces;
         string [] Interfaces;
         string [] BucketServers;

         VirtualInterfaces = parameters.GetValues("vip") ?? new string[0];
         Interfaces = parameters.GetValues("interface") ?? new string[0];
         BucketServers = parameters.GetValues("bucket") ?? new string[0];
         
         foreach (string virtualInterface in VirtualInterfaces)
            yield return GetVirtualInterfaceRequest(virtualInterface.Trim());   

         foreach (string iface in BucketServers) {
            uint BucketCount;
          
            BucketCount = Config.GetBucketCount(iface.Trim());
            for (uint c=0; c<Math.Min(BucketCount, MaxInterfaceRequests); c++)
               yield return GetBucketRequest(iface.Trim(), BucketCount);
         }

         foreach (string iface in Interfaces) {
            string[] Servers;

            Servers = Config.GetServerListByInterface(iface.Trim());
            for (uint c=0; c<Math.Min(Servers.Length, MaxInterfaceRequests); c++)
               yield return GetInterfaceRequest(iface.Trim(), Servers);
         }
      }
   }

   public class ReportCollection : IExtendedHealthReport {
      public ReportCollection() 
         : this(null) { }

      public ReportCollection(IEnumerable<ServiceCheckReport> reports) {
         this.reportCollection = new List<ServiceCheckReport>(reports ?? new ServiceCheckReport[0]);
      }

      public void Add(ServiceCheckReport report) {
         if (null != report)
            reportCollection.Add(report);
      }

      public ServiceCheckReport[] Reports {
         get { return reportCollection.ToArray(); }
         set {
            reportCollection.Clear();
            reportCollection.AddRange(value ?? new ServiceCheckReport[0]);
         }
      }

      private List<ServiceCheckReport> reportCollection;
   }

   public class ServiceCheckReport : IExtendedHealthReport {
      public ServiceCheckReport() { }

      public ServiceCheckReport(ComponentWebRequest request) {
         this.component = request.Component;
         this.url = request.Url.ToString();
         this.succeeded = HResult.Succeeded(this.result);
         this.response = "";
         this.result = request.Send(ref this.response);
      }

      public string Component {
         get { return component; }
         set { component = value; }
      }

      public string Url {
         get { return url; }
         set { url = value; }
      }

      public bool Succeeded {
         get { return succeeded; }
         set { succeeded = value; }
      }

      public uint Result {
         get { return result; }
         set { result = value; }
      }

      [XmlIgnore]
      public string Response {
         get { return response; }
         set { response = value; }
      }

      private string component;
      private string url;
      private string response;
      private bool succeeded;
      private uint result;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\health\dll\Block_PassportRPS.cs ===
// 
// Block_PassportRPS.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Healthcheck Module
// Xbox Online Service
//
// Common healthblock implementation for verifying the presence and health of the Passport 
// RPS library. This only checks the managed version.
// 
// Author: kgoodier 3/2009
//

using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Text;

using xonline.common.config;
using Microsoft.Passport.RPS;

namespace xonline.common.health
{

// --------------------------------------------------------------------------------------
// PassportRPS - 
//
// PARAMETERS:
// 
// CertSubjectContains - must find a certificate with a subject name that contains this 
// string. If not found, block fails. Optional parameter.
//
// SiteNameSetting - retrieves the RPS site name from this setting and verifies it is 
// configured in rpsconfig.xml. Optional parameter.
// @@@kgoodier Do we want to enforce site-id as well?
//
// --------------------------------------------------------------------------------------
internal class PassportRPS : IHealthBlock
{
    public ResourceTypeEnum ResourceType 
    { 
        get { return ResourceTypeEnum.Local; }
    }

    public void DoCheck(
        HealthBlockManager  blockManager,
        NameValueCollection blockParams,
        HealthReport        report)
    {
        PassportRPSReport myReport = new PassportRPSReport();
        report.ExtendedReport = myReport;

        //
        // Parameters
        //

        // Default to no enforcement and thus passing
        string  certSubjectToEnforce = null;
        bool    fFoundCert           = true;
        string[] siteNamesToEnforce  = null;
        Dictionary<string, bool> foundSites = new Dictionary<string, bool>();

        if (blockParams["CertSubjectContains"] != null)
        {
            certSubjectToEnforce = blockParams["CertSubjectContains"].Trim().ToLower();
            fFoundCert = false;
        }
        if (blockParams["SiteNameSetting"] != null)
        {
            siteNamesToEnforce = new string[1];
            siteNamesToEnforce[0] = Config.GetSetting(blockParams["SiteNameSetting"].Trim()).Trim();
        }
        if (blockParams["SiteNamesSetting"] != null)
        {
            siteNamesToEnforce = Config.GetMultiSetting(blockParams["SiteNamesSetting"].Trim());
            for (int i = 0; i < siteNamesToEnforce.Length; ++i)
            {
                siteNamesToEnforce[i] = siteNamesToEnforce[i].Trim();
            }
        }


        // May throw an exception, which is good
        Init();

        RPS rps = (RPS)_rps;
        RPSPropBag propBag;
        
        // Just dumps the whole rpsconfig.xml, with the addition of the "cert" node. It 
        // contains a list of the files in the \config\certs\ folder.
        using (propBag = new RPSServerConfig(rps))
        {
            ReadPropBag(propBag, myReport.ServerConfig, "rpsserver.xml");
        }

        // This seems to be empty, but I had hoped it would contain useful properties.  
        // Hmm.
        using (propBag = (RPSPropBag)rps.GetObject("rps.property.bag"))
        {
            ReadPropBag(propBag, myReport.RpsProperties, "");
        }

        using (propBag = new RPSServerConfig(rps))
        {
            // List of certificates configured, like "int-rps.xboxlive.com"
            using (RPSPropBag certBag = (RPSPropBag)propBag["certs"])
            {
                if (certBag != null && certBag.Names != null)
                {
                    foreach (string certName in certBag.Names)
                    {
                        NameValuePair nv = new NameValuePair();
                        nv.Name = certName.ToLower();
                        byte[] certBytes = (byte[])certBag[certName];
                        if (certBytes != null)
                        {
                            nv.Value = certBytes.Length.ToString();
                        }
                        myReport.Certificates.Add(nv);

                        // Enforce optional param
                        if (certSubjectToEnforce != null)
                        {
                            if (certName.Contains(certSubjectToEnforce))
                            {
                                fFoundCert = true;
                            }
                        }

                        // New healthblock to verify this cert. RPS returns the list of certs 
                        // in \Program Files\Microsoft Passport RPS\config\certs\. This will 
                        // check they also exist in the cert store.

                        string param = String.Format(
                            "SubjectName={0}, Store=Machine, Existence=MustPass, Expiry=ReportOnly, PrivateKey=MustPass, verify=skip",
                            certName);

                        blockManager.AddBlockToRun(
                            "CertInfo",
                            "xonline.common.health.CertInfo",
                            param,
                            false);
                    }
                }
            }

            // List of site names
            using (RPSPropBag siteBag = (RPSPropBag)propBag["sites"])
            {
                // These names are a list sites, and the values are propertybags.
                if (siteBag.Names != null)
                {
                    foreach (string site in siteBag.Names)
                    {
                        string siteId = "";
                        using (RPSPropBag thisSiteBag = (RPSPropBag)siteBag[site])
                        {
                            siteId = (string)thisSiteBag["siteId"];
                        }
                        myReport.Sites.Add(new NameValuePair(site, siteId));

                        // Enforce site name?
                        if (siteNamesToEnforce != null)
                        {
                            foreach (string siteNameToEnforce in siteNamesToEnforce)
                            {
                                if (site.Equals(siteNameToEnforce, StringComparison.OrdinalIgnoreCase))
                                {
                                    foundSites.Add(siteNameToEnforce, true);
                                }
                            }
                        }
                    }
                }
            }
        }


        report.HealthStatus = HealthStatusEnum.Green;

        if (!fFoundCert)
        {
            report.ErrorDetails += "Unable to find certificate with subject containing \"" + certSubjectToEnforce + "\".";
            report.HealthStatus = HealthStatusEnum.Red;
        }

        if (foundSites.Count < siteNamesToEnforce.Length)
        {
            StringBuilder siteNamesNotFound = new StringBuilder();

            foreach (string siteNameToEnforce in siteNamesToEnforce)
            {
                if (!foundSites.ContainsKey(siteNameToEnforce))
                {
                    if (0 > siteNameToEnforce.Length) siteNamesNotFound.Append(", ");
                    siteNamesNotFound.Append(siteNameToEnforce);
                }
            }
            report.ErrorDetails += "Unable to find site(s) matching \"" + siteNamesNotFound.ToString() + "\".";
            report.HealthStatus = HealthStatusEnum.Red;
        }

    }

    private void ReadPropBag(RPSPropBag propBag, List<NameValuePair> outList, string propPath)
    {
        if (propBag == null || propBag.Names == null)
        {
            return;
        }

        // Property bag info
        foreach (string name in propBag.Names)
        {
            if (propBag[name] is RPSPropBag)
            {
                outList.Add(new NameValuePair("====================", ""));
                NameValuePair nv = new NameValuePair("CONFIGPATH:", propPath + "\\" + name);
                outList.Add(nv);
                ReadPropBag((RPSPropBag)propBag[name], outList, nv.Value);
            }
            else
            {
                NameValuePair nv = new NameValuePair();
                nv.Name = name;
                if (propBag[name] != null)
                {
                    nv.Value = propBag[name].ToString();
                }
                else
                {
                    nv.Value = "(null)";
                }
                outList.Add(nv);
            }
        }
    }

    private void Init()
    {
        if (_rps == null)
        {
            lock (_initLock)
            {
                if (_rps != null)
                {
                    return;
                }

                RPS rps = new RPS();
                rps.Initialize(null);
                _rps = rps;
            }
        }
    }

    // This is really an RPS type, but we need to delay type load errors to the DoCheck() 
    // method, not the constructor.
    private volatile object _rps      = null;
    private object          _initLock = new object();
}

public class PassportRPSReport : IExtendedHealthReport
{
    public List<NameValuePair> Certificates;
    public List<NameValuePair> Sites;
    public List<NameValuePair> ServerConfig;
    public List<NameValuePair> RpsProperties;

    public PassportRPSReport()
    {
        Certificates  = new List<NameValuePair>();
        Sites         = new List<NameValuePair>();
        ServerConfig  = new List<NameValuePair>();
        RpsProperties = new List<NameValuePair>();

        Certificates.Add(new NameValuePair("SUBJECT", "LENGTH"));
        Sites.Add(new NameValuePair("NAME", "SITE-ID"));
    }

}


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\health\dll\Block_PerformanceCheck.cs ===
// 
// CertInfo.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Healthcheck Module
// Xbox Online Service
//
// PerformanceCheck
// Description:
//   Queries the performance category for the value of its counters.  Checks can be introduced
//   to enforce thresholds.  
//
//   The result of this block is green if and only if the check operation completes and no
//   performance counter checks failed.
//
//   If an exception is encountered then Yellow is returned.
//
//   When the check operation completes but performance counter checks failed, then the result
//   will be Red if the block is considered critical, and Yellow otherwise.
//   
// Parameters:
//   category [min=1, max=1]    : name of the performance counter category to report on
//   instance [min=0, max=1]    : name of the instance to use for performance counters
//   check [min=0, max=unbound] : expression containing performance counter and threshold
//   
// Check Format:
//   check=LValue[operator]RValue 
//      Where LValue is the name of a performance counter
//      And RValue is a float
//      And [operator] is one of the following
//         << - less than or equal
//         <  - less than
//         >> - greater than or equal
//         >  - greather than
// Example:
//   check=FailuresPerSecond<<2.5

namespace xonline.common.health {
   using System;
   using System.Diagnostics;
   using System.Collections.Specialized;
   using System.Collections.Generic;

   using CounterCheck = System.Collections.Generic.KeyValuePair<PerformanceCheckType, float>;
   using CounterDictionary = System.Collections.Generic.Dictionary<
      string,
      System.Collections.Generic.KeyValuePair<PerformanceCheckType, float>>;

    using xonline.common.mgmt;

   public enum PerformanceCheckType {
      QueryOnly,
      LessThanOrEqual,
      LessThan,
      GreaterThanOrEqual,
      GreaterThan,
   }

   public enum PerformanceCheckResult {
      Passed,
      Failed,
      InvalidOperator
   }
   
   public class PerformanceCheckHealthBlock : IHealthBlock {
      public ResourceTypeEnum ResourceType {
         get { return ResourceTypeEnum.Local; }
      }

      public void DoCheck(
         HealthBlockManager manager,
         NameValueCollection parameters,
         HealthReport report)
      {
         PerformanceCategoryReport CategoryReport;

         report.HealthStatus = HealthStatusEnum.Green;

         try {
            HealthStatusEnum FailureColor;
            
            CategoryReport = new PerformanceCategoryReport(
               GetPerformanceCategory(parameters),
               GetCategoryInstance(parameters),
               BuildCheckDictionary(parameters));

            FailureColor = HealthStatusEnum.Red;
            
            foreach (PerformanceCheckReport check in CategoryReport.PerformanceCounters) {
               if (check.CheckResult == PerformanceCheckResult.Failed) {
                  report.HealthStatus = FailureColor;
                  report.ErrorDetails +=
                     "Check failed for '" + check.CounterName + "'\r\n";
               }
            }

            report.ExtendedReport = CategoryReport;
         }
         catch (Exception e) {
            report.HealthStatus = HealthStatusEnum.Yellow;
            report.ErrorDetails += 
               "Encountered unexpected exception:\r\n" + e.ToString();
         }
      }

      private string GetCategoryInstance(NameValueCollection parameters) {
         string [] InstanceName = parameters.GetValues("instance") ?? new string[0];

         if (InstanceName.Length > 1) {
            throw new ArgumentException(
               string.Format("at most 1 instance property can be present, {0} have been specified.",
               InstanceName.Length));
         }
         else if (InstanceName.Length == 1)
            return InstanceName[0].Trim();
         
         return XomPerformanceCounterCategory.DEFAULT_INSTANCE;
      }

      private PerformanceCounterCategory GetPerformanceCategory(NameValueCollection parameters) {
         string[] CategoryName = parameters.GetValues("category") ?? new string[0];
         
         if (CategoryName.Length != 1) {
            throw new ArgumentException(
               string.Format("exactly 1 category property must be present, {0} have been specified.",
               CategoryName.Length));
         }

        if (!PerformanceCounterCategory.Exists(CategoryName[0]))
        {
            PerformanceCounter.CloseSharedResources();

            if (!PerformanceCounterCategory.Exists(CategoryName[0]))
            {
                throw new InvalidOperationException(
                    string.Format("the specified performance counter '{0}' does not exist.",
                    CategoryName[0]));
            }
         }

         return new PerformanceCounterCategory(CategoryName[0]);
      }

      private CounterDictionary BuildCheckDictionary(NameValueCollection parameters) {
         CounterDictionary CounterDictionary;

         CounterDictionary = new CounterDictionary();
         foreach (string expression in parameters.GetValues("check") ?? new string[0]) {
            string PerformanceCounter = "";
            float Operand = 0;

            if (IsOperation(expression, "<<", ref PerformanceCounter, ref Operand)) {
               CounterDictionary[PerformanceCounter] =
                 new CounterCheck(PerformanceCheckType.LessThanOrEqual, Operand); 
            }
            else if (IsOperation(expression, ">>", ref PerformanceCounter, ref Operand)) {
               CounterDictionary[PerformanceCounter] =
                 new CounterCheck(PerformanceCheckType.GreaterThanOrEqual, Operand); 
            }
            else if (IsOperation(expression, "<", ref PerformanceCounter, ref Operand)) {
               CounterDictionary[PerformanceCounter] =
                 new CounterCheck(PerformanceCheckType.LessThan, Operand); 
            }
            else if (IsOperation(expression, ">", ref PerformanceCounter, ref Operand)) {
               CounterDictionary[PerformanceCounter] =
                 new CounterCheck(PerformanceCheckType.GreaterThan, Operand); 
            }
            else
               throw new ArgumentException(
                  string.Format("invalid format for check expression '{0}'.", expression));
         }

         return CounterDictionary;
      }

      private bool IsOperation(string expression, string operation, ref string counter, ref float operand) {
         string[] Tokens;

         expression = expression.Trim();
         Tokens = expression.Split(
            new string[] { operation }, 
            StringSplitOptions.RemoveEmptyEntries);

         if (Tokens.Length == 2) {
            counter = Tokens[0].Trim();
            operand = float.Parse(Tokens[1].Trim());

            return true;
         }

         return false;
      }
   }

   public class PerformanceCategoryReport : IExtendedHealthReport {
      public PerformanceCategoryReport() {
         
      }

      public PerformanceCategoryReport(PerformanceCounterCategory category, string instance, CounterDictionary checkedCounters) {
         List<PerformanceCheckReport> Reports;

         Reports = new List<PerformanceCheckReport>();
         foreach(PerformanceCounter counter in category.GetCounters(instance) ?? new PerformanceCounter[0]) {
            string Key = counter.CounterName;

            if (checkedCounters.ContainsKey(Key)) {
               Reports.Add(new PerformanceCheckReport(counter, checkedCounters[Key].Key, checkedCounters[Key].Value));
               checkedCounters.Remove(Key);
            } else
               Reports.Add(new PerformanceCheckReport(counter));
         }

         this.categoryName = category.CategoryName;
         this.categoryDescription = category.CategoryHelp;
         this.countersInstance = instance;
         this.missingCounters = new string[checkedCounters.Count];
         checkedCounters.Keys.CopyTo(this.missingCounters, 0);

         this.performanceCounters = Reports.ToArray();
      }

      public string CategoryName {
         get { return categoryName; }
         set { categoryName = value; }
      }

      public string CategoryDescription {
         get { return categoryDescription; }
         set { categoryDescription = value; }
      }

      public string CountersInstance {
         get { return countersInstance; }
         set { countersInstance = value; }
      }

      public string[] MissingCounters {
         get { return missingCounters; }
         set { missingCounters = value; }
      }

      public PerformanceCheckReport[] PerformanceCounters {
         get { return performanceCounters ?? new PerformanceCheckReport[0]; }
         set { performanceCounters = value; }
      }

      private string categoryName;
      private string categoryDescription;
      private string countersInstance;
      private string[] missingCounters;
      private PerformanceCheckReport[] performanceCounters;
   }

   public class PerformanceCheckReport : IExtendedHealthReport {
      public PerformanceCheckReport(
            PerformanceCounter counter,
            PerformanceCheckType checkType,
            float operand)
         : this(counter)
      {
         this.checkType = checkType;
         this.checkOperand = operand;

         Check();
      }

      public PerformanceCheckReport(PerformanceCounter counter) 
         : this() 
      {
         this.counterName = counter.CounterName;
         this.counterType = counter.CounterType;
         this.counterDescription = counter.CounterHelp;
         this.counterValue = counter.NextValue();
      }

      public PerformanceCheckReport() {
         this.checkType = PerformanceCheckType.QueryOnly;
         this.checkResult = PerformanceCheckResult.Passed;
         this.counterValue = 0;
      }

      public PerformanceCheckResult Check() {
         if (PerformanceCheckType.QueryOnly == CheckType)
            CheckResult = PerformanceCheckResult.Passed;
         else {
            switch (CheckType) {
               case PerformanceCheckType.LessThanOrEqual:
                  CheckResult = CounterValue <= CheckOperand ?
                     PerformanceCheckResult.Passed :
                     PerformanceCheckResult.Failed;
                  break;
               case PerformanceCheckType.LessThan:
                  CheckResult = CounterValue < CheckOperand ?
                     PerformanceCheckResult.Passed :
                     PerformanceCheckResult.Failed;
                  break;
               case PerformanceCheckType.GreaterThanOrEqual:
                  CheckResult = CounterValue >= CheckOperand ?
                     PerformanceCheckResult.Passed :
                     PerformanceCheckResult.Failed;
                  break;
               case PerformanceCheckType.GreaterThan:
                  CheckResult = CounterValue > CheckOperand ?
                     PerformanceCheckResult.Passed :
                     PerformanceCheckResult.Failed;
                  break;
               default:
                  CheckResult = PerformanceCheckResult.InvalidOperator;
                  break;
            }
         }

         return CheckResult;
      }

      #region  Properties
      public PerformanceCheckResult CheckResult {
         get { return checkResult; }
         set { checkResult = value; }
      }

      public PerformanceCheckType CheckType {
         get { return checkType; }
         set { checkType = value; }
      }

      public float CheckOperand {
         get { return checkOperand; }
         set { checkOperand = value; }
      }

      public PerformanceCounterType CounterType {
         get { return counterType; }
         set { counterType = value; }
      }

      public string CounterName {
         get { return counterName ?? ""; }
         set { counterName = value; }
      }

      public string CounterDescription {
         get { return counterDescription ?? ""; }
         set { counterDescription = value; }
      }

      public float CounterValue {
         get { return counterValue; }
         set { counterValue = value; }
      }
      #endregion

      private PerformanceCheckType checkType;
      private PerformanceCheckResult checkResult;
      private float checkOperand;
      private PerformanceCounterType counterType;
      private string counterDescription;
      private string counterName;
      private float counterValue;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\health\dll\Block_ScsApiWebService.cs ===
//
// NpdbSettings.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Healthcheck Module
// Xbox Online Service
//
// Common healthblock implementation.
//
// Author: kgoodier 3/2008
//

using System;
using System.Collections.Specialized;

using xonline.common.billing;
using xonline.common.config;

namespace xonline.common.health
{
    // --------------------------------------------------------------------------------------
    // ScsApiWebService - initialize and check health of the SCS billing web service.
    //
    // PARAMETERS:
    //
    // "prefix" : 1 or more setting prefix for this component. Example: "prefix=lspfd" will
    // load all npdb settings matching "lspfd*".
    //
    // "setting" : 1 or more exact setting names to retrieve the value of. Example:
    // "setting=xuacs_passportName,setting=xbos_passportName"
    //
    // --------------------------------------------------------------------------------------
    internal class ScsApiWebService : IHealthBlock
    {
        private const string Keyword_RunEncryption = "RunEncryption";

        public ResourceTypeEnum ResourceType
        {
            get { return ResourceTypeEnum.Remote; }
        }

        public void DoCheck(HealthBlockManager blockManager, NameValueCollection blockParams, HealthReport report)
        {
            // set output param immediately
            ScsApiWebServiceReport myReport = new ScsApiWebServiceReport();
            report.ExtendedReport = myReport;

            // If billing connectivity is not present, report a meaningful status instead of
            // the mysterious HTTP status 403 error that results now.
            if ( BillingConfig.ConnectToBilling == false )
            {
                report.HealthStatus = HealthStatusEnum.Yellow;
                report.ErrorDetails = "Billing connectivity is disabled -- if a billing 1-box is present, check the value of the billing_connectToBilling setting!";
                return;
            }

            // default it to true 
            bool encrypt = true;

            // try to get the parameter if we want to bypass the encryption check
            string runEncryption = null;
            if (!(string.IsNullOrEmpty(blockParams[Keyword_RunEncryption])))
            {
                runEncryption = blockParams[Keyword_RunEncryption].Trim();
                bool parseResult = Boolean.TryParse(runEncryption, out encrypt);
            }

            // initialize the SCS billing provider
            BillingProvider.Init();

            BillingProvider bdk = new BillingProvider();

            myReport.WebServiceUrl = bdk.Url;
            myReport.BillingProxy = Config.GetSetting(Setting.billing_proxy);
            myReport.ClientCertSubject = Config.GetSetting(Setting.dmp_clientCertSubject);

            // first, perform a TestConnection request to initialize connectivity
            try
            {
                string outputText;
                bdk.TestConnection("healthcheck", out outputText);
            }
            catch (Exception e)
            {
                report.HealthStatus = HealthStatusEnum.Red;
                report.ErrorDetails = "TestConnection failed!  Exception: " + e.Message;
                return;
            }

            // DO NOT run encryption if bypass is requested
            // default is to always run the check
            if (encrypt)
            {
                // next, force the billing key to be loaded by performing an encryption
                try
                {
                    string cipherText = bdk.EncryptNumber("plainText");

                    if (string.IsNullOrEmpty(BillingProvider.Key))
                    {
                        report.HealthStatus = HealthStatusEnum.Red;
                        report.ErrorDetails = "Failed to obtain billing key from SCS!  Check connectivity.";
                        return;
                    }
                }
                catch (Exception e)
                {
                    report.HealthStatus = HealthStatusEnum.Red;
                    report.ErrorDetails = "Failed to  encrypt plainText using SCS billing key!  Check connectivity.  Exception: " + e.Message;
                    return;
                }
            }

            // if we made it this far, things are good to go
            report.HealthStatus = HealthStatusEnum.Green;
        }
    }

    // --------------------------------------------------------------------------------------
    // ScsApiWebServiceReport - health report
    // --------------------------------------------------------------------------------------
    public class ScsApiWebServiceReport : IExtendedHealthReport
    {
        public string WebServiceUrl;
        public string ClientCertSubject;
        public string BillingProxy;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\health\dll\Block_ThreadPool.cs ===
using System;
using System.Collections.Specialized;
using System.Threading;
using System.Text;



namespace xonline.common.health
{
   public class ThreadPoolHealthBlock : IHealthBlock
   {
      public ResourceTypeEnum ResourceType
      {
         get { return ResourceTypeEnum.Local; }
      }

      public void DoCheck(HealthBlockManager blockManager, NameValueCollection blockParams, HealthReport report)
      {
         StringBuilder detail = new StringBuilder();
         
         report.HealthStatus = HealthStatusEnum.Red;

         try 
         {
            int minWorkerThreads;
            int maxWorkerThreads;
            int minCompletionThreads;
            int maxCompletionThreads;

            string minWorkerString;
            string minCompletionString;

            HealthStatusEnum result = HealthStatusEnum.Green;

            ThreadPool.GetMinThreads(out minWorkerThreads, out minCompletionThreads);
            ThreadPool.GetMaxThreads(out maxWorkerThreads, out maxCompletionThreads);

            detail.AppendLine("Thread Pool Information");
            detail.AppendLine("   Worker Threads");
            detail.AppendLine("      Min = " + minWorkerThreads);
            detail.AppendLine("      Max = " + maxWorkerThreads);
            detail.AppendLine("   Completion Port Threads");
            detail.AppendLine("      Min = " + minCompletionThreads);
            detail.AppendLine("      Max = " + maxCompletionThreads);
            detail.AppendLine();

            if ( null != (minWorkerString = blockParams["minWorker"]) ) {
               int expectedMinWorkers = int.Parse(minWorkerString);

               detail.AppendLine("Expected Min Worker Threads: " + expectedMinWorkers);

               if (expectedMinWorkers != minWorkerThreads) {
                  if (expectedMinWorkers > minWorkerThreads && minWorkerThreads == maxWorkerThreads) {
                     detail.AppendLine("Expected Min Worker Threads cant be met due to low Max Worker Threads");
                     result = HealthStatusEnum.Yellow;
                  }
                  else {
                     detail.AppendLine("Expected Min Worker Threads does not match actual Min Worker Threads");
                     result = HealthStatusEnum.Red;
                  }
               }
            }

            if ( null != (minCompletionString = blockParams["minCompletion"]) ) {
               int expectedMinCompletion = int.Parse(minCompletionString);

               detail.AppendLine("Expected Min Completion Port Threads: " + expectedMinCompletion);

               if (expectedMinCompletion != minCompletionThreads) {
                  if (expectedMinCompletion > minCompletionThreads && minCompletionThreads == maxCompletionThreads) {
                     detail.AppendLine("Expected Min Completion Port Threads cant be met due to low Max Completion Port Threads");
                     if (result == HealthStatusEnum.Green)
                        result = HealthStatusEnum.Yellow;
                  }
                  else {
                     detail.AppendLine("Expected Min Completion Port Threads does not match actual Min Completion Port Threads");
                     result = HealthStatusEnum.Red;
                  }
               }
            }
           
            report.HealthStatus = result;   
         }
         catch (Exception e)
         {
            detail.AppendLine("Unexpected exception:");
            detail.AppendLine(e.ToString());
         }
         finally {
            report.ErrorDetails = detail.ToString();
         }
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\health\dll\Block_UpsCheck.cs ===
//
// NpdbSettings.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Healthcheck Module
// Xbox Online Service
//
// Common healthblock implementation.
//
// Author: kgoodier 3/2008
//

using System;
using System.Collections.Specialized;

using xonline.common.billing;
using xonline.common.config;

namespace xonline.common.health
{
    // --------------------------------------------------------------------------------------
    // UpsHealthBlock - initialize and check health of the UPS web services.
    //
    // PARAMETERS:
    //
    // "puid" : 1 or more puids that exist in the Passport INT environment to perform a profile
    //          query on verify.
    //
    // "prodnetPuid" : 1 or more puids that exist in the Passport Production environment to
    //          perform a profile query on verify.
    //
    // --------------------------------------------------------------------------------------
    internal class UpsHealthBlock : IHealthBlock
    {
        public ResourceTypeEnum ResourceType
        {
            get { return ResourceTypeEnum.Remote; }
        }

        public void DoCheck(HealthBlockManager blockManager, NameValueCollection blockParams, HealthReport report)
        {
            // set output param immediately
            UpsReport myReport = new UpsReport();
            report.ExtendedReport = myReport;

            string environment = Config.Environment;

            string[] puids = blockParams.GetValues(environment + "Puid");
            string[] passwds = blockParams.GetValues(environment + "Password");

            if ( puids == null || puids.Length == 0 )
            {
                puids = blockParams.GetValues("puid");
                passwds = blockParams.GetValues("password");

                if ( puids == null || puids.Length == 0 )
                {
                    // no checks were able to be performed
                    report.HealthStatus = HealthStatusEnum.Yellow;
                    report.ErrorDetails = "No value specified for puid parameter.  Health status is unknown.";
                    return;
                }
            }

            // instantiate the PassportClientGlobal singleton and resolve the member names
            // for any puids in the parameter block
            try
            {
                IUpsClient iUps = UpsClientGlobal.Global;

                if ( iUps is UpsClient )
                {
                    UpsClient ups = (UpsClient) iUps;
                    
                    myReport.Url = ups.Url;
                    myReport.PartnerId = ups.PartnerId;
                    myReport.ClientCertSubject = Config.GetSetting(Setting.ups_clientCertName);
                    myReport.ProxyUrl = Config.GetSetting(Setting.billing_proxy);
                }

                for (int i=0; i < puids.Length; i++)
                {
                    ulong puid = UInt64.Parse(puids[i]);

                    // try and retrieve the birthdate from the UPS profile
                    try
                    {
                        string attributes = String.Join(",", new string[] {
                            "Personal_CS.Birthdate",
                            "Addresses_CS.Home_Region",
                            "xbox.gamertag"
                        });

                        string profileXml;
                        iUps.GetProfile(puid, attributes, out profileXml);

                        UpsProfile profile = new UpsProfile(profileXml);

                        // Birthdate
                        string birthDateString;
                        if (profile.GetAttributeString("Personal_CS", "Birthdate", out birthDateString))
                        {
                            DateTime birthdate;
                            UpsUtil.ParseBirthdate(birthDateString, out birthdate);

                            myReport.UpsBirthdate = birthdate.ToString();
                        }
                        else
                        {
                            report.HealthStatus = HealthStatusEnum.Yellow;
                            report.ErrorDetails = "Failed to obtain birthdate from UPS profile for puid 0x" + puid.ToString("x") + ".";
                            return;
                        }

                        // gamertag
                        string gamertag;
                        if (profile.GetAttributeString("xbox", "gamertag", out gamertag))
                        {
                            myReport.UpsGamertag = gamertag;
                        }
                        else
                        {
                            report.HealthStatus = HealthStatusEnum.Yellow;
                            report.ErrorDetails = "Failed to obtain gamertag from UPS profile for puid 0x" + puid.ToString("x") + ".";
                            return;
                        }
                    }
                    catch (Exception e)
                    {
                        report.HealthStatus = HealthStatusEnum.Yellow;
                        report.ErrorDetails = "Failed to obtain birthdate or gamertag from UPS profile for puid 0x" + puid.ToString("x") + ".  Exception: " + e.Message;
                        return;
                    }
                }
            }
            catch (Exception e)
            {
                report.HealthStatus = HealthStatusEnum.Yellow;
                report.ErrorDetails = e.Message;
                return;
            }

            // if we made it this far, things are good to go
            report.HealthStatus = HealthStatusEnum.Green;
        }
    }

    // --------------------------------------------------------------------------------------
    // UpsReport - health report
    // --------------------------------------------------------------------------------------
    public class UpsReport : IExtendedHealthReport
    {
        public string Url;
        public string PartnerId;
        public string ClientCertSubject;
        public string ProxyUrl;
        public string UpsGamertag;
        public string UpsBirthdate;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\health\dll\DtcStatus.cs ===
using System;
using System.Runtime.InteropServices;

namespace xonline.common.health
{
    internal enum AUTHENTICATION_LEVEL : uint
    {
        NO_AUTHENTICATION_REQUIRED = 0,
        INCOMING_AUTHENTICATION_REQUIRED = 1,
        MUTUAL_AUTHENTICATION_REQUIRED = 2
    };

    internal sealed class DtcStatus
    {
        #region Native DTC interface declarations
        [ComImport()]
        [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
        [Guid("9797C15D-A428-4291-87B6-0995031A678D")]
        interface IDtcNetworkAccessConfig2
        {
            [return: MarshalAs(UnmanagedType.Bool)]
            bool GetAnyNetworkAccess();

            void SetAnyNetworkAccess([MarshalAs(UnmanagedType.Bool)] bool bAnyNetworkAccess);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool GetNetworkAdministrationAccess();

            void SetNetworkAdministrationAccess([MarshalAs(UnmanagedType.Bool)] bool bNetworkAdministrationAccess);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool GetNetworkTransactionAccess();

            void SetNetworkTransactionAccess([MarshalAs(UnmanagedType.Bool)] bool bNetworkTransactionAccess);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool GetNetworkClientAccess();

            void SetNetworkClientAccess([MarshalAs(UnmanagedType.Bool)] bool bNetworkClientAccess);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool GetNetworkTIPAccess();

            void SetNetworkTIPAccess([MarshalAs(UnmanagedType.Bool)] bool bNetworkTIPAccess);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool GetXAAccess();

            void SetXAAccess([MarshalAs(UnmanagedType.Bool)] bool bXAAccess);

            void RestartDtcService();

            [return: MarshalAs(UnmanagedType.Bool)]
            bool GetNetworkInboundAccess();

            [return: MarshalAs(UnmanagedType.Bool)]
            bool GetNetworkOutboundAccess();

            void SetNetworkInboundAccess([MarshalAs(UnmanagedType.Bool)] bool bInbound);

            void SetNetworkOutboundAccess([MarshalAs(UnmanagedType.Bool)] bool bOutbound);

            AUTHENTICATION_LEVEL GetAuthenticationLevel();

            void SetAuthenticationLevel(AUTHENTICATION_LEVEL AuthLevel);
        }

        static Guid IID_IDtcNetworkAccessConfig2 = typeof(IDtcNetworkAccessConfig2).GUID;

        [DllImport("xolehlp.dll", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Unicode)]
        static extern Int32 DtcGetTransactionManagerEx(
            string pszHost,
            string pszTmName,
            ref Guid riid,
            int grfOptions,
            IntPtr pvConfigParams,
            [MarshalAs(UnmanagedType.IUnknown)] out object ppvObject);

        #endregion

        IDtcNetworkAccessConfig2 pConfig = null;

        public DtcStatus()
            : this(null)
        {
        }

        public DtcStatus(string machineName)
        {
            object obj;
            int res = DtcGetTransactionManagerEx(machineName, null, ref IID_IDtcNetworkAccessConfig2, 0, IntPtr.Zero, out obj);
            if (res < 0)
                throw new COMException("Could not connect to Transaction Manager on " + (String.IsNullOrEmpty(machineName) ? "localhost" : machineName), res);
            pConfig = (IDtcNetworkAccessConfig2)obj;

            try
            {
                pConfig.GetAnyNetworkAccess();
            }
            catch (COMException)
            {
                Marshal.ReleaseComObject(pConfig);
                pConfig = null;
            }
        }

        public bool NetworkDtcEnabled
        {
            get { return pConfig != null ? pConfig.GetAnyNetworkAccess() : false; }
        }

        public bool RemoteTxnAdminEnabled
        {
            get { return pConfig != null ? pConfig.GetNetworkAdministrationAccess() : false; }
        }

        public bool RemoteTxnClientsEnabled
        {
            get { return pConfig != null ? pConfig.GetNetworkClientAccess() : false; }
        }

        public bool NetworkTransactionsEnabled
        {
            get { return pConfig != null ? pConfig.GetNetworkTransactionAccess() : false; }
        }

        public bool TIPEnabled
        {
            get { return pConfig != null ? pConfig.GetNetworkTIPAccess() : false; }
        }

        public bool XAEnabled
        {
            get { return pConfig != null ? pConfig.GetXAAccess() : false; }
        }

        public bool NetworkInboundAccessEnabled
        {
            get { return pConfig != null ? pConfig.GetNetworkInboundAccess() : false; }
        }

        public bool NetworkOutboundAccessEnabled
        {
            get { return pConfig != null ? pConfig.GetNetworkOutboundAccess() : false; }
        }

        public AUTHENTICATION_LEVEL AuthenticationLevel
        {
            get { return pConfig != null ? pConfig.GetAuthenticationLevel() : AUTHENTICATION_LEVEL.MUTUAL_AUTHENTICATION_REQUIRED; }
        }


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\health\dll\Block_XCacheInfo.cs ===
using System;
using System.Collections.Specialized;

using xonline.common.service;

namespace xonline.common.health
{
    /// <summary>
    /// Summary description for XCacheInfo
    /// </summary>
    public class XCacheInfoHealthBlock : IHealthBlock
    {
        private readonly ResourceTypeEnum resourceType = ResourceTypeEnum.Remote;

        public ResourceTypeEnum ResourceType
        {
            get { return resourceType; }
        }

        public void DoCheck(HealthBlockManager blockManager, NameValueCollection blockParams, HealthReport report)
        {
            try
            {
                XCacheUserResponseData xcurd = XCache.LookupUserByXUID(0);

                if (xcurd.szGamertag != XCache.InvalidGamertag)
                {
                    throw new ApplicationException("XCacheInfoHealthBlock: got a valid gamertag for userid 0: " + xcurd.szGamertag);
                }

                report.HealthStatus = HealthStatusEnum.Green;
            }
            catch (Exception e) 
            {
                report.HealthStatus = HealthStatusEnum.Red;
                report.ErrorDetails = e.ToString();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\health\dll\Block_XBancInfo.cs ===
using System;
using System.Collections.Specialized;

using xonline.common.config;
using xonline.common.service;

namespace xonline.common.health
{
    /// <summary>
    /// Summary description for XbancInfo
    /// </summary>
    public class XBancInfoHealthBlock : IHealthBlock
    {
        private readonly ResourceTypeEnum resourceType = ResourceTypeEnum.Remote;

        public ResourceTypeEnum ResourceType
        {
            get { return resourceType; }
        }

        public void DoCheck(HealthBlockManager blockManager, NameValueCollection blockParams, HealthReport report)
        {
            try
            {
                string[] servers = Config.GetServerListByInterface(Interface.xbanc);

                XBanc xb = new XBanc();
                uint[] hrs = xb.Health();

                if (servers.Length != hrs.Length)
                {
                    throw new ApplicationException("XBancInfoHealthBlock: config server list does not match Xbanc server list!");
                }

                uint cFailed = 0;
               
                for (uint iServer = 0; iServer < hrs.Length; iServer++)
                {
                    if (HResult.Failed(hrs[iServer]))
                    {
                        cFailed++;
                        report.ErrorDetails += "\r\nServer " + servers[iServer] + " returned hr = " + ((HResult) hrs[iServer]);
                    }
                }

                report.HealthStatus = (cFailed >= hrs.Length) ? HealthStatusEnum.Red : (cFailed > 0) ? HealthStatusEnum.Yellow : HealthStatusEnum.Green;
            }
            catch (Exception e) 
            {
                report.HealthStatus = HealthStatusEnum.Red;
                report.ErrorDetails = e.ToString();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\health\dll\Block_UserGroupCheck.cs ===
﻿using System.Collections.Specialized;
using System.Security.Principal;

namespace xonline.common.health
{
    class UserGroupCheck : IHealthBlock
    {
        public ResourceTypeEnum ResourceType
        {
            get { return ResourceTypeEnum.Local; }
        }

        public void DoCheck(HealthBlockManager blockManager, NameValueCollection blockParams, HealthReport report)
        {
            report.HealthStatus = HealthStatusEnum.Green;

            WindowsIdentity currentIdentity;
            bool isImpersonating;

            HealthcheckEngine.GetIdentityInfo(out currentIdentity, out isImpersonating);
            if(currentIdentity == null)
            {
                report.HealthStatus = HealthStatusEnum.Red;
                report.ErrorDetails += "Current identity could not be retrieved.\r\n";
                return;
            }

            string[] groupNames = blockParams.GetValues("requiredUserGroup");

            //  If no required groups were specified, then we're done with the health check.
            if (groupNames == null || groupNames.Length == 0) return;

            foreach (string groupName in groupNames)
            {
                if (string.IsNullOrEmpty(groupName.Trim())) continue;

                bool foundGroup = false;

                if(currentIdentity.Groups != null)
                {
                    foreach (IdentityReference idRef in currentIdentity.Groups)
                    {
                        NTAccount ntAccount = (NTAccount) idRef.Translate(typeof (NTAccount));

                        foundGroup = (ntAccount.Value == groupName);
                        if (foundGroup) break;
                    }
                }

                if (foundGroup) continue;

                report.ErrorDetails += string.Format("User {0} is not a member of security group {1}.\r\n",
                                                     currentIdentity.Name, groupName);
                report.HealthStatus = HealthStatusEnum.Red;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\health\dll\HealthBlock.cs ===
// 
// IHealthBlock.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Healthcheck Module
// Xbox Online Service
//
// Collection of interfaces needed to implement a healthblock, the fundamental unit of 
// work for a healthcheck.
// 
// Author: kgoodier 3/2008
//

using System;
using System.Collections.Specialized;
using System.Xml;
using System.Xml.Schema;
using System.Xml.Serialization;
using System.Runtime.InteropServices;

namespace xonline.common.health
{

// --------------------------------------------------------------------------------------
// HealthStatusEnum - the stoplight analogy makes sense, no?
//
// Green - all good!
//
// Yellow - questionable. This will get someone's attention but otherwise cause no action.
//
// Red - failed. Server may be taken out of the VIP depending on resource type.
// --------------------------------------------------------------------------------------

[ComVisible(true)]
public enum HealthStatusEnum
{
    Green, 
    Yellow,
    Red
}

// --------------------------------------------------------------------------------------
// ResourceTypeEnum - what kind of resource is your healthblock checking?
//
// Local - if the resource is only on the current machine. If this fails, the server may 
// be taken out of the VIP.
//
// Remote - if the resource is shared across servers, like UODB or Passport. If this 
// fails, we don't want to take the server out of the VIP or else no servers will be left.
// --------------------------------------------------------------------------------------

[ComVisible(true)]
public enum ResourceTypeEnum
{
    Unknown,  // really try not to use this, k?
    Local,
    Remote 
}


// --------------------------------------------------------------------------------------
// IHealthBlock
//
// Implement this to build an atomic unit health checkiness.
//
// ResourceType - see ResourceTypeEnum comments.
//
// blockManager - provided as a way to communicate with the execution engine. If your 
// healthblock needs to dynamically schedule new healthblocks to run, there is a method 
// here to do that.
//
// blockParams - arbitrary key/value pairs of input parameters. May commonly be used for 
// only keys with no value, or even keys with multiple values. 
//
// *** PLEASE DOCUMENT THE PARAMETERS FOR EVERY IHEALTHBLOCK IMPLEMENTATION. ***
//
// report - you MUST set the fields in this appropriately:
// 1. HealthStatus    - (required) Green, Yellow, or Red
// 3. ErrorDetails    - (optional) string with additional error info
// 4. ExtendedReport  - (optional) custom class that implements IExtendedHealthReport with 
// xml serializable fields.
//
// --------------------------------------------------------------------------------------

public interface IHealthBlock
{
    ResourceTypeEnum ResourceType { get; }

    void DoCheck(
        HealthBlockManager blockManager,
        NameValueCollection blockParams, 
        HealthReport report);
        
}


// --------------------------------------------------------------------------------------
// IExtendedHealthReport
// 
// Implement this to provide consistent, but detailed, results of running the healthcheck 
// for your block. Please provide useful public fields here - they will be converted to 
// XML. Private and protected fields will not be serialized.
//
// *** IMPORTANT NOTES ***
//
// Your class must be public, and any serializable fields must be public. Private & 
// protected members won't be serialized.
//
// Some types can't be xml serialized.  Basic types, arrays, List<>, and even custom 
// objects are ok. But Dictionary<> is NOT ok, though, among others. See  
// SerializableDictionary<> in HealthUtils.cs for a solution. MAKE SURE YOU TEST YOUR 
// HEALTHBLOCK!
// --------------------------------------------------------------------------------------

public interface IExtendedHealthReport 
{
    // ummm, yeah, nothing here. still good to use one in case it changes in the future.

    // put whatever other fields you want here

}


// --------------------------------------------------------------------------------------
// HealthReport 
//
// Helper that implements only the basic fields. Used internally and by very simple 
// blocks.
// --------------------------------------------------------------------------------------

public class HealthReport : IXmlSerializable
{

    // ----------------------------------------------------------------------------------
    // HealthStatus - Green if all good, Yellow if questionably good (cache is still 
    // loading, but service is usable, for instance), and Red if bad.
    // ----------------------------------------------------------------------------------
    public HealthStatusEnum HealthStatus 
    { 
        get { return _HealthStatus; } 
        set { _HealthStatus = value; }
    }

    // ----------------------------------------------------------------------------------
    // ErrorDetails - optional, please fill in whatever details are relevant if an error 
    // occurs.
    // ----------------------------------------------------------------------------------
    public string ErrorDetails
    {
        get { return _ErrorDetails; }
        set { _ErrorDetails = value; }
    }

    // ----------------------------------------------------------------------------------
    // ExtendedReport - optional, please set with a custom class full of yummy public 
    // fields that will be xml serialized and provided in the overall health report.
    // ----------------------------------------------------------------------------------
    public IExtendedHealthReport ExtendedReport
    {
        get { return _ExtendedReport; }
        set { _ExtendedReport = value; }
    }



    // ----------------------------------------------------------------------------------
    // Everything else...
    // ----------------------------------------------------------------------------------

    // needed for XmlSerializer, don't use
    public HealthReport()
    {
    }

    // "real" constructor
    public HealthReport(
        string friendlyName, 
        string fullName, 
        ResourceTypeEnum resourceType,
        bool critical,
        string parms)
    {
        _HealthStatus    = HealthStatusEnum.Red;
        _ErrorDetails    = null;
        _ExtendedReport  = null;

        _FriendlyName    = friendlyName;
        _FullName        = fullName;
        _ResourceType    = resourceType;
        _Critical        = critical;
        _Params          = parms;

        Start();
        Stop();
    }

    // ----------------------------------------------------------------------------------
    // Fail - helper for failing a check and reporting info
    // ----------------------------------------------------------------------------------
    public void Fail(string errorDetails)
    {
        _HealthStatus    = HealthStatusEnum.Red;
        _ErrorDetails    = errorDetails;
    }

    // ----------------------------------------------------------------------------------
    // DowngradeStatus - sets healthreport status to input value, but only if new status 
    // is worse than previous status. Static helper method.
    // ----------------------------------------------------------------------------------
    public static HealthStatusEnum DowngradeStatus(HealthStatusEnum baseHealthStatus, HealthStatusEnum newHealthStatus)
    {
        if ((baseHealthStatus == HealthStatusEnum.Green) || 
            (newHealthStatus == HealthStatusEnum.Red))
        {
            // Green to Yellow
            //   or
            // Green or Yellow to Red
            return newHealthStatus;
        }
        else
        {
            return baseHealthStatus;
        }
    }

    // ----------------------------------------------------------------------------------
    // DowngradeStatus - sets healthreport status to input value, but only if new status 
    // is worse than previous status.
    // ----------------------------------------------------------------------------------
    public void DowngradeStatus(HealthStatusEnum s)
    {
        this.HealthStatus = DowngradeStatus(this.HealthStatus, s);
    }

    // ----------------------------------------------------------------------------------
    // FriendlyName - should be the name of the healthblock this report corresponds to.
    // ----------------------------------------------------------------------------------
    public string FriendlyName 
    {
        get { return _FriendlyName; }
    }

    // ----------------------------------------------------------------------------------
    // FullName - should be the full class name of the healthblock.
    // ----------------------------------------------------------------------------------
    public string FullName 
    {
        get { return _FullName; }
    }

    // ----------------------------------------------------------------------------------
    // ResourceType - what kind of resource did this healthblock check?
    // ----------------------------------------------------------------------------------
    public ResourceTypeEnum ResourceType
    {
        get { return _ResourceType; }
        set { _ResourceType = value; }
    }

    // ----------------------------------------------------------------------------------
    // Critical - does the component have a critical dependency on this healthblock, or is 
    // it more informational?  If it returns RED but is not critical, the status will be 
    // rolled up as YELLOW.
    // ----------------------------------------------------------------------------------
    public bool Critical
    {
        get { return _Critical; }
    }

    // ----------------------------------------------------------------------------------
    // Parameters - the database parameters that were passed into the health block
    // ----------------------------------------------------------------------------------
    public string Parameters
    {
        get { return _Params; }
    }

    // ----------------------------------------------------------------------------------
    // Xml Serialization infrastructure
    // ----------------------------------------------------------------------------------

    public void WriteXml(XmlWriter w)
    {
        w.WriteAttributeString("Name", FriendlyName);
        w.WriteAttributeString("HealthStatus", HealthStatus.ToString());
        
        w.WriteElementString("FullName", FullName);
        w.WriteElementString("ResourceType", ResourceType.ToString());
        w.WriteElementString("Critical", Critical.ToString());
        w.WriteElementString("Parameters", Parameters);
        w.WriteElementString("ElapsedTime", ElapsedTime.ToString()); 

        if (ErrorDetails != null)
        {
            w.WriteElementString("ErrorDetails", ErrorDetails);
        }

        if (ExtendedReport != null)
        {
            try
            {
                // no more "xmlns:xsi" and "xmlns:xsd" attributes
                XmlSerializerNamespaces xsn = new XmlSerializerNamespaces();
                xsn.Add(String.Empty, String.Empty);
                XmlSerializer serializer = new XmlSerializer(ExtendedReport.GetType());

                serializer.Serialize(w, ExtendedReport, xsn);
            }
            catch (Exception e)
            {
                // Seriously, why won't .net give me the REAL exception text instead of a 
                // "can't serialize to XML" generic text?
                w.WriteElementString("Error", e.ToString());
            }

        }

    }

    public void ReadXml(XmlReader reader)
    {
        // we don't support deserialization
    }

    public XmlSchema GetSchema()
    {
        return null;
    }

    // ----------------------------------------------------------------------------------
    // ElapsedTime - how long the health block took to execute. Limited to system timer 
    // granularity, about 15 milliseconds.
    // ----------------------------------------------------------------------------------
    internal TimeSpan ElapsedTime
    {
        get { return _StopTime - _StartTime; }
    }
    
    internal void Start() { _StartTime = DateTime.UtcNow; }
    internal void Stop()  { _StopTime = DateTime.UtcNow; }

    // ----------------------------------------------------------------------------------
    // Private members
    // ----------------------------------------------------------------------------------
    private string                _Params;
    private HealthStatusEnum      _HealthStatus;
    private string                _ErrorDetails;
    private IExtendedHealthReport _ExtendedReport;
    
    private string                _FriendlyName;
    private string                _FullName;
    private ResourceTypeEnum      _ResourceType;
    private bool                  _Critical;
    private DateTime              _StartTime;
    private DateTime              _StopTime;

}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\health\dll\Installer.cs ===
using System.ComponentModel;

using xonline.common.installer;
using xonline.common.mgmt;

namespace xonline.core
{
    [RunInstaller(true)]
    public class CoreInstaller : XomConfiguratorInstall
    {
    }

    [RunInstaller(true)]
    public class CorePerformanceCounterInstaller : XomPerformanceCounterInstall
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\health\dll\HealthBlockManager.cs ===
// 
// HealthBlockManager.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Healthcheck Module
// Xbox Online Service
//
// Provides common healthcheck implementation and utilities.
// 
// Author: kgoodier 3/2008
//

using System;
using System.Collections.Generic;
using System.Reflection;
using System.Data;
using System.Data.SqlClient;
using System.Xml;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;

namespace xonline.common.health
{

// --------------------------------------------------------------------------------------
// HealthBlockManager
//
// Helps in running healthblocks and returning reports.
// --------------------------------------------------------------------------------------
public class HealthBlockManager
{
    static internal void StaticInit(Assembly callingAssembly)
    {
        HealthBlockCache.Init(callingAssembly);
    }

    internal HealthBlockManager()
    {
        _DynamicBlocksToRun = new List<RunnableHealthBlock>();
    }

    // ----------------------------------------------------------------------------------
    // AddBlockToRun - adds a new healthblock to the execution list. They will be run in 
    // breadth-first order.
    // ----------------------------------------------------------------------------------
    public void AddBlockToRun(
        string  blockFriendlyName,
        string  blockFullName,
        string  blockParams,
        bool    critical)
    {
        RunnableHealthBlock block = new RunnableHealthBlock(
            blockFriendlyName,
            blockFullName,
            blockParams,
            critical);
        _DynamicBlocksToRun.Add(block);
    }


    // Internal members below here


    // ----------------------------------------------------------------------------------
    // RunHealthBlock - executes the given healthblock. Will not throw an exception!
    // ----------------------------------------------------------------------------------
    internal HealthReport RunHealthBlock(
        RunnableHealthBlock rhb)
    {
        IHealthBlock block = null;
        HealthReport report = null;

        // Failing by default... harsh!
        report = new HealthReport(rhb.Name, rhb.FullName, ResourceTypeEnum.Unknown, rhb.Critical, rhb.ParamsString);

        block = HealthBlockCache.GetHealthBlock(rhb.FullName);
        if (block == null)
        {
            // Not found.. Bad name?
            report.Fail(String.Format(
                "No block found matching name \"{0}\", class \"{1}\"",
                rhb.Name, rhb.FullName));
            return report;
        }

        // Set found resource type
        report.ResourceType = block.ResourceType;

        // Run it
        try
        {
            report.Start();
            block.DoCheck(this, rhb.Params, report);
        }
        catch (Exception e)
        {
            report.ErrorDetails = e.ToString();
            // Force a warning if the block "forgot" and returned Green
            if (report.HealthStatus == HealthStatusEnum.Green)
            {
                report.HealthStatus = HealthStatusEnum.Yellow;
            }
        }
        finally
        {
            report.Stop();
        }
        return report;
    }

    // ----------------------------------------------------------------------------------
    // GetStaticBlocksToRun - returns a list of healthblocks to run from the database.
    // ----------------------------------------------------------------------------------
    internal List<RunnableHealthBlock> GetStaticBlocksToRun()
    {
        return HealthBlockCache.GetBlocksToRun();
    }

    // ----------------------------------------------------------------------------------
    // GetDynamicBlocksToRun - returns a list of healthblocks to run that were added 
    // dynamically by other healthblocks.
    // ----------------------------------------------------------------------------------
    internal List<RunnableHealthBlock> GetDynamicBlocksToRun()
    {
        List<RunnableHealthBlock> blocks = _DynamicBlocksToRun;
        _DynamicBlocksToRun = new List<RunnableHealthBlock>();
        return blocks;
    }

    private List<RunnableHealthBlock> _DynamicBlocksToRun;

}



// --------------------------------------------------------------------------------------
// HealthBlockCache
//
// Handles finding and instantiating all healthblocks in this assembly and the calling 
// assembly.  
// --------------------------------------------------------------------------------------
static internal class HealthBlockCache
{
    static HealthBlockCache()
    {
        _HealthBlocksByFullName = new Dictionary<string, IHealthBlock>(); 
    }

    // ----------------------------------------------------------------------------------
    // Init - loads the caches. Expected to be called once.
    // ----------------------------------------------------------------------------------
    static internal void Init(Assembly callingAssembly)
    {
        // Reflect
        LoadHealthblocksFromAssembly(Assembly.GetExecutingAssembly());
        if (callingAssembly != null)
        {
            LoadHealthblocksFromAssembly(callingAssembly);
        }
        
        // Get the connection string for the npdb interface from Config and load current 
        // blocks to run for this component. Only supports 1 component for now, though 
        // this could be extended to be a dictionary easily enough.
        _npdbConnectionString = Config.NpdbConnectionString;
        _HealthBlocksFromDb = GetBlocksToRunFromDb(Config.ComponentName);
        
        // Register for change notifications
        Config.HealthMappingsChange += new HealthMappingsChangeEventHandler(OnHealthMappingsChange);
    }

    // ----------------------------------------------------------------------------------
    // RegisterHealthBlock - lets you manually add a new healthblock that is available for 
    // running. This should only be used by the native healthblocks, really, since all 
    // others are expected to be discovered via reflection.
    // ----------------------------------------------------------------------------------
    static internal void RegisterHealthBlock(IHealthBlock block, string fullName)
    {
        _HealthBlocksByFullName[fullName] = block;
    }

    // ----------------------------------------------------------------------------------
    // GetHealthBlock - returns a reference to the health block found in either our 
    // assembly or the calling assembly. This is what we execute. Returns NULL if the name 
    // was not found.
    // ----------------------------------------------------------------------------------
    static internal IHealthBlock GetHealthBlock(string blockFullName)
    {
        IHealthBlock block;
        if (!_HealthBlocksByFullName.TryGetValue(blockFullName, out block))
        {
            return null;
        }
        return block;
    }

    // ----------------------------------------------------------------------------------
    // GetBlocksToRun - returns the current cached list of healthblocks to run from the 
    // npdb..t_health_mappings table.
    // ----------------------------------------------------------------------------------
    static internal List<RunnableHealthBlock> GetBlocksToRun()
    {
        return _HealthBlocksFromDb;
    }

    static public void OnHealthMappingsChange(object sender, EventArgs eventArgs)
    {
        // Something changed (maybe not us, oh well) -- refresh-o-matic
        // As long as we aren't iterating directly over this, we should be able to swap 
        // out the lists atomically without a lock. And since we protect the list with an 
        // accessor, I think we're guaranteed to be safe.
        _HealthBlocksFromDb = GetBlocksToRunFromDb(Config.ComponentName);

        // @@@ event here showing what mappings were reloaded?
    }


    // ----------------------------------------------------------------------------------
    // GetBlocksToRunFromDb - given a component name, retrieve list of healthblocks to run 
    // from the NPDB (t_health_mappings, t_health_blocks).
    // ----------------------------------------------------------------------------------
    static private List<RunnableHealthBlock> GetBlocksToRunFromDb(string component)
    {
        using(SqlConnection sql = new SqlConnection(_npdbConnectionString))
        {
            sql.Open();

            // Parameter: @vc_title_id as string with leading "0x"
            SqlCommand cmd = new SqlCommand("p_health_get_blocks", sql);
            cmd.CommandType = CommandType.StoredProcedure;

            if (component != null)
            {
                cmd.Parameters.Add("@vc_component", SqlDbType.NVarChar).Value = component;
            }

            List<RunnableHealthBlock> returnList = new List<RunnableHealthBlock>();

            using(SqlDataReader reader = cmd.ExecuteReader())
            {
                while (reader.Read())
                {
                    try
                    {
                        RunnableHealthBlock rhb = new RunnableHealthBlock(
                            (string)reader["vc_healthblock"],
                            (string)reader["vc_full_classname"],
                            reader["vc_params"] is DBNull ? null : (string)reader["vc_params"],
                            (bool)reader["b_critical"]);
                        returnList.Add(rhb);
                    }
                    catch (Exception)
                    {
                        // @@@ TODO: event
                    }
                }
            }

            return returnList;
        }
    }


    // ----------------------------------------------------------------------------------
    // LoadHealthblocksFromAssembly - reflect through assembly finding classes that 
    // implement IHealthBlock.
    // ----------------------------------------------------------------------------------
    static private void LoadHealthblocksFromAssembly(Assembly asm)
    {
        Type[] types = asm.GetTypes();
        foreach (Type t in types)
        {
            if (t.IsClass &&
                !t.IsAbstract &&
                t.GetInterface("IHealthBlock") != null)
            {
                ConstructorInfo ci = t.GetConstructor(Type.EmptyTypes);
                if (ci == null)
                {
                    Xom.NtEvent(XEvent.Id.HEALTH_INITIALIZE_BLOCK_FAILED, 
                        "Unable to find default constructor for type {0}", t.FullName
                    );

                    continue;
                }

                object o = null;
                try
                {
                    o = ci.Invoke(Type.EmptyTypes);
                }
                catch (Exception e)
                {
                    Xom.NtEvent(XEvent.Id.HEALTH_INITIALIZE_BLOCK_FAILED, e,
                        "HealthBlock constructor {0}() has thrown an exception", t.FullName
                    );

                    continue;
                }

                // FullName or Name?  If Name, collisions?
                _HealthBlocksByFullName[t.FullName] = (IHealthBlock)o;
            }
        }
    }

    static internal void GetHelpXml(XmlWriter w)
    {
        // Get local pointers since the global ones can get swapped out from underneath 
        // us.
        Dictionary<string, IHealthBlock> blocksByFullName = _HealthBlocksByFullName;
        List<RunnableHealthBlock> blocksFromDb = _HealthBlocksFromDb;

        w.WriteStartElement("HealthBlocks");

        w.WriteStartElement("HealthBlocksAvailable");
        foreach (KeyValuePair<string, IHealthBlock> kvp in blocksByFullName)
        {
            w.WriteElementString("HealthBlock", kvp.Key);
        }
        w.WriteEndElement();  // HealthBlocksAvailable


        w.WriteStartElement("HealthBlocksToRun");
        foreach (RunnableHealthBlock rhb in blocksFromDb)
        {
            w.WriteElementString("HealthBlock", rhb.FullName);
        }
        w.WriteEndElement();  // HealthBlocksToRun 

        w.WriteEndElement();  // HealthBlocks
    }



    // From reflection
    static private Dictionary<string, IHealthBlock>    _HealthBlocksByFullName;

    // From npdb
    static private volatile List<RunnableHealthBlock>  _HealthBlocksFromDb;
    static private string                              _npdbConnectionString;

}


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\health\dll\HealthInterop.cs ===
// 
// HealthInterop.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Healthcheck Module
// Xbox Online Service
//
// Provides COM interfaces for accessing the healthcheck system from native code.
// 
// Author: kgoodier 1/2009
//

using System;
using System.Collections.Specialized;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using System.Threading;

using xonline.common.mgmt;
using xonline.common.service;

namespace xonline.common.health
{

// --------------------------------------------------------------------------------------
// IHealthInterop - COM interface exposed to native components
// --------------------------------------------------------------------------------------

[ComVisible(true)]
[Guid("E223E0D1-E723-4066-A3DC-A7A2D477A35C")]
[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
public interface IHealthInterop
{
    void Initialize(
        string component,
        IntPtr module
        );

    void RegisterNativeHealthBlock(
        INativeHealthBlock nativeHealthBlock,
        string fullName,
        ResourceTypeEnum resourceType
        );

}

// --------------------------------------------------------------------------------------
// IHealthNativeBlock - COM interface to be implemented in native code. This is how to do 
// a native health block.
// --------------------------------------------------------------------------------------
[ComVisible(true)]
[Guid("645B4861-C903-425C-96F5-A2C14480CA1B")]
[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
public interface INativeHealthBlock
{
    // This needs to be implemented in native code. It should look something like this:
    //
    // #import "XblHealthcheck.tlb" raw_interfaces_only, no_smart_pointers
    // using namespace XblHealthcheck;
    //
    // class CCustomHealthBlock:
    //     public CComObjectRoot,
    //     public INativeHealthBlock
    // {
    // public:
    //     BEGIN_COM_MAP(CCustomHealthBlock)
    //         COM_INTERFACE_ENTRY(INativeHealthBlock)
    //     END_COM_MAP()
    // 
    //     CCustomHealthBlock()
    //     {
    //     }
    // 
    //     virtual ~CCustomHealthBlock()
    //     {
    //     }
    // 
    //     virtual HRESULT __stdcall DoCheck(
    //         IN  BSTR bstrBlockParams,
    //         OUT enum HealthStatusEnum *pHealthStatus,
    //         OUT BSTR *pbstrErrorDetails,
    //         OUT BSTR *pbstrExtendedInfo
    //         )
    //     {
    //         CComBSTR bstrExtendedInfo("Test info");
    //         if (!bstrExtendedInfo)
    //         {
    //             return E_OUTOFMEMORY;
    //         }
    // 
    //         *pHealthStatus = HealthStatusEnum_Green;
    //         *pbstrExtendedInfo = bstrExtendedInfo.Detach();
    // 
    //         return S_OK;
    //     }
    // 
    // };
    // 
    // CComPtr<IHealthInterop>               healthInterop;
    // CComObjectNoLock<CCustomHealthBlock>* pHealthBlock;
    // void Test(CComBSTR &bstrCommonConfigComponent)
    // {
    //     HRESULT hr;
    //
    //     pHealthBlock = new CComObjectNoLock<CCustomHealthBlock>();
    //     if (pHealthBlock == NULL)
    //     {
    //         // ... handle errors ...
    //     }
    //     pHealthBlock->AddRef();
    //
    //     hr = healthInterop.CoCreateInstance( __uuidof(HealthInteropImpl) );
    //     // ... handle errors ...
    //     hr = healthInterop->Initialize(bstrCommonConfigComponent);
    //     // ... handle errors ...
    //     hr = healthInterop->RegisterHealthBlock(pHealthBlock, ResourceTypeEnum_Local);
    //     // ... handle errors ...
    // }
    //

    // Note the ResourceType is set in the RegisterHealthBlock() call.

    void DoCheck(
        [MarshalAs(UnmanagedType.BStr)] string blockParams,
                                        out HealthStatusEnum healthStatus,
        [MarshalAs(UnmanagedType.BStr)] out string errorDetails,
        [MarshalAs(UnmanagedType.BStr)] out string extendedInfo);
}

// --------------------------------------------------------------------------------------
// NativeHealthBlockWrapper - provides a clean interface for the managed health block 
// manager to access native health blocks, since those don't have the exact same 
// interface.
//
// Has to be public to make XmlSerializer happy.
// --------------------------------------------------------------------------------------
public class NativeHealthBlockWrapper : IHealthBlock
{
    public class ExtendedNativeReport : IExtendedHealthReport
    {
        public List<string> Info = new List<string>();

        public void Add(string extendedInfo)
        {
            if (extendedInfo == null)
                return;

            // Parse out lines
            string[] lines = extendedInfo.Split(new char[] {'\n'});
            if (lines == null)
                return;

            foreach (string s in lines)
            {
                if (String.IsNullOrEmpty(s))
                    continue;
                Info.Add(s);
            }
        }
    }

    public ResourceTypeEnum ResourceType 
    {
        get { return _ResourceType; }
        set { _ResourceType = value; }
    }

    private INativeHealthBlock _NativeHealthBlock;
    private ResourceTypeEnum   _ResourceType;

    // Don't use this, just to make the HealthBlockManager happy
    public NativeHealthBlockWrapper()
    {
    }

    internal NativeHealthBlockWrapper(INativeHealthBlock nativeHB, ResourceTypeEnum rt)
    {
        _NativeHealthBlock = nativeHB;
        _ResourceType = rt;
    }

    public void DoCheck(
        HealthBlockManager blockManager,
        NameValueCollection blockParams, 
        HealthReport report)
    {
        string paramsString = RunnableHealthBlock.ParseParamsToString(blockParams);
        HealthStatusEnum healthStatus;
        string errorDetails;
        string extendedInfo;

        _NativeHealthBlock.DoCheck(
            paramsString, 
            out healthStatus, 
            out errorDetails, 
            out extendedInfo);

        // Fill out report
        report.HealthStatus = healthStatus;
        report.ErrorDetails = errorDetails;

        if (extendedInfo != null)
        {
            ExtendedNativeReport ex = new ExtendedNativeReport();
            ex.Add(extendedInfo);
            report.ExtendedReport = ex;
        }

    }

}



// --------------------------------------------------------------------------------------
// HealthInterop - provides the entry point and support for native components wanting to 
// use the healthcheck system.
// --------------------------------------------------------------------------------------

[ComVisible(true)]
[Guid("9B8EC82E-1C61-4F1C-B967-CF5944090126")]
[ClassInterface(ClassInterfaceType.None)]
public class HealthInterop : IHealthInterop
{

    private static int _numInterops = 0;
    public HealthInterop()
    {
        // Only if this is the first COM object being created should this be called.
        if (Interlocked.Increment(ref _numInterops) == 1)
        {
            XomLoggingControl.Init();
        }
    }

    // ----------------------------------------------------------------------------------
    // Initialize - must call this to fire up the HttpListener to handle requests.
    //
    // This is exposed via COM.
    // ----------------------------------------------------------------------------------
    public void Initialize(
        string component,
        IntPtr module
        )
    {
        try
        {
            HealthListener.InitializeHealthListener(component, module);
        }
        catch (Exception e)
        {
            Xom.NtEvent(XEvent.Id.HEALTH_INITIALIZE_INTEROP_FAILED, e,
                "Fatal error initializing the health interop for {0}.", component
            );

            throw;
        }
    }

    // ----------------------------------------------------------------------------------
    // RegisterNativeHealthBlock - call to register a native healthblock from native code.
    //
    // This is exposed via COM.
    // ----------------------------------------------------------------------------------
    public void RegisterNativeHealthBlock(
        INativeHealthBlock nativeHealthBlock,
        string fullName,
        ResourceTypeEnum resourceType
        )
    {
        try
        {
            NativeHealthBlockWrapper block = new NativeHealthBlockWrapper(nativeHealthBlock, resourceType);
            HealthBlockCache.RegisterHealthBlock(block, fullName);
        }
        catch (Exception e)
        {
            Xom.NtEvent(XEvent.Id.HEALTH_REGISTERNATIVEHEALTHBLOCK_FAILED, e,
                "Fatal error registering a native health block (" + fullName + ")"
            );

            throw;
        }
    }



}


} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\health\dll\FileUtils.cs ===
﻿// 
// FileUtils.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Healthcheck Module
// Xbox Online Service
//
// This module implements utility methods for file share access common healthblock
//
// Notes:
//
//
using System;
using System.IO;
using System.Text;

namespace xonline.common.health
{
    /// <summary>
    /// Utility class defiming methods for file share access
    /// </summary>
    public static class FileUtils
	{
        /// <summary>
        /// Check if the given file can be opened in the requested mode, access and share
        /// </summary>
        /// <param name="fileSharePath">Name of the path to check the access</param>
        /// <param name="fileShareMode">Requested access mode</param>
        /// <param name="error">Error message if there was any error access the file</param>
        /// <returns>true if the file access is allowed, false otherwise</returns>
        private static bool ProcessFileAccess(string fileSharePath, FileMode fileShareMode, out string error)
        {
            StringBuilder buffer = new StringBuilder();
            bool result = false;

            FileStream fs = null;
            string tempFile = null;

            try
            {
                // check for read access
                DirectoryInfo dir = new DirectoryInfo(fileSharePath);
                if (null != dir)
                {
                    // need to catch the exception so that we can try creating it if it does not exist
                    try
                    {
                        FileInfo[] fi = dir.GetFiles();
                    }
                    catch
                    {
                        buffer.Append(string.Format("Unable to Get File Information for : {0} \n", 
fileSharePath));
                        if (fileShareMode == FileMode.Open)
                        {
                            throw;
                        }
                    }
                }

                // read is ok, now check for write if requested
                // now check for write
                if (fileShareMode != FileMode.Open)
                {
                    try
                    {
                        // try to create dir if it does not exist
                        // we are not creating the full hierarchy, but just the last one
                        if (!Directory.Exists(fileSharePath))
                        {
                            Directory.CreateDirectory(fileSharePath);
                        }
                    }
                    catch (Exception ex)
                    {
                        buffer.Append(string.Format("Unable to create: {0} \n", fileSharePath));
                        buffer.Append("Exception: " + ex.Message + "\n");
                    }
                    
                    tempFile = Path.Combine(fileSharePath, Path.GetRandomFileName());
                    fs = new FileStream( tempFile, FileMode.CreateNew);
                }
                result = true;
            }
            catch ( Exception ex)
            {
                buffer.Append( string.Format("Unable to access: {0} in mode: {1}\n", fileSharePath, fileShareMode));
                buffer.Append( "Exception: " + ex.Message + "\n");
            }
            finally
            {
                if (fs != null)
                {
                    fs.Close();
                    File.Delete(tempFile);
                }
            }
            error = buffer.ToString();
            // Return the file access result
            return result;
        }

        /// <summary>
        /// Check if the given file can be opened for reading
        /// </summary>
        /// <param name="fileSharePath">Name of the file to check the access</param>
        /// <param name="error">Error message if there was any error access the file</param>
        /// <returns>true if the file can be opened in read mode, false otherwise</returns>
        public static bool CheckReadFileAccess(string fileSharePath, out string error)
        {
            return ProcessFileAccess(fileSharePath, FileMode.Open, out error);
        }

        /// <summary>
        /// Check if the given file can be opened for writing
        /// </summary>
        /// <param name="fileSharePath">Name of the file to check the access</param>
        /// <param name="error">Error message if there was any error access the file</param>
        /// <returns>true if the file can be opened in write mode, false otherwise</returns>
        public static bool CheckWriteFileAccess(string fileSharePath, out string error)
        {
            return ProcessFileAccess(fileSharePath, FileMode.Create, out error);
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\health\dll\HealthUtils.cs ===
// 
// HealthUtilities.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Healthcheck Module
// Xbox Online Service
//
// Provides common healthcheck implementation and utilities.
// 
// Author: kgoodier 3/2008
//

using System;
using System.IO;
using System.Text;
using System.Web;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Xml;
using System.Xml.Serialization;
using System.Net;


namespace xonline.common.health
{

// --------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------
public enum OperationEnum
{
    Status,
    Heartbeat,
    LastStatus,
    Help,
    Unknown
}

public enum XslEnum
{
    None,
    Default,
    Help
}

// --------------------------------------------------------------------------------------
// HealthUtils
//
// Handy AND dandy.
// --------------------------------------------------------------------------------------
static internal class HealthUtils
{
    // ----------------------------------------------------------------------------------
    // Constants
    // ----------------------------------------------------------------------------------

    internal const string REQPARAM_XSL          = "xsl";
    internal const string REQPARAM_OPERATION    = "op";
    internal const string REQPARAM_STYLESHEET   = "stylesheet";

    
    // ----------------------------------------------------------------------------------
    // ParseRequestParams
    // ----------------------------------------------------------------------------------
    internal static void ParseRequestParams(
        NameValueCollection nv, 
        out OperationEnum op,
        out XslEnum xsl,
        out bool useStylesheet)
    {
        string val;

        // Name: 
        // 
        //   op
        //
        // Values:  
        //
        //   status
        //   heartbeat
        //   laststatus [default]
        //   help
        //
        
        op = OperationEnum.LastStatus;
        val = nv[HealthUtils.REQPARAM_OPERATION];
        if (String.Compare(val, "status", true) == 0)
        {
            op = OperationEnum.Status;
        }
        else if (String.Compare(val, "heartbeat", true) == 0)
        {
            op = OperationEnum.Heartbeat;
        }
        else if (String.Compare(val, "laststatus", true) == 0)
        {
            op = OperationEnum.LastStatus;
        }
        else if (String.Compare(val, "help", true) == 0)
        {
            op = OperationEnum.Help;
        }
        else if (val != null)
        {
            op = OperationEnum.Unknown;
        }

        // Name: 
        // 
        //   xsl
        //
        // Values:  
        //
        //   <none> [default]
        //   default
        //   help
        //
        
        xsl = XslEnum.None;
        val = nv[HealthUtils.REQPARAM_XSL];
        if (String.Compare(val, "default", true) == 0)
        {
            xsl = XslEnum.Default;
        }
        else if (String.Compare(val, "help", true) == 0)
        {
            xsl = XslEnum.Help;
        }

        // Name: 
        // 
        //   stylesheet
        //
        // Values:  
        //
        //   yes [default]
        //   no
        //
        
        useStylesheet = true;
        val = nv[HealthUtils.REQPARAM_STYLESHEET];
        if (String.Compare(val, "no", true) == 0)
        {
            useStylesheet = false;
        }

    }

    internal static void GetHelpXml(XmlWriter w)
    {
        w.WriteStartElement("Parameters");
        
        // Param: OP
        w.WriteStartElement("Parameter");
        w.WriteAttributeString("Name", HealthUtils.REQPARAM_OPERATION);
        w.WriteElementString("Description", "Controls how the healthcheck is executed and returned to the caller.");

        w.WriteStartElement("ParamValue");
        w.WriteAttributeString("Name", OperationEnum.Status.ToString());
        w.WriteString("Triggers a healthcheck and waits for the response. Returns full XML. Always returns an HTTP 200.");
        w.WriteEndElement();

        w.WriteStartElement("ParamValue");
        w.WriteAttributeString("Name", OperationEnum.Heartbeat.ToString());
        w.WriteString("Asynchronously returns the last health status. Only returns an HTTP 200 or 500. No XML.");
        w.WriteEndElement();

        w.WriteStartElement("ParamValue");
        w.WriteAttributeString("Name", OperationEnum.LastStatus.ToString());
        w.WriteAttributeString("Default", "yes");
        w.WriteString("Asynchronously returns the last health status. Returns full XML. Always returns an HTTP 200.");
        w.WriteEndElement();

        w.WriteStartElement("ParamValue");
        w.WriteAttributeString("Name", OperationEnum.Help.ToString());
        w.WriteString("Returns this help XML for the healthcheck system.");
        w.WriteEndElement();

        w.WriteEndElement();  // Parameter


        // Param: STYLESHEET
        w.WriteStartElement("Parameter");
        w.WriteAttributeString("Name", HealthUtils.REQPARAM_STYLESHEET);
        w.WriteElementString("Description", "Used to enable or disable the use of a stylesheet.");
        
        w.WriteStartElement("ParamValue");
        w.WriteAttributeString("Name", "yes");
        w.WriteAttributeString("Default", "yes");
        w.WriteString("A stylesheet will be used for viewing this healthcheck.");
        w.WriteEndElement();

        w.WriteStartElement("ParamValue");
        w.WriteAttributeString("Name", "no");
        w.WriteString("A stylesheet will not be used for viewing this healthcheck. Useful for viewing the raw XML.");
        w.WriteEndElement();

        w.WriteEndElement();  // Parameter

        
        // Param: XSL
        w.WriteStartElement("Parameter");
        w.WriteAttributeString("Name", HealthUtils.REQPARAM_XSL);
        w.WriteElementString("Description", "Used to retrieve XSL documents automatically by the browser. Not expected for human consumption.");
        
        w.WriteStartElement("ParamValue");
        w.WriteAttributeString("Name", "none");
        w.WriteAttributeString("Default", "yes");
        w.WriteString("When parameter is missing, the XML healthcheck is returned instead of the XSL document.");
        w.WriteEndElement();

        w.WriteStartElement("ParamValue");
        w.WriteAttributeString("Name", XslEnum.Default.ToString());
        w.WriteString("Returns the default XSL document for making the standard healthcheck XML prettier.");
        w.WriteEndElement();

        w.WriteStartElement("ParamValue");
        w.WriteAttributeString("Name", XslEnum.Help.ToString());
        w.WriteString("Returns the XSL document used for viewing the healthcheck \"help\" operation.");
        w.WriteEndElement();

        w.WriteEndElement();  // Parameter



        w.WriteEndElement();  // Parameters

    }


}


// --------------------------------------------------------------------------------------
// SerializableDictionary
//
// Basic generic Dictionary<,> that can be used with XmlSerialize. Borrowed from 
// http://weblogs.asp.net/pwelter34/archive/2006/05/03/444961.aspx.
// --------------------------------------------------------------------------------------
public class SerializableDictionary<TKey, TValue>
    : Dictionary<TKey, TValue>, IXmlSerializable
{
    public System.Xml.Schema.XmlSchema GetSchema()
    {
        return null;
    }

    public void ReadXml(System.Xml.XmlReader reader)
    {
        XmlSerializer keySerializer = new XmlSerializer(typeof(TKey));
        XmlSerializer valueSerializer = new XmlSerializer(typeof(TValue));

        bool wasEmpty = reader.IsEmptyElement;
        reader.Read();

        if (wasEmpty)
            return;

        while (reader.NodeType != System.Xml.XmlNodeType.EndElement)
        {
            reader.ReadStartElement("item");

            reader.ReadStartElement("key");
            TKey key = (TKey)keySerializer.Deserialize(reader);
            reader.ReadEndElement();

            reader.ReadStartElement("value");
            TValue value = (TValue)valueSerializer.Deserialize(reader);
            reader.ReadEndElement();

            this.Add(key, value);

            reader.ReadEndElement();
            reader.MoveToContent();
        }
        reader.ReadEndElement();
    }

    public void WriteXml(System.Xml.XmlWriter writer)
    {
        XmlSerializer keySerializer = new XmlSerializer(typeof(TKey));
        XmlSerializer valueSerializer = new XmlSerializer(typeof(TValue));

        foreach (TKey key in this.Keys)
        {
            writer.WriteStartElement("item");

            writer.WriteStartElement("key");
            keySerializer.Serialize(writer, key);
            writer.WriteEndElement();

            writer.WriteStartElement("value");
            TValue value = this[key];
            valueSerializer.Serialize(writer, value);
            writer.WriteEndElement();

            writer.WriteEndElement();
        }
    }
}


// --------------------------------------------------------------------------------------
// RunnableHealthBlock
//
// A list of these provides the execution plan for our healthcheck calls.
// --------------------------------------------------------------------------------------
internal class RunnableHealthBlock
{
    internal string              Name;
    internal string              FullName;
    internal NameValueCollection Params;
    internal string              ParamsString;
    internal bool                Critical;

    internal RunnableHealthBlock(
        string name, 
        string fullName, 
        string paramsString,
        bool critical)
    {
        Name = name;
        FullName = fullName;
        Params = new NameValueCollection();
        ParamsString = paramsString;
        Critical = critical;

        if (paramsString != null)
        {
            ParseStringToParams(paramsString, Params);
        }
    }

    internal static void ParseStringToParams(string paramsString, NameValueCollection nvParams)
    {
        string[] nameValueArray = paramsString.Split(new char[] { ',' });
        foreach (string nv in nameValueArray)
        {
            string[] s = nv.Split(new char[] { '=' });
            if (s.Length == 1)
            {
                nvParams.Add(s[0].Trim(), null);
            }
            else if (s.Length == 2)
            {
                nvParams.Add(s[0].Trim(), s[1].Trim());
            }
            // @@@ TODO: event here?
        }
    }

    // ----------------------------------------------------------------------------------
    // ParseParamsToString - used to marshal params for the native health blocks.  
    // CXomNameValuePairList is the intended parser of this.
    // ----------------------------------------------------------------------------------
    internal static string ParseParamsToString(NameValueCollection nvParams)
    {
        if (nvParams.AllKeys == null)
        {
            return "";
        }

        StringBuilder sb = new StringBuilder();
        string sep = "";

        foreach (string key in nvParams.AllKeys)
        {

            if (nvParams.GetValues(key) == null)
            {
                sb.Append(sep);
                sep = ",";
                sb.Append(key);
                continue;
            }
            foreach (string val in nvParams.GetValues(key))
            {
                sb.Append(sep);
                sep = ",";
                sb.Append(key + "=" + val);
            }
        }

        return sb.ToString();
    }

}




}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\health\dll\NameValuePair.cs ===
//
// NameValuePair.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Simple Class for exporting data suitable for a webpage
//

using System.Xml.Serialization;

namespace xonline.common.health
{

    // --------------------------------------------------------------------------------------
    // Name Value Pair
    // --------------------------------------------------------------------------------------
    public class NameValuePair
    {
        [XmlAttribute]
        public string Name;

        [XmlAttribute]
        public string Value;

        public NameValuePair()
        {
        }

        public NameValuePair(string n, string v)
        {
            Name = n;
            Value = v;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\health\dll\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\health\dll\HealthListener.cs ===
//
// HealthListener.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Healthcheck Module
// Xbox Online Service
//
// Provides methods for accessing the healthcheck system from native code or managed code
// that doesn't use IIS.
//
// Author: kgoodier 1/2009
//

using System;
using System.Net;
using System.Collections.Generic;
using System.Reflection;

using xonline.common.mgmt;
using xonline.common.service;

namespace xonline.common.health
{

// --------------------------------------------------------------------------------------
// HealthListener - provides a non-IIS solution for handling healthcheck requests.
// Typically used by native components via HealthInterop, but can also be used by non-IIS
// managed services.
// --------------------------------------------------------------------------------------

public class HealthListener
{
    const ushort DEFAULT_LISTENER_PORT = 11000;

    private string       _ExpectedPath;
    private ushort       _ListenerPort;
    private string       _ListenerUrlPrefix;
    private HttpListener _Listener;

    private static List<HealthListener> _HealthListeners;

    // Used for asynchronous I/O in HttpListener stuff
    private class CallbackData
    {
        public HttpListener Listener;
        public string       ExpectedPath;
    }

    static HealthListener()
    {
        _HealthListeners = new List<HealthListener>();
    }

    // ----------------------------------------------------------------------------------
    // Initialize - must call this to fire up the HttpListener to handle requests.
    // ----------------------------------------------------------------------------------
    public static void InitializeHealthListener(
        string component
        )
    {
        InitializeHealthListener(component, Assembly.GetCallingAssembly());
    }

    public static void InitializeHealthListener(
        string component,
        Assembly assembly
        )
    {
        HealthListener hl;
        hl = new HealthListener();
        hl.Initialize(component, assembly);
        _HealthListeners.Add(hl);
    }

    public static void InitializeHealthListener(
        string component,
        IntPtr nativeModule
        )
    {
        HealthListener hl;
        hl = new HealthListener();
        hl.Initialize(component, nativeModule);
        _HealthListeners.Add(hl);
    }

    // ----------------------------------------------------------------------------------
    // CommonInit - common initialization from native and managed services.
    // ----------------------------------------------------------------------------------
    private void CommonInit(
        string component
        )
    {
        // This is the only URL path we'll accept
        _ExpectedPath = String.Format("/{0}/health.ashx", component);

        // @@@kgoodier TODO: implement IP policies to only listen on internal NICs
        _ListenerPort = DEFAULT_LISTENER_PORT;
        _ListenerUrlPrefix = String.Format("http://*:{0}/{1}/", _ListenerPort, component);

        _Listener = new HttpListener();
        _Listener.Prefixes.Add(_ListenerUrlPrefix);
        _Listener.Start();

        // Fire off async http request handler
        CallbackData cd = new CallbackData();
        cd.Listener = _Listener;
        cd.ExpectedPath = _ExpectedPath;
        IAsyncResult result = _Listener.BeginGetContext(new AsyncCallback(ListenerCallback), cd);
    }

    // ----------------------------------------------------------------------------------
    // Initialize - must call this to fire up the HttpListener to handle requests.
    // ----------------------------------------------------------------------------------
    private void Initialize(
        string component,
        Assembly callingAssembly
        )
    {
        CommonInit(component);

        // Doing it here:
        // - sets calling assembly to null, weird xml results
        // - explicit knowledge of errors
        // Not doing it here:
        // - sets calling assembly to "xblhealthcheck", good but dup xml results
        // - health engine errors get swallowed, maybe reported to human caller

        HealthcheckEngine.Initialize(component, callingAssembly);

    }

    // ----------------------------------------------------------------------------------
    // Initialize - must call this to fire up the HttpListener to handle requests.
    // ----------------------------------------------------------------------------------
    private void Initialize(
        string component,
        IntPtr nativeModule
        )
    {
        CommonInit(component);

        HealthcheckEngine.NativeComponentModule = nativeModule;
        HealthcheckEngine.Initialize(component, typeof(HealthListener).Assembly);
    }

    // ----------------------------------------------------------------------------------
    // ListenerCallback - incoming http request callback
    // ----------------------------------------------------------------------------------
    public static void ListenerCallback(IAsyncResult result)
    {
        try
        {
            CallbackData        cd = (CallbackData)result.AsyncState;
            HttpListenerContext context;

            try
            {
                // Fire off new BeginGetContext; this MUST happen, so do it before any possibility
                // of an exception.
                IAsyncResult resultNew = cd.Listener.BeginGetContext(new AsyncCallback(ListenerCallback), cd);

                context = cd.Listener.EndGetContext(result);
            }
            catch (Exception e)
            {
                Xom.NtEvent(XEvent.Id.HEALTH_LISTENER_CALLBACK_REQUEST_FAILED, e,
                    "ListenerCallback (native) failed EndGetContext, exception"
                );

                // Can't do anything without the context object
                return;
            }

            // Check for validity
            if (0 != String.Compare(context.Request.Url.AbsolutePath, cd.ExpectedPath, true))
            {
                WriteHttpResponse(
                    context,
                    (int)HttpStatusCode.NotFound,  // 404
                    "Error",
                    "<h1>Invalid healthcheck URL.</h1><p>Only \"health.ashx\" is allowed.");
                return;
            }

            // All good, feed to healthcheck engine. ProcessRequest is not expected to
            // throw an exception.
            HealthcheckEngine.ProcessRequest(context);
        }
        catch (Exception e)
        {
            try
            {
                Xom.NtEvent(XEvent.Id.HEALTH_LISTENER_CALLBACK_FAILED, e,
                    "ListenerCallback (native) exception"
                );
            }
            catch {};
        }

    }


    // ----------------------------------------------------------------------------------
    // PRIVATE STUFF HERE
    // ----------------------------------------------------------------------------------


    // ----------------------------------------------------------------------------------
    // WriteHttpResponse - makes it easier to send responses using the HttpListener
    // ----------------------------------------------------------------------------------
    private static void WriteHttpResponse(
        HttpListenerContext context,
        int statusCode,
        string htmlTitle,
        string htmlBody)
    {
        string responseString = String.Format("<html><head><title>{0}</title></head><body>{1}</body></html>",
                                              htmlTitle, htmlBody);
        byte[] buffer = System.Text.Encoding.UTF8.GetBytes(responseString);
        context.Response.StatusCode = statusCode;
        context.Response.ContentLength64 = buffer.Length;
        context.Response.OutputStream.Write(buffer, 0, buffer.Length);
        context.Response.OutputStream.Close();
    }



}


} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\health\dll\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\include\dll\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\include\dll\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\health\dll\XblHealthCategory.cs ===
namespace xonline.common.health {
    using System.Diagnostics;

   using xonline.common.mgmt;

   [XomPerformanceCounterCategoryAttr( "HealthCheck", "Xbox Live Health Check Category", true )]
   public class XblHealthCategory : XomPerformanceCounterCategory {
      public static XblHealthCategory Counters = new XblHealthCategory();

      public XblHealthCategory() {

      }

      public XblHealthCategory this[string instance] {
         get { return (XblHealthCategory)GetInstance(instance); }
      }
      
      [XomPerformanceCounterAttr(
         "HealthChecks",
         "Number of health checks done by this resource",
         PerformanceCounterType.NumberOfItems32)]
      public PerformanceCounter HealthChecks;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\include\dll\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_commoninc_none_12.4.56.0_none_e2eea1035af98530
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_commoninc_no-public-key_12.4.56.0_x-ww_16560876
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=commoninc
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_commoninc_no-public-key_12.4.56.0_x-ww_16560876
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_commoninc_no-public-key_12.4.56.0_x-ww_16560876.manifest
XP_MANIFEST_PATH=manifests\msil_commoninc_no-public-key_12.4.56.0_x-ww_16560876.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_commoninc_no-public-key_12.4.56.0_x-ww_16560876.cat
XP_CATALOG_PATH=manifests\msil_commoninc_no-public-key_12.4.56.0_x-ww_16560876.cat
XP_PAYLOAD_PATH=msil_commoninc_no-public-key_12.4.56.0_x-ww_16560876
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=commoninc,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\include\dll\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_commoninc_none_12.4.56.0_none_e2eea1035af98530
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_commoninc_no-public-key_12.4.56.0_x-ww_16560876
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=commoninc
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_commoninc_no-public-key_12.4.56.0_x-ww_16560876
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_commoninc_no-public-key_12.4.56.0_x-ww_16560876.manifest
XP_MANIFEST_PATH=manifests\msil_commoninc_no-public-key_12.4.56.0_x-ww_16560876.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_commoninc_no-public-key_12.4.56.0_x-ww_16560876.cat
XP_CATALOG_PATH=manifests\msil_commoninc_no-public-key_12.4.56.0_x-ww_16560876.cat
XP_PAYLOAD_PATH=msil_commoninc_no-public-key_12.4.56.0_x-ww_16560876
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=commoninc,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\include\frontend\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\include\frontend\FrontEndInstaller.cs ===
using System;
using System.ComponentModel;

using xonline.common.installer;
using xonline.common.mgmt;

namespace xonline.common.feapp
{
    [RunInstaller(true)]
    public class FrontEndInstaller : XomConfiguratorInstall
    {
    }

    [RunInstaller(true)]
    public class FrontEndPerformanceCounterInstaller : XomPerformanceCounterInstall
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\include\frontend\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__feapp_12_none_12.4.56.0_none_d339da89f4fd4b09
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__feapp_12_no-public-key_12.4.56.0_x-ww_d2a10ab3
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_feapp_12
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__feapp_12_no-public-key_12.4.56.0_x-ww_d2a10ab3
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__feapp_12_no-public-key_12.4.56.0_x-ww_d2a10ab3.manifest
XP_MANIFEST_PATH=manifests\x86__feapp_12_no-public-key_12.4.56.0_x-ww_d2a10ab3.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__feapp_12_no-public-key_12.4.56.0_x-ww_d2a10ab3.cat
XP_CATALOG_PATH=manifests\x86__feapp_12_no-public-key_12.4.56.0_x-ww_d2a10ab3.cat
XP_PAYLOAD_PATH=x86__feapp_12_no-public-key_12.4.56.0_x-ww_d2a10ab3
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_feapp_12,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\health\dll\HealthMain.cs ===
// 
// HealthMain.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Healthcheck Module
// Xbox Online Service
//
// Provides common healthcheck implementation and utilities.
// 
// Author: kgoodier 3/2008
//

using System;
using System.Linq;
using System.Text;
using System.Threading;
using System.Web;
using System.Diagnostics;
using System.Collections.Generic;
using System.Xml;
using System.Xml.Serialization;
using System.Reflection;
using System.Net;
using System.Security.Principal;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;

namespace xonline.common.health
{

// --------------------------------------------------------------------------------------
// HealthcheckEngine - main class for handling health requests
// --------------------------------------------------------------------------------------
public static class HealthcheckEngine
{
    // ----------------------------------------------------------------------------------
    // Entry point for IIS requests (front door healthchecks)
    // ----------------------------------------------------------------------------------
    public static void ProcessRequest(
        HttpContext ctx,
        string      component)
    {
        // MUST call GetCallingAssembly from the entry point function, not nested in 
        // another function!
        Interlocked.Increment(ref _NumberOfRequests);
        Initialize(component, Assembly.GetCallingAssembly());

        // Exceptions here should be handled by FEAPP
        using (HttpContextAdapter ctx2 = new HttpContextAdapter(ctx))
        {
            ProcessRequest(ctx2);
        }
    }

    // ----------------------------------------------------------------------------------
    // Entry point for .Net HttpListener requests (native healthchecks)
    // ----------------------------------------------------------------------------------
    internal static void ProcessRequest(
        HttpListenerContext ctx)
    {
        Interlocked.Increment(ref _NumberOfRequests);
        // Don't need to call Initialize(), since we know the HealthListener has already 
        // done that (this is an internal call).

        using (HttpContextAdapter ctx2 = new HttpContextAdapter(ctx))
        {
            try
            {
                // No FEAPP, must handle our own exceptions
                ProcessRequest(ctx2);
            }
            catch (Exception e)
            {
                Xom.NtEvent(XEvent.Id.HEALTH_REQUEST_FAILED, e, "ProcessRequest (native) exception");
                ctx2.Response.Output.Write("FATAL EXCEPTION: " + e.ToString());
            }
        }
    }

    // ----------------------------------------------------------------------------------
    // Private entry point for all requests. Does lots of work.
    // ----------------------------------------------------------------------------------
    private static void ProcessRequest(
        HttpContextAdapter ctx)
    {
        //
        // Parse GET parameters
        //

        OperationEnum op;
        XslEnum xsl;
        bool useStylesheet;
        HealthUtils.ParseRequestParams(ctx.Request.QueryString, out op, out xsl, out useStylesheet);

        if (op == OperationEnum.Help)
        {
            ProcessHelpRequest(ctx, useStylesheet);
            return;
        }

        if (op == OperationEnum.Unknown)
        {
            ctx.Response.StatusCode = (int)HttpStatusCode.BadRequest;  // 400
            return;
        }

        // If an XSL was specified, this is actually IE making a request to us for a 
        // stylesheet. We should return that instead of any other healthcheck thing.
        if (xsl != XslEnum.None)
        {
            ProcessStylesheetRequest(ctx, xsl);
            return;
        }

        if (!_EngineRunning)
        {
            // well then. fire up the thread again? why did it die?
            // @@@ event?
            ctx.Response.StatusCode = 500;
            return;
        }

        // 
        // Synchronous health check requested (first request always counts)?
        //
        if ((op == OperationEnum.Status) ||
            (op == OperationEnum.LastStatus && _CurrentReport.Info.NumberOfHealthcheckIterations == 0))
        {
            _EngineDoneEvent.Reset();
            WaitHandle.SignalAndWait(_EngineStartEvent, _EngineDoneEvent);
        }

        // Return results to client
        if (op == OperationEnum.Heartbeat)
        {
            switch (_CurrentReport.HealthStatus)
            {
            case HealthStatusEnum.Green:
            case HealthStatusEnum.Yellow:
                ctx.Response.StatusCode = 200;
                break;
            case HealthStatusEnum.Red:
                ctx.Response.StatusCode = 500;
                break;
            }
        }
        else 
        {
            ctx.Response.ContentType = "text/xml";
            ctx.Response.StatusCode = 200;  // want to see the output!

            // Serialize xml directly to http response
            XmlSerializerNamespaces xsn = new XmlSerializerNamespaces();
            xsn.Add(String.Empty, String.Empty);
            XmlSerializer serializer = new XmlSerializer(typeof(HealthReportCompilation));

            XmlWriterSettings xmlSettings = new XmlWriterSettings();
            xmlSettings.CheckCharacters = false;
            using(XmlWriter writer = XmlWriter.Create(ctx.Response.Output, xmlSettings))
            {
                // Style sheet
                if (useStylesheet && _Stylesheets.ContainsKey(XslEnum.Default))
                {
                    writer.WriteProcessingInstruction(
                        "xml-stylesheet", 
                        "href='health.ashx?xsl=" + XslEnum.Default.ToString() + "' type='text/xsl'");
                }

                serializer.Serialize(writer, _CurrentReport, xsn);
            }
        }
    }


    // ----------------------------------------------------------------------------------
    // OnSettingChange
    // ----------------------------------------------------------------------------------
    public static void OnSettingChange(object sender, SettingChangeEventArgs args)
    {
        if (args.Setting == Setting.healthcheck_executionPeriodInSeconds)
        {
            _EnginePeriodInSeconds = Int32.Parse(args.ValueNew);
        }
    }

    // ----------------------------------------------------------------------------------
    // GetIdentityInfo
    // ----------------------------------------------------------------------------------
    public static void GetIdentityInfo(out WindowsIdentity id, out bool IsImpersonating)
    {
        id = WindowsIdentity.GetCurrent(true);
        if (id == null)
        {
            IsImpersonating = false;
            id = WindowsIdentity.GetCurrent(false);
        }
        else
        {
            IsImpersonating = true;
        }
    }

    internal static bool IsNativeComponent
    {
        get { return _NativeModulePtr != IntPtr.Zero; }
    }

    internal static IntPtr NativeComponentModule
    {
        get { return _NativeModulePtr; }
        set { _NativeModulePtr = value; }
    }

    public static Assembly CallingAssembly
    {
        get { return _CallingAssembly; }
    }

    // ----------------------------------------------------------------------------------
    // Private methods here 
    // ----------------------------------------------------------------------------------


    // ----------------------------------------------------------------------------------
    // Initialize - performs one-time initialization such as finding available 
    // healthblocks, firing up the background thread, reading settings, etc.
    // ----------------------------------------------------------------------------------
    internal static void Initialize(string component, Assembly callingAssembly)
    {
        if (_IsInitialized)
        {
            return;
        }

        lock (_LockInitialize)
        {
            if (_IsInitialized)
            {
                return;
            }

            _CallingAssembly = callingAssembly;

            // Set initial (bad) report while thread spins up
            HealthReportCompilation hrc = new HealthReportCompilation(
                component, 
                _NumberOfRequests,
                0,
                XomLoggingControl.UpTime);
            hrc.HealthStatus = HealthStatusEnum.Red;
            hrc.ReadyForService = false;
            hrc.Done();
            _CurrentReport = hrc;

            // Reset Config to point to calling component, not us, for overrides and such.
            // Config.SqlApplicationName = component + " healthcheck";
            Config.ComponentName = component;

            // Need this to see our events
            XomLoggingControl.Init();
            
            // Listen for changes
            Config.SettingChange += new SettingChangeEventHandler(OnSettingChange);

            // Load healthblock caches
            HealthBlockManager.StaticInit(callingAssembly);

            // Get settings
            _EnginePeriodInSeconds = Config.GetIntSetting(Setting.healthcheck_executionPeriodInSeconds);

            // Events
            _EngineStartEvent = new EventWaitHandle(true, EventResetMode.ManualReset);  // initially signalled
            _EngineDoneEvent  = new EventWaitHandle(false, EventResetMode.ManualReset); // initially not signalled

            // Fire up background engine thread
            _EngineThread = new XboxLiveThread(new ThreadStart(EngineFunction));
            _EngineThread.IsBackground = true;
            //_EngineThread.Priority = ThreadPriority.BelowNormal;
            _EngineThread.Start();
            _EngineRunning = true;

            // Load xsl stylesheets from resources
            _Stylesheets = LoadStylesheets();

            // We now have a report set that will indicate failure. We can continue 
            // initializing now and let future requests come in. They'll return the bogus 
            // report until a real report is ready.
            _IsInitialized = true;
        }

    }


    // ----------------------------------------------------------------------------------
    // EngineFunction - this thread actually runs the healthchecks. It generally does so 
    // in the background, though it can be performed synchronously by using the 
    // _EngineStartEvent and _EngineDoneEvent events.
    //
    // It is expected this thread never terminates. It would be fatal for it to do so.
    //
    // Also keep in mind that because we run healthchecks on this thread, the 
    // HttpContext.Current is not necessarily available.
    // ----------------------------------------------------------------------------------
    private static void EngineFunction()
    {
        _EngineRunning = true;
        long numberOfIterations = 0;
        Random rand = new Random();
        const double jitterFraction = 0.1;

        while (true)
        {
            try
            {
                // Either wait for the execution period to elapse or wait for an immediate 
                // request.

                int p = _EnginePeriodInSeconds;  // use the value atomically for this loop
                TimeSpan waitTime = new TimeSpan(0, 0, p);

                // A small random jitter on each period ensures that even if all 
                // healthchecks are called at exactly the same time AND they all execute 
                // in the same amount of time, they will be roughly out of sync. We'll add 
                // between 0 and +/- EnginePeriod/20 seconds to the period. This is +/- 
                // 10%.
                TimeSpan jitter = TimeSpan.FromSeconds((rand.NextDouble() * p * jitterFraction) - (p * jitterFraction / 2));
                waitTime = waitTime.Add(jitter);

                _EngineStartEvent.WaitOne(waitTime, false);

                try
                {
                    HealthStatusEnum lastStatus = _CurrentReport.HealthStatus;
                    _CurrentReport = GenerateHealthReport(_NumberOfRequests, ++numberOfIterations);

                    // Don't log event on the very first iteration
                    if (_CurrentReport.HealthStatus != lastStatus && numberOfIterations > 1)
                    {
                        XEvent.Id eventId = 
                            _CurrentReport.HealthStatus == HealthStatusEnum.Green ? XEvent.Id.HEALTH_REPORT_GREEN :
                            _CurrentReport.HealthStatus == HealthStatusEnum.Yellow ? XEvent.Id.HEALTH_REPORT_YELLOW :
                            XEvent.Id.HEALTH_REPORT_RED;
                        Xom.NtEvent(eventId, String.Format(
                                "Health status has changed from {0} to {1}.\r\n{2}",
                                lastStatus,
                                _CurrentReport.HealthStatus,
                                _CurrentReport.ToEventText()));
                    }
                }
                finally
                {
                    _EngineStartEvent.Reset();
                    _EngineDoneEvent.Set();
                }
            }
            catch (ThreadAbortException)
            {
                // perfectly normal when app domain is being unloaded
                _EngineRunning = false;
                return;
            }
            catch (Exception e)
            {
                Xom.NtEvent(XEvent.Id.HEALTH_ENGINE_FAILURE, e,
                    "Unexpected exception encountered during the healthcheck engine's execution. " +
                    "Please escalate to the dev team during normal business hours."
                );
                // resume executing and cross our fingers it wasn't the event that failed
                // @@@ sanity check and/or reset things?  _EnginePeriodInSeconds, 
                // _EngineStartEvent, _EngineDoneEvent?
            }
        }
    }

    // ----------------------------------------------------------------------------------
    // GenerateHealthReport - loops through each healthblock and executes it, adding the 
    // report to the compilation.
    // ----------------------------------------------------------------------------------
    private static HealthReportCompilation GenerateHealthReport(
        long numberOfRequests,
        long numberOfIterations)
    {
        HealthBlockManager blockManager;
        List<RunnableHealthBlock> blocksToRun;

        blockManager = new HealthBlockManager();

        // Fresh results each time
        HealthReportCompilation hrc = new HealthReportCompilation(
            Config.ComponentName, 
            numberOfRequests,
            numberOfIterations,
            XomLoggingControl.UpTime);

        try
        {
            // Run all of the static (from the db) blocks first
            blocksToRun = blockManager.GetStaticBlocksToRun();
            while (blocksToRun.Count > 0)
            {
                foreach (RunnableHealthBlock block in blocksToRun)
                {
                    HealthReport report;
                    report = blockManager.RunHealthBlock(block);
                    hrc.AddReport(report);
                }

                // Run any dynamically added blocks until none are left
                blocksToRun = blockManager.GetDynamicBlocksToRun();
            }
        }
        catch (Exception e)
        {
            hrc.ExtraDetails = "EXCEPTION ENCOUNTERED: " + e.ToString();
        }
        
        hrc.Done();
        return hrc;
    }

    // ----------------------------------------------------------------------------------
    // ProcessStylesheetRequest - handles the request for a stylesheet
    // ----------------------------------------------------------------------------------
    private static void ProcessStylesheetRequest(HttpContextAdapter ctx, XslEnum xsl)
    {
        if (xsl == XslEnum.None || !_Stylesheets.ContainsKey(xsl))
        {
            ctx.Response.StatusCode = (int)HttpStatusCode.BadRequest;  // 400
            return;
        }

        // @@@ TEST ONLY, TAKE THIS OUT BEFORE CHECKIN. We don't want to hit the db on 
        // every request in production.
        // _Stylesheets = LoadStylesheets();

        ctx.Response.ContentType = "text/xsl";
        ctx.Response.StatusCode = 200; 
        ctx.Response.BinaryWrite(_Stylesheets[xsl]);
    }

    // ----------------------------------------------------------------------------------
    // LoadStylesheets - load the xsl blobs from t_config_blobs and map to the enum
    // ----------------------------------------------------------------------------------
    private static Dictionary<XslEnum, byte[]> LoadStylesheets()
    {
        byte[] blob;
        Dictionary<XslEnum, byte[]> stylesheets = new Dictionary<XslEnum, byte[]>();
        
        foreach (string item in Enum.GetNames(typeof(XslEnum)))
        {
            string setting = "healthcheck_xsl_" + item.ToLower();
            blob = Config.GetBlobSetting(setting);
            if (blob != null)
            {
                stylesheets[(XslEnum)Enum.Parse(typeof(XslEnum), item)] = blob;
            }
        }

        return stylesheets;
    }

    // ----------------------------------------------------------------------------------
    // ProcessHelpRequest - handles the request for help
    // ----------------------------------------------------------------------------------
    private static void ProcessHelpRequest(HttpContextAdapter ctx, bool useStylesheet)
    {
        ctx.Response.ContentType = "text/xml";
        ctx.Response.StatusCode = 200;  // want to see the output!

        XmlWriterSettings xmlSettings = new XmlWriterSettings();
        xmlSettings.CheckCharacters = false;
        using (XmlWriter w = XmlWriter.Create(ctx.Response.Output, xmlSettings))
        {
            w.WriteStartDocument();
            if (useStylesheet && _Stylesheets.ContainsKey(XslEnum.Help))
            {
                string x = "href='health.ashx?xsl=" + XslEnum.Help.ToString() + "' type='text/xsl'";
                w.WriteProcessingInstruction("xml-stylesheet", x);
            }
            w.WriteStartElement("HealthcheckHelp");

            // Parameters
            HealthUtils.GetHelpXml(w);

            // Stylesheets
            w.WriteStartElement("Stylesheets");
            foreach (KeyValuePair<XslEnum, byte[]> kvp in _Stylesheets)
            {
                w.WriteStartElement("Stylesheet");
                w.WriteElementString("StylesheetName", kvp.Key.ToString());
                w.WriteElementString("StylesheetSetting", "healthcheck_xsl_" + kvp.Key.ToString().ToLower());
                w.WriteEndElement();
            }
            w.WriteEndElement();  // Stylesheets

            // Healthblocks
            HealthBlockCache.GetHelpXml(w);

            // Settings
            w.WriteStartElement("Settings");
            w.WriteElementString("IsInitialized", _IsInitialized.ToString());
            w.WriteElementString("EnginePeriodInSeconds", _EnginePeriodInSeconds.ToString());
            w.WriteEndElement();  // Settings

            w.WriteEndElement(); // HealthcheckHelp
            w.WriteEndDocument();
        }
    }


    private static volatile HealthReportCompilation  _CurrentReport;

    private static object                   _LockInitialize = new object();
    private static volatile bool            _IsInitialized = false;
    private static long                     _NumberOfRequests = 0;
    private static Assembly                 _CallingAssembly = null;
    private static IntPtr                   _NativeModulePtr = IntPtr.Zero;

    private static XboxLiveThread           _EngineThread = null;
    private static volatile int             _EnginePeriodInSeconds = 0;
    private static EventWaitHandle          _EngineStartEvent = null;
    private static EventWaitHandle          _EngineDoneEvent = null;
    private static bool                     _EngineRunning = false;

    private static Dictionary<XslEnum, byte[]> _Stylesheets = new Dictionary<XslEnum, byte[]>();

}



// --------------------------------------------------------------------------------------
// HealthReportCompilation - holds aggregated results from all the healthblocks
// --------------------------------------------------------------------------------------
[XmlRoot("Healthcheck")]  //, Namespace="http://www.xboxlive.com", IsNullable=false)]
public class HealthReportCompilation // : IXmlSerializable
{
    [XmlAttribute]
    public string                           Name;
    [XmlAttribute]
    public string                           Server;
    [XmlAttribute]
    public HealthStatusEnum                 HealthStatus;
    [XmlAttribute]
    public bool                             ReadyForService;

    public string                           ExtraDetails;

    public HealthcheckExtendedInfo          Info;
    public List<HealthReport>               Reports;
    
    // ----------------------------------------------------------------------------------
    // Constructor (internal use only, for XmlSerializer)
    // ----------------------------------------------------------------------------------
    public HealthReportCompilation()
    {
    }
    
    public HealthReportCompilation(
        string name, 
        long numRequests,
        long numIterations,
        TimeSpan upTime)
    {
        try
        {
            Name                = name;
            Server              = Config.Server;
            ReadyForService     = true;
            HealthStatus        = HealthStatusEnum.Green;
            ExtraDetails        = null;
            Info                = new HealthcheckExtendedInfo();
            Reports             = new List<HealthReport>();
            
            // Set extended info
            Info._StartTime = DateTime.Now;
            Info._ElapsedTime = new TimeSpan(0);

            Info.NumberOfRequests               = numRequests;
            Info.NumberOfHealthcheckIterations  = numIterations;
            Info.UpTime                         = upTime.ToString();
            Info.LastHealthcheckTime            = Info._StartTime.ToString("G");
            Info.ElapsedTime                    = Info._ElapsedTime.ToString();
            Info.ProcessId                      = System.Diagnostics.Process.GetCurrentProcess().Id;

            // Assembly info
            if (HealthcheckEngine.IsNativeComponent)
            {
                Info.CallingAssemblyInfo = CreateNativeAssemblyInfo(HealthcheckEngine.NativeComponentModule);
            }
            else
            {
                Info.CallingAssemblyInfo = CreateAssemblyInfo(HealthcheckEngine.CallingAssembly, true);
            }

            Info.HealthcheckAssemblyInfo = CreateAssemblyInfo(Assembly.GetExecutingAssembly(), true);

            Info.LoadedAssemblyInfo = new List<AssemblyExtendedInfo>();
            foreach (Assembly asm in AppDomain.CurrentDomain.GetAssemblies())
            {
                Info.LoadedAssemblyInfo.Add(CreateAssemblyInfo(asm, false));
            }

            // User identity and groups

            Info.IdentityInfo = CreateIdentityInfo();
        }
        catch (Exception e)
        {
            ExtraDetails = "EXCEPTION ENCOUNTERED: " + e.ToString();
            HealthStatus = HealthStatusEnum.Red;
        }
    }

    private AssemblyExtendedInfo CreateNativeAssemblyInfo(IntPtr module)
    {
        AssemblyExtendedInfo ex = new AssemblyExtendedInfo();

        try
        {
            if (module != IntPtr.Zero)
            {
                ProcessModuleCollection modules = Process.GetCurrentProcess().Modules;

                ProcessModule m = modules.OfType<ProcessModule>().Where(mod => mod.BaseAddress == module).First();

                ex.Name = m.ModuleName;
                ex.FileVersion = m.FileVersionInfo.FileVersion;
                ex.Location = m.FileName;
            }
            else
            {
                ex.Name = "Unknown";
                ex.AssemblyFullname = "Unknown";
            }
        }
        catch (Exception e)
        {
            ex.ExtraDetails = "EXCEPTION ENCOUNTERED: " + e.ToString();
        }

        return ex;
    }

    private AssemblyExtendedInfo CreateAssemblyInfo(Assembly asm, bool fIncludeReferencedAssemblies)
    {
        AssemblyExtendedInfo ex = new AssemblyExtendedInfo();

        try
        {
            if (asm == null)
            {
                ex.Name                 = "Unknown";
                ex.AssemblyFullname     = "Unknown";
                ex.Location             = "";
                ex.FileVersion          = "0.0.0.0";
                ex.ReferencedAssemblies = null;
            }
            else
            {
                ex.Name               = (new AssemblyName(asm.FullName)).Name;
                ex.AssemblyFullname   = asm.FullName;
                if (!String.IsNullOrEmpty(asm.Location))
                {
                    ex.Location           = asm.Location;
                    ex.FileVersion        = FileVersionInfo.GetVersionInfo(asm.Location).FileVersion;
                }

                if (fIncludeReferencedAssemblies)
                {
                    AssemblyName[] refasms = asm.GetReferencedAssemblies();
                    ex.ReferencedAssemblies = Array.ConvertAll<AssemblyName, string>(
                        refasms,
                        delegate(AssemblyName an) { 
                        return an.FullName;
                        });
                }
                else
                {
                    ex.ReferencedAssemblies = null;
                }
            }
        }
        catch (Exception e)
        {
            ex.ExtraDetails = "EXCEPTION ENCOUNTERED: " + e.ToString();
        }

        return ex;
    }

    private IdentityExtendedInfo CreateIdentityInfo()
    {
        IdentityExtendedInfo ex = new IdentityExtendedInfo();

        try
        {
            WindowsIdentity currentIdentity;
            HealthcheckEngine.GetIdentityInfo(out currentIdentity, out ex.IsImpersonating);

            if (currentIdentity == null)
            {
                ex.UserContext = "Could not retrieve current Windows identity.";
                return ex;
            }

            ex.Name = currentIdentity.Name;
            ex.UserContext = currentIdentity.Name;
            ex.UserGroups = new List<string>();

            if (currentIdentity.Groups != null) 
            {
                // currentIdentity.Groups is a collection of SecurityIdentifier instances.
                foreach (IdentityReference idRef in currentIdentity.Groups)
                {
                    NTAccount ntAccount = (NTAccount)idRef.Translate(typeof (NTAccount));
                    ex.UserGroups.Add(string.Format("{0} ({1})", ntAccount.Value, idRef.Value));
                }
            }
        }
        catch (Exception e)
        {
            ex.ExtraDetails = "EXCEPTION ENCOUNTERED: " + e.ToString();
        }

        return ex;
    }

    public void AddReport(HealthReport r)
    {
        // Store it
        Reports.Add(r);

        // Now update state

        // Downgrade overall health status
        //
        // 1. Remote resource, red    -> yellow, ready
        // 2. Remote resource, yellow -> yellow, ready
        // 3. Remote resource, green  -> green,  ready
        // 4. Local resource,  red    -> red,    not ready
        // 5. Local resource,  yellow -> yellow, ready
        // 6. Local resource,  green  -> green,  ready
        //
        // Any non-critical healthblock: red -> yellow
        //

        // Overrides for "red"
        if (r.HealthStatus == HealthStatusEnum.Red)
        {
            if (!r.Critical || r.ResourceType == ResourceTypeEnum.Remote)
            {
                DowngradeStatus(HealthStatusEnum.Yellow);
            }
            else
            {
                DowngradeStatus(HealthStatusEnum.Red);
            }
        }
        else
        {
            // We never remap green or yellow
            DowngradeStatus(r.HealthStatus);
        }

    }

    public void Done()
    {
        Info._ElapsedTime = DateTime.Now - Info._StartTime;
        Info.ElapsedTime = Info._ElapsedTime.ToString();
    }

    public string ToEventText()
    {
        StringBuilder sb = new StringBuilder();
        sb.AppendFormat("HealthCheck results for {0}\r\n", Name);
        sb.AppendFormat("HealthStatus: {0}\r\n", HealthStatus);
        sb.AppendFormat("NumberOfHealthcheckIterations: {0}\r\n", Info.NumberOfHealthcheckIterations);
        sb.AppendFormat("LastHealthcheckTime: {0}\r\n", Info.LastHealthcheckTime);
        sb.AppendFormat("UpTime: {0}\r\n", Info.UpTime);
        sb.AppendFormat("ElapsedTime: {0}\r\n", Info.ElapsedTime);
        sb.AppendFormat("Reports:\r\n");
        foreach (HealthReport r in Reports)
        {
            sb.AppendFormat("{0}: {1} ({2})\r\n", r.FriendlyName, r.HealthStatus, r.ErrorDetails);
        }
        return sb.ToString();
    }

    private void DowngradeStatus(HealthStatusEnum s)
    {
        if (s == HealthStatusEnum.Yellow && this.HealthStatus == HealthStatusEnum.Green)
        {
            this.HealthStatus = s;
        }
        else if (s == HealthStatusEnum.Red)
        {
            this.HealthStatus = s;
            this.ReadyForService = false;
        }
    }
}

public class HealthcheckExtendedInfo
{
    public long         NumberOfRequests;
    public long         NumberOfHealthcheckIterations;
    public string       UpTime;
    public string       LastHealthcheckTime;
    public string       ElapsedTime;
    public int          ProcessId;
    public AssemblyExtendedInfo     CallingAssemblyInfo;
    public AssemblyExtendedInfo     HealthcheckAssemblyInfo;
    public List<AssemblyExtendedInfo> LoadedAssemblyInfo;
    public IdentityExtendedInfo     IdentityInfo;

    // XmlSerializer sux. It won't let me tweak the format of DateTime, and it won't show 
    // TimeSpan at all (?). It also won't serialize a public string accessor (seriously?).  
    // So we have to store these as duplicate strings and manually set those. 
    [XmlIgnore]
    public DateTime    _StartTime;
    [XmlIgnore]
    public TimeSpan    _ElapsedTime;
}

public class AssemblyExtendedInfo
{
    [XmlAttribute]
    public string       Name;
    public string       AssemblyFullname;
    public string       FileVersion;
    public string       Location;
    public string[]     ReferencedAssemblies;
    public string       ExtraDetails;
}

public class IdentityExtendedInfo
{
    [XmlAttribute]
    public string       Name;
    public bool         IsImpersonating;
    public string       UserContext;
    public List<string> UserGroups;
    public string       ExtraDetails;
}


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\include\frontend\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__feapp_12_none_12.4.56.0_none_d339da89f4fd4b09
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__feapp_12_no-public-key_12.4.56.0_x-ww_d2a10ab3
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_feapp_12
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__feapp_12_no-public-key_12.4.56.0_x-ww_d2a10ab3
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__feapp_12_no-public-key_12.4.56.0_x-ww_d2a10ab3.manifest
XP_MANIFEST_PATH=manifests\x86__feapp_12_no-public-key_12.4.56.0_x-ww_d2a10ab3.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__feapp_12_no-public-key_12.4.56.0_x-ww_d2a10ab3.cat
XP_CATALOG_PATH=manifests\x86__feapp_12_no-public-key_12.4.56.0_x-ww_d2a10ab3.cat
XP_PAYLOAD_PATH=x86__feapp_12_no-public-key_12.4.56.0_x-ww_d2a10ab3
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_feapp_12,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\include\frontend\FrontEndApp.cs ===
using System;
using System.Web;
using System.Reflection;
using System.Diagnostics;

using xonline.common.config;
using xonline.common.mgmt;

namespace xonline.common.service 
{
    public class FrontEndApp : FrontEndAppInternal
    {
        public FrontEndApp() : this(true)
        {
        }

        public FrontEndApp(bool fPerApiCounters) : base(fPerApiCounters)
        {
            // This one line must run in assembly of the application
            // and must be  "included"  instead  of  linked  against

            Config.Assembly = Assembly.GetExecutingAssembly();

            // Don't forget this, else FrontEndAppInternal will throw exceptions
            FrontEndAppInternal.FrontEndAppCounters = XrlPerfCounters.Counters;
        }

        public override void Application_Start(object sender, EventArgs e)
        {
            base.Application_Start(sender, e);
	}
    }

    [XomComponentPerformanceCounterCategoryAttr( "XRL" , "Xbox Live Common Per-XRL Counters" )]
    public class XrlPerfCounters : XomPerformanceCounterCategory, IFrontEndAppCounters
    {
        public IFrontEndAppCounters this[string xrl]
        {
            get
            {
                return (XrlPerfCounters) GetInstance(xrl);
            }
        }

        static public XrlPerfCounters Counters = new XrlPerfCounters();

        [XomPerformanceCounterAttr(
             "Requests, Total",
             "Total number of requests",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter _TotalRequests;

        public PerformanceCounter TotalRequests { get { return _TotalRequests; } }

        [XomPerformanceCounterAttr(
             "Requests, In Progress",
             "Number of requests in progress",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter _RequestsInProgress;
        
        public PerformanceCounter RequestsInProgress { get { return _RequestsInProgress; } }

        [XomPerformanceCounterAttr(
             "Requests, Per Sec",
             "Number of requests completed per second",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter _RequestsPerSec;
        
        public PerformanceCounter RequestsPerSec { get { return _RequestsPerSec; } }

        [XomPerformanceCounterAttr(
             "Requests, Avg. Execution Time (in ms)",
             "Average request execution time in the current AppDomain (in ms)",
             PerformanceCounterType.AverageTimer32)]
        public PerformanceCounter _AverageExecutionTime;

        public PerformanceCounter AverageExecutionTime { get { return _AverageExecutionTime; } }

        [XomPerformanceCounterAttr(
             "Requests, Avg. Execution Time Base",
             "Base for the average request execution time in the current AppDomain",
             PerformanceCounterType.AverageBase)]
        public PerformanceCounter _AverageExecutionTimeBase;

        public PerformanceCounter AverageExecutionTimeBase { get { return _AverageExecutionTimeBase; } }

        [XomPerformanceCounterAttr(
             "Failures, Per Sec",
             "Number of failures per second",
             PerformanceCounterType.RateOfCountsPerSecond32)]
        public PerformanceCounter _FailuresPerSecond;

        public PerformanceCounter FailuresPerSecond { get { return _FailuresPerSecond; } }

        [XomPerformanceCounterAttr(
             "Failures, Total",
             "Total number of failures",
             PerformanceCounterType.NumberOfItems64)]
        public PerformanceCounter _FailuresTotal;

        public PerformanceCounter FailuresTotal { get { return _FailuresTotal; } }

        [XomPerformanceCounterAttr(
             "Failures, Percentage",
             "Request failure percentage",
             PerformanceCounterType.SampleFraction)]
        public PerformanceCounter _FailuresPercentage;

        public PerformanceCounter FailuresPercentage { get { return _FailuresPercentage; } }

        [XomPerformanceCounterAttr(
             "Failures, Percentage Base",
             "Base for the prequest failure percentage",
             PerformanceCounterType.SampleBase)]
        public PerformanceCounter _FailuresPercentageBase;

        public PerformanceCounter FailuresPercentageBase { get { return _FailuresPercentageBase; } }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\include\health\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\include\health\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__health_9_none_12.4.56.0_none_a3810cc9c3cd0375
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__health_9_no-public-key_12.4.56.0_x-ww_7ac3bfeb
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_health_9
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__health_9_no-public-key_12.4.56.0_x-ww_7ac3bfeb
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__health_9_no-public-key_12.4.56.0_x-ww_7ac3bfeb.manifest
XP_MANIFEST_PATH=manifests\x86__health_9_no-public-key_12.4.56.0_x-ww_7ac3bfeb.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__health_9_no-public-key_12.4.56.0_x-ww_7ac3bfeb.cat
XP_CATALOG_PATH=manifests\x86__health_9_no-public-key_12.4.56.0_x-ww_7ac3bfeb.cat
XP_PAYLOAD_PATH=x86__health_9_no-public-key_12.4.56.0_x-ww_7ac3bfeb
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_health_9,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\include\health\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__health_9_none_12.4.56.0_none_a3810cc9c3cd0375
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__health_9_no-public-key_12.4.56.0_x-ww_7ac3bfeb
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_health_9
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__health_9_no-public-key_12.4.56.0_x-ww_7ac3bfeb
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__health_9_no-public-key_12.4.56.0_x-ww_7ac3bfeb.manifest
XP_MANIFEST_PATH=manifests\x86__health_9_no-public-key_12.4.56.0_x-ww_7ac3bfeb.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__health_9_no-public-key_12.4.56.0_x-ww_7ac3bfeb.cat
XP_CATALOG_PATH=manifests\x86__health_9_no-public-key_12.4.56.0_x-ww_7ac3bfeb.cat
XP_PAYLOAD_PATH=x86__health_9_no-public-key_12.4.56.0_x-ww_7ac3bfeb
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_health_9,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\include\health\BaseHealthRequest.cs ===
using System;
using System.IO;
using System.Text;
using System.Web;
using System.Web.Caching;
using System.Diagnostics;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;

using xonline.common.config;
using xonline.common.service;
using xonline.common.mgmt;

namespace xonline.common.health
{

// --------------------------------------------------------------------------------------
//
// Entry point for the healthcheck request. This needs to compile into the application, 
// since we want ProcessRequest() to load the application, not hit the xblhealthcheck.dll 
// directly. 
//
// --------------------------------------------------------------------------------------

public class BaseHealthRequest : IHttpHandler
{

    // ----------------------------------------------------------------------------------
    // Rest of implementation is below here. You can ignore it.
    // ----------------------------------------------------------------------------------

    // IHttpHandler method
    public virtual void ProcessRequest( HttpContext ctx )
    {
        // Have to pass in everything that lives in this assembly/component
        xonline.common.health.HealthcheckEngine.ProcessRequest(
            ctx,
            Config.ComponentName);
    }

    // IHttpHandler method
    public bool IsReusable
    {
        get { return true; }
    }


    // ----------------------------------------------------------------------------------
    // Helpers for the health stuff
    // ----------------------------------------------------------------------------------



}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\ingestionutils\content\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\ingestionutils\content\AvatarItemBin.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Threading;
using System.Security.Cryptography;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.config;


namespace xonline.common.content
{
    public class AvatarItemBin : IXICPackage
    {
        private string path;
        private UInt32 titleId;

        public AvatarItemBin(string path, UInt32 titleId)
        {
            this.path = path;
            this.titleId = titleId;
        }

        #region IXICPackage Members

        public string Path
        {
            get { return this.path; }
        }

        public string GetFullCDNSharePath(string Server)
        {
            // bug fix 36289
            // all CDN paths & filenames need to be lower case
            return String.Format("{0}{1:x8}\\avataritems\\{2}",
                    Server,
                    this.titleId,
                    System.IO.Path.GetFileName(this.path)).ToLowerInvariant();
        }

        #endregion

        /// <summary>
        /// Public Method to sign an Avatar Item .Bin file. A temporary directory is needed, in which the signed .bin file will be put.
        /// The original .bin file will not be changed.
        /// </summary>
        /// <param name="tempDirectory">Temporary directory must exist.</param>
        /// <param name="fileNameToSign"></param>
        /// <param name="assetId">Asset Id of avatar item to be added before signing</param>
        /// <returns>Full path to the signed .bin file</returns>
        public static string SignFile(string tempDirectory, string fileNameToSign, Guid assetId)
        {
            return SignFile(tempDirectory, fileNameToSign, assetId, null);
        }

        /// <summary>
        /// Public Method to sign an Avatar Item .Bin file. A temporary directory is needed, in which the signed .bin file will be put.
        /// The original .bin file will not be changed.
        /// </summary>
        /// <param name="tempDirectory">Temporary directory must exist.</param>
        /// <param name="fileNameToSign"></param>
        /// <param name="assetId">Asset Id of avatar item to be added before signing</param>
        /// <param name="newFileName">Name of the new bin file that will be signed</param>
        /// <returns>Full path to the signed .bin file</returns>
        public static string SignFile(string tempDirectory, string fileNameToSign, Guid assetId, string newFileName)
        {
            if (String.IsNullOrEmpty(tempDirectory))
                throw new ArgumentException("tempDirectory");
            if (String.IsNullOrEmpty(fileNameToSign))
                throw new ArgumentException("fileNameToSign");

            if (!File.Exists(fileNameToSign))
                throw new ArgumentException("File to sign doesn't exist");

            byte[] bytesInAssetIdRaw = assetId.ToByteArray();

            // the asset id is needed in big endian format
            // but the ToByteArray method uses little endian for Data1(_a), Data2(_b) and Data 3 (_c)
            // in the code below
            //    return new byte[] { ((byte) this._a), ((byte) (this._a >> 8)), ((byte) (this._a >> 0x10)), ((byte) (this._a >> 0x18)), ((byte) this._b), ((byte) (this._b >> 8)), ((byte) this._c), ((byte) (this._c >> 8)), this._d, this._e, this._f, this._g, this._h, this._i, this._j, this._k };
            // We need to swap the bytes for _a (DWORD), _b(WORD) and _c(WORD)
            byte[] bytesInAssetId = new Byte[]
                {
                    bytesInAssetIdRaw[3], bytesInAssetIdRaw[2], bytesInAssetIdRaw[1], bytesInAssetIdRaw[0], // _a
                    bytesInAssetIdRaw[5], bytesInAssetIdRaw[4], // _b
                    bytesInAssetIdRaw[7], bytesInAssetIdRaw[6], // _c
                    bytesInAssetIdRaw[8],  // _d
                    bytesInAssetIdRaw[9],  // _e
                    bytesInAssetIdRaw[10], // _f
                    bytesInAssetIdRaw[11], // _g
                    bytesInAssetIdRaw[12], // _h
                    bytesInAssetIdRaw[13], // _i
                    bytesInAssetIdRaw[14], // _j
                    bytesInAssetIdRaw[15]  // _k
                };

            byte[] bytesInFile = ReadBytes(fileNameToSign);

            List<Byte> list = new List<Byte>(bytesInAssetId.Length + bytesInFile.Length);
            list.AddRange(bytesInAssetId);
            list.AddRange(bytesInFile);
            
            byte[] input = list.ToArray();

            string fileNameSigned = null;

            // call Xsig to sign it
            uint hr = HResult.S_OK;

            // Build the request to send to xsig.
            GetSignedHeaderRequest request = new GetSignedHeaderRequest();
            request.fileSize = (uint)input.Length;
            request.fileType = GetSignedHeaderRequest.ONLY_LEGAL_FILE_TYPE;
            request.fileHash = GetFileHash(input);

            // Call accross to xsig.
            GetSignedHeaderResponse response = new GetSignedHeaderResponse();
            XRLObject2 xrlo = response;
            hr = XRLUtil.PostXrlRequest(VirtualInterface.xsig_int, request.Xrl, null, request, ref xrlo);

            // Do some error checking on the response.
            if (HResult.Failed(hr))
            {
                throw new Exception(String.Format("Proxy call to xsig failed with hresult {0:X8}. Check event viewer for error.", hr));
            }

            if (response.headerSize != response.header.Length)
            {
                throw new Exception(String.Format(
                    "Actual size of the header returned ({0}) is different than the headerSize returned ({1}). That's fishy.",
                    response.header.Length, response.headerSize));
            }

            // write signed header and the original file bytes to a temporary file
            if (String.IsNullOrEmpty(newFileName))
            {
                fileNameSigned = System.IO.Path.Combine(tempDirectory, System.IO.Path.GetFileName(fileNameToSign));
            }
            else
            {
                fileNameSigned = System.IO.Path.Combine(tempDirectory, newFileName);
            }

            using (FileStream fs = new FileStream(fileNameSigned, FileMode.Create))
            {
                using (BinaryWriter writer = new BinaryWriter(fs))
                {
                    // write header
                    writer.Write(response.header);
                    // write bytes from original file
                    writer.Write(input);
                }
            }

            return fileNameSigned;
        }

        /// <summary>
        /// Returns the file specified as a byte array.
        /// </summary>
        /// <param name="fileName">Name of the file to open</param>
        /// <returns></returns>
        public static byte[] ReadBytes(string fileName)
        {
            if (String.IsNullOrEmpty(fileName))
                throw new ArgumentNullException("fileName");
            if (!File.Exists(fileName))
                throw new ArgumentException(String.Format("File {0} does not exist.", fileName));

            byte[] bytesRead = null;

            FileInfo fileInfo = new FileInfo(fileName);
            using (FileStream fileStream = new FileStream(fileName, FileMode.Open, FileAccess.Read))
            {
                using (BinaryReader reader = new BinaryReader(fileStream))
                {
                    bytesRead = reader.ReadBytes((int)fileInfo.Length);
                }
            }

            return bytesRead;
        }

        /// <summary>
        /// Returns the SHA1Managed hash of the specified byte array (from a file).
        /// </summary>
        /// <param name="file">byte array</param>
        /// <returns></returns>
        public static byte[] GetFileHash(byte[] file)
        {
            if (file == null)
                throw new ArgumentNullException("file");

            byte[] hash = null;
            using (SHA1Managed sha1Managed = new SHA1Managed())
            {
                hash = sha1Managed.ComputeHash(file);
            }

            return hash;
        }

        #region constants
        public readonly static string FileExtension = ".bin";
        public readonly static string MarketplaceBinFileName = "asset.bin";
        public readonly static string ACPFileExtension = ".acp";

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\ingestionutils\content\IXICPackage.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Threading;

namespace xonline.common.content
{
    public interface IXICPackage
    {
        string Path { get; }

        string GetFullCDNSharePath(string server);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\ingestionutils\content\ContentInstaller.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Threading;
using System.Globalization;
using System.Text;
using System.Runtime.InteropServices;
using Microsoft.Webstore.WstClient;
using xonline.common.protocol;
using xonline.common.config;
using xonline.common.service;
using xonline.common.sql.sqlclient;
using xonline.common.tools.stutilcore;
using xonline.common.title;

namespace xonline.common.content
{
    public abstract class PackageInstaller
    {
        static PackageInstaller()
        {
#region TargetHelperCodeInit
            // Init Interface/VirtualInterface Helper Arrays
            TargetIfaces[0] = Interface.None;
            TargetIfaces[1] = VirtualInterface.uodb;

            // Init Database TargetType Helper Arrays
            TargetTypes[0] = TargetType.unknown;
            TargetTypes[1] = TargetType.webstore;

            // Init Database Target names Helper Arrays
            TargetDBs[0] = TargetDB.unknown; // not used, but makes things cleaner/safer, so Index Zero data is ignored, since some of the Enums are Bitwise
            TargetDBs[1] = TargetDB.uodb;
#endregion
        }

        /// <summary>
        /// Target Databases to Prop.
        /// </summary>
        public enum TargetDB
        {
            unknown    = 0x00,
            uodb       = 0x01,
            all        = 0xff   // important, bitwise!!!
        }

#region TargetHelperCode
        public enum TargetType
        {
            unknown     = 0x00,
            webstore    = 0x01,
            sql         = 0x02
        }

        private const int maxTypes = 3;

        private static string[] TargetIfaces = new string[maxTypes];

        private static TargetType[] TargetTypes = new TargetType[maxTypes];

        private static TargetDB[] TargetDBs = new TargetDB[maxTypes];
#endregion

        private static TargetDB target = TargetDB.all; // not thread-safe. this is dangerous, but this class is only used in single-threaded LiveOffer utility

        /// <summary>
        /// The Target DataStore
        /// </summary>
        public static TargetDB Target
        {
            get
            {
                return target;
            }
            set
            {
                target = value;
            }
        }

        #region overridable methods

        public
        virtual
        bool
        Preinstall(
            XICPackage Package,
            string[]   ContentFiles,
            string     RedirecteePackage,
            string[]   ManifestFiles
            )
        {
            return true;
        }

        public
        virtual
        bool
        InternalInstall(
            XICPackage Package,
            string[]   ContentFiles,
            string     RedirecteePackage,
            string[]   ManifestFiles
            )
        {
            return true;
        }

        public virtual Guid? GameContentMediaId
        {
            get
            {
                return null;
            }
        }

        #endregion

        public
        bool
        Install(
            XICPackage Package,
            string[]   ContentFiles,
            string     RedirecteePackage,
            string[]   ManifestFiles
            )
        {
            Console.WriteLine("[Installer] Invoking pre-install ...");
            if (!Preinstall(Package, ContentFiles, RedirecteePackage, ManifestFiles))
            {
                return false;
            }

            Console.WriteLine("[Installer] Writing to uodb ...");
            if (!InternalInstall(Package, ContentFiles, RedirecteePackage, ManifestFiles))
            {
                return false;
            }
            return true;
        }

        #region static methods

        public
        static
        void
        ExecuteStoredProc(
            string StoredProc,
            SqlParameter[] Parameters
            )
        {
            for (int i = 0; i < maxTypes; ++i)
            {
                if (0 != ((int) target & (int) TargetDBs[i]))
                {
                    switch(TargetTypes[i])
                    {
                        case TargetType.webstore:
                            ExecuteVirtualInterfaceStoredProc(
                                TargetIfaces[i],
                                StoredProc,
                                Parameters
                                );
                            break;
                        case TargetType.sql:
                            ExecuteInterfaceStoredProc(
                                TargetIfaces[i],
                                StoredProc,
                                Parameters
                                );
                            break;
                        default: // no-op at this point. should never get here.
                            break;
                    }
                }
            }
        }

        public
        static
        void
        ExecuteVirtualInterfaceStoredProc(
            string viface,
            string StoredProc,
            SqlParameter[] Parameters
            )
        {
            ArrayList               ParamList               = new ArrayList();
            StringBuilder           ProcInfo                = new StringBuilder();
            IVirtualInterfaceInfo   viInfo                  = Config.GetVirtualInterface(viface, Site.main);
            string                  WebStoreApplicationName = viInfo.WebstoreApp;

            for (int c = 0; c < Parameters.Length; ++c)
            {
                ParamList.Add( Parameters[c] );
            }

            try {
                ExecuteWebstoreNonQuery(
                    WebStoreApplicationName,
                    ParamList,
                    StoredProc,
                    ref ProcInfo
                    );
            }
            catch (Exception e)
            {
                throw new Exception(
                    String.Format(
                        "Query execute failed -- {0}",
                        ProcInfo.ToString()
                        ),
                    e
                    );
            }
        }

        public
        static
        void
        ExecuteVirtualInterfaceStoredProcQuery(
            string viface,
            string StoredProc,
            SqlParameter[] Parameters
            )
        {
            IVirtualInterfaceInfo viInfo = Config.GetVirtualInterface(viface, Site.main);
            string WebStoreApplicationName = viInfo.WebstoreApp;

            try
            {
                using (WstConnection conn = new WstConnection(WebStoreApplicationName))
                {
                    conn.Open();
                    using (WstCommand cmd = conn.CreateCommand())
                    {
                        cmd.CommandType = CommandType.StoredProcedure;
                        cmd.CommandText = StoredProc;
                        cmd.WstFailoverMode = WstFailoverMode.PrimaryThenSecondary;
                        cmd.PartitionType = WstPartitionType.Logical;
                        cmd.Partition = WstCommand.AnyPartition;

                        foreach (SqlParameter param in Parameters)
                        {
                            cmd.Parameters.Add(param);
                        }

                        cmd.ExecuteNonQuery();
                    }
                }
            }
            catch (Exception e)
            {
                throw new Exception(
                    String.Format(
                        "Query execute failed -- rError Calling" +
                        StoredProc +
                        ": " +
                        e.Message +
                        "\n\r Stack: " +
                        e.StackTrace
                        )
                    );
            }
        }

        public
        static
        void
        ExecuteInterfaceStoredProc(
            string         iface,
            string         StoredProc,
            SqlParameter[] Parameters
            )
        {
            SqlClient client = new SqlClient(iface);

            using (client)
            {
                client.StoredProc = StoredProc;

                foreach(SqlParameter param in Parameters)
                {
                    client.Command.Parameters.Add(param);
                }

                try
                {
                    client.ExecuteNonQuery();
                }
                catch
                {
                    throw;
                }
            }
        }

        public
        static
        string
        XRLPath(
            XICPackage Package,
            string location
            )
        {
            return location + String.Format("{0:x8}/", Package.TitleID) +
                Package.XCPName;
        }

        public
        static
        string
        XRLManifestPath(
            string location,
            string configName,
            short  build,
            short  qfe,
            int    revision
            )
        {
            return location + String.Format("{0}/{1}/{2}/{3}", configName, build, qfe, revision);
        }

        public
        static
        string
        SourceManifestPath(
            string location,
            string configName,
            short  build,
            short  qfe,
            int    revision
            )
        {
            return location + String.Format("{0}\\{1}\\{2}\\{3}", configName, build, qfe, revision);
        }

        public
        static
        string
        XRLRedirecteePath(
            string location,
            string configName,
            ushort build,
            string redirecteeFilename
            )
        {
            return location + String.Format("{0}/{1}/{2}", configName, build, redirecteeFilename);
        }

        public
        static
        string
        SourceRedirecteeDirectory(
            string location,
            string configName,
            ushort build
            )
        {
            return location + String.Format(@"{0}\{1}", configName, build);
        }

        //NOTE:
        //  all calls must be for Webstore DB's
        //  all calls must be NonQuery
        //  all procedures called must have "set" semantic not additive
        //  (i.e. repeated calls with same params will not change configuration )
        public
        static
        void
        ExecuteWebstoreNonQuery(
            string            applicationName,
            ArrayList         paramList,
            string            procName,
            ref StringBuilder procInfo
            )
        {

            int partitionCount;
            //get partition count
            using (WstConnection conn = new WstConnection(applicationName))
            {
                conn.Open();
                partitionCount = conn.SqlPartitions.Count;
            }

            ArrayList connectionList = new ArrayList();
            ArrayList commandList    = new ArrayList();

            try
            {
                //open a connection for each partition
                for (int physicalPartition = 0; physicalPartition < partitionCount; ++physicalPartition)
                {

                    WstConnection conn = new WstConnection(applicationName);
                    conn.Open();

                    //Hold on to this connection for later
                    connectionList.Add(conn);

                    //  Set up the command
                    WstCommand cmd = new WstCommand(
                        procName,                   //name of the stored procedure
                        conn,                       //connection
                        physicalPartition,
                        WstFailoverMode.PrimaryOnly
                        );

                    //Hold on to this command for later
                    commandList.Add(cmd);

                    cmd.CommandType = CommandType.StoredProcedure;
                    cmd.PartitionType = WstPartitionType.Physical;

                    //this should prevent changes to the original parameter set
                    foreach (SqlParameter sp in paramList)
                    {
                        SqlParameter paramCopy = new SqlParameter(
                            sp.ParameterName,
                            sp.SqlDbType,
                            sp.Size,
                            sp.Direction,
                            sp.IsNullable,
                            sp.Precision,
                            sp.Scale,
                            sp.SourceColumn,
                            sp.SourceVersion,
                            sp.Value
                            );
                        cmd.Parameters.Add(paramCopy);
                    } // copy params

                    try
                    {
                        cmd.ExecuteNonQuery();
                    }
                    catch (Exception e)
                    {
                        string errString = "\n\rError Calling " +
                            procName +
                            " on ptn " +
                            physicalPartition +
                            ": " +
                            e.Message +
                            "\n\r Stack: " +
                            e.StackTrace;
                        procInfo.Append(errString);
                        throw;
                    }
                }// for each partition

                //if all commands execute ok, commit all transactions
                foreach (WstCommand cmd in commandList)
                {
                    cmd.Parameters.Clear();
                }

            }
            finally
            {
                //task: assumes auto-rollback on close  is this the case??
                foreach (WstConnection conn in connectionList)
                {
                    conn.Close();
                }
            }
        }

        #endregion
    }

    public class ContentInstaller : PackageInstaller
    {
    }

    public class GamerTileInstaller : ContentInstaller
    {
        protected static uint defXboxId = 1;
        protected static uint defUserId = 1;

        private
        static
        string
        GetLargeTileName(
            string SmallTileName
            )
        {
            return Path.GetDirectoryName(SmallTileName) +
                "\\64" +
                Path.GetFileName(SmallTileName).Substring(2);
        }

        public
        static
        bool
        IsSmallTileName(string TileName)
        {
            if (Path.GetFileName(TileName).Substring(0, 2) == "32")
            {
                return true;
            }
            return false;
        }

        public
        static
        uint
        GetTileID(
            string TileName
            )
        {
            string IdString;

            //Format 32_[TITLEID ]0001[TILE]
            IdString = Path.GetFileName(TileName).Substring(15, 4);
            return uint.Parse(IdString, NumberStyles.HexNumber);
        }

        public
        override
        bool
        Preinstall(
            XICPackage Package,
            string[]   ContentFiles,
            string     RedirecteePackage,
            string[]   ManifestFiles
            )
        {
            uint CurrentTile;

            foreach (string ContentFile in ContentFiles)
            {
                if (IsSmallTileName(ContentFile))
                {

                    try
                    {
                        CurrentTile = GetTileID(ContentFile);
                    }
                    catch (Exception e)
                    {
                        Console.WriteLine(
                            "[Installer] GetTileID FAILED\n\r\tFile: {0}\n\tException: {1}",
                            ContentFile,
                            e.Message
                            );
                        return false;
                    }

                    string smallTilePath = String.Format("//global/t:{0:x8}/tile/0/1{1:x4}", Package.TitleID, CurrentTile);
                    string largeTilePath = String.Format("//global/t:{0:x8}/tile/0/2{1:x4}", Package.TitleID, CurrentTile);
                    string smallTileFile = ContentFile;
                    string largeTileFile = GetLargeTileName(ContentFile);

                    try {
                        StUtil.Write(
                            defUserId,
                            defXboxId,
                            smallTilePath,
                            Package.TitleID,
                            true,
                            smallTileFile
                            );
                        StUtil.Write(
                            defUserId,
                            defXboxId,
                            largeTilePath,
                            Package.TitleID,
                            true,
                            largeTileFile
                            );
                        CurrentTile++;
                    }
                    catch
                    {
                        return false;
                    }
                }
            }

            return true;
        }

        public
        static
        uint
        GetStartingID(
            UInt32 TitleID
            )
        {
            uint                start = 0, count = 100;
            uint                max = 0x7FFF;
            string              Path = String.Format("//global/t:{0:x8}/tile/0/*", TitleID);
            RepEnumerateFiles[] files;

            while (true)
            {
                uint end = start + count;
                HResult hr;

                try
                {
                    hr = EnumerateFiles(TitleID, defXboxId, defUserId, Path, start, end, out files);
                }
                catch
                {
                    return 0;
                }

                uint tileId;

                if ( HResult.Failed(hr) )
                {
                     return 0;
                }

                if (files.Length == 0)
                {
                    break;
                }

                start += (uint)files.Length;

                foreach (RepEnumerateFiles file in files)
                {
                    string filePath = file.ToString();
                    int Mark = filePath.LastIndexOf('/');

                    if (-1 == Mark)
                    {
                        return 0;
                    }

                    //Id = 1[id] or 2[id] so ignore the first digit (note mark is currently on /)
                    tileId = uint.Parse(
                        filePath.Substring(Mark + 2),
                        NumberStyles.HexNumber
                        );
                    if (tileId > max)
                    {
                        max = tileId;
                    }
                }

                if (max >= 0xFFFF)
                {
                    return 0;
                }
            }

            return max+1;
        }

        public
        static
        HResult
        EnumerateFiles(
                uint                titleId,
                ulong               xboxId,
                ulong               userId,
                string              path,
                uint                start,
                uint                end,
            out RepEnumerateFiles[] files
            )
        {
            files = null;

            ReadFileToken t  = new ReadFileToken();
            t._operation = (ushort) Operation.FileEnumerate;
            t._version = AccessToken.accessTokenVersion;
            t._serviceId = 0;
            t._userPuid = userId;
            t._xboxPuid = xboxId;

            t._pathName = path;

            t._tokenExpirationDate = 0;
            t._signatureSize = 0;

            ReqEnumerateFiles msg    = new ReqEnumerateFiles();
            msg._titleId             = titleId;
            msg._titleVersion        = 1;
            msg._resultsStart        = start;
            msg._resultsEnd          = end;
            msg._ifModifiedSinceDate = 0;
            msg._accessToken         = t;
            msg._userCountryId       = 103;

            MemoryStream memStream   = new MemoryStream();
            BinaryWriter writer      = new BinaryWriter(memStream);
            msg.WriteTo(writer);

            byte[] reqbuf = memStream.ToArray();
            HResult hr = HResult.S_OK;

            XrlRequest req = new XrlRequest();
            req.TargetVirtualInterface= VirtualInterface.stfd_storage_int;
            req.PostData = reqbuf;

            HTTPAuthData authdata = new HTTPAuthData(
                0,
                0,
                0,
                xboxId,
                userId,
                titleId,
                (uint)XOService.Storage,
                0
                );
            authdata.OverrideXUsers[0].dwUserFlags = 0x00006700;
            authdata.OverrideTitleVersion = 1;

            req.AuthData = authdata.GetBase64EncodedString();
            req.Path = msg.GetXRL();

            hr = req.Send();

            if ( HResult.Succeeded(hr) )
            {
                memStream = new MemoryStream(req.ResponseData);
                BinaryReader reader = new BinaryReader(memStream);

                uint totalFiles = reader.ReadUInt32();
                uint numFiles = reader.ReadUInt32();
                files = new RepEnumerateFiles[numFiles];

                for (int i = 0; i < numFiles; ++i)
                {
                    files[i] = new RepEnumerateFiles();
                    files[i].ReadFrom(reader);
                }
            }

            return hr;
        }
    }

    public class AvatarItemInstaller : ContentInstaller
    {
        private Guid? avatarAssetId = null;
        private UInt16 categoryMask = 0;
        private UInt32 subcategoryMask = 0;
        private byte bodyMask = 0;

        [DllImport("AvatarBinParser.dll", BestFitMapping = false, ThrowOnUnmappableChar = true)]
        [return: MarshalAs(UnmanagedType.I1)]
        static extern Boolean ParseAssetMetadata(
            [MarshalAs(UnmanagedType.LPStr)]
            [In] String fileName,
            ref UInt16 categoryMask,
            ref byte bodyTypeMask,
            ref UInt32 subcategory);

        public override Guid? GameContentMediaId
        {
            get
            {
                return avatarAssetId;
            }
        }

        public Guid? AvatarAssetId
        {
            get
            {
                return avatarAssetId;
            }
            set
            {
                this.avatarAssetId = value;
            }
        }

        public UInt16 CategoryMask
        {
            get { return this.categoryMask; }
        }

        public UInt32 SubcategoryMask
        {
            get { return this.subcategoryMask; }
        }

        public byte BodyMask
        {
            get { return this.bodyMask; }
        }

        public override bool Preinstall(
            XICPackage Package,
            string[] ContentFiles,
            string   RedirecteePackage,
            string[] ManifestFiles
            )
        {
            if (!this.GameContentMediaId.HasValue)
            {
                Console.WriteLine("ERROR: missing AvatarAssetId in content.xbx that is needed for this content type.");
                return false;
            }

            bool isAssetBinFound = false;
            List<string> imageFiles = new List<string>();
            
            foreach (string ContentFile in ContentFiles)
            {
                if (IsAvatarBinFile(ContentFile))
                {
                    string avatarItemPath = ContentFile;
                    string signedAvatarItemPath = null;

                    isAssetBinFound = true;
                    categoryMask = 0;
                    subcategoryMask = 0;
                    bodyMask = 0;

                    if (!ParseAssetMetadata(avatarItemPath, ref categoryMask, ref bodyMask, ref subcategoryMask))
                    {
                        throw new Exception("Failed to parse the asset.bin file contained in the content package. Make sure it is a valid avatar .bin file.");
                    }

                    // use the same temporary directory where the files were extracted
                    string tempDirectory = Path.GetDirectoryName(ContentFile);

                    // process Avatar Item guid1
                    try
                    {
                        signedAvatarItemPath = AvatarItemBin.SignFile(
                            tempDirectory,
                            avatarItemPath,
                            this.GameContentMediaId.Value,
                            this.GameContentMediaId + AvatarItemBin.FileExtension);
                    }
                    catch (Exception e)
                    {
                        Console.WriteLine("ERROR: failed to sign file " + avatarItemPath + " with " + e.ToString());
                        return false;
                    }

                    AvatarItemBin avatarItemBin = new AvatarItemBin(signedAvatarItemPath, Package.TitleID);

                    XICDistributer distributer = new XICDistributer();
                    if (!distributer.DistributePackage(avatarItemBin, true /*overwrite*/))
                    {
                        Console.WriteLine("ERROR: Avatar Items distribution failed.");
                        return false;
                    }
                }
                else if (IsAvatarPngFile(ContentFile))
                {
                    // add to list of images to be propped
                    // can't prop it here because we need to guid to be generated
                    // and the ContentFiles can be in any order
                    imageFiles.Add(ContentFile);
                }
            }

            // here we should have generated the avatar asset id and we can prop the images
            if (!isAssetBinFound)
            {
                Console.WriteLine("ERROR: asset.bin file was not present in content package.");
                return false;
            }

            if (imageFiles.Count > 0)
            {
                foreach (string imageFile in imageFiles)
                {
                    string suffix = null;
                    string filename = Path.GetFileName(imageFile).ToLower();
                    switch (filename)
                    {
                        case "icon.png":
                            suffix = AvatarItemImageProp.MediumIconSuffix;
                            break;
                        case "icon-64.png":
                            suffix = AvatarItemImageProp.SmallIconSuffix;
                            break;
                        case "icon-300.png":
                            suffix = AvatarItemImageProp.LargeIconSuffix;
                            break;
                        default:
                            // optional pngs
                            if (filename.StartsWith("detail"))
                            {
                                try
                                {
                                    // optional images will follow this format: detail#.png (where # is 0-9)
                                    string imageNumberString = Path.GetFileNameWithoutExtension(filename).Replace("detail", String.Empty);
                                    UInt16 imageNumber = UInt16.Parse(imageNumberString);
                                    if (imageNumber < 10)
                                        suffix = imageNumber.ToString();
                                }
                                catch (Exception)
                                {
                                    // if filename is not following the predefined format, don't add it to storage
                                    suffix = null;
                                }
                            }
                            // ignore other images
                            break;
                    }

                    if (!String.IsNullOrEmpty(suffix))
                    {
                        AvatarItemImageProp avatarItemImageProp = new AvatarItemImageProp(Package.TitleID.ToString("X"), this.GameContentMediaId.Value, imageFile, suffix);
                        if (!avatarItemImageProp.PropToStorage())
                        {
                            return false;
                        }
                    }
                }
            }

            return true;
        }

        private bool IsAvatarBinFile(string filename)
        {
            return (Path.GetFileName(filename) == AvatarItemBin.MarketplaceBinFileName);
        }

        private bool IsAvatarPngFile(string filename)
        {
            return (Path.GetExtension(filename) == ".png");
        }
    }

    public class UpdaterInstaller : PackageInstaller
    {
        public
        override
        bool
        InternalInstall(
            XICPackage Package,
            string[]   ContentFiles,
            string     RedirecteePackage,
            string[]   ManifestFiles
            )
        {
            try
            {
                Guid            betaGroupId;
                PlatformTypes   platformType = (PlatformTypes)Package.Platform;
                ConsoleTypeEnum consoleType;
                string          platformConfigName;

                switch (platformType)
                {
                case PlatformTypes.PC:
                    platformConfigName = "panorama";
                    consoleType = ConsoleTypeEnum.PC;
                    break;
                case PlatformTypes.Xenon:
                    platformConfigName = "xenon";
                    consoleType = ConsoleTypeEnum.Xenon;
                    break;
                default:
                    throw new Exception("Invalid platform type found in metadata.");
                }

                if(Package.VersionFlag == 1)
                {
                    betaGroupId = new Guid("1A75281C-6B30-4BA8-80C6-66B339F2BA89");
                }
                else
                {
                    betaGroupId = Guid.Empty;
                }

                DownloadServerList dsl = new DownloadServerList();
                int rank = 0;
                int TitleID;
                bool result;
                ushort updateBuildVersion = (ushort)(Package.UpdateVersion >> 8);

                unchecked
                {
                    TitleID = (int)Package.TitleID;
                }

                result = p_svc_insert_title_versions(
                    TitleID,
                    (int)Package.BaseVersion,
                    (int)Package.UpdateVersion,
                    consoleType,
                    betaGroupId
                    );
                if (result == false)
                {
                    return false;
                }

                result = p_svc_insert_title_update_packages(
                    Package.ContentID,
                    TitleID,
                    (int)Package.BaseVersion,
                    (int)Package.UpdateVersion,
                    (int)Package.PackageSize,
                    (int)Package.InstallSize,
                    Package.SymmetricKey,
                    Package.PublicKey,
                    consoleType
                    );
                if (result == false)
                {
                    return false;
                }

                foreach (string location in dsl.XRLLocations)
                {
                    result = p_svc_insert_title_update_locations(
                        TitleID,
                        (int)Package.BaseVersion,
                        (int)Package.UpdateVersion,
                        rank,
                        PackageInstaller.XRLPath(Package, location),
                        consoleType
                        );
                    if (result == false)
                    {
                        return false;
                    }
                    rank++;
                }

                // Do more work depending on if we have a redirectee package
                if (RedirecteePackage != null)
                {
                    string redirecteePackageFileName = Path.GetFileName(RedirecteePackage);
                    // Copy the redirectee package to the final destination.
                    foreach (string location in dsl.ShareNames)
                    {
                        string shareTarget = PackageInstaller.SourceRedirecteeDirectory(
                            location, platformConfigName, updateBuildVersion);
                        if (!Directory.Exists(shareTarget))
                        {
                            Console.WriteLine(
                                "[Installer] Creating Redirectee Directory {0}...",
                                shareTarget
                                );
                            Directory.CreateDirectory(shareTarget);
                        }

                        string targetFile = Path.Combine(shareTarget, redirecteePackageFileName);

                        if (File.Exists(targetFile))
                        {
                            Console.WriteLine(
                                "[Installer] Overwritting Redirectee Package {0}",
                                targetFile
                                );
                            File.Copy(RedirecteePackage, targetFile, true);
                        }
                        else
                        {
                            Console.WriteLine(
                                "[Installer] Installing Redirectee Package {0}",
                                targetFile
                                );
                            File.Copy(RedirecteePackage, targetFile, false);
                        }
                    }

                    // update the uodb for this redirectee package
                    InstallRedirecteePackage(Package, RedirecteePackage, dsl, platformConfigName);
                }

                // Do more work depending on if we have manifest files
                if (ManifestFiles != null && ManifestFiles.Length > 0)
                {
                    // We already validated the manifest previously, but
                    // we need to reload it to obtain the build and qfe fields
                    SystemManifest  manifest = new SystemManifest(
                        ManifestFiles[0],
                        Package.UpdateVersion
                        );
                    if (manifest.ValidateManifest() == false)
                    {
                        Console.WriteLine("ERROR: Manifest couldn't be validated");
                        return false;
                    }

                    // Copy the package files to their final destination.
                    // This is done before the NPDB tables are updated
                    // in order to make sure that the clients won't
                    // try to access them before they are present.
                    foreach (string location in dsl.ShareNames)
                    {
                        string shareTarget = PackageInstaller.SourceManifestPath(
                            location,
                            platformConfigName,
                            manifest.Build,
                            manifest.Qfe,
                            manifest.Revision
                            );
                        if (!Directory.Exists(shareTarget))
                        {
                            Console.WriteLine(
                                "[Installer] Creating Manifest Directory {0}...",
                                shareTarget
                                );
                            Directory.CreateDirectory(shareTarget);
                        }

                        foreach (string file in ManifestFiles)
                        {
                            string targetFile = System.IO.Path.Combine(
                                shareTarget,
                                System.IO.Path.GetFileName(file)
                                );

                            if (File.Exists(targetFile))
                            {
                                Console.WriteLine(
                                    "[Installer] Overwritting Manifest File {0}",
                                    targetFile
                                    );
                                File.Copy( file, targetFile, true );
                            }
                            else
                            {
                                Console.WriteLine(
                                    "[Installer] Installing Manifest File {0}",
                                    targetFile
                                    );
                                File.Copy( file, targetFile, false );
                            }
                        }
                    }

                    // We have enough information at this point to write
                    // the current manifest revision to the NPDB tables
                    result = p_live_registry_set_setting(
                        platformConfigName,
                        "CurrentManifestRevision",
                        manifest.Build,
                        manifest.Qfe,
                        betaGroupId,
                        manifest.Revision.ToString()
                        );
                    if (result == false)
                    {
                        return false;
                    }

                    // Create PackageUriRootX entries starting from 1
                    int i = 1;
                    foreach (string location in dsl.XRLLocations)
                    {
                        string xrlTarget = PackageInstaller.XRLManifestPath(
                            location,
                            platformConfigName,
                            manifest.Build,
                            manifest.Qfe,
                            manifest.Revision
                            );
                        result = p_live_registry_set_setting(
                            platformConfigName,
                            "PackageUriRoot" + i.ToString(),
                            manifest.Build,
                            manifest.Qfe,
                            betaGroupId,
                            xrlTarget
                            );
                        if (result == false)
                        {
                            return false;
                        }
                        i++;
                    }
                }
            }
            catch (Exception)
            {
                return false;
            }

            return true;
        }

        private
        bool
        InstallRedirecteePackage(
            XICPackage Package,
            string RedirecteePackage,
            DownloadServerList dsl,
            string platformConfigName
            )
        {
            try
            {
                PlatformTypes platformType = (PlatformTypes)Package.Platform;
                ConsoleTypeEnum consoleType;

                switch (platformType)
                {
                    case PlatformTypes.Xenon:
                        consoleType = ConsoleTypeEnum.Xenon;
                        break;
                    default:
                        throw new Exception("Invalid platform type found in metadata.");
                }

                int rank = 0;
                int TitleID = unchecked((int) 0xFFFE07D1);
                ushort UpdateBuildVersion = (ushort)(Package.UpdateVersion >> 8);
                ulong SuOfferID = ((ulong)TitleID << 32) | 0xAAAA0000 | UpdateBuildVersion;
                bool result;

                //
                // Parse the RedirecteePackage file name and obtain the content ID.
                //

                byte[] redirecteePackageContentID = new byte[20];
                string redirecteePackageFileName = Path.GetFileName(RedirecteePackage);
                if (redirecteePackageFileName.Length != "su".Length + 2 * redirecteePackageContentID.Length + ".cab".Length)
                {
                    throw new Exception("Invalid redirectee package file name: " + redirecteePackageFileName);
                }
                else
                {
                    for (int i = 0; i < redirecteePackageContentID.Length; i++)
                    {
                        redirecteePackageContentID[i] = byte.Parse(redirecteePackageFileName.Substring("su".Length + 2 *i, 2), NumberStyles.HexNumber);
                    }
                }

                //
                // If the offer already exists, make sure it's an unrestricted offer.
                //
                ConsoleTypeEnum ConsoleType;
                DateTime StartDate;
                DateTime EndDate;
                int OfferTypeID;
                int OfferFrequencyID;
                bool Cancelable;
                int EsrbID;
                int BitFilter;
                int InstallSize;
                int PackageSize;
                byte[] SymKey;
                int PolicyFlags;
                string BillingComponentID;
                string FriendlyName;
                short GlobalOfferDetails;
                byte[] PubKey;
                int TierID;
                uint ReturnValue;

                result = p_xbos_load_offer(
                    SuOfferID,
                    out ConsoleType,
                    out StartDate,
                    out EndDate,
                    out OfferTypeID,
                    out OfferFrequencyID,
                    out Cancelable,
                    out EsrbID,
                    out BitFilter,
                    out InstallSize,
                    out PackageSize,
                    out SymKey,
                    out PolicyFlags,
                    out BillingComponentID,
                    out FriendlyName,
                    out GlobalOfferDetails,
                    out PubKey,
                    out TierID,
                    out ReturnValue
                    );
                if (result == false)
                {
                    return false;
                }
                else
                {
                    if (ReturnValue == 0 && (PolicyFlags & 4) == 0)
                    {
                        throw new Exception(string.Format("Offer 0x{0:X} already exists as a restricted offer.", SuOfferID));
                    }
                }

                result = p_svc_insert_content(
                    redirecteePackageContentID,
                    0,                              // InstallSize,     not used
                    0,                              // PackageSize,     not used
                    new byte[16],                   // SymmetricKey,    not used
                    new byte[284],                  // PublicKey,       not used
                    "System Update Content Package " + UpdateBuildVersion.ToString()
                    );
                if (result == false)
                {
                    return false;
                }

                foreach (string location in dsl.XRLLocations)
                {
                    result = p_svc_insert_content_locations(
                        redirecteePackageContentID,
                        rank,
                        PackageInstaller.XRLRedirecteePath(location, platformConfigName, UpdateBuildVersion, redirecteePackageFileName)
                        );
                    if (result == false)
                    {
                        return false;
                    }
                    rank++;
                }

                result = p_svc_insert_offers(
                    TitleID,
                    SuOfferID,
                    0,                                                      // EsrbID,              not used,   All
                    false,                                                  // Cancelable,          not used
                    0,                                                      // PackageSize,         not used
                    0,                                                      // InstallSize,         not used
                    new byte[16],                                           // SymKey,              not used
                    0,                                                      // BitFilter,           not used
                    "",                                                     // BillingComponentID,  not used
                    2,                                                      // OfferTypeID,         not used,   Premium Content
                    0,                                                      // OfferFrequencyID,    not used,   Non-Terminating
                    new DateTime(2000, 1, 1),                               // StartDate,           not used
                    new DateTime(3001, 1, 1),                               // EndDate,             not used
                    "System Update Offer " + UpdateBuildVersion.ToString(), // FriendlyName,        not used
                    new byte[284],                                          // PubKey,              not used
                    4,                                                      // PolicyFlags,         must be 4,  unstricted
                    consoleType,                                            // ConsoleType,         not used
                    redirecteePackageContentID                              // ContentID
                    );
                if (result == false)
                {
                    return false;
                }
            }
            catch (Exception e)
            {
                Console.WriteLine(
                    "[Installer] Unable to install package: '{0}'",
                    e.Message
                    );
                return false;
            }

            return true;
        }

        public
        static
        bool
        p_svc_insert_title_update_packages(
            byte[]          ContentID,
            int             TitleID,
            int             BaseVersion,
            int             UpdateVersion,
            int             PackageSize,
            int             InstallSize,
            byte[]          SymKey,
            byte[]          PubKey,
            ConsoleTypeEnum consoleType
            )
        {
            if ((null == ContentID) || (null == SymKey) || (null == PubKey))
            {
                return false;
            }

            if (ContentID.Length != PackageInstallerLogic.ContentIDLength)
            {
                return false;
            }

            if (SymKey.Length > PackageInstallerLogic.MaxSymKeyLength)
            {
                return false;
            }

            if (PubKey.Length > PackageInstallerLogic.MaxPubKeyLength)
            {
                return false;
            }

            try
            {
                SqlParameter[] Parameters = new SqlParameter[]
                {
                    new SqlParameter("@b_content_id", SqlDbType.Binary, PackageInstallerLogic.ContentIDLength),
                    new SqlParameter("@i_title_id", TitleID),
                    new SqlParameter("@i_title_base_version", BaseVersion),
                    new SqlParameter("@i_title_update_version", UpdateVersion),
                    new SqlParameter("@i_package_size", (int)Math.Min(PackageSize, 0xFFFFFFFFL)),
                    new SqlParameter("@i_install_size", (int)Math.Min(InstallSize, 0xFFFFFFFFL)),
                    new SqlParameter("@vb_update_sym_key", SqlDbType.VarBinary, PackageInstallerLogic.MaxSymKeyLength),
                    new SqlParameter("@vb_public_key", SqlDbType.VarBinary, PackageInstallerLogic.MaxPubKeyLength),
                    new SqlParameter("@ti_console_type_id", (byte)consoleType)
                };

                Parameters[0].Value = ContentID;
                Parameters[6].Value = SymKey;
                Parameters[7].Value = PubKey;

                PackageInstaller.ExecuteVirtualInterfaceStoredProc(
                    VirtualInterface.uodb,
                    "dbo.p_svc_insert_title_update_packages",
                    Parameters
                    );
            }
            catch (Exception e)
            {
                Console.WriteLine(
                    "[Installer] p_svc_insert_title_update_packages FAILED '{0}'",
                    e.Message
                    );
                return false;
            }
            return true;
        }

        public
        static
        bool
        p_svc_insert_title_update_locations(
            int             TitleID,
            int             BaseVersion,
            int             UpdateVersion,
            int             Rank,
            string          XRL,
            ConsoleTypeEnum consoleType
            )
        {
            if (null == XRL)
            {
                return false;
            }

            if (XRL.Length > PackageInstallerLogic.MaxXRLLength)
            {
                return false;
            }

            try
            {
                SqlParameter[] Parameters = new SqlParameter[]
                {
                    new SqlParameter("@i_title_id", TitleID),
                    new SqlParameter("@i_title_base_version", BaseVersion),
                    new SqlParameter("@i_title_update_version", UpdateVersion),
                    new SqlParameter("@i_location_rank", Rank),
                    new SqlParameter("@vc_XRL", XRL),
                    new SqlParameter("@ti_console_type_id", (byte)consoleType)
                };

                PackageInstaller.ExecuteVirtualInterfaceStoredProc(
                    VirtualInterface.uodb,
                    "dbo.p_svc_insert_title_update_locations",
                    Parameters
                    );
            }
            catch (Exception e)
            {
                Console.WriteLine(
                    "[Installer] p_svc_insert_title_update_locations FAILED '{0}'",
                    e.Message
                    );
                return false;
            }
            return true;
        }

        public
        static
        bool
        p_svc_insert_title_versions(
            int             TitleID,
            int             BaseVersion,
            int             UpdateVersion,
            ConsoleTypeEnum consoleType,
            Guid            betaGroupId
            )
        {
            try
            {
                SqlParameter[] Parameters = new SqlParameter[]
                {
                    new SqlParameter("@i_title_id", TitleID),
                    new SqlParameter("@i_base_version", BaseVersion),
                    new SqlParameter("@i_new_version", UpdateVersion),
                    new SqlParameter("@uid_beta_group_id", betaGroupId),
                    new SqlParameter("@ti_console_type_id", (byte)consoleType)
                };

                PackageInstaller.ExecuteVirtualInterfaceStoredProc(
                    VirtualInterface.uodb,
                    "dbo.p_svc_insert_title_versions",
                    Parameters
                    );
            }
            catch (Exception e)
            {
                Console.WriteLine(
                    "[Installer] p_svc_insert_title_versions FAILED '{0}'",
                    e.Message
                    );
                return false;
            }
            return true;
        }

        public
        static
        bool
        p_live_registry_set_setting(
            string  clientConfig,
            string  setting,
            short   build,
            short   qfe,
            Guid    betaGroupId,
            string  value
            )
        {
            try
            {
                SqlParameter[] Parameters = new SqlParameter[]
                {
                    new SqlParameter("@vc_environment",   Config.Environment),
                    new SqlParameter("@vc_client_config", clientConfig),
                    new SqlParameter("@vc_setting",       setting),
                    new SqlParameter("@si_build",         build),
                    new SqlParameter("@si_qfe",           qfe),
                    new SqlParameter("@guid_beta_group_id", betaGroupId),
                    new SqlParameter("@vc_value",         value)
                };

                PackageInstaller.ExecuteInterfaceStoredProc(
                    Interface.npdb,
                    "dbo.p_live_registry_set_setting",
                    Parameters
                    );
            }
            catch (Exception e)
            {
                Console.WriteLine(
                    "[Installer] p_live_registry_set_setting FAILED '{0}'",
                    e.Message
                    );
                return false;
            }
            return true;
        }

        public
        static
        bool
        p_svc_insert_content(
            byte[] ContentID,
            int InstallSize,
            int PackageSize,
            byte[] SymKey,
            byte[] PubKey,
            string FriendlyName
            )
        {
            if ((null == ContentID) || (null == SymKey) || (null == PubKey))
            {
                return false;
            }

            if (ContentID.Length != PackageInstallerLogic.ContentIDLength)
            {
                return false;
            }

            if (SymKey.Length > PackageInstallerLogic.MaxSymKeyLength)
            {
                return false;
            }

            if (PubKey.Length > PackageInstallerLogic.MaxPubKeyLength)
            {
                return false;
            }

            try
            {
                SqlParameter[] Parameters = new SqlParameter[]
                {
                    new SqlParameter("@b_content_id", SqlDbType.Binary, PackageInstallerLogic.ContentIDLength),
                    new SqlParameter("@i_install_size", (int)Math.Min(InstallSize, 0xFFFFFFFFL)),
                    new SqlParameter("@i_package_size", (int)Math.Min(PackageSize, 0xFFFFFFFFL)),
                    new SqlParameter("@vb_sym_key", SqlDbType.VarBinary, PackageInstallerLogic.MaxSymKeyLength),
                    new SqlParameter("@vb_public_key", SqlDbType.VarBinary, PackageInstallerLogic.MaxPubKeyLength),
                    new SqlParameter("@vc_friendly_name", FriendlyName)
                };

                Parameters[0].Value = ContentID;
                Parameters[3].Value = SymKey;
                Parameters[4].Value = PubKey;

                PackageInstaller.ExecuteVirtualInterfaceStoredProc(
                    VirtualInterface.uodb,
                    "dbo.p_svc_insert_content",
                    Parameters
                    );
            }
            catch (Exception e)
            {
                Console.WriteLine(
                    "[Installer] p_svc_insert_content FAILED '{0}'",
                    e.Message
                    );
                return false;
            }
            return true;
        }

        public
        static
        bool
        p_svc_insert_content_locations(
            byte[] ContentID,
            int Rank,
            string XRL
            )
        {
            if (null == XRL)
            {
                return false;
            }

            if (ContentID.Length != PackageInstallerLogic.ContentIDLength)
            {
                return false;
            }

            if (XRL.Length > PackageInstallerLogic.MaxXRLLength)
            {
                return false;
            }

            try
            {
                SqlParameter[] Parameters = new SqlParameter[]
                {
                    new SqlParameter("@b_content_id", SqlDbType.Binary, PackageInstallerLogic.ContentIDLength),
                    new SqlParameter("@i_location_rank", Rank),
                    new SqlParameter("@vc_XRL", XRL),
                };

                Parameters[0].Value = ContentID;

                PackageInstaller.ExecuteVirtualInterfaceStoredProc(
                    VirtualInterface.uodb,
                    "dbo.p_svc_insert_content_locations",
                    Parameters
                    );
            }
            catch (Exception e)
            {
                Console.WriteLine(
                    "[Installer] p_svc_insert_content_locations FAILED '{0}'",
                    e.Message
                    );
                return false;
            }
            return true;
        }

        public
        static
        bool
        p_svc_insert_offers(
            int TitleID,
            ulong OfferID,
            int EsrbID,
            bool Cancelable,
            int PackageSize,
            int InstallSize,
            byte[] SymKey,
            int BitFilter,
            string BillingComponentID,
            int OfferTypeID,
            int OfferFrequencyID,
            DateTime StartDate,
            DateTime EndDate,
            string FriendlyName,
            byte[] PubKey,
            int PolicyFlags,
            ConsoleTypeEnum consoleType,
            byte[] ContentID
            )
        {
            if ((null == SymKey) || (null == PubKey))
            {
                return false;
            }

            if (ContentID.Length != PackageInstallerLogic.ContentIDLength)
            {
                return false;
            }

            if (SymKey.Length > PackageInstallerLogic.MaxSymKeyLength)
            {
                return false;
            }

            if (PubKey.Length > PackageInstallerLogic.MaxPubKeyLength)
            {
                return false;
            }

            try
            {
                unchecked
                {
                    SqlParameter[] Parameters = new SqlParameter[]
                    {
                        new SqlParameter("@i_title_id", TitleID),
                        new SqlParameter("@bi_offer_id", (long)OfferID),
                        new SqlParameter("@i_ESRB_id", EsrbID),
                        new SqlParameter("@b_cancelable", Cancelable ? 1 : 0),
                        new SqlParameter("@i_package_size", PackageSize),
                        new SqlParameter("@i_install_size", InstallSize),
                        new SqlParameter("@vb_sym_key", SymKey),
                        new SqlParameter("@i_bitfilter", BitFilter),
                        new SqlParameter("@vc_billing_svc_component_id", BillingComponentID),
                        new SqlParameter("@i_offer_type_id", OfferTypeID),
                        new SqlParameter("@i_offer_frequency_id", OfferFrequencyID),
                        new SqlParameter("@dt_start_date", StartDate),
                        new SqlParameter("@dt_end_date", EndDate),
                        new SqlParameter("@vc_friendly_name", FriendlyName),
                        new SqlParameter("@vb_public_key", PubKey),
                        new SqlParameter("@i_policy_flags", PolicyFlags),
                        new SqlParameter("@ti_console_type_id", (byte)consoleType),
                        new SqlParameter("@b_content_id", ContentID),
                    };

                    PackageInstaller.ExecuteVirtualInterfaceStoredProc(
                        VirtualInterface.uodb,
                        "dbo.p_svc_insert_offers",
                        Parameters
                        );
                }
            }
            catch (Exception e)
            {
                Console.WriteLine(
                    "[Installer] p_svc_insert_offers FAILED '{0}'",
                    e.Message
                    );
                return false;
            }
            return true;
        }

        public
        static
        bool
        p_xbos_load_offer(
            ulong OfferID,
            out ConsoleTypeEnum ConsoleType,
            out DateTime StartDate,
            out DateTime EndDate,
            out int OfferTypeID,
            out int OfferFrequencyID,
            out bool Cancelable,
            out int EsrbID,
            out int BitFilter,
            out int InstallSize,
            out int PackageSize,
            out byte[] SymKey,
            out int PolicyFlags,
            out string BillingComponentID,
            out string FriendlyName,
            out short GlobalOfferDetails,
            out byte[] PubKey,
            out int TierID,
            out uint ReturnValue
            )
        {
            ConsoleType = (ConsoleTypeEnum)0;
            StartDate = DateTime.MinValue;
            EndDate = DateTime.MinValue;
            OfferTypeID = 0;
            OfferFrequencyID = 0;
            Cancelable = false;
            EsrbID = 0;
            BitFilter = 0;
            InstallSize = 0;
            PackageSize = 0;
            SymKey = null;
            PolicyFlags = 0;
            BillingComponentID = null;
            FriendlyName = null;
            GlobalOfferDetails = 0;
            PubKey = null;
            TierID = 0;
            ReturnValue = 0xffffffff;

            try
            {
                unchecked
                {
                    SqlParameter[] Parameters = new SqlParameter[]
                    {
                        new SqlParameter(),
                        new SqlParameter("@bi_offer_id", (long)OfferID),
                        new SqlParameter("@ti_console_type_id", SqlDbType.TinyInt),
                        new SqlParameter("@dt_start_date", SqlDbType.DateTime),
                        new SqlParameter("@dt_end_date", SqlDbType.DateTime),
                        new SqlParameter("@i_offer_type_id", SqlDbType.Int),
                        new SqlParameter("@i_offer_frequency_id", SqlDbType.Int),
                        new SqlParameter("@b_cancelable", SqlDbType.TinyInt),
                        new SqlParameter("@i_esrb_rating", SqlDbType.Int),
                        new SqlParameter("@i_bitfilter", SqlDbType.Int),
                        new SqlParameter("@i_install_size", SqlDbType.Int),
                        new SqlParameter("@i_package_size", SqlDbType.Int),
                        new SqlParameter("@vb_sym_key", SqlDbType.VarBinary, PackageInstallerLogic.MaxSymKeyLength),
                        new SqlParameter("@i_policy_flags", SqlDbType.Int),
                        new SqlParameter("@vc_service_component_id", SqlDbType.NVarChar, 36),
                        new SqlParameter("@vc_friendly_name", SqlDbType.NVarChar, 150),
                        new SqlParameter("@si_global_offer_details", SqlDbType.SmallInt),
                        new SqlParameter("@vb_public_key", SqlDbType.VarBinary, PackageInstallerLogic.MaxPubKeyLength),
                        new SqlParameter("@i_tier_id", SqlDbType.Int),
                    };

                    int i = 0;
                    Parameters[i++].Direction = ParameterDirection.ReturnValue;
                    Parameters[i++].Direction = ParameterDirection.Input;
                    Parameters[i++].Direction = ParameterDirection.Output;
                    Parameters[i++].Direction = ParameterDirection.Output;
                    Parameters[i++].Direction = ParameterDirection.Output;
                    Parameters[i++].Direction = ParameterDirection.Output;
                    Parameters[i++].Direction = ParameterDirection.Output;
                    Parameters[i++].Direction = ParameterDirection.Output;
                    Parameters[i++].Direction = ParameterDirection.Output;
                    Parameters[i++].Direction = ParameterDirection.Output;
                    Parameters[i++].Direction = ParameterDirection.Output;
                    Parameters[i++].Direction = ParameterDirection.Output;
                    Parameters[i++].Direction = ParameterDirection.Output;
                    Parameters[i++].Direction = ParameterDirection.Output;
                    Parameters[i++].Direction = ParameterDirection.Output;
                    Parameters[i++].Direction = ParameterDirection.Output;
                    Parameters[i++].Direction = ParameterDirection.Output;
                    Parameters[i++].Direction = ParameterDirection.Output;
                    Parameters[i++].Direction = ParameterDirection.Output;
                    Debug.Assert(i == Parameters.Length);

                    PackageInstaller.ExecuteVirtualInterfaceStoredProcQuery(
                        VirtualInterface.uodb,
                        "dbo.p_xbos_load_offer",
                        Parameters
                        );

                    i = 0;
                    ReturnValue = (uint)(int)Parameters[i++].Value;
                    if (ReturnValue == 0)
                    {
                        i++;
                        ConsoleType = (ConsoleTypeEnum)(byte)Parameters[i++].Value;
                        StartDate = (DateTime)Parameters[i++].Value;
                        EndDate = (DateTime)Parameters[i++].Value;
                        OfferTypeID = (int)Parameters[i++].Value;
                        OfferFrequencyID = (int)Parameters[i++].Value;
                        Cancelable = ((byte)Parameters[i++].Value != 0);
                        EsrbID = (int)Parameters[i++].Value;
                        BitFilter = (int)Parameters[i++].Value;
                        InstallSize = (int)Parameters[i++].Value;
                        PackageSize = (int)Parameters[i++].Value;
                        SymKey = (byte[])Parameters[i++].Value;
                        PolicyFlags = (int)Parameters[i++].Value;
                        BillingComponentID = (string)Parameters[i++].Value;
                        FriendlyName = (string)Parameters[i++].Value;
                        GlobalOfferDetails = (short)Parameters[i++].Value;
                        PubKey = (byte[])Parameters[i++].Value;
                        TierID = (int)Parameters[i++].Value;
                        Debug.Assert(i == Parameters.Length);
                    }
                }
            }
            catch (Exception e)
            {
                Console.WriteLine(
                    "[Installer] p_xbos_load_offer FAILED '{0}'",
                    e.Message
                    );
                return false;
            }
            return true;
        }
    }

    public class PackageInstallerLogic
    {
        public static int ContentIDLength   = 20;       // Refer to t_content.sql
        public static int MaxSymKeyLength   = 16;       // Refer to t_content.sql
        public static int MaxPubKeyLength   = 284;      // Refer to t_content.sql
        public static int MaxXRLLength      = 4000;

        //This process is a proper subset of content logic
        public static PackageInstaller GetInstaller(XICPackage Package)
        {
            //Autoupdate content package
            switch (Package.ContentType)
            {
                case XboxContentTypes.Installer:
                    return new UpdaterInstaller();
                case XboxContentTypes.GamerPicture:
                    return new GamerTileInstaller();
                case XboxContentTypes.AvatarItem:
                    return new AvatarItemInstaller();
                default:
                    return new ContentInstaller();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\ingestionutils\content\PackageBuilder.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Threading;
using System.Runtime.InteropServices;
using System.Text;

namespace xonline.common.content    
{
    // This enum is a bit overloaded, but for Spring09 will suffice.  CrackCab has additional check to only apply StfImage logic to CABs 
    public enum BuildMethods : int
    {
        Xbox360         = 0,
        StfImageExe     = 2,
        StfImageExeNoTimeStamp      = 3,
        StfImageExeNoTimeStampAvatarMarketplace = 4,
        UnCompressedSvodImage        = 0x00010000  // Default for Spring09 is to Compress SVOD files
    }

    public class PackageBuilder
    {
      public const uint FusionTitleID = 0xFFFE07D2;
      public const string GamesOnDemandExtension = ".xpkg";

        public delegate uint GamerTileIdProc(uint TitleId);

        // set the callback to be static, so the delegate doesn't get garbage collected
        // and crackcab.dll can't call it when it is needed
        static GamerTileIdProc callback = new GamerTileIdProc(GamerTileInstaller.GetStartingID);

        #region Crackcab.dll Imports
        [DllImport("crackcab.dll", EntryPoint="CreateCabinetContext")]
            private static extern IntPtr _CreateCabinetContext();

        [DllImport("crackcab.dll", EntryPoint="DestroyCabinetContext")]
            private static extern Int32 _DestroyCabinetContext(IntPtr context);

        [DllImport("crackcab.dll", EntryPoint="RegisterGamerTileIdCallback")]
            private static extern Int32 _RegisterGamerTileIdCallback(IntPtr Context,
                    GamerTileIdProc Callback);

        [DllImport("crackcab.dll", EntryPoint="IsContextValid")]
            private static extern Int32 _IsContextValid(IntPtr context);

        [DllImport("crackcab.dll", EntryPoint="IsContextBusy")]
            private static extern Int32 _IsContextBusy(IntPtr context);

        [DllImport("crackcab.dll", EntryPoint="GetErrorString")]
            private static extern Int32 _GetErrorString(Int32 ErrorCode, StringBuilder errorBuffer, int size);

        [DllImport("crackcab.dll", EntryPoint="GetErrorCode")]
            private static extern Int32 _GetErrorCode();

        [DllImport("crackcab.dll", EntryPoint="GetErrorCodeEx")]
            private static extern Int32 _GetErrorCodeEx(IntPtr context);

        [DllImport("crackcab.dll", EntryPoint="Build360InstallCabinet")]
            private static extern Int32 _Build360InstallCabinet(IntPtr Context, String CabinetFile,
                    String OutputDirectory, String XRLs, BuildMethods BuildMethod);

        [DllImport("crackcab.dll", EntryPoint="Build360InstallCabinetFromContentPackage")]
            private static extern Int32 _Build360InstallCabinetFromContentPackage(
                    IntPtr Context, String ContentFile, String XRLs, String OutputDirectory);

        [DllImport("crackcab.dll", EntryPoint="GetContentPackageCount")]
            private static extern int _GetContentPackageCount(IntPtr Context);

        [DllImport("crackcab.dll", EntryPoint="GetContentPackage")]
            private static extern Int32 _GetContentPackage(IntPtr Context, int Index,
                    ref XICPackageInfo Package, StringBuilder PackageName, int BufferSize);

        [DllImport("crackcab.dll", EntryPoint="GetContentFileCount")]
            private static extern int _GetContentFileCount(IntPtr Context);

        [DllImport("crackcab.dll", EntryPoint="GetContentFile")]
            private static extern Int32 _GetContentFile(IntPtr Context, int Index,
                    StringBuilder FileName, int SizeBuffer);

        [DllImport("crackcab.dll", EntryPoint="IsCabinetValid")]
            private static extern Int32 _IsCabinetValid(String cabinetPath);

        [DllImport("crackcab.dll", EntryPoint="DeflateFile")]
            private static extern Int32 _DeflateFile(IntPtr Context, String CabinetFile,
                    String OutputDirectory, String InternalName);

        #endregion

        #region Member variables
        protected string    _packagePath;
        protected IntPtr    _contextHandle;
        #endregion

        #region ctor/dtor
        public PackageBuilder(string packagePath)
        {
            _contextHandle = _CreateCabinetContext();

            if (!IsContextValid)
                throw GetException("Could not create context");

            _RegisterGamerTileIdCallback(_contextHandle,
                    callback);

            if( !System.IO.Path.IsPathRooted(packagePath) )
            {
                packagePath = System.IO.Path.Combine(Environment.CurrentDirectory, packagePath);
            }

            _packagePath = packagePath;
        }

        ~PackageBuilder()
        {
            if (0 == _DestroyCabinetContext(_contextHandle))
                throw GetException("Could not destroy context");

            _contextHandle = (IntPtr)(-1);
            _packagePath = "";
        }
        #endregion

        #region Properties
        protected Exception GetException(String title)
        {
            return new Exception(String.Format("{0}.  \n\tReason: {1}", title, Error));
        }

        public string Error
        {
            get
            {
                StringBuilder sb = new StringBuilder(256);
                Int32 ErrorCode;

                ErrorCode = _GetErrorCodeEx(_contextHandle);
                if (ErrorCode == -1)
                    return "";

                _GetErrorString(ErrorCode, sb, sb.Capacity);

                return sb.ToString();
            }
        }

        public bool IsBusy
        {
            get
            {
                if (IsContextValid)
                    return (0 != _IsContextBusy(_contextHandle));

                return false;
            }
        }

        public string Path
        {
            get { return _packagePath; }
        }

        public bool IsContextValid
        {
            get
            {
                return (0 != _IsContextValid(_contextHandle));
            }
        }

        public bool IsCabinetValid
        {
            get { return (0 != _IsCabinetValid(_packagePath)); }
        }
        #endregion

        #region Operations
        private
        bool
        FetchContentResults(
            out    XICPackage[] Packages,
            out    String[]     ContentFiles,
            string xicSuffix
            )
        {
            int PackageCount     = _GetContentPackageCount(_contextHandle);
            int ContentFileCount = _GetContentFileCount(_contextHandle);
            int result;

            Packages = null;
            ContentFiles = null;

            if ((PackageCount > 0) && (ContentFileCount > 0))
            {
                XICPackage[]    packages     = new XICPackage[PackageCount];
                String[]        contentFiles = new String[ContentFileCount];

                for (int Package = 0; Package < PackageCount; ++Package)
                {
                    XICPackageInfo Info        = new XICPackageInfo(0);
                    StringBuilder  packagePath = new StringBuilder(260); //max path length

                    result = _GetContentPackage(
                        _contextHandle,
                        Package,
                        ref Info,
                        packagePath,
                        packagePath.Capacity
                        );
                    if (0 == result)
                    {
                        Console.WriteLine(
                            "_GetContentPackage failed for package {0}. {1} '{2}'.",
                            Package,
                            _GetErrorCodeEx(_contextHandle),
                            Error
                            );
                        return false;
                    }

                    if (GamesOnDemandExtension != System.IO.Path.GetExtension(packagePath.ToString()))
                    {
                        packages[Package] = new XICPackage(Info, packagePath.ToString() + xicSuffix);
                    }
                    else
                    {
                        packages[Package] = new XICPackage(Info, packagePath.ToString());
                    }
                }

                for (int c=0; c<ContentFileCount; c++)
                {
                    StringBuilder contentFilePath = new StringBuilder(260);

                    result = _GetContentFile(
                        _contextHandle,
                        c,
                        contentFilePath,
                        contentFilePath.Capacity
                        );
                    if (0 == result)
                    {
                        Console.WriteLine(
                            "_GetContentFile failed {0}. '{1}'.",
                            c,
                            Error
                            );
                        return false;
                    }

                    contentFiles[c] = contentFilePath.ToString();
                }

                Packages = packages;
                ContentFiles = contentFiles;

                return true;
            }

            return false;
        }

        private
        bool
        FetchManifestResults(
                string      OutputPath,
            out string[]    ManifestFiles
            )
        {
            ManifestFiles = null;

            // Hold the list of files that we care about
            List<string> fileList = new List<string>();

            // Build the path for where all the extracted files live
            string extractPath = System.IO.Path.Combine( OutputPath, "$CabExtract\\");

            // Does this path exist?
            if (Directory.Exists(extractPath) == false)
            {
                // Not a failure in the API
                return true;
            }

            // Does the system manifest exist in this directory?
            string manifestFile = System.IO.Path.Combine( extractPath, "system.manifest");
            if (File.Exists(manifestFile) == false)
            {
                // Not a failure in the API
                return true;
            }
            fileList.Add( manifestFile );

            // Does the packages subdirectory exist?
            string packagesPath = System.IO.Path.Combine( extractPath, "Packages\\");
            if (Directory.Exists(packagesPath) == true)
            {
                foreach (string fileEntry in Directory.GetFiles(packagesPath))
                {
                    if (fileEntry.EndsWith(".cab", StringComparison.InvariantCultureIgnoreCase))
                    {
                        fileList.Add(fileEntry);
                    }
                }
            }

            // Return the array
            ManifestFiles = fileList.ToArray();
            return true;
        }

        private
        string
        FetchRedirecteePackage(string OutputPath)
        {
            // Build the path for where all the extracted files live
            string extractPath = System.IO.Path.Combine(OutputPath, "$CabExtract\\");

            // Does the packages subdirectory exist?
            string packagesPath = System.IO.Path.Combine(extractPath, "Packages\\");
            if (Directory.Exists(packagesPath) == true)
            {
                foreach (string fileEntry in Directory.GetFiles(packagesPath))
                {
                    string fileName = System.IO.Path.GetFileName(fileEntry);
                    if (fileName.StartsWith("su", StringComparison.InvariantCultureIgnoreCase) &&
                        fileName.EndsWith(".bin", StringComparison.InvariantCultureIgnoreCase))
                    {
                        return fileEntry;
                    }
                }
            }

            return null;
        }

        private string GetXRLString()
        {
            String             xrlLocations = "";
            String[]           xrlLocationArray;
            DownloadServerList serverList = new DownloadServerList();

            xrlLocationArray = serverList.XRLLocations;

            if (xrlLocationArray != null)
            {
                foreach (String xrl in xrlLocationArray)
                {
                    if (0 != xrlLocations.Length)
                    {
                        xrlLocations += ";" + xrl;
                    }
                    else
                    {
                        xrlLocations = xrl;
                    }
                }
            }
            else
            {
                xrlLocations = null;
            }
            return xrlLocations;
        }

        public
        bool
        BuildPackage(
                string       OutputPath,
            out XICPackage[] Packages,
            out String[]     ContentFiles,
            out String       RedirecteeFile,
            out String[]     ManifestFiles,
                uint         ExpectedTitleID,
                string       xicSuffix,
                BuildMethods buildMethod
            )
        {
            Packages       = null;
            ContentFiles   = null;
            ManifestFiles  = null;
            RedirecteeFile = null;

            string xrlLocations = GetXRLString();

            if (null == xrlLocations || IsContextValid == false)
            {
                return false;
            }

            // Call into crackcab.dll to build the install cabinet
            Int32 hr = _Build360InstallCabinet(
                _contextHandle,
                _packagePath,
                OutputPath,
                xrlLocations,
                buildMethod
                );
            if (0 == hr)
            {
                return false;
            }

            // Enumerate the packages and files in the cab
            bool result = FetchContentResults(out Packages, out ContentFiles, xicSuffix);
            if (result == false)
            {
                return false;
            }

            foreach (XICPackage Package in Packages)
            {
                // Expected Title ID Sanity Check
                if (0 != ExpectedTitleID && Package.TitleID != ExpectedTitleID)
                {
                    Console.WriteLine(
                        "ERROR: Package Title ID ({0:X8}) does not match supplied title ID ({1:X8}).",
                        Package.TitleID,
                        ExpectedTitleID
                        );
                    return false;
                }

                // Games on Demand Sanity Checks
                if (Package.ContentType == XboxContentTypes.XboxTitle)
                {
                    // All map to a specific title ID
                    if (Package.TitleID != FusionTitleID)
                    {
                        Console.WriteLine(
                            "ERROR: Invalid Package Title ID ({0:X8}) Games on Demand content packages must use the Fusion Title ID.",
                            Package.TitleID
                            );
                        return false;
                    }
                }
            }

            RedirecteeFile = FetchRedirecteePackage(OutputPath);

            // Enumerate the manifest files in the cab
            result = FetchManifestResults(OutputPath, out ManifestFiles);
            if (result == false)
            {
                return false;
            }

            return true;
        }

        public bool ExtractFile(string OutputDirectory, String FileName)
        {
            if (IsContextValid)
            {
                if (0 != _DeflateFile(_contextHandle, _packagePath, OutputDirectory, FileName))
                {
                    return true;
                }
            }
            return false;
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\ingestionutils\content\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__content_1_none_12.4.56.0_none_67adfd828fe07716
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__content_1_no-public-key_12.4.56.0_x-ww_49cd14a2
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_content_1
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__content_1_no-public-key_12.4.56.0_x-ww_49cd14a2
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__content_1_no-public-key_12.4.56.0_x-ww_49cd14a2.manifest
XP_MANIFEST_PATH=manifests\x86__content_1_no-public-key_12.4.56.0_x-ww_49cd14a2.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__content_1_no-public-key_12.4.56.0_x-ww_49cd14a2.cat
XP_CATALOG_PATH=manifests\x86__content_1_no-public-key_12.4.56.0_x-ww_49cd14a2.cat
XP_PAYLOAD_PATH=x86__content_1_no-public-key_12.4.56.0_x-ww_49cd14a2
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_content_1,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\ingestionutils\content\SystemManifest.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Threading;
using System.Text;
using System.Runtime.InteropServices;
using xonline.common.service;
using xonline.common.config;

namespace xonline.common.content
{
    // Quick and dirty way to handle reading the manifest file
    public class SystemManifestInfo : WireData
    {
        [WireInfo(BigEndian=true)]
        public       UInt32       Signer;

        [WireInfo(ArraySize=16)]
        public       byte[]       Key;

        [WireInfo(ArraySize=16)]
        public       byte[]       Nonce;

        [WireInfo(ArraySize=20)]
        public       byte[]       Digest;

        [WireInfo(ArraySize=256)]
        public       byte[]       Signature;

        public const UInt32       ValidMagic = 0x786d616e; // 'xman'
        [WireInfo(BigEndian=true)]
        public       UInt32       Magic;

        [WireInfo(BigEndian=true)]
        public       UInt32       TotalSize;

        [WireInfo(BigEndian=true)]
        public       UInt32       Version;

        [WireInfo(BigEndian=true)]
        public       UInt32       Revision;

        [WireInfo(BigEndian=true)]
        public       UInt32       Schema;

        [WireInfo(BigEndian=true)]
        public       UInt32       FlashPackageBuild;

        [WireInfo(ArraySize=16)]
        public       byte[]       ZeroPadding;

        [WireInfo(BigEndian=true)]
        public       UInt32       PackageOffset;
    }

    public class SystemManifest
    {
        protected   string              manifestFile;
        protected   SystemManifestInfo  manifestInfo;
        protected   UInt32              expectedFlashPackageBuild;
        protected   UInt32              actualFlashPackageBuild;
        protected   UInt32              manifestRevision;
        protected   UInt16              buildVersion;
        protected   UInt16              qfeVersion;

        public SystemManifest( string ManifestFile, UInt32 ExpectedFlashPackageBuild)
        {
            // No processing here
            manifestRevision = 0;
            manifestInfo = new SystemManifestInfo();
            manifestFile = ManifestFile;
            expectedFlashPackageBuild = ExpectedFlashPackageBuild;
        }

        public bool ValidateManifest()
        {
            // Manifest files must be present
            if (manifestFile == null || manifestFile.Length == 0)
            {
                Console.WriteLine("[SystemManifest] No Manifes File Present");
                return false;
            }

            // By convention, the 1st file in the manifest list is the
            // manifest itself
            BinaryReader    binReader = new BinaryReader(
                File.Open(manifestFile, FileMode.Open)
                );
            manifestInfo.ReadStream( binReader );
            binReader.Close();

            // Sanity check that the magic is correct
            if (manifestInfo.Magic != SystemManifestInfo.ValidMagic)
            {
                Console.WriteLine(
                    "[SystemManifest] Expected Magic is {0:x}, got {1:x}",
                    SystemManifestInfo.ValidMagic,
                    manifestInfo.Magic
                    );
                return false;
            }

            // Remember the manifest revision
            manifestRevision = manifestInfo.Revision;

            // Sanity check the build number
            actualFlashPackageBuild = manifestInfo.FlashPackageBuild;
            if (expectedFlashPackageBuild != 0 &&
                expectedFlashPackageBuild != actualFlashPackageBuild)
            {
                Console.WriteLine(
                    "[SystemManifest] Expected Flash Build is {0:x}, got {1:x}",
                    expectedFlashPackageBuild,
                    actualFlashPackageBuild
                    );
                return false;
            }

            // Convert the FlashPackageBuild version from the MNBBBBQQ format
            // into the Build and QFE fields we care about
            buildVersion = (UInt16) ( (0xFFFF) & (actualFlashPackageBuild >> 8) );
            qfeVersion   = (UInt16) ( (0x00FF) & (actualFlashPackageBuild     ) );

            return true;
        }

        public short Build    { get { return (short) buildVersion;   } }
        public short Qfe      { get { return (short) qfeVersion;     } }
        public int   Revision { get { return (int) manifestRevision; } }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\ingestionutils\content\DownloadServerList.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Threading;
using xonline.common.config;

namespace xonline.common.content
{
    public class DownloadServerList
    {
        #region Member variables
        protected static string[]   serverList = null;
        protected static string[]   shareNames = null;
        protected static string[]   xrlLocations = null;
        protected static int[]  sites = null;
        #endregion

        #region ctor
        public DownloadServerList() 
        {
            if (null == serverList) 
            {
                try 
                {
                    serverList = Config.GetServerListByInterface(Interface.download_share);
                }
                catch (Exception e) 
                {
                    throw new Exception("GetServerListByInterface Failed", e);
                }
            }
        }
        #endregion
        
        #region Properties
        public int[] Sites 
        {
            get { return sites; }
            set { sites = value; }
        }

        public string[] ShareNames 
        {
            get 
            {
                if (null == shareNames) 
                {
                    //Names not yet cached
                    ArrayList shareNamesList = new ArrayList();

                    for (int c=0; c<serverList.Length; c++) 
                    {
                        IInterfaceInfo info;
                        string shareName;
                        int siteId;

                        info = Config.GetInterface(serverList[c], Interface.download_share);
                        Config.GetServerInfo(serverList[c], out siteId);

                        foreach(int site in sites)
                        {
                            if(site == siteId)
                            {
                                shareName = String.Format("\\\\{0}{1}\\", 
                                    info.IPAddressString, 
                                    info.Sharename);
                                
                                if ((null == shareName) || (0 == shareName.Length)) {
                                    Console.WriteLine("ERROR: Share name {0} is null.", c);
                                    return null;
                                }
                                
                                if ('\\' != shareName[shareName.Length-1])
                                    shareName += "\\";
                                
                                shareNamesList.Add(shareName);

                                break;
                            }
                        }
                    }

                    shareNames = new string[shareNamesList.Count];
                    shareNamesList.CopyTo(shareNames);
                }

                return shareNames;
            }

            set { shareNames = value; }
        }

        public string[] XRLLocations
        {
            get
            {
                if (null == xrlLocations) 
                {
                    int index = 0;
                    
                    if ((null == sites) || (0 == sites.Length)) {
                        Console.WriteLine("ERROR: No sites information provided.");
                        return null;
                    }

                    xrlLocations = new string[sites.Length];

                    foreach(int site in sites) {                
                        try 
                        {
                            IVirtualInterfaceInfo info;
                            string host, vcinfo1;

                            info = Config.GetVirtualInterface(VirtualInterface.download, site);
                            host = info.IPAddressString;
                            vcinfo1 = info.Info1;

                            // DNS info, if present, to use instead of IP-address
                            if(vcinfo1 != null && vcinfo1.Length > 0)
                            {
                                host = vcinfo1;
                            }
                            else
                            {
                                host = info.IPAddressString;
                            }
                    
                            xrlLocations[index] = String.Format("http://{0}:{1}/content/",
                                    host,
                                    info.Port);

                            index++;
                        } 
                        catch (Exception) 
                        {
                            Console.WriteLine("ERROR: No virtual interface found for site {0}.", site);
                            return null;
                        }
                    }
                }

                return xrlLocations;
            }

            set { xrlLocations = value; }
        }
        #endregion

        #region Methods

        /// <summary>
        /// Method that parses a list of possible sites
        /// separated by semicolons and set them as the Sites property
        /// </summary>
        /// <param name="sites"></param>
        public void ParseSiteList(string sites)
        {
            Hashtable siteHash = new Hashtable();
            int[] siteArray;
            int index = 0;
            string[] split;

            split = sites.Split(";".ToCharArray());
            siteArray = new int[split.Length];

            foreach (string item in split)
            {
                int site;

                //Caused by ;;
                if (0 == item.Length)
                {
                    throw new ArgumentException(String.Format("ERROR: /site format is invalid '{0}'", sites));
                }

                try
                {
                    site = int.Parse(item);
                }
                catch (Exception e)
                {
                    throw new ArgumentException(String.Format("ERROR: error parsing site value '{0}'", item), e);
                }

                if (0 == site)
                {
                    throw new ArgumentException("ERROR: 0 is an invalid site id");
                }

                if (siteHash.Contains(site))
                {
                    throw new ArgumentException(String.Format("ERROR: duplicate entry {0} found in /site", site));
                }
                else
                {
                    siteHash.Add(site, site);
                    siteArray[index] = site;
                    index++;
                }
            }

            //DownloadServerList will use the to enumerate XRL's
            this.Sites = siteArray;
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\ingestionutils\content\XICPackage.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Threading;
using System.Text;
using System.Runtime.InteropServices;
using System.Globalization;

namespace xonline.common.content
{
    public enum XboxContentTypes : uint
    {
        MarketPlace = 0x00000002,   //XCONTENTTYPE_MARKETPLACE
        Publisher = 0x00000003,   //XCONTENTTYPE_PUBLISHER
        XboxTitle = 0x00005000,   //XCONTENTTYPE_XBOXTITLE
        Xbox360Title = 0x00007000,   //XCONTENTTYPE_XBOX360TITLE
        GamerPicture = 0x00020000,   //XCONTENTTYPE_GAMERPICTURE
        ThematicSkin = 0x00030000,   //XCONTENTTYPE_THEMATICSKIN
        GameDemo = 0x00080000,   //XCONTENTTYPE_GAMEDEMO
        Video = 0x00090000,   //XCONTENTTYPE_VIDEO
        GameTitle = 0x000A0000,   //XCONTENTTYPE_GAMETITLE
        GameTrailer = 0x000C0000,   //XCONTENTTYPE_GAMETRAILER
        Arcade = 0x000D0000,	  //XCONTENTTYPE_ARCADE
        AvatarItem = 0x00009000, //XCONTENTTYPE_AVATAR_ASSET

        Installer = 0x000B0000,   //XCONTENTTYPE_INSTALLER
        

        UnknownType
    }

    //
    //  These definitions must match the definitions in //depot/xenon/main/core/private/inc/xex.h
    //
    public enum PlatformTypes : byte
    {
        Xenon = 0x02,         //XEX_PLATFORM_XENON
        PC = 0x10,         //XEX_PLATFORM_PC
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct XICPackageInfo
    {
        //NOTE:
        //
        //This structure layout must match the structure layout
        //of CONTENT_PACKAGE_INFO defined in \private\tools\content\CrackCab.h
        //
        public UInt32 TitleID;
        public UInt32 Xbox1TitleID;

        public UInt32 BaseVersion;
        public UInt32 UpdateVersion;

        public UInt32 ContentTypeID;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 20)]
        public byte[] ContentID;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 16)]
        public byte[] SymmetricKey;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 284)]
        public byte[] PublicKey;

        public Int64 InstallSize;
        public Int64 PackageSize;

        public UInt32 cbSize;

        [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 256)]
        public string FriendlyName;

        public UInt64 OfferID;

        public byte Platform;

        public UInt32 GameRegion;   

        public XICPackageInfo(UInt32 size)
        {
            // Non-default Struct contructors must initialize every member to avoid 
            // error CS0171: Field 'fooStruct.fooMember' must be fully assigned before control leaves the constructor

            this = new XICPackageInfo(); // shortcut, since C# Struct default contructors init everything to zero
            this.cbSize = size;

            // If no size provided, then init to known 'sizeof' for this struct
            if (size == 0)
            {
                this.cbSize = XICPackageInfoHelper.CPI_SIZE;
            }
        }
    }

    //	public class ContentTypeIDConstants 
    //	{
    //		public const UInt32 XCONTENTTYPE_SAVEDGAME			= 0x00000001;
    //		public const UInt32 XCONTENTTYPE_MARKETPLACE			= 0x00000002;
    //		public const UInt32 XCONTENTTYPE_PUBLISHER			= 0x00000003;
    //		public const UInt32 XCONTENTTYPE_NONE					= 0x00000000;
    //		public const UInt32 XCONTENTTYPE_PROFILE				= 0x00010000;
    //		public const UInt32 XCONTENTTYPE_GAMERPICTURE		= 0x00020000;
    //		public const UInt32 XCONTENTTYPE_THEMATICSKIN		= 0x00030000;
    //		public const UInt32 XCONTENTTYPE_CACHE					= 0x00040000;
    //		public const UInt32 XCONTENTTYPE_STORAGEDOWNLOAD	= 0x00050000;
    //		public const UInt32 XCONTENTTYPE_XboxSAVEDGAME		= 0x00060000;
    //		public const UInt32 XCONTENTTYPE_XboxDOWNLOAD		= 0x00070000;
    //		public const UInt32 XCONTENTTYPE_GAMEDEMO				= 0x00080000;
    //		public const UInt32 XCONTENTTYPE_VIDEO					= 0x00090000;
    //		public const UInt32 XCONTENTTYPE_GAMETITLE			= 0x000A0000;
    //		public const UInt32 XCONTENTTYPE_INSTALLER			= 0x000B0000;
    //		public const UInt32 XCONTENTTYPE_GAMETRAILER			= 0x000C0000;
    //		public const UInt32 XCONTENTTYPE_ARCADE				= 0x000D0000;
    //	};


    // Helper to perform a c++ style 'sizeof' to get the size in bytes of XICPackageInfo (a.k.a. CONTENT_PACKAGE_INFO)
    public class XICPackageInfoHelper
    {
        private static UInt32 cpi_size = 0;
        static XICPackageInfoHelper() { cpi_size = (UInt32)Marshal.SizeOf(new XICPackageInfo()); }

        public static UInt32 CPI_SIZE { get { return cpi_size; } }
    }

    public class XICPackage : IXICPackage
    {
        protected string xicPath;
        private string saveAsFileName; // file name to be used when the package is saved
        protected XICPackageInfo packageInfo;
        protected int versionFlag;

        public XICPackage()
        {
            xicPath = "";
            packageInfo.cbSize = XICPackageInfoHelper.CPI_SIZE;
        }

        public static string BinaryToHexString(byte[] Binary)
        {
            if (Binary != null)
            {
                StringBuilder sb = new StringBuilder(Binary.Length * 2);

                foreach (byte b in Binary)
                {
                    sb.AppendFormat("{0:x2}", b);
                }

                return sb.ToString();
            }

            return "";
        }

        public static byte[] HexStringToByteArray(string s)
        {
            s = s.Trim().ToUpper();

            if (s[0] == '0' && s[1] == 'X')
                s = s.Substring(2);

            int numBytes = s.Length / 2;
            byte[] bytes = new byte[numBytes];

            for (int j = 0; j < numBytes; j++)
            {
                bytes[j] = Byte.Parse(s.Substring(j * 2, 2), NumberStyles.HexNumber);
            }

            return bytes;
        }

        public XICPackage(XICPackageInfo PackageInfo, string XICPath)
        {
            packageInfo = PackageInfo;
            xicPath = XICPath;

            if (packageInfo.cbSize == 0)
                packageInfo.cbSize = XICPackageInfoHelper.CPI_SIZE;
        }

        public UInt32 ContentTypeID
        {
            get { return packageInfo.ContentTypeID; }
        }

        public int VersionFlag
        {
            get { return versionFlag; }
            set { versionFlag = value; }
        }

        public XboxContentTypes ContentType
        {
            get
            {
                if (Enum.IsDefined(typeof(XboxContentTypes), packageInfo.ContentTypeID))
                    return (XboxContentTypes)packageInfo.ContentTypeID;
                else
                    return XboxContentTypes.UnknownType;
            }
        }

        ///General properties
        public UInt32 TitleID
        {
            get { return packageInfo.TitleID; }
        }

        public UInt32 Xbox1TitleID
        {
            get { return packageInfo.Xbox1TitleID; }
        }

        public UInt64 OfferID
        {
            get { return packageInfo.OfferID; }
        }

        public UInt32 BaseVersion
        {
            get { return packageInfo.BaseVersion; }
        }

        public UInt32 UpdateVersion
        {
            get { return packageInfo.UpdateVersion; }
        }

        public string FriendlyName
        {
            get { return packageInfo.FriendlyName; }
        }

        ///Content Metadata properites
        public byte[] ContentID
        {
            get { return packageInfo.ContentID; }
        }

        public string ContentIDString
        {
            get
            {
                string hexString = BinaryToHexString(ContentID);
                // bug fix 36289
                // all CDN paths & filenames need to be lower case
                if (!String.IsNullOrEmpty(hexString))
                    return hexString.ToLowerInvariant();
                return hexString;
            }
        }

        public byte[] SymmetricKey
        {
            get { return packageInfo.SymmetricKey; }
        }

        public string SymmetricKeyString
        {
            get { return BinaryToHexString(SymmetricKey); }
        }

        public byte[] PublicKey
        {
            get { return packageInfo.PublicKey; }
        }

        public string PublicKeyString
        {
            get { return BinaryToHexString(PublicKey); }
        }

        public Int64 InstallSize
        {
            get { return packageInfo.InstallSize; }
        }

        public Int64 PackageSize
        {
            get { return packageInfo.PackageSize; }
        }

        public byte Platform
        {
            get { return packageInfo.Platform; }
        }

        public UInt32 GameRegion
        {
            get { return packageInfo.GameRegion; }
        }

        public string SaveAsFileName
        {
            get
            {
                return this.saveAsFileName;
            }
            set
            {
                // If we have a SaveAsFileName use that

                // bug fix 36289
                // all CDN paths & filenames need to be lower case
                if (!String.IsNullOrEmpty(value))
                    this.saveAsFileName = value.ToLowerInvariant();
                else
                    this.saveAsFileName = value;
            }
        }

        public string XCPName
        {
            get
            {
                // If we have a SaveAsFileName use that
                if (!String.IsNullOrEmpty(this.SaveAsFileName))
                    return this.SaveAsFileName;

                // If its a PC install package, the Package.Path will have the filename
                // we want to use, but it has added the .new extension to differentiate from
                // the input file (although it is the same)
                if (PlatformTypes.PC == (PlatformTypes)this.Platform &&
                    this.ContentType == XboxContentTypes.Installer)
                {
                    // bug fix 36289
                    // all CDN paths & filenames need to be lower case
                    return System.IO.Path.GetFileNameWithoutExtension(this.Path).ToLowerInvariant();
                }

                string contentIdString = this.ContentIDString;
                // never never use an empty or invalid ContentID string as a filename
                // that means someone is using the tool with some invalid metadata
                if (String.IsNullOrEmpty(contentIdString) || (contentIdString == "0000000000000000000000000000000000000000"))
                {
                    throw new Exception("Cannot use an empty or invalid Content Id for propping this package.");
                }

                // Otherwise use xcp extension for saving
                return String.Format("{0}.xcp", contentIdString);
            }
        }

        #region IXICPackage Members

        public string Path
        {
            get { return xicPath; }
        }

        public string GetFullCDNSharePath(string Server)
        {
            // bug fix 36289
            // all CDN paths & filenames need to be lower case
            return String.Format("{0}{1:x8}\\{2}",
                    Server,
                    this.TitleID,
                    this.XCPName).ToLowerInvariant();
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\ingestionutils\dll\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\ingestionutils\content\XICDistributer.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Threading;

namespace xonline.common.content
{
	public class SyncBarrier 
	{
		#region Member variables

		object waitCount;
		bool succeeded;
		ManualResetEvent resetEvent;
		
		#endregion
		
		public SyncBarrier() 
		{
			waitCount = (int)0;
			succeeded = true;
			resetEvent = new ManualResetEvent(false);
			resetEvent.Reset();
		}

		public SyncBarrier(int WaitCount) 
		{
			if (WaitCount <= 0)
				throw new Exception("WaitCount must be greater than 0");

			waitCount = WaitCount;
			succeeded = true;
			resetEvent = new ManualResetEvent(false);
			resetEvent.Reset();
		}

		//Reset
		//Resets the barrier and prepares
		public void Reset(int WaitCount) 
		{
			if (WaitCount <= 0)
				throw new Exception("WaitCount must be greater than 0");

			waitCount = WaitCount;
			succeeded = true;
			resetEvent.Reset();
		}

		//Reset
		////Resets the barrier and prepares
		public void Reset(Thread[] Threads) 
		{
			if (null == Threads) 
				throw new Exception("null array of threads specified");

			try { Reset(Threads.Length); }
			catch (Exception e) { throw e; }
		}

		//EnterWait
		//Waits until all objects have entered
		// - true indicates that all objects have successfully entered the barrier
		// - false indicates that the barrier could not be reached by everyone (Cancel envoked)
		public bool EnterWait() 
		{
			int newWaitCount;
	
			if (!succeeded)
				return false;

			lock (waitCount) {
				newWaitCount = (int)waitCount;
				
				if (0 == newWaitCount)
					throw new Exception("WaitCount is already zero");

				newWaitCount--;

				waitCount = newWaitCount;
			}

			if (0 < newWaitCount) {
				//newWaitCount >= waitCount
				resetEvent.WaitOne();
			} else {
				//newWaitCount = waitCount
				resetEvent.Set();
			}

			return succeeded;
		}

		//Cancel the barrier
		//Affects:
		// - Future EnterWait calls will no longer suspend the caller
		// - Future EnterWait calls will return false (FAILURE)
		// - Currently suspended calls to EnterWait will be awakened
		// - Currently suspended calls to EnterWait will return false (FAILURE)
		public void Cancel() 
		{
			succeeded = false;

			resetEvent.Set();
		}

		public bool Canceled 
		{
			get { return succeeded != true; }
		}
	};

	public class XICDistributer 
	{
		#region member variables
		private DownloadServerList	    serverList;			//List of download servers
		private Thread[]				threadArray;		//pool of worker threads
		private Queue					serverQueue;		//queue of download server targets
        private IXICPackage             xicPackage;
		private bool					overwrite;

		private SyncBarrier			    barrier;				//force threads to wait for all threads to finish
		
		#endregion

		public XICDistributer() 
		{
			serverList = new DownloadServerList();

			serverQueue = new Queue();
			
			barrier = new SyncBarrier();
		}

        private void DistributePackage(IXICPackage xicPackage, string To, bool Overwrite) 
		{
			try
			{
				string ParentDirectory = Path.GetDirectoryName(To);

				if (!Directory.Exists(ParentDirectory)) {
					Console.WriteLine("[Distributer] Creating Directory {0}...", ParentDirectory);
					Directory.CreateDirectory(ParentDirectory);
				}
				
				if (File.Exists(To))
				{
					if (Overwrite)
					{
						Console.WriteLine("[Distributer] Overwriting {0} ...", To);
						// Make sure file is writable, before attempting to overwrite
						File.SetAttributes(To, File.GetAttributes(To) & (~FileAttributes.ReadOnly));
						File.Copy(xicPackage.Path, To, true);
					}
					else 
					{
						Console.WriteLine("[Distributer] No-overwrite (skipping) {0} ...", To);
					}
				}
				else
				{
					Console.WriteLine("[Distributer] Copying to {0} ...", To);
					File.Copy(xicPackage.Path, To, false);
				}
			} 
			catch (Exception e) 
			{
				throw new Exception(
					String.Format("Failed to copy from '{0}' to '{1}'", xicPackage.Path, To), e);
			}
		}

		#region Thread control/handling members
		private void WorkerItem() 
		{
			string serverString = DequeueServerString();

			//All threads should be given work
			if (null == serverString)
			{
				Cancel();
				return;
			}

			if (barrier.Canceled)
				return;

			//Copy File
			try { DistributePackage(xicPackage, serverString, overwrite); }
			catch (Exception) { Cancel(); }

			if (!barrier.EnterWait()) {
				//Threads have failed to distribute content
				try { File.Delete(serverString); }
				catch (Exception) { /*nothing doing*/ }
			}
		
			//All threads have finished
		}

		private void SpinUpThreads(int ThreadCount) 
		{
			threadArray = new Thread[ThreadCount];

			for (int c=0; c<ThreadCount; c++) 
				threadArray[c] = new Thread(new ThreadStart(WorkerItem));
		}

		private void Cancel() 
		{
			barrier.Cancel();
		}

		#endregion

		private void PrepareDistribute() 
		{
			try
			{
			if (serverList.ShareNames == null || 0 == serverList.ShareNames.Length) {
			   Exception e = new Exception("there are no servers in the server list, check npdb configuration.");
			   Console.WriteLine("[Distributer] ERROR: " + e.Message);
			   throw e;
			}

				foreach (string server in serverList.ShareNames) 
				{
					EnqueueServerString(xicPackage.GetFullCDNSharePath(server));
				}

				SpinUpThreads(serverList.ShareNames.Length);
			}
			catch (Exception) { 
			throw;
		 }

		}

        public void DestroyPackage(IXICPackage xicPackage)
		{
			foreach (string server in serverList.ShareNames)
			{

				string path;

                path = xicPackage.GetFullCDNSharePath(server);

				try 
				{
					if (File.Exists(path))
						File.Delete(path);
				}
				catch (Exception) 
				{ 	}
				
			}
		}

        public bool DistributePackage(IXICPackage Package, bool Overwrite) 
		{
			if (Package == null)
				return false;

			if (File.Exists(Package.Path)) 
			{
				xicPackage = Package;
				overwrite = Overwrite;

				try
				{
					PrepareDistribute();

					barrier.Reset(threadArray.Length + 1);
		
					foreach (Thread thread in threadArray) 
						thread.Start();

					//Wait for worker threads to finish
					return barrier.EnterWait();
				}
				catch (Exception) { return false; }

			}

			return false;
		}

		#region Concurrent queue access members
		private void EnqueueServerString(String str) 
		{
			lock (serverQueue) {
			
				serverQueue.Enqueue(str);

			}
		}

		private string DequeueServerString() 
		{
			string result = null;

			lock (serverQueue) {

				if (serverQueue.Count > 0)
					result = (string)serverQueue.Dequeue();

			}
			
			return result;
		}

		private bool ServerQueueIsEmpty()
		{
			bool is_empty;

			lock (serverQueue) {

				is_empty = serverQueue.Count == 0;

			}

			return is_empty;
		}
		#endregion
	}

	public class XICParallelDistributer {

        public static bool DistributePackages(IXICPackage[] Packages, bool Overwrite)
        {
			return DistributePackages(Packages, Overwrite, false);
		}

        public static bool DistributePackages(IXICPackage[] Packages, bool Overwrite, bool Silent)
        {
		 if (null == Packages || 0 == Packages.Length) {
			Console.WriteLine("[Distributer] ERROR: there are no packages to distribute");
			return false;
		 }

			if (1 == Packages.Length) {
				XICDistributer Distributer = new XICDistributer();

				return Distributer.DistributePackage(Packages[0], Overwrite);
			} else {
				XICDistributer Distributer;
				
				try {
					Distributer = new XICDistributer();
				} catch (Exception e) {
					Console.WriteLine("[Distributer] ERROR: could not allocate Distributer, " +
							"an exception was raised {1}.", e.Message);

					return false;
				}
				
				for(int package=0; package<Packages.Length; package++) {
					
					if (!Silent) {
						Console.WriteLine("[Distributer] Distributing package {0}/{1} {2}...",
								package+1, Packages.Length, Path.GetFileName(Packages[package].Path));
					}

					if (!Distributer.DistributePackage(Packages[package], Overwrite)) {
						Console.WriteLine("[Distributer] ERROR: Could not distribute package {0}.",
								package+1);

						//Destroy all packages that completed before this one
						for (int unwind=0; unwind<package; unwind++) {
							Console.WriteLine("[Distributer] Destroying package {0}/{1} {2}", 
									unwind+1, package, Path.GetFileName(Packages[package].Path));

							Distributer.DestroyPackage(Packages[unwind]);
						}

						return false;
					}
				}

				return true;
			}
		}


        public static void DestroyPackages(IXICPackage[] Packages)
        {
			XICDistributer Distributer;

			try {
				Distributer = new XICDistributer();

				if (null == Distributer)
					return;
			} catch (Exception) { return; }
			
			if (null == Packages)
				return;

			if (0 == Packages.Length)
				return;

            foreach (IXICPackage Package in Packages)
				Distributer.DestroyPackage(Package);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\ingestionutils\content\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__content_1_none_12.4.56.0_none_67adfd828fe07716
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__content_1_no-public-key_12.4.56.0_x-ww_49cd14a2
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_content_1
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__content_1_no-public-key_12.4.56.0_x-ww_49cd14a2
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__content_1_no-public-key_12.4.56.0_x-ww_49cd14a2.manifest
XP_MANIFEST_PATH=manifests\x86__content_1_no-public-key_12.4.56.0_x-ww_49cd14a2.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__content_1_no-public-key_12.4.56.0_x-ww_49cd14a2.cat
XP_CATALOG_PATH=manifests\x86__content_1_no-public-key_12.4.56.0_x-ww_49cd14a2.cat
XP_PAYLOAD_PATH=x86__content_1_no-public-key_12.4.56.0_x-ww_49cd14a2
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_content_1,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\ingestionutils\dll\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyKeyFile("j:\\xonline_main\\public\\ext\\sdk\\vs9sp1\\internal\\strongnamekeys\\fake\\XBLKey.snk")]
[assembly:System.Reflection.AssemblyDelaySign(false)]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\ingestionutils\dll\Installer.cs ===
using System;
using System.ComponentModel;

using xonline.common.installer;
using xonline.common.mgmt;

namespace xonline.ingestionutils
{
    [RunInstaller(true)]
    public class IngestionUtilsInstaller : XomConfiguratorInstall
    {
    }

    [RunInstaller(true)]
    public class IngestionUtilsPerformanceCounterInstaller : XomPerformanceCounterInstall
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\ingestionutils\livetitleconfig\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\ingestionutils\dll\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xblingestionutils_8b1c842ce623c912_12.4.56.0_none_19112ce40ebbb36d
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xblingestionutils_8b1c842ce623c912_12.4.56.0_x-ww_49673fa3
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xblingestionutils
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=8b1c842ce623c912
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xblingestionutils_8b1c842ce623c912_12.4.56.0_x-ww_49673fa3
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xblingestionutils_8b1c842ce623c912_12.4.56.0_x-ww_49673fa3.manifest
XP_MANIFEST_PATH=manifests\msil_xblingestionutils_8b1c842ce623c912_12.4.56.0_x-ww_49673fa3.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xblingestionutils_8b1c842ce623c912_12.4.56.0_x-ww_49673fa3.cat
XP_CATALOG_PATH=manifests\msil_xblingestionutils_8b1c842ce623c912_12.4.56.0_x-ww_49673fa3.cat
XP_PAYLOAD_PATH=msil_xblingestionutils_8b1c842ce623c912_12.4.56.0_x-ww_49673fa3
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=/keyfile:j:\xonline_main\public\ext\sdk\vs9sp1\internal\strongnamekeys\fake\XBLKey.snk]
!endif
CODESIGN_TESTKEY=j:\xonline_main\public\ext\sdk\vs9sp1\internal\strongnamekeys\fake\XBLKey.snk
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS) /keyfile:j:\xonline_main\public\ext\sdk\vs9sp1\internal\strongnamekeys\fake\XBLKey.snk /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xblingestionutils,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=8b1c842ce623c912
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\ingestionutils\dll\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_xblingestionutils_8b1c842ce623c912_12.4.56.0_none_19112ce40ebbb36d
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_xblingestionutils_8b1c842ce623c912_12.4.56.0_x-ww_49673fa3
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xblingestionutils
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=8b1c842ce623c912
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_xblingestionutils_8b1c842ce623c912_12.4.56.0_x-ww_49673fa3
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_xblingestionutils_8b1c842ce623c912_12.4.56.0_x-ww_49673fa3.manifest
XP_MANIFEST_PATH=manifests\msil_xblingestionutils_8b1c842ce623c912_12.4.56.0_x-ww_49673fa3.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_xblingestionutils_8b1c842ce623c912_12.4.56.0_x-ww_49673fa3.cat
XP_CATALOG_PATH=manifests\msil_xblingestionutils_8b1c842ce623c912_12.4.56.0_x-ww_49673fa3.cat
XP_PAYLOAD_PATH=msil_xblingestionutils_8b1c842ce623c912_12.4.56.0_x-ww_49673fa3
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=/keyfile:j:\xonline_main\public\ext\sdk\vs9sp1\internal\strongnamekeys\fake\XBLKey.snk]
!endif
CODESIGN_TESTKEY=j:\xonline_main\public\ext\sdk\vs9sp1\internal\strongnamekeys\fake\XBLKey.snk
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS) /keyfile:j:\xonline_main\public\ext\sdk\vs9sp1\internal\strongnamekeys\fake\XBLKey.snk /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xblingestionutils,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=8b1c842ce623c912
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\ingestionutils\dll\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyKeyFile("j:\\xonline_main\\public\\ext\\sdk\\vs9sp1\\internal\\strongnamekeys\\fake\\XBLKey.snk")]
[assembly:System.Reflection.AssemblyDelaySign(false)]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\ingestionutils\livetitleconfig\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__livetitleconfig_1_none_12.4.56.0_none_5e86d322054c291b
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__livetitleconfig_1_no-public-key_12.4.56.0_x-ww_810b12d7
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_livetitleconfig_1
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__livetitleconfig_1_no-public-key_12.4.56.0_x-ww_810b12d7
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__livetitleconfig_1_no-public-key_12.4.56.0_x-ww_810b12d7.manifest
XP_MANIFEST_PATH=manifests\x86__livetitleconfig_1_no-public-key_12.4.56.0_x-ww_810b12d7.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__livetitleconfig_1_no-public-key_12.4.56.0_x-ww_810b12d7.cat
XP_CATALOG_PATH=manifests\x86__livetitleconfig_1_no-public-key_12.4.56.0_x-ww_810b12d7.cat
XP_PAYLOAD_PATH=x86__livetitleconfig_1_no-public-key_12.4.56.0_x-ww_810b12d7
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_livetitleconfig_1,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\ingestionutils\Title\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\ingestionutils\livetitleconfig\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__livetitleconfig_1_none_12.4.56.0_none_5e86d322054c291b
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__livetitleconfig_1_no-public-key_12.4.56.0_x-ww_810b12d7
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_livetitleconfig_1
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__livetitleconfig_1_no-public-key_12.4.56.0_x-ww_810b12d7
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__livetitleconfig_1_no-public-key_12.4.56.0_x-ww_810b12d7.manifest
XP_MANIFEST_PATH=manifests\x86__livetitleconfig_1_no-public-key_12.4.56.0_x-ww_810b12d7.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__livetitleconfig_1_no-public-key_12.4.56.0_x-ww_810b12d7.cat
XP_CATALOG_PATH=manifests\x86__livetitleconfig_1_no-public-key_12.4.56.0_x-ww_810b12d7.cat
XP_PAYLOAD_PATH=x86__livetitleconfig_1_no-public-key_12.4.56.0_x-ww_810b12d7
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_livetitleconfig_1,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\ingestionutils\livetitleconfig\livetitleconfig.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Globalization;  //for number conversion style
using System.IO;
using System.Xml;
using System.Xml.Serialization;

using xonline.common.config;
using xonline.common.xlastutil;


namespace xonline.common.livetitleconfig
{

    #region Supporting classes and enums
    public enum Generation
    {
        Xbox,
        Xenon
    }

    public class LeaderboardConfig
    {

        [System.Xml.Serialization.XmlAttributeAttribute()]
        public int LeaderboardID;

        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string HostingLbs;

        [System.Xml.Serialization.XmlAttributeAttribute()]
        public bool IsCompetition = false;

        public LeaderboardConfig()
        {
        }

        public LeaderboardConfig( int leaderboardID, string hostingServer )
        {
            if ( hostingServer.Length > 15 )
            {
                throw new ArgumentException( "Server name is too long!" );
            }
            this.LeaderboardID = leaderboardID;
            this.HostingLbs = hostingServer;
        }

    }

    public class RRServer
    {
        [System.Xml.Serialization.XmlAttribute("servername")]
        public string servername;
    }

    public class GameMode
    {
        [System.Xml.Serialization.XmlAttribute()]
        public int modeid;

        [System.Xml.Serialization.XmlElement("RRServer")]
        public RRServer [] rrServer;
    }

    public class GameType
    {
        [System.Xml.Serialization.XmlAttribute()]
        public int typeid;

        [System.Xml.Serialization.XmlElement("GameMode")]
        public GameMode [] modes;
    }

    #endregion

    /// <summary>
    /// Summary description for LiveTitleConfig
    /// </summary>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/livetitleconfig")]
    [System.Xml.Serialization.XmlRootAttribute(Namespace="http://www.xboxlive.com/livetitleconfig", IsNullable=false)]
    public class LiveTitleConfig
    {
        public Generation   TitleGeneration;
        public uint         TitleID;

        //privilege related
        public bool         AllowCrossPlatformPlay;

        //stats related
        public int          StatsMaxReads;
        public int          StatsMaxWrites;
        public int          StatsMaxLeaderboards;
        public bool         BountyExempt;
        public float        MuSigmaBeta;
        public float        MuSigmaTau;

        //Achievement related
        public int          MinAchievements;
        public int          MaxAchievements;
        public int          MinAchievementsWithCred;
        public int          MaxAchievementsWithCred;
        public int          MinCred;
        public int          MaxCred;
        public int          MaxUniqueAchImages;
        public int          MaxContexts;
        public int          MaxContextValues;

        //Gamer Pictures
        public int          MaxGamerPictures;

        public int          MaxProperties;
        public int          MaxRichPresenceModes;
        public int          MaxGameModes;
        public bool         TitlePictureRequired;
        public bool         TitleMarketplacePictureRequired;

        //Avatar Items related
        public int          MaxAvatarItems;

        //Alternate titleids
        public int          TitleRegion;
        public int          DiscMediaID;
        public int          LiveTitleID;
        public int          AlternateTitleID1;
        public int          AlternateTitleID2;
        public int          AlternateTitleID3;
        public int          AlternateTitleID4;
        public int          Service1;
        public int          Service1AltID;
        public int          Service2;
        public int          Service2AltID;
        public int          Service3;
        public int          Service3AltID;
        public int          Service4;
        public int          Service4AltID;

        public const uint   SkillLBIDBase = 0xfffe0000;
        public const uint   RankedLBIDBase = 0xffff0000;

        //match related
        [System.Xml.Serialization.XmlElementAttribute( )]
        public string       MatchServerList;

        [System.Xml.Serialization.XmlElementAttribute( )]
        public uint         MatchExpiration;

        [System.Xml.Serialization.XmlElementAttribute( )]
        public uint         MatchDeleteDelaySeconds;

        [System.Xml.Serialization.XmlElementAttribute( )]
        public string       MatchCrossPlatform;

        [System.Xml.Serialization.XmlElementAttribute( )]
        public bool          MatchSessionLimitJobExists;

        [System.Xml.Serialization.XmlElementAttribute( )]
        public bool          MatchSessionLimitEnabled;

        [System.Xml.Serialization.XmlElementAttribute( )]
        public uint          MatchSessionMaxAvail;

        [System.Xml.Serialization.XmlElementAttribute( )]
        public uint          MatchSessionTruncateLevelAvail;

        [System.Xml.Serialization.XmlElementAttribute( )]
        public uint          MatchSessionWarnLevelAvail;

        [System.Xml.Serialization.XmlElementAttribute( )]
        public uint          MatchSessionMaxUnavail;

        [System.Xml.Serialization.XmlElementAttribute( )]
        public uint          MatchSessionTruncateLevelUnavail;

        [System.Xml.Serialization.XmlElementAttribute( )]
        public uint          MatchSessionWarnLevelUnavail;

        [System.Xml.Serialization.XmlElementAttribute( )]
        public uint          MatchSessionCleanupPeriodMinutes;

        [System.Xml.Serialization.XmlElementAttribute( )]
        public uint          MatchSessionCleanupOffsetMinutes;

        [System.Xml.Serialization.XmlElementAttribute()]
        public uint          MatchMaxTitleParamsPerQuery;

        //Miscellaneous section...
        //strings don't get serialized unless you specify it...
        [System.Xml.Serialization.XmlElementAttribute( )]
        public string clusterid;

        [System.Xml.Serialization.XmlElementAttribute(  )]
        public string locale;

        public LeaderboardConfig[] LeaderboardConfigs;

        public GameType [] MatchPartitions;

        //needed for serialization... not for developer use!
        public LiveTitleConfig( )
        {
            this.TitleGeneration            = Generation.Xenon;

            this.AllowCrossPlatformPlay     = false;

            //stats related
            this.StatsMaxReads              = 5;
            this.StatsMaxWrites             = 6;
            this.StatsMaxLeaderboards       = 282;
            this.MuSigmaBeta                = 0.5f;
            this.MuSigmaTau                 = 0.01f;
            this.LeaderboardConfigs         = null;

            this.BountyExempt               = false;

            this.MinAchievements            = 0;
            this.MaxAchievements            = 50;
            this.MinAchievementsWithCred    = 0;
            this.MaxAchievementsWithCred    = 50;
            this.MinCred                    = 0;
            this.MaxCred                    = 1000;
            this.MaxUniqueAchImages         = 80;
            this.MaxContexts                = 1000;
            this.MaxContextValues           = 100;

            this.MaxGamerPictures           = 2;

            this.MaxAvatarItems             = 5;

            this.MaxProperties              = 1000;
            this.MaxRichPresenceModes       = 16;
            this.MaxGameModes               = 16;
            this.TitlePictureRequired       = true;
            this.TitleMarketplacePictureRequired = true;

            //match related
            this.MatchServerList            = "";
            this.MatchExpiration            = 86400;

            // We will be defaulting match delete delay seconds for new titles that do not
            // already have the LTC file. If there is an existing LTC file we will not add
            // this feature for migration. We are considering adding a selection to XLAST 
            // to enable this in which case this can be upgraded to conditionally check 
            // this XLAST setting.
            this.MatchDeleteDelaySeconds    = 300;

            // semi-intelligent defaults for the match stale session cleanup job
            // since the first two are false, the job should not be created and the rest should be ignored by default.
            this.MatchSessionLimitJobExists = false;
            this.MatchSessionLimitEnabled = false;
            this.MatchSessionMaxAvail = 2000;
            this.MatchSessionTruncateLevelAvail = 1750;
            this.MatchSessionWarnLevelAvail = 1500;
            this.MatchSessionMaxUnavail = 100000;
            this.MatchSessionTruncateLevelUnavail = 82500;
            this.MatchSessionWarnLevelUnavail = 75000;
            this.MatchSessionCleanupPeriodMinutes = 10;
            this.MatchSessionCleanupOffsetMinutes = 10;
            
            // Maximum number of parameters allowed in a query (on a per-title basis)
            this.MatchMaxTitleParamsPerQuery = 22;

            //alt title id
            this.TitleRegion        = 0;
            this.DiscMediaID        = 0;
            this.LiveTitleID        = 0;
            this.AlternateTitleID1  = 0;
            this.AlternateTitleID2  = 0;
            this.AlternateTitleID3  = 0;
            this.AlternateTitleID4  = 0;
            this.Service1           = 0;
            this.Service1AltID      = 0;
            this.Service2           = 0;
            this.Service2AltID      = 0;
            this.Service3           = 0;
            this.Service3AltID      = 0;
            this.Service4           = 0;
            this.Service4AltID      = 0;
        }

        public LiveTitleConfig( uint titleID, Generation ConsoleGeneration ) : this( titleID )
        {
            this.TitleGeneration         = ConsoleGeneration;

            switch ( ConsoleGeneration )
            {
                case Generation.Xenon:
                    //nothing yet, all defaults are Xenon-oriented
                    break;

                case Generation.Xbox:
                    this.StatsMaxWrites          = 5;
                    this.StatsMaxLeaderboards   = 100;
                    this.MatchDeleteDelaySeconds = 0;
                    break;
            }
        }

        public LiveTitleConfig( uint titleID ) : this()
        {
            //task: give properties their proper default values, add an Xbox-oriented constructor later...
            this.TitleID                    = titleID;
        }

      
        public static LiveTitleConfig Get( uint titleID )
        {
            //retrives the LiveTitleConfig from NPDB for this title

            using (SqlConnection ltcConn = new SqlConnection(ConfigUtil.NpdbConnectionString))
            {
                ltcConn.Open();
                SqlCommand ltcCmd = ltcConn.CreateCommand();
                ltcCmd.CommandType = CommandType.StoredProcedure;
                ltcCmd.CommandText = "dbo.p_Live_Title_Config_Get";

                ltcCmd.Parameters.Add( "@i_title_id", SqlDbType.Int ).Value = (int) titleID;
                ltcCmd.Parameters["@i_title_id"].Direction = ParameterDirection.Input;

                //task: do something with the rows affected?
                SqlDataReader ltcReader = ltcCmd.ExecuteReader();

                if ( ltcReader.Read() )
                {
                    //deserialize ltc
                    LiveTitleConfig ltc = LiveTitleConfig.FromXml( ltcReader.GetString( ltcReader.GetOrdinal( "xml_title_config" ) ) );
                    return ltc;
                }
                else
                {
                    //review: throw an exception?
                    return null;
                }
            }
        }

        //used for creating an initial titleconfig that reflects the title's information...
        //NOTE: similar code is in statsxlastutil.cs.  this one creates LeaderboardConfigs, the other creates Leaderboards
        public static LiveTitleConfig GetLiveTitleConfigFromXlast( string xlastXml, string lbServer, string matchsvr )
        {

            XboxLiveSubmissionProject xlsp = XlastUtil.GetXlastFromXml( xlastXml );
            LiveTitleConfig ltc = new LiveTitleConfig( UInt32.Parse( xlsp.GameConfigProject.titleId.Substring( 2 ), NumberStyles.HexNumber ), Generation.Xenon );
            ltc.MatchServerList = matchsvr;
            LeaderboardConfig lb;
            ArrayList leaderboards = new ArrayList( );

            //
            //  Change defaults based on title type
            //

            switch (xlsp.GameConfigProject.titleType)
            {
                case XlastUtil.TITLE_TYPE_SYSTEM:
                    ltc.MinAchievements = 0;
                    ltc.MaxAchievements = 0;
                    ltc.MinAchievementsWithCred = 0;
                    ltc.MaxAchievementsWithCred = 0;
                    ltc.MinCred = 0;
                    ltc.MaxCred = 0;
                    ltc.MaxGamerPictures = Int32.MaxValue;
                    ltc.MaxAvatarItems = 0;
                    break;

                case XlastUtil.TITLE_TYPE_FULL:
                    ltc.MinAchievements = 5;
                    ltc.MaxAchievements = 80;
                    ltc.MinAchievementsWithCred = 5;
                    ltc.MaxAchievementsWithCred = 80;
                    ltc.MinCred = 1000;
                    ltc.MaxCred = 1750;
                    ltc.MaxAvatarItems = 5;
                    break;

                case XlastUtil.TITLE_TYPE_DEMO:
                    ltc.MinAchievements = 0;
                    ltc.MaxAchievements = 0;
                    ltc.MinAchievementsWithCred = 0;
                    ltc.MaxAchievementsWithCred = 0;
                    ltc.MinCred = 0;
                    ltc.MaxCred = 0;
                    ltc.MaxAvatarItems = 0;
                    break;

                case XlastUtil.TITLE_TYPE_DOWNLOADABLE:
                    ltc.MinAchievements = 12;
                    ltc.MaxAchievements = 15;
                    ltc.MinAchievementsWithCred = 5;
                    ltc.MaxAchievementsWithCred = 15;
                    ltc.MinCred = 200;
                    ltc.MaxCred = 250;
                    ltc.MaxAvatarItems = 2;
                    break;
            }

            if (
                ( xlastXml.IndexOf( "<StatsViews" ) > 0 ) &&
                ( xlsp.GameConfigProject.StatsViews != null ) &&
                ( xlsp.GameConfigProject.StatsViews.StatsView != null ) &&
                ( xlsp.GameConfigProject.StatsViews.StatsView.Length > 0 )
                )
            {
                //add leaderboards with default server + plus a couple extra for the skill leaderboards
                foreach( StatsView sv in xlsp.GameConfigProject.StatsViews.StatsView )
                {
                    lb = new LeaderboardConfig(
                        (int) sv.id,
                        lbServer
                        );
                    leaderboards.Add( lb );
                }
            }

            if (
                ( xlastXml.IndexOf( "<GameModes" ) > 0 ) &&
                ( xlsp.GameConfigProject.GameModes != null ) &&
                ( xlsp.GameConfigProject.GameModes.GameMode != null ) &&
                ( xlsp.GameConfigProject.GameModes.GameMode.Length > 0 )
                )
            {

                int lbID = 0;
                int gameModeContext = xlsp.GameConfigProject.GameModes.GameMode.Length;

                //add skill leaderboards, if there are any game modes...
                //only add skill leaderboards if the game mode context was found
                foreach ( LiveGameMode gm in xlsp.GameConfigProject.GameModes.GameMode )
                {
                    //SkillLB - Ranked id: 0xffff0000 + GameModes\GameMode\Value
                    lbID = (int) ( LiveTitleConfig.SkillLBIDBase + gm.Value );
                    lb = new LeaderboardConfig(
                        lbID,
                        lbServer
                        );
                    leaderboards.Add( lb );

                    //SkillLB - Ranked id: 0xffff0000 + Contexts\Context\ContextValue\contextValue
                    lbID = (int) ( LiveTitleConfig.RankedLBIDBase + gm.Value );
                    lb = new LeaderboardConfig(
                        lbID,
                        lbServer
                        );
                    leaderboards.Add( lb );
                }
            }

            if ( leaderboards.Count > 0 )
            {
                //leaderboard ID's aren't necessarily sequential...
                //so we can't just put them in an array using the lbid as the index
                ltc.LeaderboardConfigs = new LeaderboardConfig[ leaderboards.Count ];
                leaderboards.CopyTo( ltc.LeaderboardConfigs );
            }

            //  If multiple platforms specified, set the cross platform play privilege.
            ltc.AllowCrossPlatformPlay = 
                (xlsp.GameConfigProject.ProductInformation.Platform != null) &&
                (xlsp.GameConfigProject.ProductInformation.Platform.Length > 1);

            return ltc;
        }

        //        //returns the titleID of the string it just wrote...
        //        public static uint PutLiveTitleConfigFromDrive( string ltcPath )
        //        {
        //            StreamReader ltcReader = new StreamReader( ltcPath );
        //            string ltcXml = xlastReader.ReadToEnd();
        //
        //            //task: this is dumb... serialize it to get the titleid, then deserialize it to save it...
        //            LiveTitleConfig ltc = LiveTitleConfig.FromXml( ltcXml );
        //            LiveTitleConfig.SaveLiveTitleConfig( ltc.TitleID, ltc.ToXml() );
        //        }
        public static LiveTitleConfig UpdateLiveTitleConfigFromExisting( LiveTitleConfig ltcNew, LiveTitleConfig ltc, string LbServer )
        {
            // if none have leaderboards, then just return
            if (((ltc.LeaderboardConfigs    == null) || (ltc.LeaderboardConfigs.Length    == 0)) &&
                ((ltcNew.LeaderboardConfigs == null) || (ltcNew.LeaderboardConfigs.Length == 0)))
            {
                return ltc;
            }

            //if old one has none, new one has
            //or, if old one has, but new one doesn't,
            //  then assign and return
            if (
                ((ltc.LeaderboardConfigs == null || ltc.LeaderboardConfigs.Length == 0) && (ltcNew.LeaderboardConfigs != null && ltcNew.LeaderboardConfigs.Length != 0)) ||
                ((ltc.LeaderboardConfigs != null && ltc.LeaderboardConfigs.Length != 0) && (ltcNew.LeaderboardConfigs == null || ltcNew.LeaderboardConfigs.Length == 0))
                )
            {
                //old leaderboard configs will get cleaned up...
                ltc.LeaderboardConfigs = ltcNew.LeaderboardConfigs;
                return ltc;
            }
            
            // if both have leaderboards then update new from the old
            if (ltc.LeaderboardConfigs != null && ltc.LeaderboardConfigs.Length != 0 && 
                ltcNew.LeaderboardConfigs != null && ltcNew.LeaderboardConfigs.Length != 0)
            {
                foreach (LeaderboardConfig newLc in ltcNew.LeaderboardConfigs)
                {
                    foreach (LeaderboardConfig oldLc in ltc.LeaderboardConfigs)
                    {
                        if (oldLc.LeaderboardID == newLc.LeaderboardID &&
                             oldLc.IsCompetition == newLc.IsCompetition)
                        {
                            newLc.HostingLbs = oldLc.HostingLbs;
                            break;
                        }
                    }
                }

                ltc.LeaderboardConfigs = ltcNew.LeaderboardConfigs;
                return ltc;
            }

            // and the last case is the exclusive or (for which we don't actually
            // need to test) -  the old leaderboards are cleaned up / overwritten
            ltc.LeaderboardConfigs = ltcNew.LeaderboardConfigs;
            return ltc;
        }

        //return true if found
        public bool UpdateHostingServerForLb(string szServer, int nLbIDToReplace)
        {
            foreach (LeaderboardConfig config in this.LeaderboardConfigs)
            {
                if (config.LeaderboardID == nLbIDToReplace)
                {
                    config.HostingLbs = szServer;
                    return true;
                }
            }

            return false;
        }

        public static LiveTitleConfig MergeFragmentOverrides(LiveTitleConfig ltc, string ltcFragmentFile)
        {
            XmlDocument ltcDoc = new XmlDocument();
            XmlDocument ltcFragmentDoc = new XmlDocument();

            ltcDoc.LoadXml(ltc.ToXml());
            ltcFragmentDoc.Load(ltcFragmentFile);

            XmlNamespaceManager nsmgr = new XmlNamespaceManager(ltcDoc.NameTable);
            nsmgr.AddNamespace("ltc", "http://www.xboxlive.com/livetitleconfig");

            //
            //  Iterate through each child of the root, and
            //  apply the corresponding override to the LTC file.
            //

            foreach (XmlNode childNode in ltcFragmentDoc.DocumentElement.ChildNodes)
            {
                //
                //  Ignore certain elements if they occur in the fragment
                //

                if (childNode.Name == "TitleGeneration" ||
                    childNode.Name == "TitleID" ||
                    childNode.Name == "DiscMediaID" ||
                    childNode.Name == "LiveTitleID" ||
                    childNode.Name == "AlternateTitleID1" ||
                    childNode.Name == "AlternateTitleID2" ||
                    childNode.Name == "AlternateTitleID3" ||
                    childNode.Name == "AlternateTitleID4" ||
                    childNode.Name == "LeaderboardConfigs" ||
                    childNode.Name == "MatchServerList"
                    )
                {
                    Console.WriteLine(string.Format("LTC fragment file is not allowed to override {0}, ignoring this element.", childNode.Name));
                    continue;
                }

                if (childNode.NodeType == XmlNodeType.Element)
                {
                    XmlNode ltcDocChildNode = ltcDoc.SelectSingleNode("//ltc:" + childNode.Name, nsmgr);
                    if (ltcDocChildNode != null)
                    {
                        ltcDocChildNode.InnerText = childNode.InnerText;
                    }
                }
            }

            return LiveTitleConfig.FromXml(ltcDoc.OuterXml);
        }

        public void Save ()
        {
            LiveTitleConfig.SaveLiveTitleConfig( this.TitleID, this.ToXml() );
        }

        //there must already be an XLAST config for this title, or you'll get a SQLException
        public static void SaveLiveTitleConfig( uint titleID, string liveTitleConfig )
        {

            //retrives the LiveTitleConfig from NPDB for this title

            using (SqlConnection ltcConn = new SqlConnection(ConfigUtil.NpdbConnectionString))
            {
                ltcConn.Open();
                SqlCommand ltcCmd = ltcConn.CreateCommand();
                ltcCmd.CommandType = CommandType.StoredProcedure;
                ltcCmd.CommandText = "dbo.p_Live_Title_Config_Set";

                ltcCmd.Parameters.Add( "@i_title_id", SqlDbType.Int ).Value = (int) titleID;
                ltcCmd.Parameters["@i_title_id"].Direction = ParameterDirection.Input;

                ltcCmd.Parameters.Add( "@xml_title_config", SqlDbType.NText ).Value = liveTitleConfig;
                ltcCmd.Parameters["@xml_title_config"].Direction = ParameterDirection.Input;

                //task: do something with the rows affected?
                int rows = ltcCmd.ExecuteNonQuery();

            }

        }

        public static void Delete( uint titleID )
        {

            using (SqlConnection ltcConn = new SqlConnection(ConfigUtil.NpdbConnectionString))
            {
                ltcConn.Open();
                SqlCommand ltcCmd = ltcConn.CreateCommand();
                ltcCmd.CommandType = CommandType.StoredProcedure;
                ltcCmd.CommandText = "dbo.p_Live_Title_Config_Delete";

                ltcCmd.Parameters.Add( "@i_title_id", SqlDbType.Int ).Value = (int) titleID;
                ltcCmd.Parameters["@i_title_id"].Direction = ParameterDirection.Input;

                //task: do something with the rows affected?
                int rows = ltcCmd.ExecuteNonQuery();
            }
        }



        public string ToXml()
        {
            XmlSerializer serializer = new XmlSerializer( typeof( LiveTitleConfig ) );
            StringWriter sw = new StringWriter();
            serializer.Serialize( sw, this );
            return sw.ToString();
        }

        public static LiveTitleConfig FromXml( string liveTitleConfig )
        {
            XmlTextReader xmlReader = new XmlTextReader( new StringReader( liveTitleConfig ) );
            XmlSerializer serializer = new XmlSerializer( typeof( LiveTitleConfig ) );
            LiveTitleConfig ltc = ( LiveTitleConfig ) serializer.Deserialize( xmlReader );

            return ltc;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\ingestionutils\Title\ImageLibrary.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Data.SqlTypes;
using System.Globalization;
using System.IO;
using xonline.common.config;
using Microsoft.Webstore.WstClient;
using xonline.common.sql.webstore;
using xonline.common.tools.stutilcore;
using xonline.common.xlastutil;


namespace xonline.common.title
{
    public class ImageProp
    {
        protected string titleId;
        protected string imageType;
        protected string imageFile;
        protected ulong imageId;

        /* ImageLibary (constructor)
         * ------------------------------------
         * The constructor is used to validate the Images section of
         * the GCP portion of the XLAST file and to create a simply
         * mapping of image IDs to actual file+path specifications.
         *
         * The intention here is to weed out Images that may not have
         * an id specified or an actual file
         *
         * Parameters:  
         *
         *
        */
        public ImageProp(string _titleId, string _imageType, ulong _imageId, string _imageFile)
        {
            titleId   = _titleId;
            imageType = _imageType;
            imageId   = _imageId;
            imageFile = _imageFile;
        }

        protected virtual string StoragePath
        {
            get
            {
                //    achievement:  //global/t:<titleId>/ach/0/<image id>
                //    gamertiles:   //global/t:<titleid>/tile/0/<image id>
                //    game icon:    //global/t:<titleid>/icon/0/8000
                //    mktplc icon:  //global/t:<titleid>/marketplace/0/1

                return "//global/t:" + titleId + "/" + imageType + "/0/" + imageId.ToString("X").ToLower();
            }
        }


        public bool PropToStorage()
        {
            uint    uTitleId = UInt32.Parse(titleId, NumberStyles.HexNumber);

            try
            {
                StUtil.Write(0, 0, this.StoragePath, uTitleId, true, imageFile);

            }
            catch (Exception e)
            {
                Console.WriteLine("StUtil.Write() generated an exception: " + e.Message);
                return false;
            }

            return true;
        }
    } // class ImageProp

    public class AvatarItemImageProp : ImageProp
    {
        Guid avatarItemGuid;
        string suffix;

        public AvatarItemImageProp(string _titleId, Guid _avatarItemGuid, string _imageFile, string _suffix)
            : base(_titleId, null, 0,_imageFile)
        {
            this.avatarItemGuid = _avatarItemGuid;
            this.suffix = _suffix;
        }

        public Guid Guid
        {
            get { return this.avatarItemGuid; }
            set { this.avatarItemGuid = value; }
        }

        protected override string StoragePath
        {
            get
            {
                //    avatar items  //global/t:<titleId>/avataritem/<avatar item guid>

                return "//global/t:" + titleId + "/avataritem/" + this.avatarItemGuid.ToString() + "/" + this.suffix;
            }
        }

        public static bool IsAvatarItemNeutral(Guid avatarItemGuid1)
        {
            // body types
            // 1 - male
            // 2 - female
            // 3 - neutral
            byte bodyType = (byte)((avatarItemGuid1.ToByteArray())[6] & 0x0F);
            return bodyType == 3;
        }

        public readonly static string SmallIconSuffix = "64";
        public readonly static string MediumIconSuffix = "128";
        public readonly static string LargeIconSuffix = "300";
        public readonly static string PngFileExtension = ".png";
    }

    public class ImageLibrary : BaseLibrary
    {
        Hashtable   library;
        ArrayList   proplist;
        string      strTitleId;

        
        /* ImageLibary (constructor)
         * ------------------------------------
         * The constructor is used to validate the Images section of
         * the GCP portion of the XLAST file and to create a simply
         * mapping of image IDs to actual file+path specifications.
         *
         * The intention here is to weed out Images that may not have
         * an id specified or an actual file
         *
        */

        public ImageLibrary(uint titleId, Images images, Achievements achievements, GamerPictures gamerPictures, string localPath)
            : this(false,0, titleId, images, achievements, gamerPictures, null, localPath)
        {
        }

        public ImageLibrary(bool typeSpecified, ulong titleType, uint titleId, Images images, Achievements achievements, GamerPictures gamerPictures, AvatarItems avatarItems, string localPath) : base()
        {
            ulong      gameIconId  = (ulong) 32768;  //  0x8000 = Game Icon image ID (related to X_IMAGEID_GAME in xam.x)
            ulong      mktplIconId = (ulong) 32772;  // '0x8004 = Marketplace Icon image ID  (related to X_IMAGEID_GAME_MARKETPLACE in xam.x)

            library   = new Hashtable();
            proplist  = new ArrayList();

            strTitleId = titleId.ToString("x");

            //-----------------------------------------------------------------
            // First we need to examine each Image in the Images section and 
            // confirm that the file associated with it is actually present
            // 
            if (images.Image != null)
            {
                foreach (Image x in images.Image)
                {
                    if (!x.idSpecified)
                    {
                        errors.Add("Image " + x.friendlyName + " does not have an ID");
                        continue;
                    }

                    string  fspec  = x.Path;
                    int     delim  = fspec.LastIndexOf('\\');
                    string  name   = localPath + "\\" + ((delim<0) ? fspec.ToLower() : fspec.Substring(delim+1, fspec.Length - delim - 1).ToLower());

                    //bug 44000 - System titles are not required to supply title and marketplace images. 
                    //SPAC already verifies all paths for non-system titles.  Since only system
                    //titles can have blank image paths, and only for the Marketplace and Game Tile images,
                    //then it's ok to pass on a blank image without further verification, since only system 
                    //titles should have this property
                    //For maintenance... it's not good to have the same check in multiple places.

                    //But, in case someone wants to verify this more carefully here, this is the information
                    ///// TitleType defines whether this title is a full game, a demo, a download, etc.
                    //public enum TitleType : uint
                    //{
                    //    System                  = 0x00000000,
                    //    Full                    = 0x00000001,
                    //    Demo                    = 0x00000002,
                    //    Download                = 0x00000003,
                    //}

                    if ( fspec.Length == 0 )
                    {
                        continue;
                    }

                    if (!File.Exists(name ))
                    {
                        errors.Add("Image " + x.friendlyName + " file " + name + " was not found in " + localPath);
                        continue;
                    }
                                     
                    if (library[x.id] != null)
                    {
                        // uh oh, this Id is already in the library which means the XLAST specified the same value twice!
                        errors.Add("Image " + x.friendlyName + " id of " + x.id + " is already in use (specified twice in XLAST)" );
                        continue;
                    }

                    library.Add(x.id, name);
                }
            }

            //-----------------------------------------------------------------
            // Now, go through all the entries in the GCP that could refer to
            // these images so we can determine what the type of the image is
            // and construct the storage path accordingly
            // 

            AddGameIcon(typeSpecified, titleType, gameIconId);

            AddMarketplaceIcon(typeSpecified, titleType, mktplIconId);

            AddAchievementImages(achievements);

            AddGamerPictures(gamerPictures);

            AddAvatarItemsImages(avatarItems, localPath);

        } // ImageLibrary(ctor)

        private void AddGameIcon(bool typeSpecified, ulong titleType, ulong gameIconId)
        {
            if (library[gameIconId] != null)
            {
                proplist.Add(new ImageProp(strTitleId, "icon", gameIconId, (string)library[gameIconId]));
            }
            else
            {
                if (!typeSpecified || titleType != 0)
                {
                    errors.Add("Game icon specified an image does not exist or was not valid");
                }
            }
        }

        private void AddMarketplaceIcon(bool typeSpecified, ulong titleType, ulong mktplIconId)
        {
            if (library[mktplIconId] != null)
            {
                proplist.Add(new ImageProp(strTitleId, "marketplace", 1, (string)library[mktplIconId]));  // storage path for marketplace image uses a '1' instead of the actual image ID
            }
            else
            {
                if (!typeSpecified || titleType != 0)
                {
                    errors.Add("Marketplace icon specified an image does not exist or was not valid");
                }
            }
        }
        
        private void AddAchievementImages(Achievements achievements)
        {
            if (achievements != null && achievements.Achievement != null)
            {
                foreach (XboxLiveSubmissionProjectGameConfigProjectAchievementsAchievement x in achievements.Achievement)
                {
                    if (x.imageIdSpecified)
                    {
                        if (library[x.imageId] != null)
                        {
                            proplist.Add(new ImageProp(strTitleId, "ach", x.imageId, (string)library[x.imageId]));
                        }
                        else
                        {
                            errors.Add("Achievement " + x.friendlyName + " specified an imageId " + x.imageId + " that either does not exist or was not valid");
                        }
                    }
                    else
                    {
                        errors.Add("Achievement " + x.friendlyName + "did not specify an associated image");
                    }
                }
            }
        }

        private void AddGamerPictures(GamerPictures gamerPictures)
        {
            if (gamerPictures != null && gamerPictures.Picture != null)
            {
                foreach (Picture x in gamerPictures.Picture)
                {
                    if (x.idSpecified)
                    {
                        // GamerTile images are a little different:  The id attribute in the Picture element is
                        // actually the low order word of the Image id.  In order to support large and small
                        // images, we need to add 0x10000 and 0x20000 to this picture id
                        //
                        if ((x.id & 0xFFFF0000) == 0)
                        {
                            ulong imageId;

                            imageId = x.id | 0x10000;
                            if (library[imageId] != null)
                                proplist.Add(new ImageProp(strTitleId, "tile", imageId, (string)library[imageId]));
                            else
                                errors.Add("Gamer Picture (small)" + x.friendlyName + " specified an imageId " + imageId + " that either does not exist or was not valid");

                            imageId = x.id | 0x20000;
                            if (library[imageId] != null)
                                proplist.Add(new ImageProp(strTitleId, "tile", imageId, (string)library[imageId]));
                            else
                                errors.Add("Gamer Picture (large)" + x.friendlyName + " specified an imageId " + imageId + " that either does not exist or was not valid");
                        }
                        else
                        {
                            errors.Add("Gamer Picture " + x.friendlyName + " specified an imageId " + x.id + " that had reserved bits in the high order word set");
                        }

                    }
                    else
                    {
                        errors.Add("Gamer Picture " + x.friendlyName + " did not specify an associated image");
                    }
                }
            }
        }

        private void AddAvatarItemsImages(AvatarItems avatarItems, string localPath)
        {
            if (avatarItems != null && avatarItems.AvatarItem != null)
            {
                foreach (XboxLiveSubmissionProjectGameConfigProjectAvatarItemsAvatarItem avatarItem in avatarItems.AvatarItem)
                {
                    // Process Avatar Item for Gender 1

                    // the 64x64 avatar item png should be in the image tables
                    if (library[avatarItem.imageId1] != null)
                    {
                        proplist.Add(new AvatarItemImageProp(strTitleId, avatarItem.guid1, (string)library[avatarItem.imageId1], AvatarItemImageProp.SmallIconSuffix));
                        // double prop the 64x64 icon to ach domain for the console
                        proplist.Add(new ImageProp(strTitleId, "ach", avatarItem.imageId1, (string)library[avatarItem.imageId1]));
                    }
                    else
                    {
                        errors.Add("Avatar Item " + avatarItem.guid1 + " specified an imageId " + avatarItem.imageId1 + " that either does not exist or was not valid");
                    }
                    
                    // the 128x128 avatar item png needs to be added manually because it is not part of the image table
                    string avatarItemMedImage1 = Path.Combine(localPath, avatarItem.guid1.ToString("D") + AvatarItemImageProp.PngFileExtension);
                    if (File.Exists(avatarItemMedImage1))
                    {
                        proplist.Add(new AvatarItemImageProp(strTitleId, avatarItem.guid1, avatarItemMedImage1, AvatarItemImageProp.MediumIconSuffix));
                    }
                    else
                    {
                        errors.Add("Avatar Item " + avatarItem.guid1 + " does not have an image at " + avatarItemMedImage1);
                    }

                    if (!AvatarItemImageProp.IsAvatarItemNeutral(avatarItem.guid1))
                    {
                        // Process Avatar Item for Gender 2

                        // the 64x64 avatar item png should be in the image tables
                        if (library[avatarItem.imageId2] != null)
                        {
                            proplist.Add(new AvatarItemImageProp(strTitleId, avatarItem.guid2, (string)library[avatarItem.imageId2], AvatarItemImageProp.SmallIconSuffix));
                            // double prop the 64x64 icon to ach domain for the console
                            proplist.Add(new ImageProp(strTitleId, "ach", avatarItem.imageId2, (string)library[avatarItem.imageId2]));
                        }
                        else
                        {
                            errors.Add("Avatar Item " + avatarItem.guid2 + " specified an imageId " + avatarItem.imageId2 + " that either does not exist or was not valid");
                        }

                        // the 128x128 avatar item png needs to be added manually because it is not part of the image table
                        string avatarItemMedImage2 = Path.Combine(localPath, avatarItem.guid2.ToString("D") + AvatarItemImageProp.PngFileExtension);
                        if (File.Exists(avatarItemMedImage2))
                        {
                            proplist.Add(new AvatarItemImageProp(strTitleId, avatarItem.guid2, avatarItemMedImage2, AvatarItemImageProp.MediumIconSuffix));
                        }
                        else
                        {
                            errors.Add("Avatar Item " + avatarItem.guid2 + " does not have an image at " + avatarItemMedImage2);
                        }
                    }
                }
            }
        }

        public bool PropImages()
        {
            bool fOk = true;

            foreach (ImageProp x in proplist)
            {
                if (!x.PropToStorage())
                    fOk = false;
            }

            return fOk;
        }
    } // class ImageLibrary

} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\ingestionutils\Title\BaseLibrary.cs ===
using System;
using System.Collections;
using System.Globalization;


namespace xonline.common.title
{
     public class BaseLibrary
     {
         protected ArrayList   errors;
 
         protected BaseLibrary()
         {
             errors = new ArrayList();
         }
 
 
         public bool ErrorsDetected()
         {
             return (errors.Count > 0) ? true : false;
         }
     
         public string ErrorText()
         {
             string text = "Detected " + errors.Count + " errors\n";
     
             foreach (string x in errors)
                 text += "    " + x + "\n";
     
             return text;
         }
     }

} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\ingestionutils\Title\StringLibrary.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Data.SqlTypes;
using System.Globalization;
using System.IO;
using xonline.common.config;
using Microsoft.Webstore.WstClient;
using xonline.common.sql.webstore;
using xonline.common.tools.stutilcore;
using xonline.common.xlastutil;


namespace xonline.common.title
{
    public class StringLibrary  : BaseLibrary
     {
         Hashtable   library;
      
         public Hashtable   cultures;
         public Hashtable   locales;
         public ArrayList   languages;
 
         string      defaultLocale;
         int         defaultLanguageId;
         int         cLocales;

         public const string XLAST_CHINESE_LOCALE_CODE = "zh-CHT";
         public const int    UODB_CHINESE_LANGUAGE_ID  = 8;

 
         
         /* StringLibrary (constructor)
          * ------------------------------------
          * The constructor is used to preparse and validate the LocalizedStrings
          * section of the GCP portion of the XLAST file.  The actions here are
          * folded into a single class because the some activities here depend on
          * information in the UODB.
          *
          *
          * There are several lists constructed:
          *
          * cultures (hashtable)
          * calculated from the UODB and maps each distinct language ID
          * to an ArrayList of all the culture IDs that use that language
          *
          * library (GCP)
          * Maps each string ID to a child hashtable which in turn maps each
          * language ID to a translated string.  Note that because this is
          * constructed from the GCP, if a given langauge is not listed as
          * supported, an entry will not be created for that language ID in 
          * the child hashtable (IE it is the class' responsibility to calculate
          * the correct default translation to use based on the setting of the
          * GCP's defaultLocale setting.)
          *
          * locales (GCP + UODB)
          * Despite its name, the actual purpose of this table is to create a
          * list of language IDs that map to the corresponding language CODEs
          * (eg en-US) that are present in the GCP.
          *
          *
         */
         public StringLibrary(LocalizedStrings strings) : base()
         {
             cultures  = new Hashtable(50);
             locales   = new Hashtable(strings.SupportedLocale.Length);
             library   = new Hashtable(strings.LocalizedString.Length);
 
 
             if (strings.defaultLocale == null)
                 errors.Add("XLAST did not specify a defaultLocale for LocalizedStrings!");
             else
                 defaultLocale = strings.defaultLocale;
 
 
             if (strings.SupportedLocale == null)
                 errors.Add("XLAST did not specify any SupportedLocales for LocalizedStrings!");
             else
                 cLocales = strings.SupportedLocale.Length;
 
 
 
             foreach (SupportedLocale x in strings.SupportedLocale)
             {
                 // $BUG: Xenon#53651 -- we know that the XLAST file will specify
                 // Chineese as zh-cht, but we also know that the t_cultures table
                 // doesn't have an entry for zh-CHT, so the loop below won't be
                 // able to draw up a match.  To compensate, we're going to hardcode
                 // a mapping for zh-CHT to language ID 8
                 //
                 if (String.Compare(x.locale, XLAST_CHINESE_LOCALE_CODE, true) == 0)
                     locales.Add(x.locale, UODB_CHINESE_LANGUAGE_ID);
                 else
                     locales.Add(x.locale, 0);
             }
 
     
             using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.READORWRITE_COMMANDTYPE))
             {
                 // Data is partitioned by user puid
                 ws.PartitionType   = WstPartitionType.Logical;
                 ws.Partition       = WstCommand.AnyPartition;
                 ws.StoredProc      = "dbo.p_svc_get_cultures";
                 
                 WstDataReader r = ws.Execute();
 
                 while (r.Read())
                 {
                     int cultureID       = r.GetInt32(0);
                     int languageID      = r.GetInt32(4);
                     string cultureCode  = r.GetString(3);
                     byte bLiveSupported  = (byte) r.GetByte(5);
 

                     // Xenon#85146: The XLAST file can contain translations with xx-XX codes
                     // that map to cultures (t_cultures records) that are not 'live enabled' 
                     // (ti_xbox_live_supported != 0).  Currently (02/07/07) pl-PL is one such
                     // case.  It's i_language_id is inappropriately set to 1 which suggests
                     // that the translations it supplies are for english.  To avoid Hashtable
                     // key collisions, we ignore records that are indicated as not supporting
                     // live, thereby avoiding this potential headache.  The corollary here then
                     // is that when such records ARE set to indicate live support, they must
                     // also supply a valid and unique (at least among the codes enumerated in
                     // an XLAST file) language ID
                     //
                     if (bLiveSupported != 0)
                     {
                         if (locales.ContainsKey(cultureCode))
                             locales[cultureCode] = languageID;
                     
                         if (defaultLocale == cultureCode)
                             defaultLanguageId = languageID;
                     
                         if (cultures[languageID] == null)
                             cultures[languageID] = new ArrayList();
                    
                         ((ArrayList)cultures[languageID]).Add(cultureID);
                     }
                 }
             }
     
 
             //-----------------------------------------------------------------
             // Now that we have our reference tables loaded, rip through the
             // XLAST and break out the localized strings into a dual level 
             // HashTable parititioned first by string ID and then by language ID
             //
             if (strings.LocalizedString != null)
             {
                 foreach (LocalizedString x in strings.LocalizedString)
                 {
                     if (x.idSpecified)
                     {
                         Hashtable y = new Hashtable(cLocales);
 
                         foreach (Translation z in x.Translation)
                         {
                             int languageID = (int) locales[z.locale];

                             // If the languageID for the locale is still set to zero, then it means that we were
                             // unable correlate it to a t_cultures record which means that we don't know what
                             // language the translation is in.  As such, we can't do anything with the string
                             // so we have no recourse but to ignore it
                             //
                             if (languageID != 0)
                             {
                                 if (y.ContainsKey(languageID))
                                 {
                                     Console.WriteLine("WARNING: Duplicate language translation " + z.locale + " to language " + languageID);
                                 }
                                 else
                                 {
                                     // bug 40260 - a space will deserialize as a null, causing problems downstream
                                     // change it here, and everyone should be happy. 
                                     if ( z.Value == null ) 
                                     {
                                         y.Add(languageID, "");
                                     }
                                     else
                                     {
                                         y.Add(languageID, z.Value);
                                     }
                                 }
                             }
                         }
 
                         library.Add(x.id, y);
                     }
                 }
             }
         } // StringLibrary(ctor)
 
 
         public string GetString(System.UInt16 id, int languageId)
         {
             Hashtable t = (Hashtable) library[id];

             if(t == null)
                 throw new ApplicationException(string.Format("The specified string id {0} does not exist in the LocalizedStrings collection.", id));
 
             if (!locales.ContainsValue(languageId))
                 languageId = defaultLanguageId;
 
             return (string) t[languageId];
         }
 
         public bool Exists(System.UInt16 id, int languageId)
         {
             Hashtable t = (Hashtable) library[id];

             if(t == null)
                 return false;
 
             if (!locales.ContainsValue(languageId))
                 languageId = defaultLanguageId;
 
             return t.ContainsKey(languageId);
         }

     } // class StringLibrary
 
} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\ingestionutils\xlastutil\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\ingestionutils\Title\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__title_2_none_12.4.56.0_none_49c26ba804b09336
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__title_2_no-public-key_12.4.56.0_x-ww_fea78142
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_title_2
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__title_2_no-public-key_12.4.56.0_x-ww_fea78142
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__title_2_no-public-key_12.4.56.0_x-ww_fea78142.manifest
XP_MANIFEST_PATH=manifests\x86__title_2_no-public-key_12.4.56.0_x-ww_fea78142.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__title_2_no-public-key_12.4.56.0_x-ww_fea78142.cat
XP_CATALOG_PATH=manifests\x86__title_2_no-public-key_12.4.56.0_x-ww_fea78142.cat
XP_PAYLOAD_PATH=x86__title_2_no-public-key_12.4.56.0_x-ww_fea78142
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_title_2,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\ingestionutils\Title\ReferenceData.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Data.SqlTypes;
using System.Globalization;
using System.IO;
using xonline.common.config;
using Microsoft.Webstore.WstClient;
using xonline.common.sql.webstore;
using xonline.common.tools.stutilcore;
using xonline.common.xlastutil;


namespace xonline.common.title
{
    public class ReferenceData : BaseLibrary
    {
        public Hashtable   hdtvModes;
        public Hashtable   ratings;
        public Hashtable   genres;

        
        /* ReferenceData (constructor)
         * ------------------------------------
         * The constructor has two functions>
         * 1) to load all dynamic reference data from any online databases
         * 2) to perform all possible XLAST validation against this data
         *
         * The intention here is to weed out Images that may not have
         * an id specified or an actual file
         *
         * Parameters:  
         *
         *
        */
        public ReferenceData(ProductInformation info)  : base()
        {
            hdtvModes = new Hashtable(30);
            ratings   = new Hashtable(100);
            genres    = new Hashtable(50);
    
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.READORWRITE_COMMANDTYPE))
            {
                ws.PartitionType   = WstPartitionType.Logical;
                ws.Partition       = WstCommand.AnyPartition;
                ws.StoredProc      = "dbo.p_svc_get_HDTVModes";
                
                WstDataReader r = ws.Execute();

                while (r.Read())
                {
                    if (r.GetValue(0) != DBNull.Value && r.GetValue(1) != DBNull.Value)
                    {
                        uint hdtvMode       = (uint)r.GetInt32(0);
                        uint hdtvSystem     = (uint)r.GetInt32(1);
                        hdtvModes.Add(hdtvMode, hdtvSystem);
                    }
                }
            }

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.READORWRITE_COMMANDTYPE))
            {
                ws.PartitionType   = WstPartitionType.Logical;
                ws.Partition       = WstCommand.AnyPartition;
                ws.StoredProc      = "dbo.p_svc_get_rating_systems";
                
                WstDataReader r = ws.Execute();

                while (r.Read())
                {
                    if (r.GetValue(0) != DBNull.Value && r.GetValue(1) != DBNull.Value)
                    {
                        uint ratingId       = (uint)r.GetInt32(1);
                        uint ratingSystem   = (uint)r.GetInt32(0);
                        ratings.Add(ratingId, ratingSystem);
                    }
                }
            }

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.READORWRITE_COMMANDTYPE))
            {
                ws.PartitionType   = WstPartitionType.Logical;
                ws.Partition       = WstCommand.AnyPartition;
                ws.StoredProc      = "dbo.p_svc_get_genres";
                
                WstDataReader r = ws.Execute();

                while (r.Read())
                {
                    if (r.GetValue(0) != DBNull.Value && r.GetValue(1) != DBNull.Value)
                    {
                        uint genreId       = (uint)r.GetInt32(0);
                        uint productTypeId = (uint)r.GetInt32(1);
                        genres.Add(genreId, productTypeId);
                    }
                }
            }


            //-----------------------------------------------------------------
            // DATA VALIDATION
            //-----------------------------------------------------------------
            if (info != null)
            {
                if (info.HdtvMode != null)
                {
                    foreach (HdtvMode x in info.HdtvMode)
                        if (!IsValidHdtvData(x.hdtvId, x.hdtvSystemId))
                            errors.Add("HdtvMode specification did not match known values: Id = " + x.hdtvId + ", System = " + x.hdtvSystemId);
                }
    
                if (info.Rating != null)
                {
                    foreach (Rating x in info.Rating)
                        if (!IsValidRatingData(x.ratingId, x.ratingSystemId))
                            errors.Add("Rating specification did not match known values: Id = " + x.ratingId + ", System = " + x.ratingSystemId);
                }
    
                if (info.Genre != null)
                {
                    foreach (Genre x in info.Genre)
                        if (!IsValidGenreData(x.genreId))
                            errors.Add("Genre specification did not match known values: Id = " + x.genreId);
                }
            }
    
        } // ReferenceData(ctor)

        bool IsValidHdtvData(uint id, uint system)
        {
            if (hdtvModes[id] != null)
                if ((uint)hdtvModes[id] == system)
                    return  true;

            return false;
        }

        bool IsValidRatingData(uint id, uint system)
        {
            if (ratings[id] != null)
                if ((uint)ratings[id] == system)
                    return  true;

            return false;
        }

        bool IsValidGenreData(uint id)
        {
            if (genres.ContainsKey(id))
                return  true;

            return false;
        }

    } // class ReferenceData


} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\ingestionutils\Title\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__title_2_none_12.4.56.0_none_49c26ba804b09336
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__title_2_no-public-key_12.4.56.0_x-ww_fea78142
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_title_2
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__title_2_no-public-key_12.4.56.0_x-ww_fea78142
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__title_2_no-public-key_12.4.56.0_x-ww_fea78142.manifest
XP_MANIFEST_PATH=manifests\x86__title_2_no-public-key_12.4.56.0_x-ww_fea78142.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__title_2_no-public-key_12.4.56.0_x-ww_fea78142.cat
XP_CATALOG_PATH=manifests\x86__title_2_no-public-key_12.4.56.0_x-ww_fea78142.cat
XP_PAYLOAD_PATH=x86__title_2_no-public-key_12.4.56.0_x-ww_fea78142
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_title_2,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\ingestionutils\xlastutil\xlastchecker.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Xml;
using System.Xml.Schema;
using System.Xml.Serialization;
using System.Text;
using System.Xml.XPath;
using xonline.common.config;
using xonline.common.livetitleconfig;
using xonline.common.mgmt;
using xonline.common.protocol;

namespace xonline.common.xlastutil
{

    public class XlastChecker
    {
        public const int X_IMAGEID_GAME = 32768;
        public const int X_IMAGEID_GAME_MARKETPLACE = 32772;

        public static bool CheckXlast( XboxLiveSubmissionProject xlsp, LiveTitleConfig ltc, ref StringBuilder validationInfo )
        {        
            bool validXlast = true;
            validationInfo.Append( "Starting Validation\n" );

            // Make sure we have valid parameters
            if ( (xlsp == null) || (ltc == null) || (validationInfo == null) )
            {
                validationInfo.Append( "Invalid (null) Parameters passed.\n" );
                return false;
            }

            if (xlsp.GameConfigProject == null)
            {
                validationInfo.Append( "GameConfigProject passed is null\n" );
                return false;
            }

            if (xlsp.MarketplaceConfigProject != null)
            {
                validationInfo.Append( "MarketplaceConfigProject is not null\n" );
                return false;
            }
            
            GameConfigProject gcp = xlsp.GameConfigProject;

            //task: seems like there should be a more elegant way to write this... 
            //task: confirm C# rich presence expressions
            //task: any other tests that should be done before deploying an XLAST-LTC pair?

            //it is a deliberate choice to continue checking even if one test fails...
            //I think it's preferable to have a full list of errors to reduce iteration.
            if ( !CheckTitleID( xlsp, ltc, ref validationInfo ) )
            {
                validationInfo.Append( "\r\n\r\n-- TitleID's didn't match between XLAST and LTC.\r\n" );
                validXlast = false;
            }

            if (!CheckGamerPictures(xlsp, ltc, ref validationInfo))
            {
                validationInfo.Append("\r\n\r\n-- Number of Gamer Pictures in XLAST file exceeds the limit specified in the LTC.\r\n");
                validXlast = false;
            }

//            if ( !CheckRating( xlsp, ltc ) )
//            {
//                validationInfo.Append( "\r\n-- Ratings contained invalid values." );
//                validXlast = false;
//            }
            
            if ( !CheckLeaderBoards( xlsp, ltc, ref validationInfo ) )
            {
                validationInfo.Append( "\r\n\r\n-- Inconsistent leaderboard specification between XLAST and LTC.\r\n" );
                validXlast = false;
            }

            if ( !CheckAchievementsAndCred( xlsp, ltc, ref validationInfo ) )
            {
                validationInfo.Append( "\r\n\r\n-- The Achievements section of this XLAST doesn't match limits in its LTC.\r\n" );
                validXlast = false;
            }

            if ( !CheckContexts( xlsp, ltc, ref validationInfo ) )
            {
                validationInfo.Append( "\r\n\r\n-- The Context section of this XLAST doesn't match limits in its LTC.\r\n" );
                validXlast = false;
            }

            if ( !CheckProperties( xlsp, ltc, ref validationInfo ) )
            {
                validationInfo.Append( "\r\n\r\n-- The number of Properties specified in this XLAST doesn't match limits in its LTC.\r\n" );
                validXlast = false;
            }

            if ( !CheckRichPresenceModes( xlsp, ltc, ref validationInfo ) )
            {
                validationInfo.Append( "\r\n\r\n-- The number of Rich Presence modes specified in this XLAST doesn't match limits in its LTC.\r\n" );
                validXlast = false;
            }
            
            if ( !CheckGameModes( xlsp, ltc, ref validationInfo ) )
            {
                validationInfo.Append( "\r\n\r\n-- The number of Game Modes specified in this XLAST doesn't match limits in its LTC.\r\n" );
                validXlast = false;
            }
             
            if ( !CheckTitlePicture( xlsp, ltc, ref validationInfo ) )
            {
                validationInfo.Append( "\r\n\r\n-- Unless the LTC grants exception, all titles must have a Title Picture.\r\n" );
                validXlast = false;
            }
 
            if ( !CheckMarketPlacePicture( xlsp, ltc, ref validationInfo ) )
            {
                validationInfo.Append( "\r\n\r\n-- Unless the LTC grants exception, all titles must have a Title Picture.\r\n" );
                validXlast = false;
            }
 
            if ( !CheckBounty() )
            {
                validationInfo.Append( "\r\n===> Incorrect Bounty Setting: Bounty must be Y or N!" );
                validXlast = false;
            }

            if ( !CheckMatchmaking( xlsp, ltc, ref validationInfo ) )
            {
                validationInfo.Append( "\r\n\r\n-- Unable to validate the matchmaking game config" );
                validXlast = false;
            }

            if (!CheckAvatarItems(xlsp, ltc, ref validationInfo))
            {
                validationInfo.Append("\r\n\r\n-- The AvatarItems section of this XLAST doesn't match limits in its LTC.\r\n");
                validXlast = false;
            }

            return validXlast;

        }

        public static bool CheckTitleID( XboxLiveSubmissionProject xlsp, LiveTitleConfig ltc, ref StringBuilder sb )
        {
            uint titleID = (uint) XlastUtil.ConvertTitleIDString( xlsp.GameConfigProject.titleId );

            if ( titleID != ltc.TitleID ) 
            {
                sb.Append( " TitleID Check Failed." );
                return false;
            }
            else
            {
                sb.Append( " TitleID Check Succeeded." );
                return true;
            }
        }

        public static bool CheckGamerPictures(XboxLiveSubmissionProject xlsp, LiveTitleConfig ltc, ref StringBuilder sb)
        {
            if ((xlsp.GameConfigProject.GamerPictures.Picture != null) &&
                (xlsp.GameConfigProject.GamerPictures.Picture.Length > ltc.MaxGamerPictures))
            {
                sb.Append(" Max Gamer Pictures Check Failed.");
                return false;
            }

            sb.Append(" Max Gamer Pictures Check Succeeded.");
            return true;
        }

        //task: should this be here or in a stats related file?
        //confirm leaderboards don't exceed LTC limits, and that XLAST and LTC contain same lbid's
        public static bool CheckLeaderBoards( XboxLiveSubmissionProject xlsp, LiveTitleConfig ltc, ref StringBuilder sb )
        {
            bool flag = true;
            int lbCount = 0;
            GameConfigProject gcp = xlsp.GameConfigProject;

            //IF there's stats, check consistency between XLAST and LTC
            if ( 
                ( gcp.StatsViews != null ) &&
                ( gcp.StatsViews.StatsView != null )
                )
            {
                lbCount += gcp.StatsViews.StatsView.Length;
            }

            //skill leaderboards count toward max as well
            if (
                ( gcp.GameModes != null ) &&
                ( gcp.GameModes.GameMode != null )
                )
            {
                lbCount += gcp.GameModes.GameMode.Length;
            }

            if ( lbCount > ltc.StatsMaxLeaderboards )
            {
                sb.Append( "\r\n\r\nThe Xlast document contains more leaderboards than the LiveTitleConfig " );
                sb.Append( "document allows.  Please reduce leaderboards in Xlast or increase MaxStatsLeaderboards in LTC." );
                flag = false;
            }

            //======================
            //task: add checks to confirm all the lbid's in XLAST are assigned in the LTC

            return flag;
        }


        //task: should we move rating checking from ReferenceData here??
//        //confirm rating elements conform to rating info in npdb
//        public static bool CheckRating( XboxLiveSubmissionProject xlsp, LiveTitleConfig ltc )
//        {
//
//            //task: What checks should really be here?
//            //task: confirm this rating number exists for this rating system... 
//
//            //            int rsid = 0;
//            //            int rating = 0;
//            //            try 
//            //            {
//            //                rsid = Convert.ToInt32( argParser[ "rsid" ] );
//            //                rating = Convert.ToInt32( argParser[ "rating" ] );
//            //            }
//            //                //review: is there a more elegant way to do this?
//            //            catch ( ArithmeticException )
//            //            {
//            //                Console.WriteLine( "Either the rating system ID or rating is unable to be converted to an integer." );
//            //                return -1;
//            //            }
//
//            //            int esrb = 0;
//            //            try 
//            //            {
//            //                esrb = Convert.ToInt32( argParser[ "esrb" ] );
//            //
//            //            }
//            //                //review: is there a more elegant way to do this?
//            //            catch ( ArithmeticException )
//            //            {
//            //                Console.WriteLine( "The esrb argument is unable to be converted to an integer." );
//            //                return -1;
//            //            }
//
//            return true;
//        }

        public static bool CheckAchievementsAndCred( XboxLiveSubmissionProject xlsp, LiveTitleConfig ltc, ref StringBuilder sb )
        {
            bool flag = true;
            GameConfigProject gcp = xlsp.GameConfigProject;

            if (
                ( gcp.Achievements == null ) ||
                ( gcp.Achievements.Achievement == null ) 
                )
            {
                if ( ltc.MinAchievements != 0 )
                {
                    sb.Append( "\r\n\r\nThe Xlast document contains no Achievements but some are required by the LiveTitleConfig " );
                    sb.Append( "document.  Please add Achievements in Xlast or decrease MinAchievements in LTC." );
                    return false;
                }
                else
                {
                    return true;
                }
            }

            if ( gcp.Achievements.Achievement.Length < ltc.MinAchievements )
            {
                sb.Append( "\r\n\r\nThe Xlast document contains fewer Achievements than required the LiveTitleConfig " );
                sb.Append( "document.  Please add Achievements in Xlast or decrease MinAchievements in LTC." );
                flag = false;
            }

            if ( gcp.Achievements.Achievement.Length > ltc.MaxAchievements )
            {
                sb.Append( "\r\n\r\nThe Xlast document contains more Achievements than allowed by the LiveTitleConfig " );
                sb.Append( "document.  Please remove Achievements in Xlast or increase MaxAchievements in LTC." );
                flag = false;
            }

            if ( gcp.Achievements.Achievement.Length > 0 )
            {
                Hashtable images = new Hashtable();
                int achWithCred = 0;
                int achWithoutCred = 0;
                int totalCred = 0;

                foreach( XboxLiveSubmissionProjectGameConfigProjectAchievementsAchievement ach in gcp.Achievements.Achievement )
                {              
                    if ( ! images.ContainsKey( ach.imageId ) )
                    {
                        images.Add( ach.imageId, ach.id.ToString() );
                    }
                    if ( ach.cred == 0 )
                    {
                        achWithoutCred++;
                    }
                    else
                    {
                        achWithCred++;
                        totalCred += ach.cred;
                    }
                }

                //check counts now that we've tallied all achievements
                if ( images.Count > ltc.MaxUniqueAchImages )
                {
                    sb.Append( "\r\n\r\nThe Xlast document contains more unique Achievement Images than allowed " );
                    sb.Append( "by the LiveTitleConfig document.  Please remove Achievements in Xlast " );
                    sb.Append( "or increase MaxAchievements in LTC." );

                    flag = false;
                }
                if ( achWithCred < ltc.MinAchievementsWithCred )
                {
                    sb.Append( "\r\n\r\nThe Xlast document contains fewer Achievements with Cred than allowed " );
                    sb.Append( "by the LiveTitleConfig document.  Please add Achievements with Cred in Xlast " );
                    sb.Append( "or decrease MinAchievementsWithCred in LTC." );

                    flag = false;
                }
                if ( achWithCred > ltc.MaxAchievementsWithCred )
                {
                    sb.Append( "\r\n\r\nThe Xlast document contains more Achievements with Cred than allowed " );
                    sb.Append( "by the LiveTitleConfig document.  Please remove Achievements with Cred in Xlast " );
                    sb.Append( "or increase MaxAchievementsWithCred in LTC." );

                    flag = false;
                }    
        
                if ( totalCred < ltc.MinCred )
                {
                    sb.Append( "\r\n\r\nThe Xlast document contains less total Cred than allowed " );
                    sb.Append( "by the LiveTitleConfig document.  Please add Cred in Xlast " );
                    sb.Append( "or decrease MinCred in LTC." );

                    flag = false;
                }
                if ( totalCred > ltc.MaxCred )
                {
                    sb.Append( "\r\n\r\nThe Xlast document contains more total Cred than allowed " );
                    sb.Append( "by the LiveTitleConfig document.  Please remove Cred in Xlast " );
                    sb.Append( "or increase MaxCred in LTC." );

                    flag = false;
                }
            }
            else
            {
                //all the other tests may also have issues when Achievements are added...
                sb.Append( "\r\n\r\nNo Achievements found, some checks were not run. " );
                sb.Append( "After Achievements are added, additional tests can be run." );
            }

            return flag;
        }

        public static bool CheckContexts( XboxLiveSubmissionProject xlsp, LiveTitleConfig ltc, ref StringBuilder sb )
        {
            //task: count values per context to make sure no context exceeds these values... 
            //Setting name="maxContexts"                        value="1000"
            //Setting name="maxContextValues"                   value="100" 
            
            bool flag = true;
            GameConfigProject gcp = xlsp.GameConfigProject;

            //if there are no contexts, then just return true....
            if (
                ( gcp.Contexts != null ) &&
                ( gcp.Contexts.Context != null )
                )
            {

                if ( gcp.Contexts.Context.Length > ltc.MaxContexts )
                {
                    sb.Append( "\r\n\r\nThe Xlast document contains more Contexts than allowed by the LiveTitleConfig " );
                    sb.Append( "document.  Please remove Contexts in Xlast or increase MaxContexts in LTC." );
                    flag = false;
                }

                foreach( Context ctx in gcp.Contexts.Context )
                {
                    if ( ctx.ContextValue.Length > ltc.MaxContextValues )
                    {
                        sb.Append( "\r\n\r\nThe Xlast document, on Context " + ctx.id.ToString() + " contains more ContextValues than allowed " );
                        sb.Append( "by the LiveTitleConfig document.  Please remove ContextValues in Xlast or " );
                        sb.Append( "increase MaxContextValues in LTC." );
                        flag = false;
                    }
                }
            }
            return flag;
        }

        public static bool CheckProperties( XboxLiveSubmissionProject xlsp, LiveTitleConfig ltc, ref StringBuilder sb )
        {
            bool flag = true;
            GameConfigProject gcp = xlsp.GameConfigProject;

            //Setting name="maxProperties"                      value="1000" 
            if (
                ( gcp.Properties != null ) &&
                ( gcp.Properties.Property != null )
                )
            {
                if ( gcp.Properties.Property.Length > ltc.MaxProperties )
                {
                    sb.Append( "\r\n\r\nThe Xlast document contains more Properties than allowed by the LiveTitleConfig " );
                    sb.Append( "document.  Please remove Properties in Xlast or increase MaxProperties in LTC." );
                    flag = false;
                }
            }
            return flag;
        }

        public static bool CheckRichPresenceModes( XboxLiveSubmissionProject xlsp, LiveTitleConfig ltc, ref StringBuilder sb )
        {
            bool flag = true;
            GameConfigProject gcp = xlsp.GameConfigProject;

            //Setting name="maxRichPresenceModes"               value="16"
            if (
                ( gcp.Presence != null ) &&
                ( gcp.Presence.PresenceMode != null )
                )
            {
                if ( gcp.Presence.PresenceMode.Length > ltc.MaxRichPresenceModes )
                {
                    sb.Append( "\r\n\r\nThe Xlast document contains more PresenceModes than allowed by the LiveTitleConfig " );
                    sb.Append( "document.  Please remove PresenceModes in Xlast or increase MaxRichPresenceModes in LTC." );
                    flag = false;
                }
            }

            return flag;
        }

        public static bool CheckGameModes( XboxLiveSubmissionProject xlsp, LiveTitleConfig ltc, ref StringBuilder sb )
        {
            bool flag = true;
            GameConfigProject gcp = xlsp.GameConfigProject;

            //Setting name="maxGameModes"                       value="16"
            if (
                ( gcp.GameModes != null ) &&
                ( gcp.GameModes.GameMode != null )
                )
            {
                if ( gcp.GameModes.GameMode.Length > ltc.MaxGameModes )
                {
                    sb.Append( "\r\n\r\nThe Xlast document contains more GameModes than allowed by the LiveTitleConfig " );
                    sb.Append( "document.  Please remove GameModes in Xlast or increase MaxGameModess in LTC." );
                    flag = false;
                }
            }

            return flag;
        }

        public static bool CheckTitlePicture( XboxLiveSubmissionProject xlsp, LiveTitleConfig ltc, ref StringBuilder sb )
        {

            bool flag = false;
            GameConfigProject gcp = xlsp.GameConfigProject;

            //task: refactor this loop out so TitlePicture and MarketplacePicture checks share it?
            //task: would it be faster to use an XQuery?
            //Setting name="titlePictureRequired"               value="true"
            //if required, is it present?
            if ( ltc.TitlePictureRequired )
            {
                if ( ( gcp.Images == null ) || ( gcp.Images.Image == null ) )
                {
                    flag = false;
                }
                else
                {
                    //for (int iLoop = 0; iLoop < gcp.Images.Image.Length; iLoop++ )
                    foreach( Image image in gcp.Images.Image )
                    {
                        //if ( gcp.Images.Image[ iLoop ].id == X_IMAGEID_GAME )
                        if ( image.id == X_IMAGEID_GAME )
                        {
                            flag = true;
                            break;
                        }
                    }
                }
            }
            else
            {
                // if it's not required, it doesn't matter if it's there.
                flag = true;  
            }

            if ( !flag )
            {
                sb.Append( "\r\n\r\nThe Xlast document is required to contain a TitlePicture image, but none was present." );
                flag = false;
            }

            return flag;
        }

        public static bool CheckMarketPlacePicture( XboxLiveSubmissionProject xlsp, LiveTitleConfig ltc, ref StringBuilder sb )
        {
            bool flag = true;
            GameConfigProject gcp = xlsp.GameConfigProject;

            //Setting name="titleMarketplacePictureRequired"    value="true"
            //if required, is it present?
            if ( ltc.TitlePictureRequired )
            {
                if ( ( gcp.Images == null ) || ( gcp.Images.Image == null ) )
                {
                    flag = false;
                }
                else
                {
                    //for(int iLoop = 0; iLoop < Images.Image.Length; iLoop++ )
                    foreach( Image image in gcp.Images.Image )
                    {
                        //if ( gcp.Images.Image[ iLoop ].id == X_IMAGEID_GAME )
                        if ( image.id == X_IMAGEID_GAME_MARKETPLACE )
                        {
                            flag = true;
                            break;
                        }
                    }
                }
            }
            else
            {
                // if it's not required, it doesn't matter if it's there.
                flag = true;  
            }

            if ( !flag )
            {
                sb.Append( "\r\n\r\nThe Xlast document is required to contain a MarketPlacePicture image, but none was present." );
                flag = false;
            }

            return flag;
        }

        public static bool CheckBounty()
        {

//            bool flag;
//            if (
//                 ( null != argParser[ "bountyflag" ] ) &&
//                 (
//                  ( "Y" == argParser[ "bountyflag" ] ) ||
//                  ( "N" == argParser[ "bountyflag" ] )
//                 )
//                )
//            {
//                bounty = ( argParser[ "bountyflag" ] == "Y" );
//                Console.WriteLine("bounty is " + bounty );
//            }
//            else
//            {
//                Usage();
//                Console.WriteLine( "\n\r===> Incorrect Bounty Setting: Bounty must be True or False!" );
//                return 0;
//            }

            return true;
        }

        public static bool CheckAvatarItems(XboxLiveSubmissionProject xlsp, LiveTitleConfig ltc, ref StringBuilder sb)
        {            
            if ((xlsp.GameConfigProject.AvatarItems != null) 
                && (xlsp.GameConfigProject.AvatarItems.AvatarItem != null)
                && (xlsp.GameConfigProject.AvatarItems.AvatarItem.Length > ltc.MaxAvatarItems))
            {
                sb.Append("\r\n\r\nThe Xlast document contains more Avatar Items than allowed by the LiveTitleConfig ");
                sb.Append("document.  Please remove Avatar Items in Xlast or increase MaxAvatarItems in LTC.");
                return false;
            }

            return true;
        }

        private static string AttributeName(uint id)
        {
            return "0X" + MaskId(id).ToString("X8");
        }

        private static uint MaskId(uint id)
        {
            return id & (MatchDefs.X_ATTRIBUTE_SCOPE_MASK
                    | MatchDefs.X_ATTRIBUTE_XENON_DATATYPE_MASK
                    | MatchDefs.X_ATTRIBUTE_ID_MASK);
        }

        public static bool CheckMatchmaking(
                XboxLiveSubmissionProject xlsp, 
                LiveTitleConfig ltc, 
                ref StringBuilder sb)
        {
            bool matchOk = false;
            Hashtable validAttrs = new Hashtable();
            XboxLiveSubmissionProjectGameConfigProjectMatchmaking           matchmaking = xlsp.GameConfigProject.Matchmaking;

            // No matchmaking support in this title
            if(null == matchmaking)
            {
                matchOk = true;
                goto lbDone;
            }

            XboxLiveSubmissionProjectGameConfigProjectMatchmakingSchema     schema = matchmaking.Schema;
            XboxLiveSubmissionProjectGameConfigProjectMatchmakingConstants  constants = matchmaking.Constants;
            XboxLiveSubmissionProjectGameConfigProjectMatchmakingQueries    queries = matchmaking.Queries;

            if(null == schema)
            {
                sb.Append( "\r\n\r\nMissing schema section in matchmaking definition");
                goto lbDone;
            }

            if(null == queries)
            {
                sb.Append( "\r\n\r\nMissing query section in matchmaking definition");
                goto lbDone;
            }

            if (0 == schema.Attribute.Length || schema.Attribute.Length > MatchDefs.X_MATCH_MAX_TOTAL_SCHEMA_ATTRS)
            {
                sb.Append( "\r\n\r\nInvalid matchmaking schema attribute count: " + schema.Attribute.Length);
                goto lbDone;
            }

            // Add the built-in schema attributes
            validAttrs[AttributeName(MatchDefs.X_ATTRIBUTE_GAME_TYPE)] = true;
            validAttrs[AttributeName(MatchDefs.X_ATTRIBUTE_GAME_MODE)] = true;
            validAttrs[AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_ZONE)] = true;
            validAttrs[AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_COUNTRY)] = true;
            validAttrs[AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_LANGUAGE)] = true;
            validAttrs[AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_RATING)] = true;
            validAttrs[AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_MU)] = true;
            validAttrs[AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_SIGMA)] = true;
            validAttrs[AttributeName(MatchDefs.X_ATTRIBUTE_GAMER_HOSTNAME)] = true;
            validAttrs[AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_TYPE)] = true;
            validAttrs[AttributeName(MatchDefs.X_ATTRIBUTE_PLATFORM_LOCK)] = true;

            foreach(XboxLiveSubmissionProjectGameConfigProjectMatchmakingSchemaAttribute attr 
                    in schema.Attribute)
            {
                if(!attr.id.ToUpper().StartsWith("0X"))
                {
                    sb.Append("\r\n\r\nMatchmaking schema attribute was not a valid hexid: " + attr.id);
                }
                if(attr.id.Length != 10)
                {
                    sb.Append("\r\n\r\nMatchmaking schema attribute was not a valid 4 byte hexid: " + attr.id);
                }
                validAttrs[attr.id.ToUpper()] = true;
            }

            if(null == queries.Query)
            {
                sb.Append( "\r\n\r\nMissing query definitions in matchmaking query section, skipping per-query checks");
                matchOk = true;
                goto lbDone;
            }

            foreach(XboxLiveSubmissionProjectGameConfigProjectMatchmakingQueriesQuery query
                    in queries.Query)
            {
                string queryId = "0x" + query.id.ToString("x");
                string friendlyName = query.friendlyName;
                Hashtable validParams = new Hashtable();

                // Validate basic query properties
                if(query.maxResults > MatchDefs.X_MATCH_MAX_QUERY_RESULTS)
                {
                    sb.Append( "\r\n\r\nSpecified query: " + queryId + " max results exceeds: " + MatchDefs.X_MATCH_MAX_QUERY_RESULTS);
                    goto lbDone;
                }
                // Validate the absolute maximum number of query parameters allowed 
                if(query.Parameters.Length > MatchDefs.X_MATCH_MAX_QUERY_PARAMS)
                {
                    sb.Append( "\r\n\r\nQuery: " + queryId + " parameter count exceeds: " + MatchDefs.X_MATCH_MAX_QUERY_PARAMS);
                    goto lbDone;
                }
                // This validates the maximum number of query parameters allowed for this title, 
                // which may be set to less than the absolute maximum for perf reasons.
                if (query.Parameters.Length > ltc.MatchMaxTitleParamsPerQuery)
                {
                    sb.Append("\r\n\r\nQuery: " + queryId + " parameter count exceeds max title params per query of " + ltc.MatchMaxTitleParamsPerQuery);
                    goto lbDone;
                }

                foreach(XboxLiveSubmissionProjectGameConfigProjectMatchmakingQueriesQueryParameter param in query.Parameters)
                {
                    if(!param.id.ToUpper().StartsWith("0X"))
                    {
                        sb.Append("\r\n\r\nQuery: " + queryId + " parameter id: " + param.id + " is not specified in hex");
                    }

                    validParams[param.id.ToUpper()] = true;
                }
        
                foreach(XboxLiveSubmissionProjectGameConfigProjectMatchmakingQueriesQueryFilter filter in query.Filters)
                {
                    if(!IsValidMatchQueryFilter(queryId, validAttrs, validParams, filter, ref sb))
                    {
                        sb.Append("\r\n\r\nQuery: " + queryId + " failed to validate filters");
                        goto lbDone;
                    }
                }
        
                foreach(XboxLiveSubmissionProjectGameConfigProjectMatchmakingQueriesQueryReturn ret in query.Returns)
                {
                    if(!ret.id.ToUpper().StartsWith("0X"))
                    {
                        sb.Append("\r\n\r\nQuery: " + queryId + " return id: " + ret.id + " is not specified in hex");
                    }

                    if(!validAttrs.Contains(ret.id.ToUpper()))
                    {
                        sb.Append( "\r\n\r\nQuery: " + queryId + " return id: " + ret.id + " does not match a known schema attribute");
                        goto lbDone;
                    }
                }
            }
            
            matchOk = true;
lbDone:
            return matchOk;
        }

        public static bool IsValidMatchQueryFilter(
                string queryId,
                Hashtable validAttrs,
                Hashtable validParams,
                XboxLiveSubmissionProjectGameConfigProjectMatchmakingQueriesQueryFilter filter, 
                ref StringBuilder sb)
        {
            bool valid = false;

            if(!filter.left.ToUpper().StartsWith("0X"))
            {
                sb.Append("\r\n\r\nQuery: " + queryId + " filter left id is not specified in hex");
                goto lbDone;
            }

            if(!filter.leftTypeSpecified)
            {
                sb.Append("\r\n\r\nFilter left id: " + filter.left + " did not specify a type");
                goto lbDone;
            }
            
            if(!filter.rightTypeSpecified)
            {
                sb.Append("\r\n\r\nFilter right id: " + filter.right + " did not specify a type");
                goto lbDone;
            }

            switch (filter.leftType)
            {
            case MatchFilterItemType.Parameter:
                if(validParams.Contains(filter.left.ToUpper()))
                {
                    sb.Append(
                        "\r\n\r\nQuery: " + queryId
                        + " left parameter filter id: " + filter.left
                        + " does not exist in the parameter list");
                    goto lbDone;
                }

                switch (filter.rightType)
                {
                case MatchFilterItemType.Parameter:
                    sb.Append(
                        "\r\n\r\nIllegal Match Query Filter detected. "
                        + "Right side cannot be a Parameter when Left side is a Parameter. "
                        + " Left Side id: " + filter.left
                        + " Right Side id: " + filter.right);
                    break;
                case MatchFilterItemType.Attribute:
                    if(!validAttrs.Contains(filter.right.ToUpper()))
                    {
                        sb.Append( "\r\n\r\nQuery: " + queryId 
                            + " right attribute filter id: " + filter.right 
                            + " does not exist in the schema attributes");
                        goto lbDone;
                    }
                    valid = true;
                    break;
                case MatchFilterItemType.Constant:
                    sb.Append( 
                        "\r\n\r\nIllegal Match Query Filter detected. "
                        + "Right side cannot be a Constant when Left side is a Parameter. "
                        + " Left Side id: " + filter.left
                        + " Right Side id: " + filter.right);
                    break;
                case MatchFilterItemType.ContextValue:
                    sb.Append(
                        "\r\n\r\nIllegal Match Query Filter detected. "
                        + "Right side cannot be a ContextValue when Left side is a Parameter. "
                        + " Left Side id: " + filter.left
                        + " Right Side id: " + filter.right); 
                    break; 
                default:
                    sb.Append(
                       "\r\n\r\nIllegal Match Query Filter detected. "
                       + "Unknown type on Right side "
                       + " Left Side id: " + filter.left
                       + " Right Side id: " + filter.right);
                    break;
                }
                break;

            case MatchFilterItemType.Attribute:
                if(!validAttrs.Contains(filter.left.ToUpper()))
                {
                    sb.Append( "\r\n\r\nQuery: " + queryId 
                            + " left attribute filter id: " + filter.left 
                            + " does not exist in the schema attributes");
                    goto lbDone;
                }

                switch (filter.rightType)
                {
                case MatchFilterItemType.Parameter:
                    if(!validParams.Contains(filter.right.ToUpper()))
                    {
                        sb.Append( "\r\n\r\nQuery: " + queryId 
                            + " right filter id: " + filter.right 
                            + " is not a recognized parameter of the query");
                        goto lbDone;
                    }

                    valid = true;
                    break;

                case MatchFilterItemType.Attribute:
                    sb.Append(
                        "\r\n\r\nIllegal Match Query Filter detected. "
                        + "Right side cannot be an Attribute when Left side is an Attribute. "
                        + " Left Side id: " + filter.left
                        + " Right Side id: " + filter.right);
                    break;
                case MatchFilterItemType.Constant:
                    valid = true;
                    break;

                case MatchFilterItemType.ContextValue:
                    valid = true;
                    break;

                default:
                    sb.Append(
                        "Illegal Match Query Filter detected. "
                        + "Unknown type on Right side "
                        + " Left Side id: " + filter.left
                        + " Right Side id: " + filter.right);
                    break;
                }
                break;

            case MatchFilterItemType.Constant:
                sb.Append(
                    "\r\n\r\nIllegal Match Query Filter detected. "
                    + "Left side cannot be a Constant "
                    + " Left Side id: " + filter.left
                    + " Right Side id: " + filter.right);
                break;

            default:
                sb.Append(
                    "\r\n\r\nIllegal Match Query Filter detected. "
                    + "Unknown type on Left side "
                    + " Left Side id: " + filter.left
                    + " Right Side id: " + filter.right);
                break;
            }
lbDone:
            return valid;
        }
    }
} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\ingestionutils\xlastutil\xlastschemautil.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Xml;
using System.Xml.Schema;
using System.Xml.Serialization;
using System.Xml.XPath;

using xonline.common.config;
using xonline.common.mgmt;


//note: also uses xlastutil log area, defined in xlastutil.cs


namespace xonline.common.xlastutil
{

    public class XlastSchemaUtil
    {

        //task: this method stores an Xlast Schema in NPDB
        public static void PutXlastSchema( string xdkVersion, string schema )
        {
            using (SqlConnection xlastConn = new SqlConnection( ConfigUtil.NpdbConnectionString ) )
            {
                xlastConn.Open();
                SqlCommand xlastCmd = xlastConn.CreateCommand();
                xlastCmd.CommandType = CommandType.StoredProcedure;
                xlastCmd.CommandText = "dbo.p_game_schema_set";

                xlastCmd.Parameters.Add( "@vc_xdk_version", SqlDbType.VarChar, 50 ).Value = xdkVersion;
                xlastCmd.Parameters["@vc_xdk_version"].Direction = ParameterDirection.Input;  
              
                xlastCmd.Parameters.Add( "@xml_schema", SqlDbType.NText ).Value = schema;
                xlastCmd.Parameters["@xml_schema"].Direction = ParameterDirection.Input; 
                
                xlastCmd.Parameters.Add( "@hr", SqlDbType.Int );
                xlastCmd.Parameters["@hr"].Direction = ParameterDirection.ReturnValue;

                //task: do something with row information?
                int rows = xlastCmd.ExecuteNonQuery();

                //p_game_schema_set will return non-zero hr if the title wasn't found.
                //0x80150013 -- 2146107373 -- XONLINE_E_INVALID_TITLE_ID
                if ( System.Convert.ToInt32( xlastCmd.Parameters["@hr"].Value ) != 0 )
                {
                    Xom.Trace(XomAreaName.xlastutil, LogLevel.L_ERROR, "There was no data for that XDK Version " + xdkVersion );
                    throw new Exception( "There was no data for that XDK Version " + xdkVersion );
                }

            } //using 

        }

        //task: this grabs a file from file storage and puts it in NPDB
        public static void PutXlastSchemaFromDrive( string xdk, string xlastPathString )
        {

            StreamReader xlastReader = new StreamReader( xlastPathString );
            string xlastSchema = xlastReader.ReadToEnd();
            XlastSchemaUtil.PutXlastSchema( xdk, xlastSchema );
        }

        //task: returns the Schema given the Xdk
        public static string GetXlastSchema( string xdkVersion )
        {

            using (SqlConnection xlastConn = new SqlConnection( ConfigUtil.NpdbConnectionString ) )
            {
                xlastConn.Open();
                SqlCommand xlastCmd = xlastConn.CreateCommand();
                xlastCmd.CommandType = CommandType.StoredProcedure;
                xlastCmd.CommandText = "dbo.p_game_schema_get";

                xlastCmd.Parameters.Add( "@vc_xdk_version", SqlDbType.VarChar, 50 ).Value = xdkVersion;
                xlastCmd.Parameters["@vc_xdk_version"].Direction = ParameterDirection.Input;  
              
                xlastCmd.Parameters.Add( "@hr", SqlDbType.Int );
                xlastCmd.Parameters["@hr"].Direction = ParameterDirection.ReturnValue;

                SqlDataReader xlastReader = xlastCmd.ExecuteReader();

                //p_game_get_config will return non-zero hr if the title wasn't found.
                //0x80150013 -- 2146107373 -- XONLINE_E_INVALID_TITLE_ID
                if ( xlastReader.Read() || ( System.Convert.ToInt32( xlastCmd.Parameters["@hr"].Value ) != 0 ) )
                {
                    return (string) xlastReader.GetSqlString( 1 );
                }
                else 
                {
                    Xom.Trace(XomAreaName.xlastutil, LogLevel.L_ERROR, "There was no data for that XDK Version " + xdkVersion);
                    throw new Exception( "There was no data for that XDK Version " + xdkVersion );
                }

            } //using 

        }

        //task: returns the appropriate Schema as a string given an Xlast document
        public static string GetXlastSchemaFromXlastString( string xlast )
        {

            //task: till April Xdk we'll continue to have no version in the Xlast file
//            omNtEvent( XEvent.Id.COMMON_WARNING_0, "XDK Version is currently HARDCODED to 2.0.1342.0 until Xlast begins supplying an XDK Version." );
            EventLog.WriteEntry("XlastUtil", 
                "XDK Version is currently HARDCODED to 2.0.1342.0 until Xlast begins supplying an XDK Version.", 
                System.Diagnostics.EventLogEntryType.Error, 
                0);

            return XlastSchemaUtil.GetXlastSchema( "2.0.1342.0" );
            
//            //review: we don't know if it's XML yet, why try to use an XML reader?
//            int versionStart = xlastXml.IndexOf( " projectVersion=" ) + 17;
//            if ( versionStart < 0 )
//            {
//                throw new ArgumentException( "Invalid XML format of argument. XML Started with: " + xlastXml.Substring( 0, 50 ) );
//            }
//            int versionEnd = xlastXml.IndexOf( "\"", versionStart );
//            xlast.Substring( versionStart, versionEnd - versionStart ) );
//            return "";
        }


    }


} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\ingestionutils\xlastutil\xlastcomparer.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Xml;
using System.Xml.Schema;
using System.Xml.Serialization;
using System.Text;
using System.Xml.XPath;

using xonline.common.config;
using xonline.common.livetitleconfig;
using xonline.common.mgmt;
using xonline.common.service;

namespace xonline.common.xlastutil
{
    public class XlastComparer
    {
        public static bool IsValidUpdate( XboxLiveSubmissionProject oldXlast, XboxLiveSubmissionProject newXlast, StringBuilder sb )
        {
            bool ret = true;

            // Currently, we're only testing and forbidding the removal of achievements and changes to leaderboards
            ret = !AreAchievementsRemoved(oldXlast.GameConfigProject.Achievements,                            newXlast.GameConfigProject.Achievements,                     sb) && ret;
            ret = !AreStatsViewsModified( oldXlast.GameConfigProject.StatsViews.StatsView,                    newXlast.GameConfigProject.StatsViews.StatsView,             sb) && ret;

            return ret;
        }

        public static bool IsContentUpdate( XboxLiveSubmissionProject oldXlast, XboxLiveSubmissionProject newXlast, string oldImageDir, string newImageDir, StringBuilder sb )
        {
            bool ret = true;

            ret =  IsVersionGreater(oldXlast.GameConfigProject.projectVersion,                                 newXlast.GameConfigProject.projectVersion,                   sb) && ret;
            ret = !AreAchievementsModified(oldXlast.GameConfigProject.Achievements,                            newXlast.GameConfigProject.Achievements,                     sb) && ret;
            ret = !AreStatsViewsModified(oldXlast.GameConfigProject.StatsViews.StatsView,                      newXlast.GameConfigProject.StatsViews.StatsView,             sb) && ret;
            ret = !AreContextsModified(oldXlast.GameConfigProject.Contexts.Context,                            newXlast.GameConfigProject.Contexts.Context,                 sb) && ret;
            ret = !ArePropertiesModified(oldXlast.GameConfigProject.Properties.Property,                       newXlast.GameConfigProject.Properties.Property,              sb) && ret;
            ret = !AreGameModesModified(oldXlast.GameConfigProject.GameModes.GameMode,                         newXlast.GameConfigProject.GameModes.GameMode,               sb) && ret;
            ret = !AreSupportedLocalesModified(oldXlast.GameConfigProject.LocalizedStrings.SupportedLocale,    newXlast.GameConfigProject.LocalizedStrings.SupportedLocale, sb) && ret;
            ret = !AreLocalizedStringsModified(oldXlast.GameConfigProject.LocalizedStrings.LocalizedString,    newXlast.GameConfigProject.LocalizedStrings.LocalizedString, sb) && ret;
            ret = !AreImagesModified(oldXlast.GameConfigProject.Images.Image,                                  newXlast.GameConfigProject.Images.Image,                     oldImageDir, newImageDir, sb) && ret;
            ret = !ArePresenceModesModified(oldXlast.GameConfigProject.Presence.PresenceMode,                  newXlast.GameConfigProject.Presence.PresenceMode,            sb) && ret;
            ret = !AreMatchmakingAttributesModified(oldXlast.GameConfigProject.Matchmaking.Schema.Attribute,   newXlast.GameConfigProject.Matchmaking.Schema.Attribute,     sb) && ret;
            ret = !AreMatchmakingConstantsModified(oldXlast.GameConfigProject.Matchmaking.Constants.Constant,  newXlast.GameConfigProject.Matchmaking.Constants.Constant,   sb) && ret;
            ret = !AreMatchmakingQueriesModified(oldXlast.GameConfigProject.Matchmaking.Queries.Query,         newXlast.GameConfigProject.Matchmaking.Queries.Query,        sb) && ret;

            return ret;

        }

        public static bool IsVersionGreater( string oldVersion, string newVersion, StringBuilder sb )
        {
            string[] oldVerParts = oldVersion.Split(new char[] {'.'});
            string[] newVerParts = newVersion.Split(new char[] {'.'});

            if (oldVerParts.Length != 4)
            {
                sb.Append("\r\nInvalid format for projectVersion in old xlast!  ('" + oldVersion + "')");
                return false;
            }
            if (newVerParts.Length != 4)
            {
                sb.Append("\r\nInvalid format for projectVersion in new xlast!  ('" + newVersion + "')");
                return false;
            }


            for (int i = 0; i < oldVerParts.Length; i++)
            {
                int ov = SafeConvert.ToInt32(oldVerParts[i], -1);
                if (ov == -1)
                {
                    sb.Append("\r\nCouldn't understand version number in old xlast!  ('" + oldVersion + "')");
                    return false;
                }

                int nv = SafeConvert.ToInt32(newVerParts[i], -1);
                if (nv == -1)
                {
                    sb.Append("\r\nCouldn't understand version number in old xlast!  ('" + oldVersion + "')");
                    return false;
                }


                if (nv > ov)
                {
                    // yep, the version is higher
                    return true;
                }
            }

            sb.Append("\r\nVersion in old xlast >= version in new xlast!");
            return false;
        }


        public static bool AreAchievementsRemoved(
            Achievements oldAchievements,
            Achievements newAchievements,
            StringBuilder sb)
        {

            // Some title types (specifically Demo) can pass SPAC validation without an
            // Achievements node (Xlast.GameConfigProject.Achievements == null) so we
            // need to check if an Achievements node exists and if it doesn't, treat it
            // as if the Achievement array is a null object (IE no achievements)

            if (oldAchievements == null || oldAchievements.Achievement == null)
            {
                return false;
            }

            if (newAchievements == null || newAchievements.Achievement == null)
            {
                sb.Append("\r\nAll achievements have been removed!");
                return true;
            }


            if (oldAchievements.Achievement.Length > newAchievements.Achievement.Length)
            {
                sb.Append("\r\nAchievements have been removed!");
                return true;
            }

            foreach  (XboxLiveSubmissionProjectGameConfigProjectAchievementsAchievement oldAch in oldAchievements.Achievement)
            {
                bool found = false;

                foreach (XboxLiveSubmissionProjectGameConfigProjectAchievementsAchievement newAch in newAchievements.Achievement)
                {
                    if (oldAch.id == newAch.id)
                    {
                        found = true;
                        break;
                    }
                }

                if (!found)
                {
                    sb.Append("\r\nAchievement id " + oldAch.id + " is missing from new xlast!");
                    return true;
                }
            }

            // all good!
            return false;
        }


        public static bool AreAchievementsModified(
            Achievements oldAchievements,
            Achievements newAchievements,
            StringBuilder sb)
        {
            if (oldAchievements == null || oldAchievements.Achievement == null)
            {
                return false;
            }

            if (newAchievements == null || newAchievements.Achievement == null)
            {
                sb.Append("\r\nAchievements have been removed!");
                return true;
            }


            if (oldAchievements.Achievement.Length > newAchievements.Achievement.Length)
            {
                sb.Append("\r\nAchievements have been removed!");
                return true;
            }

            foreach  (XboxLiveSubmissionProjectGameConfigProjectAchievementsAchievement oldAch in oldAchievements.Achievement)
            {
                bool found = false;

                foreach (XboxLiveSubmissionProjectGameConfigProjectAchievementsAchievement newAch in newAchievements.Achievement)
                {
                    if (oldAch.id == newAch.id)
                    {
                        // found the match, make sure everything is the same
                        if (oldAch.achievementType != newAch.achievementType)
                        {
                            sb.Append("\r\nType of achievement has changed for achievement id " + oldAch.id);
                            return true;
                        }

                        if (oldAch.cred != newAch.cred)
                        {
                            sb.Append("\r\nAchievement cred has changed for achievement id " + oldAch.id);
                            return true;
                        }

                        if (oldAch.descriptionStringId != newAch.descriptionStringId)
                        {
                            sb.Append("\r\nAchievement description has changed for achievement id " + oldAch.id);
                            return true;
                        }

                        if (oldAch.imageId != newAch.imageId)
                        {
                            sb.Append("\r\nAchievement image has changed for achievement id " + oldAch.id);
                            return true;
                        }

                        if (oldAch.showUnachieved != newAch.showUnachieved)
                        {
                            sb.Append("\r\nAchievement display rules have changed for achievement id " + oldAch.id);
                            return true;
                        }

                        if (oldAch.titleStringId != newAch.titleStringId)
                        {
                            sb.Append("\r\nAchievement title string has changed for achievement id " + oldAch.id);
                            return true;
                        }

                        if (oldAch.unachievedStringId != newAch.unachievedStringId)
                        {
                            sb.Append("\r\nAchievement unachieved string has changed for achievement id " + oldAch.id);
                            return true;
                        }
                        if (oldAch.webDescriptionStringId != newAch.webDescriptionStringId)
                        {
                            sb.Append("\r\nAchievement web description string has changed for achievement id " + oldAch.id);
                            return true;
                        }

                        // all good, proceed to the next achievement
                        found = true;
                        break;
                    }
                }

                if (!found)
                {
                    sb.Append("\r\nAchievement id " + oldAch.id + " is missing from new xlast!");
                    return true;
                }
            }

            // all good!
            return false;
        }


        public static bool AreStatsViewsModified(
            StatsView[] oldViews,
            StatsView[] newViews,
            StringBuilder sb)
        {
            if (oldViews == null)
            {
                return false;
            }

            if (newViews == null)
            {
                sb.Append("\r\nStatsViews have been removed!");
                return true;
            }

            if (oldViews.Length > newViews.Length)
            {
                sb.Append("\r\nStatsViews have been removed!");
                return true;
            }


            // N.B. The asymmetry here is intentional.  We only care about whether
            //      old leaderboards have been altered or removed.  If a new on is
            //  added, this loop will not detect it, and we're fine with that 
            //  because adding a new leaderboard is an allowed operation
            //
            foreach  (StatsView oldView in oldViews)
            {
                bool found = false;

                foreach (StatsView newView in newViews)
                {
                    if (oldView.id == newView.id)
                    {
                        if (AreColumnsModified(oldView.Columns, newView.Columns, sb))
                        {
                            sb.Append("\r\nColumns changed for view id " + oldView.id);
                            return true;
                        }

                        if (oldView.arbitrated != newView.arbitrated)
                        {
                            sb.Append("\r\nStatsView arbitrated setting has changed for view id " + oldView.id);
                            return true;
                        }

                        if (oldView.entryExpiration != newView.entryExpiration)
                        {
                            sb.Append("\r\nStatsView entry expiration setting has changed for view id " + oldView.id);
                            return true;
                        }

                        if (oldView.hidden != newView.hidden)
                        {
                            sb.Append("\r\nStatsView hidden setting has changed for view id " + oldView.id);
                            return true;
                        }

                        if (oldView.topEntries != newView.topEntries)
                        {
                            sb.Append("\r\nStatsView top entries setting has changed for view id " + oldView.id);
                            return true;
                        }

                        if (oldView.onlineOnly != newView.onlineOnly)
                        {
                            sb.Append("\r\nStatsView onlineOnly setting has changed for view id " + oldView.id);
                            return true;
                        }

                        if (oldView.viewType != newView.viewType)
                        {
                            sb.Append("\r\nStatsView viewType setting has changed for view id " + oldView.id);
                            return true;
                        }

                        // note: changes to maxAttachments are ok

                        // all good, proceed to the next statsView
                        found = true;
                        break;
                    }
                }

                if (!found)
                {
                    sb.Append("\r\nStatsViews id " + oldView.id + " is missing from new xlast!");
                    return true;
                }
            }

            // all good!
            return false;
        }

        public static bool AreColumnsModified( ViewFieldType[] oldColumns, ViewFieldType[] newColumns, StringBuilder sb )
        {

            // N.B.  Unlike the leaderboard check above (AreStatsViewsModified)
            //       this check _IS_ concerned with _ALL_ changes to the columns
            // of a leaderboard.  Specifically, removal, changes and even 
            // additions of new columnds are flagged as a modification.
            //
            if (oldColumns.Length > newColumns.Length)
            {
                sb.Append("\r\nColumns have been removed!");
                return true;
            }

            if (oldColumns.Length < newColumns.Length)
            {
                sb.Append("\r\nColumns have been added!");
                return true;
            }

            // Since we have already checked to ensure that the new column count
            // matches the old one, we now need to make sure that the column
            // attributes are identical (this covers the scenario where an
            // existing column was removed and a new one was added in its place
            //
            foreach  (ViewFieldType oldColumn in oldColumns)
            {
                bool found = false;

                foreach (ViewFieldType newColumn in newColumns)
                {
                    if (oldColumn.attributeId == newColumn.attributeId)
                    {
                        if (oldColumn.Item.GetType() != newColumn.Item.GetType())
                        {
                            sb.Append("\r\nColumn context/property types have changed!");
                            return true;
                        }

                        if (oldColumn.Item is PropertyFieldType)
                        {
                            if (((PropertyFieldType)(oldColumn.Item)).Aggregation.type != ((PropertyFieldType)(newColumn.Item)).Aggregation.type)
                            {
                                sb.Append("\r\nColumn aggregation type has changed!");
                                return true;
                            }

                            if (((PropertyFieldType)(oldColumn.Item)).id != ((PropertyFieldType)(newColumn.Item)).id)
                            {
                                sb.Append("\r\nColumn property id has changed!");
                                return true;
                            }
                        }
                        else
                        {
                            if (((ContextFieldType)(oldColumn.Item)).id != ((ContextFieldType)(newColumn.Item)).id)
                            {
                                sb.Append("\r\nColumn context id has changed!");
                                return true;
                            }
                        }

                        // all good, proceed to the next statsView
                        found = true;
                        break;
                    }
                }

                if (!found)
                {
                    sb.Append("\r\nStatsView column id " + oldColumn.attributeId + " is missing from new xlast!");
                    return true;
                }
            }

            return false;

        }

        public static bool AreContextsModified( Context[] oldContexts, Context[] newContexts, StringBuilder sb )
        {
            if (oldContexts == null)
            {
                return false;
            }

            if (newContexts == null)
            {
                sb.Append("\r\nAll contexts have been removed!");
                return true;
            }

            if (oldContexts.Length > newContexts.Length)
            {
                sb.Append("\r\nColumns have been removed!");
                return true;
            }

            foreach (Context oldContext in oldContexts)
            {
                bool found = false;

                foreach (Context newContext in newContexts)
                {
                    if (oldContext.id == newContext.id)
                    {
                        if (oldContext.ContextValue.Length > newContext.ContextValue.Length)
                        {
                            sb.Append("\r\nContext values have been removed for context id " + oldContext.id);
                            return true;
                        }

                        if (oldContext.stringId != newContext.stringId)
                        {
                            sb.Append("\r\nContext name has changed for context id " + oldContext.id);
                            return true;
                        }

                        if (oldContext.defaultValue != newContext.defaultValue)
                        {
                            sb.Append("\r\nDefault value has changed for context id " + oldContext.id);
                            return true;
                        }

                        foreach (ContextValue oldValue in oldContext.ContextValue)
                        {
                            bool foundContext = false;

                            foreach (ContextValue newValue in newContext.ContextValue)
                            {
                                if (newValue.contextValue == oldValue.contextValue)
                                {
                                    if (oldValue.stringId != newValue.stringId)
                                    {
                                        sb.Append("\r\nContext values have changed for context id " + oldContext.id);
                                        return true;
                                    }

                                    foundContext = true;
                                    break;
                                }
                            }

                            if (!foundContext)
                            {
                                sb.Append("\r\nCouldn't find old context value " + oldValue.contextValue + " in new xlast, for context id " + oldContext.id);
                                return true;
                            }
                        }

                        found = true;
                        break;
                    }
                }

                if (!found)
                {
                    sb.Append("\r\nContext id " + oldContext.id + " has been removed!");
                    return true;
                }
            }

            return false;
        }

        public static bool ArePropertiesModified(
            XboxLiveSubmissionProjectGameConfigProjectPropertiesProperty[] oldProperties,
            XboxLiveSubmissionProjectGameConfigProjectPropertiesProperty[] newProperties,
            StringBuilder sb )
        {
            if (oldProperties == null)
            {
                return false;
            }

            if (newProperties == null)
            {
                sb.Append("\r\nAll Properties have been removed!");
                return true;
            }

            if (oldProperties.Length > newProperties.Length)
            {
                sb.Append("\r\nColumns have been removed!");
                return true;
            }

            foreach (XboxLiveSubmissionProjectGameConfigProjectPropertiesProperty oldProperty in oldProperties)
            {
                bool found = false;

                foreach (XboxLiveSubmissionProjectGameConfigProjectPropertiesProperty newProperty in newProperties)
                {
                    if (oldProperty.id == newProperty.id)
                    {
                        if (oldProperty.dataSize != newProperty.dataSize)
                        {
                            sb.Append("\r\nData size changed for property id " + oldProperty.id);
                            return true;
                        }

                        if (oldProperty.stringId != newProperty.stringId)
                        {
                            sb.Append("\r\nString id changed for property id " + oldProperty.id);
                            return true;
                        }

                        if (!(oldProperty.Format == null && newProperty.Format == null))
                        {
                            if ((oldProperty.Format != null && newProperty.Format == null)         ||
                                (oldProperty.Format == null && newProperty.Format != null)         ||
                                oldProperty.Format.decimals     != newProperty.Format.decimals     ||
                                oldProperty.Format.day          != newProperty.Format.day          ||
                                oldProperty.Format.hours        != newProperty.Format.hours        ||
                                oldProperty.Format.minutes      != newProperty.Format.minutes      ||
                                oldProperty.Format.seconds      != newProperty.Format.seconds      ||
                                oldProperty.Format.milliseconds != newProperty.Format.milliseconds ||
                                oldProperty.Format.month        != newProperty.Format.month        ||
                                oldProperty.Format.year         != newProperty.Format.year)
                            {
                                sb.Append("\r\nFormat changed for property id " + oldProperty.id);
                                return true;
                            }
                        }

                        found = true;
                        break;
                    }
                }

                if (!found)
                {
                    sb.Append("\r\nProerty id " + oldProperty.id + " has been removed!");
                    return true;
                }
            }

            return false;
        }

        public static bool AreGameModesModified(LiveGameMode[] oldGameModes, LiveGameMode[] newGameModes, StringBuilder sb)
        {
            if (oldGameModes == null)
            {
                return false;
            }

            if (newGameModes == null)
            {
                sb.Append("\r\nAll GameModes have been removed!");
                return true;
            }

            if (oldGameModes.Length > newGameModes.Length)
            {
                sb.Append("\r\nColumns have been removed!");
                return true;
            }

            foreach (LiveGameMode oldGameMode in oldGameModes)
            {
                bool found = false;

                foreach (LiveGameMode newGameMode in newGameModes)
                {
                    if (oldGameMode.Value == newGameMode.Value)
                    {
                        if (oldGameMode.stringId != newGameMode.stringId)
                        {
                            sb.Append("\r\nString id changed for game mode " + oldGameMode.Value);
                            return true;
                        }

                        found = true;
                        break;
                    }
                }

                if (!found)
                {
                    sb.Append("\r\nGame mode " + oldGameMode.Value + " was removed!");
                    return true;
                }
            }

            return false;
        }


        public static bool AreSupportedLocalesModified(SupportedLocale[] oldLocales, SupportedLocale[] newLocales, StringBuilder sb)
        {
            if (oldLocales == null)
            {
                return false;
            }

            if (newLocales == null)
            {
                sb.Append("\r\nAll Locales have been removed!");
                return true;
            }

            if (oldLocales.Length > newLocales.Length)
            {
                sb.Append("\r\nLocales have been removed!");
                return true;
            }

            foreach (SupportedLocale oldLocale in oldLocales)
            {
                bool found = false;

                foreach (SupportedLocale newLocale in newLocales)
                {
                    if (oldLocale.locale == newLocale.locale)
                    {
                        found = true;
                        break;
                    }
                }

                if (!found)
                {
                    sb.Append("\r\nLocale " + oldLocale.locale + " was removed!");
                    return true;
                }
            }

            return false;
        }

        public static bool AreLocalizedStringsModified(LocalizedString[] oldLocalizedStrings, LocalizedString[] newLocalizedStrings, StringBuilder sb)
        {
            if (oldLocalizedStrings == null)
            {
                return false;
            }

            if (newLocalizedStrings == null)
            {
                sb.Append("\r\nAll LocalizedStrings have been removed!");
                return true;
            }

            if (oldLocalizedStrings.Length > newLocalizedStrings.Length)
            {
                sb.Append("\r\nColumns have been removed!");
                return true;
            }

            foreach (LocalizedString oldLocalizedString in oldLocalizedStrings)
            {
                bool found = false;

                foreach (LocalizedString newLocalizedString in newLocalizedStrings)
                {
                    if (oldLocalizedString.id == newLocalizedString.id)
                    {
                        if (oldLocalizedString.Translation.Length > newLocalizedString.Translation.Length)
                        {
                            sb.Append("\r\nTranslations have been removed for string id " + oldLocalizedString.id);
                            return true;
                        }

                        foreach (Translation oldLoc in oldLocalizedString.Translation)
                        {
                            bool foundLoc = false;

                            foreach (Translation newLoc in newLocalizedString.Translation)
                            {
                                if (oldLoc.locale == newLoc.locale)
                                {
                                    if (oldLoc.Value != newLoc.Value)
                                    {
                                        sb.Append("\r\nThe string for string id " + oldLocalizedString.id + " locale " + oldLoc.locale + " has changed!");
                                        return true;
                                    }

                                    foundLoc = true;
                                    break;
                                }

                            }

                            if (!foundLoc)
                            {
                                sb.Append("\r\nThe locale " + oldLoc.locale + " for string id " + oldLocalizedString.id + " has been removed!");
                                return true;
                            }
                        }

                        found = true;
                        break;
                    }
                }

                if (!found)
                {
                    sb.Append("\r\nlocalized string id " + oldLocalizedString.id+ " was removed!");
                    return true;
                }
            }

            return false;
        }

        public static bool AreImagesModified(
            Image[] oldImages,
            Image[] newImages,
            string oldXlastPath,
            string newXlastPath,
            StringBuilder sb)
        {
            if (oldImages == null)
            {
                return false;
            }

            if (newImages == null)
            {
                sb.Append("\r\nAll Images have been removed!");
                return true;
            }

            if (oldImages.Length > newImages.Length)
            {
                sb.Append("\r\nImages have been removed!");
                return true;
            }

            foreach (Image oldImage in oldImages)
            {
                bool found = false;

                foreach (Image newImage in newImages)
                {
                    if (oldImage.id == newImage.id)
                    {
                        if (oldImage.Path != newImage.Path)
                        {
                            sb.Append("\r\nImage path changed for Image id " + oldImage.id);
                            return true;
                        }

                        byte[] oldImageBytes = LoadImage(Path.Combine(oldXlastPath, oldImage.Path));
                        byte[] newImageBytes = LoadImage(Path.Combine(newXlastPath, newImage.Path));

                        if (oldImageBytes == null)
                        {
                            sb.Append("\r\nCouldn't read image referenced by old xlast file: " + Path.Combine(oldXlastPath, oldImage.Path));
                            return true;
                        }
                        if (newImageBytes == null)
                        {
                            sb.Append("\r\nCouldn't read image referenced by new xlast file: " + Path.Combine(newXlastPath, newImage.Path));
                            return true;
                        }


                        if (!ByteArray.Equals(oldImageBytes, newImageBytes))
                        {
                            sb.Append("\r\nImages changed for image id " + oldImage.id);
                            return true;
                        }

                        found = true;
                        break;
                    }
                }

                if (!found)
                {
                    sb.Append("\r\nImage id " + oldImage.id + " was removed!");
                    return true;
                }
            }

            return false;
        }


        public static byte[] LoadImage(string imagePath)
        {
#if TEST
            if (_images.Contains(imagePath))
                return (byte[])_images[imagePath];
#endif

            if (!File.Exists(imagePath))
            {
                return null;
            }

            using (FileStream reader = File.Open(imagePath, FileMode.Open, FileAccess.Read, FileShare.Read))
            {
                byte[] file = new byte[reader.Length];
                reader.Read(file, 0, file.Length);

                return file;
            }
        }

#if TEST
        private static Hashtable _images = new Hashtable();
        public static void SetImage(string path, byte[] image)
        {
            _images[path] = image;
        }
#endif


        public static bool AreGamerPicturesModified(
            Picture[] oldPictures,
            Picture[] newPictures,
            StringBuilder sb)
        {
            if (oldPictures == null)
            {
                return false;
            }

            if (newPictures == null)
            {
                sb.Append("\r\nAll Pictures have been removed!");
                return true;
            }

            if (oldPictures.Length > newPictures.Length)
            {
                sb.Append("\r\nPictures have been removed!");
                return true;
            }

            foreach (Picture oldPicture in oldPictures)
            {
                bool found = false;

                foreach (Picture newPicture in newPictures)
                {
                    if (oldPicture.id == newPicture.id)
                    {
                        found = true;
                        break;
                    }
                }

                if (!found)
                {
                    sb.Append("\r\nPicture id " + oldPicture.id + " was removed!");
                    return true;
                }
            }

            return false;
        }

        public static bool ArePresenceModesModified(
                XboxLiveSubmissionProjectGameConfigProjectPresencePresenceMode[] oldModes,
                XboxLiveSubmissionProjectGameConfigProjectPresencePresenceMode[] newModes,
                StringBuilder sb)
        {
            if (oldModes == null)
            {
                return false;
            }

            if (newModes == null)
            {
                sb.Append("\r\nAll Presnce Modes have been removed!");
                return true;
            }

            if (oldModes.Length > newModes.Length)
            {
                sb.Append("\r\nPresence modes have been removed!");
                return true;
            }

            foreach (XboxLiveSubmissionProjectGameConfigProjectPresencePresenceMode oldMode in oldModes)
            {
                bool found = false;

                foreach (XboxLiveSubmissionProjectGameConfigProjectPresencePresenceMode newMode in newModes)
                {
                    if (oldMode.contextValue == newMode.contextValue)
                    {
                        if (oldMode.stringId != newMode.stringId)
                        {
                            sb.Append("\r\nPresence Mode string changed for PresenceMode id " + oldMode.contextValue);
                            return true;
                        }

                        found = true;
                        break;
                    }
                }

                if (!found)
                {
                    sb.Append("\r\nPresence Mode id " + oldMode.contextValue + " was removed!");
                    return true;
                }
            }

            return false;
        }

        public static bool AreMatchmakingAttributesModified(
                XboxLiveSubmissionProjectGameConfigProjectMatchmakingSchemaAttribute[] oldAttributes,
                XboxLiveSubmissionProjectGameConfigProjectMatchmakingSchemaAttribute[] newAttributes,
                StringBuilder sb)
        {
            if (oldAttributes == null)
            {
                return false;
            }

            if (newAttributes == null)
            {
                sb.Append("\r\nMatchmaking attributes have been removed!");
                return true;
            }

            if (oldAttributes.Length > newAttributes.Length)
            {
                sb.Append("\r\nMatchmaking attributes have been removed!");
                return true;
            }

            foreach (XboxLiveSubmissionProjectGameConfigProjectMatchmakingSchemaAttribute oldAttribute in oldAttributes)
            {
                bool found = false;

                foreach (XboxLiveSubmissionProjectGameConfigProjectMatchmakingSchemaAttribute newAttribute in newAttributes)
                {
                    if (oldAttribute.id == newAttribute.id)
                    {
                        found = true;
                        break;
                    }
                }

                if (!found)
                {
                    sb.Append("\r\nMatchmaking attribute id " + oldAttribute.id + " was removed!");
                    return true;
                }
            }

            return false;
        }


        public static bool AreMatchmakingConstantsModified(
                XboxLiveSubmissionProjectGameConfigProjectMatchmakingConstantsConstant [] oldConstants,
                XboxLiveSubmissionProjectGameConfigProjectMatchmakingConstantsConstant[] newConstants,
                StringBuilder sb)
        {
            if (oldConstants == null)
            {
                return false;
            }

            if (newConstants == null)
            {
                sb.Append("\r\nMatchmaking Constants have been removed!");
                return true;
            }

            if (oldConstants.Length > newConstants.Length)
            {
                sb.Append("\r\nMatchmaking Constants have been removed!");
                return true;
            }

            foreach (XboxLiveSubmissionProjectGameConfigProjectMatchmakingConstantsConstant oldConstant in oldConstants)
            {
                bool found = false;

                foreach (XboxLiveSubmissionProjectGameConfigProjectMatchmakingConstantsConstant newConstant in newConstants)
                {
                    if (oldConstant.id == newConstant.id)
                    {
                        if (oldConstant.value != newConstant.value)
                        {
                            sb.Append("\r\nMatchmaking constant value has changed for id " + oldConstant.id);
                            return true;
                        }

                        if (oldConstant.name != newConstant.name)
                        {
                            sb.Append("\r\nMatchmaking constant name has changed for id " + oldConstant.id);
                            return true;
                        }

                        found = true;
                        break;
                    }
                }

                if (!found)
                {
                    sb.Append("\r\nMatchmaking Constant id " + oldConstant.id + " was removed!");
                    return true;
                }
            }

            return false;
        }

        public static bool AreMatchmakingQueriesModified(
                XboxLiveSubmissionProjectGameConfigProjectMatchmakingQueriesQuery[] oldQueries,
                XboxLiveSubmissionProjectGameConfigProjectMatchmakingQueriesQuery[] newQueries,
                StringBuilder sb)
        {
            if (oldQueries == null)
            {
                return false;
            }

            if (newQueries == null)
            {
                sb.Append("\r\nMatchmaking Queries have been removed!");
                return true;
            }

            if (oldQueries.Length > newQueries.Length)
            {
                sb.Append("\r\nMatchmaking Queries have been removed!");
                return true;
            }

            foreach (XboxLiveSubmissionProjectGameConfigProjectMatchmakingQueriesQuery oldQuery in oldQueries)
            {
                bool found = false;

                foreach (XboxLiveSubmissionProjectGameConfigProjectMatchmakingQueriesQuery newQuery in newQueries)
                {
                    if (oldQuery.id == newQuery.id)
                    {
                        if (oldQuery.type != newQuery.type)
                        {
                            sb.Append("\r\nMatchmaking Query type has changed for id " + oldQuery.id);
                            return true;
                        }

                        if (AreMatchmakingQueryParamsModified(oldQuery.Parameters, newQuery.Parameters, sb) ||
                            AreMatchmakingQueryReturnsModified(oldQuery.Returns, newQuery.Returns, sb))
                        {
                            sb.Append("\r\nMatchmaking query parameters were modifed for id " + oldQuery.id);
                            return true;
                        }

                        found = true;
                        break;
                    }
                }

                if (!found)
                {
                    sb.Append("\r\nMatchmaking Query id " + oldQuery.id + " was removed!");
                    return true;
                }
            }

            return false;
        }


        public static bool AreMatchmakingQueryParamsModified(
            XboxLiveSubmissionProjectGameConfigProjectMatchmakingQueriesQueryParameter[] oldParams,
            XboxLiveSubmissionProjectGameConfigProjectMatchmakingQueriesQueryParameter[] newParams,
            StringBuilder sb)
        {
            if (oldParams == null)
            {
                return false;
            }

            if (newParams == null)
            {
                sb.Append("\r\nAll Params have been removed!");
                return true;
            }

            if (oldParams.Length != newParams.Length)
            {
                sb.Append("\r\nParams have been removed!");
                return true;
            }

            foreach (XboxLiveSubmissionProjectGameConfigProjectMatchmakingQueriesQueryParameter oldParam in oldParams)
            {
                bool found = false;

                foreach (XboxLiveSubmissionProjectGameConfigProjectMatchmakingQueriesQueryParameter newParam in newParams)
                {
                    if (oldParam.id == newParam.id)
                    {
                        found = true;
                        break;
                    }
                }

                if (!found)
                {
                    sb.Append("\r\nParam " + oldParam.id + " was removed!");
                    return true;
                }
            }

            return false;
        }

        public static bool AreMatchmakingQueryReturnsModified(
            XboxLiveSubmissionProjectGameConfigProjectMatchmakingQueriesQueryReturn[] oldReturns,
            XboxLiveSubmissionProjectGameConfigProjectMatchmakingQueriesQueryReturn[] newReturns,
            StringBuilder sb)
        {
            if (oldReturns == null)
            {
                return false;
            }

            if (newReturns == null)
            {
                sb.Append("\r\nAll Returns have been removed!");
                return true;
            }

            if (oldReturns.Length != newReturns.Length)
            {
                sb.Append("\r\nMatchmaking returns have been removed!");
                return true;
            }


            foreach (XboxLiveSubmissionProjectGameConfigProjectMatchmakingQueriesQueryReturn oldReturn in oldReturns)
            {
                bool found = false;

                foreach (XboxLiveSubmissionProjectGameConfigProjectMatchmakingQueriesQueryReturn newReturn in newReturns)
                {
                    if (oldReturn.id == newReturn.id)
                    {
                        if (oldReturn.type != newReturn.type)
                        {
                            sb.Append("\r\ntype for return id " + oldReturn.id + " has been modified!");
                            return true;
                        }

                        if (oldReturn.ordinal != newReturn.ordinal )
                        {
                            sb.Append("\r\nOrdinal for return id " + oldReturn.id + " has been modified!");
                            return true;
                        }

                        found = true;
                        break;
                    }
                }

                if (!found)
                {
                    sb.Append("\r\nReturn " + oldReturn.id + " was removed!");
                    return true;
                }
            }

            return false;
        }
    }

} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\ingestionutils\xlastutil\xlastutil.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Xml;
using System.Xml.Schema;
using System.Xml.Serialization;
using System.Xml.XPath;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.tools.framework;

[assembly: XomAreaDefinition(XomAreaName.xlastutil)]
//task: add this to Config stuff... (other than settings.cs)

namespace xonline.common.xlastutil
{
    /// <summary>
    /// Class to make it easier to deal with xlast data from NPDB.
    /// </summary>
    public class XlastUtil  
    {

        public const int TITLE_NAME_STRING_ID = 32768;

        public const ulong TITLE_TYPE_SYSTEM       = 0;
        public const ulong TITLE_TYPE_FULL         = 1;
        public const ulong TITLE_TYPE_DEMO         = 2;
        public const ulong TITLE_TYPE_DOWNLOADABLE = 3;

        public XlastUtil()
        {
        }

        public static void PutXlastFromDrive( uint titleID, string xlastPathString )
        {

            //task: exceptions??? Let the caller handle the exception
            
            //this should ONLY be used for non-production code
            StreamReader xlastReader = new StreamReader( xlastPathString );
            string xlast = xlastReader.ReadToEnd();

            //task: validate Xlast file before adding it to NPDB!!!
            
            XlastUtil.PutXlast( titleID, xlast );
        }

        public static void PutXlast( uint titleID, string xlastString )
        {

            //use class to get the schema string
            //task: find the XDK version number ... 

            //task: validate the xlast string

            using (SqlConnection xlastConn = new SqlConnection( ConfigUtil.NpdbConnectionString ) )
            {
                xlastConn.Open();
                SqlCommand xlastCmd = xlastConn.CreateCommand();
                xlastCmd.CommandType = CommandType.StoredProcedure;

                //confirm that title doesn't already exist in NPDB
                xlastCmd.CommandText = "dbo.p_game_save_config";

                xlastCmd.Parameters.Add( "@i_title_id", SqlDbType.Int ).Value = (int) titleID;
                xlastCmd.Parameters["@i_title_id"].Direction = ParameterDirection.Input;  
                
                xlastCmd.Parameters.Add( "@xml_config", SqlDbType.NText ).Value = xlastString;
                xlastCmd.Parameters["@xml_config"].Direction = ParameterDirection.Input;

                //task: hardcoded for now, will need to change once XLAST has the schema version.
                xlastCmd.Parameters.Add( "@vc_xdk_version", SqlDbType.VarChar, 50 ).Value = "2.0.1420.0";
                xlastCmd.Parameters["@vc_xdk_version"].Direction = ParameterDirection.Input;

                xlastCmd.Parameters.Add( "@hr", SqlDbType.Int );
                xlastCmd.Parameters["@hr"].Direction = ParameterDirection.ReturnValue ;

                SqlDataReader xlastReader = xlastCmd.ExecuteReader();

                //if it worked... 
                if ( System.Convert.ToInt32( xlastCmd.Parameters["@hr"].Value ) != 0 )
                {
                    //task: something didn't work, exception?
                }

            }

        }

//        //task: Implement SAVE as an instance method  ???
//        public void Save( XboxLiveSubmissionProject xlsp )
//        {
//            string xlastXml = .ToXml();
//
//            //call put
//            XlastUtil.PutXlast( xlsp.GameConfigProject.titleId, xlastXml );
//        }
        
//        public static bool XlastExists( uint TitleID )
//        {
//            //find out whether this title has a non empty Xlast file
//            return false;
//
//        }

//        public static StatsViews GetStatsViews( uint titleID )
//        {
//            //get xlast
//            string xlast = XlastUtil.GetXlastString( titleID );
//            if ( xlast == "" )
//            {
//                throw new Exception( "TitleID " + titleID + " not found!" );
//            }
//
//            return GetStatsViewsFromXlast( xlast );
//        }

        //review: is this really that useful??
//        public static StatsViews GetStatsViewsFromXlast( string xlast )
//        {
//            //deserialize it and find the statsviews element
//            XboxLiveSubmissionProject xlsp = XlastUtil.GetXlastFromXml( xlast );
//            StatsViews sv = xlsp.GameConfigProject.StatsViews;
//
//            return sv;
//        }

        //returns null if it's not there, or there's a problem with the DB
        public static XboxLiveSubmissionProject GetXlast( uint titleID )
        {

            XboxLiveSubmissionProject xlast = null;

            try
            {
                string xlastString = GetXlastString( titleID );
                XmlTextReader xmlReader = new XmlTextReader( new StringReader( xlastString ) );
                XmlSerializer serializer = new XmlSerializer( typeof( XboxLiveSubmissionProject ) );
                xlast = ( XboxLiveSubmissionProject ) serializer.Deserialize( xmlReader );
                return xlast;
            }
            //task: make this more specific or remove it!
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Returns the XML string for this titleID as retrieved from NPDB or empty string if not found or error.
        /// </summary>
        public static string GetXlastString( uint titleID )
        {
        
            //std sql code here for getting the xlast file
            string xlastString = "";
            try 
            {
                using (SqlConnection xlastConn = new SqlConnection( ConfigUtil.NpdbConnectionString ) )
                {
                    xlastConn.Open();
                    SqlCommand xlastCmd = xlastConn.CreateCommand();
                    xlastCmd.CommandType = CommandType.StoredProcedure;
                    xlastCmd.CommandText = "dbo.p_game_get_config ";

                    xlastCmd.Parameters.Add( "@i_title_id", SqlDbType.Int ).Value = (int) titleID;
                    xlastCmd.Parameters["@i_title_id"].Direction = ParameterDirection.Input;  
              
                    xlastCmd.Parameters.Add( "@hr", SqlDbType.Int );
                    xlastCmd.Parameters["@hr"].Direction = ParameterDirection.ReturnValue;

                    SqlDataReader xlastReader = xlastCmd.ExecuteReader();

                    //p_game_get_config will return non-zero hr if the title wasn't found.
                    //0x80150013 -- 2146107373 -- XONLINE_E_INVALID_TITLE_ID
                    if ( xlastReader.Read() && ( System.Convert.ToInt32( xlastCmd.Parameters["@hr"].Value ) == 0 ) )
                    {
                        xlastString = (string) xlastReader.GetSqlString(2);
                    }
                    else 
                    {
                        Xom.Trace(XomAreaName.xlastutil, LogLevel.L_ERROR, "There was no data for that TitleID " + titleID );
                        throw new Exception("There was no data for that TitleID " + titleID);
                    }

                } //using 

            }
            catch ( Exception e )
            {
                Xom.Trace(XomAreaName.xlastutil, LogLevel.L_ERROR, " There was an error attempting to retrieve the xlast file. \n" + e.ToString() );
            }

            return xlastString;
        }


        //task: looping through the file twice isn't particularly efficient,
        //      but we need to make sure it's valid before we attempt to make 
        //      changes to stats based on the information.  Perhaps an XMLDoc might
        //      be a better way to go in the future... 
        public static bool ValidateXlast( string xlastXml, int titleID )
        {
            string schemaXml = XlastSchemaUtil.GetXlastSchemaFromXlastString( xlastXml ); 
            StringReader schemaStream = new StringReader(schemaXml);
            StringReader xmlStream = new StringReader(xlastXml);

            XmlReaderSettings xmlReaderSettings;
            XmlTextReader schemaReader;

            schemaReader = new XmlTextReader(schemaStream);
            xmlReaderSettings = new XmlReaderSettings();

            xmlReaderSettings.Schemas.Add("http://www.xboxlive.com/xlast", schemaReader);
            xmlReaderSettings.ValidationType = ValidationType.Schema;
            XmlReader xmlReader = XmlReader.Create(xmlStream, xmlReaderSettings);

            bool foundTitleID = false;
            Xom.Trace(XomAreaName.xlastutil, LogLevel.L_INFO, "\nVALIDATING XLAST file that was retrieved from NPDB..." );

            while ( xmlReader.Read() )
            {
                // do mostly nothing except read through an confirm it's well-formed and valid XML
                // if there's invalid XML, there's an event that will call the event handler
                // ... and in the event handler, we set xmlValid to false.

                //this is a good place to check whether the titleID they gave us is accurate... 
                if ( ! foundTitleID )
                {

                    //Console.WriteLine( "Element: Name: " + vr.Name + ", Value: " + vr.Value );

                    if ( "GameConfigProject" == xmlReader.Name )
                    {
                        //this element as a titleid attribute.
                        while( xmlReader.MoveToNextAttribute () & ( ! foundTitleID ) )
                        {                      
                            if ( "titleId" == xmlReader.Name )
                            {
                                foundTitleID = true;
                                Xom.Trace(XomAreaName.xlastutil, LogLevel.L_INFO, "==> XLAST TitleID is " + xmlReader.Value );
                                int xlastTitleID = ConvertTitleIDString( xmlReader.Value );
                                if ( titleID != xlastTitleID )
                                {
                                    Xom.Trace(XomAreaName.xlastutil, LogLevel.L_ERROR, "==> INCORRECT Xlast file stored for this titleID. TitleID's do not match!" );
                                    return false;
                                }
                                else
                                {
                                    Xom.Trace(XomAreaName.xlastutil, LogLevel.L_INFO,  "==> Correct Xlast file stored for this titleID." );
                                }
                            } //titleid attr

                        } // while attributes
                        
                        if ( !foundTitleID )
                        {
                            Xom.Trace(XomAreaName.xlastutil, LogLevel.L_ERROR, "==> INVALID Xlast file does not have required titleID attribute!" );
                            return false;
                        }
                    } // if gameconfig element

                } // if foundTitleID

            } // while more nodes and no invalid callback

            return true;

        }


        //this is where the action is...
        public static bool ValidateXlast( string xlastXml, string schemaXml )
        {
            StringReader schemaStream = new StringReader(schemaXml);
            StringReader xmlStream = new StringReader(xlastXml);

            XmlReaderSettings xmlReaderSettings;
            XmlTextReader schemaReader;

            schemaReader = new XmlTextReader(schemaStream);
            xmlReaderSettings = new XmlReaderSettings();

            xmlReaderSettings.Schemas.Add("http://www.xboxlive.com/xlast", schemaReader);
            xmlReaderSettings.ValidationType = ValidationType.Schema;
            XmlReader xmlReader = XmlReader.Create(xmlStream, xmlReaderSettings);

            Xom.Trace(XomAreaName.xlastutil, LogLevel.L_INFO, "VALIDATING XLAST document" );
             bool validXml = false;
           try 
            {
                while ( xmlReader.Read() )
                {
                    // do mostly nothing except read through an confirm it's well-formed and valid XML
                    // if there's invalid XML, there'll be an exception
                } // while more nodes

                validXml = true;
            }
            catch ( Exception e )
            {
                Xom.Trace(XomAreaName.xlastutil, LogLevel.L_INFO, "INVALID XLAST document. Exception: " + e.ToString() );
            }
            return validXml;
        }

        //deletes both the Xlast and the Live Title Config
        public static void DeleteTitleInfo( uint titleID )
        {

            //task: let the exception bubble up if there's an error ???
            using (SqlConnection xlastConn = new SqlConnection( ConfigUtil.NpdbConnectionString ) )
            {
                xlastConn.Open();
                SqlCommand xlastCmd = xlastConn.CreateCommand();
                xlastCmd.CommandType = CommandType.StoredProcedure;
                xlastCmd.CommandText = "dbo.p_game_delete_config";

                xlastCmd.Parameters.Add( "@i_title_id", SqlDbType.Int ).Value = (int) titleID;
                xlastCmd.Parameters["@i_title_id"].Direction = ParameterDirection.Input;  
              
                xlastCmd.Parameters.Add( "@hr", SqlDbType.Int );
                xlastCmd.Parameters["@hr"].Direction = ParameterDirection.ReturnValue;
                
                xlastCmd.ExecuteNonQuery();

            } //using 

        }

        //task: once XSD's are in NPDB... implement this one...
//        public static bool ValidatedXlastString( string xlastXML, string xdkVersion )
//        {
//            // get XSD from npdb
//            // validate Xlast string
//        }
//        public static bool ValidateXlast( uint titleID )
//        {
//              //get xlast string
//              //extract xdkVersion information
//              //call function above 
//        }

        //finds the GAME_MODE context... used in several places, so I've refactored into it's own function
        public static int FindGameModeContext( Context[] context )
        {
            int gameModeContext = -1;

            //task: find constants for these "magic values"
            //loop through to find the one where Context.id = 0x0000800B or friendlyname = "GAME_MODE"
            for( int iLoop = 0; iLoop < context.Length; iLoop++ )
            {
                if (
                    ( context[ iLoop ].id == "0x0000800B" ) &&
                    ( context[ iLoop ].friendlyName == "GAME_MODE" )
                    )
                {
                    gameModeContext = iLoop;
                    break;
                }
            }

            return gameModeContext;
        }

        public static XboxLiveSubmissionProject GetXlastFromXml( string xlastXml )
        {
            XmlTextReader xmlReader = new XmlTextReader( new StringReader( xlastXml ) );
            XmlSerializer serializer = new XmlSerializer( typeof( XboxLiveSubmissionProject ) );
            XboxLiveSubmissionProject xlast = ( XboxLiveSubmissionProject ) serializer.Deserialize( xmlReader );
            return xlast;

        }

        public static string ToXml( XboxLiveSubmissionProject xlsp )
        {
            XmlSerializer serializer = new XmlSerializer( typeof( XboxLiveSubmissionProject ) );
            StringWriter sw = new StringWriter();
            serializer.Serialize( sw, xlsp );
            return sw.ToString();
        }

        //to get the version without having to deserialize the whole file
        public static string GetXlastVersion( string xlastXml )
        {
            //yes, copied almost verbatim from \common\config\TitleConfig.cs
            xlastXml = xlastXml.Replace("xmlns=\"http://www.xboxlive.com/xlast\"", "");
            
            XmlDocument doc = new XmlDocument();
            doc.LoadXml(xlastXml); 
            XPathNavigator root = doc.CreateNavigator();
            
            XPathNodeIterator it = root.Select("/XboxLiveSubmissionProject/GameConfigProject");
            if (it.Count == 0)
            {
                throw new ApplicationException( "Invalid game config xml. Could not find XboxLiveSubmissionProject/GameConfigProject" );
            }
            if (it.Count > 1)
            {
                // we can't handle this.. is it necessary?
                throw new ApplicationException( "Invalid game config xml found for title id. Too many GameConfigProject nodes!");
            }
            it.MoveNext();

            // grab the xlast version
            string xlastVersion = it.Current.GetAttribute("schemaVersion", "");

            if ( xlastVersion == "" )
            {
                xlastVersion = "NoSchemaVersion";
            }
            return xlastVersion;

        }

        //to get the version without having to deserialize the whole file
        public static string GetXlastTitleID( string xlastXml )
        {
            xlastXml = xlastXml.Replace("xmlns=\"http://www.xboxlive.com/xlast\"", "");
            
            XmlDocument doc = new XmlDocument();
            doc.LoadXml(xlastXml); 
            XPathNavigator root = doc.CreateNavigator();

            XPathNodeIterator it = root.Select("/XboxLiveSubmissionProject/GameConfigProject");
            if (it.Count == 0)
            {
                throw new ApplicationException( "Invalid game config xml. Could not find /XboxLiveSubmissionProject/GameConfigProject" );
            }
            if (it.Count > 1)
            {
                // we can't handle this.. is it necessary?
                throw new ApplicationException( "Invalid game config xml found for title id. Too many XboxLiveSubmissionProject/GameConfigProject nodes!");
            }
            it.MoveNext();

            // grab the xlast version
            string xlastTitleID = it.Current.GetAttribute("titleId", "");

            return xlastTitleID;

        }

        //retrieve the array of transations for the TitleName
        public static LocalizedString GetTitleNameLocalizeString( LocalizedStrings strings )
        {          

            foreach( LocalizedString ls in strings.LocalizedString )
            {
                if ( ls.id == TITLE_NAME_STRING_ID )
                    return ls;
            }

            return null;
        }

        //task: add this to the CTitleID class in the framework as a *STATIC* method and add unit tests
        public static int ConvertTitleIDString( string xmlTitleID )
        {
            //task: need to work out better cases for this:
            //- unconvertable text
            //- unlikely titleids
            //

            int titleID = 0;
            CTitleId ctitleID;
            ctitleID = new CTitleId( xmlTitleID );
            titleID = (int) ctitleID.uiTitleId;

            return titleID;
        }

    } // xlastutil

} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\ingestionutils\xlastutil\marketplaceutil.cs ===
using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Xml;
using System.Xml.Schema;
using System.Xml.Serialization;
using System.Xml.XPath;

using xonline.common.config;
using xonline.common.mgmt;


namespace xonline.common.xlastutil
{
    /// <summary>
    /// Class to make it easier to deal with marketplace config data
    /// </summary>
    public class MarketplaceUtil  
    {
        // TODO: These are duplicately defined in xlastchecker.cs and xlastutil.cs. They should 
        //  be moved to a common global include file and defined once. 
        public const int TITLE_NAME_STRING_ID = 32768;

        public const int X_IMAGEID_GAME = 32768;
        public const int X_IMAGEID_GAME_MARKETPLACE = 32772;


        public MarketplaceUtil()
        {
        }


        //
        // Ensure a given image is included in the collection
        //
        public static bool CheckImage( Images images, ulong imageID, ref StringBuilder sb )
        {
            bool foundImage = false;

            if ( ( images == null ) || ( images.Image == null ) )
            {
                foundImage = false;
            }
            else
            {
                foreach( Image image in images.Image )
                {
                    if ( image.id == imageID )
                    {
                        foundImage = true;
                        break;
                    }
                }
            }

            if ( !foundImage )
            {
                sb.AppendFormat( "\r\n\r\nThe Xlast document is required to contain image ID {0}, but it was not found.", imageID );
                foundImage = false;
            }

            return foundImage;
        }

        //
        // Ensure a given string is included in the collection
        //
        public static bool CheckString( LocalizedStrings strings, int stringID, ref StringBuilder sb )
        {
            bool foundString = false;

            if ( ( strings == null ) || ( strings.LocalizedString == null ) )
            {
                foundString = false;
            }
            else
            {
                foreach( LocalizedString str in strings.LocalizedString )
                {
                    if ( str.id == stringID )
                    {
                        foundString = true;
                        break;
                    }
                }
            }

            if ( !foundString )
            {
                sb.AppendFormat( "\r\n\r\nThe Xlast document is required to contain string ID {0}, but it was not found.", stringID );
                foundString = false;
            }

            return foundString;
        }


        //
        // This method performs extended consistency checks on the data provided. 
        //  It is assumed that the schema checks have passed if this method is being
        //  called. We check for existence of required elements, etc. 
        //
        public static bool CheckMarketplaceConfig(XboxLiveSubmissionProject xlsp, ref StringBuilder validationInfo)
        {
            bool validConfig = false;
            validationInfo.Append( "Starting Validation\n" );

            // Make sure we have valid parameters
            if ( (xlsp == null) || (validationInfo == null) )
            {
                validationInfo.Append( "Invalid (null) Parameters passed.\n" );
                goto Exit;
            }

            if (xlsp.GameConfigProject != null)
            {
                validationInfo.Append( "GameConfigProject passed is not null\n" );
                goto Exit;
            }

            if (xlsp.MarketplaceConfigProject == null)
            {
                validationInfo.Append( "MarketplaceConfigProject is null\n" );
                goto Exit;
            }

            MarketplaceConfigProject mcp = xlsp.MarketplaceConfigProject;
            validConfig = true;

            //
            // In the spirit of XSD validation, check everything we can check and report all the results together. 
            //

            // Titlename strings must exist
            if (!CheckString(mcp.LocalizedStrings, TITLE_NAME_STRING_ID, ref validationInfo))
            {
                validationInfo.Append( "MarketplaceConfigProject is missing localized titlename strings\n" );
                validConfig = false;
            }

            // Strings referenced in ProductInformation must exist
            if (!CheckString(mcp.LocalizedStrings, mcp.ProductInformation.sellTextStringId, ref validationInfo))
            {
                validationInfo.Append( "MarketplaceConfigProject is missing required X_IMAGEID_GAME image\n" );
                validConfig = false;
            }
            if (!CheckString(mcp.LocalizedStrings, mcp.ProductInformation.publisherStringId, ref validationInfo))
            {
                validationInfo.Append( "MarketplaceConfigProject is missing required X_IMAGEID_GAME image\n" );
                validConfig = false;
            }
            if (!CheckString(mcp.LocalizedStrings, mcp.ProductInformation.developerStringId, ref validationInfo))
            {
                validationInfo.Append( "MarketplaceConfigProject is missing required X_IMAGEID_GAME image\n" );
                validConfig = false;
            }
            if (!CheckString(mcp.LocalizedStrings, mcp.ProductInformation.genreTextStringId, ref validationInfo))
            {
                validationInfo.Append( "MarketplaceConfigProject is missing required X_IMAGEID_GAME image\n" );
                validConfig = false;
            }            
            
            if (!CheckImage(mcp.Images, X_IMAGEID_GAME, ref validationInfo))
            {
                validationInfo.Append( "MarketplaceConfigProject is missing required X_IMAGEID_GAME image\n" );
                validConfig = false;
            }            
            
            if (!CheckImage(mcp.Images, X_IMAGEID_GAME_MARKETPLACE, ref validationInfo))
            {
                validationInfo.Append( "MarketplaceConfigProject is missing required X_IMAGEID_GAME_MARKETPLACE image\n" );
                validConfig = false;
            }            
            
Exit:
            return validConfig;
        }
       

        //
        // This method performs basic schema validation of the config file against
        //  the XSD stored in NPDB. 
        //
        public static bool ValidateMarketplaceConfig( string marketplaceXml, string schemaXml )
        {
            StringReader schemaStream = new StringReader(schemaXml);
            StringReader xmlStream = new StringReader(marketplaceXml);

            XmlReaderSettings xmlReaderSettings;
            XmlTextReader schemaReader;

            schemaReader = new XmlTextReader(schemaStream);
            xmlReaderSettings = new XmlReaderSettings();

            xmlReaderSettings.Schemas.Add("http://www.xboxlive.com/xlast", schemaReader);
            xmlReaderSettings.ValidationType = ValidationType.Schema;
            XmlReader xmlReader = XmlReader.Create(xmlStream, xmlReaderSettings);

            bool validXml = false;
            Xom.Trace(XomAreaName.xlastutil, LogLevel.L_INFO, "VALIDATING Marketplace configuration against XML Schema");
            try
            {
                while (xmlReader.Read()) ;
                validXml = true;
            }
            catch (Exception e)
            {
                Xom.Trace(XomAreaName.xlastutil, LogLevel.L_INFO, "INVALID Marketplace configuration document. Exception: " + e.ToString());
            }
            return validXml;
        }
            
    } // marketplaceutil

} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\ingestionutils\xlastutil\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__xlastutil_2_none_12.4.56.0_none_c65343eb9a790cde
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__xlastutil_2_no-public-key_12.4.56.0_x-ww_a9aefbba
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_xlastutil_2
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__xlastutil_2_no-public-key_12.4.56.0_x-ww_a9aefbba
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__xlastutil_2_no-public-key_12.4.56.0_x-ww_a9aefbba.manifest
XP_MANIFEST_PATH=manifests\x86__xlastutil_2_no-public-key_12.4.56.0_x-ww_a9aefbba.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__xlastutil_2_no-public-key_12.4.56.0_x-ww_a9aefbba.cat
XP_CATALOG_PATH=manifests\x86__xlastutil_2_no-public-key_12.4.56.0_x-ww_a9aefbba.cat
XP_PAYLOAD_PATH=x86__xlastutil_2_no-public-key_12.4.56.0_x-ww_a9aefbba
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_xlastutil_2,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\ingestionutils\xlastutil\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__xlastutil_2_none_12.4.56.0_none_c65343eb9a790cde
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__xlastutil_2_no-public-key_12.4.56.0_x-ww_a9aefbba
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_xlastutil_2
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__xlastutil_2_no-public-key_12.4.56.0_x-ww_a9aefbba
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__xlastutil_2_no-public-key_12.4.56.0_x-ww_a9aefbba.manifest
XP_MANIFEST_PATH=manifests\x86__xlastutil_2_no-public-key_12.4.56.0_x-ww_a9aefbba.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__xlastutil_2_no-public-key_12.4.56.0_x-ww_a9aefbba.cat
XP_CATALOG_PATH=manifests\x86__xlastutil_2_no-public-key_12.4.56.0_x-ww_a9aefbba.cat
XP_PAYLOAD_PATH=x86__xlastutil_2_no-public-key_12.4.56.0_x-ww_a9aefbba
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_xlastutil_2,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\leaderboard\dll\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\ingestionutils\xlastutil\gi.cs ===
// 
//    C# representation of GI configuration files.. This class structure is used by both XLAST and MARKETPLACE 
//     config files to deserialize XML into useable classes. Edit with care. 
//
namespace xonline.common.xlastutil {
    using System.Xml.Serialization;
    
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
    [System.Xml.Serialization.XmlRootAttribute(Namespace="http://www.xboxlive.com/xlast", IsNullable=false)]
    public class XboxLiveSubmissionProject {
        
        /// <remarks/>
        public GameConfigProject GameConfigProject;
        
        /// <remarks/>
        public MarketplaceConfigProject MarketplaceConfigProject;

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string Version;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
    public class GameConfigProject {
        
        /// <remarks/>
        public LocalizedStrings LocalizedStrings;

        /// <remarks/>
        public Privilege[] Privileges;
        
        /// <remarks/>
        public LiveGameModes GameModes;
        
        /// <remarks/>
        public Contexts Contexts;
        
        /// <remarks/>
        public Images Images;
        
        /// <remarks/>
        public Achievements Achievements;

        /// <remarks/>
        public AvatarItems AvatarItems;
        
        /// <remarks/>
        public XboxLiveSubmissionProjectGameConfigProjectProperties Properties;
        
        /// <remarks/>
        public XboxLiveSubmissionProjectGameConfigProjectPresence Presence;
        
        /// <remarks/>
        public StatsViews StatsViews;

        /// <summary>
        /// Used to store the information about Mobile and Web leaderboards.
        /// </summary>
        public FriendStatsViews FriendStatsViews;

        /// <remarks/>
        public XboxLiveSubmissionProjectGameConfigProjectMatchmaking Matchmaking;
        
        /// <remarks/>
        public ProductInformation ProductInformation;
        
        /// <remarks/>
        public GamerPictures GamerPictures;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string clsid;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string titleId;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string titleName;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt64 titleType;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool titleTypeSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string multiplayer;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string name;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string projectVersion;

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string schemaVersion;

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string classification;

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string arn;
    }

    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
    public class MarketplaceConfigProject {
        
        /// <remarks/>
        public LocalizedStrings LocalizedStrings;
        
        /// <remarks/>
        public Images Images;
        
        /// <remarks/>
        public ProductInformation ProductInformation;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string clsid;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string titleId;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string titleName;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt64 titleType;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool titleTypeSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string multiplayer;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string name;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string projectVersion;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
    public class LocalizedStrings {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("SupportedLocale")]
        public SupportedLocale[] SupportedLocale;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("LocalizedString")]
        public LocalizedString[] LocalizedString;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string clsid;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt16 nextId;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool nextIdSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string defaultLocale;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
    public class SupportedLocale
    {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string locale;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
    public class LocalizedString {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("Translation")]
        public Translation[] Translation;
        
        /// <remarks/>
        public object Presence;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string clsid;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string friendlyName;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt16 id;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool idSpecified;
    }

    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
    public class Translation {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string locale;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlTextAttribute()]
        public string Value;
    }


    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.xboxlive.com/xlast")]
    public class Privilege
    {
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string name;
    }

    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
    public class Picture
    {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string friendlyName;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt64 id;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool idSpecified;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
    public class GamerPictures
    {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("Picture")]
        public Picture[] Picture;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string clsid;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
    public class Feature
    {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string name;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public bool enabled = true;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.xboxlive.com/xlast")]
    public class Platform
    {

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string name;

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public byte id;
    }

    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
    public class Genre
    {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt32 genreId;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool genreIdSpecified;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
    public class HdtvMode
    {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt32 hdtvSystemId;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool hdtvSystemIdSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt32 hdtvId;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool hdtvIdSpecified;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
    public class Rating
    {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt32 ratingSystemId;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool ratingSystemIdSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt32 ratingId;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool ratingIdSpecified;
    }

    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
    public class ProductInformation
    {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("Rating")]
        public Rating[] Rating;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("HdtvMode")]
        public HdtvMode[] HdtvMode;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("Genre")]
        public Genre[] Genre;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("Feature")]
        public Feature[] Feature;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("Platform")]
        public Platform[] Platform;

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string creatorContributorId;

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt16 offlinePlayersMax;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool offlinePlayersMaxSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt16 systemLinkPlayersMax;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool systemLinkPlayersMaxSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt16 livePlayersMax;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool livePlayersMaxSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt16 shortDescriptionStringId;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool shortDescriptionStringIdSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt16 sellTextStringId;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool sellTextStringIdSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt16 publisherStringId;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool publisherStringIdSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt16 developerStringId;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool developerStringIdSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt16 genreTextStringId;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool genreTextStringIdSpecified;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
    public class XboxLiveSubmissionProjectGameConfigProjectMatchmakingQueriesQueryReturn {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string id;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public XboxLiveSubmissionProjectGameConfigProjectMatchmakingQueriesQueryReturnType type;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool typeSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt16 ordinal;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool ordinalSpecified;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
    public enum XboxLiveSubmissionProjectGameConfigProjectMatchmakingQueriesQueryReturnType {
        
        /// <remarks/>
        Normal,
        
        /// <remarks/>
        Average,
        
        /// <remarks/>
        Sum,
        
        /// <remarks/>
        Minimum,
        
        /// <remarks/>
        Maximum,
        
        /// <remarks/>
        Count,
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
    public class XboxLiveSubmissionProjectGameConfigProjectMatchmakingQueriesQuerySortOperation {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string id;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt16 ordinal;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool ordinalSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public XboxLiveSubmissionProjectGameConfigProjectMatchmakingQueriesQuerySortOperationType type;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool typeSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string distanceid;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
    public enum XboxLiveSubmissionProjectGameConfigProjectMatchmakingQueriesQuerySortOperationType {
        
        /// <remarks/>
        Ascending,
        
        /// <remarks/>
        Descending,
        
        /// <remarks/>
        Near,
        
        /// <remarks/>
        Far,
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
    public class XboxLiveSubmissionProjectGameConfigProjectMatchmakingQueriesQueryFilter {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string left;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public MatchFilterItemType leftType;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool leftTypeSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string op;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string right;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public MatchFilterItemType rightType;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool rightTypeSpecified;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
    public enum MatchFilterItemType {
        
        /// <remarks/>
        Attribute,
        
        /// <remarks/>
        Parameter,
        
        /// <remarks/>
        Constant,
        
        /// <remarks/>
        ContextValue,
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
    public class XboxLiveSubmissionProjectGameConfigProjectMatchmakingQueriesQueryParameter {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string id;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
    public class XboxLiveSubmissionProjectGameConfigProjectMatchmakingQueriesQuery {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute("Parameter", IsNullable=false)]
        public XboxLiveSubmissionProjectGameConfigProjectMatchmakingQueriesQueryParameter[] Parameters;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute("Filter", IsNullable=false)]
        public XboxLiveSubmissionProjectGameConfigProjectMatchmakingQueriesQueryFilter[] Filters;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute("SortOperation", IsNullable=false)]
        public XboxLiveSubmissionProjectGameConfigProjectMatchmakingQueriesQuerySortOperation[] SortOperations;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute("Return", IsNullable=false)]
        public XboxLiveSubmissionProjectGameConfigProjectMatchmakingQueriesQueryReturn[] Returns;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string clsid;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt64 id;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool idSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string friendlyName;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt16 maxResults;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool maxResultsSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public XboxLiveSubmissionProjectGameConfigProjectMatchmakingQueriesQueryType type;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool typeSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public bool qosProbe;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool qosProbeSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string groupBy;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
    public enum XboxLiveSubmissionProjectGameConfigProjectMatchmakingQueriesQueryType {
        
        /// <remarks/>
        Normal,
        
        /// <remarks/>
        Findfromid,
        
        /// <remarks/>
        Aggregate,
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
    public class XboxLiveSubmissionProjectGameConfigProjectMatchmakingQueries {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("Query")]
        public XboxLiveSubmissionProjectGameConfigProjectMatchmakingQueriesQuery[] Query;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string clsid;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt64 nextId;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool nextIdSpecified;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
    public class XboxLiveSubmissionProjectGameConfigProjectMatchmakingConstantsConstant {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string name;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string id;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string value;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
    public class XboxLiveSubmissionProjectGameConfigProjectMatchmakingConstants {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("Constant")]
        public XboxLiveSubmissionProjectGameConfigProjectMatchmakingConstantsConstant[] Constant;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string clsid;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt64 nextId;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool nextIdSpecified;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
    public class XboxLiveSubmissionProjectGameConfigProjectMatchmakingSchemaAttribute {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string id;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
    public class XboxLiveSubmissionProjectGameConfigProjectMatchmakingSchema {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("Attribute")]
        public XboxLiveSubmissionProjectGameConfigProjectMatchmakingSchemaAttribute[] Attribute;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string clsid;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
    public class XboxLiveSubmissionProjectGameConfigProjectMatchmaking {
        
        /// <remarks/>
        public XboxLiveSubmissionProjectGameConfigProjectMatchmakingSchema Schema;
        
        /// <remarks/>
        public XboxLiveSubmissionProjectGameConfigProjectMatchmakingConstants Constants;
        
        /// <remarks/>
        public XboxLiveSubmissionProjectGameConfigProjectMatchmakingQueries Queries;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string clsid;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public bool isV1Title = false;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
    public class StatsView {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute("Field", IsNullable=false)]
        public ViewFieldType[] Columns;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string friendlyName;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string clsid;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt64 id;

        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool idSpecified;

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string platformVisible;

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt16 platformVisibleRatingAttributeId;

        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool platformVisibleRatingAttributeIdSpecified;

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public ResetType resetType;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool resetTypeSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt16 stringId;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool stringIdSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt16 entryExpiration;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool entryExpirationSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt64 topEntries;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool topEntriesSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public bool arbitrated;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool arbitratedSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public bool hidden;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool hiddenSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt16 maxAttachments;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool maxAttachmentsSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public bool onlineOnly;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool onlineOnlySpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public bool flipAxes;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool flipAxesSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string viewType;
    }

    /// <summary>
    /// Used to capture the specifications of Mobile and Web leaderboard stats.
    /// </summary>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.xboxlive.com/xlast")]
    public class FriendStatsView
    {
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt64 id;
       
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool idSpecified;

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string platformVisible;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string friendlyName;

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string bestOutcomeSortOrder;

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string bestOutcome;

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt16 stringId;

        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool stringIdSpecified;
    }

    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
    public class ViewFieldType {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("Context", typeof(ContextFieldType))]
        [System.Xml.Serialization.XmlElementAttribute("Property", typeof(PropertyFieldType))]
        public object Item;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt16 attributeId;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool attributeIdSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string friendlyName;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public bool hidden;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool hiddenSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt16 stringId;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool stringIdSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt16 ordinal;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool ordinalSpecified;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
    public class ContextFieldType {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt64 id;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool idSpecified;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
    public class PropertyFieldType {
        
        /// <remarks/>
        public PropertyFieldTypeAggregation Aggregation;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string id;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
    public class PropertyFieldTypeAggregation {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public PropertyFieldTypeAggregationType type;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool typeSpecified;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
    public enum PropertyFieldTypeAggregationType {
        
        /// <remarks/>
        Min,
        
        /// <remarks/>
        Max,
        
        /// <remarks/>
        Sum,
        
        /// <remarks/>
        Last,
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
    public enum ResetType {
        
        /// <remarks/>
        Weekly,
        
        /// <remarks/>
        Biweekly,
        
        /// <remarks/>
        Monthly,
        
        /// <remarks/>
        Bimonthly,
        
        /// <remarks/>
        Annually,
        
        /// <remarks/>
        Never,
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
    public class StatsViews {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("StatsView")]
        public StatsView[] StatsView;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string clsid;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt64 nextViewId;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool nextViewIdSpecified;
    }

    /// <summary>
    /// Contains all the Mobile and Web leaderboard specifications.
    /// </summary>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.xboxlive.com/xlast")]
    public class FriendStatsViews
    {
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("FriendStatsView")]
        public FriendStatsView[] FriendStatsView;
    }

    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
    public class XboxLiveSubmissionProjectGameConfigProjectPresencePresenceMode {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string clsid;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt16 contextValue;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool contextValueSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt16 stringId;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool stringIdSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string friendlyName;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
    public class XboxLiveSubmissionProjectGameConfigProjectPresence {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("PresenceMode")]
        public XboxLiveSubmissionProjectGameConfigProjectPresencePresenceMode[] PresenceMode;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string clsid;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt16 nextContextValue;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool nextContextValueSpecified;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
    public class XboxLiveSubmissionProjectGameConfigProjectPropertiesPropertyFormat
    {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        [System.ComponentModel.DefaultValueAttribute(typeof(System.Byte), "0")]
        public System.Byte decimals = ((System.Byte)(0));
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        [System.ComponentModel.DefaultValueAttribute(false)]
        public bool year = false;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        [System.ComponentModel.DefaultValueAttribute(false)]
        public bool month = false;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        [System.ComponentModel.DefaultValueAttribute(false)]
        public bool day = false;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        [System.ComponentModel.DefaultValueAttribute(false)]
        public bool hours = false;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        [System.ComponentModel.DefaultValueAttribute(false)]
        public bool minutes = false;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        [System.ComponentModel.DefaultValueAttribute(false)]
        public bool seconds = false;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        [System.ComponentModel.DefaultValueAttribute(false)]
        public bool milliseconds = false;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
    public class XboxLiveSubmissionProjectGameConfigProjectPropertiesProperty {
        
        /// <remarks/>
        public object DefaultValue;
        
        /// <remarks/>
        public XboxLiveSubmissionProjectGameConfigProjectPropertiesPropertyFormat Format;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string clsid;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt16 dataSize;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool dataSizeSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string id;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string friendlyName;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt16 stringId;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool stringIdSpecified;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
    public class XboxLiveSubmissionProjectGameConfigProjectProperties {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("Property")]
        public XboxLiveSubmissionProjectGameConfigProjectPropertiesProperty[] Property;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string clsid;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt16 nextId;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool nextIdSpecified;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
    public class XboxLiveSubmissionProjectGameConfigProjectAchievementsAchievement {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public XboxLiveSubmissionProjectGameConfigProjectAchievementsAchievementAchievementType achievementType;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool achievementTypeSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string clsid;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt16 descriptionStringId;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool descriptionStringIdSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string friendlyName;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt16 id;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool idSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt64 imageId;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool imageIdSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public bool showUnachieved = true;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt16 titleStringId;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool titleStringIdSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt16 unachievedStringId;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool unachievedStringIdSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt16 webDescriptionStringId;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool webDescriptionStringIdSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt16 cred;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool credSpecified;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
    public enum XboxLiveSubmissionProjectGameConfigProjectAchievementsAchievementAchievementType {
        
        /// <remarks/>
        Completion,
        
        /// <remarks/>
        Leveling,
        
        /// <remarks/>
        Unlock,
        
        /// <remarks/>
        Event,
        
        /// <remarks/>
        Tournament,
        
        /// <remarks/>
        Checkpoint,
        
        /// <remarks/>
        Other,
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
    public class Achievements {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("Achievement")]
        public XboxLiveSubmissionProjectGameConfigProjectAchievementsAchievement[] Achievement;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string clsid;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt16 nextId;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool nextIdSpecified;
    }

    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://www.xboxlive.com/xlast")]
    public class XboxLiveSubmissionProjectGameConfigProjectAvatarItemsAvatarItem
    {
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public string clsid;

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string friendlyName;

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt16 id;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt16 descriptionStringId;

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public bool showUnachieved;

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt16 unachievedStringId;

        #region gender 1

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.Guid guid1;

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt64 imageId1;

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt16 displayStringId1;

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt32 subCategory1;

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.String binLocation1;

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.String imageMedLocation1;

        #endregion

        #region gender 2

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.Guid guid2;

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt64 imageId2;

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt16 displayStringId2;

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt32 subCategory2;

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.String binLocation2;

        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.String imageMedLocation2;

        #endregion

    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
    public class AvatarItems
    {
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("AvatarItem")]
        public XboxLiveSubmissionProjectGameConfigProjectAvatarItemsAvatarItem[] AvatarItem;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string clsid;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
    public class Image
    {
        
        /// <remarks/>
        public string Path;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string friendlyName;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt64 id;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool idSpecified;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
    public class Images
    {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("Image")]
        public Image[] Image;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string clsid;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
    public class ContextValue {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute("value")]
        public System.UInt16 contextValue;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool valueSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt16 stringId;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool stringIdSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string friendlyName;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
    public class Context {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("ContextValue")]
        public ContextValue[] ContextValue;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string clsid;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt16 defaultValue;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool defaultValueSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string friendlyName;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string id;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt16 stringId;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool stringIdSpecified;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
    public class Contexts {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("Context")]
        public Context[] Context;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string clsid;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string nextId;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(TypeName = "GameMode", Namespace="http://www.xboxlive.com/xlast")]
    public class LiveGameMode
    {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute("value")]
        public System.UInt16 Value;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool valueSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt16 stringId;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool stringIdSpecified;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string friendlyName;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.Byte drawProbability;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool drawProbabilitySpecified;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(TypeName = "GameModes", Namespace="http://www.xboxlive.com/xlast")]
    public class LiveGameModes
    {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute("GameMode")]
        public LiveGameMode[] GameMode;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public string clsid;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAttributeAttribute()]
        public System.UInt16 defaultValue;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool defaultValueSpecified;
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://www.xboxlive.com/xlast")]
    public class NonValidatedElement {
        
        /// <remarks/>
        [System.Xml.Serialization.XmlAnyElementAttribute()]
        public System.Xml.XmlElement[] Any;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\inhbase\dll\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\leaderboard\dll\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\leaderboard\dll\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\ingestionutils\xlastutil\MobileAndWebLeaderboardUtils.cs ===
﻿// <copyright file="MobileAndWebLeaderboardUtils.cs" company="Microsoft">Copyright (c) 2011 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2011-04-26</date>
// <summary>Contains the utilities required for converting mobile/web leaderboards to console format.</summary>

namespace xonline.common.xlastutil
{
    using System;
    using System.Collections.Generic;
    using System.Xml;
    using System.Xml.XPath;

    // attributeId values that are used by XBL Leaderboards
    public static class ColumnAttributeId
    {
        // Column IDs
        public readonly static ushort Gamertag = 65535;       // Column AttributeID for Gamertag
        public readonly static ushort Rating = 65534;         // Column AttributeID for Rating
        public readonly static ushort Rank = 65533;           // Column AttributeID for Rank
    }

    /// <summary>
    /// The columns which are to be used for rating the leaderboard stats.
    /// </summary>
    public enum MobileAndWebRatingColumn : uint
    {
        /// <summary>
        /// Best score is the column to be used for rating.
        /// </summary>
        BestScore = 0,

        /// <summary>
        /// Best time is the column to be used for rating.
        /// </summary>
        BestTime = 1,

        /// <summary>
        /// Number of wins is the column to be used for rating.
        /// </summary>
        MostWins = 2
    }

    /// <summary>
    /// The leaderboard types supported for mobile and web titles.
    /// </summary>
    public enum MobileAndWebLeaderboardType : uint
    {
        /// <summary>
        /// Lifetime leaderboards - these are not reset.
        /// </summary>
        Lifetime = 0,

        /// <summary>
        /// Weekly leaderboards - these are reset each week.
        /// </summary>
        Weekly = 1
    }

    /// <summary>
    /// Whether the best outcome is determined by ascending or descending order.
    /// </summary>
    public enum BestOutcomeSortOrder
    {
        /// <summary>
        /// The order of sorting is ascending.
        /// </summary>
        Ascending,

        /// <summary>
        /// The order of sorting is descending.
        /// </summary>
        Descending
    }

    /// <summary>
    /// This class provides utilities for ingestion of mobile and web titles.
    /// </summary>
    public class MobileAndWebLeaderboardUtils
    {
        /// <summary>
        /// Contains the mapping from a mobile leaderboard column to its essential data.
        /// </summary>
        public static readonly Dictionary<MobileStatsColumns, MobileColumnData> MobileColData;

        /// <summary>
        /// The default locale to populate for localized strings.
        /// </summary>
        public const string DefaultLocale = "en-US";

        /// <summary>
        /// The file name that has the localized column data.
        /// </summary>
        public const string ColLocalizationDataFile = "MobileStatsColumnsLocalized.xml";

        /// <summary>
        /// The format used for the key in the column localization data dictionary.
        /// </summary>
        public const string ColLocalizationDataKeyFormat = "{0}:{1}";

        /// <summary>
        /// Initializes static members of the MobileAndWebLeaderboardUtils class.
        /// </summary>
        static MobileAndWebLeaderboardUtils()
        {
            MobileColData = new Dictionary<MobileStatsColumns, MobileColumnData>();

            // Add the data for all the mobile leaderboard stats columns.
            MobileColData.Add(
                MobileStatsColumns.GamerName,
                new MobileColumnData() { Name = "Gamer Name", AttributeId = ColumnAttributeId.Rank, Aggregation = PropertyFieldTypeAggregationType.Last, PropertyId = "0x40008002", DataSize = 0, StringId = 32515 });

            // We don't use all the data from this, we use the data from the base column.
            MobileColData.Add(
                MobileStatsColumns.Rating,
                new MobileColumnData() { Name = "Rating", AttributeId = ColumnAttributeId.Rating, Aggregation = PropertyFieldTypeAggregationType.Max, PropertyId = "0x50008104", DataSize = 4, StringId = 32522 });

            MobileColData.Add(
                MobileStatsColumns.Rank,
                new MobileColumnData() { Name = "Rank", AttributeId = ColumnAttributeId.Gamertag, Aggregation = PropertyFieldTypeAggregationType.Last, PropertyId = "0x10008001", DataSize = 4, StringId = 32517 });

            MobileColData.Add(
                MobileStatsColumns.BestScore,
                new MobileColumnData() { Name = "BestScore", AttributeId = 1, Aggregation = PropertyFieldTypeAggregationType.Max, PropertyId = "0x20000001", DataSize = 8, StringId = 33001 });

            MobileColData.Add(
                MobileStatsColumns.BestTime,
                new MobileColumnData() { Name = "BestTime", AttributeId = 2, Aggregation = PropertyFieldTypeAggregationType.Max, PropertyId = "0x20000002", DataSize = 8, StringId = 33002 });

            MobileColData.Add(
                MobileStatsColumns.GamesPlayed,
                new MobileColumnData() { Name = "GamesPlayed", AttributeId = 3, Aggregation = PropertyFieldTypeAggregationType.Sum, PropertyId = "0x20000003", DataSize = 8, StringId = 33003 });

            MobileColData.Add(
                MobileStatsColumns.LastPlayedDateTime,
                new MobileColumnData() { Name = "LastPlayedDateTime", AttributeId = 4, Aggregation = PropertyFieldTypeAggregationType.Last, PropertyId = "0x20000004", DataSize = 8, StringId = 33004 });

            MobileColData.Add(
                MobileStatsColumns.Wins,
                new MobileColumnData() { Name = "Wins", AttributeId = 5, Aggregation = PropertyFieldTypeAggregationType.Sum, PropertyId = "0x20000005", DataSize = 8, StringId = 33005 });

            MobileColData.Add(
                MobileStatsColumns.CumulativeScore,
                new MobileColumnData() { Name = "CumulativeScore", AttributeId = 6, Aggregation = PropertyFieldTypeAggregationType.Sum, PropertyId = "0x20000006", DataSize = 8, StringId = 33006 });

            MobileColData.Add(
                MobileStatsColumns.CumulativeTime,
                new MobileColumnData() { Name = "CumulativeTime", AttributeId = 7, Aggregation = PropertyFieldTypeAggregationType.Sum, PropertyId = "0x20000007", DataSize = 8, StringId = 33007 });

            MobileColData.Add(
                MobileStatsColumns.Losses,
                new MobileColumnData() { Name = "Losses", AttributeId = 8, Aggregation = PropertyFieldTypeAggregationType.Sum, PropertyId = "0x20000008", DataSize = 8, StringId = 33008 });
        }

        /// <summary>
        /// Tabulates all the columns for mobile/web leaderboards.
        /// </summary>
        public enum MobileStatsColumns
        {
            /// <summary>
            /// The gamer name column.
            /// </summary>
            GamerName,

            /// <summary>
            /// The rating column.
            /// </summary>
            Rating,

            /// <summary>
            /// The rank column.
            /// </summary>
            Rank,

            /// <summary>
            /// The best score achieved column.
            /// </summary>
            BestScore,

            /// <summary>
            /// The best time achieved column.
            /// </summary>
            BestTime,

            /// <summary>
            /// The number of games played column.
            /// </summary>
            GamesPlayed,

            /// <summary>
            /// The last played date time for the title.
            /// </summary>
            LastPlayedDateTime,

            /// <summary>
            /// The number of wins column.
            /// </summary>
            Wins,

            /// <summary>
            /// The culumative score column.
            /// </summary>
            CumulativeScore,

            /// <summary>
            /// The culumative time column.
            /// </summary>
            CumulativeTime,

            /// <summary>
            /// The number of losses column.
            /// </summary>
            Losses
        }

        /// <summary>
        /// Gets the leaderboardId based on the game variant, rating column and leaderboard type.
        /// </summary>
        /// <param name="gameVariant">The game variant for which to get the leaderboard.</param>
        /// <param name="ratingColumn">The column which should be used to specify the rating.</param>
        /// <param name="leaderboardType">The type of leaderboard.</param>
        /// <returns>The leaderboardId based on the inputs.</returns>
        public static int GetLeaderboardId(uint gameVariant, MobileAndWebRatingColumn ratingColumn, MobileAndWebLeaderboardType leaderboardType)
        {
            // LeaderboardId format:
            // reserved for matchmaking leaderboards - 1 bit (most significant bit)
            // gameVariant - 27 bits
            // ratingColumn - 3 bits
            // leaderboardType - 1 bit (least significant bit)
            const uint MaxVariantValue = 0x07FFFFFF;
            if (gameVariant > MaxVariantValue)
            {
                throw new ArgumentOutOfRangeException("gameVariant", gameVariant, "Game variant value cannot be greater than " + MaxVariantValue);
            }

            return (int)(((gameVariant << 4) & 0x7FFFFFF0) |
                        (((uint)ratingColumn << 1) & 0x0000000E) |
                        ((uint)leaderboardType & 0x00000001));
        }

        /// <summary>
        /// Gets the data dictionary with the localized column names.
        /// </summary>
        /// <param name="configFilePath">The path of the config file with the localization data.</param>
        /// <returns>The data dictionary with the localized column names.</returns>
        public static Dictionary<string, string> GetLocalizationDataDictionary(string configFilePath)
        {
            Dictionary<string, string> localizationData = new Dictionary<string, string>();

            XmlDocument doc = new XmlDocument();

            try
            {
                doc.Load(configFilePath);
                XPathNodeIterator iterator = doc.CreateNavigator().Select("//MobileStatsColumnsLocalized//Entry");

                foreach (XPathNavigator node in iterator)
                {
                    string column = node.SelectSingleNode("@Column").Value;
                    string locale = node.SelectSingleNode("@Locale").Value;
                    string value = node.SelectSingleNode("@Value").Value;
                    string key = string.Format(ColLocalizationDataKeyFormat, locale, column);
                    localizationData.Add(key, value);
                }
            }
            catch (Exception ex)
            {
                throw new ApplicationException("Error while trying to load and parse the mobile column localization data file.", ex);
            }

            return localizationData;
        }

        /// <summary>
        /// Is the Xbox Live Submission Project for a mobile title?
        /// </summary>
        /// <param name="xlsp">The Xbox Live Submission Project to be queried.</param>
        /// <returns>True if the Xbox Live Submission Project is for a mobile title</returns>
        public static bool IsMobileTitle(XboxLiveSubmissionProject xlsp)
        {
            bool isMobileTitle;

            if ((xlsp.GameConfigProject.FriendStatsViews != null) &&
                (xlsp.GameConfigProject.FriendStatsViews.FriendStatsView != null) &&
                (xlsp.GameConfigProject.FriendStatsViews.FriendStatsView.Length > 0))
            {
                isMobileTitle = true;
            }
            else
            {
                isMobileTitle = false;
            }

            return isMobileTitle;
        }

        /// <summary>
        /// Converts the mobile leaderboards to general XBL format.
        /// This method basically converts FriendStatsViews objects to equivalent StatsViews.
        /// </summary>
        /// <param name="xlsp">The mobile Xbox Live Submission Project to be converted to general format.</param>
        /// <param name="colLocalizationData">Contains the mapping from a key (locale + column) to localized column name.</param>
        public static void ConvertMobileLeaderboardsToGeneralFormat(XboxLiveSubmissionProject xlsp, Dictionary<string, string> colLocalizationData)
        {
            List<StatsView> convertedStatsViews = new List<StatsView>();

            // Add stats related localized strings and properties.
            AddLocalizedStringsAndProperties(xlsp, colLocalizationData);

            // Get the information about each variant's rating column sort order.
            Dictionary<ulong, Dictionary<MobileAndWebRatingColumn, BestOutcomeSortOrder>> variantRatingSortOrderDict = GetVariantRatingSortOrderDictionaries(xlsp);

            // Add stats views for each friend stats view.
            ulong nextStatsViewId = 1;
            foreach (FriendStatsView friendStatsView in xlsp.GameConfigProject.FriendStatsViews.FriendStatsView)
            {
                Dictionary<MobileAndWebRatingColumn, BestOutcomeSortOrder> ratingSortOrderDictionary = variantRatingSortOrderDict[friendStatsView.id];

                // Add lifetime stats view
                StatsView lifetimeStatsView = GetStatsViewForAFriendStatsView(friendStatsView, MobileAndWebLeaderboardType.Lifetime, ratingSortOrderDictionary);
                convertedStatsViews.Add(lifetimeStatsView);
                nextStatsViewId++;

                if (friendStatsView.platformVisible == "primary")
                {
                    friendStatsView.platformVisible = "enabled"; // only the lifetime leaderboard can be the primary (because there is only *one* primary)
                }

                // Add weekly stats view
                StatsView weeklyStatsView = GetStatsViewForAFriendStatsView(friendStatsView, MobileAndWebLeaderboardType.Weekly, ratingSortOrderDictionary);
                convertedStatsViews.Add(weeklyStatsView);
                nextStatsViewId++;
            }

            // Clear the friend stats view data.
            xlsp.GameConfigProject.FriendStatsViews = null;

            // Set the stats view data.
            xlsp.GameConfigProject.StatsViews = new StatsViews()
                                                {
                                                    nextViewId = nextStatsViewId
                                                };

            xlsp.GameConfigProject.StatsViews.StatsView = convertedStatsViews.ToArray();
        }

        /// <summary>
        /// Gets the column whose value is to be used as the value of the rating column.
        /// </summary>
        /// <param name="bestOutcome">The bestOutcome attribute of a FriendStatsView tag.</param>
        /// <returns>The column whose value is to be used as the value of the rating column.</returns>
        internal static MobileAndWebRatingColumn GetMobileAndWebRatingColumn(string bestOutcome)
        {
            MobileAndWebRatingColumn ratingColumn;
            try
            {
                ratingColumn = (MobileAndWebRatingColumn)Enum.Parse(typeof(MobileAndWebRatingColumn), bestOutcome, true);
            }
            catch (Exception ex)
            {
                throw new Exception(
                            "Exception while trying to parse the bestOutcome attribute of a FriendStatsView. This attribute is needed in the leaderboard specification of a mobile or web title.",
                            ex);
            }

            return ratingColumn;
        }

        /// <summary>
        /// Gets the column which determines whethe higher or lower values are better for rating.
        /// </summary>
        /// <param name="bestOutcomeSortOrderStr">The bestOutcomeSortOrder attribute of a FriendStatsView tag.</param>
        /// <returns>The column which determines whethe higher or lower values are better for rating.</returns>
        internal static BestOutcomeSortOrder GetBestOutcomeSortOrder(string bestOutcomeSortOrderStr)
        {
            BestOutcomeSortOrder bestOutcomeSortOrder;
            try
            {
                bestOutcomeSortOrder = (BestOutcomeSortOrder)Enum.Parse(typeof(BestOutcomeSortOrder), bestOutcomeSortOrderStr, true);
            }
            catch (Exception ex)
            {
                throw new Exception(
                            "Exception while trying to parse the bestOutcomeSortOrder attribute of a FriendStatsView. This attribute is needed in the leaderboard specification of a mobile or web title.",
                            ex);
            }

            return bestOutcomeSortOrder;
        }

        /// <summary>
        /// Get the information about each variant's rating column to sort order mappings.
        /// </summary>
        /// <param name="xlsp">The mobile Xbox Live Submission Project from which to get the variant->rating column sort order mapping.</param>
        /// <returns>The dictionary mapping a variant to a dictionary of rating columns and their sort orders.</returns>
        private static Dictionary<ulong, Dictionary<MobileAndWebRatingColumn, BestOutcomeSortOrder>> GetVariantRatingSortOrderDictionaries(XboxLiveSubmissionProject xlsp)
        {
            Dictionary<ulong, Dictionary<MobileAndWebRatingColumn, BestOutcomeSortOrder>> variantRatingSortOrderDict =
                                        new Dictionary<ulong, Dictionary<MobileAndWebRatingColumn, BestOutcomeSortOrder>>();

            foreach (FriendStatsView friendStatsView in xlsp.GameConfigProject.FriendStatsViews.FriendStatsView)
            {
                Dictionary<MobileAndWebRatingColumn, BestOutcomeSortOrder> ratingSortOrderDictionary;

                // Add the variant if it is not present in the dictionary.
                if (!variantRatingSortOrderDict.TryGetValue(friendStatsView.id, out ratingSortOrderDictionary))
                {
                    ratingSortOrderDictionary = new Dictionary<MobileAndWebRatingColumn, BestOutcomeSortOrder>();
                    variantRatingSortOrderDict.Add(friendStatsView.id, ratingSortOrderDictionary);
                }

                MobileAndWebRatingColumn ratingColumn = GetMobileAndWebRatingColumn(friendStatsView.bestOutcome);
                BestOutcomeSortOrder sortOrder = GetBestOutcomeSortOrder(friendStatsView.bestOutcomeSortOrder);
                try
                {
                    ratingSortOrderDictionary.Add(ratingColumn, sortOrder);
                }
                catch (ArgumentNullException ex)
                {
                    throw new Exception("Cannot have bestOutcome attribute as null in FriendStatsView", ex);
                }
                catch (ArgumentException ex)
                {
                    throw new Exception("Cannot have the multiple FriendStatsViews with the same bestOutcome attribute and the same id ", ex);
                }
            }

            return variantRatingSortOrderDict;
        }

        /// <summary>
        /// Get a stats view object that is equivalent to a friend stats object.
        /// </summary>
        /// <param name="friendStatsView">The object to be used as the basis for the stats view.</param>
        /// <param name="leaderboardType">The leaderboard type for the friend stats view.</param>
        /// <param name="ratingSortOrderDictionary">Mapping between rating columns and best outcome sort order.</param>
        /// <returns>A stats view object that is equivalent to a friend stats object.</returns>
        private static StatsView GetStatsViewForAFriendStatsView(
            FriendStatsView friendStatsView, MobileAndWebLeaderboardType leaderboardType, Dictionary<MobileAndWebRatingColumn, BestOutcomeSortOrder> ratingSortOrderDictionary)
        {
            MobileAndWebRatingColumn ratingColumn = MobileAndWebLeaderboardUtils.GetMobileAndWebRatingColumn(friendStatsView.bestOutcome);
            int leaderboardId = MobileAndWebLeaderboardUtils.GetLeaderboardId((uint)friendStatsView.id, ratingColumn, leaderboardType);
            ResetType resetType = (leaderboardType == MobileAndWebLeaderboardType.Lifetime) ? ResetType.Never : ResetType.Weekly;

            StatsView statsView = new StatsView()
            {
                friendlyName = friendStatsView.friendlyName,
                id = (ulong)leaderboardId,
                idSpecified = true,
                platformVisible = friendStatsView.platformVisible,
                platformVisibleRatingAttributeIdSpecified = false,
                resetType = resetType,
                resetTypeSpecified = true,
                stringId = friendStatsView.stringId,
                stringIdSpecified = friendStatsView.stringIdSpecified,
                entryExpiration = 0,
                entryExpirationSpecified = true,
                topEntries = (ulong)uint.MaxValue,
                topEntriesSpecified = true,
                arbitrated = false,
                arbitratedSpecified = true,
                hidden = false,
                hiddenSpecified = true,
                maxAttachments = ushort.MaxValue,
                maxAttachmentsSpecified = true,
                onlineOnly = false,
                onlineOnlySpecified = true,
                flipAxesSpecified = false,
                viewType = "Leaderboard"
            };

            // Add all the columns for a mobile/web title.
            Dictionary<MobileStatsColumns, MobileColumnData>.KeyCollection mobileColumns = MobileColData.Keys;
            List<ViewFieldType> statsViewColumns = new List<ViewFieldType>();
            ushort i = 0;
            BestOutcomeSortOrder friendStatsViewSortOrder = GetBestOutcomeSortOrder(friendStatsView.bestOutcomeSortOrder);
            foreach (var mobileColumn in mobileColumns)
            {
                MobileStatsColumns baseColumn;
                PropertyFieldTypeAggregationType aggregationType;
                bool isHidden = false;

                // For rating column, use the column that is used as the value of rating as the baseColumn.
                if (mobileColumn == MobileStatsColumns.Rating)
                {
                    // Hide the rating column if the sort order is ascending.
                    // This is due to the fact that clients post negative values which we want to hide.
                    if (friendStatsViewSortOrder == BestOutcomeSortOrder.Ascending)
                    {
                        isHidden = true;
                    }

                    switch (ratingColumn)
                    {
                        case MobileAndWebRatingColumn.BestScore:
                            baseColumn = MobileStatsColumns.BestScore;
                            break;

                        case MobileAndWebRatingColumn.BestTime:
                            baseColumn = MobileStatsColumns.BestTime;
                            break;

                        case MobileAndWebRatingColumn.MostWins:
                            baseColumn = MobileStatsColumns.Wins;
                            break;

                        default:
                            throw new ApplicationException("Unsupported bestOutcome found in FriendStatsView: " + friendStatsView.bestOutcome);
                    }

                    // Aggregation type is determined by the base column in case of rating.
                    aggregationType = MobileColData[baseColumn].Aggregation;

                    if (!string.IsNullOrEmpty(statsView.platformVisible))
                    {
                        if (isHidden == false)
                        {
                            statsView.platformVisibleRatingAttributeId = ColumnAttributeId.Rating;
                        }
                        else
                        {
                            statsView.platformVisibleRatingAttributeId = MobileColData[baseColumn].AttributeId;
                        }
                        statsView.platformVisibleRatingAttributeIdSpecified = true;
                    }
                }
                else
                {
                    // Skip the base column if the base column and rating column have the exact same value.
                    if (friendStatsViewSortOrder == BestOutcomeSortOrder.Descending)
                    {
                        if ((ratingColumn == MobileAndWebRatingColumn.BestScore && mobileColumn == MobileStatsColumns.BestScore) ||
                            (ratingColumn == MobileAndWebRatingColumn.BestTime && mobileColumn == MobileStatsColumns.BestTime) ||
                            (ratingColumn == MobileAndWebRatingColumn.MostWins && mobileColumn == MobileStatsColumns.Wins))
                        {
                            continue;
                        }
                    }

                    // Use the column itself as the base column.
                    baseColumn = mobileColumn;
                    aggregationType = GetColumnAggregationType(baseColumn, ratingSortOrderDictionary);
                }

                // Set all of these depending on the base column.
                string id = MobileColData[baseColumn].PropertyId;
                string friendlyName = MobileColData[baseColumn].Name;
                ushort stringId = MobileColData[baseColumn].StringId;

                ViewFieldType viewFieldType = new ViewFieldType()
                {
                    Item = new PropertyFieldType()
                    {
                        Aggregation = new PropertyFieldTypeAggregation() { type = aggregationType, typeSpecified = true },
                        id = id
                    },
                    attributeId = MobileColData[mobileColumn].AttributeId,
                    attributeIdSpecified = true,
                    friendlyName = friendlyName,
                    hidden = isHidden,
                    hiddenSpecified = true,
                    stringId = stringId,
                    stringIdSpecified = true,
                    ordinal = i,
                    ordinalSpecified = true
                };
                statsViewColumns.Add(viewFieldType);                

                i++;
            }

            statsView.Columns = statsViewColumns.ToArray();           

            return statsView;
        }

        /// <summary>
        /// Gets the aggregation type for the stats column.
        /// </summary>
        /// <param name="statsColumn">The column for which to get the aggregation type.</param>
        /// <param name="ratingSortOrderDictionary">Mapping between rating columns and best outcome sort order.</param>
        /// <returns>The aggregation type for the stats column.</returns>
        private static PropertyFieldTypeAggregationType GetColumnAggregationType(
            MobileStatsColumns statsColumn, Dictionary<MobileAndWebRatingColumn, BestOutcomeSortOrder> ratingSortOrderDictionary)
        {
            PropertyFieldTypeAggregationType aggregationType;

            PropertyFieldTypeAggregationType defaultAggregationType = MobileColData[statsColumn].Aggregation;
            switch (statsColumn)
            {
                case MobileStatsColumns.BestScore:
                    aggregationType = GetRatingAggregationType(MobileAndWebRatingColumn.BestScore, ratingSortOrderDictionary, defaultAggregationType);
                    break;
                case MobileStatsColumns.BestTime:
                    aggregationType = GetRatingAggregationType(MobileAndWebRatingColumn.BestTime, ratingSortOrderDictionary, defaultAggregationType);
                    break;
                case MobileStatsColumns.Wins:
                    aggregationType = GetRatingAggregationType(MobileAndWebRatingColumn.MostWins, ratingSortOrderDictionary, defaultAggregationType);
                    break;
                default:
                    // Use the default value if the column is not one of the above.
                    aggregationType = defaultAggregationType;
                    break;
            }

            return aggregationType;
        }

        /// <summary>
        /// Gets the aggregation type for a column that is also a rating column in one of the leaderboards.
        /// </summary>
        /// <param name="ratingColumn">A column that is also a rating column in one of the leaderboards.</param>
        /// <param name="ratingSortOrderDictionary">The mapping from a rating column to the best outcome sort order.</param>
        /// <param name="defaultAggregationType">The dedault aggregation type for the column.</param>
        /// <returns>The aggregation type for a column that is also a rating column in one of the leaderboards.</returns>
        private static PropertyFieldTypeAggregationType GetRatingAggregationType(
                                                            MobileAndWebRatingColumn ratingColumn,
                                                            Dictionary<MobileAndWebRatingColumn, BestOutcomeSortOrder> ratingSortOrderDictionary,
                                                            PropertyFieldTypeAggregationType defaultAggregationType)
        {
            PropertyFieldTypeAggregationType aggregationType;

            BestOutcomeSortOrder sortOrder;
            bool sortOrderFound = ratingSortOrderDictionary.TryGetValue(ratingColumn, out sortOrder);
            if (!sortOrderFound)
            {
                // Use the default value if no sort order is defined for the column.
                aggregationType = defaultAggregationType;
            }
            else
            {
                if (sortOrder == BestOutcomeSortOrder.Descending)
                {
                    // Use the default value if the column sort order is descending.
                    aggregationType = defaultAggregationType;
                }
                else
                {
                    // Reverse the default order in case the sort order is ascending.
                    switch (defaultAggregationType)
                    {
                        case PropertyFieldTypeAggregationType.Max:
                            aggregationType = PropertyFieldTypeAggregationType.Min;
                            break;

                        case PropertyFieldTypeAggregationType.Min:
                            aggregationType = PropertyFieldTypeAggregationType.Max;
                            break;

                        default:
                            aggregationType = defaultAggregationType;
                            break;
                    }
                }
            }

            return aggregationType;
        }

        /// <summary>
        /// Adds the LocalizedStrings and Properties to the mobile title to make it on par with a console title.
        /// </summary>
        /// <param name="xlsp">The Xbox Live Submission Project to modify.</param>
        /// <param name="colLocalizationData">Contains the mapping from a key (locale + column) to localized column name.</param>
        private static void AddLocalizedStringsAndProperties(XboxLiveSubmissionProject xlsp, Dictionary<string, string> colLocalizationData)
        {
            // Create a list for localized strings.
            LocalizedString[] localizedStringArr;

            try
            {
                localizedStringArr = xlsp.GameConfigProject.LocalizedStrings.LocalizedString;
            }
            catch (NullReferenceException ex)
            {
                throw new ApplicationException("Missing information in XboxLiveSubmissionProject.", ex);
            }

            List<LocalizedString> localizedStringList;
            if (localizedStringArr == null)
            {
                localizedStringList = new List<LocalizedString>();
            }
            else
            {
                localizedStringList = new List<LocalizedString>(localizedStringArr);
            }

            // Create a list for game config properties.
            if (xlsp.GameConfigProject.Properties == null)
            {
                xlsp.GameConfigProject.Properties = new XboxLiveSubmissionProjectGameConfigProjectProperties();
            }

            List<XboxLiveSubmissionProjectGameConfigProjectPropertiesProperty> gameConfigPropList;
            if (xlsp.GameConfigProject.Properties.Property == null)
            {
                gameConfigPropList = new List<XboxLiveSubmissionProjectGameConfigProjectPropertiesProperty>();
            }
            else
            {
                gameConfigPropList = new List<XboxLiveSubmissionProjectGameConfigProjectPropertiesProperty>(xlsp.GameConfigProject.Properties.Property);
            }

            // Add all the columns for a mobile/web title.
            Dictionary<MobileStatsColumns, MobileColumnData>.KeyCollection mobileColumns = MobileColData.Keys;
            ushort i = 1;
            string[] supportedLocales = GetAllSupportedLocales(xlsp);
            foreach (var mobileColumn in mobileColumns)
            {
                // Add the localized string.
                LocalizedString colLocalizedString = new LocalizedString()
                {
                    id = MobileColData[mobileColumn].StringId,
                    idSpecified = true,
                    friendlyName = mobileColumn.ToString()
                };

                colLocalizedString.Translation = new Translation[supportedLocales.Length];
                int index = 0;
                foreach (string supportedLocale in supportedLocales)
                {
                    colLocalizedString.Translation[index] =
                            new Translation()
                            {
                                locale = supportedLocale,
                                Value = GetLocalizedStringForColumn(mobileColumn, supportedLocale, colLocalizationData)
                            };
                    index++;
                }

                localizedStringList.Add(colLocalizedString);

                // Add the corresponding property.
                XboxLiveSubmissionProjectGameConfigProjectPropertiesProperty property = new XboxLiveSubmissionProjectGameConfigProjectPropertiesProperty()
                {
                    id = MobileColData[mobileColumn].PropertyId,
                    stringId = MobileColData[mobileColumn].StringId,
                    stringIdSpecified = true,
                    dataSize = MobileColData[mobileColumn].DataSize,
                    dataSizeSpecified = true,
                    friendlyName = mobileColumn.ToString(),
                };

                // For Gamer Name, no need to add format.
                if (mobileColumn != MobileStatsColumns.GamerName)
                {
                    // For rating show two decimal places.
                    if (mobileColumn == MobileStatsColumns.Rating)
                    {
                        property.Format = new XboxLiveSubmissionProjectGameConfigProjectPropertiesPropertyFormat()
                        {
                            decimals = 2
                        };
                    }
                    else if (mobileColumn == MobileStatsColumns.BestTime)
                    {
                        // For BestTime, all stats must be uploaded in milliseconds, so that it can be properly
                        // reflected by the new PlatformVisibleLeaderboard APIs.
                        property.Format = new XboxLiveSubmissionProjectGameConfigProjectPropertiesPropertyFormat()
                        {
                            hours = true,
                            minutes = true,
                            seconds = true,
                            milliseconds = true,
                        };
                    }
                    else
                    {
                        property.Format = new XboxLiveSubmissionProjectGameConfigProjectPropertiesPropertyFormat();
                    }
                }

                gameConfigPropList.Add(property);
                i++;
            }

            xlsp.GameConfigProject.LocalizedStrings.LocalizedString = localizedStringList.ToArray();
            xlsp.GameConfigProject.Properties.nextId = i;
            xlsp.GameConfigProject.Properties.Property = gameConfigPropList.ToArray();
        }

        /// <summary>
        /// Gets all the supported locales for a XLSP.
        /// </summary>
        /// <param name="xlsp">The XboxLiveSubmissionProject for which to get the supported locales.</param>
        /// <returns>The supported locales for a XLSP.</returns>
        private static string[] GetAllSupportedLocales(XboxLiveSubmissionProject xlsp)
        {
            string[] supportedLocales;

            // If no locales were found, just return the default locale.
            if (xlsp.GameConfigProject.LocalizedStrings.SupportedLocale == null ||
                xlsp.GameConfigProject.LocalizedStrings.SupportedLocale.Length == 0)
            {
                supportedLocales = new string[] { DefaultLocale };
            }
            else
            {
                List<string> localeList = new List<string>();
                foreach (var supportedLocale in xlsp.GameConfigProject.LocalizedStrings.SupportedLocale)
                {
                    localeList.Add(supportedLocale.locale);
                }

                supportedLocales = localeList.ToArray();
            }

            return supportedLocales;
        }

        /// <summary>
        /// Gets the localized string for the name of a mobile column.
        /// </summary>
        /// <param name="mobileStatsColumn">The mobile column for which to get the localized string.</param>
        /// <param name="locale">The locale for which to get the localized string.</param>
        /// <param name="colLocalizationData">Contains the mapping from a key (locale + column) to localized column name.</param>
        /// <returns>The localized string for the name of a mobile column.</returns>
        private static string GetLocalizedStringForColumn(MobileStatsColumns mobileStatsColumn, string locale, Dictionary<string, string> colLocalizationData)
        {
            string localizedString;

            string key = string.Format(ColLocalizationDataKeyFormat, locale, mobileStatsColumn.ToString());
            if (colLocalizationData.ContainsKey(key))
            {
                localizedString = colLocalizationData[key];
            }
            else
            {
                // Use the default data that we have for the column.
                localizedString = MobileColData[mobileStatsColumn].Name;
            }

            return localizedString;
        }

        /// <summary>
        /// Used to store essential data about a mobile column.
        /// </summary>
        public class MobileColumnData
        {
            /// <summary>
            /// Gets or sets the name of the column.
            /// </summary>
            public string Name { get; set; }

            /// <summary>
            /// Gets or sets the attributeId of the column.
            /// </summary>
            public ushort AttributeId { get; set; }

            /// <summary>
            /// Gets or sets the aggregation type to be used for the column.
            /// </summary>
            public PropertyFieldTypeAggregationType Aggregation { get; set; }

            /// <summary>
            /// Gets or sets the value of stringId for the column.
            /// </summary>
            public ushort StringId { get; set; }

            /// <summary>
            /// Gets or sets the value of propertyId for the column.
            /// </summary>
            public string PropertyId { get; set; }

            /// <summary>
            /// Gets or sets the value of dataSize for the column property.
            /// </summary>
            public ushort DataSize { get; set; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\leaderboard\dll\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_leaderboard_none_12.4.56.0_none_01561eb82c5ec838
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_leaderboard_no-public-key_12.4.56.0_x-ww_53006660
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=leaderboard
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_leaderboard_no-public-key_12.4.56.0_x-ww_53006660
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_leaderboard_no-public-key_12.4.56.0_x-ww_53006660.manifest
XP_MANIFEST_PATH=manifests\msil_leaderboard_no-public-key_12.4.56.0_x-ww_53006660.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_leaderboard_no-public-key_12.4.56.0_x-ww_53006660.cat
XP_CATALOG_PATH=manifests\msil_leaderboard_no-public-key_12.4.56.0_x-ww_53006660.cat
XP_PAYLOAD_PATH=msil_leaderboard_no-public-key_12.4.56.0_x-ww_53006660
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=leaderboard,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\leaderboard\leaderboard\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\leaderboard\dll\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_leaderboard_none_12.4.56.0_none_01561eb82c5ec838
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_leaderboard_no-public-key_12.4.56.0_x-ww_53006660
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=leaderboard
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_leaderboard_no-public-key_12.4.56.0_x-ww_53006660
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_leaderboard_no-public-key_12.4.56.0_x-ww_53006660.manifest
XP_MANIFEST_PATH=manifests\msil_leaderboard_no-public-key_12.4.56.0_x-ww_53006660.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_leaderboard_no-public-key_12.4.56.0_x-ww_53006660.cat
XP_CATALOG_PATH=manifests\msil_leaderboard_no-public-key_12.4.56.0_x-ww_53006660.cat
XP_PAYLOAD_PATH=msil_leaderboard_no-public-key_12.4.56.0_x-ww_53006660
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=leaderboard,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\inhbase\dll\InhBaseService.cs ===
using System;

using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Diagnostics;
using System.Linq;
using System.Net;
using System.Reflection;
using System.ServiceProcess;
using System.Text;
using System.Threading;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;

namespace xonline.common.inhbase
{
    public abstract class InhBaseService : ServiceBase
    {
        protected static void CreateInstance<T>(Assembly assembly) where T : InhBaseService, new()
        {
            Assembly = assembly;

            Instance = new T();
        }

#region Logging/Tracing/Events
        public static void TraceLow(string format, params object[] args)
        {
            Trace(LogLevel.L_LOW, format, args);
        }

        public static void TraceNormal(string format, params object[] args)
        {
            Trace(LogLevel.L_NORMAL, format, args);
        }

        public static void TraceHigh(string format, params object[] args)
        {
            Trace(LogLevel.L_HIGH, format, args);
        }

        public static void TraceError(string format, params object[] args)
        {
            Trace(LogLevel.L_ERROR, format, args);
        }

        protected static void Trace(LogLevel logLevel, string format, params object[] args)
        {
            Xom.Trace(Instance.TraceAreaName, logLevel, format, args);
        }

        public virtual void Log(string format, params object[] args)
        {
            Xom.Log(Instance.LogAreaName, format, args);
        }

        public virtual void Log(string output)
        {
            if ( RunningAsConsole )
            {
                Console.WriteLine(output);
            }

            Xom.Log(Instance.LogAreaName, output);
        }

        protected abstract XEvent.Id StartupEventId
        {
            get;
        }

        protected abstract XEvent.Id ShutdownStartingEventId
        {
            get;
        }

        protected abstract XEvent.Id ShutdownCompleteEventId
        {
            get;
        }

        protected abstract XEvent.Id StartupErrorEventId
        {
            get;
        }

        protected abstract XEvent.Id ShutdownErrorEventId
        {
            get;
        }

        protected abstract string TraceAreaName
        {
            get;
        }

        protected virtual string LogAreaName
        {
            get { return XomAreaName.log; }
        }

#endregion

        // Singleton
        public static InhBaseService Instance
        {
            get;
            protected set;
        }

        protected static Assembly Assembly
        {
            get;
            private set;
        }

        protected string ComponentName
        {
            get;
            private set;
        }

        public bool RunningAsConsole
        {
            get;
            protected set;
        }

        protected virtual void InitService()
        {
            try
            {
                // This ensures the component is registered rather than XblInhBase
                Config.Assembly = Assembly;

                // set the component name
                ComponentName = Config.ComponentName;

                // XomLoggingControl.Init determines the current assembly, and will detect
                // XblInhBase if it is not overridden here.

                // This ensures our xmgmt name is our actual component name, i.e.
                // e :vortex
                // and not the name of the .exe:
                // e :vortexsvc
                //
                // XomControlConnection.cs is responsible for this, but i'm (kgoodier) hesitant
                // to change that code. Fortunately jelien provided this override
                // already.
                XomLoggingControl.OverrideAssemblyName = ComponentName;

                XomLoggingControl.Init();

                // add the XMGMT command handler here
                XomControl.ControlRequestEvent += new XomControl.ControlRequestEventHandler(OnControlRequest);

                Xom.NtEvent(StartupEventId, "{0}: service is starting...", ComponentName);
            }
            catch (Exception e)
            {
                XEvent.Id eventId = StartupErrorEventId;

                if ( e is ExceptionWithEvent )
                {
                    eventId = ((ExceptionWithEvent)e).EventId;
                }

                Xom.NtEvent(eventId, e, "{0}: failed to initialize XomLogging (no logging will be available)", ComponentName);
                throw;
            }

            // Set up the non-IIS healthcheck listener
            try
            {
                xonline.common.health.HealthListener.InitializeHealthListener(ComponentName, Config.Assembly);
            }
            catch (Exception e)
            {
                Xom.NtEvent(StartupErrorEventId, e, "Failed initializing the Healthcheck system, continuing for now (no healthchecks will be available)");

                // go ahead and throw
                throw;
            }

        }

        protected virtual void CloseService()
        {
            XomLoggingControl.Close();
        }

        protected override void OnStart(string[] args)
        {
            // Every 5 seconds, request an additional 10 seconds from the SCM. Use a
            // threadpool thread. Disposing the timer will stop it. Vortex tends to
            // take a while to start sometimes, but it will never get permanently
            // stuck.

            try
            {
                if (!RunningAsConsole)
                {
                    int watchdogPeriodInMillis = 5000;
                    using (Timer watchdogTimer = new Timer(
                        p =>
                        {
                            try
                            {
                                RequestAdditionalTime(watchdogPeriodInMillis * 2);
                            }
                            catch (Exception)
                            { }
                        },
                        null,
                        0,
                        watchdogPeriodInMillis))
                    {
                        InitService();
                    }
                }
                else
                {
                    // Hmm, awkward to refactor with the using() block.
                    InitService();
                }
            }
            catch (Exception e)
            {
                Xom.NtEvent(StartupErrorEventId, e, "Unexpected runtime error while initializing the {0} service", ComponentName);
                throw;
            }
        }

        /// Stop this service.
        protected override void OnStop()
        {
            // if shutdown has already run, don't do it again
            if ( Instance == null )
            {
                return;
            }

            TraceNormal("OnStop: shutting down {0}...", ComponentName);

            try
            {
                if (!RunningAsConsole)
                {
                    int watchdogPeriodInMillis = 5000;
                    // Wrap the RequestAdditionalTime call in a try/catch to prevent
                    // this error:
                    //   InvalidOperationException (unhandled) "UpdatePendingStatus
                    //   can only be called during the handling of Start, Stop, Pause
                    //   and Continue commands."
                    using (Timer watchdogTimer = new Timer(
                        p =>
                        {
                            try
                            {
                                TraceLow("OnStop: requesting additional shutdown time ...");

                                RequestAdditionalTime(watchdogPeriodInMillis * 2);
                            }
                            catch (Exception)
                            { }
                        },
                        null,
                        0,
                        watchdogPeriodInMillis))
                    {
                        Xom.NtEvent(ShutdownStartingEventId, "{0}: service is stopping...", ComponentName);

                        CloseService();

                        Xom.NtEvent(ShutdownCompleteEventId, "{0}: service is stopped.", ComponentName);
                    }
                }
                else
                {
                    // Hmm, awkward to refactor with the using() block.
                    CloseService();
                }
            }
            catch (Exception e)
            {
                // not so great to have unhandled exceptions past here
                Xom.NtEvent(ShutdownErrorEventId, e, "Unhandled error while shutting down the service. Please investigate.");
            }

            RunningAsConsole = false;

            // if XMGMT is uninitialized, this is not likely to do much
            TraceNormal("{0} is now stopped.", ComponentName);

            // finally, clear the instance
            Instance = null;

        }

        private void RunAsConsole(string[] args)
        {
            RunningAsConsole = true;

            OnStart(args);

            try
            {
                Console.WriteLine("{0}: running as console. Type Ctrl-C to exit. Type \"help\" for commands.", ComponentName);

                Console.CancelKeyPress += (sender, eventArgs) => { Console.WriteLine("Exiting..."); OnStop(); };

                while (RunningAsConsole)
                {
                    string cmd = Console.ReadLine();
                    if (string.IsNullOrEmpty(cmd))
                    {
                        continue;
                    }

                    string response = "Invalid Command\r\n";
                    try
                    {
                        ControlRequestEventArgs cmdArgs = new ControlRequestEventArgs(cmd, 0);
                        response = HandleManangementCommand(cmdArgs);
                    }
                    catch (Exception e)
                    {
                        Console.WriteLine("Error: " + e.ToString() + "\r\n\r\n");
                    }

                    Console.WriteLine(response);
                }
            }
            finally
            {
                OnStop();
            }
        }

        protected abstract string HandleManangementCommand(ControlRequestEventArgs args);

        public static void OnControlRequest(object sender, ControlRequestEventArgs args)
        {
            try
            {
                string response = Instance.HandleManangementCommand(args);
                XomControlConnection.SendMessage(response, args.RequestId);
            }
            catch(Exception e)
            {
                XomControlConnection.SendMessage("Error: " + e.ToString() + "\r\n\r\n", args.RequestId);
            }
        }

        public static void Run(string[] args)
        {
            InhBaseService service = Instance;

            bool runAsConsole = false;

            runAsConsole = args.Contains("-console", StringComparer.InvariantCultureIgnoreCase) || args.Contains("/console", StringComparer.InvariantCultureIgnoreCase);

            if (runAsConsole)
            {
                service.RunAsConsole(args);
            }
            else
            {
                ServiceBase.Run(service);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\leaderboard\leaderboard\leaderboard.cs ===
using System;
using xonline.tools.framework;
using System.Text;
using System.Collections;
using System.Collections.Generic;

namespace xonline.common.leaderboard
{
    public enum LbType
    {
        Regular,
        Competition
    }

    // Copied from \server\stats\lbs\lb.h
    public enum LbResetType
    {
        LbResetTypeNever         = 0,
        LbResetTypeWeekly        = 1,
        LbResetTypeMonthly       = 2,
        LbResetTypeBimonthly     = 3,
        LbResetTypeQuarterly     = 4,
        LbResetTypeSemiannually  = 5,
        LbResetTypeAnnually      = 6
    }

    public class PlatformVisibleLeaderboardLocInfo
    {
        public byte Flags { get; private set; }               // Platform visible flags
        public byte FormatType { get; private set; }          // Platform visible type
        public byte Format { get; private set; }              // Platform visible format
        public ushort RatingAttributeId { get; private set; } // If a custom rating attribute is specified, this is it!
        public string Name { get; private set; }              // leaderboard Name
        public string Rating { get; private set; }            // leaderboard Rating string

        public PlatformVisibleLeaderboardLocInfo(
            ushort usRatingAttrId, 
            byte bFlags,
            byte bType,
            byte bFormat,
            string name, 
            string rating)
        {            
            RatingAttributeId = usRatingAttrId;
            Flags = bFlags;
            FormatType = bType;
            Format = bFormat;
            Name = name;
            Rating = rating;            
        }           
    }

    // contains all NPDB settings about leaderboards
    // lots more info is in XLAST that we don't need while configuring the service
    public class LeaderboardSettings
    {
        public LbType   Type;                   // leaderboard type

        public string   LBServer;
        public uint     TitleID;                // titleid
        public int      LeaderboardID;          // LB id
//        public string FriendlyName;           // friendlyName
        public byte     ResetType;              // bResetType
        public int      MaxAttachments;         // iAttCount,  == maxAttachments
        public int      MaxAttachmentSize;      // iMaxAttSize, == maxAttachmentSize
        public int      DecayDays;              // entryExpiration or iDecayDays
        public int      TopEntries;             // iMaxRatCount, == topEntries;; 1 or 0 for Xenon M3
        public string   EloE;                   // Elo settings... still needed for Xbox 1 back-compat
        public int      EloK;                   //
        public int      EloNew;                 //
        public string   EloCtable;              //
        public bool     TeamView;               // IsTeam,
        public bool     Arbitrated;             // bReqArbitration
        public DateTime LastReset;              // Last reset date for this leaderboard

        private Dictionary<string, PlatformVisibleLeaderboardLocInfo> pvlInfo = new Dictionary<string, PlatformVisibleLeaderboardLocInfo>();

        public Dictionary<string, PlatformVisibleLeaderboardLocInfo> PlatformVisibleLeaderboardData
        {
            get
            {
                return pvlInfo;
            }   
        }

        public bool HasPlatformVisibleLeaderboards
        {
            get
            {
                return (pvlInfo.Count > 0);
            }
        }
        
        // WebDB stuff
        public LocalizedDescription[] Descriptions = new LocalizedDescription[0];    // list of leaderboard descriptions
        public RawAttribute[]         RawAttributes = new RawAttribute[0];   // list of raw attributes
        public LbColumn[]             Columns = new LbColumn[0];         // list of column formats

        public const string UnknownServer = "Unknown";

        public LeaderboardSettings()
        {
            //task: constructor need to do anything?
        }

        public LeaderboardSettings( string lbserver, uint titleID, int leaderboardID, byte resetType, int maxAttchments, int maxAttchmentSize,
                            int decayDays, int topEntries, bool isTeamView, bool isArbitrated, DateTime lastReset )
        {
            //somewhere, there's a .Net style guide author who's very happy to see this use of casing...
            Type = LbType.Regular;
            LBServer = lbserver;
            TitleID = titleID;
            LeaderboardID = leaderboardID;
            ResetType = resetType;
            MaxAttachments = maxAttchments;
            MaxAttachmentSize = maxAttchmentSize;
            DecayDays = decayDays;
            TopEntries = topEntries;
            TeamView = isTeamView;
            Arbitrated = isArbitrated;
            LastReset = lastReset;
            EloE = "10";
            EloK = 100;
            EloNew = 500;
            EloCtable = "0:40";           
        }

        public LeaderboardSettings( string lbserver, uint titleID, int leaderboardID, byte resetType, int maxAttchments, int maxAttchmentSize,
                            int decayDays, string eloE, int eloK, int eloNew, string eloCtable,
                            int topEntries, bool isTeamView, bool isArbitrated, DateTime lastReset )
        {
            Type = LbType.Regular;

            //somewhere, there's a .Net style guide author who's very happy to see this use of casing...
            LBServer = lbserver;
            TitleID = titleID;
            LeaderboardID = leaderboardID;
            ResetType = resetType;
            if ( eloE.Length > 2 )
            {
                throw new ArgumentException( "EloE value can only be 2 characters long" );
            }
            EloE = eloE;
            EloK = eloK;
            EloNew = eloNew;
            EloCtable = eloCtable;
            MaxAttachments = maxAttchments;
            MaxAttachmentSize = maxAttchmentSize;
            DecayDays = decayDays;
            TopEntries = topEntries;
            TeamView = isTeamView;
            Arbitrated = isArbitrated;
            LastReset = lastReset;
        }

        public void AddPlatformVisibleLeaderboardInfo(
            string locale,
            ushort usRatingAttrId,
            byte bFlags,
            byte bType,
            byte bFormat,
            string name,
            string rating)
        {
            pvlInfo[locale] = new PlatformVisibleLeaderboardLocInfo(usRatingAttrId, bFlags, bType, bFormat, name, rating);
        }

        public bool HasPlatformLeaderboards
        {
            get
            {
                return (PlatformVisibleLeaderboardData.Count > 0);
            }
        }

        // If returns true, comparisonLbSettings platform leaderboard data is NOT the same as this objects's 
        // platform leaderboard data
        public bool PlatformLeaderboardIsDifferent(LeaderboardSettings comparisonLbSettings)
        {
            if (pvlInfo.Count != comparisonLbSettings.PlatformVisibleLeaderboardData.Count)
            {
                return true;  // different number of platform visible leaderboard loc entries!
            }

            if (pvlInfo.Count == 0)
            {
                return false;  // no platform visible leaderboards for either leaderboard, so not different...
            }

            foreach (KeyValuePair<string, PlatformVisibleLeaderboardLocInfo> kvp in pvlInfo)
            {
                try
                {
                    PlatformVisibleLeaderboardLocInfo compareData = comparisonLbSettings.PlatformVisibleLeaderboardData[kvp.Key];

                    if (kvp.Value.Flags != compareData.Flags ||
                        kvp.Value.FormatType != compareData.FormatType ||
                        kvp.Value.Format != compareData.Format ||
                        kvp.Value.RatingAttributeId != compareData.RatingAttributeId ||
                        kvp.Value.Name != compareData.Name ||
                        kvp.Value.Rating != compareData.Rating)
                    {
                        return true; // definitely different!
                    }
                }
                catch
                {
                    // different! 
                    return true;
                }
            }

            return false; // exactly the same...so NOT different
        }

    } //leaderboard

    public class LbColumn
    {
        public string Name;
        public int ReturnType;
        public string Formula;
        public LocalizedDescription[] Descriptions;

        // xlast fields
        public uint AttributeId;
        public uint PropertyId;
        public string Aggregation;

        public LbColumn(string szNameIn, uint attributeIdIn, string FormulaIn)
        {
            Name = szNameIn;
            AttributeId = attributeIdIn;
            Formula = FormulaIn;
        }

        public LbColumn()
        {
            
        }
    }

    public class LocalizedDescription
    {
        public string Locale;
        public string Description;

        public LocalizedDescription(string LocaleIn, string DescriptionIn)
        {
            Locale = LocaleIn;
            Description = DescriptionIn;
        }

        public LocalizedDescription()
        {
            
        }
    }

    public class RawAttribute
    {
        public int  Index;
        public bool IsPuid;
    }

} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\leaderboard\leaderboard\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__leaderboard_1_none_12.4.56.0_none_3fc0bccae03ff1c4
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__leaderboard_1_no-public-key_12.4.56.0_x-ww_cc33fdc6
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_leaderboard_1
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__leaderboard_1_no-public-key_12.4.56.0_x-ww_cc33fdc6
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__leaderboard_1_no-public-key_12.4.56.0_x-ww_cc33fdc6.manifest
XP_MANIFEST_PATH=manifests\x86__leaderboard_1_no-public-key_12.4.56.0_x-ww_cc33fdc6.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__leaderboard_1_no-public-key_12.4.56.0_x-ww_cc33fdc6.cat
XP_CATALOG_PATH=manifests\x86__leaderboard_1_no-public-key_12.4.56.0_x-ww_cc33fdc6.cat
XP_PAYLOAD_PATH=x86__leaderboard_1_no-public-key_12.4.56.0_x-ww_cc33fdc6
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_leaderboard_1,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\leaderboard\leaderboard\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__leaderboard_1_none_12.4.56.0_none_3fc0bccae03ff1c4
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__leaderboard_1_no-public-key_12.4.56.0_x-ww_cc33fdc6
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_leaderboard_1
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__leaderboard_1_no-public-key_12.4.56.0_x-ww_cc33fdc6
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__leaderboard_1_no-public-key_12.4.56.0_x-ww_cc33fdc6.manifest
XP_MANIFEST_PATH=manifests\x86__leaderboard_1_no-public-key_12.4.56.0_x-ww_cc33fdc6.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__leaderboard_1_no-public-key_12.4.56.0_x-ww_cc33fdc6.cat
XP_CATALOG_PATH=manifests\x86__leaderboard_1_no-public-key_12.4.56.0_x-ww_cc33fdc6.cat
XP_PAYLOAD_PATH=x86__leaderboard_1_no-public-key_12.4.56.0_x-ww_cc33fdc6
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_leaderboard_1,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\livetest\core\AssemblyReference.cs ===
using System;
using System.Reflection;

namespace livetest.core
{
    /// <summary>
    ///  A lighweight container for assemblies that allows lazy-loading.
    /// </summary>
    public class AssemblyReference
    {
        /// <summary>Full path to the assembly file.</summary>
        public string FullPath;
        /// <summary>A name for this AssemblyReference.</summary>
        public string Name;

        private Assembly _Asm;


        /// <value>Assembly that this AssemblyReference references.</value>
        public Assembly Asm
        {
            get {
                if(null == _Asm)
                {
                    throw new Exception("Assembly is not loaded");
                }
                return _Asm;
            }
        }


        /// <value>true if Asm as been initialized, false otherwise.</value>
        public bool IsLoaded
        {
            get {
                return null != _Asm;
            }
        }


        /// <summary>
        ///  Creates a new AssemblyReference.
        /// </summary>
        public AssemblyReference ()
        {
        }


        /// <summary>
        ///  Loads the actual Assembly. The result of this call is that 
        ///  IsLoaded returns true.
        /// </summary>
        public void Instantiate ()
        {
            if(!IsLoaded)
            {
                if(null == FullPath || 0 == FullPath.Length)
                {
                    throw new Exception("FullPath was not configured correctly");
                }
                _Asm = Assembly.LoadFile(FullPath);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\livetest\core\Bus.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.Text.RegularExpressions;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Threading;
using System.Diagnostics;

namespace livetest.core
{
    public class Bus
    {
        private class Channel
        {
            public uint             Id;
            public IMessageHandler  Owner;
            public ArrayList        Listeners;

            public void OnShutdown(Bus bus)
            {
                // TODO: deliver shutdown event to subscribers? manually remove listeners?
            }
        }

        // Static destinations
        public const string AnyChannel = "*";


        // The main dispatch table
        private Hashtable       _Channels;
        private uint            _NextId;
        private Queue           _MessageQueue;
        private AutoResetEvent  _HasDataEvent;
        private BusManager      _Manager;

        private static Bus  _Default;


        /// <summary>
        ///  TODO
        /// </summary>
        public static Bus Default {
            get {
                if(null == _Default)
                {
                    BusManager manager = BusManager.Instance;

                    lock(typeof(Bus))
                    {
                        if(null == _Default)
                        {
                            _Default = new Bus(manager);
                        }
                    }
                }
                return _Default;
            }
        }

        public uint ChannelListVersion
        {
            get {
                return _NextId;
            }
        }

        public string[] ChannelNames
        {
            get {
                lock(this)
                {
                    string[] names = new string[_Channels.Count];
                    uint i = 0;

                    foreach(string n in _Channels.Keys)
                    {
                        names[i++] = n;
                    }
                    return names;
                }
            }
        }

        public WaitHandle AsyncWaitHandle
        {
            get {
                return _HasDataEvent;
            }
        }

        public Bus(BusManager manager)
        {
            _Channels       = new Hashtable();
            _MessageQueue   = new Queue();
            _HasDataEvent   = new AutoResetEvent(false);
            _Manager        = manager;

            manager.RegisterBus(this);
        }

        // Register a new a channel, if it is created it will set the specified
        // handler as the owner. Otherwise the handler will be a listener on the channel
        public void RegisterChannel(string name, IMessageHandler handler)
        {
            name = name.ToLower();

            lock(this)
            {
                Channel channel = _Channels[name] as Channel;

                if(null == channel)
                {
                    channel = new Channel();
                    channel.Id    = _NextId++;
                    channel.Owner = handler;
                    _Channels[name] = channel;
                }
                else
                {
                    if(null == channel.Listeners)
                    {
                        channel.Listeners = new ArrayList();
                        channel.Listeners.Add(handler);
                    }
                }
            }
        }

        // Remove a message handler from the specified channel name. If it is the owner
        // the channel will be removed completely, otherwise it will remove the specified
        // handler from the passive listeners list
        public void UnregisterChannel(string name, IMessageHandler handler)
        {
            name = name.ToLower();

            lock(this)
            {
                Channel channel = _Channels[name] as Channel;
                if(null != channel)
                {
                    if(handler == channel.Owner)
                    {
                        // Remove the channel completely
                        channel.OnShutdown(this);
                        _Channels.Remove(name);
                    }
                    else if(null != channel.Listeners)
                    {
                        // Remove the listener
                        channel.Listeners.Remove(handler);

                        if(0 == channel.Listeners.Count)
                        {
                            channel.Listeners = null;
                        }
                    }
                }
            }
        }

        public void Publish(string name, string src, Payload payload)
        {
            Publish(name, src, AnyChannel, payload, 0);
        }

        public void Publish(string name, string src, string dst, Payload payload)
        {
            Publish(name, src, dst, payload, 0);
        }

        public void Publish(string name, string src, string dst, Payload payload, uint flags)
        { 
            Message msg = new Message();
            msg.Name        = name;
            msg.Src         = src;
            msg.Dst         = dst;
            msg.Payload     = payload;
            msg.Flags       = flags;

            PublishMessage(msg);
        }

        public void PublishMessage(Message msg)
        {
            if(Message.AsyncDelivery == (msg.Flags & Message.AsyncDelivery))
            {
                lock(this)
                {
                    _MessageQueue.Enqueue(msg);
                    _HasDataEvent.Set();
                }
            }
            else
            {
                // Delivery directly on the calling thread
                ArrayList deliverto = new ArrayList(); 
                GetDestinations(msg, deliverto);
                DeliverMessage(msg, deliverto);
            }
        }

        // Get all queued messages and deliver
        public void Pulse()
        {
            ArrayList messages = new ArrayList();
            ArrayList deliverto = new ArrayList();

            lock(this)
            { 
                messages.AddRange(_MessageQueue);
                _MessageQueue.Clear();
            }

            foreach(Message msg in messages)
            {
                GetDestinations(msg, deliverto);
                DeliverMessage(msg, deliverto);
                deliverto.Clear();
            }
        }

        private void DeliverMessage(Message msg, ArrayList deliverto)
        {
            string []pathElements = msg.Dst.Split(
                    new char[]{Message.PathScopeOperatorChar}, 
                    StringSplitOptions.RemoveEmptyEntries);

            if(2 == pathElements.Length)
            {
                // Route messages with scope through the bus manager
                _Manager.RouteNetworkMessage(msg, pathElements);
            }
            else
            {
                // Local delivery

                // Prune duplicates from deliverto, this list should be short
                for(int i = 0, c = deliverto.Count; i < c; ++i)
                {
                    IMessageHandler mh = deliverto[i] as IMessageHandler; 
                    for(int j = i + 1; j < c; ++j)
                    {
                        if(mh == deliverto[j])
                        {
                            deliverto.RemoveAt(j);
                            c--;
                            break;
                        }
                    }
                }

                // Dispatch to registered handlers
                foreach(IMessageHandler mh in deliverto)
                {
                    mh.HandleMessage(msg);
                }
            } 
        }

        private void GetDestinations(Message msg, ArrayList deliverto)
        {
            lock(this)
            {
                if(null != msg.Dst && "*" != msg.Dst)
                {
                    Channel channel = _Channels[msg.Dst.ToLower()] as Channel;
                    if(null != channel)
                    {
                        // Add the channel owner by default
                        deliverto.Add(channel.Owner);

                        if(null != channel.Listeners)
                        {
                            foreach(IMessageHandler mh in channel.Listeners)
                            {
                                deliverto.Add(mh);
                            }
                        }
                    }
                }
                else
                {
                    // Add all channels for broadcast messages
                    foreach(Channel channel in _Channels.Values)
                    {
                        // Add the channel owner by default
                        deliverto.Add(channel.Owner);

                        if(null != channel.Listeners)
                        {
                            foreach(IMessageHandler mh in channel.Listeners)
                            {
                                deliverto.Add(mh);
                            }
                        }
                    }
                }
            } // end lock(this)
        }
    }

    public class BusManager : IMessageHandler
    {
        private class BusTracker
        {
            public Bus     Bus;
            public uint    LastVersion;

            public BusTracker(Bus bus, uint version)
            {
                Bus = bus;
                LastVersion = version;
            }
        }

        public const ushort DefaultPort             = 0xfdfd;
        public const string ChannelName             = "lbm";
        public const string AnyHost                 = "*";        
        public const string AnyChannel              = "*";        
        public const string Broadcast               = AnyHost + Message.PathScopeOperatorString + AnyChannel;

        // Message names constants
        public const string BusNamespace            = "BusMgr";
        public const string KeepAlive               = "BusMgrKeepAlive";
        public const string Error                   = "BusMgrError";
        public const string Status                  = "BusMgrStatus";
        public const string ChannelListQuery        = "BusMgrChannelListQuery";
        public const string ChannelListAdvertise    = "BusMgrChannelListAdvertise";
        public const string RegisterPeer            = "BusMgrRegisterPeer";
        public const string UnregisterPeer          = "BusMgrUnregisterPeer";
        public const string SyncPeerList            = "BusMgrSyncPeerList";
        public const string KickPeer                = "BusMgrKickPeer";

        private const uint MaxPeerConnectionAttempts = 10;


        private static Report       _Report     = new Report("BusManager");
        private static BusManager   _Instance;

        private int                 _PulseInterval;
        private Connection          _GroupManager;
        private List<Connection>    _Peers;
        private List<Connection>    _Clients;
        private List<BusTracker>    _BusTrackerList;
        private List<string>        _KnownPeers;
        private uint                _KnownPeersVersion;

        private Thread              _MaintainenceThread;
        private WaitHandle          _ThreadShutdownEvent;
        private ManualResetEvent    _ShutdownEvent;
        private AutoResetEvent      _MaintainenceKickEvent;
        private IPAddress           _LocalAddress;

        public static BusManager Instance
        {
            get
            {
                if(null == _Instance)
                {
                    lock(typeof(BusManager))
                    {
                        // Two threads racing on above condition will serialize here
                        // but we don't serialize on the lock for every call to Instance
                        if(null == _Instance)
                        {
                            _Instance = new BusManager();
                        }
                    }
                }
                return _Instance;
            }
        }

        public IPAddress LocalAddress
        {
            get {
                return _LocalAddress;
            }
        }

        public string [] KnownPeers
        {
            get {
                return _KnownPeers.ToArray();
            }
        }

        public void RegisterBus(Bus bus)
        {
            lock(this)
            {
                _BusTrackerList.Add(new BusTracker(bus, bus.ChannelListVersion));
            }

            // local bus manager
            bus.RegisterChannel(ChannelName, this);
        }

        public void UnregisterBus(Bus bus)
        {
            lock(this)
            {
                foreach(BusTracker tracker in _BusTrackerList)
                {
                    if(bus == tracker.Bus)
                    {
                        _BusTrackerList.Remove(tracker);
                        break;
                    }
                }
            }
        }

        private BusManager()
        {
            _PulseInterval = 15000;
            _Peers = new List<Connection>();
            _KnownPeers = new List<string>();
            _Clients = new List<Connection>();
            _BusTrackerList = new List<BusTracker>();
            _ShutdownEvent  = new ManualResetEvent(false);
            _MaintainenceKickEvent = new AutoResetEvent(false);
            _LocalAddress = null;

            // We need to walk the list list of available IP
            // addresses until we find one that is IPv4.
            IPHostEntry hostEntry = Dns.GetHostEntry(Dns.GetHostName());
            foreach (IPAddress addr in hostEntry.AddressList)
            {
                if (addr.AddressFamily == AddressFamily.InterNetwork)
                {
                    _LocalAddress = addr;
                    break;
                }
            }

            if(null == _LocalAddress)
            {
                throw new ApplicationException("Failed to get a local host name for routing.");
            }

            _MaintainenceThread = new Thread(new ThreadStart(this.MaintainenceThreadProc));
            _ThreadShutdownEvent = ThreadContainer.Register(_MaintainenceThread);
            _MaintainenceThread.Start();
        }

        // 
        // Maintainence thread runs a pulse interval or when
        // there a data event on the bus that should be delivered
        //
        // When the pulse interval runs we make sure that we have a group
        // manager connection. Either we are maintaining it or some
        // other lbm is managing it.
        //
        private void MaintainenceThreadProc()
        {
            int status = WaitHandle.WaitTimeout;
            DateTime timeout = DateTime.Now;
            Bus defaultBus = Bus.Default;
            WaitHandle []handles = new WaitHandle[4];
            handles[0] = _ShutdownEvent;
            handles[1] = _MaintainenceKickEvent;
            handles[2] = _ThreadShutdownEvent;
            handles[3] = defaultBus.AsyncWaitHandle;

            // Pulse the bus on the provided interval
            for(;;)
            {
                try
                {
                    // Do some logic to determine if we have a good
                    // connection or if we need to assume port control
                    // when the pulse interval times out or enough time
                    // has passed.
                    if(    WaitHandle.WaitTimeout == status 
                        || 1 == status
                        || DateTime.Now >= timeout)
                    {
                        timeout = DateTime.Now.AddMilliseconds(_PulseInterval);

                        // Try to assume group manager role or connect to current as appropriate
                        CheckGroupManager();

                        // Monitor the peer connections for health and freshness
                        CheckPeerConnections();

                        // Sync all clients and peers with last known version of peer list if neccessary
                        SyncKnownPeers();

                        // Send a keep alive message
                        defaultBus.Publish(
                                BusManager.KeepAlive,
                                ChannelName, 
                                Bus.AnyChannel, 
                                null, 
                                Message.AsyncDelivery);
                    }

                    defaultBus.Pulse();

                    // Thread shutdown event
                    if(status == 0)
                    {
                        break;
                    }

                    status = WaitHandle.WaitAny(handles, _PulseInterval, false);
                }
                catch(Exception ex)
                {
                    _Report.Error("[MaintainenceThreadProc]: Failed with exception" + ex.ToString());
                }
            }

            // Close the listener on shutdown if required
            if(null != _GroupManager)
            {
                _GroupManager.Disconnect();
                _GroupManager = null;
            }

            // Close all client connections, they will be removed from the list
            // when they disconnect
            Connection []clients = _Clients.ToArray();
            foreach(Connection client in clients)
            {
                client.Disconnect();
            }
            _Clients.Clear();

            // Close all peer connections, they will be removed from the list
            // when they disconnect
            Connection []peers = _Peers.ToArray();
            foreach(Connection peer in peers)
            {
                peer.Disconnect();
            }
            _Peers.Clear();
            _KnownPeers.Clear();
        }

        private void CheckGroupManager()
        {
            if(null != _GroupManager)
            {
                return;
            }

            lock(this)
            {
                // Check again after serializing
                if(null != _GroupManager)
                {
                    return;
                }

                try
                {
                    Connection groupManager = new Connection(this, null, new IPEndPoint(LocalAddress, DefaultPort), true);
                    groupManager.StartListening();
                    _GroupManager = groupManager;

                    _Report.Debug("[ConnectToGroupManager]: Assumed group manager role on network bus for address: {0}",
                            LocalAddress.ToString());
                }
                catch(SocketException ex)
                {
                    // Could not create the socket listener, if it's because there is already
                    // a group manager listening, try to connect to it as a client
                    if((int)SocketError.AddressAlreadyInUse == ex.ErrorCode)
                    {
                        try
                        {
                            // Try to connect, if it fails we'll remove the group manager and come through here
                            // on the next maintainence tick
                            _GroupManager = new Connection(this, null, new IPEndPoint(LocalAddress, DefaultPort), true); 
                            _GroupManager.StartConnect();
                        }
                        catch(Exception innerEx)
                        {
                            // We will catch any errors here and let the next call retry
                            _Report.Error("[ConnectToGroupManager]: Failed to connect to group manager: " + innerEx.Message);
                        }
                    }
                }
            }
        }

        private void CheckPeerConnections()
        {
            lock(this)
            {
                // If this is on the GM we will initiate the connection logic
                // and version the peer list for sync'ing to clients and peers
                if(OwnsGroupManagerRole())
                {
                    bool updateVersion = false;

                    foreach(string knownPeer in _KnownPeers)
                    {
                        // Track 'self' peer entry but don't try to connect to it as a peer (the group manager/client
                        // connection handles this)
                        if(knownPeer == _LocalAddress.ToString() || knownPeer == "127.0.0.1")
                        {
                            continue; 
                        }

                        Connection conn = LookupPeerConnection(knownPeer);
                        if(null == conn)
                        {
                            _Report.Debug("[CheckPeerConnections]: Adding peer from known peers list: {0}",
                                    knownPeer);

                            conn = new Connection(this, null, new IPEndPoint(IPAddress.Parse(knownPeer), DefaultPort), false);
                            _Peers.Add(conn);
                            conn.StartConnect();
                            updateVersion = true;
                        }
                    }

                    if(updateVersion)
                    {
                        _KnownPeersVersion++;
                    }
                }
               
                // Try to keep peers alive in the case of GM migration
                for(int i = 0; i < _Peers.Count; ++i)
                {
                    Connection peer = _Peers[i];
                    if(peer.IsDisconnected)
                    {
                        if(peer.ConnectionAttempts == MaxPeerConnectionAttempts)
                        {
                            _Report.Info("[CheckPeerConnections]: Removing peer connection: {0} after {1} failed connection attempts", 
                                    peer.EndPoint.ToString(),
                                    peer.ConnectionAttempts);
                            RemoveConnection(peer);
                        }
                        else
                        {
                            peer.StartReconnect();
                        }
                    }
                }
            }
        }

        private bool OwnsGroupManagerRole()
        {
            return null != _GroupManager && _GroupManager.IsListening;
        }

        private void SyncKnownPeers()
        {
            lock(this)
            {
                foreach(Connection conn in _Clients)
                {
                    if(conn.LastSync != _KnownPeersVersion)
                    {
                        Message msg = new Message();
                        msg.Name = BusManager.SyncPeerList;
                        msg.Src = BusManager.ChannelName;
                        msg.Dst = BusManager.ChannelName;
                        msg.Payload = new StringListPayload(_KnownPeers.ToArray());

                        conn.SendMessage(msg);
                        conn.LastSync = _KnownPeersVersion;
                    }
                }
                foreach(Connection conn in _Peers)
                {
                    if(conn.LastSync != _KnownPeersVersion)
                    {
                        Message msg = new Message();
                        msg.Name = BusManager.SyncPeerList;
                        msg.Src = BusManager.ChannelName;
                        msg.Dst = BusManager.ChannelName;
                        msg.Payload = new StringListPayload(_KnownPeers.ToArray());

                        conn.SendMessage(msg);
                        conn.LastSync = _KnownPeersVersion;
                    }
                }
            }
        }

        public void AddPeer(string host)
        {
            IPEndPoint ep = HostNameToEndPoint(host);
            AddPeer(ep);
        }

        private IPEndPoint HostNameToEndPoint(string host)
        {
            Regex rx = new Regex(@"\d+\.\d+\.\d+\.\d+");
            IPEndPoint ep = null;

            if(rx.IsMatch(host))
            {
                IPAddress addr = IPAddress.Parse(host);
                ep = new IPEndPoint(addr, BusManager.DefaultPort);
            }
            else
            {
                IPHostEntry hostEnt = Dns.GetHostEntry(host);
                ep = new IPEndPoint(hostEnt.AddressList[0], BusManager.DefaultPort);
            }

            return ep;
        }

        private void AddPeer(IPEndPoint endpoint)
        {
            lock(this)
            {
                try
                {
                    if(!_KnownPeers.Contains(endpoint.Address.ToString()))
                    {
                        _KnownPeers.Add(endpoint.Address.ToString());
                        _MaintainenceKickEvent.Set();
                        _KnownPeersVersion++;

                        _Report.Debug("[AddPeer]: Added new known peer: {0} and kicked maintainence event",
                                endpoint.Address.ToString());
                    }
                }
                catch(SocketException ex)
                {
                    _Report.Error("[AddPeer]: Failed to start connecting to peer connection: {0}\n{1}",
                            endpoint.ToString(),
                            ex.ToString());
                }
            }
        }


        public void RemovePeer(string host)
        {
            RemovePeer(host, true);
        }

        public void RemovePeer(string host, bool sendKick)
        {
            IPEndPoint ep = HostNameToEndPoint(host);
            string peerAddress = ep.Address.ToString();


            lock(this)
            {
                // Notify other peers
                if(sendKick)
                {
                    Message msg = new Message();
                    msg.Name = BusManager.KickPeer;
                    msg.Src = BusManager.ChannelName;
                    msg.Dst = BusManager.Broadcast;
                    msg.Payload = new StringPayload(peerAddress);

                    foreach(Connection conn in _Peers)
                    {
                        conn.SendMessage(msg);
                    }
                }

                // Remove one or all peer connections depending on if this host is the
                // target of the removal.
                if(peerAddress != _LocalAddress.ToString())
                {
                    _Report.Debug("[RemovePeer]: Attempting to remove remote peer {0}", host);
                    Connection conn = LookupPeerConnection(peerAddress);
                    if(null != conn)
                    {
                        conn.Disconnect(true);
                    }
                }
                else
                {
                    _Report.Debug("[RemovePeer]: Local machine is to be removed, clearing connections and known peers");
                    while(_Peers.Count > 0)
                    {
                        Connection conn = _Peers[_Peers.Count - 1];
                        conn.Disconnect(true);
                    }
                }
            }
        }

        // Called from the accept socket to add new client connections
        protected void OnClientAccepted(Socket socket)
        {
            lock(this)
            {
                IPEndPoint ep = socket.RemoteEndPoint as IPEndPoint;
                Connection conn = new Connection(this, socket, ep, true);
                _Clients.Add(conn);
                _KnownPeersVersion++;
                _MaintainenceKickEvent.Set();
                conn.StartReading();

                _Report.Info("[OnClientAccepted]: Accepted client connection from: {0}",
                        socket.RemoteEndPoint.ToString());
            }
        }

        // Called from the accept socket to add new peer connection objects
        protected void OnPeerAccepted(Socket socket)
        {
            lock(this)
            {
                IPEndPoint ep = socket.RemoteEndPoint as IPEndPoint;
                string peerAddress = ep.Address.ToString();

                // Make sure we add this to the known peers list
                if(!_KnownPeers.Contains(peerAddress))
                {
                    _KnownPeers.Add(peerAddress);
                    _KnownPeersVersion++;
                    _MaintainenceKickEvent.Set();
                }


                Connection conn = LookupPeerConnection(peerAddress);
                if(null == conn)
                {
                    conn = new Connection(this, socket, ep, false);
                    _Peers.Add(conn);
                    conn.StartReading();

                    _Report.Info("[OnPeerAccepted]: Accepted peer connection from: {0}",
                            ep.ToString());
                }
                else
                {
                    if(conn.SocketState != Connection.State.Connecting && conn.SocketState != Connection.State.Connected)
                    {

                        _Report.Debug("[OnPeerAccepted]: Replacing connection socket handle for: {0}",
                                ep.ToString());

                        conn.AttachSocket(socket);
                        conn.StartReading();
                    }
                    else
                    {
                        _Report.Warn("[OnPeerAccepted]: Discarding duplicate connection from: {0}",
                                ep.ToString());

                        socket.Close();
                    }
                }
            }
        }

        

        // Called on AIO connection completion, could be from client connection
        // or peer connection to group manager
        protected void NotifyConnectionComplete(Connection conn)
        {
            lock(this)
            {
                if(_GroupManager != conn)
                {
                    _Report.Debug("[NotifyConnectionComplete]: Connected to peer: Local: {0}, Remote: {1}",
                            conn.LocalAddress,
                            conn.RemoteAddress);

                    // Ensure the new peer is sent our version of the peer list
                    ++_KnownPeersVersion;
                    _MaintainenceKickEvent.Set();
                }
                else
                {
                    _Report.Debug("[NotifyConnectionComplete]: Connected to group manager: Local: {0}, Remote: {1}",
                            conn.LocalAddress,
                            conn.RemoteAddress);

                }

                conn.StartReading();
            }
        }

        protected void RemoveConnection(Connection conn)
        {
            lock(this)
            {
                // For lbm not owning the listen port the group manager is also
                // the master peer connection
                if(_GroupManager == conn)
                {
                    _GroupManager = null;

                    _Report.Debug("[RemoveConnection]: Removed group manager: {0}",
                            conn.RemoteAddress);
                }
                else
                {
                    if(_Peers.Contains(conn))
                    {
                        _Peers.Remove(conn);
                        _Report.Debug("[RemoveConnection]: Removed peer: Local: {0}, Remote: {1}", 
                                conn.LocalAddress,
                                conn.RemoteAddress);

                        // Remove from known peers table
                        for(int i = 0; i < _KnownPeers.Count; ++i)
                        {
                            string knownPeer = _KnownPeers[i];
                            if(conn.EndPoint.ToString().StartsWith(knownPeer))
                            {
                                _KnownPeers.RemoveAt(i);
                                _KnownPeersVersion++;
                                _MaintainenceKickEvent.Set();
                                break;
                            }
                        }
                    }
                    else if(_Clients.Contains(conn))
                    {
                        _Clients.Remove(conn);
                        _Report.Debug("[RemoveConnection]: Removed client: Local: {0}, Remote: {1}", 
                                conn.LocalAddress,
                                conn.RemoteAddress);
                    }
                }
            }
        }

        //  
        // Handle messages arriving for 'lbm'
        //
        public void HandleMessage(Message msg)
        {
            switch(msg.Name)
            {
                case BusManager.SyncPeerList:
                    lock(this)
                    {

                        // Always store the peer list for redundancy across
                        // the all the nodes in a group, clients will treat the peer
                        // list as authoritative but other GM peers will add new 
                        // peers that they don't yet know about
                        StringListPayload payload = (StringListPayload)msg.Payload;
                        _Report.Debug("[HandleMessage]: Syncing {0} peers from {1}",
                                payload.Values.Length,
                                msg.Src);

                        if(OwnsGroupManagerRole())
                        {
                            foreach(string peer in payload.Values)
                            {
                                Connection conn = LookupPeerConnection(peer);
                                if(null == conn)
                                {
                                    AddPeer(peer);
                                }
                            }
                        }
                        else
                        {
                            _KnownPeers.Clear();
                            _KnownPeers.AddRange(payload.Values);
                        }
                    }
                    break;
                case BusManager.KickPeer:
                    lock(this)
                    {
                        // If this is the peer being kicked we will flush our peer list
                        // else we will remove the peer from our known list and our connection
                        // table.
                        StringPayload payload = (StringPayload)msg.Payload;
                        RemovePeer(payload.Value, false);
                    }
                    break;
                case BusManager.ChannelListQuery:
                    lock(this)
                    {
                        List<string> values = new List<string>();
                        foreach(BusTracker tracker in _BusTrackerList)
                        {
                            string[] names = tracker.Bus.ChannelNames;
                            foreach(string name in names)
                            {
                                values.Add(name);
                            }
                        }

                        // Put the channel advertise from this lbm on the bus
                        Bus.Default.Publish(
                                BusManager.ChannelListAdvertise,
                                BusManager.ChannelName, 
                                msg.Src, 
                                new StringListPayload(values.ToArray()),
                                Message.AsyncDelivery);
                    }
                    break;
                case BusManager.RegisterPeer:
                    lock(this)
                    {
                        StringListPayload payload = msg.Payload as StringListPayload;
                        if(null != payload)
                        {
                            Connection conn = LookupPeerConnection(msg.SrcHost);
                            if(conn != null)
                            {
                                MessageError(msg, "Peer connection was not found for: " + msg.SrcHost);
                            }
                            else
                            {
                                foreach(string target in payload.Values)
                                {
                                    foreach(BusTracker tracker in _BusTrackerList)
                                    {
                                        tracker.Bus.RegisterChannel(target, conn);
                                    }
                                }
                            }
                        }
                    }
                    break;
                case BusManager.UnregisterPeer:
                    lock(this)
                    {
                        StringListPayload payload = msg.Payload as StringListPayload;
                        if(null != payload)
                        {
                            Connection conn = LookupPeerConnection(msg.SrcHost);
                            if(conn != null)
                            {
                                MessageError(msg, "Peer connection was not found for: " + msg.SrcHost);
                            }
                            else
                            {
                                foreach(string target in payload.Values)
                                {
                                    foreach(BusTracker tracker in _BusTrackerList)
                                    {
                                        tracker.Bus.UnregisterChannel(target, conn);
                                    }
                                }
                            }
                        }
                    }
                    break;
            } // end switch
        }

        private void MessageError(Message msg, string errorText)
        {
            _Report.Error("[MessageError]: An error occurred: {0}", errorText);
        }

        private Connection LookupPeerConnection(string hostExpr)
        {
            foreach(Connection conn in _Peers)
            {
                if(conn.EndPoint.ToString().StartsWith(hostExpr))
                {
                    return conn;
                }
            }

            return null;
        }

        public void Shutdown()
        {
            _ShutdownEvent.Set();
        }

        // 
        // The bus manager is given the ability to route messages
        // at global scope by the bus. We use this opportunity
        // to resolve externally host scoped messages and send
        // them over the correct connection.
        //
        public void RouteNetworkMessage(Message msg, string [] dstPathElements)
        {
            string srcHost;
            string dstHost;
            string localAddress;
            
            lock(this)
            {
                // Handle the case where the group manager connection 
                // has not initialized yet.
                if(null != _GroupManager)
                {
                    localAddress = _GroupManager.LocalAddress;
                }
                else
                {
                    localAddress = _LocalAddress.ToString();
                }

                dstHost = dstPathElements[0];

                //
                // Handle loopback addressing for the local bus
                //
                if(dstHost.StartsWith(localAddress) || BusManager.AnyHost == dstHost)
                {
                    // Remove the host scope operator to localize the message
                    // to this host. (Msg.Src will be correct in this context both on the local
                    // host and the remote receiving host)
                    Bus.Default.Publish(
                            msg.Name,
                            msg.Src,
                            dstPathElements[1],
                            msg.Payload,
                            msg.Flags);
                }

                srcHost = msg.SrcHost;
                
                //
                // If we are not the listen owner of the local group manager
                // connection we should route all messages not destined for
                // the local bus through the group manager. These messages
                // should not have had the source host filled out yet.
                if(         null != _GroupManager
                        &&  null == srcHost
                        &&  false == _GroupManager.IsListening
                        &&  dstHost != _GroupManager.LocalAddress)
                {
                    // Let the group manager handle routing
                    _GroupManager.SendMessage(msg);
                }
                else
                {
                    // Route through to peers and clients if the message originated on this host, if the message
                    // originated from another peer only route it through clients. The originating host
                    // has already done a directed peer or broadcast distribution
                    if(null == srcHost || srcHost.StartsWith(_LocalAddress.ToString()))
                    {
                        RouteNetworkMessage(_Peers, msg, srcHost, dstHost);
                        RouteNetworkMessage(_Clients, msg, srcHost, dstHost);
                    }
                    else
                    {
                        RouteNetworkMessage(_Clients, msg, srcHost, dstHost);
                    }
                }
            }
        }

        //
        // Route the message to peers in the peer table. 
        //
        private bool RouteNetworkMessage(List<Connection> hosts, Message msg, string srcHost, string dstHost)
        {
            bool exactMatch = false;

            if (null == srcHost)
            {
                srcHost = "";
            }

            lock(this)
            {
                foreach(Connection conn in hosts)
                {
                    // Valid route
                    if(BusManager.AnyHost == dstHost || dstHost.StartsWith(conn.EndPoint.Address.ToString()))
                    {
                        // Avoid recursive routing issues
                        if(srcHost == conn.RemoteAddress)
                        { 
                            // Don't loop messages back to clients
                            continue;   
                        }
                        else if (!srcHost.StartsWith(_LocalAddress.ToString()) && srcHost.StartsWith(conn.EndPoint.Address.ToString()))
                        {
                            // Don't loop messages back to peers
                            continue;
                        }

                        conn.SendMessage(msg);

                        // Optimization: if the host was exactly matched, end route search
                        if(dstHost == conn.RemoteAddress)
                        {
                            exactMatch = true;
                            break;
                        }
                    }
                }
            }

            return exactMatch;
        }

        //------------------------------------------------------------------------------
        // LBM connection management
        // 
        // Each connection object represents a full-duplex connection between a group
        // manager and a peer local manager. If at any time the group manager goes
        // away one of the peers will become the new group manager and all the other
        // peers will connect to the new group manager.
        //------------------------------------------------------------------------------
        protected internal class Connection : IMessageHandler
        {
            private const int DefaultContextBufferSize = 512;

            // Context used to track async message completions
            // for send
            private class SendContext
            {
                public uint             Id;
                public byte[]           Payload;
                public int              Pending;
            }

            private const uint DefaultSendTimeout = 10000;
            private const uint DefaultReceiveTimeout = 10000;
            private const uint MaxDeferredQueueSize = 2048;

            public enum State
            {
                Disconnected,
                Disconnecting,
                Connecting,
                Connected,
                Listening
            }

            // Connection settings
            private Socket          _Socket;

            // Local packet queue
            private State           _State;
            private uint            _NextContextId;
            private Exception       _Exception;
            private byte[]          _Scratch;
            private MemoryStream    _ReadBuffer;
            private IPEndPoint      _EndPoint;
            private BusManager      _Manager;
            private bool            _AutoRemoval;
            private uint            _ConnectionAttempts;
            private List<Message>   _DeferredMessageQueue;

            public string           RemoteAddress;
            public string           LocalAddress;

            // Last stamp of sync
            public uint             LastSync;

            //
            // Property accessors
            //
            public bool Connected {
                get {
                    return State.Disconnected != _State && State.Disconnecting != _State;
                }
            }

            public bool IsListening {
                get {
                    return State.Listening == _State;
                }
            }

            public bool IsDisconnected {
                get {
                    return State.Disconnected == _State;
                }
            }

            public State SocketState {
                get {
                    return _State;
                }
            }

            public uint ConnectionAttempts
            {
                get {
                    return _ConnectionAttempts;
                }
            }

            public bool IsDiconnected {
                get {
                    return State.Disconnected == _State;
                }
            }

            public IPEndPoint EndPoint {
                get {
                    return _EndPoint;
                }
            }

            //
            // When creating a new connection the bus manager will store the endpoint that
            // should be on the other side of the connection. The socket passed in may be null
            // because the connection object is allowed to be in a non-connected state.
            //
            public Connection(BusManager manager, Socket socket, IPEndPoint endpoint, bool autoRemoval)
            {
                _Manager            = manager;
                _EndPoint           = endpoint;
                _Scratch            = new byte[DefaultContextBufferSize * 4];
                _ReadBuffer         = new MemoryStream(DefaultContextBufferSize);
                _AutoRemoval        = autoRemoval;
                _DeferredMessageQueue = new List<Message>();

                AttachSocket(socket);
            }

            public void AttachSocket(Socket socket)
            {
                _Exception = null;
                _Socket = socket;

                if(null != _Socket && _Socket.Connected)
                {
                    _State = State.Connected;
                    _Socket.Blocking = false;
                    UpdateAddresses();
                }
                else
                {
                    _State = State.Disconnected;
                }
            }

            public void StartConnect()
            {
                AssertState(State.Disconnected);

                _Exception = null;
                _ConnectionAttempts++;
                _State  = State.Connecting;
                _Socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
                _Socket.Blocking = false;
                _Socket.BeginConnect(_EndPoint, new AsyncCallback(this.OnConnectComplete), this);
            }

            public void StartReconnect()
            {
                StartConnect(); 
            }

            private void OnConnectComplete(IAsyncResult ar)
            {
                try
                {
                    _Socket.EndConnect(ar);
                    _State = State.Connected;

                    UpdateAddresses();

                    _Socket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.SendTimeout, (int)DefaultSendTimeout);
                    _Socket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReceiveTimeout, (int)DefaultReceiveTimeout);
                    _Socket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, 1);

                    if(!_Socket.Connected)
                    {
                        throw new Exception("Unexpected: socket is in an unconnected state");
                    }

                    _Manager.NotifyConnectionComplete(this);
                }
                catch(Exception ex)
                {
                    HandleException(ex);
                }
            }

            public void StartListening()
            {
                _State  = State.Listening;
                _Socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
                _Socket.Blocking = false;

                _Socket.Bind(_EndPoint);
                _Socket.Listen(5);

                UpdateAddresses();

                _Socket.BeginAccept(new AsyncCallback(this.OnAcceptComplete), this);
            }

            private void OnAcceptComplete(IAsyncResult ar)
            {
                try
                {
                    // Wrap the incoming socket in a connection object
                    if(null != _Socket)
                    {
                        Socket s = _Socket.EndAccept(ar);

                        // Add the incoming connecting to the peer list of 
                        // the local manager if it coming from a different machine
                        // otherwise make the connection a client of the group manager
                        // connection
                        if((s.RemoteEndPoint as IPEndPoint).Address.Equals((_Socket.LocalEndPoint as IPEndPoint).Address))
                        {
                            _Manager.OnClientAccepted(s);
                        }
                        else
                        {
                            _Manager.OnPeerAccepted(s);
                        }
                        

                        // Prepare the next accept
                        _Socket.BeginAccept(new AsyncCallback(this.OnAcceptComplete), this);
                    }
                }
                catch(Exception ex)
                {
                    HandleException(ex);
                }
            }

            public void Disconnect()
            {
                Disconnect(false);
            }
            
            public void Disconnect(bool forceRemoval)
            {
                if(null != _Manager)
                {
                    // Normally we do not automatically remove peer connections, 
                    // the group manager might be migrating or other errors may pop
                    // up for these connections. We will try to re-open the connection 
                    // later in the maintainence thread and we use the connection object
                    // to maintain retry state and endpoint information.
                    if(forceRemoval || _AutoRemoval)
                    {
                        _Manager.RemoveConnection(this);
                        _Manager = null;
                    }
                }

                if(null != _Socket && _Socket.Connected)
                {
                    _State = State.Disconnecting;
                    _Socket.Shutdown(SocketShutdown.Send);
                    _Socket.BeginReceive(_Scratch, 0, _Scratch.Length, 0, new AsyncCallback(this.OnReceiveComplete), this);
                }
                else
                {
                    try
                    {
                        Socket s = _Socket;

                        // Clear members first in case the close throws
                        _Socket = null;
                        _State = State.Disconnected;

                        if(null != s)
                        {
                            s.Close();
                        }
                    }
                    catch(Exception)
                    {
                        // Ignore errors here on final shutdown
                    }
                }
            }

            
            public void SendMessage(Message msg)
            {
                // Provide some message queueing for connections that are
                // temporarily down
                if(null != _Socket && State.Connected == _State)
                {
                    if(_DeferredMessageQueue.Count > 0)
                    {
                        // Drain the entire queue first
                        foreach(Message deferred in _DeferredMessageQueue)
                        {
                            SendMessageInternal(deferred);
                        }

                        _DeferredMessageQueue.Clear();
                    }
                    SendMessageInternal(msg);
                }
                else
                {
                    if(_DeferredMessageQueue.Count < MaxDeferredQueueSize)
                    {
                        _DeferredMessageQueue.Add(msg);
                    }
                }
            }

            // 
            // When the message is sent the destination may need to be rewritten
            // to account for broadcast routing. An infinite loop could occur on 
            // the peer side if it doesn't know the message is intended for 
            // direct delivery
            //
            private void SendMessageInternal(Message msg)
            {
                string networkSrc;
                string networkDst;

                //
                // Only fill out the host portion of the message source on the 
                // originating connection. Any replies will have to be re-routed
                // to this connection object on the remote side using the provided
                // source.
                //
                if(null == msg.SrcHost)
                {
                    networkSrc = LocalAddress + Message.PathScopeOperatorString + msg.Src;
                }
                else
                {
                    networkSrc = msg.Src;
                }

                // Specify the host if one has not been specified
                if(null == msg.DstHost)
                {
                    networkDst = RemoteAddress + Message.PathScopeOperatorString + msg.DstChannel;
                }
                else
                {
                    networkDst = msg.Dst;
                }


                SendContext ctx = new SendContext();
                ctx.Id      = _NextContextId++;

                MemoryStream stream = new MemoryStream(DefaultContextBufferSize);
                BinaryWriter writer = new BinaryWriter(stream);

                // Serailize a placeholder for the message size
                writer.Write((int)0);

                // Serialize the message 
                SerializeMessage(writer, msg, networkSrc, networkDst);

                // Go back and write the size
                writer.Seek(0, SeekOrigin.Begin);
                writer.Write((int)stream.Length);

                // Turn the stream into a payload and push it to the async socket
                ctx.Payload = stream.ToArray();
                ctx.Pending = ctx.Payload.Length;

                _Socket.BeginSend(
                        ctx.Payload, 
                        0, 
                        ctx.Pending, 
                        0, 
                        new AsyncCallback(this.OnSendComplete), 
                        ctx);
            }

            private void OnSendComplete(IAsyncResult ar)
            {
                try
                {
                    int written = _Socket.EndSend(ar);
                    SendContext ctx = ar.AsyncState as SendContext;

                    if(null == ctx)
                    {
                        throw new ApplicationException("Invalid context async result state was null");
                    }

                    ctx.Pending -= written;

                    if(ctx.Pending < 0)
                    {
                        throw new ApplicationException("Invalid send, sent more bytes than were pending on context: " + ctx.Id);
                    }
                    else if(ctx.Pending > 0)
                    {
                        // Continue sending payload
                        _Socket.BeginSend(
                            ctx.Payload, 
                            ctx.Payload.Length - ctx.Pending, 
                            ctx.Pending, 
                            0, 
                            new AsyncCallback(this.OnSendComplete), 
                            ctx);
                    }
                }
                catch(Exception ex)
                {
                    HandleException(ex);
                }
            }

            public void StartReading()
            {
                if(State.Connected == _State || State.Disconnecting == _State)
                {
                    _Socket.BeginReceive(_Scratch, 0, _Scratch.Length, 0, new AsyncCallback(this.OnReceiveComplete), this);
                   
                }
                else
                {
                    throw new ApplicationException(
                            String.Format("Invalid connection state: {0} for StartReading() (requires Connected or Disconnecting)",
                                _State.ToString()));
                }
            }

            private void OnReceiveComplete(IAsyncResult ar)
            {
                try
                {
                    int received = 0;
                    
                    if(null != _Socket)
                    {
                        _Socket.EndReceive(ar);
                    }

                    if(0 == received)
                    {
                        // Socket was either intentionally closed locally by a previous call to disconnect
                        // or closed by the remote party 
                        _State = State.Disconnected;
                        Disconnect();
                        return;
                    }

                    if(received > _Scratch.Length)
                    {
                        throw new Exception("Invalid receive, received bytes exceeds scratch buffer size");
                    }

                    // Buffer reads at the end of the read buffer
                    _ReadBuffer.Seek(0, SeekOrigin.End);
                    _ReadBuffer.Write(_Scratch, 0, received);

                    // Parse header if we don't have it yet
                    if(_ReadBuffer.Length >= 4)
                    {
                        // Get a reader on the array
                        BinaryReader reader = new BinaryReader(_ReadBuffer);

                        // Read the size, determine if we have a full message
                        _ReadBuffer.Seek(0, SeekOrigin.Begin);
                        uint size = reader.ReadUInt32(); 
                        if(size <= (uint)_ReadBuffer.Length)
                        {
                            Message msg = DeserializeMessage(reader, size);

                            try
                            {
                                string []pathElements = msg.Dst.Split(
                                        new char[] {Message.PathScopeOperatorChar}, 
                                        StringSplitOptions.RemoveEmptyEntries);

                                if(pathElements.Length != 2)
                                {
                                    throw new ApplicationException(
                                            String.Format("Invalid destination in network destination path element: '{0}', did not specify a destination host path element", msg.Dst));
                                }

                                _Manager.RouteNetworkMessage(msg, pathElements);
                            }
                            catch(Exception ex)
                            {
                                _Report.Error("[OnReceiveComplete]: DistributeMessageFromConnection() failed for message: {0}\nDetails: {1}",
                                    msg.ToString(),
                                    ex.ToString());
                            }

                            // Reset the buffer size as we have processed the 
                            // message contained in the buffer
                            _ReadBuffer.SetLength(0);
                        }
                    }

                    StartReading(); 
                }
                catch(Exception ex)
                {
                    HandleException(ex);
                }
            }

            // 
            // Internal interface
            //
            private void HandleException(Exception ex)
            {
                Report.Root.Error("[Bus.Connection.HandleException]: There was a failure duing socket communication: " + ex.ToString());
                _Exception = ex;
                Disconnect();
            }

            private void AssertState(State state)
            {
                if(_State != state)
                {
                    _Exception = new ApplicationException(
                            String.Format("Connection: {0} was in invalid state: {1} != expected state {2}",
                                null != _Socket ? _Socket.ToString() : "<not connected>",
                                _State.ToString(),
                                state.ToString()));
                    _State = State.Disconnected;
                    _Socket = null;

                    throw _Exception;
                }
            }

            private void SerializeMessage(BinaryWriter writer, Message msg, string networkSrc, string networkDst)
            {
                Payload.WriteStringWithLength(writer, msg.Name);
                Payload.WriteStringWithLength(writer, networkSrc);
                Payload.WriteStringWithLength(writer, networkDst);

                byte []payloadBytes = msg.PayloadBytes;
                if(null != payloadBytes)
                {
                    writer.Write((int)msg.PayloadBytes.Length);
                    writer.Write(msg.PayloadBytes);
                }
                else
                {
                    writer.Write((int)0);
                }
            }

            private Message DeserializeMessage(BinaryReader reader, uint size)
            {
                Message msg = new Message();

                msg.Name = Payload.ReadStringWithLength(reader);
                msg.Src = Payload.ReadStringWithLength(reader);
                msg.Dst = Payload.ReadStringWithLength(reader);

                int msgPayloadSize = reader.ReadInt32();
                if(0 != msgPayloadSize)
                {
                    msg.PayloadBytes = reader.ReadBytes(msgPayloadSize);
                }

                return msg;
            }

            // Implemented from IMessageHandler
            // 
            // Messages arriving on this connection has subscribed to a specific channel,
            // if the messages don't have host specifiers make them explicit delivery.
            //
            public void HandleMessage(Message msg)
            {
                try
                {
                    SendMessage(msg);
                }
                catch(Exception ex)
                {
                    HandleException(ex);
                }
            }

            private void UpdateAddresses()
            {
                // We cache this information since disconnections
                // of the socket will cause it to go null
                if(State.Listening == _State)
                {
                    // Listening sockets do not have a remote endpoint
                    RemoteAddress = _Socket.LocalEndPoint.ToString();
                }
                else
                {
                    RemoteAddress = _Socket.RemoteEndPoint.ToString();
                }

                LocalAddress = _Socket.LocalEndPoint.ToString();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\livetest\core\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\livetest\core\ConfigLoader.cs ===
using System;
using System.Reflection;
using System.Xml;
using System.Collections.Generic;
using System.IO;

namespace livetest.core
{
    /// <summary>The exception thrown by the ConfigLoader class.</summary>
    public class ConfigLoaderException : Exception
    {
        /// <summary>See System.Exception(string)</summary>
        public ConfigLoaderException (string message) : base(message) { }
    }


    /// <summary>
    ///  Can only store public fields. Fields should be limited to int, uint, 
    ///  float, string, and bool. Fields can also be arrays of any of the
    ///  aforementioned data types.
    /// </summary>
    public interface SettingsObj { }


    /// <summary>
    ///  Responsible for loading configuration files that can be used in 
    ///  LiveTest.
    /// </summary>
    public class ConfigLoader
    {
        // Stores all the loaded assemblies in memory
        static Dictionary<string, AssemblyReference> assemblies;
        // Stores all the loaded xml configuration files
        static Dictionary<string, XmlDocument> xmlConfigs;

        static ConfigLoader ()
        {
            assemblies = new Dictionary<string, AssemblyReference>();
            xmlConfigs = new Dictionary<string, XmlDocument>();
        }

        /// <summary>
        ///  Loads settings from an XMLElement into an object of type T.
        /// </summary>
        public static T LoadSettingsObj<T> (XmlElement element)
            where T : SettingsObj, new()
        {
            // Initialize the type
            Type settingsType = typeof(T);
            T settingsObj = new T();

            // Fill out all the fields of the type
            foreach(XmlNode node in element.ChildNodes)
            {
                if(!(node is XmlElement))
                    continue;

                XmlElement setting = (XmlElement)node;

                if(setting.Name != "setting")
                    throw new ConfigLoaderException("The '"+settingsType.Name+"' XML element should only contain 'setting' XML elements.");

                string fieldName = setting.GetAttributeNode("name").Value;
                string fieldValue = setting.GetAttributeNode("value").Value;

                FieldInfo fieldInfo = settingsType.GetField(fieldName);

                if(fieldInfo == null)
                    throw new ConfigLoaderException("'"+settingsType.Name+"' does not contain a field called '"+fieldName+"'.");

                try
                {
                    if(fieldInfo.FieldType.IsArray)
                        fieldInfo.SetValue(settingsObj, parseArray(fieldInfo.FieldType, fieldValue));
                    else
                        fieldInfo.SetValue(settingsObj, parseData(fieldInfo.FieldType, fieldValue));

                }
                catch(Exception e)
                {
                    throw new ConfigLoaderException("Could not load value for field: "+fieldInfo.Name+"\nReason: "+e.Message);
                }
            }

            return settingsObj;
        }

        /// <summary>
        ///  Loads a xml configuration file and instantiates an instance of T.
        /// </summary>
        /// <typeparam name="T">Must inherit from SettingsObj</typeparam>
        /// <param name="xmlSettingsPath">Path to the xml configuration file 
        ///  to load the data into T.</param>
        /// <returns>A instance of T with its values set to those in the xml 
        ///  file.</returns>
        public static T LoadSettingsObj<T> (string xmlSettingsPath)
            where T : SettingsObj, new()
        {

            if(xmlSettingsPath == null)
                throw new ArgumentNullException("xmlSettingsPath cannot be null.");

            Type settingsType = typeof(T);

            // Load XML file
            XmlDocument xmlSettings = GetXMLDocument(xmlSettingsPath);
            XmlNodeList nodeList = xmlSettings.GetElementsByTagName(settingsType.Name);

            if(nodeList.Count != 1)
                throw new ConfigLoaderException("XML file malformed. Should contain one "+settingsType.Name+" XML node.");

            XmlElement element = (XmlElement)nodeList[0];

            return LoadSettingsObj<T>(element);
        }


        /// <param name="path">Path to the XML file to load.</param>
        /// <returns>An XmlDocument of the file loaded.</returns>
        public static XmlDocument GetXMLDocument (string path)
        {
            return getXMLDocument(MakePathAbsolute(path));
        }


        // Helper function for standardizing paths. All paths that this class 
        // deals with should be absolute.
        private static string MakePathAbsolute (string path)
        {
            if(Path.IsPathRooted(path))
                return path;

            return Path.GetFullPath(path);
        }

        // Handles lazy initialization of XML documents.
        private static XmlDocument getXMLDocument (string absPath)
        {
            if(xmlConfigs.ContainsKey(absPath))
                return xmlConfigs[absPath];

            // Not in cache, make one
            XmlDocument xmlDoc = new XmlDocument();
            xmlDoc.Load(absPath);

            xmlConfigs.Add(absPath, xmlDoc);

            return xmlDoc;
        }

        // Handles lazy initialization of AssemblyReferences
        private static AssemblyReference GetAsmReference (string absPath)
        {
            if(assemblies.ContainsKey(absPath))
                return assemblies[absPath];

            AssemblyReference asmRef = new AssemblyReference();
            asmRef.FullPath = absPath;
            asmRef.Instantiate();

            assemblies.Add(absPath, asmRef);

            return asmRef;
        }

        private static object parseArray (Type arrayType, string data)
        {
            string[] strElements = data.Split(',');
            Array elements = Array.CreateInstance(arrayType.GetElementType(), strElements.Length);
            for(int i=0; i<strElements.Length; i++)
                elements.SetValue(parseData(arrayType.GetElementType(), strElements[i]), i);
            return elements;
        }

        private static object parseData (Type type, string data)
        {
            if(type.Equals(typeof(Int32)))
                return Int32.Parse(data);

            else if(type.Equals(typeof(UInt32)))
                return UInt32.Parse(data);

            else if(type.Equals(typeof(UInt64)))
                return UInt64.Parse(data);

            else if(type.Equals(typeof(Single)))
                return Single.Parse(data);

            else if(type.Equals(typeof(Boolean)))
                return Boolean.Parse(data);

            else if(type.Equals(typeof(string)))
                return data;

            else
                throw new Exception("The data type: '"+type.FullName+"' is not supported in a '"+typeof(SettingsObj).FullName+"'.");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\livetest\core\Command.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;
using System.Text;

namespace livetest.core
{
	public class CommandLine
	{
		public class Switch
		{
			public string Name;
			public string[] Params = null;

			public Switch(string name)
			{
				Name = name;
			}
		}

		public bool HasSwitch(string name)
		{
			return Switches[name] != null;
		}

		public Hashtable Switches = new Hashtable();
		public string[] Params = null;
	}

	public class CommandLineParser
	{
		public class SwitchType
		{
			public string Name;
			public int NumArgs;
			public string ParamDescription;
			public string Description;
			public bool UsageVisible = true;
			public bool Shortcut = false;

			public SwitchType(string name, int numArgs, string paramDescription, string description)
			{
				Name = name;
				NumArgs = numArgs;
				ParamDescription = paramDescription;
				Description = description;
			}
		}

		private Hashtable switchTypes = new Hashtable();
		private string usage;
		private string notes;

		public CommandLineParser(string usage, string notes)
		{
			this.usage = usage;
			this.notes = notes;
		}

		public void AddSwitch(string name, int numArgs, string paramDescription, string description)
		{
			switchTypes[name] = new SwitchType(name, numArgs, paramDescription, description);
		}

		public void AddSwitch(string name, string description)
		{
			AddSwitch(name, 0, null, description);
		}

		public void AddSwitch(string name, int numArgs, string paramDescription, string description, bool shortcut)
		{
			SwitchType st = new SwitchType(name, numArgs, paramDescription, description);
			st.Shortcut = true;
			switchTypes[name] = st;

			st = new SwitchType(name, numArgs, paramDescription, description);
			st.UsageVisible = false;
			switchTypes[name.Substring(0, 1)] = st;
		}

		public void AddSwitch(string name, string description, bool shortcut)
		{
			AddSwitch(name, 0, null, description, shortcut);
		}

		public void AddSwitch(SwitchType st)
		{
			switchTypes[st.Name] = st;
		}

		public CommandLine Parse(string[] commandLine)
		{
			CommandLine cl = new CommandLine();
			ArrayList paramList = new ArrayList();
			for (int i = 0; i < commandLine.Length; i++)
			{
				string command = commandLine[i].ToLower();
				if (command.StartsWith("-") || command.StartsWith("/"))
				{
					command = command.Substring(1);

					SwitchType whichSwitch = (SwitchType)switchTypes[command];
					if (whichSwitch == null)
					{
						throw new Exception("Switch '/" + command + "' unknown.");
					}
					else
					{
						CommandLine.Switch s = new CommandLine.Switch(whichSwitch.Name);

						if (whichSwitch.NumArgs > 0)
						{
							ArrayList switchParamList = new ArrayList();
							for (int j = 0; j < whichSwitch.NumArgs; j++)
								switchParamList.Add(commandLine[++i].ToLower());
							s.Params = (string[])switchParamList.ToArray(typeof(string));
						}

						cl.Switches[s.Name] = s;
					}
				}
				else
				{
					paramList.Add(commandLine[i].ToLower());
				}
			}

			cl.Params = (string[])paramList.ToArray(typeof(string));
			return cl;
		}

		public void PrintUsage()
		{
			Console.WriteLine("Usage:");
			Console.WriteLine("  " + usage);
			Console.WriteLine("  Options include:");
			foreach (SwitchType st in switchTypes.Values)
			{
				if (!st.UsageVisible)
					continue;

				string name = st.Shortcut ? "(" + st.Name.Substring(0, 1) + ")" + st.Name.Substring(1) : st.Name;

				if (st.ParamDescription == null)
				{
					Console.WriteLine("    -" + name.PadRight(16, ' ') + (st.Description == null ? "" : st.Description));
				}
				else
				{
					Console.WriteLine("    -" + name + " " + st.ParamDescription);
					if (st.Description != null)
						Console.WriteLine("                    " + st.Description);
				}
			}

			Console.WriteLine();
			Console.WriteLine("  " + notes);
		}
	}

    public class CommandAttribute : Attribute
    {
        public string Help;

        public CommandAttribute()
        {
        }

        public CommandAttribute(string help)
        {
            Help = help;
        }
    }


    public class CommandManager
    {
        private class Binder
        {
            public object Instance;
            public MethodInfo Method;
        }

        private Dictionary<string, Binder> _Commands;

        public CommandManager() : this(null)
        {
        }

        public CommandManager(object o)
        {
            _Commands = new Dictionary<string, Binder>();
            RegisterCommands(o);
        }

        public void RegisterCommands(object o)
        {
            if(null != o)
            {
                foreach(MethodInfo method in o.GetType().GetMethods(BindingFlags.Instance|BindingFlags.NonPublic|BindingFlags.Public)) 
                {
                    foreach (Attribute attr in Attribute.GetCustomAttributes(method)) 
                    {
                        if (attr.GetType() == typeof(CommandAttribute))
                        {
                            ValidateCommandSignature(method);

                            Binder binder = new Binder();
                            binder.Instance = o;
                            binder.Method = method;

                            _Commands.Add(method.Name.ToLower(), binder);
                        }
                    }
                }
            }
        }

        private void ValidateCommandSignature(MethodInfo method)
        {
            ParameterInfo []parameters = method.GetParameters();
            foreach(ParameterInfo param in parameters)
            {
                if(param.IsOut)
                {
                    throw new ApplicationException("Can't execute commands that have 'out' parameters: " + param.Name);
                }
            }
        }

        public void ExecuteString(string str)
        {
            string []tokens = str.Split(new char[]{' ', '\t', '\n', ','}, StringSplitOptions.RemoveEmptyEntries);
            Binder binder;
            string command;
            
            if(0 == tokens.Length)
            {
                throw new CommandException("No command was given in tokens");
            }

            command = tokens[0].ToLower();
            
            if(_Commands.TryGetValue(command, out binder))
            {
                InvokeCommand(binder, tokens);
            }
            else
            {
                // Special case the help for commands
                if(tokens[0] == "help" || tokens[0] == "?")
                {
                    foreach (KeyValuePair<string, Binder> kv in _Commands) 
                    {
                        Report.Root.Info("Command: {0}", kv.Value.Method.Name);
                    }
                }
                else
                {
                    // Try to do partial match of command, command string
                    // only needs enough characters to make it unique
                    List<string> matches = new List<string>();
                    foreach (KeyValuePair<string, Binder> kv in _Commands) 
                    {
                        if(kv.Key.StartsWith(command))
                        {
                            matches.Add(kv.Value.Method.Name);
                        }
                    }

                    if(matches.Count > 1)
                    {
                        Report.Root.Info("Ambigious command matches:");
                        foreach(string name in matches)
                        {
                            Report.Root.Info("  {0}", name);
                        }
                    }
                    else if(matches.Count == 1)
                    {
                        InvokeCommand(_Commands[matches[0].ToLower()], tokens);
                    }
                    else
                    {
                        Report.Root.Error("Unknown command {0}", command);
                    }
                }
            }
        }

        private void InvokeCommand(Binder binder, string []tokens)
        {
            int iParam = 0;

            MethodInfo method = binder.Method;
            ParameterInfo []parameters = method.GetParameters();
            List<object> args = new List<object>();

            for(int iToken = 1; iToken < tokens.Length; ++iToken)
            {
                for(iParam = 0; iParam < parameters.Length; ++iParam)
                {
                    ParameterInfo param = parameters[iParam];
                    Type type = param.ParameterType;

                    // Convert the string parameter to the parameter type
                    // and add to the argument array.
                    object o = null;
                    try
                    {
                        o = Convert.ChangeType(tokens[iToken], type);
                    }
                    catch(Exception)
                    {
                        ThrowCommandException(binder.Method.Name, parameters);
                    }

                    if(null == o)
                    {
                        ThrowCommandException(binder.Method.Name, parameters);
                    }

                    args.Add(o);

                    iParam++;
                }
            }

            // Try to fill the rest with defaults
            for(; iParam < parameters.Length; ++iParam)
            {
                ParameterInfo param = parameters[iParam];
                if(typeof(System.DBNull) != param.DefaultValue.GetType())
                {
                    args.Add(param.DefaultValue);
                }
            }

            if(args.Count != parameters.Length)
            {
                ThrowCommandException(binder.Method.Name, parameters);
            }

            try
            {
                // Attempt the method call
                method.Invoke(binder.Instance, args.ToArray());
            }
            catch(TargetInvocationException ex)
            {
                if(null != ex.InnerException)
                {
                    throw new CommandException("Invocation failed for method: " + method.Name + ", exception: " + 
                            ex.InnerException.ToString());
                }

            }
        }

        private void ThrowCommandException(string methodName, ParameterInfo []parameters)
        {
            StringBuilder paramBuffer = new StringBuilder(64);
            foreach(ParameterInfo param in parameters)
            {
                paramBuffer.Append("Name: ");
                paramBuffer.Append(param.Name);
                paramBuffer.Append(", Type: ");
                paramBuffer.Append(param.ParameterType.FullName);
                paramBuffer.Append("\n");
            }
            throw new CommandException("Invalid arguments to method: " + methodName + " parameters:\n" + paramBuffer.ToString());
        }
    }

    public class CommandException : Exception
    {
        public CommandException(string msg)
            : base(msg)
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\livetest\core\ConsoleX.cs ===
//////////////////////////////////////////////////////////
// 
// Copyright  Microsoft Corporation.  All rights reserved
// MSN Search
//
//  File:   ConsoleX.cs
//
//  Summary:  ConsoleX class - extends standard Console  with CRT kbhit() and getch() methods 
//            and provides colored console output.
//
//  Author: V.Pinich (VladiP)
//  10/23/2001
//	
//  11/02/2001  Special thanks to Keith Stutler and Yann Christensen for useful advices
//	06/??/2002	Removed warnings (aaronlie)
//	02/21/2003	Added SetConsoleScreenBufferSize (reljam)
//
//////////////////////////////////////////////////////////

/* usage example

namespace ConsoleXtest
{  
  	using System;
	

	class App
	{
		static void Main()
		{
			int   i = 1234;
			float f = 23.263f;
			char  c = ' ';

			ConsoleX.WriteLine(CC.YELLOW, " ConsoleX output examples\n");

			ConsoleX.WriteLine(" Simple output without {} brackets:   int: ", i, "  float: ", f);
			ConsoleX.WriteLine(CC.BLUE, " Simple colored output: ", CC.GREEN, " int: ",i, "  float: ", f);

			ConsoleX.Write(CC.WHITE, "\n Formatted output: ", CC.GREEN, "f= ", f.ToString("000.0"));
			ConsoleX.Write("   Inversed default color: ", CC.INV, "i= ", i, " 0x", i.ToString("x") );

			ConsoleX.Write( CC.WHITE, "\n\n Default ", CC.GREEN, "background ", CC.RED, "output \n"); 
			ConsoleX.Write( CC.ABS, CC.B_WHITE, CC.BGND, " White   ", CC.RED, "background ", CC.BLUE, "output \n"); 
			ConsoleX.Write( CC.ABS, (byte)(CC.B_GRAY | CC.WHITE), "       white on gray       \n"); 
			ConsoleX.Write( CC.ABS, (byte)(CC.B_GREEN | CC.GREEN),"       green bar           \n\n"); 
		
			byte OldColor = ConsoleX.Write("Set global color:\n", CC.ABS, (byte)(CC.B_BLUE|CC.GRAY), CC.GLOBAL, " Same call\n");
			ConsoleX.Write(" New call \n");
			ConsoleX.Write(CC.WHITE," Restoring old console color: ", CC.ABS, OldColor, CC.GLOBAL, " here it is !!\n");

			ConsoleX.WriteLine(CC.YELLOW, "\n kbhit() + getch() example, hit any key to loop, hit Esc to exit\n" );
		
			while (c != 27)
			{
				if (ConsoleX.kbhit())
				{
					c = ConsoleX.getch();
					ConsoleX.WriteLine(CC.GREEN,"Key: ", c, "  code: ", CC.WHITE, ((int)c).ToString("d") );
				}

				System.Threading.Thread.Sleep(200);
			}
		}
	}
}
*/ 

using System;
using System.Text;
using System.IO;
using System.Text.RegularExpressions;
using System.Runtime.InteropServices;  // Must have to gain access to Win32 API attributes.

namespace livetest.core
{
	/// <summary>
	/// <p>class ConsoleX: Extends standard Console  with kbhit() and getch() methods and colored output.</p>
	/// 
	/// <p>uses MSVCR70.DLL Runtime library for kbhit() and getch()</p>
	/// <p>uses kernel32.dll and Win32 Console API for colored output</p>
	///  
	/// contacts: VladiP
	/// </summary>
	/// <example>
	/// <code>
	/// // write colored output for arg list without brackets {},  see comments in CC class  for color output details
	/// ConsoleX.WriteLine(CC.BLUE, " Simple colored output: ", CC.GREEN, " int: ",i, "  float: ", f);
	/// ConsoleX.Write(CC.WHITE, "\n Formatted output: ", CC.GREEN, "f= ", f.ToString("000.0")); 
	/// 
	/// // kbhit example
	/// while (27 != c)
	/// {
	///		if (ConsoleX.kbhit())
	///		{
	///			c = ConsoleX.getch();
	///			ConsoleX.WriteLine(CC.GREEN,"Key: ", c, "  code: ", CC.WHITE, ((int)c).ToString("d") );
	///		}
	///	}
	/// </code>
	/// </example>
	/// 
	public class ConsoleX
	{
		const short STD_INPUT_HANDLE  = -10;
		const short STD_OUTPUT_HANDLE = -11;
		const short STD_ERROR_HANDLE  = -12;

		[DllImport("kernel32")]
		static extern int GetStdHandle(int hStdHandle);

		[DllImport("kernel32")]
		static extern int SetConsoleTextAttribute( int hConsole, ushort Attribute); 

		[DllImport("kernel32", CharSet=CharSet.Unicode, EntryPoint = "SetConsoleTitleW")]
		static extern int SetTitle(string title); 

		[DllImport("kernel32")]
		static extern int GetConsoleScreenBufferInfo( int hConsole, ref CONSOLE_SCREEN_BUFFER_INFO cbInfo ); 

		[DllImport("kernel32")]
		static extern int SetConsoleScreenBufferSize( int hConsole, COORD Size ); 

		[DllImport("kernel32", CharSet=CharSet.Unicode, EntryPoint = "WriteConsoleW")]
		static extern int WriteConsole( int hConsole,
			String  pText,	int nTextLength, int nWritten, int nReserved);

		[DllImport("MSVCR70.DLL")]
		static extern bool _kbhit();

		[DllImport("MSVCR70.DLL")]
		static extern char _getch();

		private static StreamWriter sw = null;
		public static void SetFile(string filename)
		{
			if (sw != null)
			{
				sw.Flush();
				sw.Close();
			}

			if (filename == null)
			{
				sw = null;
				return;
			}

			Match m = new Regex(@"^(.+)\\(.+)$").Match(filename);
			string pathName = ".";
			if (m.Success)
				pathName = m.Groups[1].Value;

			Directory.CreateDirectory(pathName);
			sw = File.CreateText(filename);
		}

		public static char getch()
		{
			return _getch();
		}

		public static bool kbhit()
		{
			return _kbhit();
		}

		public static void SetConsoleTitle(string title)
		{
			ConsoleX.SetTitle(title);
		}

		public static int SetBufferSize(short width, short height)
		{
			int  hConsoleOut = GetStdHandle( STD_OUTPUT_HANDLE );
			COORD newSize=new COORD(width,height);
			int retCode=SetConsoleScreenBufferSize(hConsoleOut, newSize);
			return retCode;
		}

		public static int GetBufferWidth()
		{
			int  hConsoleOut = GetStdHandle( STD_OUTPUT_HANDLE );
			CONSOLE_SCREEN_BUFFER_INFO Info=new CONSOLE_SCREEN_BUFFER_INFO();
			int retCode=GetConsoleScreenBufferInfo(hConsoleOut, ref Info);
			return Info.dwSize.X;
		}

		public static void	PressAnyKey()
		{
			Console.Write("Press any key to continue ...\r");
			getch();
			ClearLine();
		}

		public static void	WriteSeparatorLine()
		{
			Console.WriteLine(new String('-',GetBufferWidth()-1));
		}

		public static void	WriteSeparatorLine(string title)
		{
			int bw = GetBufferWidth();
			Console.Write(title+" ");
			Console.WriteLine(new String('=',bw-title.Length-2));
		}
		

		public static void	ClearLine()
		{
			int bw = GetBufferWidth();
			if (bw == 0)
			{
				// This is debug output and we have to do the best we can...
				Console.Write("\n");
			}
			else
			{
				Console.Write("\r");
				Console.Write(new string(' ', bw-1));
				Console.Write("\r");
			}
		}

		public static void	SleepWithUserFeedback(int msecs) { SleepWithUserFeedback( msecs, "Waiting" ); }
		public static void	SleepWithUserFeedback(int msecs, string msg ) 
		{
			int updateTime=268;
			int totalWaitedTime=0;

			for (totalWaitedTime=0; totalWaitedTime<msecs; totalWaitedTime+=updateTime)
			{
				int percent=totalWaitedTime*100/msecs;
				WriteGuage(msg, percent);
				int timeToWait=Math.Min(msecs - updateTime, updateTime);
				System.Threading.Thread.Sleep(timeToWait);
			}

			ConsoleX.WriteLine();
		}
		
		public static void WriteGuage(string msg, int percent)
		{
			ClearLine();
			msg += " {0}% [";

			int blocks=9,i;
			for (i=0; i<(percent+blocks/2)/blocks; i++)
			{
				msg += "#";
			}
			for (; i<100/blocks; i++)
			{
				msg += ".";
			}
			msg += "]";
			Console.Write(msg,percent);
		}

		/// <summary>
		/// writes arg list to console, parameters with byte type will set color options for the next output items
		/// see comments in CC class  for color output details
		/// </summary>
		/// <param name="olist"> parameter list with optional byte type color modifiers </param>
		/// <returns> byte value - old default console color </returns>
		public static byte Write( params object[] olist  )
		{
			lock(typeof(ConsoleX))
			{
				CONSOLE_SCREEN_BUFFER_INFO cbInfo = new CONSOLE_SCREEN_BUFFER_INFO();		// Console information 
				int  hConsoleOut = GetStdHandle( STD_OUTPUT_HANDLE );					    // Handle to the console 

				GetConsoleScreenBufferInfo( hConsoleOut,  ref cbInfo );

				byte colorDEF  =  (byte) cbInfo.wAttributes; 
				byte colorLAST =  colorDEF;
				byte colorMODE =  CC.DEF;								// default color mode - related to default color
				bool SetGlobal =  false;								// indicates color restoring on return 

				foreach(object o in olist)
				{
					if (o is Byte)		// use byte value for color change -- was: if(o.GetType().Equals(typeof(System.Byte)))
					{
						byte colorNEW = (byte) o;			
						if( CC.ABS == colorNEW )			// use absolute color
						{
							colorMODE = CC.ABS;
							continue;
						}
						else if ( CC.BGND == colorNEW )		// use previous background
						{
							colorMODE = CC.BGND;
							continue;
						}
						else if ( CC.GLOBAL == colorNEW )	// use current color as global 
						{
							SetGlobal = true;
							continue;
						}
						else if ( CC.DEF == colorNEW )		// use default console color
						{
							colorMODE = CC.DEF;
							colorNEW  = colorDEF;
						}
						else if ( CC.INV == colorNEW )
						{
							if (CC.DEF == colorMODE)
								colorNEW  = (byte) (colorDEF ^ 0xFF);    // for default we invert default color
							else
								colorNEW  = (byte) (colorLAST ^ 0xFF);   // for absolute we invert last color
						}
						else if ( CC.DEF == colorMODE )
						{
							colorNEW  = (byte) ( (colorDEF & 0xF0) | (colorNEW & 0x0F) );
						}
						else if ( CC.BGND == colorMODE )
							colorNEW  = (byte) ( (colorLAST & 0xF0) | (colorNEW & 0x0F) );

						colorLAST =  colorNEW;
						SetConsoleTextAttribute(hConsoleOut, colorNEW );
					}
					else
					{
						Console.Write("{0}", o);
						if (sw != null)
							sw.Write("{0}", o);
					}
				}

				if (!SetGlobal)
					SetConsoleTextAttribute(hConsoleOut, cbInfo.wAttributes);		// restore old color

				return (byte)cbInfo.wAttributes;									// return old default color
			}
		}


		/// <summary>
		/// WriteLine: works as Write with new line at the end of parameter list
		/// </summary>
		/// <param name="olist"></param>
		/// <returns> byte value - old default console color </returns>
		public static byte WriteLine( params object[] olist  )
		{
			byte ret;
			lock( typeof(ConsoleX) )	
			{
				ret = Write( olist );
				Console.Write("\n");
				if (sw != null)
					sw.WriteLine();
			}
			return ret;
		}

	}


	/// <summary>
	/// class CC - contains color constants to be used with ConsoleX output methods.
	/// Thanks to Keith Stutler (KeithSt) -- he suggested to put all constants into public class
	/// </summary>
	public static class CC
	{
		public const byte DEF    = 0;				// use default console foreground and background colors for output
		public const byte ABS    = 0x8;				// use absolute coloring - not related to curent or default background
		public const byte INV    = 0x80;			// use inverted console color for output
		public const byte BGND   = 0x88;			// use current background for next output
		public const byte GLOBAL = 0xff;			// use current color or last color for this call as global console color

		public const byte F_BLUE      = 0x1;		//  text color contains blue.
		public const byte F_GREEN     = 0x2;		//  text color contains green.
		public const byte F_RED       = 0x4;		//  text color contains red.
		public const byte F_INTENSITY = 0x8;		//  text color is intensified.
		public const byte B_BLUE      = 0x10;		//  background color contains blue.
		public const byte B_GREEN     = 0x20;		//  background color contains green.
		public const byte B_RED       = 0x40;		//  background color contains red.
		public const byte B_INTENSITY = 0x80;		//  background color is intensified.
		public const byte B_GRAY      = 0x70;		//  background gray color.
		public const byte B_WHITE     = 0xF0;		//  background white color.

		public const byte BLUE    = F_INTENSITY | F_BLUE;				// 0x9
		public const byte GREEN   = F_INTENSITY | F_GREEN;				// 0xA
		public const byte RED     = F_INTENSITY | F_RED;				// 0xC

		public const byte YELLOW  = F_INTENSITY | F_RED   | F_GREEN;	
		public const byte PINK    = F_INTENSITY | F_RED   | F_BLUE;	
		public const byte AQUA    = F_INTENSITY | F_GREEN | F_BLUE;	
		public const byte GRAY    = 0x7;
		public const byte WHITE   = 0xF;

		public const byte DARK_BLUE    = F_BLUE;		// 0x1
		public const byte DARK_GREEN   = F_GREEN;		// 0x2
		public const byte DARK_RED     = F_RED;			// 0x4

		public const byte INFO    = GREEN;				// console color for info msgs
		public const byte ERROR   = RED;				// console color for error msgs
		public const byte WARNING = YELLOW;				// console color for warning msgs
	}

	/// <summary>
	/// Win32 API struct
	/// </summary>

	struct COORD 
	{ 
		public short X; 
		public short Y; 

		public COORD(short _X, short _Y)
		{
			X = _X;
			Y = _Y;
		}
	}

	/// <summary>
	/// Win32 API struct
	/// </summary>
	struct SMALL_RECT 
	{
		public short Left; 
		public short Top; 
		public short Right; 
		public short Bottom; 

		public SMALL_RECT(short _Left, short _Top, short _Right, short _Bottom)
		{
			Left = _Left;
			Top = _Top;
			Right = _Right;
			Bottom = _Bottom;
		}

	} 

	/// <summary>
	/// Win32 API struct
	/// </summary>
	struct CONSOLE_SCREEN_BUFFER_INFO 
	{ 
		public COORD      dwSize; 
		public COORD      dwCursorPosition; 
		public ushort     wAttributes; 
		public SMALL_RECT srWindow; 
		public COORD      dwMaximumWindowSize; 
	} 
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\livetest\core\Counter.cs ===
namespace livetest.core
{
    
    public class Counter
    {
        /// <summary>Value of Counter since the last call to Poll.</summary>
        public float Instance;

        /// <summary>
        ///  Overall value of counter, does not get reset when Poll is called.
        /// </summary>
        public float Total;

        /// <summary>Previous Instance value, before call to Poll.</summary>
        public float Last;

        /// <summary>Maximum reached value of Instance.</summary>
        public float Max;

        /// <summary>Minimum reached value of Instance.</summary>
        public float Min;

        /// <summary>
        ///  Last recorded rate at the time of the last call to Poll.
        /// </summary>
        public float Rate;

        /// <summary>
        ///  Creates a new Counter with all public fields initialized to 0.
        /// </summary>
        public Counter ()
        {
            Clear();
        }

        /// <summary>Sets Instance to 0.</summary>
        public void Zero ()
        {
            Instance = 0.0f;
        }

        /// <summary>Initializes all public fields to 0.</summary>
        public virtual void Clear ()
        {
            Instance    = 0.0f;
            Total       = 0.0f;
            Last        = 0.0f;
            Max         = 0.0f;
            Min         = 0.0f;
            Rate        = 0.0f;
        }

        /// <summary>Increments Instance and Total by v.</summary>
        /// <returns>New Instance value.</returns>
        public float Increment (float v)
        {
            Instance += v;
            Total += v;
            if(Instance > Max)
            {
                Max = Instance;
            }
            return Instance;
        }

        /// <summary>Decrements Instance and Total by v.</summary>
        /// <returns>New Instance value.</returns>
        public float Decrement (float v)
        {
            Instance -= v;
            Total -= v;
            if(Instance < Min)
            {
                Min = Instance;
            }
            return Instance;
        }

        /// <summary>Sets Instance and Total to v.</summary>
        /// <returns>New Instance value.</returns>
        public float Set (float v)
        {
            Instance = v;
            Total = v;

            if(Instance > Max)
            {
                Max = Instance;
            }
            if(Instance < Min)
            {
                Min = Instance;
            }
            return Instance;
        }

        /// <summary>
        ///  Calculates the rate, Instance/elapsed. Stores Instance into Last
        ///  and resets Instance to 0.
        /// </summary>
        /// <param name="elapsed"></param>
        public void Poll (float elapsed)
        {
            Last = Instance;
            Rate = Last / (elapsed + .000001f);
            Instance = 0;
        }

        /// <summary>c.Increment(v)</summary>
        public static float operator+ (Counter c, float v)
        {
            return c.Increment(v);
        }

        /// <summary>c.Decrement(v)</summary>
        public static float operator- (Counter c, float v)
        {
            return c.Decrement(v);
        }

        /// <summary>c.Increment(1.0f)</summary>
        public static Counter operator++ (Counter c)
        {
            c.Increment(1.0f);
            return c;
        }

        /// <summary>c.Decrement(1.0f)</summary>
        public static Counter operator-- (Counter c)
        {
            c.Decrement(1.0f);
            return c;
        }

        /// <returns>c.Instance</returns>
        public static explicit operator float (Counter c)
        {
            return c.Instance;
        }

        /// <summary>c.Set(v)</summary>
        public static explicit operator Counter (float v)
        {
            Counter c = new Counter();
            c.Set(v);
            return c;
        }

        /// <returns>Instance.ToString()</returns>
        public override string ToString ()
        {
            return Instance.ToString();
        }
    }

    
    public class RunningAverageCounter : Counter
    {
        
        public const uint DEFAULT_SAMPLES = 16;

        
        public float Average;
        
        public float[] Samples;
        
        public uint Count;
        uint _Index;

        
        public RunningAverageCounter ()
        {
            Allocate(DEFAULT_SAMPLES);
            Clear();
        }

        
        public RunningAverageCounter (uint count)
        {
            Allocate(count);
            Clear();
        }

        
        public void Allocate (uint count)
        {
            Count = count;
            Samples = new float[count];
            _Index = 0;
        }

        
        public void SampleValue (float v)
        {
            Instance = v;
            Total -= Samples[_Index];
            Total += v;
            Samples[_Index] = v;
            _Index = (_Index + 1) % Count;

            Average = Total / Count;
            if(Instance > Max)
            {
                Max = Instance;
            }
            if(Instance < Min)
            {
                Min = Instance;
            }
        }

        
        public override void Clear ()
        {
            base.Clear();
            Average = 0.0f;
            _Index = 0;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\livetest\core\ContextManager.cs ===
using System;

namespace livetest.core
{
    /// <summary>
    ///  <para>Interface for extension of allocation scheme before and after a
    ///   worker is run. If the contexts are available for a worker that would 
    ///   like to run then Acquire() returns true to the scheduler and the 
    ///   worker is run. If something fails or the worker completes the worker 
    ///   is passed back to the context manager to release any resources that 
    ///   were at one time attached.</para>
    /// 
    ///  <para>If you plan to make any test suite wide initializations, you 
    ///   should place them in the constructor of your implemented 
    ///   IContextManager.</para>
    /// </summary>
    public interface IContextManager
    {
        /// <summary>
        ///  Used by the Scheduler to prepare a worker and to make sure the 
        ///  worker can be prepared.
        /// </summary>
        /// <param name="types">The data that the Worker will use to perform 
        ///  its task.</param>
        /// <param name="worker">The Worker that will perform the task.</param>
        /// <returns>
        ///  true if the appropriate resources are available for the given 
        ///  task and worker. false if the given data cannot be run.
        /// </returns>
        bool Acquire (uint[] types, Worker worker);

        /// <summary>
        ///  Gets called when the Worker has completed its task. This method 
        ///  should provide the code to release any resources that the Worker
        ///  no longer needs.
        /// </summary>
        /// <param name="worker">Worker that has completed its task.</param>
        /// <returns>true if the Worker was released, false otherwise.</returns>
        bool Release (Worker worker);

        /// <summary>
        ///  Converts the string parameter read from the xml config file into a
        ///  uint that the scheduler can use to pass to Acquire to prepare a 
        ///  Worker.
        /// </summary>
        /// <param name="typeName">string parameter read from the xml 
        ///  configuration file.</param>
        /// <returns>A uint that uniquely represents the context type.</returns>
        uint ContextTypeNameToId (string typeName);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\livetest\core\Plugin.cs ===
using System;
using System.IO;
using System.Collections;
using System.ComponentModel;


namespace livetest.core
{
    public class PluginException : Exception
    {
        public PluginException(string msg) : base(msg)
        {
        }
    }

    //
    // Plugin services: By providing an implementation of a plugin
    // service interface the plugin writer can provide standard
    // functionality without having to worry about the bus messaging
    // details.
    //
    

    // Topology service allows the plugin to provide a description 
    // of object containment and a set of generic actions that be
    // be provided on the topology.
    public interface IPluginTopologyProvider
    {
        string[]        GetActions();
        TopologyNode    ReadTopology(string []path);
        void            ExecuteNodes(string path, byte []actions);
    }

    // Daemon services are long running automated processes
    public interface IPluginServiceController
    {
        string[]        GetServices();
        void            Start(string serviceName);
        void            Stop(string serviceName);
    }

    public class Plugin : IMessageHandler, IServiceProvider
    {
        IPluginTopologyProvider  _TopologyProvider;
        IPluginServiceController _ServiceController;

        // This is the name assigned from the plugin loader
        // and is also used to register this plugin on a bus channel
        public string Name;

        public Plugin()
        {
        }

        //
        // Plugin event overrides
        //
        public virtual void OnPluginLoaded()
        {
        }

        public virtual void OnPluginUnloaded()
        {
        }

        // 
        // From IMessageHandler
        //

        // Do some plugin message routing
        public virtual void HandleMessage(Message msg)
        {
            if(msg.Name.StartsWith("Topology"))
            {
                HandleTopologyMessage(msg);
            }
            else if(msg.Name.StartsWith("Service"))
            {
                HandleServiceMessage(msg);
            }
            else if(msg.Name.StartsWith("Plugin"))
            {
                HandlePluginMessage(msg);
            }
        }

        //
        // From IServiceProvider, override to provide your own plugin services
        //
        public virtual object GetService(Type type)
        {
            return null;
        }

        // This private method is responsible for bootstrapping any known service
        // instances from the plugin provider that are implemented
        private void InitializeAllServices()
        {
            _TopologyProvider = (IPluginTopologyProvider)GetService(typeof(IPluginTopologyProvider));
            _ServiceController = (IPluginServiceController)GetService(typeof(IPluginServiceController));
        }

        // Private message handler for topology messages
        protected virtual void HandleTopologyMessage(Message msg)
        {
            if(null == _TopologyProvider)
            {
                return;
            }

            try
            {
                switch(msg.Name)
                {
                    case Topology.GetActions:
                        Bus.Default.Publish(
                                Topology.GetActionsReply,
                                Name,
                                msg.Src,
                                new StringListPayload(_TopologyProvider.GetActions()));
                        break;
                    case Topology.Read:
                        {
                            StringListPayload request = (StringListPayload)msg.Payload;
                            TopologyNode node = _TopologyProvider.ReadTopology(request.Values);
                            Bus.Default.Publish(
                                    Topology.ReadReply,
                                    Name,
                                    msg.Src,
                                    new TopologyPayload(node));
                        }

                        break;
                    case Topology.ExecuteNodes:
                        {
                            TopologyExecutePayload payload = (TopologyExecutePayload)msg.Payload;
                            _TopologyProvider.ExecuteNodes(payload.Path, payload.Actions);
                        }
                        break;
                }
            }
            catch(Exception ex)
            {
                Bus.Default.Publish(
                        BusManager.Error,
                        Name,
                        msg.Src,
                        new StringPayload(ex.ToString()));
            }
        }

        // Private message handler for service messages
        protected virtual void HandleServiceMessage(Message msg)
        {
            switch(msg.Name)
            {
                case "ServiceQueryAll":
                    break;
                case "ServiceStart":
                    break;
                case "ServiceStop":
                    break;
            }
        }

        // Private message handler for plugin messages 
        protected virtual void HandlePluginMessage(Message msg)
        {
            switch(msg.Name)
            {
                case "PluginLoaded":
                    {
                        InitializeAllServices();
                        OnPluginLoaded();
                    }
                    break;
                case "PluginUnloaded":
                    {
                        OnPluginUnloaded();
                    }
                    break;
            }
        }
    }

    public class PluginLoader : DllLoader
    {
        private class PluginReference
        {
            public string            Name;
            public string            FullPath;
            public AssemblyReference AsmRef;
            public Plugin            Instance;
        }

        private Hashtable _Plugins;

        public PluginLoader()
        {
            _Plugins = new Hashtable();
        }

        public string[] Names
        {
            get {
                ArrayList names = new ArrayList(_Plugins.Count);
                IDictionaryEnumerator it = _Plugins.GetEnumerator();
                while(it.MoveNext())
                {
                    names.Add(it.Key as string);
                }

                return (string[])names.ToArray(typeof(string));
            }
        }
         
        public void LoadAll()
        {
            // Get all of the paths registered to find plugin DLLs
            PathResolver resolver = PathResolver.Default;
            string []paths = resolver.GetPaths("plugin");

            // Enumerate each file in each registered path
            foreach(string path in paths)
            {
                string []files = Directory.GetFiles(path, "*.dll");
                foreach(string file in files)
                {
                    try
                    {
                        LoadPluginFromFile(Path.GetFileNameWithoutExtension(file).ToLower(), file, true);
                    }
                    catch(Exception ex)
                    {
                        Report.Root.Error("Failed to load a plugin from file: {0}, exception thrown: {1}",
                                file,
                                ex.ToString());
                    }
                }
            }
        }

        public void LoadPlugin(string name)
        {
            name = name.ToLower();

            PathResolver resolver = PathResolver.Default;

            if(null != _Plugins[name])
            {
                throw new PluginException("Plugin: " + name + " already loaded");
            }
            
            string fileName = name + ".dll";
            string fullFileName;

            if(resolver.Resolve("plugin", fileName, out fullFileName))
            {
                LoadPluginFromFile(name, fullFileName, false);
            }
            else
            {
                throw new PluginException("No such plugin: " + name + ", filename: " + fileName);
            }
        }

        private void LoadPluginFromFile(string name, string fullFileName, bool instantiate)
        {
            if(_Plugins.Contains(name))
            {
                throw new PluginException("Tried to load load the same plugin twice, name: " + name + 
                        ", fullFileName: " + fullFileName + 
                        ", intantiate: " + instantiate);
            }

            AssemblyReference asmRef = base.LoadDll(fullFileName);

            // Create the plugin reference
            PluginReference pluginRef = new PluginReference();
            pluginRef.Name      = name;
            pluginRef.FullPath  = fullFileName;
            pluginRef.AsmRef    = asmRef;
            pluginRef.Instance  = null;
            _Plugins[name] = pluginRef;

            if(instantiate)
            {
                InstantiatePluginReference(pluginRef);
            }
        }

        public void Instantiate(string name)
        {
            PluginReference pluginRef = _Plugins[name] as PluginReference;
            if(null == pluginRef)
            {
                throw new PluginException("Plugin not registered: " + name);
            }

            InstantiatePluginReference(pluginRef);
        }

        private void InstantiatePluginReference(PluginReference pluginRef)
        {
            if(null != pluginRef.Instance)
            {
                throw new PluginException("Plugin has already been instantiated: " + pluginRef.Name);
            }

            // Instantiate the assembly
            pluginRef.AsmRef.Instantiate();

            // Inspect the assembly to get the plugin
            Type[] eTypes = pluginRef.AsmRef.Asm.GetExportedTypes();
            foreach( Type t in eTypes )
            {
                if(t.IsSubclassOf(typeof(livetest.core.Plugin)))
                {
                    pluginRef.Instance = pluginRef.AsmRef.Asm.CreateInstance( t.FullName, true) as Plugin;
                    break;
                }
            }

            if(null == pluginRef.Instance)
            {
                throw new PluginException("Could not find type of class: livetest.core.Plugin in assembly: " + pluginRef.FullPath);
            }
            else
            {
                // Copy the name into the plugin so it knows how it is referenced
                pluginRef.Instance.Name = pluginRef.Name;

                // Wire the plugin into the bus on the local channel identified by it's name
                Bus.Default.RegisterChannel(pluginRef.Name, pluginRef.Instance);

                // Fire the first message to notify the plugin 
                // that it has loaded on another thread
                Bus.Default.Publish(
                        "PluginLoaded",
                        Bus.AnyChannel, 
                        pluginRef.Name, 
                        new StringPayload(pluginRef.Name),
                        Message.AsyncDelivery);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\livetest\core\PriorityQueue.cs ===
using System;
using System.Collections.Generic;

namespace livetest.core
{
    /// <summary>
    ///  This class represents a thread safe priority queue. Everytime an 
    ///  element is added to the PriorityQueue, it is placed at the 
    ///  appropriate position based on the natural ordering of the given 
    ///  element type T. Thus, Enqueing is an O(log n) operation since it 
    ///  uses BinarySearch to add the element. All other operations are order 
    ///  O(1) except for Dequeue which is O(n). The invariant of this class 
    ///  is that the element at the front of the PriorityQueue is the smallest 
    ///  element in the PriorityQueue. This class should be revised to use a 
    ///  tree as the internal data structure (such as an RB-Tree) so that all
    ///  operations can be O(lg n).
    /// </summary>
    /// <typeparam name="T">Element of this PriorityQueue. This type must 
    ///  implement the generic IComparable interface.</typeparam>
    public class PriorityQueue<T> : IEnumerable<T>
        where T : IComparable<T>
    {
        // Stores the state of this PriorityQueue
        private List<T> internalList;


        /// <summary>
        ///  Initializes a new instace of a PriorityQueue.
        /// </summary>
        public PriorityQueue ()
        {
            internalList = new List<T>();
        }


        /// <summary>This method takes O(log n) time.</summary>
        /// <param name="item">Item to enqueue in the PriorityQueue.</param>
        public void Enqueue (T item)
        {
            lock(internalList)
            {
                int index = internalList.BinarySearch(item);

                if(index < 0)
                { // Not in the list
                    // Debug - remove when finished testing
                    if(~index > internalList.Count)
                        throw new Exception("BinarySearch returned a index compliment greater than count.");//debug
                    // End Debug

                    internalList.Insert(~index, item);

                }
                else
                {
                    // Debug - remove when finished testing
                    if(index == internalList.Count)
                        throw new Exception("BinarySearch returned an index equal to count.");//debug
                    if(index > internalList.Count)
                        throw new Exception("BinarySearch returned an index greater than count.");//debug
                    // End Debug

                    internalList.Insert(index+1, item);
                }
            }
        }


        /// <summary>
        ///  This method removes the item at the front of the PriorityQueue in 
        ///  O(n) time and returns it.
        /// </summary>
        /// <returns>The item at the front of the Queue.</returns>
        /// <exception cref="InvalidOperationException">
        ///  Thrown if PriorityQueue.Count == 0.</exception>
        public T Dequeue ()
        {
            lock(internalList)
            {
                if(internalList.Count == 0)
                    throw new InvalidOperationException("The PriorityQueue is empty.");

                T item = internalList[0];
                internalList.RemoveAt(0);
                return item;
            }
        }


        /// <summary>
        ///  This method does not modify the PriorityQueue. O(1) time 
        ///  operation.
        /// </summary>
        /// <returns>The item at the front of the Queue.</returns>
        /// <exception cref="InvalidOperationException">
        ///  Thrown if PriorityQueue.Count == 0.</exception>
        public T Peek ()
        {
            lock(internalList)
            {
                if(internalList.Count == 0)
                    throw new InvalidOperationException("The PriorityQueue is empty.");

                return internalList[0];
            }
        }


        /// <summary>O(1) operation.</summary>
        /// <value>The number of items in this PriorityQueue.</value>
        public int Count
        {
            get {
                lock(internalList)
                {
                    return internalList.Count;
                }
            }
        }

        #region IEnumerable<T> Members

        /// <returns>An IEnumerator over this PriorityQueue.</returns>
        public IEnumerator<T> GetEnumerator ()
        {
            return internalList.GetEnumerator();
        }

        #endregion

        #region IEnumerable Members

        /// <returns>An IEnumerator over this PriorityQueue.</returns>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator ()
        {
            return internalList.GetEnumerator();
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\livetest\core\Message.cs ===
using System;
using System.IO;
using System.Text;
using System.Reflection;
using System.Collections.Generic;

namespace livetest.core
{
	public class Message
	{
        //
        // Publish flags
        //

        // Async deliver will deliver the message on a background
        // thread and message publish will return immediately
        public const uint AsyncDelivery = 0x00000001;


        //
        // When specifying source and destination paths the host and 
        // channel should be seperated with the scope operator
        //
        public const char   PathScopeOperatorChar   = '/';
        public const string PathScopeOperatorString = "/";

		public string   Name;
        public string   Src;
        public string   Dst;
        public uint     Flags;

        // Payloads are not serialized or deserialized until they need to cross
        // some process boundary. The public Payload accessor makes this invisible
        // to the caller.
        private Payload _Payload;
        private byte[] _PayloadBytes;

        public byte[]   PayloadBytes
        {
            get {
                if(null == _PayloadBytes && null != _Payload)
                {
                    MemoryStream stream = new MemoryStream(128);
                    BinaryWriter writer = new BinaryWriter(stream);

                    // Serialize the name so it can be handled on the other end without
                    // any extra help
                    Payload.WriteStringWithLength(writer, _Payload.GetType().FullName);
                    _Payload.Write(writer);

                    _PayloadBytes = stream.ToArray();
                }

                return _PayloadBytes;
            }
            set {
                _Payload = null;
                _PayloadBytes = value;
            }
        }

        public Payload  Payload
        {
            get {
                if(null == _Payload && null != _PayloadBytes)
                {
                    BinaryReader reader = new BinaryReader(new MemoryStream(_PayloadBytes));
                    string typeName = Payload.ReadStringWithLength(reader);
                    Type payloadType = Type.GetType(typeName);

                    if(payloadType.IsSubclassOf(typeof(livetest.core.Payload)))
                    {
                        // Get the default constructor and create instance
                        ConstructorInfo constructor = payloadType.GetConstructor(Type.EmptyTypes);
                        if(null == constructor)
                        {
                            string msg = String.Format("Payload type: {0} did not provide a default constructor", payloadType.FullName);
                            throw new ApplicationException(msg);
                        }

                        _Payload = constructor.Invoke(new Object[0]) as Payload;

                        // Deserialize the rest of the payload
                        if(null != _Payload)
                        {
                            _Payload.Read(reader);
                        }
                    }
                    else
                    {
                        throw new ApplicationException("Type: " + typeName + " is not a subclass of livetest.core.Payload");
                    }
                }

                return _Payload;
            }
            set {
                _Payload = value;
                _PayloadBytes = null;
            }
        }

        public string SrcHost
        {
            get {
                string []pathElements = Src.Split(
                        new char[] {PathScopeOperatorChar}, 
                        StringSplitOptions.RemoveEmptyEntries);
                if(pathElements.Length > 1)
                {
                    return pathElements[0];
                }
                else
                {
                    return null;
                }
            }
        }

        public string SrcChannel
        {
            get {
                string []pathElements = Src.Split(
                        new char[] {PathScopeOperatorChar}, 
                        StringSplitOptions.RemoveEmptyEntries);
                if(pathElements.Length > 1)
                {
                    return pathElements[1];
                }
                else
                {
                    return Src;
                }
            }
        }

        public string DstHost
        {
            get {
                string []pathElements = Dst.Split(
                        new char[] {PathScopeOperatorChar}, 
                        StringSplitOptions.RemoveEmptyEntries);
                if(pathElements.Length > 1)
                {
                    return pathElements[0];
                }
                else
                {
                    return null;
                }
            }
        }

        public string DstChannel
        {
            get {
                string []pathElements = Dst.Split(
                        new char[] {PathScopeOperatorChar}, 
                        StringSplitOptions.RemoveEmptyEntries);
                if(pathElements.Length > 1)
                {
                    return pathElements[1];
                }
                else
                {
                    return Dst;
                }
            }
        }


        public override string ToString()
        {
            return String.Format("Name: {0}, Src: {1}, Dst: {2}, Flags: 0x{3:x8}, Payload: {4}",
                Name,
                Src,
                Dst,
                Flags,
                null != _Payload ? _Payload.GetType().FullName : "<null>");
        }
    }
	
    // Interface responsible for handing message objects and providing a
    // unique local bus specific identifier
	public interface IMessageHandler
	{
        void HandleMessage(Message msg);
	}

    public class Payload
    {
        public const int MaxPayloadStringSize = 512;
 
        public virtual void Write(BinaryWriter writer)
        {
            throw new ApplicationException("Write() not implemented");
        }

        public virtual void Read(BinaryReader reader)
        {
            throw new ApplicationException("Read() not implemented");
        }

        public static explicit operator byte [] (Payload payload)
        {
            MemoryStream stream = new MemoryStream();
            payload.Write(new BinaryWriter(stream));
            return stream.ToArray();
        }

        public void FromBytes(byte[] payload)
        {
            MemoryStream stream = new MemoryStream(payload);
            BinaryReader reader = new BinaryReader(stream);
            Read(reader);
        }

        public static void WriteStringWithLength(BinaryWriter writer, string str)
        {
            if(null != str && str.Length > MaxPayloadStringSize)
            {
                throw new ArgumentException("Payload strings larger than " + MaxPayloadStringSize + " are not allowed");
            }

            if(null != str && str.Length > 0)
            {
                byte[] encoded = new UTF8Encoding().GetBytes(str);
                writer.Write((int)encoded.Length);
                writer.Write(encoded);
            }
            else
            {
                writer.Write((int)0);
            }
        }

        public static string ReadStringWithLength(BinaryReader reader)
        {
            string str = null;

            // Get the utf-8 encoded string
            int length = reader.ReadInt32();
            if(length > MaxPayloadStringSize)
            {
                throw new ApplicationException("Payload strings larger than " + MaxPayloadStringSize + " are not allowed");
            }

            if(length > 0)
            {
                byte[] encoded = reader.ReadBytes(length);
                str = new UTF8Encoding().GetString(encoded, 0, length);
            }

            return str;
        }
    }

	public class StringPayload : Payload
	{
		public string Value;

        public StringPayload()
        {
        }

        public StringPayload(string strValue)
        {
            Value = strValue;
        }

        public override void Write(BinaryWriter  writer)
        {
            WriteStringWithLength(writer, Value);
        }

        public override void Read(BinaryReader reader)
        {
            Value = ReadStringWithLength(reader);
        }

        public override string ToString()
        {
            return (null != Value ? Value : "<nodata>");
        }
	}

    public class StringListPayload : Payload
    {
        public string []Values;

        public StringListPayload()
        {
        }

        public StringListPayload(string []values)
        {
            Values = values;
        }

        public StringListPayload(params object [] values)
        {
            List<string> valueList = new List<string>(values.Length);

            foreach(string str in values)
            {
                valueList.Add(str);
            }

            Values = valueList.ToArray();
        }

        public override void Write(BinaryWriter writer)
        {
            writer.Write(Values.Length);
            foreach(string str in Values)
            {
                WriteStringWithLength(writer, str);
            }
        }

        public override void Read(BinaryReader reader)
        {
            int nStrings;
            nStrings = reader.ReadInt32();

            Values = new string[nStrings];

            for(int i = 0; i < nStrings; ++i)
            {
                Values[i] = ReadStringWithLength(reader);
            }
        }

        public override string ToString()
        {
            if(null != Values)
            {
                StringBuilder buf = new StringBuilder(128);
                foreach(string str in Values)
                {
                    if(buf.Length > 0)
                    {
                        buf.Append(", ");
                    }
                    buf.Append(str);
                }
                return buf.ToString();
            }
            else
            {
                return "<nodata>";
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\livetest\core\Report.cs ===
using System;
using System.Text;
using System.IO;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text.RegularExpressions;

namespace livetest.core
{
    /// <summary>
    ///  Reporting tool used by LiveTest.
    /// </summary>
    public class Report
    {
        /// <summary>
        ///  Bit flags used for specifying the logging level of a report.
        /// </summary>
        [Flags]
        public enum Level
        {
            /// <summary>Should not be used.</summary>
            NONE,
            /// <summary>Debug level.</summary>
            DEBUG,
            /// <summary>Info level.</summary>
            INFO,
            /// <summary>Warn level.</summary>
            WARN,
            /// <summary>Error level.</summary>
            ERROR,
            /// <summary>Fatal level.</summary>
            FATAL,
            /// <summary>Success level.</summary>
            SUCCESS
        }


        /// <summary>Interface needed to a log message sink.</summary>
        public interface Destination
        {
            /// <summary>Logs an event.</summary>
            /// <param name="level">Level to log.</param>
            /// <param name="path">string path to log file.</param>
            /// <param name="message">A string to log.</param>
            void Log (Level level, string path, string message);
        }


        // create the root report
        static Report _Root = new Report();
        Report _Parent;
        string _Name;
        string _Category;
        List<Destination> _Destinations;
        Level _Filter;


        /// <value>The name of this Report.</value>
        public string Name
        {
            get { return _Name; }
        }


        /// <value>The category of this Report.</value>
        public string Category
        {
            get { return _Category; }
        }


        /// <value>The logging Level to filter of the Report.</value>
        public Level Filter
        {
            get { return _Filter; }
            set { _Filter = value; }
        }


        /// <summary>Get the global root reporting destination.</summary>
        public static Report Root
        {
            get {
                return _Root;
            }
        }


        /// <summary>
        ///  Default constructor only to be called by the static initializer.
        /// </summary>
        protected Report ()
        {
            _Parent = null;
            _Category = "Global";
            _Name = "";
            _Filter = Level.DEBUG|Level.INFO|Level.WARN|Level.ERROR|Level.FATAL|Level.SUCCESS;
            _Destinations = null;
        }


        /// <summary>
        /// Create a new report object that will be placed under the root report.
        /// </summary>
        /// <param name="Category">Category of logging</param>
        /// <param name="Name">Name of specific log</param>
        public Report (string Category, string Name)
        {
            _Parent = Report.Root;
            _Category = Category;
            _Name = Name;
            _Filter = Level.DEBUG|Level.INFO|Level.WARN|Level.ERROR|Level.FATAL|Level.SUCCESS;
            _Destinations = null;
        }


        /// <summary>
        ///  Create a new report that inherits it's properties from
        ///  a parent report. Name must be specified for every report seperately.
        /// </summary>
        /// <param name="parent">Report to inherit properties from.</param>
        /// <param name="Name">Name of this Report.</param>
        public Report (Report parent, string Name)
        {
            _Parent = parent;
            _Category = _Parent._Category;
            _Filter = _Parent._Filter;
            _Name = Name;
            _Destinations = null;
        }


        /// <summary>
        ///  Create a new default style Report with a given name and 
        ///  unspecified category. This Report will automatically be attached 
        ///  to the root reporting object.
        /// </summary>
        /// <param name="Name">Name of this Report.</param>
        public Report (string Name)
        {
            _Parent = Report.Root;
            _Category = _Parent.Category;
            _Filter = _Parent.Filter;
            _Name = Name;
            _Destinations = null;
        }


        /// <summary>
        ///  Add a new reporting destination to the internal list of reporters.
        /// </summary>
        /// <param name="dest">Class conforming to abstract protocol 
        ///  Destination</param>
        public void AddReportDestination (Destination dest)
        {
            if(_Destinations == null)
                _Destinations = new List<Destination>();
            _Destinations.Add(dest);
        }


        /// <summary>
        ///  Remove a new reporting destination by reference.
        /// </summary>
        /// <param name="dest">Class conforming to abstract protocol 
        ///  Destination</param>
        public void RemoveReportDestination (Destination dest)
        {
            if(_Destinations != null)
            {
                _Destinations.Remove(dest);
            }
        }


        /// <summary>
        ///  Return a list of all destinations for this report.
        /// </summary>
        /// <returns>ArrayList of Destinations.</returns>
        public List<Destination> GetReportDestinations ()
        {
            return _Destinations;
        }


        /// <summary>
        ///  Remove all reporting destinations.
        /// </summary>
        public void ResetDestinations ()
        {
            if(_Destinations != null)
                _Destinations.Clear();
        }


        void Log (Level level, string name, string message)
        {
            if((level & _Filter) == 0)
            {
                return;
            }

            if(_Destinations != null && _Destinations.Count > 0)
            {
                foreach(Destination dest in _Destinations)
                {
                    // Added lock to make writing to a destination thread safe 
                    // (t-robtos)
                    lock(dest)
                    {
                        dest.Log(level, name, message);
                    }
                }
            }

            if(_Parent != null)
            {
                _Parent.Log(level, name, message);
            }
        }


        /// <summary>
        ///  Log a message at DEBUG priority.
        /// </summary>
        /// <param name="message">String to send to logs.</param>
        public void Debug (string message)
        {
            Log(Level.DEBUG, _Name, message);
        }


        /// <summary>
        ///  Log a message at DEBUG priority.
        /// </summary>
        /// <param name="format">Format string applied to objets.</param>
        /// <param name="args">Object paramaters to use in format string.
        /// </param>
        public void Debug (string format, params object[] args)
        {
            Log(Level.DEBUG, _Name, String.Format(format, args));
        }


        /// <summary>
        ///  Log a message at INFO priority.
        /// </summary>
        /// <param name="message">String to send to logs.</param>
        public void Info (string message)
        {
            Log(Level.INFO, _Name, message);
        }


        /// <summary>
        ///  Log a message at INFO priority.
        /// </summary>
        /// <param name="format">Format string applied to objets.</param>
        /// <param name="args">Object paramaters to use in format string.
        /// </param>
        public void Info (string format, params object[] args)
        {
            Log(Level.INFO, _Name, String.Format(format, args));
        }


        /// <summary>
        ///  Log a message at WARNING priority.
        /// </summary>
        /// <param name="message">String to send to logs.</param>
        public void Warn (string message)
        {
            Log(Level.WARN, _Name, message);
        }


        /// <summary>
        ///  Log a message at WARNING priority.
        /// </summary>
        /// <param name="format">Format string applied to objets.</param>
        /// <param name="args">Object paramaters to use in format string.
        /// </param>
        public void Warn (string format, params object[] args)
        {
            Log(Level.WARN, _Name, String.Format(format, args));
        }


        /// <summary>
        ///  Log a message at ERROR priority.
        /// </summary>
        /// <param name="message">String to send to logs.</param>
        public void Error (string message)
        {
            Log(Level.ERROR, _Name, message);
        }


        /// <summary>
        ///  Log a message at ERROR priority.
        /// </summary>
        /// <param name="format">Format string applied to objets.</param>
        /// <param name="args">Object paramaters to use in format string.
        /// </param>
        public void Error (string format, params object[] args)
        {
            Log(Level.ERROR, _Name, String.Format(format, args));
        }


        /// <summary>
        ///  Log a message at FATAL priority.
        /// </summary>
        /// <param name="message">String to send to logs.</param>
        public void Fatal (string message)
        {
            Log(Level.FATAL, _Name, message);
        }


        /// <summary>
        ///  Log a message at FATAL priority.
        /// </summary>
        /// <param name="format">Format string applied to objets.</param>
        /// <param name="args">Object paramaters to use in format string.
        /// </param>
        public void Fatal (string format, params object[] args)
        {
            Log(Level.FATAL, _Name, String.Format(format, args));
        }


        /// <summary>
        ///  Log a message at SUCCESS priority.
        /// </summary>
        /// <param name="message">String to send to logs.</param>
        public void Success (string message)
        {
            Log(Level.SUCCESS, _Name, message);
        }


        /// <summary>
        ///  Log a message at SUCCESS priority.
        /// </summary>
        /// <param name="format">Format string applied to objets.</param>
        /// <param name="args">Object paramaters to use in format string.
        /// </param>
        public void Success (string format, params object[] args)
        {
            Log(Level.SUCCESS, _Name, String.Format(format, args));
        }
    }
    
    public class ConsoleReportDestination : Report.Destination
	{
		public void Log(Report.Level level, string path, string message)
		{
            string logLine = "[" + DateTime.Now.ToString() + "] ["+path+"] " + message;
			switch(level)
			{
				case Report.Level.DEBUG:
					ConsoleX.Write(CC.GRAY, "[DBG] " + logLine + "\n");
					break;
				case Report.Level.INFO:
					ConsoleX.Write(CC.WHITE, "[INF] " + logLine + "\n");
					break;
				case Report.Level.WARN:
					ConsoleX.Write(CC.YELLOW, "[WRN] " + logLine + "\n");
					break;
				case Report.Level.ERROR:
					ConsoleX.Write(CC.RED, "[ERR] " + logLine + "\n");
					break;
				case Report.Level.FATAL:
					ConsoleX.Write(CC.RED, "[FTL] " + logLine + "\n");
					break;
				case Report.Level.SUCCESS:
					ConsoleX.Write(CC.GREEN, "[SUC] " + logLine + "\n");
					break;
			}
		}
	}

    public class FileReportDestination : Report.Destination
	{
		string _Filename;
		StreamWriter _LogFile;

		private void Initialize(string filename)
		{
			_Filename = filename;

            // If the path specified for this filename doesn't exist, we need to create it.
            Match m = new Regex(@"^(.+)\\(.+)$").Match(filename);
            string pathName = ".";
            if (m.Success)
            {
                pathName = m.Groups[1].Value;
            }

            Directory.CreateDirectory(pathName);

            // This creates the file if it doesn't exist, but not the directory.
			_LogFile = File.AppendText(_Filename);

			Log(Report.Level.INFO, "", _Filename + ": stream opened for logging");
		}

		public FileReportDestination(string filename)
		{
			Initialize(filename);
		}

		public FileReportDestination(string path, string filename, DateTime dt)
		{
			string fullName = String.Format(path + "\\{0}-{1}-{2}-{3}-{4}-{5}.txt",
				new object[]{
								filename,
								dt.Year,
								dt.Month,
								dt.Day,
								dt.Hour,
								dt.Minute
							});
			Initialize(fullName);
		}

		~FileReportDestination()
		{
            if (_LogFile!=null)
            {
                try
                {
                    _LogFile.Close();
                }
                catch(ObjectDisposedException)
                {
                    // Logfile handle was disposed before we were
                    // able to close it
                    _LogFile = null;
                }
            }
		}

		// Implemented from Report.Destination
		public void Log(Report.Level level, string path, string message)
		{
			_LogFile.Write("[" + DateTime.Now.ToString() + "]: " + message + "\r\n");
			_LogFile.Flush();
		}

		public void Close()
		{
			_LogFile.Flush();
			_LogFile.Close();
		}
	}

    public class DebugOutputReportDestination : Report.Destination
	{
		// Implemented from Report.Destination
		public void Log(Report.Level level, string path, string message)
		{
			string strLogLine = String.Format("[{0}] [{1}]: {2}",
					DateTime.Now.ToString(),
					path,
					message);
			Debug.WriteLine(strLogLine);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\livetest\core\DllLoader.cs ===
using System;
using System.IO;

namespace livetest.core
{
    /// <summary>
    ///  Class that captures functionality for loading assemblies.
    /// </summary>
    public class DllLoader
    {
        
        public bool ForceLoad;

        /// <summary>
        ///  Creates a DllLoader with ForceLoad set to false.
        /// </summary>
        public DllLoader ()
        {
            ForceLoad = false;
        }

        /// <summary>
        ///  Creates a DllLoader with ForceLoad set to forceLoad.
        /// </summary>
        /// <param name="forceLoad">Value for this.ForceLoad</param>
        public DllLoader (bool forceLoad)
        {
            ForceLoad = forceLoad;
        }

        /// <summary>
        ///  Loads the assembly.
        /// </summary>
        /// <param name="fullPath">Full string path to the dll to load.</param>
        /// <returns>An AssemblyReference that represents the dll.</returns>
        public AssemblyReference LoadDll (string fullPath)
        {
            AssemblyReference asmRef = new AssemblyReference();
            asmRef.Name = Path.GetFileNameWithoutExtension(fullPath);
            asmRef.FullPath = Path.GetFullPath(fullPath);

            if(ForceLoad)
            {
                asmRef.Instantiate();
            }

            return asmRef;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\livetest\core\PathResolver.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;

namespace livetest.core
{
    /// <summary>
    ///  The PathResolver maintains a set of paths that are associated with a 
    ///  file extension. Whenever a path to a particular file needs to be 
    ///  resolved, the PathResolver finds a path to that file by looking in the
    ///  set of paths that correspond to the given file extension.
    /// </summary>
    public class PathResolver
    {
        private Dictionary<string, List<string>> _SearchPaths;
        private static PathResolver _Default;

        /// <summary>
        ///  Creates a new PathResolver with an empty set of paths.
        /// </summary>
        public PathResolver ()
        {
            _SearchPaths = new Dictionary<string, List<string>>();
        }

        /// <value>Static instance of the PathResolver</value>
        public static PathResolver Default
        {
            get {
                if(null == _Default)
                {
                    _Default = new PathResolver();
                }
                return _Default;
            }
        }

        /// <summary>
        ///  Adds a path to this PathResolver associated with the given 
        ///  file extension.
        /// </summary>
        /// <param name="type">The file extension to associate with the given 
        ///  path.</param>
        /// <param name="path">The path to add to this PathResolver.</param>
        public void AddPath (string type, string path)
        {
            if(type.Length > 16)
            {
                throw new ArgumentException("Type name cannot exceed 16 characters.");
            }

            if(!path.EndsWith("\\"))
            {
                path += "\\";
            }

            List<string> paths = GetPathList(type);
            if(null == paths)
            {
                paths = new List<string>();
                _SearchPaths[type] = paths;
            }
            paths.Add(path);
        }

        /// <summary>Removes a path from this PathResolver.</summary>
        public void RemovePath (string type, string path)
        {
            List<string> paths = GetPathList(type);
            if(null != paths)
            {
                paths.Remove(path);
                if(0 == paths.Count)
                {
                    _SearchPaths.Remove(type);
                }
            }
        }

        /// <returns>The paths contained in this PathResolver.</returns>
        public string[] GetPaths (string type)
        {
            List<string> paths = GetPathList(type);
            if(null == paths)
            {
                return new string[0];
            }
            else
            {
                return paths.ToArray();
            }
        }

        /// <summary>
        ///  Resolves a path using the paths contained in GetPaths(string).
        /// </summary>
        /// <param name="type">File type of the file to search for.</param>
        /// <param name="fileName">Name of the file.</param>
        /// <param name="fullFileName">If the file path is found, this string 
        ///  will contain the result.</param>
        /// <returns>true if the file was found, false otherwise. If the 
        ///  result is true, then the path to the file can be found in 
        ///  fullFileName.</returns>
        public bool Resolve (string type, string fileName, out string fullFileName)
        {

            bool found = false;

            if(Path.IsPathRooted(fileName))
            {
                if(File.Exists(fileName))
                {
                    fullFileName = fileName;
                    found = true;
                    goto lbDone;
                }
            }

            List<string> paths = GetPathList(type);

            if(null != paths)
            {
                foreach(string path in paths)
                {
                    fullFileName = path + fileName;

                    if(File.Exists(fullFileName))
                    {
                        found = true;
                        goto lbDone;
                    }
                }
            }

            // Not found
            fullFileName = "";

        lbDone:

            return found;
        }

        /// <summary>
        ///  Resolves a path using the paths contained in GetPaths(string).
        /// </summary>
        public bool Resolve (string fileName, out string fullFileName)
        {
            bool found = false;

            foreach(KeyValuePair<string, List<string>> entry in _SearchPaths)
            {
                string type = entry.Key;

                if(fileName.EndsWith(type))
                {
                    List<string> paths = entry.Value;

                    foreach(string path in paths)
                    {
                        fullFileName = path + fileName;
                        if(File.Exists(fullFileName))
                        {
                            found = true;
                            goto lbDone;
                        }
                    }
                }
            }

            // Not found
            fullFileName = "";

        lbDone:
            return found;
        }

        private List<string> GetPathList (string type)
        {
            return _SearchPaths.ContainsKey(type)?
				_SearchPaths[type] :
				null;
        }

        // General purpose greedy glob matcher for dealing with 
        // DOS style path expressions
        public static bool GlobMatch(string expr, string data)
        {
            if(expr.Length == 0 || data.Length == 0)
            {
                throw new ArgumentException("Data and expression must both be non-zero length");
            }

            char []exprChars = expr.ToLower().ToCharArray();
            char []dataChars = data.ToLower().ToCharArray();
            int iExpr = 0;
            int iExprEndGlom = -1;
            int cExpr = exprChars.Length;
            int iData = 0;
            int cData = dataChars.Length;


            while(iExpr < cExpr && iData < cData)
            {
                if('*' == exprChars[iExpr])
                {
                    // Find the end of the glom (handle multiple glom chars)
                    if(-1 == iExprEndGlom)
                    {
                        iExprEndGlom = iExpr + 1;
                        while(iExprEndGlom < cExpr && '*' == exprChars[iExprEndGlom])
                        {
                            ++iExprEndGlom;
                        }
                    }

                    // When we find a character after a glom we will try to advance
                    // and start matching explicitly but if this fails we fall back on the
                    // greedy glomming
                    if(iExprEndGlom < cExpr && exprChars[iExprEndGlom] == dataChars[iData])
                    {
                        // Search fowards for the subexpression
                        int iSubExpr = iExprEndGlom;
                        int iSubData = iData;
                        while(iSubExpr < cExpr && iSubData < cData && exprChars[iSubExpr] == dataChars[iSubData])
                        {
                            // End sub expression on another glom
                            if('*' == exprChars[iSubExpr])
                            {
                                break;
                            }

                            ++iSubExpr;
                            ++iSubData;

                        }

                        // If the whole expression was consumed on the data (stem match) or we
                        // consumed the whole subexpression and now have a new glom we will 
                        // mark the expression as being consumed and reset the end marker. Otherwise
                        // we will move to the next character in the data and try to match the subexpression
                        if((iSubExpr == cExpr && iSubData == cData) || (iSubExpr < cExpr && '*' == exprChars[iSubExpr]))
                        {
                            iExpr = iSubExpr;
                            iData = iSubData;
                            iExprEndGlom = -1;
                        }
                        else
                        {
                            // No partial match after testing subexpression, consume data
                            ++iData;
                        }
                    }
                    else
                    {
                        // No chance of partial match consume data
                        ++iData;
                    }
                }
                else if(exprChars[iExpr] == dataChars[iData])
                {
                    // Exact match
                    ++iExpr;
                    ++iData;
                }
                else
                {
                    // No match
                    break;
                }
            }

            // Consumed whole expression or terminated on last glom character (glom matches entire stem)
            return (iExpr == cExpr || ('*' == exprChars[iExpr] && iExpr == cExpr - 1));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\livetest\core\HttpWorker.cs ===
using System;
using System.Diagnostics;
using System.Net;
using System.Net.Sockets;
using System.Text;

namespace livetest.core
{
    /// <summary>
    ///  This class represents a Worker that is designed to encapsulate HTTP 
    ///  transactions. Each worker keeps a byte array buffer to handle the 
    ///  transaction.
    /// </summary>
    public class HttpWorker : Worker
    {
        /// <summary>
        ///  Delegate that is called when the HTTP transaction has been fully 
        ///  completed.
        /// </summary>
        public delegate void Callback ();

        private enum TCPState
        {
            DISCONNECTED,
            DISCONNECTING,
            CONNECTED,
            CONNECTING,
            SENDINPROGRESS,
            RECVINPROGRESS
        }

        // Settings
        private const int SEND_TIMEOUT          = 30000;
        private const int RECV_TIMEOUT          = 30000;

        static private byte[] _kHttpTermination = new byte[] { 0x0d, 0x0a, 0x0d, 0x0a };

        IPEndPoint _EndPoint;
        
        protected Socket _Socket;
        
        protected byte[] _Buffer;


        Callback _Callback;
        TCPState _State;
        uint _ConnectTry;
        
        protected uint _BufferCount;
        uint _BufferPending;
        
        protected uint _HeaderLength;
        
        protected int _ContentLength;
        
        protected int _HttpStatus;
        
        protected uint _XErr;

        /// <summary>
        ///  Creates a new HttpWorker with a buffer of bufferSize bytes.
        /// </summary>
        public HttpWorker (uint bufferSize)
        {
            _State      = TCPState.DISCONNECTED;
            _Buffer     = new byte[bufferSize];
        }

        /// <value>
        ///  true if this HttpWorker is connected. false otherwise.
        /// </value>
        public bool IsConnected()
        {
            return TCPState.DISCONNECTED != _State;
        }

        /// <summary>
        ///  Initiates the connection process.
        /// </summary>
        public void StartConnect ()
        {
            try
            {
                _ConnectTry++;
                _State  = TCPState.CONNECTING;
                _Socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
                _Socket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, 1);

                _Socket.BeginConnect(_EndPoint, new AsyncCallback(this.CompleteConnect), this);
            }
            catch(Exception ex)
            {
                HandleException(ex);
            }
        }

        /// <summary>
        ///  AsyncCallback method that is executed when connection has 
        ///  completed.
        /// </summary>
        public virtual void CompleteConnect (IAsyncResult ar)
        {
            try
            {
                Debug.Assert(TCPState.CONNECTING == _State);

                _Socket.EndConnect(ar);
                _State = TCPState.CONNECTED;


                if(0 == _BufferCount)
                {
                    throw new Exception("Cannot initiate send, no pending buffer data");
                }

                if(!_Socket.Connected)
                {
                    throw new Exception("Unexpected: socket is in an unconnected state");
                }

                // Just continue now to send the data
                StartSend(null, 0, null);
            }
            catch(SocketException ex)
            {
                if(ex.ErrorCode == 10054)	// An existing connection was forcibly closed by the remote host
                {
                    // Server closed this socket, cleanup and bail
                    _Socket.Close();
                    _State = TCPState.DISCONNECTED;
                }

                HandleException(ex);
            }
            catch(Exception ex)
            {
                HandleException(ex);
            }
        }

        /// <summary>
        ///  Disconnects from server.
        /// </summary>
        public void Disconnect ()
        {
            try
            {
                _State = TCPState.DISCONNECTING;
                _Socket.Shutdown(SocketShutdown.Send);
                _Socket.BeginReceive(_Buffer, (int)_BufferCount, (int)(_BufferCount - _Buffer.Length), 0, new AsyncCallback(this.CompleteReceive), this);
            }
            catch(Exception ex)
            {
                HandleException(ex);
            }
        }

        /// <summary>
        ///  Starts to send data in the data buffer to host:port.
        /// </summary>
        /// <param name="host">Host to send request to.</param>
        /// <param name="port">Port to send request to.</param>
        /// <param name="callback">Will be executed upon completion of sending 
        ///  the request.</param>
        public void StartSend (IPAddress host, ushort port, Callback callback)
        {
            try
            {
                Debug.Assert(TCPState.DISCONNECTING != _State);

                if(null == _Socket || !_Socket.Connected)
                {
                    // Create our address/port 
                    _Callback = callback;
                    _EndPoint = new IPEndPoint(host, (int)port);
                    StartConnect();
                }
                else
                {
                    // Make sure we're connected
                    Debug.Assert(TCPState.CONNECTED == _State);

                    // Setup SPI

                    // Send request
                    _State = TCPState.SENDINPROGRESS;
                    _BufferPending = _BufferCount;
                    _Socket.BeginSend(_Buffer, 0, (int)_BufferCount, 0, new AsyncCallback(this.CompleteSend), this);
                }
            }
            catch(Exception ex)
            {
                HandleException(ex);
            }
        }

        /// <summary>
        ///  Executing when sending has finished. This method automatically 
        ///  starts up the receiving phase of the HTTP transaction.
        /// </summary>
        public void CompleteSend (IAsyncResult ar)
        {
            int sent;

            try
            {
                Debug.Assert(TCPState.SENDINPROGRESS == _State);
                sent = _Socket.EndSend(ar);
                if(sent > _BufferPending)
                {
                    throw new Exception("Invalid condition reached, " + sent + " bytes sent but only: " + _BufferPending + " bytes pending");
                }

                _BufferPending -= (uint)sent;

                if(0 == _BufferPending)
                {
                    StartReceive();
                }
                else
                {
                    _Socket.BeginSend(_Buffer, (int)(_BufferCount - _BufferPending), (int)_BufferPending, 0, new AsyncCallback(this.CompleteSend), this);
                }
            }
            catch(Exception ex)
            {
                HandleException(ex);
            }
        }

        /// <summary>
        ///  Starts receiving HTTP response.
        /// </summary>
        public void StartReceive ()
        {
            try
            {
                Debug.Assert(TCPState.RECVINPROGRESS != _State);

                // Clear receive state
                _BufferCount    = 0;
                _HeaderLength   = 0;
                _ContentLength  = 0;
                _HttpStatus     = 0;

                _State = TCPState.RECVINPROGRESS;
                _Socket.BeginReceive(_Buffer, 0, _Buffer.Length, 0, new AsyncCallback(this.CompleteReceive), this);
            }
            catch(Exception ex)
            {
                HandleException(ex);
            }
        }

        /// <summary>
        ///  Executed when reception of the HTTP response is complete.
        /// </summary>
        public void CompleteReceive (IAsyncResult ar)
        {
            int received;

            try
            {
                Debug.Assert(TCPState.RECVINPROGRESS == _State || TCPState.DISCONNECTING == _State);


                received = _Socket.EndReceive(ar);
                _BufferCount += (uint)received;

                // Parse header if we don't have it yet
                if(0 == _HeaderLength)
                {
                    uint mark = FindByteSequence(_Buffer, _BufferCount, _kHttpTermination);
                    if(0 == mark)
                    {
                        _Socket.BeginReceive(_Buffer, (int)_BufferCount, (int)(_Buffer.Length - _BufferCount), 0, new AsyncCallback(this.CompleteReceive), this);
                    }
                    else
                    {
                        _HeaderLength = mark + 4;

                        Debug.Assert(_HeaderLength < _Buffer.Length);

                        ParseHeaders();
                    }
                }

                if(received > 0)
                {
                    if(_BufferCount > (_HeaderLength + _ContentLength))
                    {
                        Disconnect();
                    }
                    else
                    {
                        // Continue reading until we get the full content length
                        _Socket.BeginReceive(_Buffer, (int)_BufferCount, (int)(_Buffer.Length - _BufferCount), 0, new AsyncCallback(this.CompleteReceive), this);

                        //_Socket.BeginReceive(_Buffer, (int)_BufferCount, (int)((_HeaderLength + _ContentLength)-_BufferCount), 0, new AsyncCallback(this.CompleteReceive), this);
                    }

                }
                else
                {
                    // 0 length read, time to close down
                    _Socket.Close();
                    _State = TCPState.DISCONNECTED;

                    // Fire the local completion routine
                    _Callback.DynamicInvoke(new Object[0]);
                    Finish();
                }
            }
            catch(Exception ex)
            {
                HandleException(ex);
            }
        }

        //
        // Buffer management
        //

        /// <summary>
        ///  Appends data to this object's HTTP data buffer.
        /// </summary>
        /// <param name="verb">HTTP verb to append.</param>
        /// <param name="resource">HTTP resource to append.</param>
        /// <param name="headers">HTTP headers to append.</param>
        /// <param name="contentLength">Length of appended data.</param>
        public void AppendRequest (string verb, string resource, string[] headers, uint contentLength)
        {

            // Clear state get ready for new request.
            _BufferCount    = 0;


            ASCIIEncoding encoding = new ASCIIEncoding();

            // Write the request
            string request = verb + " " + resource + " HTTP/1.0\r\n";
            AppendBytes(encoding.GetBytes(request));

            // Write the extra headers
            if(null != headers)
            {
                for(uint i = 0; i < headers.Length; i += 2)
                {
                    AppendBytes(encoding.GetBytes(headers[i]));
                    AppendBytes(encoding.GetBytes(": "));
                    AppendBytes(encoding.GetBytes(headers[i+1]));
                    AppendBytes(encoding.GetBytes("\r\n"));
                }
            }

            // Append content length
            AppendBytes(encoding.GetBytes("Content-Length: "));
            AppendBytes(encoding.GetBytes(contentLength.ToString()));
            AppendBytes(encoding.GetBytes("\r\n"));

            // Terminate
            AppendBytes(encoding.GetBytes("\r\n"));
        }

        /// <summary>
        ///  Append a single byte b to the internal HTTP data buffer.
        /// </summary>
        public void AppendByte (byte b)
        {
            if(_BufferCount == _Buffer.Length)
            {
                throw new Exception("Buffer overrun");
            }

            _Buffer[_BufferCount++] = b;
        }

        /// <summary>
        ///  Append multiple bytes to the internal HTTP data buffer.
        /// </summary>
        public void AppendBytes (byte[] bytes)
        {
            if((bytes.Length + _BufferCount) > _Buffer.Length)
            {
                throw new Exception("Buffer overrun");
            }

            for(uint i = 0; i < bytes.Length; ++i)
            {
                _Buffer[_BufferCount++] = bytes[i];
            }
        }

        //------------------------------------------------------------------------------
        // Internal methods
        //------------------------------------------------------------------------------
        private uint FindByteSequence (byte[] haystack, uint count, byte[] seq)
        {
            uint j = 0;
            uint mark = 0;

            for(uint i = 0; i < count; ++i)
            {
                mark = i;

                while(j < seq.Length && i < count && seq[j] == haystack[i])
                {
                    i++;
                    j++;
                }

                if(j == seq.Length)
                {
                    break;
                }
                else
                {
                    i = mark;
                    j=0;
                }
            }

            return mark;
        }

        /*private void ParseHeaders()
        {
            string header = new ASCIIEncoding().GetString(_Buffer);
            string[]lines = header.Split("\r".ToCharArray());

            // First line contains the HTTP status (we could catch sub status
            // and extended messages later)
            string[] statusTokens = lines[0].Split(" ".ToCharArray());
            _HttpStatus = UInt32.Parse(statusTokens[1].Split(".".ToCharArray())[0]);

            for(uint i = 1; i < lines.Length; ++i)
            {
                string[] tokens = lines[i].Split(":".ToCharArray());
                string name = tokens[0].Trim();
                if(name == "Content-Length")
                {
                    _ContentLength = UInt32.Parse(tokens[1].Trim());
                }
            }
        }
		*/
        private uint HexToInt (byte b)
        {
            if(b>='a')
                return (uint)b-'a'+10;
            if(b>='A')
                return (uint)b-'A'+10;
            return (uint)b-'0';
        }

        private unsafe void ParseHeaders ()
        {
            int i;
            int len=_Buffer.Length;

            fixed(byte* pData=_Buffer)
            {
                // find HTTP error code
                byte* p=pData+9;
                _HttpStatus =(*(p)-'0')*100;
                _HttpStatus+=(*(p+1)-'0')*10;
                _HttpStatus+=(*(p+2)-'0');


                for(i=5; i<len; i+=2)
                {
                    if(p[i]<=0x0D)
                    {
                        // this is a part of a CRLF. Let's see which
                        if(p[i]==0x0D)
                            i+=2;
                        else
                            i++;

                        if(p[i]==0x0D && p[i+1]==0x0A)
                            break;

                        if(p[i]=='X')
                        {
                            if(p[i+1]!='-' || (p[i+2]!='E' && p[i+2]!='D'))
                                continue;
                            // this is the error code or X-Delay
                            if(p[i+2] == 'E')
                            {
                                i+=7;
                                int j = i;
                                _XErr=0;
                                int digits=0;
                                while(p[j]>='0' && digits<8)
                                {
                                    _XErr<<=4;
                                    _XErr+=HexToInt(p[j]);
                                    j++;
                                    digits++;
                                }
                            }

                        }
                        else if((p[i]=='C') && (p[i+1]=='o') && (p[i+2]=='n') && (p[i+3]=='t'))
                        {
                            if((p[i+7]=='-') && (p[i+8]=='L'))
                            {
                                int j = i + 16; // j is the beginning of contentLen
                                _ContentLength = 0;
                                while(p[j] > 0x0D)
                                {
                                    _ContentLength = _ContentLength*10 + (p[j]-'0');
                                    j++;
                                }
                            }
                        }
                    }
                }
            }

        }

        private void HandleException (Exception ex)
        {
            _State = TCPState.DISCONNECTED;
            _Exception = ex;
            Finish();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\livetest\core\ScopeTimer.cs ===
using System;
using System.Runtime.InteropServices;

namespace livetest.core
{

    public class ScopeTimer
    {
        [DllImport("Kernel32.dll")]
        private static extern bool QueryPerformanceCounter (out long lpPerformanceCount);

        [DllImport("Kernel32.dll")]
        private static extern bool QueryPerformanceFrequency (out long lpFrequency);

        private long _StartTime;
        private long _StopTime;
        private long _Frequency;

        /// <summary>
        ///  Get the sampled time after we have left the scope.
        /// </summary>
        public double Duration
        {
            get {
                if(0 == _StopTime)
                {
                    throw new Exception("Scope timer has not finished. Use Sample() instead");
                }
                return (double)(_StopTime - _StartTime) / (double)_Frequency;
            }

        }

        public ScopeTimer ()
        {
            if(QueryPerformanceFrequency(out _Frequency) == false)
            {
                throw new Exception("QueryPerformanceCounter is not available");
            }
        }

        public void Enter ()
        {
            if(!QueryPerformanceCounter(out _StartTime))
            {
                throw new Exception("QueryPerformanceCounter() failed");
            }
        }

        public void Leave ()
        {
            QueryPerformanceCounter(out _StopTime);
        }

        public double Sample ()
        {
            long stopTime;
            double returnValue;

            QueryPerformanceCounter(out stopTime);
            returnValue = (double)(stopTime - _StartTime) / (double)_Frequency;

            return returnValue;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\livetest\core\ThreadBase.cs ===
using System;
using System.Threading;

namespace livetest.core
{
    public abstract class ThreadBase
    {
        // Implement ThreadBody() in your thread subclass 
        protected abstract void ThreadBody();

        public Thread        TaskThread;
        public WaitHandle    ShutdownEvent;

        public virtual void Go()
        {
            TaskThread = new Thread(new ThreadStart(ThreadBody));
            ShutdownEvent = ThreadContainer.Register(TaskThread);
            TaskThread.Start();
        }

        public virtual void Stop()
        {
            if(null != TaskThread)
            {
                ThreadContainer.Unregister(TaskThread);
                TaskThread.Abort();
            }
        }

        public virtual void Join()
        {
            if (null != TaskThread)
            {
                TaskThread.Join();
            }
        }

        public bool IsAlive
        {
            get
            {
                if (null == TaskThread)
                {
                    return false;
                }

                return TaskThread.IsAlive;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\livetest\core\UdpWorker.cs ===
using System;
using System.Net;
using System.Net.Sockets;

namespace livetest.core
{
    /// <summary>
    /// <para>This class represents a Worker that executes UDP protocol 
    ///  tasks. All of its functions are asynchronous (which is only the 
    ///  StartReceive call). This is an immutable class that can either be 
    ///  bound to a specific port, or an arbitrary one.
    /// </para>
    /// 
    /// <para>The general idea about exception handling for this class is that
    ///  most exceptions will not be caught. It is left up to the subclass or
    ///  a client of this class to handle exceptions. The only exceptions that
    ///  are handled within this class are any exceptions thrown when completing
    ///  a receive. This is because a client or a subclass cannot be notified 
    ///  that an exception is thrown within the internal callback function of 
    ///  this class. In light of this, the callback simply stores the 
    ///  encountered exception in the protected backing store in the Worker 
    ///  class. A client can gain access to this stored exception by using the 
    ///  Exception property of the Worker class; and a subclass can gain access
    ///  to it by using the protected _Exception member of the Worker class.
    /// </para>
    /// 
    /// <para>In addition to handling exceptions. A subclass or client of this 
    ///  class must remember to call Finish at the completion of a given task.
    /// </para>
    /// </summary>
    public class UDPWorker : Worker
    {
        /// <summary>
        ///  A delegate for the type of function that is to be called when 
        ///  data is completely received.
        /// </summary>
        /// <param name="sender">EndPoint representing the sender of the 
        ///  received data.</param>
        /// <param name="bytesReceived">Number of bytes received.</param>
        public delegate void ReceiveCallback (EndPoint sender,
                                              int bytesReceived);

        enum UDPStates { RECEIVING, IDLE }

        Socket socket;         // Socket for this class
        ReceiveCallback receiveCallback;// Callback executed when data received
        EndPoint sourceEP;       // EndPoint received data from
        UDPStates state;          // Internal state of this
        AsyncCallback asyncCallback;  // Used with BeginReceiveFrom
        IAsyncResult asyncResult;    // Used for asynchronous implementation


        /// <summary>
        ///  Returns a new UDPWorker with its socket initialized appropriately.
        ///  See System.Net.Sockets.Socket.Bind for more info on exceptions 
        ///  thrown.
        /// </summary>
        /// <param name="port">Port to bind this UDPWorker to.</param>
        /// <exception cref="System.Net.Sockets.SocketException">
        ///  Throw if this constructor was unable to create a socket for this 
        ///  UDPWorker.</exception>
        public UDPWorker (int port)
        {
            state = UDPStates.IDLE;
            sourceEP = new IPEndPoint(IPAddress.Any, 0);
            asyncCallback = new AsyncCallback(ReceiveComplete);

            socket = new Socket(AddressFamily.InterNetwork,
                                SocketType.Dgram,
                                ProtocolType.Udp);

            socket.Bind(new IPEndPoint(IPAddress.Any, port));
        }


        /// <summary>
        ///  Returns a new UDPWorker with its socket initialized appropriately.
        ///  Its port is arbitrarily chosen.
        /// </summary>
        /// <exception cref="System.Net.Sockets.SocketException">
        ///  Throw if this constructor was unable to create a socket for this 
        ///  UDPWorker.</exception>
        public UDPWorker () : this(0) { }


        /// <summary>
        ///  Sends data to the specified destination. Since this is UDP this 
        ///  call returns immediately.
        /// </summary>
        /// <param name="dataBuffer">A byte array containing the data to be 
        ///  sent</param>
        /// <param name="endPoint">IPEndPoint to where the data is to be sent
        /// </param>
        /// <param name="byteOffset">A byte offset into the array</param>
        /// <param name="byteCount">How many bytes of the dataBuffer to send
        /// </param>
        /// <returns>The number of bytes sent</returns>
        /// <exception cref="System.Exception">
        ///  Thrown if the method failed to send 'byteCount' the bytes.
        ///  </exception>
        public void SendTo (byte[] dataBuffer, int byteOffset,
                            int byteCount, IPEndPoint endPoint)
        {
            if(endPoint == null || dataBuffer == null)
                throw new ArgumentNullException("Input arguments cannot be null.");

            int sent = socket.SendTo(dataBuffer, byteOffset, byteCount,
                                     SocketFlags.None, endPoint);

            if(sent < byteCount)
                throw new Exception("Did not send all "+byteCount+" bytes, "+(byteCount-sent)+" bytes remaining.");
        }


        /// <summary>
        ///  Begins an asynchronous call to receive UDP packets. See 
        ///  Socket.BeginReceiveFrom Method for information about thrown 
        ///  exceptions.
        /// </summary>
        /// <param name="buffer">byte array which is where the data is to be 
        ///  placed</param>
        /// <param name="byteOffset">byte offset into buffer</param>
        /// <param name="byteCount">How many bytes to copy into buffer</param>
        /// <param name="callback">A ReceiveCallback that will be executed when
        ///  the data has been completely received.</param>
        public void StartReceive (byte[] buffer,
                                  int byteOffset, int byteCount,
                                  ReceiveCallback callback)
        {
            // Debug code
            if(state == UDPStates.RECEIVING)
                throw new Exception("Already receiving.");
            // End debug code

            state = UDPStates.RECEIVING;

            receiveCallback = callback;

            try
            {
                asyncResult = socket.BeginReceiveFrom(buffer, byteOffset,
                                        byteCount, SocketFlags.None,
                                        ref sourceEP,
                                        asyncCallback,
                                        this);
            }
            catch(Exception)
            {
                state = UDPStates.IDLE;
                throw;
            }
        }


        /// <summary>
        ///  Terminates the UDP receiving initiated by the StartReceive method.
        ///  This method closes the existing socket and creates a new one to 
        ///  ensure that the previously executed callback will never be 
        ///  executed. This is the only method available right now to end 
        ///  asynchronous socket receives. An input parameter specifies 
        ///  whether the new socket will reuse the port it previously held. See
        ///  System.Net.Sockets.Socket.Bind for more info on exceptions thrown.
        /// </summary>
        /// <param name="reusePort">Specifies whether to reuse the port that 
        ///  this UDPWorker's socket was bound to, or to bind to a new port.
        ///  </param>
        public void EndReceive (bool reusePort)
        {
            if(state == UDPStates.IDLE) return;

            state = UDPStates.IDLE;
            asyncResult = null;

            int port = ((IPEndPoint)socket.LocalEndPoint).Port;
            socket.Close(1);
            socket = new Socket(AddressFamily.InterNetwork,
                                    SocketType.Dgram,
                                    ProtocolType.Udp);
            if(reusePort)
                socket.Bind(new IPEndPoint(IPAddress.Any, port));
            else
                socket.Bind(new IPEndPoint(IPAddress.Any, 0));
        }


        // Executes when the receiving is complete. Exceptions thrown by 
        // System.Net.Sockets.Socket.EndReceiveFrom are caught and stored in
        // _Exception.
        void ReceiveComplete (IAsyncResult ar)
        {
            if(state == UDPStates.IDLE) return;

            if(asyncResult == null || ar != asyncResult) return;

            state = UDPStates.IDLE;
            int bytesReceived = 0;

            try
            {
                bytesReceived = socket.EndReceiveFrom(ar, ref sourceEP);

            }
            catch(Exception e)
            {
                _Exception = e;
            }

            receiveCallback.Invoke(sourceEP, bytesReceived);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\livetest\core\Topology.cs ===
using System;
using System.IO;
using System.Text;
using System.Collections.Generic;
using System.Runtime.Serialization.Formatters.Binary;

namespace livetest.core
{
    [Serializable]
    public class TopologyNode
    {
        public string Name;
        public string PropertyList;
        public byte[] AllowedActions;
        public TopologyNode []Children;

        public TopologyNode(string name, string propertyList, byte[] allowedActions)
        {
            Name = name;
            PropertyList = propertyList;
            AllowedActions = allowedActions;
            Children = null;
        }

        public override string ToString()
        {
            return Name + " (" + PropertyList + ")";
        }

        // Recursive string converter (to a buffer)
        public string ToString(StringBuilder buffer, int depth)
        {
            for (int i = 0; i < depth; ++i)
            {
                buffer.Append("  ");
            }
            buffer.Append(this.ToString());
            buffer.Append("\r\n");

            if(null != Children)
            {
                foreach(TopologyNode node in Children)
                {       
                    node.ToString(buffer, depth + 1);
                }
            }

            return buffer.ToString();
        }
    }

    public class TopologyNodeVisitor
    {
        int             _iPath;
        string[]        _Path;
        TopologyNode    _Current;
        List<TopologyNode> _Queue;

        public const string RecursiveMatch = "...";

        public void Visit(TopologyNode root, string path)
        {
            Visit(root, path.Split(new char[]{'/'}, StringSplitOptions.RemoveEmptyEntries));
        }

        public void Visit(TopologyNode root, string []pathElements)
        {
            _Current = root;
            _Path = pathElements;
            _iPath = 0;
            _Queue = new List<TopologyNode>();

            // Always enqueue the root, unless it is specified and does not match
            //
            // "/" -- yes
            // ""  -- yes
            // "/..." -- yes
            // "..." -- yes
            // "/something != /myrootnode" -- no
            if(     null == pathElements 
                ||  0 == pathElements.Length 
                ||  pathElements[0] == RecursiveMatch 
                ||  PathResolver.GlobMatch(_Path[_iPath], _Current.Name))
            {
                Enqueue(_Current);
            }
        }

        public bool GetNext(out TopologyNode next)
        {
            next = null;
            
            next = Next();
            if(null != next && null != next.Children)
            {
                // Determine which children to enqueue
                foreach(TopologyNode child in next.Children)
                {
                    if(_iPath < _Path.Length && _Path[_iPath] == RecursiveMatch)
                    {
                        // If current element is a recursive match
                        Enqueue(child); 
                    }
                    if(_iPath + 1 < _Path.Length && PathResolver.GlobMatch(_Path[_iPath + 1], child.Name))
                    {
                        // If next specified path element matches child element ensure it is visited
                        Enqueue(child);
                    }
                }
            }
            
            return null != next;
        }

        private void Enqueue(TopologyNode node)
        {
            _Queue.Add(node);
        }

        private TopologyNode Next()
        {
            if(0 == _Queue.Count)
            {
                return null;
            }

            TopologyNode node = _Queue[0];
            _Queue.RemoveAt(0);

            return node;
        }
    }

    public class TopologyPayload : Payload
    {
        TopologyNode Root;

        public TopologyPayload()
        {
        }

        public TopologyPayload(TopologyNode node)
        {
            Root = node;
        }

        public override void Read(BinaryReader reader)
        {
            BinaryFormatter formatter = new BinaryFormatter();
            Root = (TopologyNode)formatter.Deserialize(reader.BaseStream);
        }

        public override void Write(BinaryWriter writer)
        {
            BinaryFormatter formatter = new BinaryFormatter();
            formatter.Serialize(writer.BaseStream, Root);
        }

        public override string ToString()
        {
            StringBuilder buffer = new StringBuilder(128);
            return (null != Root ? Root.ToString(buffer, 0) : "<nodata>");
        }
    }

    public class TopologyExecutePayload : Payload
    {
        public string Path;
        public byte[] Actions;

        public TopologyExecutePayload()
        {
            Path = "/";
            Actions = new byte[0];
        }

        public TopologyExecutePayload(string path, byte []actions)
        {
            Path = path;
            Actions = actions;
        }

        public override void Read(BinaryReader reader)
        {
            Path = ReadStringWithLength(reader);

            int nActions = reader.ReadInt32();
            Actions = reader.ReadBytes(nActions);
        }

        public override void Write(BinaryWriter writer)
        {
            WriteStringWithLength(writer, Path);
            writer.Write(Actions.Length);
            writer.Write(Actions);
        }
    }

    public class Topology
    {
        // Topology message names
        public const string BusNamespace      = "Topology";
        public const string GetActions        = "TopologyGetActions";
        public const string GetActionsReply   = "TopologyGetActionsReply";
        public const string Read              = "TopologyRead";
        public const string ReadReply         = "TopologyReadReply";
        public const string ExecuteNodes      = "TopologyExecuteNodes";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\livetest\core\Worker.cs ===
using System;
using System.Reflection;

namespace livetest.core
{
    /// <summary>
    /// This interface represents an object that manages Workers.
    /// </summary>
    public interface IWorkerManager
    {
        /// <summary>One can use this method to provide any post-completion 
        ///  processing.</summary>
        /// <param name="worker">Worker that has completed its task.</param>	
        void PostCompletedWorker (Worker worker);
    }


    /// <summary>
    /// <para>A Worker is a mutable class that represents an entity capable of 
    ///  executing tasks. Workers are managed by an IWorkerManager that is 
    ///  responsible for starting them. A Worker should call Finish to notify
    ///  its manager that it has completed. If a Worker encounters an 
    ///  exception, during the execution of a task, it should catch the 
    ///  exception and call Finish().</para>
    /// 
    /// <para>A Worker should call Finish() once during the execution of a 
    ///  task. More specifically, a Worker should call Finish at the end of the
    ///  execution of its task, or when it encounters an exception. In the case
    ///  where it encounters an exception, if Finish is called, a subclass 
    ///  must remember to not call the Finish that was at the end of the 
    ///  execution (the Finish that would have been called if no Exception was 
    ///  encountered). If Finish is called more than once during the execution 
    ///  of a single task, an unnecssary load on the IWorkerManager might 
    ///  ensue, depending on how the manager is implemented.</para>
    /// 
    /// <para>It is inteded that Workers be relatively light weight. The 
    ///  number of fields and data kept within their state should be kept to a 
    ///  minimum. As such, one might find it advantageous for Workers to 
    ///  reference static members. These static members can be initialized 
    ///  appropriately by an IContextManager's constructor. This allows the 
    ///  IContextManager to load any settings from configuratino files, and 
    ///  prepare the Workers appropriately. There are several examples of 
    ///  lightweight Workers in the livetest.samples namespace.</para>
    /// </summary>
    public abstract class Worker
    {
        /// <summary>
        ///  An enumeration of the states that a Worker can be in.
        /// </summary>
        public enum State
        {
            /// <summary>Worker is ready to execute a task.</summary>
            READY,
            /// <summary>Worker is currently executing a task.</summary>
            BUSY,
            /// <summary>Worker has finished a task.</summary>
            FINISHED
        }


        /// <summary>
        ///  Current state of the worker. This member can be used by an 
        ///  IWorkerManager to have more control over its Workers.
        /// </summary>
        public State CurrentState;


        /// <summary>
        ///  Total number of ticks passed during execution of a task.
        /// </summary>
        public uint TotalTicks  {
            get {
                return (uint)(_StartTicks - _EndTicks); 
            }
        }


        /// <value>
        ///  An Exception that the Worker encountered during its execution. If
        ///  a Worker encounters an Exception during its execution, it should 
        ///  store the Exception and call Finish.
        /// </value>
        public Exception Exception {
            get {
                return _Exception;
            }
        }


        /// <summary>
        ///  Used to identify which task the Worker is executing.
        /// </summary>
        public uint Key;


        /// <summary>The IWorkerManager managing this Worker.</summary>
        protected IWorkerManager _Manager;


        /// <summary>
        ///  Backing store for this.Exception. A subclass of this class should 
        ///  remember to store any exception encountered in this field so that 
        ///  the IWorkerManager can process it.</summary>
        protected Exception _Exception;


        /// <summary>
        ///  Environment tick count at the Start of the Worker.
        /// </summary>
        protected uint _StartTicks;


        /// <summary>
        ///  Environment tick count at the Finish of the Worker.
        /// </summary>
        protected uint _EndTicks;


        /// <summary>
        ///  Invoke a method on the implemented worker, this is the main 
        ///  method that is called from a scheduler.
        /// </summary>
        /// <param name="start">Method for Worker to invoke.</param>
        /// <param name="manager">IWorkerManager for this Worker.</param>
        public void Start (MethodInfo start, IWorkerManager manager)
        {
            _StartTicks     = (uint)Environment.TickCount;
            _EndTicks       = 0;
            _Exception      = null;
            _Manager        = manager;

            CurrentState = State.BUSY;

            start.Invoke(this, new Object[0]);
        }


        /// <summary>
        ///  When a worker is done it should call Finish() in order to notify 
        ///  IWorkerManager that it is done with its Worker method.
        /// </summary>
        public void Finish ()
        {
            if(CurrentState == State.BUSY)
            {
                _EndTicks = (uint)Environment.TickCount;

                CurrentState = State.FINISHED;

                if(_Manager != null)
                    _Manager.PostCompletedWorker(this);
            }
        }


        /// <summary>
        ///  Use this method if you want to explicitly say that your task 
        ///  failed. This method does not invoke Finish(), so you must 
        ///  remember to call Finish() in your Worker method.
        /// </summary>
        /// <param name="formattedString">A regular string or formatted string 
        ///  containing a failure message.</param>
        /// <param name="args">Arguments that would go in your formattedString.
        /// </param>
        protected virtual void Fail (string formattedString, params object[] args)
        {
            // Lazy initialization
            if(failException == null)
                failException = new FailureException();

            failException.FailureMessage = String.Format(formattedString, args);

            _Exception = failException;
        }


        // Used with the Fail method. So that a new Exception does not have to 
        // be made everytime Fail is called.
        private FailureException failException;


        // This is a mutable exception created for optimization. This class 
        // exposes the Message property so that it is mutable.
        private class FailureException : Exception
        {
            private string message;

            public FailureException ()
                :
                base("You should not see this message, if you do, it has nothing to do with the exception.") { }

            public string FailureMessage
            {
                get { return message; }
                set { message = (value==null)? String.Empty : value; }
            }

            public override string Message
            {
                get { return message; }
            }

            // Not equivalent to the Exception.ToString() method.
            public override string ToString ()
            {
                return "Worker failed during task: "+message;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\livetest\core\TimeoutManager.cs ===
using System;
using System.Collections.Generic;
using System.Threading;
using System.Diagnostics;

namespace livetest.core
{
    /// <summary>
    ///  <para>Manages all of the expirations of all the clients registered
    ///   with this TimeoutManager. A client uses the Add method to specify a 
    ///   timeout and a callback to be executed upon expiration. The Add method
    ///   returns a unique ID for that entry. A client can remove this timed 
    ///   invocation by using the Remove method and giving it the ID returned 
    ///   by the Add method.</para>
    /// 
    ///  <para>There is a subtle bug in this implementation. Currently this 
    ///   implementation will break after 29.7 days or Int32.MaxValue 
    ///   milliseconds because it uses the Environment.TickCount to synchronize
    ///   its clients. In the future, this bug should be corrected by adding a 
    ///   bit more math.</para>
    /// 
    ///  <para>This class is thread safe. One can execute concurrent Adds and 
    ///  Removes.</para>
    /// </summary>
    public class TimeoutManager
    {
        /// <summary>
        ///  This delegate represents the method that is executed when a 
        ///  client's time has expired.
        /// </summary>
        public delegate void ExpireCallback ();


        //Class used to store information
        private class InternalClient : IComparable<InternalClient>
        {
            static private int currentID = 0;

            public readonly int uniqueID;
            public readonly int expireTime;

            public InternalClient (int timeout)
            {
                uniqueID = currentID++;
                expireTime = Environment.TickCount + timeout;
            }

            public override bool Equals (object o)
            {
                return o is InternalClient &&
                       expireTime == ((InternalClient)o).expireTime &&
                       uniqueID == ((InternalClient)o).uniqueID;
            }

            public override int GetHashCode ()
            {
                return uniqueID*17;
            }

            #region IComparable<InternalClient> Members

            // Smaller InternalClient is the one that is going to timeout 
            // sooner.
            public int CompareTo (InternalClient other)
            {
                return (int)expireTime - (int)other.expireTime;
            }

            #endregion
        }


        private PriorityQueue<InternalClient> clients;
        private Dictionary<int, ExpireCallback> clientMap;
        // Makes the checkClients method fire every interval milliseconds
        private Timer timer;
        // Interval to check the clients in milliseconds
        private int interval;


        // state is not used by this function
        private void checkClients (object state)
        {
            while(clients.Count > 0 &&
                   Environment.TickCount >= clients.Peek().expireTime)
            {
                InternalClient iClient = clients.Dequeue();

                // Check to see if the client has already been removed
                if(clientMap.ContainsKey(iClient.uniqueID))
                {
                    ExpireCallback expireMethod = clientMap[iClient.uniqueID];
                    clientMap.Remove(iClient.uniqueID);
                    // This should be made into some kind of asynchronous call, 
                    // or it should be recommend that Expire be fast
                    expireMethod.Invoke();
                }
            }
        }


        /// <param name="interval">Interval that the TimeoutManager should 
        ///  check its clients for expirations in milliseconds.</param>
        public TimeoutManager (int interval)
        {
            this.interval = interval;
        }


        /// <summary>
        ///  Adds a client to this TimeoutManager. Lazy initialization is 
        ///  handled by this method.
        /// </summary>
        /// <param name="expireCallback">Method to execute when this client's 
        ///  time has expired.</param>
        /// <param name="timeout">The amount of time in milliseconds for this
        ///  client to expire.</param>
        public int Add (ExpireCallback expireCallback, int timeout)
        {
            if(expireCallback == null)
                throw new ArgumentNullException("expireCallback cannot be null.");

            // Lazy initialization
            if(clients == null)
            {
                clients = new PriorityQueue<InternalClient>();
                clientMap = new Dictionary<int, ExpireCallback>();
                timer = new Timer(checkClients, null, interval, interval);
            }

            InternalClient iClient = new InternalClient(timeout);

            lock(clientMap)
            {
                // Enforce that the generated key is indeed a unique key.
                if(clientMap.ContainsKey(iClient.uniqueID))
                    throw new Exception("TimeoutManager full.");

                clientMap.Add(iClient.uniqueID, expireCallback);
            }

            lock(clients)
            {
                clients.Enqueue(iClient);
            }

            return iClient.uniqueID;
        }


        /// <summary>
        ///  Removes a TimeoutClient from this.
        /// </summary>
        /// <param name="client">TimeoutClient to remove from this.</param>
        public void Remove (int uniqueID)
        {
            if(clients == null)
                return;

            lock(clientMap)
            {
                clientMap.Remove(uniqueID);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\livetest\core\ThreadContainer.cs ===
//
// Utility container for tracing threads across the current
// app domain. When we shut the app we want to be able
// to kill all pending threads even for tests that spawn up
// their own threads. If you don't use ThreadBase you
// should register your Thread object with this class. 
//
// A watchdog thread is provided with EnableWatchdog() to allow debugging in 
// deadlock scenarios. 

// TODO: consider changing thread pri of watchdog to idle
// TODO: use the ThreadBase.Stop() method instead of just killing it to allow
// people to cleanup gracefully.

using System.Threading;
using System.Collections;

namespace livetest.core
{
    public class ThreadContainer
    {
        private class Watchdog
        {
            public void Run()
            {
                while(true)
                {
                    Thread.Sleep(1000);
                }
            }
        }

        private static Watchdog         _Watchdog       = null;
        private static Thread           _WatchdogThread = null;
        private static Hashtable        _ThreadHash     = new Hashtable();
        private static ManualResetEvent _ShutdownEvent  = null;

        public static WaitHandle ShutdownEvent {
            get {
                return _ShutdownEvent;
            }
        }

        // Watchdog thread is useful if you find yourself in deadlock situations
        // where the debugger cannot break because you have locked all the threads.
        public static void EnableWatchdog()
        {
            _Watchdog       = new Watchdog();
            _WatchdogThread = new Thread(new ThreadStart(_Watchdog.Run));
        }

        public static void DisableWatchdog()
        {
            if(null != _Watchdog && null != _WatchdogThread)
            {
                try
                {
                    _WatchdogThread.Abort();
                }
                catch(System.Exception)
                {
                    // Ignore
                }

                _WatchdogThread = null;
                _Watchdog       = null;
            }
        }

        public static WaitHandle Register(Thread thread)
        {
            lock(_ThreadHash)
            {
                if(null == _ShutdownEvent)
                {
                    _ShutdownEvent = new ManualResetEvent(false);
                }
                _ThreadHash.Add(thread, null);
            }

            return _ShutdownEvent;
        }

        public static void Unregister(Thread thread)
        {
            lock(_ThreadHash)
            {
                _ThreadHash.Remove(thread);
            }
        }

        // We will first lock and read the threads before we operate 
        // on them in case an operation on a thread causes it to call
        // back to this class (ThreadBase is hooked to the container).
        // This will might a deadlock.
        private static ArrayList GetSynchronizedThreadList()
        {
            lock(_ThreadHash)
            {
                ArrayList threads = new ArrayList(_ThreadHash.Keys.Count);
                foreach(Thread thread in _ThreadHash.Keys)
                {
                    threads.Add(thread);
                }
                return threads;
            }
        }

        private static void SynchronizedCleanup(ArrayList threads)
        {
            lock(_ThreadHash)
            {
                foreach(Thread thread in threads)
                {
                    _ThreadHash.Remove(thread);
                }
            }
        }

        public static void ClearDeadThreads()
        {
            ArrayList threads = GetSynchronizedThreadList();
            ArrayList cleanup = new ArrayList();
            foreach(Thread thread in threads)
            {
                if(!thread.IsAlive)
                {
                    cleanup.Add(thread);
                }
            }
            SynchronizedCleanup(cleanup);
        }

        public static uint GetActiveCount()
        {
            uint count = 0;
            ArrayList threads = GetSynchronizedThreadList();

            foreach(Thread thread in threads)
            {
                if(thread.IsAlive)
                {
                    count++;
                }
            }

            return count;
        }

        public static uint GetTotalCount()
        {
            return (uint)_ThreadHash.Keys.Count;
        }

        public static void StopAll()
        {
            // Give the threads a chance to respond to the shutdown event
            // and cleanup the threads that are finished cleanup.
            _ShutdownEvent.Set();
            Thread.Sleep(100);
            ClearDeadThreads();

            ArrayList threads = GetSynchronizedThreadList();
            foreach(Thread thread in threads)
            {
                try
                {
                    thread.Abort();
                }
                catch(System.Exception)
                {
                    // Ignore
                }
            }

            ClearDeadThreads();

            // Destroy the shutdown event
            lock(_ThreadHash)
            {
                _ShutdownEvent.Close();
                _ShutdownEvent = null;
            }
        }

        public static void InterruptAll()
        {
            ArrayList threads = GetSynchronizedThreadList();

            foreach(Thread thread in threads)
            {
                try
                {
                    thread.Interrupt();
                } 
                catch(System.Exception)
                {
                    // Ignore
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\livetest\samples\busmon\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\livetest\samples\stress\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\livetest\samples\busmon\BusmonPlugin.cs ===
using livetest.core;
using System.Windows.Forms;
using System.Threading;
using System.Diagnostics;

namespace livetest.plugin.busmon
{
	public class BusMon : Plugin
	{
		static private Report ro = new Report(typeof(BusMon).Name);
        private BusMonWindow _Window; 
        private Thread       _UIThread;

		public override void OnPluginLoaded()
		{
            Debug.Assert(null == _Window);

		    ro.Info("Busmon plugin loaded, starting UI thread");

            // Fork the UI thread
            _UIThread = new Thread(new ThreadStart(this.UIThreadProc));
            ThreadContainer.Register(_UIThread);
            _UIThread.Start();
        }

        public override void OnPluginUnloaded()
        {
			ro.Info("Busmon plugin unloaded.");
		}

        public override void HandleMessage(livetest.core.Message msg)
        {
            base.HandleMessage(msg);

            if(null != _Window && !_Window.IsDisposed)
            {
                _Window.Invoke(new WindowLogMessageDelegate(_Window.LogMessage), new object[] { msg });
            }
        }

        private delegate void WindowLogMessageDelegate(livetest.core.Message msg);
        
        // Application run requires a seperate thread to manage the UI
        private void UIThreadProc()
        {
            _Window = new BusMonWindow();
            Application.Run(_Window);
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\livetest\samples\busmon\BusMonWindow.cs ===
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;

using livetest.core;

namespace livetest.plugin.busmon
{
    /// <summary>
    /// Summary description for BusMonWindow.
    /// </summary>
    public class BusMonWindow : System.Windows.Forms.Form
    {
        private const uint LOG_MAX  = 1024;
        private const uint LOG_MASK = 1023;

        private System.Windows.Forms.ListView logView;
        
        private uint           _Cursor;
        private uint           _Count;
            

        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.Container components = null;

        public BusMonWindow()
        {
            //
            // Required for Windows Form Designer support
            //
            InitializeComponent();

            logView.Columns.Add("Arrived", 80, HorizontalAlignment.Left);
            logView.Columns.Add("Src", 40, HorizontalAlignment.Left);
            logView.Columns.Add("Dst", 40, HorizontalAlignment.Left);
            logView.Columns.Add("TypeName", 120, HorizontalAlignment.Left);
            logView.Columns.Add("Size", 40, HorizontalAlignment.Left);
            logView.Columns.Add("DataValue", 220, HorizontalAlignment.Left);
        }

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        protected override void Dispose( bool disposing )
        {
            if( disposing )
            {
                if(components != null)
                {
                    components.Dispose();
                }
            }
            base.Dispose( disposing );
        }

        public void LogMessage(livetest.core.Message msg)
        {

            string[]    values = new string[]
            {
                DateTime.Now.ToString(),
                    null != msg.Src ? msg.Src : "",
                    null != msg.Dst ? msg.Dst : "",
                    msg.Name,
                    (null != msg.PayloadBytes ? msg.PayloadBytes.Length : 0).ToString(),
                    (null != msg.Payload ? msg.Payload.ToString() : "")
            };

            if(_Count < LOG_MAX)
            {
                ListViewItem lvi = new ListViewItem(values);
                logView.Items.Add(lvi);
                _Count++;
            }
            else
            {
                ListViewItem lvi = logView.Items[(int)_Cursor];
                lvi.SubItems[0].Text = values[0];
                lvi.SubItems[1].Text = values[1];
                lvi.SubItems[2].Text = values[2];
                lvi.SubItems[3].Text = values[3];
                lvi.SubItems[4].Text = values[4];
                lvi.SubItems[5].Text = values[5];
            }
                
            _Cursor = (_Cursor + 1) & LOG_MASK;
        }

        #region Windows Form Designer generated code
        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.logView = new System.Windows.Forms.ListView();
            this.SuspendLayout();
            // 
            // logView
            // 
            this.logView.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
            this.logView.Dock = System.Windows.Forms.DockStyle.Fill;
            this.logView.Location = new System.Drawing.Point(0, 0);
            this.logView.Name = "logView";
            this.logView.Size = new System.Drawing.Size(608, 237);
            this.logView.TabIndex = 0;
            this.logView.UseCompatibleStateImageBehavior = false;
            this.logView.View = System.Windows.Forms.View.Details;
            // 
            // BusMonWindow
            // 
            this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
            this.ClientSize = new System.Drawing.Size(608, 237);
            this.Controls.Add(this.logView);
            this.Name = "BusMonWindow";
            this.Text = "BusMonWindow";
            this.ResumeLayout(false);

        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\livetest\samples\stress\SampleStress.cs ===
using System;
using System.Net;
using System.Net.Sockets;

using livetest.core;

namespace livetest.samples.stress
{
    // Do all your hostname->address lookups ahead of time, the IO engine
    // is not going to provide an async/caching NS mechanism for you. If you want
    // one you can provide it yourself. Realize that a simplistic cache is going
    // to cause thread contention.
    public class WorkerGlobal
    {
        static public IPAddress Address    = IPAddress.Loopback;
        static public ushort Port          = 80;
    }

    public class XNullWorker : HttpWorker
    {
        static Report ro = new Report(typeof(XNullWorker).Name);

        // Allocate a static buffer on the base worker
        public XNullWorker() : base(0x1000)
        {
        }

        // Measure your packet ahead of time and then layout 
        // your buffer on the provided cached worker buffer
        public void Test1()
        {
            AppendRequest("POST", "/xnull/xnull.asmx", null, 1);
            AppendByte(0x1);

            StartSend(
                    WorkerGlobal.Address, 
                    WorkerGlobal.Port, 
                    new HttpWorker.Callback(this.CompleteTest1));
        }

        public void CompleteTest1()
        {
            ro.Debug("Finished test1");
        }

        public void Test2()
        {
            AppendRequest("POST", "/xnull/xnull.asmx", null, 1);
            AppendByte(0x2);
            StartSend(
                    WorkerGlobal.Address, 
                    WorkerGlobal.Port, 
                    new HttpWorker.Callback(this.CompleteTest2));
        }

        public void CompleteTest2()
        {
            ro.Debug("Finished test2");
        }
    }

    // This simple worker only subclasses the straight worker
    // type. This is mainly just a test of the throughput of 
    // the scheduler. 
    //
    // Note that this worker has to manually call the Finish()
    // method of the super class to make sure that the worker
    // is posted back to the scheduler.
    public class SimpleWorker : Worker
    {
        public void Test()
        {
            Finish();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\livetest\samples\UDPBenchmark\BenchmarkCM.cs ===
using System;
using System.Net;

using livetest.core;

namespace livetest.samples.UDPSample {

    /// <summary>
    ///  Holds settings for the BenchmarkCM. A reminder that all fields that 
    ///  are loaded from the xml file need to be made public.
    /// </summary>
    public class BenchmarkSettings : SettingsObj {
        public string ipaddress;
        public int port;
        public uint smallsize;
        public uint largesize;
        public uint mediumsize;

        public override string ToString () {
            return "ipaddress: "+ipaddress+"\nport: "+port;
        }
    }

    /// <summary>
    ///  IContextManager for the UDPBenchmarkWorker.
    /// </summary>
    public class BenchmarkCM : IContextManager {

        private BenchmarkSettings bSettings;

        /// <summary>
        ///  Initializes a new instance of the BenchmarkCM. This method loads 
        ///  the internal BenchmarkSettings object and uses those loaded 
        ///  settings to configure the ipaddress and port to run the benchmark 
        ///  on.
        /// </summary>
        public BenchmarkCM () {
            bSettings = ConfigLoader.LoadSettingsObj<BenchmarkSettings>("BenchmarkSettings.xml");
            UDPBenchmarkWorker.remoteEP = new IPEndPoint(IPAddress.Parse(bSettings.ipaddress), bSettings.port);
        }

        #region IContextManager Members

        private enum BenchmarkContexts {
            SMALL,
            MEDIUM,
            LARGE
        }


        /// <summary>
        ///  Each task has a context associated with it. This context lets the 
        ///  BenchmarkCM know what size UDP packet a UDPBenchmarkWorker should 
        ///  send.
        /// </summary>
        public bool Acquire (uint[] types, Worker worker) {
            if (types.Length != 1)
                return false;
            if (!(worker is UDPBenchmarkWorker))
                return false;

            UDPBenchmarkWorker bWorker = (UDPBenchmarkWorker)worker;

            switch (types[0]) {
                case (uint)BenchmarkContexts.SMALL:
                    bWorker.dataSize = bSettings.smallsize;
                    break;
                case (uint)BenchmarkContexts.MEDIUM:
                    bWorker.dataSize = bSettings.mediumsize;
                    break;
                case (uint)BenchmarkContexts.LARGE:
                    bWorker.dataSize = bSettings.largesize;
                    break;
                default:
                    bWorker.dataSize = bSettings.smallsize;
                    break;
            }

            return true;
        }

        public bool Release (Worker worker) {
            return true;
        }

        public uint ContextTypeNameToId (string typeName) {
            switch (typeName) {
                case "small":
                    return (uint)BenchmarkContexts.SMALL;
                case "medium":
                    return (uint)BenchmarkContexts.MEDIUM;
                case "large":
                    return (uint)BenchmarkContexts.LARGE;
                default:
                    return (uint)BenchmarkContexts.SMALL;
            }
        }

        #endregion
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\livetest\samples\UDPBenchmark\UDPBenchmarkWorker.cs ===
using System.Net;

using livetest.core;

namespace livetest.samples.UDPSample {

    /// <summary>
    ///  <para>This UDPWorker has two types of tasks that it can execute. The 
    ///   first, BenchmarkSend, simply sends a UDP packet of variable length to 
    ///   a server. The second, BenchmarkSendAndReceive, sends a UDP packet and
    ///   asynchronously waits for a response from the server. This Worker is 
    ///   meant to send its data to a ThroughputReflector--a server which 
    ///   either just gobbles packets, reflects them back, or other various 
    ///   services. See kgoodier for more details on the ThroughputReflector.
    ///  </para>
    /// 
    ///  <para>Each UDPBenchmarkWorker has an internal byte data buffer of size
    ///   1400 bytes and a unsigned int of how many bytes to send in a given 
    ///   task.</para>
    /// 
    ///  <specfield name="dataSize">Size of packet to send.</specfield>
    ///  <specfield name="buffer">Represents the internal buffer this 
    ///   UDPBenchmarkWorker uses to send UDP packets.</specfield>
    /// </summary>
    public class UDPBenchmarkWorker : UDPWorker {

        private const uint MAX_BUFFER_SIZE = 1400;
        private byte[] buffer;

        public static IPEndPoint remoteEP;
        public uint dataSize = 16;

        /// <summary>Initializes a new UDPBenchmarkWorker.</summary>
        public UDPBenchmarkWorker () {
            buffer = new byte[MAX_BUFFER_SIZE];
        }

        /// <summary>
        ///  Simply sends a packet of this.dataSize length. Since the first 
        ///  byte of this.buffer is set to 0x80, the ThroughputReflector 
        ///  gobbles the packet when it receives it.
        /// </summary>
        public void BenchmarkSend () {
            buffer[0] = 0x80;
            SendTo(buffer, 0, (int)dataSize, remoteEP);
            Finish();
        }

        /// <summary>
        ///  This task sets the first byte of this.buffer to 0x81 (which 
        ///  corresponds to a ThroughputReflector reflection of the incoming 
        ///  packet, back to where it came from). It then begins 
        ///  asynchronously receiving and registers a completion callback. It 
        ///  then sends a packet to the ThroughputReflector. When the packet 
        ///  is reflected back to this Worker, the callback is invoked and 
        ///  Finish() is called on the UDPBenchmarkWorker. If this test is 
        ///  failing it is probably due to the fact that the 
        ///  ThroughputReflector is not running at this.remoteEP.
        /// </summary>
        public void BenchmarkSendAndReceive () {
            buffer[0] = 0x81;

            StartReceive(buffer, 0, (int)dataSize, new ReceiveCallback(BenchmarkSendAndReceiveCallback));
            SendTo(buffer, 0, (int)dataSize, remoteEP);
        }

        // Callback that is invoked when the ThroughputReflector sends data 
        // back to this.
        private void BenchmarkSendAndReceiveCallback (EndPoint sender,
                                                      int bytesReceived) {
            Finish();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\livetest\samples\XMACS\XMACSCM.cs ===
using System;
using System.Xml;
using System.IO;
using System.Collections.Generic;

using livetest.core;

using ServerTestFramework;
using ServerTestFramework.LiveService.Auth;

namespace livetest.samples.XMACS {

    /// <summary>
    ///  <para>Xbox Machine Account Creation Server Context Manager. This class 
    ///   prepares XMACSWorkers with the necessary resources to start their
    ///   task. It also contains a Report object to log Worker and 
    ///   ContextManager activity.</para>
    /// 
    ///  <para>stf.xml should be in the same folder as the assembly that holds 
    ///   this class.</para>
    /// </summary>
    public class XMACSCM : IContextManager {

        // Available contexts (this comes from the xml configuration file)
        enum Contexts {
            XBOXCREATE,
            XBOXREUSE,
            XENONCREATE,
            XENONREUSE,
            PANORAMACREATE,
            PANORAMAREUSE
        }

        /// <summary>
        ///  Reporting object used by XMACSWorkers to log events.
        /// </summary>
        public static livetest.core.Report XMACSReport;

        // Boundaries on the # of XmacsClients to have in any of the below 
        // Queues at once. This should match the number of workers in the xml confi
        const int MAX_CLIENTS = 1000;
        const int MIN_CLIENTS = 300;

        string logFilePath;
        Queue<XmacsClient> xboxClients;
        Queue<XmacsClient> xenonClients;
        Queue<XmacsClient> panoramaClients;

        /// <summary>
        ///  Initializes a new XMACSCM object. stf.xml must be in the same 
        ///  folder as the current executing directory.
        /// </summary>
        public XMACSCM () 
        {
            xboxClients = new Queue<XmacsClient>();
            xenonClients = new Queue<XmacsClient>();
            panoramaClients = new Queue<XmacsClient>();

            // STF initialization
            XmlDocument stfDoc = ConfigLoader.GetXMLDocument(@"stf.xml");
            Global.NpdbSettings = null;
            Global.Initialize(stfDoc);
            Global.XEnv.Initialize(stfDoc);

            // Reporting code for XMACS Workers
            XMACSReport = new livetest.core.Report("XMACS report");
            logFilePath = @"log.txt";
            XMACSReport.AddReportDestination(new XMACSReportDestination(new FileInfo(Path.GetFullPath(logFilePath))));

            // This is for Panorama initialization
            AuthClientBase.InitializeKerbClient();
            AuthClientBase.InitializePassportIDCRL();
        }

        #region IContextManager Members

        /// <summary>
        ///  This method checks to see what kind of task the worker is trying 
        ///  to Acquire and sets the AuthContext of the worker appropriately.
        /// </summary>
        /// <param name="types">This method assumes that there is only one 
        ///  type passed in to the xml configuration file</param>
        /// <param name="worker">Worker to acquire resources for.</param>
        /// <returns>true if the worker is ready to execute its next task.
        /// </returns>
        public bool Acquire (uint[] types, Worker worker) 
        {
            XMACSWorker xWorker = (XMACSWorker)worker;

            switch (types[0]) {

                case (uint)Contexts.XBOXCREATE:
                    return createXmacsClient(xWorker, AuthContext.ClientTypes.Xbox, xboxClients);

                case (uint)Contexts.XENONCREATE:
                    return createXmacsClient(xWorker, AuthContext.ClientTypes.Xenon, xenonClients);

                case (uint)Contexts.PANORAMACREATE:
                    return createXmacsClient(xWorker, AuthContext.ClientTypes.Panorama, panoramaClients);

                case (uint)Contexts.XBOXREUSE:
                    return swapXmacsClient(xWorker, xboxClients);

                case (uint)Contexts.XENONREUSE:
                    return swapXmacsClient(xWorker, xenonClients);

                case (uint)Contexts.PANORAMAREUSE:
                    return swapXmacsClient(xWorker, panoramaClients);

                default:
                    throw new Exception("IWorkerManger trying to acquire an invalid context type: "+types[0]);
            }
        }

        /// <summary>
        ///  This simply returns true, nothing needs to be done when a 
        ///  XMACSWorker completes its task.
        /// </summary>
        /// <param name="worker">Worker to release</param>
        /// <returns>true if 'worker' was properly released.</returns>
        public bool Release (Worker worker) 
        {
            XMACSWorker xWorker = (XMACSWorker)worker;

            if(xWorker.xmacsClient == null)
                return true;

            switch (xWorker.xmacsClient.Context.ClientType)
            {
                case AuthContext.ClientTypes.Xbox:
                    if(xboxClients.Count < MAX_CLIENTS)
                        xboxClients.Enqueue(xWorker.xmacsClient);
                    break;

                case AuthContext.ClientTypes.Xenon:
                    if(xenonClients.Count < MAX_CLIENTS)
                        xenonClients.Enqueue(xWorker.xmacsClient);
                    break;

                case AuthContext.ClientTypes.Panorama:
                    if(panoramaClients.Count < MAX_CLIENTS)
                        panoramaClients.Enqueue(xWorker.xmacsClient);
                    break;
            }

            return true;
        }

        /// <summary>
        ///  Converts a string in the xml config file to a Contexts uint value.
        /// </summary>
        /// <param name="typeName">string to convert.</param>
        /// <returns>The uint representation of typeName.</returns>
        public uint ContextTypeNameToId (string typeName) {
            switch (typeName) {
                case "xboxcreate":
                    return (uint)Contexts.XBOXCREATE;
                case "xboxreuse":
                    return (uint)Contexts.XBOXREUSE;
                case "xenoncreate":
                    return (uint)Contexts.XENONCREATE;
                case "xenonreuse":
                    return (uint)Contexts.XENONREUSE;
                case "panoramacreate":
                    return (uint)Contexts.PANORAMACREATE;
                case "panoramareuse":
                    return (uint)Contexts.PANORAMAREUSE;
                default:
                    throw new Exception("Invalid context type read from xml configuration file: "+typeName);
            }
        }

        #endregion

        // Creates a new XmacsClient
        static bool createXmacsClient (XMACSWorker xWorker, 
                                       AuthContext.ClientTypes clientType, 
                                       Queue<XmacsClient> clientQueue)
        {
            if(clientQueue.Count >= MIN_CLIENTS)
            { // If there are enough, reuse an existing XmacsClient
                xWorker.xmacsClient = clientQueue.Dequeue();
                xWorker.xmacsClient.isManualSetup = true;
                XmacsClient.SetDefaults(xWorker.xmacsClient.Context);
            }
            else
            { // Not enough, create a new XmacsClient
                AuthContext newAuthContext = new AuthContext(clientType);
                xWorker.xmacsClient = new XmacsClient(newAuthContext);
                xWorker.xmacsClient.ReceivePacketBuffer = new byte[1500];
                xWorker.xmacsClient.isManualSetup = true;
                XmacsClient.SetDefaults(xWorker.xmacsClient.Context);

                try
                {
                    if(clientType == AuthContext.ClientTypes.Panorama)
                        xWorker.xmacsClient.Context.PassportAuthenticate();
                }
                catch(PassportException pe)
                {
                    XMACSReport.Error("Failed to PassportAuthenticate: "+pe);
                    return false;
                }
            }

            return true;
        }

        // Dequeues an existing XmacsClient from availableClients to give to 
        // an xWorker.
        static bool swapXmacsClient (XMACSWorker xWorker, Queue<XmacsClient> availableClients)
        {
            if(availableClients.Count > 0)
            {
                xWorker.xmacsClient = availableClients.Dequeue();
                return true;
            }
            return false;
        }
    }

    /// <summary>
    ///  Handles reporting for this XMACS test. This basically writes to a text 
    ///  file.
    /// </summary>
    public class XMACSReportDestination : livetest.core.Report.Destination, IDisposable {

        TextWriter textWriter;

        public XMACSReportDestination (FileInfo fInfo) {
            textWriter = new StreamWriter(fInfo.FullName);
        }

        #region IDisposable Members

        public void Dispose () {
            if (textWriter != null)
                textWriter.Close();
        }

        #endregion

        #region Destination Members

        public void Log (livetest.core.Report.Level level, string path, string message) {
            textWriter.WriteLine(path+"--"+level+": "+message);
            textWriter.Flush();
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\livetest\tools\console\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\livetest\tools\service\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\livetest\samples\XMACS\XMACSWorker.cs ===
using System;
using System.Threading;
using System.Net;
using System.Runtime.InteropServices;

using livetest.core;

using ServerTestFramework.LiveService.Auth;

namespace livetest.samples.XMACS {

    /// <summary>
    ///  The XMACSWorker class has two types of tasks. One of the tasks is to
    ///  sign in to the XMACS and create a new machine account. The other task
    ///  is to reuse a machine account and sign in to the XMACS. Each platform
    ///  has this pair of tasks. After the XMACSWorker sends the request to the
    ///  XMACS, it waits in a system thread for a response. At the time the 
    ///  request is sent, the XMACSWorker registers itself with a
    ///  TimeoutManager. This TimeoutManager will cause the XMACSWorker to end
    ///  its waiting and log an error to Report held by the XMACSCM class.
    /// </summary>
    public class XMACSWorker : UDPWorker {

        // Statics
        static TimeoutManager timeoutManager = new TimeoutManager(1000);
        const int TIMEOUT = 30000; // in ms

        // Member Variables
        public XmacsClient xmacsClient;
        int timeoutID;


        public XMACSWorker () { }


        /// <summary>Starts the XMACS sign-in process.</summary>
        public void BeginSignIn () {
            try {
                xmacsClient.BuildRequest();

                StartReceive(xmacsClient.ReceivePacketBuffer,
                             0, xmacsClient.ReceivePacketBuffer.Length,
                             new ReceiveCallback(SignInComplete));

                timeoutID = timeoutManager.Add(
                    delegate() {
                        EndReceive(true);
                        XMACSCM.XMACSReport.Error("Worker timedout: "+xmacsClient.Context.ClientType);
                        Fail("Worker timedout waiting for a response from the XMACS.");
                        Finish();

                    }, TIMEOUT);

                //Send it
                SendTo(xmacsClient.SendPacketBuffer, 0, xmacsClient.SendPacketBufferLength, xmacsClient.IpServer);

            } catch (Exception e) {
                EndReceive(true);
                HandleException(e);
                Finish();
            }
        }


        // Executed if this worker receives a response from the XMACS before 
        // the expiration of the timeout.
        void SignInComplete (EndPoint sender, int bytesReceived)
        {
            timeoutManager.Remove(timeoutID);

            if(_Exception == null)
            {
                try
                {
                    xmacsClient.ReceivePacketBufferLength = bytesReceived;
                    xmacsClient.VerifyResponse();
                }
                catch(Exception e)
                {
                    HandleException(e);
                }
            }

            Finish();
        }


        // Handles any exceptions encountered in this worker. Notice that it 
        // makes sure to remove the worker from the TimeoutManager, otherwise 
        // the timeout delegate will be launched after the worker starts 
        // working on its next task.
        void HandleException (Exception e) 
        {
            timeoutManager.Remove(timeoutID);
            XMACSCM.XMACSReport.Error(xmacsClient.Context.ClientType+"--"+e.ToString());
            _Exception = e;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\livetest\tools\stress\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\livetest\tools\console\Console.cs ===
using System;
using System.Xml;
using System.Text.RegularExpressions;
using System.Collections;
using System.Net;
using System.Net.Sockets;

using livetest.core;

namespace livetest.tools.console
{
    public class MainClass : IMessageHandler
    {
        enum Mode
        {
            None,
            Run,
            List,
            Interactive
        }

        private Mode _Mode;
        private CommandManager _Commands;
        private string []_PeerList;
        private static Report _Report = new Report("Console");

        private const string _ChannelName = "console";

        [STAThread]
        public static void Main(string []args)
        {
            // Route all reports form the root to debug output and consoleX
            Report.Root.AddReportDestination(new DebugOutputReportDestination());
            Report.Root.AddReportDestination(new ConsoleReportDestination());

            try
            {
                new MainClass().InternalMain(args);
            }
            catch(Exception ex)
            {
                _Report.Error("There was an error: {0}\nDetails: {1}",
                        ex.Message,
                        ex.ToString());
            }
            finally
            {
                BusManager.Instance.Shutdown();
            }
        }

        protected void InternalMain(string []args)
        {
            CommandLine.Switch runSwitch;

            CommandLineParser clp = new CommandLineParser(
                    "STFConsole.exe <options> <test suites (.dll)> <test config files (.xml)>",
                     "");

			clp.AddSwitch("help", "Show usage", true);
			clp.AddSwitch("?", "Show usage", true);
			clp.AddSwitch("run", "Expression to match against tests to run (/run:*Alive*)", true);
			clp.AddSwitch("list", "Expression to match against tests to list, tests will not execute", true);
			clp.AddSwitch("interactive", "Execute console in interactive mode", true);
			clp.AddSwitch("peerlist", 1, "List of peer addresses to connect to", "Peer list", true);
			clp.AddSwitch("wait", "Wait until the user presses a key before exiting.", true);
			clp.AddSwitch("nofilelog", "Disable logging results to a file (FuncResults\\*).", true);
            clp.AddSwitch("regdb", "Hostname of RegDB server for results reporting", false);

            CommandLine cl = clp.Parse(args);


            if(cl.HasSwitch("help") || cl.HasSwitch("?"))
            {
                clp.PrintUsage();
                goto lbDone;
            }
            
            //
            // Mode selection
            //
            runSwitch = cl.Switches["run"] as CommandLine.Switch;
            if(null != runSwitch)
            {
                _Mode = Mode.Run;
            }
            if(Mode.None == _Mode)
            {
                runSwitch = cl.Switches["list"] as CommandLine.Switch;
                if(null != runSwitch)
                {
                    _Mode = Mode.List;
                }
            }
            if(Mode.None == _Mode)
            {
                runSwitch = cl.Switches["interactive"] as CommandLine.Switch;
                if(null != runSwitch)
                {
                    _Mode = Mode.Interactive;
                }
            }

            if(cl.HasSwitch("peerlist") && null != cl.Switches["peerlist"])
            {
                CommandLine.Switch sw = (CommandLine.Switch)cl.Switches["peerlist"];
                _PeerList = sw.Params;
            }

            // Do one-time initialization
            Initialize();

            switch(_Mode)
            {
                case Mode.Run:
                    break;
                case Mode.List:
                    break;
                case Mode.Interactive:
                    InteractivePrompt();
                    break;
            }

lbDone:
            // Wait for user input if requested
			if (cl.HasSwitch("wait"))
            {
				AnyKey();
            }
        }

        private void Initialize()
        {
            Bus.Default.RegisterChannel(_ChannelName, this);
            _Commands = new CommandManager(this);

            if(null != _PeerList)
            {
                foreach(string peer in _PeerList)
                {
                    BusManager.Instance.AddPeer(peer);
                }
            }
        }

        private void InteractivePrompt()
        {
            string line;

            _Report.Info("LiveTest console starting interactive mode...");

            while(null != (line = Console.ReadLine()))
            {
                _Report.Debug("Input: {0}", line);

                try
                {
                    _Commands.ExecuteString(line);
                }
                catch(CommandException ex)
                {
                    _Report.Error(ex.Message);
                }
            }
        }

        // From IMessageHandler
        public void HandleMessage(Message msg)
        {
            // Don't spam the console with keep-alives
            if(BusManager.KeepAlive != msg.Name)
            {
                _Report.Debug("[HandleMessage] name: {0}, route: {1}->{2}, payload: ({3})", 
                        msg.Name,
                        msg.Src,
                        msg.Dst,
                        null != msg.Payload ? msg.Payload.ToString() : "<null>");
            }
        }

		private void AnyKey()
		{
			ConsoleX.WriteLine();
			ConsoleX.WriteLine("Press any key to continue");
			ConsoleX.getch();
		}

        [Command]
        private void ListChannels()
        {
            Bus.Default.Publish(
                    BusManager.ChannelListQuery,
                    _ChannelName,
                    BusManager.AnyHost + Message.PathScopeOperatorString + BusManager.ChannelName,
                    null);
        }

        [Command]
        private void Subscribe(string target)
        {
            Bus.Default.RegisterChannel(target, this);
        }

        [Command]
        private void GetActions()
        {
            Bus.Default.Publish(
                    Topology.GetActions,
                    _ChannelName,
                    BusManager.Broadcast,
                    null);
        }

        [Command]
        private void GetTopology()
        {
            Bus.Default.Publish(
                    Topology.Read,
                    _ChannelName,
                    BusManager.Broadcast,
                    new StringListPayload(new string[]{"/"}));
        }

        [Command]
        private void Execute(string path)
        {
            Bus.Default.Publish(
                    Topology.ExecuteNodes,
                    _ChannelName,
                    BusManager.Broadcast,
                    new TopologyExecutePayload(path, new byte[]{0,1,2}));
        }

        [Command]
        private void ShowPeers()
        {
            string []knownPeers = BusManager.Instance.KnownPeers;
            for(int i = 0; i < knownPeers.Length; ++i)
            {
                string host = knownPeers[i];
                _Report.Info("[ShowPeers] Peer[{0}]: {1}",
                        i,
                        host);
            }
        }

        [Command]
        private void AddPeer(string peer)
        {
            BusManager.Instance.AddPeer(peer);
        }

        [Command]
        private void RemovePeer(string peer)
        {
            BusManager.Instance.RemovePeer(peer);
        }

        [Command]
        private void Quit()
        {
            Environment.Exit(0);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\livetest\tools\stress\LogView.cs ===
using System;
using System.Drawing;
using System.Windows.Forms;

using livetest.core;

namespace livetest.stress {

    public class LogView : Form, Report.Destination {
        private RichTextBox logTextBox;

        public LogView (string title) {

            InitializeComponent();
            Text = title;
            Hide();
        }

        public void Log (Report.Level level, string path, string message) {

            switch (level) {
                case Report.Level.SUCCESS:
                    logTextBox.SelectionColor = Color.Lime;
                    break;
                case Report.Level.INFO:
                    logTextBox.SelectionColor = Color.Cyan;
                    break;
                case Report.Level.WARN:
                    logTextBox.SelectionColor = Color.Yellow;
                    break;
                case Report.Level.FATAL:
                    logTextBox.SelectionColor = Color.Magenta;
                    break;
                case Report.Level.ERROR:
                    logTextBox.SelectionColor = Color.Red;
                    break;
                case Report.Level.DEBUG:
                    logTextBox.SelectionColor = Color.Silver;
                    break;
                default:
                    logTextBox.SelectionColor = Color.Silver;
                    break;
            }

            logTextBox.SelectedText = path+"--"+level+": "+message+"\n";
            logTextBox.Refresh();
        }

        private void InitializeComponent () {
            this.logTextBox = new System.Windows.Forms.RichTextBox();
            this.SuspendLayout();
            // 
            // logTextBox
            // 
            this.logTextBox.BackColor = System.Drawing.Color.Black;
            this.logTextBox.Dock = System.Windows.Forms.DockStyle.Fill;
            this.logTextBox.Location = new System.Drawing.Point(0, 0);
            this.logTextBox.Name = "logTextBox";
            this.logTextBox.Size = new System.Drawing.Size(792, 266);
            this.logTextBox.TabIndex = 0;
            this.logTextBox.Text = "";
            // 
            // LogView
            // 
            this.ClientSize = new System.Drawing.Size(792, 266);
            this.Controls.Add(this.logTextBox);
            this.Name = "LogView";
            this.FormClosing += new System.Windows.Forms.FormClosingEventHandler(this.LogViewClose);
            this.ResumeLayout(false);

        }

        private void LogViewClose (Object sender, FormClosingEventArgs e) {
            e.Cancel = true;
            Hide();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\livetest\tools\stress\StressMain.cs ===
using System;
using System.Windows.Forms;

using livetest.core;

namespace livetest.stress
{
    /// <summary>
    ///  Class that holds the main entry point for the stress test runner.
    /// </summary>
    public class StressMain
    {
        static private Report ro = new Report(typeof(StressMain).Name);

        /// <summary>
        ///  Main entry point for the Stress tool.
        /// </summary>
        /// <param name="args">Command line arguments.</param>
        [STAThread()]
        public static void Main (string[] args)
        {
            try
            {
                InternalMain(args);

            }
            catch(Exception ex)
            {
                MessageBox.Show(ex.ToString(), "Error while starting stress application",
                        MessageBoxButtons.OK, MessageBoxIcon.Stop);
                System.Console.WriteLine("An error occurred: " + ex.ToString());
            }
        }

        private static void InternalMain (string[] args)
        {
            //Bus.Default.RegisterForMessageLevel(Bus.LEVEL_SYSTEM, this);
            //Bus.Default.RegisterForMessageLevel(Bus.LEVEL_PLUGIN, this);
            //_Window = new BusMonWindow();

            StressMonitorWindow window;

            if(0 == args.Length)
                window = new StressMonitorWindow();
            else
                window = new StressMonitorWindow(args[0]);

            Application.Run(window);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\livetest\tools\service\LiveTestService.cs ===
using System;
using System.IO;
using System.Windows.Forms;

using livetest.core;

namespace livetest.service
{
    public class LTS
    {
        public static Report Report = new Report("LiveTestService");

        [STAThread]
        public static int Main(string []args)
        {
            // Configure reporting
            Report.Root.AddReportDestination(new DebugOutputReportDestination());

            // Read in command line arguments
            
            // Configure initial paths
            PathResolver resolver = PathResolver.Default;
            resolver.AddPath("config", Path.GetFullPath(".") + "\\config");
            resolver.AddPath("plugin", Path.GetFullPath(".") + "\\plugins");

            // Load any plugins (will auto-full load plugins based on config)
            try
            {
                PluginLoader loader = new PluginLoader();
                loader.LoadAll();
            }
            catch (PluginException ex)
            {
                LTS.Report.Error("PluginLoader failed to load plugins: " + ex.ToString());
            }

            // Startup the system tray monitor/invoker
            Application.Run(new SystemTray());

            return 0;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\livetest\tools\service\SystemTray.cs ===
using System;
using System.Drawing;
using System.Resources;
using System.ComponentModel;
using System.Windows.Forms;

using livetest.core;

public class SystemTray : System.Windows.Forms.Form
{
	private System.Windows.Forms.NotifyIcon WSNotifyIcon;
	private System.ComponentModel.IContainer components;
	private Icon mDirIcon = new Icon(typeof(SystemTray).Assembly.GetManifestResourceStream("FLGUSA02.ICO"));
	
	public SystemTray()
	{
		//constructor for the form
		InitializeComponent();
		
		//keep the form hidden
		this.Hide();
		InitializeNotifyIcon();

	}

	/// <summary>
	/// Clean up any resources being used.
	/// </summary>
	protected override void Dispose( bool disposing )
	{
		if( disposing )
		{
			if (components != null) 
			{
				components.Dispose();
			}
		}
		base.Dispose( disposing );
	}

	#region Windows Form Designer generated code
	/// <summary>
	/// Required method for Designer support - do not modify
	/// the contents of this method with the code editor.
	/// </summary>
	private void InitializeComponent()
	{
		this.components = new System.ComponentModel.Container();
		this.WSNotifyIcon = new System.Windows.Forms.NotifyIcon(this.components);
		// 
		// WSNotifyIcon
		// 
		this.WSNotifyIcon.Text = "";
		this.WSNotifyIcon.Visible = true;
		// 
		// SysTray
		// 
		this.AccessibleRole = System.Windows.Forms.AccessibleRole.None;
		this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
		this.ClientSize = new System.Drawing.Size(8, 7);
		this.ControlBox = false;
		this.Enabled = false;
		this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.None;
		this.MaximizeBox = false;
		this.MinimizeBox = false;
		this.Name = "SystemTray";
		this.Opacity = 0;
		this.ShowInTaskbar = false;
		this.StartPosition = System.Windows.Forms.FormStartPosition.Manual;

	}
	#endregion


	public void BusChannelQuery(object sender, EventArgs e)
	{
        Bus.Default.Publish(
                BusManager.ChannelListQuery,
                Bus.AnyChannel,
                BusManager.ChannelName, 
                null,
                livetest.core.Message.AsyncDelivery);
	}


	public void ExitControlForm(object sender, EventArgs e)
	{
		//Hide the NotifyIcon.
		WSNotifyIcon.Visible=false;

		this.Close();

        Environment.Exit(0);
	}


	private void InitializeNotifyIcon()
	{
		//setup the Icon
		NotifyIcon WSNotifyIcon = new NotifyIcon();
		WSNotifyIcon.Icon = mDirIcon;
		WSNotifyIcon.Text = "LiveTest Service";
		WSNotifyIcon.Visible = true;
		
		//Create the MenuItem objects and add them to
		//the context menu of the NotifyIcon.
		MenuItem[] mnuItems = new MenuItem[3];
		
		//create the menu items array
		mnuItems[0] = new MenuItem("Query bus channels", new EventHandler(this.BusChannelQuery));
		mnuItems[0].DefaultItem=true;
		mnuItems[1] = new MenuItem("-");
		mnuItems[2] = new MenuItem("Exit", new EventHandler(this.ExitControlForm));
		
		//add the menu items to the context menu of the NotifyIcon
		ContextMenu notifyIconMenu = new ContextMenu(mnuItems);
		WSNotifyIcon.ContextMenu=notifyIconMenu;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\livetest\tools\service\CommandLine.cs ===
using System;
using System.Collections;

namespace livetest.service
{
	public class CommandLine
	{
		public class Switch
		{
			public string Name;
			public string[] Params = null;

			public Switch(string name)
			{
				Name = name;
			}
		}

		public bool HasSwitch(string name)
		{
			return Switches[name] != null;
		}

		public Hashtable Switches = new Hashtable();
		public string[] Params = null;
	}

	public class CommandLineParser
	{
		public class SwitchType
		{
			public string Name;
			public int NumArgs;
			public string ParamDescription;
			public string Description;
			public bool UsageVisible = true;
			public bool Shortcut = false;

			public SwitchType(string name, int numArgs, string paramDescription, string description)
			{
				Name = name;
				NumArgs = numArgs;
				ParamDescription = paramDescription;
				Description = description;
			}
		}

		private Hashtable switchTypes = new Hashtable();
		private string usage;
		private string notes;

		public CommandLineParser(string usage, string notes)
		{
			this.usage = usage;
			this.notes = notes;
		}

		public void AddSwitch(string name, int numArgs, string paramDescription, string description)
		{
			switchTypes[name] = new SwitchType(name, numArgs, paramDescription, description);
		}

		public void AddSwitch(string name, string description)
		{
			AddSwitch(name, 0, null, description);
		}

		public void AddSwitch(string name, int numArgs, string paramDescription, string description, bool shortcut)
		{
			SwitchType st = new SwitchType(name, numArgs, paramDescription, description);
			st.Shortcut = true;
			switchTypes[name] = st;

			st = new SwitchType(name, numArgs, paramDescription, description);
			st.UsageVisible = false;
			switchTypes[name.Substring(0, 1)] = st;
		}

		public void AddSwitch(string name, string description, bool shortcut)
		{
			AddSwitch(name, 0, null, description, shortcut);
		}

		public void AddSwitch(SwitchType st)
		{
			switchTypes[st.Name] = st;
		}

		public CommandLine Parse(string[] commandLine)
		{
			CommandLine cl = new CommandLine();
			ArrayList paramList = new ArrayList();
			for (int i = 0; i < commandLine.Length; i++)
			{
				string command = commandLine[i].ToLower();
				if (command.StartsWith("-") || command.StartsWith("/"))
				{
					command = command.Substring(1);

					SwitchType whichSwitch = (SwitchType)switchTypes[command];
					if (whichSwitch == null)
					{
						throw new Exception("Switch '/" + command + "' unknown.");
					}
					else
					{
						CommandLine.Switch s = new CommandLine.Switch(whichSwitch.Name);

						if (whichSwitch.NumArgs > 0)
						{
							ArrayList switchParamList = new ArrayList();
							for (int j = 0; j < whichSwitch.NumArgs; j++)
								switchParamList.Add(commandLine[++i].ToLower());
							s.Params = (string[])switchParamList.ToArray(typeof(string));
						}

						cl.Switches[s.Name] = s;
					}
				}
				else
				{
					paramList.Add(commandLine[i].ToLower());
				}
			}

			cl.Params = (string[])paramList.ToArray(typeof(string));
			return cl;
		}

		public void PrintUsage()
		{
			Console.WriteLine("Usage:");
			Console.WriteLine("  " + usage);
			Console.WriteLine("  Options include:");
			foreach (SwitchType st in switchTypes.Values)
			{
				if (!st.UsageVisible)
					continue;

				string name = st.Shortcut ? "(" + st.Name.Substring(0, 1) + ")" + st.Name.Substring(1) : st.Name;

				if (st.ParamDescription == null)
				{
					Console.WriteLine("    -" + name.PadRight(16, ' ') + (st.Description == null ? "" : st.Description));
				}
				else
				{
					Console.WriteLine("    -" + name + " " + st.ParamDescription);
					if (st.Description != null)
						Console.WriteLine("                    " + st.Description);
				}
			}

			Console.WriteLine();
			Console.WriteLine("  " + notes);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\livetest\tools\stress\TaskDescriptor.cs ===
using System;
using System.Reflection;

using livetest.core;

namespace livetest.stress
{
    /// <summary>
    ///  A TaskDescriptor is a description of a type of task. It contains 
    ///  information like how many tasks of this type have been run -- how 
    ///  many have completed, starved, yielded, or encountered error. This 
    ///  gets its state from the XML configuration file.
    /// </summary>
    public class TaskDescriptor
    {
        
        public const uint ERROR_LOG_SIZE = 16;

        /// <summary>Name of this TaskDescriptor.</summary>
        public string Name;
        /// <summary>
        ///  Boolean indicating whether this task is enabled or not.
        /// </summary>
        public bool Enabled;

        
        public float Scale;
        /// <summary>
        ///  The strings that appear under the contexts attribute in the XML 
        ///  task description.
        /// </summary>
        public string[] ContextNames;
        /// <summary>
        ///  uints that map to the strings in this.ContextNames.
        /// </summary>
        public uint[] ContextIds;
        /// <summary>Name given to nethod associated with this task.</summary>
        public string WorkerMethodName;
        /// <summary>The method specified in the XML config file.</summary>
        public MethodInfo WorkerMethod;

        // Stats
        
        public Counter Scheduled;

        /// <summary>
        ///  Counter of tasks of this TaskDescriptor that have completed.
        /// </summary>
        public Counter Completed;
        
        public Counter Starved;
        
        public Counter Yielded;
        
        public Counter Errors;
        
        public Exception[] ErrorLog;

        
        public RunningAverageCounter AvgScheduled;
        
        public RunningAverageCounter AvgElapsed;
        
        public RunningAverageCounter AvgRoundTripTime;

        float _DesiredTps;
        float _RemainingTps;
        uint _AllowedInProgress;
        uint _Id;

        //
        // Property accessors
        //
        
        public uint Id
        {
            get { 
                return _Id; 
            }
        }

        
        public float DesiredTps
        {
            get { 
                return _DesiredTps; 
            }
            set {
                _DesiredTps = value;
                _AllowedInProgress = (uint)(20 + value) * 2;
            }
        }

        
        public float ActualTps
        {
            get { 
                return (AvgScheduled.Total / (AvgElapsed.Total + 0.000001f)); 
            }
        }

        
        public float AverageRoundTripTime
        {
            get { 
                return AvgRoundTripTime.Average; 
            }
        }

        
        public uint AllowedInProgress
        {
            get { 
                return _AllowedInProgress; 
            }
        }

        
        public float InProgress
        {
            get { 
                return (Scheduled.Instance - Completed.Instance); 
            }
        }

        // 
        // Begin contructor/method implementation
        //
        
        public TaskDescriptor (uint id)
        {
            _Id = id;

            Scheduled           = new Counter();
            Completed           = new Counter();
            Starved             = new Counter();
            Yielded             = new Counter();
            Errors              = new Counter();

            ErrorLog            = new Exception[ERROR_LOG_SIZE];
            AvgScheduled        = new RunningAverageCounter();
            AvgElapsed          = new RunningAverageCounter();
            AvgRoundTripTime    = new RunningAverageCounter();
        }

        
        public void RecordScheduled (float elapsed, float scheduled)
        {
            Scheduled.Increment(scheduled);
            AvgScheduled.SampleValue(scheduled);
            AvgElapsed.SampleValue(elapsed);
        }

        /// <summary>
        ///  Records information about the completion of a task of this 
        ///  TaskDescriptor.
        /// </summary>
        /// <param name="elapsed">Number of ticks elapsed during execution of 
        ///  a task.</param>
        /// <param name="exception">The Exception a Worker encounted while 
        ///  executing this task. If no Exception was encountered exception 
        ///  will be null.</param>
        public void RecordCompleted (float elapsed, Exception exception)
        {
            Completed++;
            AvgRoundTripTime.SampleValue(elapsed);

            if(null != exception)
            {
                uint index = (uint)Math.Floor(Errors.Instance);
                ErrorLog[index % ERROR_LOG_SIZE] = exception;

                /*Scheduler._Report.Error("Exception occurred in worker: {0}, reason: {1}",
                        Name,
                        exception.ToString());*/
                Errors++;
            }
        }

        /// <summary>this.Starved++</summary>
        public void RecordStarved ()
        {
            Starved++;
        }

        /// <summary>
        ///  Recalculates how many tasks to schedule within one timeslice 
        ///  given the input.
        /// </summary>
        /// <param name="elapsed"></param>
        /// <param name="loadScale"></param>
        /// <returns>The ammount of tasks to schedule for the next timeslice.
        /// </returns>
        public uint LeftToSchedule (float elapsed, float loadScale)
        {
            float deltaTps;
            float scheduleAmmt;
            float scheduleAmmtActual;
            float desiredTps = _DesiredTps * loadScale * Scale;

            // Calculate how far off we are from desired TPS
            deltaTps = desiredTps - ActualTps;

            // Calculate how many tasks to schedule for this last elapsed time slice
            scheduleAmmt = ((desiredTps + deltaTps) * elapsed) + _RemainingTps;

            // If the delta TPS out runs the desired tps and forces our scheduled ammt 
            // into the negative we want to completly skip this time slice to let things
            // stabalize
            if(+scheduleAmmt > 0.0f)
            {
                scheduleAmmtActual = (float)Math.Floor(scheduleAmmt);

                // Save remainder for next timeslice
                _RemainingTps = scheduleAmmt - scheduleAmmtActual;
            }
            else
            {
                scheduleAmmtActual = 0.0f;
                _RemainingTps = 0.0f;
            }

            return (uint)scheduleAmmtActual;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\login\client\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.0.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\livetest\tools\stress\Scheduler.cs ===
using System;
using System.Threading;
using System.Xml;
using System.Collections.Generic;
using System.Reflection;
using System.IO;
using System.Runtime.InteropServices;

using System.Diagnostics;
using System.Text;

using livetest.core;

namespace livetest.stress
{
    /// <summary>
    ///  Used to store settings specific to the Scheduler.
    /// </summary>
    public class SchedulerSettings : SettingsObj
    {
        /// <summary>Number of workers to load.</summary>
        public uint maxInProgress=0;

        
        public float loadScale=1.0f;

        /// <summary>
        ///  Assembly containing Worker and ContextManager types.
        /// </summary>
        public string assembly="";

        /// <summary>Worker type to load.</summary>
        public string worker="";

        /// <summary>ContextManager type to load.</summary>
        public string contextManager="";

        /// <summary>
        ///  External assemblies that this stress test suite might depend on.
        /// </summary>
        public string[] externalAssemblies;
    }

    /// <summary>
    /// <para>The Scheduler class handles the scheduling of execution of 
    ///  workers.</para>
    /// 
    /// <para>The Scheduler maintains a queue of Workers that have completed 
    ///  their assigned tasks and queue of Workers that are ready to be 
    ///  assigned tasks.</para>
    /// </summary>
    public class Scheduler : IWorkerManager
    {
        /// <summary>Root Report.</summary>
        public static Report _Report = new Report(typeof(Scheduler).Name);

        bool _Running;
        bool _Pause;
        Queue<Worker> _CleanupQueue;

        AssemblyReference _AsmRef;
        IContextManager _ContextManager;
        Type _WorkerType;

        Thread _SchedulingThread;

        // Moved these fields to the SchedulerSettings object (t-robtos)
        //float               _LoadScale;
        //uint                _MaxInProgress;

        Worker[] _WorkerBuffer;
        Queue<Worker> _WorkerQueue;

        List<TaskDescriptor> _TaskDescriptors;
        string _SettingsPath;
        DateTime _LastSettingsChange;

        SchedulerSettings settings;
        XmlDocument settingsDoc;

        public event UnitWorkCompletedHandler UnitWorkLoadingCompleted;
        public delegate void UnitWorkCompletedHandler (int unitsLeft);

        // Stats
        uint _Cycles;
        uint _Scheduled;
        uint _Cleaned;
        uint _Starved;
        uint _Errors;
        //uint            _Timeouts;
        uint _InProgress;

        /// <value>A List of TaskDescriptors.</value>
        public List<TaskDescriptor> TaskDescriptors
        {
            get { 
                return _TaskDescriptors; 
            }
        }

        /// <summary>
        ///  Creates a new Scheduler configured by the configuration file 
        ///  specified by settingsPath.
        /// </summary>
        /// <param name="settingsPath">Path to an XML configuration file.
        ///  </param>
        public Scheduler (string settingsPath)
        {
            settings = new SchedulerSettings();

            if(!Path.IsPathRooted(settingsPath))
                settingsPath = Directory.GetCurrentDirectory() + "\\" + settingsPath;

            if(!File.Exists(settingsPath))
                throw new FileNotFoundException("Xml configuration file could not be found.", settingsPath);

            _SettingsPath = settingsPath;

            // This is so the executing directory is in the settingsPath (t-robtos)
            Directory.SetCurrentDirectory(Path.GetDirectoryName(settingsPath));

            // Add the directory where we found the settings XML to the search path
            PathResolver.Default.AddPath("dll", Path.GetDirectoryName(settingsPath));

            // Create communication queues

            // Old call: used a generic queue to replace this queue, hopefully 
            // synchronization issues are the same -- t-robtos
            //_CleanupQueue = Queue.Synchronized(new Queue<Worker>((int)_MaxInProgress));

            _CleanupQueue = new Queue<Worker>((int)settings.maxInProgress);
            _WorkerQueue  = new Queue<Worker>();
            _TaskDescriptors = new List<TaskDescriptor>();
            _LastSettingsChange = new DateTime();
        }

        /// <summary>Starts the Scheduler.</summary>
        public void Start ()
        {
            // Create scheduler thread and start it
            _SchedulingThread = new Thread(new ThreadStart(this.SchedulingThread));
            _SchedulingThread.Start();
        }

        /// <value>
        ///  true if the Scheduler's execution is paused. false otherwise.
        /// </value>
        public bool IsPaused
        {
            get { return _Pause; }
        }

        /// <summary>Pauses execution of the Scheduler.</summary>
        public void Pause ()
        {
            if(_Running)
            {
                _Pause = true;
            }
        }

        /// <summary>Unpauses execution of the Scheduler.</summary>
        public void Unpause ()
        {
            _Pause = false;
        }

        /// <summary>
        ///  Stops the Scheduler and persists the current stress settings to the xml configuration file.
        /// </summary>
        public void Stop ()
        {
            _Running = false;
            PersistSettings();
        }

        /// <summary>
        ///  Places worker on the cleanup queue. If the worker has already 
        ///  been placed on the cleanup queue, it will not be placed on the 
        ///  queue again.
        /// </summary>
        public void PostCompletedWorker (Worker worker)
        {
            if(worker.CurrentState == Worker.State.FINISHED)
            {
                worker.CurrentState = Worker.State.READY;
                lock(_CleanupQueue)
                {
                    _CleanupQueue.Enqueue(worker);
                }
            }
        }

        /// <summary>
        ///  Pulls a Worker off the queue of available Workers.
        /// </summary>
        /// <returns>A worker if available, otherwise null.</returns>
        protected Worker AcquireWorker ()
        {
            return _WorkerQueue.Dequeue();
        }

        /// <summary>
        /// Notfies ContextManager that the Worker has finished, and puts it 
        /// on the available Worker queue.
        /// </summary>
        protected void ReleaseWorker (Worker worker)
        {
            if(null != _ContextManager)
            {
                if (!_ContextManager.Release(worker))
                    _Report.Debug("Failed to acquire resources for task: {0}", _TaskDescriptors[(int)worker.Key].Name);
            }
            _WorkerQueue.Enqueue(worker);
        }

        /// <summary>Parses a boolean value.</summary>
        /// <param name="defaultValue">Value returned if name is not in el.
        /// </param>
        /// <param name="el">Element to load the attribute from.</param>
        /// <param name="name">The name of the attribute to load.</param>
        protected bool GetBoolAttribute (XmlElement el, string name, bool defaultValue)
        {
            if(!el.HasAttribute(name))
            {
                return defaultValue;
            }
            else
            {
                return Boolean.Parse(el.GetAttribute(name));
            }
        }

        /// <summary>Parses a scalar value.</summary>
        /// <param name="defaultValue">Value returned if name is not in el.
        /// </param>
        /// <param name="el">Element to load the attribute from.</param>
        /// <param name="name">The name of the attribute to load.</param>
        protected float GetScalarAttribute (XmlElement el, string name, float defaultValue)
        {
            if(!el.HasAttribute(name))
            {
                return defaultValue;
            }
            else
            {
                return (float)Double.Parse(el.GetAttribute(name));
            }
        }

        /// <summary>Parses a string value.</summary>
        /// <param name="defaultValue">Value returned if name is not in el.
        /// </param>
        /// <param name="el">Element to load the attribute from.</param>
        /// <param name="name">The name of the attribute to load.</param>
        protected string GetStringAttribute (XmlElement el, string name, string defaultValue)
        {
            if(!el.HasAttribute(name))
            {
                return defaultValue;
            }
            else
            {
                return el.GetAttribute(name);
            }
        }

        /// <summary>
        ///  Initializes the Scheduler's internals using the XML configuration 
        ///  file.
        /// </summary>
        public void LoadSettings ()
        {
            DateTime lastModified = File.GetLastWriteTime(_SettingsPath);
            if(_LastSettingsChange < lastModified)
            {
                _LastSettingsChange = lastModified;
            }

            _Report.Info("Loading scheduler settings and task descriptions from: {0}", _SettingsPath);

            settingsDoc = new XmlDocument();
            settingsDoc.Load(_SettingsPath);

            int unitsOfWorkLeft = (int)settings.maxInProgress + 3;

            UnitWorkLoadingCompleted.Invoke(unitsOfWorkLeft--);

            LoadGlobals(settingsDoc);
            UnitWorkLoadingCompleted.Invoke(unitsOfWorkLeft--);

            LoadTaskDescriptors(settingsDoc);
            UnitWorkLoadingCompleted.Invoke(unitsOfWorkLeft--);

            // Create our worker buffer
            _Report.Debug("Creating worker queue...");
            _WorkerBuffer = new Worker[settings.maxInProgress];
            ConstructorInfo[] constructors = _WorkerType.GetConstructors();
            if(0 == constructors.Length)
            {
                throw new Exception("No default public constructor found for worker type: " + _WorkerType.Name);
            }

            _WorkerQueue.Clear();
            for(uint i = 0; i < settings.maxInProgress; i++)
            {
                try
                {
                    _WorkerBuffer[i] = constructors[0].Invoke(null) as Worker;
                }
                catch(TargetInvocationException tie)
                {
                    throw new Exception(_WorkerType.FullName+"'s constructor threw an exception:\n"+tie.InnerException);
                }
                if(null == _WorkerBuffer[i])
                {
                    throw new Exception("Default constructor for " + _WorkerType.Name + " failed to create a new instance");
                }

                _WorkerQueue.Enqueue(_WorkerBuffer[i]);
                UnitWorkLoadingCompleted.Invoke(unitsOfWorkLeft--);
            }

            _Report.Debug("Finished creating {0} workers", settings.maxInProgress);

        }


        /// <summary>
        ///  This function will take the current settings for all task 
        ///  descriptors and persist them to the .xml file loaded by 
        ///  LoadSettings().
        /// </summary>
        public void PersistSettings ()
        {
            // Go through and set all of the enabled fields on the TaskDescriptors
            XmlNodeList nodeList = settingsDoc.SelectNodes("/stressmix/taskdesc");

            for (int i=0; i<_TaskDescriptors.Count; i++)
            {
                XmlNode taskDescNode = nodeList[i];
                TaskDescriptor taskDesc = _TaskDescriptors[i];

                // Verify that we have the right node (this assumes that each 
                // task has a unique name, which might not be true, but there 
                // is no other unique identifier in the xml configuration file 
                // besides position).
                if(taskDescNode.Attributes.GetNamedItem("name").Value != taskDesc.Name)
                    continue; // Couldn't find that task, skipping it

                taskDescNode.Attributes.GetNamedItem("enabled").Value = 
                    taskDesc.Enabled? "true" : "false";

                taskDescNode.Attributes.GetNamedItem("tps").Value = 
                    taskDesc.DesiredTps.ToString();

                taskDescNode.Attributes.GetNamedItem("scale").Value = 
                    taskDesc.Scale.ToString();
            }

            settingsDoc.Save(_SettingsPath);
        }


        /// <summary>Loads the XML configuration file.</summary>
        /// <param name="doc">The XML configuration file.</param>
        protected void LoadGlobals (XmlDocument doc)
        {
            XmlNodeList nodeList = doc.SelectNodes("/stressmix/SchedulerSettings");
            if(nodeList.Count != 1)
            {
                throw new Exception("There should only be one 'SchedulerSettings' node in the configuration file.");
            }

            settings = ConfigLoader.LoadSettingsObj<SchedulerSettings>((XmlElement)nodeList[0]);

            // Load the assembly
            _Report.Debug("Resolving assembly: "+settings.assembly);

            string fullPath = "";
            if(!PathResolver.Default.Resolve("dll", settings.assembly, out fullPath))
            {
                throw new Exception("Could not resolve the assembly: " + settings.assembly);
            }
            _AsmRef = new DllLoader(true).LoadDll(fullPath);

            // Load any external assemblies (see hack comment below this method)
            if(settings.externalAssemblies != null && settings.externalAssemblies.Length > 0)
            {
                AppDomain.CurrentDomain.AssemblyResolve += new ResolveEventHandler(CurrentDomain_AssemblyResolve);

                foreach(string asmPath in settings.externalAssemblies)
                {
                    fullPath = "";
                    if(!PathResolver.Default.Resolve(asmPath, out fullPath))
                    {
                        throw new Exception("Could not resolve the assembly: " + asmPath);
                    }
                    Assembly asm = Assembly.LoadFile(fullPath);
                }
            }

            // Load the worker
            _WorkerType = _AsmRef.Asm.GetType(settings.worker);
            if(null == _WorkerType)
            {
                throw new Exception("No such type found for worker: '" + settings.worker + "' in assembly: " + _AsmRef.FullPath);
            }
            if(_WorkerType.BaseType.IsInstanceOfType(typeof(Worker)))
            {
                throw new Exception("The specified worker class, '"+_WorkerType.Name+"', does not inherit from "+typeof(Worker).FullName+".");
            }

            // Load the ContextManager if there was one specified
            if(settings.contextManager != String.Empty)
            {
                Type type = _AsmRef.Asm.GetType(settings.contextManager);
                if(type == null)
                {
                    throw new Exception("No such type found for context manager: '" + settings.contextManager + "'");
                }

                ConstructorInfo[] constructorInfo = type.GetConstructors();
                try
                {
                    _ContextManager = constructorInfo[0].Invoke(null) as IContextManager;
                }
                catch(Exception e)
                {
                    throw new Exception("There was a problem loading the ContextManager ("+settings.contextManager+"): "+e.ToString());
                }
                if(null == _ContextManager)
                {
                    throw new Exception("Construction or cast to IContextManager failed for: " + type.FullName);
                }
            }

            // Initialization checks
            if(null == _WorkerType)
            {
                throw new Exception("Scheduler requires setting: worker to specify a class of type 'Worker'");
            }

            if(null == _ContextManager)
            {
                _Report.Debug("No contextManager provided");
            }
        }

        // Loading a test suite may require that the Scheduler load external 
        // assemblies that the test suite depends on. One can specify these 
        // external assemblies in the Scheduler configuration file. At load 
        // time, the Scheduler iterates through the given external assemblies 
       