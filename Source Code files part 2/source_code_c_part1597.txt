           \
    NdisInterlockedIncrement(&(_pVc)->RefCount);

#define RNDISMP_DEREF_VC(_pVc, _pRefCount)                                  \
    {                                                                       \
        ULONG       _RefCount;                                              \
                                                                            \
        RNDISMP_ACQUIRE_VC_LOCK(_pVc);                                      \
                                                                            \
        RNDISMP_DEREF_VC_LOCKED(_pVc, &_RefCount);                          \
        *(_pRefCount) = _RefCount;                                          \
        if (_RefCount != 0)                                                 \
        {                                                                   \
            RNDISMP_RELEASE_VC_LOCK(_pVc);                                  \
        }                                                                   \
    }

#define RNDISMP_DEREF_VC_LOCKED(_pVc, _pRefCount)                           \
    {                                                                       \
        ULONG       __RefCount;                                             \
        NDIS_HANDLE __NdisVcHandle;                                         \
                                                                            \
        __RefCount = NdisInterlockedDecrement(&(_pVc)->RefCount);           \
        *(_pRefCount) = __RefCount;                                         \
        if (__RefCount == 0)                                                \
        {                                                                   \
            RNDISMP_RELEASE_VC_LOCK(_pVc);                                  \
            DeallocateVc(_pVc);                                             \
        }                                                                   \
        else                                                                \
        {                                                                   \
            if ((__RefCount == 1) &&                                        \
                ((_pVc)->VcState == RNDISMP_VC_DEACTIVATED))                \
            {                                                               \
                __NdisVcHandle = (_pVc)->NdisVcHandle;                      \
                (_pVc)->VcState = RNDISMP_VC_CREATED;                       \
                NdisInterlockedIncrement(&(_pVc)->RefCount);                \
                                                                            \
                RNDISMP_RELEASE_VC_LOCK(_pVc);                              \
                                                                            \
                NdisMCoDeactivateVcComplete(NDIS_STATUS_SUCCESS,            \
                                            __NdisVcHandle);                \
                                                                            \
                RNDISMP_ACQUIRE_VC_LOCK(_pVc);                              \
                                                                            \
                __RefCount = NdisInterlockedDecrement(&(_pVc)->RefCount);   \
                *(_pRefCount) = __RefCount;                                 \
                if (__RefCount == 0)                                        \
                {                                                           \
                    RNDISMP_RELEASE_VC_LOCK(_pVc);                          \
                    DeallocateVc(_pVc);                                     \
                }                                                           \
            }                                                               \
        }                                                                   \
    }
           
//
// Prototypes for functions in rndismp.c
//

NTSTATUS
DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath);


NDIS_STATUS
RndisMInitializeWrapper(OUT PNDIS_HANDLE                      pNdisWrapperHandle,
                        IN  PVOID                             MicroportContext,
                        IN  PVOID                             DriverObject,
                        IN  PVOID                             RegistryPath,
                        IN  PRNDIS_MICROPORT_CHARACTERISTICS  pCharacteristics);

VOID
RndismpUnload(IN PDRIVER_OBJECT pDriverObject);

NTSTATUS
DllUnload(VOID);

VOID
RndismpHalt(IN NDIS_HANDLE MiniportAdapterContext);

VOID
RndismpInternalHalt(IN NDIS_HANDLE MiniportAdapterContext,
                    IN BOOLEAN bCalledFromHalt);

NDIS_STATUS
RndismpReconfigure(OUT PNDIS_STATUS pStatus,
                   IN NDIS_HANDLE MiniportAdapterContext,
                   IN NDIS_HANDLE ConfigContext);

NDIS_STATUS
RndismpReset(OUT PBOOLEAN    AddressingReset,
             IN  NDIS_HANDLE MiniportAdapterContext);

BOOLEAN
RndismpCheckForHang(IN NDIS_HANDLE MiniportAdapterContext);

NDIS_STATUS
RndismpInitialize(OUT PNDIS_STATUS  OpenErrorStatus,
                  OUT PUINT         SelectedMediumIndex,
                  IN  PNDIS_MEDIUM  MediumArray,
                  IN  UINT          MediumArraySize,
                  IN  NDIS_HANDLE   MiniportAdapterHandle,
                  IN  NDIS_HANDLE   ConfigurationHandle);

VOID
RndisMSendComplete(IN  NDIS_HANDLE    MiniportAdapterContext,
                   IN  NDIS_HANDLE    RndisMessageHandle,
                   IN  NDIS_STATUS    SendStatus);


BOOLEAN
InitCompletionMessage(IN PRNDISMP_ADAPTER   pAdapter,
                      IN PRNDIS_MESSAGE     pMessage,
                      IN PMDL               pMdl,
                      IN ULONG              TotalLength,
                      IN NDIS_HANDLE        MicroportMessageContext,
                      IN NDIS_STATUS        ReceiveStatus,
                      IN BOOLEAN            bMessageCopied);

BOOLEAN
HaltMessage(IN PRNDISMP_ADAPTER   pAdapter,
            IN PRNDIS_MESSAGE     pMessage,
            IN PMDL               pMdl,
            IN ULONG              TotalLength,
            IN NDIS_HANDLE        MicroportMessageContext,
            IN NDIS_STATUS        ReceiveStatus,
            IN BOOLEAN            bMessageCopied);

BOOLEAN
ResetCompletionMessage(IN PRNDISMP_ADAPTER   pAdapter,
                       IN PRNDIS_MESSAGE     pMessage,
                       IN PMDL               pMdl,
                       IN ULONG              TotalLength,
                       IN NDIS_HANDLE        MicroportMessageContext,
                       IN NDIS_STATUS        ReceiveStatus,
                       IN BOOLEAN            bMessageCopied);

BOOLEAN
KeepAliveCompletionMessage(IN PRNDISMP_ADAPTER   pAdapter,
                           IN PRNDIS_MESSAGE     pMessage,
                           IN PMDL               pMdl,
                           IN ULONG              TotalLength,
                           IN NDIS_HANDLE        MicroportMessageContext,
                           IN NDIS_STATUS        ReceiveStatus,
                           IN BOOLEAN            bMessageCopied);


BOOLEAN
KeepAliveMessage(IN PRNDISMP_ADAPTER   pAdapter,
                 IN PRNDIS_MESSAGE     pMessage,
                 IN PMDL               pMdl,
                 IN ULONG              TotalLength,
                 IN NDIS_HANDLE        MicroportMessageContext,
                 IN NDIS_STATUS        ReceiveStatus,
                 IN BOOLEAN            bMessageCopied);

VOID
RndismpShutdownHandler(IN NDIS_HANDLE MiniportAdapterContext);

VOID
RndismpDisableInterrupt(IN NDIS_HANDLE MiniportAdapterContext);

VOID
RndismpEnableInterrupt(IN NDIS_HANDLE MiniportAdapterContext);

VOID
RndismpHandleInterrupt(IN NDIS_HANDLE MiniportAdapterContext);

VOID
RndismpIsr(OUT PBOOLEAN InterruptRecognized,
           OUT PBOOLEAN QueueDpc,
           IN  PVOID    Context);

VOID
CompleteSendHalt(IN PRNDISMP_MESSAGE_FRAME pMsgFrame,
                 IN NDIS_STATUS SendStatus);

VOID
CompleteSendReset(IN PRNDISMP_MESSAGE_FRAME pMsgFrame,
                  IN NDIS_STATUS SendStatus);

VOID
CompleteMiniportReset(IN PRNDISMP_ADAPTER pAdapter,
                      IN NDIS_STATUS ResetStatus,
                      IN BOOLEAN AddressingReset);

NDIS_STATUS
ReadAndSetRegistryParameters(IN PRNDISMP_ADAPTER pAdapter,
                             IN NDIS_HANDLE ConfigurationContext);

NDIS_STATUS
SendConfiguredParameter(IN PRNDISMP_ADAPTER     pAdapter,
                        IN NDIS_HANDLE          ConfigHandle,
                        IN PNDIS_STRING         pParameterName,
                        IN PNDIS_STRING         pParameterType);

VOID
RndismpPnPEventNotify(IN NDIS_HANDLE MiniportAdapterContext,
                      IN NDIS_DEVICE_PNP_EVENT EventCode,
                      IN PVOID InformationBuffer,
                      IN ULONG InformationBufferLength);

//
// Prototypes for functions in init.c
//

NDIS_STATUS
SetupSendQueues(IN PRNDISMP_ADAPTER Adapter);

NDIS_STATUS
SetupReceiveQueues(IN PRNDISMP_ADAPTER Adapter);

NDIS_STATUS
AllocateTransportResources(IN PRNDISMP_ADAPTER Adapter);

VOID
FreeTransportResources(IN PRNDISMP_ADAPTER Adapter);

VOID
FreeSendResources(IN PRNDISMP_ADAPTER Adapter);

VOID
FreeReceiveResources(IN PRNDISMP_ADAPTER Adapter);


//
// Prototypes for functions in receive.c
//

VOID
RndismpReturnPacket(IN NDIS_HANDLE    MiniportAdapterContext,
                    IN PNDIS_PACKET   Packet);

VOID
DereferenceRcvFrame(IN PRNDISMP_RECV_DATA_FRAME pRcvFrame,
                    IN PRNDISMP_ADAPTER         pAdapter);

VOID
RndisMIndicateReceive(IN NDIS_HANDLE        MiniportAdapterContext,
                      IN PMDL               pMessageHead,
                      IN NDIS_HANDLE        MicroportMessageContext,
                      IN RM_CHANNEL_TYPE    ChannelType,
                      IN NDIS_STATUS        ReceiveStatus);
VOID
IndicateReceive(IN PRNDISMP_ADAPTER         pAdapter,
                IN PRNDISMP_VC              pVc OPTIONAL,
                IN PRNDISMP_RECV_DATA_FRAME pRcvFrame,
                IN PPNDIS_PACKET            PacketArray,
                IN ULONG                    NumberOfPackets,
                IN NDIS_STATUS              ReceiveStatus);

PRNDIS_MESSAGE
CoalesceMultiMdlMessage(IN PMDL         pMdl,
                        IN ULONG        TotalLength);

VOID
FreeRcvMessageCopy(IN PRNDIS_MESSAGE    pMessage);

BOOLEAN
ReceivePacketMessage(IN PRNDISMP_ADAPTER    pAdapter,
                     IN PRNDIS_MESSAGE      pMessage,
                     IN PMDL                pMdl,
                     IN ULONG               TotalLength,
                     IN NDIS_HANDLE         MicroportMessageContext,
                     IN NDIS_STATUS         ReceiveStatus,
                     IN BOOLEAN             bMessageCopied);

BOOLEAN
ReceivePacketMessageRaw(IN PRNDISMP_ADAPTER    pAdapter,
                        IN PRNDIS_MESSAGE      pMessage,
                        IN PMDL                pMdl,
                        IN ULONG               TotalLength,
                        IN NDIS_HANDLE         MicroportMessageContext,
                        IN NDIS_STATUS         ReceiveStatus,
                        IN BOOLEAN             bMessageCopied);

BOOLEAN
IndicateStatusMessage(IN PRNDISMP_ADAPTER   pAdapter,
                      IN PRNDIS_MESSAGE     pMessage,
                      IN PMDL               pMdl,
                      IN ULONG              TotalLength,
                      IN NDIS_HANDLE        MicroportMessageContext,
                      IN NDIS_STATUS        ReceiveStatus,
                      IN BOOLEAN            bMessageCopied);

BOOLEAN
UnknownMessage(IN PRNDISMP_ADAPTER   pAdapter,
               IN PRNDIS_MESSAGE     pMessage,
               IN PMDL               pMdl,
               IN ULONG              TotalLength,
               IN NDIS_HANDLE        MicroportMessageContext,
               IN NDIS_STATUS        ReceiveStatus,
               IN BOOLEAN            bMessageCopied);

PRNDISMP_RECV_DATA_FRAME
AllocateReceiveFrame(IN PRNDISMP_ADAPTER    pAdapter);

VOID
FreeReceiveFrame(IN PRNDISMP_RECV_DATA_FRAME    pRcvFrame,
                 IN PRNDISMP_ADAPTER            pAdapter);

VOID
IndicateTimeout(IN PVOID SystemSpecific1,
                IN PVOID Context,
                IN PVOID SystemSpecific2,
                IN PVOID SystemSpecific3);

//
// Prototypes for functions in send.c
//

VOID
RndismpMultipleSend(IN NDIS_HANDLE   MiniportAdapterContext,
                    IN PPNDIS_PACKET PacketArray,
                    IN UINT          NumberOfPackets);

VOID
DoMultipleSend(IN PRNDISMP_ADAPTER  pAdapter,
               IN PRNDISMP_VC       pVc OPTIONAL,
               IN PPNDIS_PACKET     PacketArray,
               IN UINT              NumberOfPackets);

VOID
DoMultipleSendRaw(IN PRNDISMP_ADAPTER  pAdapter,
                  IN PRNDISMP_VC       pVc OPTIONAL,
                  IN PPNDIS_PACKET     PacketArray,
                  IN UINT              NumberOfPackets);

PRNDISMP_PACKET_WRAPPER
PrepareDataMessage(IN   PNDIS_PACKET            pNdisPacket,
                   IN   PRNDISMP_ADAPTER        pAdapter,
                   IN   PRNDISMP_VC             pVc         OPTIONAL,
                   IN OUT PULONG                pTotalMessageLength);

PRNDISMP_PACKET_WRAPPER
PrepareDataMessageRaw(IN   PNDIS_PACKET            pNdisPacket,
                      IN   PRNDISMP_ADAPTER        pAdapter,
                      IN OUT PULONG                pTotalMessageLength);

PRNDISMP_PACKET_WRAPPER
AllocatePacketMsgWrapper(IN PRNDISMP_ADAPTER        pAdapter,
                         IN ULONG                   MsgHeaderLength);

VOID
FreePacketMsgWrapper(IN PRNDISMP_PACKET_WRAPPER     pPktWrapper);

VOID
CompleteSendData(IN  PRNDISMP_MESSAGE_FRAME pMsgFrame,
                 IN  NDIS_STATUS            SendStatus);

VOID
FreeMsgAfterSend(IN  PRNDISMP_MESSAGE_FRAME pMsgFrame,
                 IN  NDIS_STATUS            SendStatus);

#if THROTTLE_MESSAGES
VOID
QueueMessageToMicroport(IN PRNDISMP_ADAPTER pAdapter,
                        IN PRNDISMP_MESSAGE_FRAME pMsgFrame,
                        IN BOOLEAN          bQueueMessageForResponse);
VOID
FlushPendingMessages(IN  PRNDISMP_ADAPTER        pAdapter);
#endif

VOID
SendProcessTimeout(IN PVOID SystemSpecific1,
                  IN PVOID Context,
                  IN PVOID SystemSpecific2,
                  IN PVOID SystemSpecific3);

//
// Prototypes for functions in request.c
//

NDIS_STATUS
RndismpQueryInformation(IN  NDIS_HANDLE MiniportAdapterContext,
                        IN  NDIS_OID    Oid,
                        IN  PVOID       InformationBuffer,
                        IN  ULONG       InformationBufferLength,
                        OUT PULONG      pBytesWritten,
                        OUT PULONG      pBytesNeeded);
NDIS_STATUS
ProcessQueryInformation(IN  PRNDISMP_ADAPTER    pAdapter,
                        IN  PRNDISMP_VC         pVc,
                        IN  PNDIS_REQUEST       pRequest,
                        IN  NDIS_OID            Oid,
                        IN  PVOID               InformationBuffer,
                        IN  ULONG               InformationBufferLength,
                        OUT PULONG              pBytesWritten,
                        OUT PULONG              pBytesNeeded);

NDIS_STATUS
RndismpSetInformation(IN  NDIS_HANDLE   MiniportAdapterContext,
                      IN  NDIS_OID      Oid,
                      IN  PVOID         InformationBuffer,
                      IN  ULONG         InformationBufferLength,
                      OUT PULONG        pBytesRead,
                      OUT PULONG        pBytesNeeded);

NDIS_STATUS
ProcessSetInformation(IN  PRNDISMP_ADAPTER    pAdapter,
                      IN  PRNDISMP_VC         pVc OPTIONAL,
                      IN  PNDIS_REQUEST       pRequest OPTIONAL,
                      IN  NDIS_OID            Oid,
                      IN  PVOID               InformationBuffer,
                      IN  ULONG               InformationBufferLength,
                      OUT PULONG              pBytesRead,
                      OUT PULONG              pBytesNeeded);

NDIS_STATUS
DriverQueryInformation(IN  PRNDISMP_ADAPTER pAdapter,
                       IN  PRNDISMP_VC      pVc OPTIONAL,
                       IN  PNDIS_REQUEST    pRequest OPTIONAL,
                       IN  NDIS_OID         Oid,
                       IN  PVOID            InformationBuffer,
                       IN  ULONG            InformationBufferLength,
                       OUT PULONG           pBytesWritten,
                       OUT PULONG           pBytesNeeded);

NDIS_STATUS
DeviceQueryInformation(IN  PRNDISMP_ADAPTER pAdapter,
                       IN  PRNDISMP_VC      pVc OPTIONAL,
                       IN  PNDIS_REQUEST    pRequest OPTIONAL,
                       IN  NDIS_OID         Oid,
                       IN  PVOID            InformationBuffer,
                       IN  ULONG            InformationBufferLength,
                       OUT PULONG           pBytesWritten,
                       OUT PULONG           pBytesNeeded);

NDIS_STATUS
DriverSetInformation(IN  PRNDISMP_ADAPTER   pAdapter,
                     IN  PRNDISMP_VC        pVc OPTIONAL,
                     IN  PNDIS_REQUEST      pRequest OPTIONAL,
                     IN  NDIS_OID           Oid,
                     IN  PVOID              InformationBuffer,
                     IN  ULONG              InformationBufferLength,
                     OUT PULONG             pBytesRead,
                     OUT PULONG             pBytesNeeded);

NDIS_STATUS
DeviceSetInformation(IN  PRNDISMP_ADAPTER   pAdapter,
                     IN  PRNDISMP_VC        pVc OPTIONAL,
                     IN  PNDIS_REQUEST      pRequest OPTIONAL,
                     IN  NDIS_OID           Oid,
                     IN  PVOID              InformationBuffer,
                     IN  ULONG              InformationBufferLength,
                     OUT PULONG             pBytesRead,
                     OUT PULONG             pBytesNeeded);

BOOLEAN
QuerySetCompletionMessage(IN PRNDISMP_ADAPTER   pAdapter,
                          IN PRNDIS_MESSAGE     pMessage,
                          IN PMDL               pMdl,
                          IN ULONG              TotalLength,
                          IN NDIS_HANDLE        MicroportMessageContext,
                          IN NDIS_STATUS        ReceiveStatus,
                          IN BOOLEAN            bMessageCopied);

VOID
CompleteSendDeviceRequest(IN PRNDISMP_MESSAGE_FRAME pMsgFrame,
                          IN NDIS_STATUS            SendStatus);

#ifdef BUILD_WIN9X

VOID
CompleteSendDiscardDeviceRequest(IN PRNDISMP_MESSAGE_FRAME pMsgFrame,
                                 IN NDIS_STATUS            SendStatus);

#endif // BUILD_WIN9X


NDIS_STATUS
BuildOIDLists(IN PRNDISMP_ADAPTER  Adapter, 
              IN PNDIS_OID         DeviceOIDList,
              IN UINT              NumDeviceOID,
              IN PNDIS_OID         DriverOIDList,
              IN UINT              NumDriverOID);

UINT
GetOIDSupport(IN PRNDISMP_ADAPTER Adapter, IN NDIS_OID Oid);

VOID
FreeOIDLists(IN PRNDISMP_ADAPTER Adapter);

PRNDISMP_REQUEST_CONTEXT
AllocateRequestContext(IN PRNDISMP_ADAPTER pAdapter);

VOID
FreeRequestContext(IN PRNDISMP_ADAPTER pAdapter,
                   IN PRNDISMP_REQUEST_CONTEXT pReqContext);


//
// Prototypes for functions in util.c
//

NDIS_STATUS
MemAlloc(OUT PVOID *Buffer, IN UINT Length);

VOID
MemFree(IN PVOID Buffer, IN UINT Length);

VOID
AddAdapter(IN PRNDISMP_ADAPTER Adapter);

VOID
RemoveAdapter(IN PRNDISMP_ADAPTER Adapter);

VOID
DeviceObjectToAdapterAndDriverBlock(IN PDEVICE_OBJECT pDeviceObject,
                                    OUT PRNDISMP_ADAPTER * ppAdapter,
                                    OUT PDRIVER_BLOCK * ppDriverBlock);

VOID
AddDriverBlock(IN PDRIVER_BLOCK Head, IN PDRIVER_BLOCK Item);

VOID
RemoveDriverBlock(IN PDRIVER_BLOCK BlockHead, IN PDRIVER_BLOCK Item);

PDRIVER_BLOCK
DeviceObjectToDriverBlock(IN PDRIVER_BLOCK Head, 
                          IN PDEVICE_OBJECT DeviceObject);

PDRIVER_BLOCK
DriverObjectToDriverBlock(IN PDRIVER_BLOCK Head,
                          IN PDRIVER_OBJECT DriverObject);

PRNDISMP_MESSAGE_FRAME
AllocateMsgFrame(IN PRNDISMP_ADAPTER pAdapter);

VOID
DereferenceMsgFrame(IN PRNDISMP_MESSAGE_FRAME pMsgFrame);

VOID
ReferenceMsgFrame(IN PRNDISMP_MESSAGE_FRAME pMsgFrame);

VOID
EnqueueNDISPacket(IN PRNDISMP_ADAPTER Adapter, IN PNDIS_PACKET Packet);

PNDIS_PACKET
DequeueNDISPacket(IN PRNDISMP_ADAPTER Adapter);

VOID
KeepAliveTimerHandler(IN PVOID SystemSpecific1,
                      IN PVOID Context,
                      IN PVOID SystemSpecific2,
                      IN PVOID SystemSpecific3);

VOID
CompleteSendKeepAlive(IN PRNDISMP_MESSAGE_FRAME pMsgFrame,
                      IN NDIS_STATUS SendStatus);

PRNDISMP_MESSAGE_FRAME
BuildRndisMessageCommon(IN  PRNDISMP_ADAPTER  Adapter, 
                        IN  PRNDISMP_VC       pVc,
                        IN  UINT              NdisMessageType,
                        IN  NDIS_OID          Oid,
                        IN  PVOID             InformationBuffer,
                        IN  ULONG             InformationBufferLength);


PRNDISMP_MESSAGE_FRAME
AllocateMessageAndFrame(IN PRNDISMP_ADAPTER Adapter,
                        IN UINT MessageSize);

VOID
FreeAdapter(IN PRNDISMP_ADAPTER pAdapter);

PRNDISMP_VC
AllocateVc(IN PRNDISMP_ADAPTER      pAdapter);

VOID
DeallocateVc(IN PRNDISMP_VC         pVc);

PRNDISMP_VC
LookupVcId(IN PRNDISMP_ADAPTER  pAdapter,
           IN UINT32            VcId);

VOID
EnterVcIntoHashTable(IN PRNDISMP_ADAPTER    pAdapter,
                     IN PRNDISMP_VC         pVc);

VOID
RemoveVcFromHashTable(IN PRNDISMP_ADAPTER   pAdapter,
                      IN PRNDISMP_VC        pVc);

//
// Prototypes for functions in comini.c
//
NDIS_STATUS
RndismpCoCreateVc(IN NDIS_HANDLE    MiniportAdapterContext,
                  IN NDIS_HANDLE    NdisVcHandle,
                  IN PNDIS_HANDLE   pMiniportVcContext);

VOID
CompleteSendCoCreateVc(IN PRNDISMP_MESSAGE_FRAME    pMsgFrame,
                       IN NDIS_STATUS               SendStatus);

VOID
HandleCoCreateVcFailure(IN PRNDISMP_VC      pVc,
                        IN NDIS_STATUS      Status);

NDIS_STATUS
RndismpCoDeleteVc(IN NDIS_HANDLE    MiniportVcContext);

NDIS_STATUS
StartVcDeletion(IN PRNDISMP_VC      pVc);

VOID
CompleteSendCoDeleteVc(IN PRNDISMP_MESSAGE_FRAME    pMsgFrame,
                       IN NDIS_STATUS               SendStatus);

VOID
HandleCoDeleteVcFailure(IN PRNDISMP_VC      pVc,
                        IN NDIS_STATUS      Status);

NDIS_STATUS
RndismpCoActivateVc(IN NDIS_HANDLE          MiniportVcContext,
                    IN PCO_CALL_PARAMETERS  pCallParameters);

NDIS_STATUS
StartVcActivation(IN PRNDISMP_VC            pVc);

VOID
CompleteSendCoActivateVc(IN PRNDISMP_MESSAGE_FRAME      pMsgFrame,
                         IN NDIS_STATUS                 SendStatus);

NDIS_STATUS
RndismpCoDeactivateVc(IN NDIS_HANDLE          MiniportVcContext);

VOID
CompleteSendCoDeactivateVc(IN PRNDISMP_MESSAGE_FRAME    pMsgFrame,
                           IN NDIS_STATUS               SendStatus);

NDIS_STATUS
RndismpCoRequest(IN NDIS_HANDLE          MiniportAdapterContext,
                 IN NDIS_HANDLE          MiniportVcContext,
                 IN OUT PNDIS_REQUEST    pRequest);

VOID
RndismpCoSendPackets(IN NDIS_HANDLE          MiniportVcContext,
                     IN PNDIS_PACKET *       PacketArray,
                     IN UINT                 NumberOfPackets);

BOOLEAN
ReceiveCreateVcComplete(IN PRNDISMP_ADAPTER    pAdapter,
                        IN PRNDIS_MESSAGE      pMessage,
                        IN PMDL                pMdl,
                        IN ULONG               TotalLength,
                        IN NDIS_HANDLE         MicroportMessageContext,
                        IN NDIS_STATUS         ReceiveStatus,
                        IN BOOLEAN             bMessageCopied);

BOOLEAN
ReceiveActivateVcComplete(IN PRNDISMP_ADAPTER    pAdapter,
                          IN PRNDIS_MESSAGE      pMessage,
                          IN PMDL                pMdl,
                          IN ULONG               TotalLength,
                          IN NDIS_HANDLE         MicroportMessageContext,
                          IN NDIS_STATUS         ReceiveStatus,
                          IN BOOLEAN             bMessageCopied);

BOOLEAN
ReceiveDeleteVcComplete(IN PRNDISMP_ADAPTER    pAdapter,
                        IN PRNDIS_MESSAGE      pMessage,
                        IN PMDL                pMdl,
                        IN ULONG               TotalLength,
                        IN NDIS_HANDLE         MicroportMessageContext,
                        IN NDIS_STATUS         ReceiveStatus,
                        IN BOOLEAN             bMessageCopied);

BOOLEAN
ReceiveDeactivateVcComplete(IN PRNDISMP_ADAPTER    pAdapter,
                            IN PRNDIS_MESSAGE      pMessage,
                            IN PMDL                pMdl,
                            IN ULONG               TotalLength,
                            IN NDIS_HANDLE         MicroportMessageContext,
                            IN NDIS_STATUS         ReceiveStatus,
                            IN BOOLEAN             bMessageCopied);

PRNDISMP_MESSAGE_FRAME
BuildRndisMessageCoMiniport(IN  PRNDISMP_ADAPTER    pAdapter,
                            IN  PRNDISMP_VC         pVc,
                            IN  UINT                NdisMessageType,
                            IN  PCO_CALL_PARAMETERS pCallParameters OPTIONAL);

VOID
CompleteSendDataOnVc(IN PRNDISMP_VC         pVc,
                     IN PNDIS_PACKET        pNdisPacket,
                     IN NDIS_STATUS         Status);

VOID
IndicateReceiveDataOnVc(IN PRNDISMP_VC         pVc,
                        IN PNDIS_PACKET *      PacketArray,
                        IN UINT                NumberOfPackets);

//
// Prototypes for functions in wdmutil.c
//

PDRIVER_OBJECT
DeviceObjectToDriverObject(IN PDEVICE_OBJECT DeviceObject);

NTSTATUS
GetDeviceFriendlyName(IN PDEVICE_OBJECT pDeviceObject,
                      OUT PANSI_STRING pAnsiString,
                      OUT PUNICODE_STRING pUnicodeString);

VOID
HookPnpDispatchRoutine(IN PDRIVER_BLOCK    DriverBlock);

NTSTATUS
PnPDispatch(IN PDEVICE_OBJECT       pDeviceObject,
            IN PIRP                 pIrp);

#ifdef BUILD_WIN9X

VOID
HookNtKernCMHandler(IN PRNDISMP_ADAPTER     pAdapter);

VOID
UnHookNtKernCMHandler(IN PRNDISMP_ADAPTER     pAdapter);
MY_CONFIGRET __cdecl
RndisCMHandler(IN MY_CONFIGFUNC         cfFuncName,
               IN MY_SUBCONFIGFUNC      cfSubFuncName,
               IN MY_DEVNODE            cfDevNode,
               IN ULONG                 dwRefData,
               IN ULONG                 ulFlags);

#endif

#if DBG

//
// Prototypes for functions in debug.c
//

PCHAR
GetOidName(IN NDIS_OID Oid);

VOID
DisplayOidList(IN PRNDISMP_ADAPTER Adapter);

VOID
RndisPrintHexDump(PVOID            Pointer,
                  ULONG            Length);

VOID
RndisLogSendMessage(
    IN  PRNDISMP_ADAPTER        pAdapter,
    IN  PRNDISMP_MESSAGE_FRAME  pMsgFrame);

#endif


#endif // _RNDISMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rndis\rndismp\util.c ===
/***************************************************************************

Copyright (c) 1999  Microsoft Corporation

Module Name:

    UTIL.C

Abstract:

    Utility routines for Remote NDIS Miniport driver

Environment:

    kernel mode only

Notes:

    THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
    KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
    PURPOSE.

    Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.


Revision History:

    5/17/99 : created

Author:

    Tom Green

    
****************************************************************************/

#include "precomp.h"


ULONG   MsgFrameAllocs = 0;

/****************************************************************************/
/*                          MemAlloc                                        */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Allocate memory                                                         */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  Buffer - pointer to buffer pointer                                      */
/*  Length - length of buffer to allocate                                   */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    NDIS_STATUS                                                           */
/*                                                                          */
/****************************************************************************/
NDIS_STATUS
MemAlloc(OUT PVOID *Buffer, IN UINT Length)
{
    NDIS_STATUS Status;

    TRACE3(("MemAlloc\n"));
    ASSERT(Length != 0);

    Status = NdisAllocateMemoryWithTag(Buffer, 
                                       Length,
                                       RNDISMP_TAG_GEN_ALLOC);

    // zero out allocation
    if(Status == NDIS_STATUS_SUCCESS)
        NdisZeroMemory(*Buffer, Length);

    return Status;
} // MemAlloc

/****************************************************************************/
/*                          MemFree                                         */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Free memory                                                             */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  Buffer - pointer to buffer                                              */
/*  Length - length of buffer to allocate                                   */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    VOID                                                                  */
/*                                                                          */
/****************************************************************************/
VOID
MemFree(IN PVOID Buffer, IN UINT Length)
{
    TRACE3(("MemFree\n"));

    NdisFreeMemory(Buffer, Length, 0);
} // MemFree


/****************************************************************************/
/*                          AddAdapter                                      */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Add an adapter to the list of adapters associated with this driver      */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - Adapter object, contains pointer to associated driver block  */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    VOID                                                                  */
/*                                                                          */
/****************************************************************************/
VOID
AddAdapter(IN PRNDISMP_ADAPTER pAdapter)
{
    PDRIVER_BLOCK   DriverBlock = pAdapter->DriverBlock;

    TRACE3(("AddpAdapter\n"));

    CHECK_VALID_ADAPTER(pAdapter);

    // grab the global spinlock
    NdisAcquireSpinLock(&RndismpGlobalLock);

    pAdapter->NextAdapter        = DriverBlock->AdapterList;
    DriverBlock->AdapterList    = pAdapter;

    // keep track of number of adapters associated with this driver block
    DriverBlock->NumberAdapters++;

    // release global spinlock
    NdisReleaseSpinLock(&RndismpGlobalLock);

} // AddAdapter


/****************************************************************************/
/*                          RemoveAdapter                                   */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Remove an adapter from the list of adapters associated with this driver */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - Adapter object, contains pointer to associated driver block  */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    VOID                                                                  */
/*                                                                          */
/****************************************************************************/
VOID
RemoveAdapter(IN PRNDISMP_ADAPTER pAdapter)
{
    PDRIVER_BLOCK   DriverBlock = pAdapter->DriverBlock;

    TRACE3(("RemoveAdapter\n"));

    CHECK_VALID_ADAPTER(pAdapter);

    // remove the adapter from the driver block list of adapters.

    // grab the global spinlock
    NdisAcquireSpinLock(&RndismpGlobalLock);

    // see if it is the first one
    if (DriverBlock->AdapterList == pAdapter) 
    {
        DriverBlock->AdapterList = pAdapter->NextAdapter;

    }
    // not the first one, so walk the list
    else 
    {
        PRNDISMP_ADAPTER * ppAdapter = &DriverBlock->AdapterList;

        while (*ppAdapter != pAdapter)
        {
            ASSERT(*ppAdapter != NULL);
            ppAdapter = &((*ppAdapter)->NextAdapter);
        }

        *ppAdapter = pAdapter->NextAdapter;
    }

    // removing this adapter
    DriverBlock->NumberAdapters--;

    // release global spinlock
    NdisReleaseSpinLock(&RndismpGlobalLock);

} // RemoveAdapter


/****************************************************************************/
/*                       DeviceObjectToAdapter                              */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Given a pointer to an FDO, return the corresponding Adapter structure,  */
/*  if it exists, and the driver block.                                     */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pDeviceObject - pointer to the device object to search for.             */
/*  ppAdapter - place to return pointer to the adapter structure.           */
/*  ppDriverBlock - place to return pointer to driver block.                */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    VOID                                                                  */
/*                                                                          */
/****************************************************************************/
VOID
DeviceObjectToAdapterAndDriverBlock(IN PDEVICE_OBJECT pDeviceObject,
                                    OUT PRNDISMP_ADAPTER * ppAdapter,
                                    OUT PDRIVER_BLOCK * ppDriverBlock)
{
    PDRIVER_BLOCK       pDriverBlock;
    PRNDISMP_ADAPTER    pAdapter;

    pAdapter = NULL;
    pDriverBlock = DeviceObjectToDriverBlock(&RndismpMiniportBlockListHead, pDeviceObject);
    if (pDriverBlock != NULL)
    {
        NdisAcquireSpinLock(&RndismpGlobalLock);

        for (pAdapter = pDriverBlock->AdapterList;
             pAdapter != NULL;
             pAdapter = pAdapter->NextAdapter)
        {
            if (pAdapter->pDeviceObject == pDeviceObject)
            {
                break;
            }
        }

        NdisReleaseSpinLock(&RndismpGlobalLock);
    }

    *ppAdapter = pAdapter;
    *ppDriverBlock = pDriverBlock;

} // DeviceObjectToAdapter

/****************************************************************************/
/*                          AddDriverBlock                                  */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Add driver block to list of drivers (microports) associated with this   */
/*  driver                                                                  */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  Head - head of list                                                     */
/*  Item - driver block to add to list                                      */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    VOID                                                                  */
/*                                                                          */
/****************************************************************************/
VOID
AddDriverBlock(IN PDRIVER_BLOCK Head, IN PDRIVER_BLOCK Item)
{
    TRACE3(("AddDriverBlock\n"));

    CHECK_VALID_BLOCK(Item);

    // first time through, so allocate global spinlock
    if(!RndismpNumMicroports)
        NdisAllocateSpinLock(&RndismpGlobalLock);

    // grab the global spinlock
    NdisAcquireSpinLock(&RndismpGlobalLock);

    // Link the driver block on the global list of driver blocks
    Item->NextDriverBlock   = Head->NextDriverBlock;
    Head->NextDriverBlock   = Item;

    // keep track of how many microports we support so we can free
    // global resources
    RndismpNumMicroports++;
    
    // release global spinlock
    NdisReleaseSpinLock(&RndismpGlobalLock);

} // AddDriverBlock



/****************************************************************************/
/*                          RemoveDriverBlock                               */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Remove driver block from list of drivers (microports) associated with   */
/*  this driver                                                             */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  Head - head of list                                                     */
/*  Item - driver block to remove from list                                 */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    VOID                                                                  */
/*                                                                          */
/****************************************************************************/
VOID
RemoveDriverBlock(IN PDRIVER_BLOCK BlockHead, IN PDRIVER_BLOCK Item)
{
    UINT    NumMicroports;

    PDRIVER_BLOCK   Head = BlockHead;

    TRACE1(("RemoveDriverBlock\n"));

    CHECK_VALID_BLOCK(Item);

    // grab the global spinlock
    NdisAcquireSpinLock(&RndismpGlobalLock);

    // Remove the driver block from the global list of driver blocks
    while(Head->NextDriverBlock != Item) 
    {
        Head = Head->NextDriverBlock;

        // make sure this is valid
        if(!Head)
            break;
    }

    if(Head)
        Head->NextDriverBlock = Head->NextDriverBlock->NextDriverBlock;

    // keep track of how many microports we support so we can free
    // global resources
    RndismpNumMicroports--;

    NumMicroports = RndismpNumMicroports;
    
    // release global spinlock
    NdisReleaseSpinLock(&RndismpGlobalLock);

    // see if we need to free global spinlock
    if(!RndismpNumMicroports)
        NdisFreeSpinLock(&RndismpGlobalLock);

    ASSERT(Head);

} // RemoveDriverBlock


/****************************************************************************/
/*                          DeviceObjectToDriverBlock                       */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Get driver block pointer associated with the PDO passed in              */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  Head - head of driver block list                                        */
/*  DeviceObject - device object we want to get associated driver block for */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    PDRIVER_BLOCK                                                         */
/*                                                                          */
/****************************************************************************/
PDRIVER_BLOCK
DeviceObjectToDriverBlock(IN PDRIVER_BLOCK Head, 
                          IN PDEVICE_OBJECT DeviceObject)
{
    PDRIVER_OBJECT  DriverObject;

    TRACE3(("DeviceObjectToDriverBlock\n"));

    // grab the global spinlock
    NdisAcquireSpinLock(&RndismpGlobalLock);

    // get the driver object for this adapter
    DriverObject = DeviceObjectToDriverObject(DeviceObject);

    Head = Head->NextDriverBlock;

    // walk the list of driver blocks to find a match with driver object
    while(Head->DriverObject != DriverObject)
    {
        Head = Head->NextDriverBlock;

        // break out if we are at the end of the list
        if(!Head)
            break;
    }

    // release global spinlock
    NdisReleaseSpinLock(&RndismpGlobalLock);

    CHECK_VALID_BLOCK(Head);

    return Head;

} // DeviceObjectToDriverBlock


/****************************************************************************/
/*                          DriverObjectToDriverBlock                       */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Get driver block pointer associated with the Driver Object passed in    */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  Head - head of driver block list                                        */
/*  DriverObject - Driver object we want to get associated driver block for */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    PDRIVER_BLOCK                                                         */
/*                                                                          */
/****************************************************************************/
PDRIVER_BLOCK
DriverObjectToDriverBlock(IN PDRIVER_BLOCK Head, 
                          IN PDRIVER_OBJECT DriverObject)
{
    TRACE3(("DriverObjectToDriverBlock\n"));

    // grab the global spinlock
    NdisAcquireSpinLock(&RndismpGlobalLock);

    Head = Head->NextDriverBlock;

    // walk the list of driver blocks to find a match with driver object
    while(Head->DriverObject != DriverObject)
    {
        Head = Head->NextDriverBlock;

        // break out if we are at the end of the list
        if(!Head)
            break;
    }

    // release global spinlock
    NdisReleaseSpinLock(&RndismpGlobalLock);

    CHECK_VALID_BLOCK(Head);

    return Head;

} // DriverObjectToDriverBlock


/****************************************************************************/
/*                          AllocateMsgFrame                                */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Allocate a frame that holds context about a message we are about to     */
/*  send.                                                                   */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - Adapter object                                               */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    PRNDISMP_MESSAGE_FRAME                                                */
/*                                                                          */
/****************************************************************************/
PRNDISMP_MESSAGE_FRAME
AllocateMsgFrame(IN PRNDISMP_ADAPTER pAdapter)
{
    PRNDISMP_MESSAGE_FRAME  pMsgFrame;

#ifndef DONT_USE_LOOKASIDE_LIST
    pMsgFrame = (PRNDISMP_MESSAGE_FRAME)
                    NdisAllocateFromNPagedLookasideList(&pAdapter->MsgFramePool);

#else
    {
        NDIS_STATUS Status;
        Status = MemAlloc(&pMsgFrame, sizeof(RNDISMP_MESSAGE_FRAME));
        if (Status != NDIS_STATUS_SUCCESS)
        {
            pMsgFrame = NULL;
        }
    }
#endif // DONT_USE_LOOKASIDE_LIST

    if (pMsgFrame)
    {
        NdisZeroMemory(pMsgFrame, sizeof(*pMsgFrame));
        pMsgFrame->pAdapter = pAdapter;
        pMsgFrame->RequestId = NdisInterlockedIncrement(&pAdapter->RequestId);
        pMsgFrame->Signature = FRAME_SIGNATURE;

        pMsgFrame->RefCount = 1;
        NdisInterlockedIncrement(&MsgFrameAllocs);
    }
#if DBG
    else
    {
        TRACE1(("AllocateMsgFrame: pAdapter %x, MsgFramePool at %x, alloc failed, count %d\n",
            pAdapter, &pAdapter->MsgFramePool, MsgFrameAllocs));
        DbgBreakPoint();
    }
#endif // DBG

    return (pMsgFrame);
}

/****************************************************************************/
/*                          DereferenceMsgFrame                             */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Free a message frame and any associated resources.                      */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  Frame - pointer to frame                                                */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    VOID                                                                  */
/*                                                                          */
/****************************************************************************/
VOID
DereferenceMsgFrame(IN PRNDISMP_MESSAGE_FRAME pMsgFrame)
{
    PRNDISMP_ADAPTER        pAdapter;
    PMDL                    pMdl;
    PUCHAR                  pMessage;

    CHECK_VALID_FRAME(pMsgFrame);

    if (NdisInterlockedDecrement(&pMsgFrame->RefCount) == 0)
    {
        //
        // Mess up the contents slightly to catch bugs resulting from
        // improper reuse of this frame after it is freed.
        //
        pMsgFrame->Signature++;

        pMdl = pMsgFrame->pMessageMdl;
        pMsgFrame->pMessageMdl = NULL;
    
        if (pMdl)
        {
            pMessage = MmGetMdlVirtualAddress(pMdl);
        }
        else
        {
            pMessage = NULL;
        }
    
        if (pMessage)
        {
            MemFree(pMessage, -1);
            IoFreeMdl(pMdl);
        }

        pAdapter = pMsgFrame->pAdapter;

#ifndef DONT_USE_LOOKASIDE_LIST
        NdisFreeToNPagedLookasideList(&pAdapter->MsgFramePool, pMsgFrame);
#else
        MemFree(pMsgFrame, sizeof(RNDISMP_MESSAGE_FRAME));
#endif
        NdisInterlockedDecrement(&MsgFrameAllocs);
    }

} // DereferenceMsgFrame


/****************************************************************************/
/*                          ReferenceMsgFrame                               */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Add a ref count to a message frame                                      */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  Frame - pointer to frame                                                */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    VOID                                                                  */
/*                                                                          */
/****************************************************************************/
VOID
ReferenceMsgFrame(IN PRNDISMP_MESSAGE_FRAME pMsgFrame)
{
    NdisInterlockedIncrement(&pMsgFrame->RefCount);
}

/****************************************************************************/
/*                          KeepAliveTimerHandler                           */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Timer that keeps tabs on messages coming up from the device and         */
/*  sends a "KeepAlive" message if the device has been inactive too long    */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  SystemSpecific1 - Don't care                                            */
/*  Context - pAdapter object                                               */
/*  SystemSpecific2 - Don't care                                            */
/*  SystemSpecific3 - Don't care                                            */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  PNDIS_PACKET                                                            */
/*                                                                          */
/****************************************************************************/
VOID
KeepAliveTimerHandler(IN PVOID SystemSpecific1,
                      IN PVOID Context,
                      IN PVOID SystemSpecific2,
                      IN PVOID SystemSpecific3)
{
    PRNDISMP_ADAPTER            pAdapter;
    PRNDISMP_MESSAGE_FRAME      pMsgFrame;
    ULONG                       CurrentTime;

    // get adapter context
    pAdapter = PRNDISMP_ADAPTER_FROM_CONTEXT_HANDLE(Context);

    TRACE2(("KeepAliveTimerHandler\n"));

    do
    {
        // get current tick (in milliseconds)
        NdisGetSystemUpTime(&CurrentTime);

        // check and see if too much time has elapsed since we
        // got the last message from the device

        RNDISMP_ACQUIRE_ADAPTER_LOCK(pAdapter);

        if (((CurrentTime - pAdapter->LastMessageFromDevice) > KEEP_ALIVE_TIMER))
        {
            // see if we have a keep alive message pending, so let's bong this
            if (pAdapter->KeepAliveMessagePending)
            {
                TRACE1(("KeepAliveTimer: Adapter %x, message pending\n", pAdapter));

                // indicate later from check for hang handler
                pAdapter->NeedReset = TRUE;

                RNDISMP_RELEASE_ADAPTER_LOCK(pAdapter);

                RNDISMP_INCR_STAT(pAdapter, KeepAliveTimeout);

                break;
            }

            RNDISMP_RELEASE_ADAPTER_LOCK(pAdapter);


            // too much time has elapsed, send down a keep alive message
            pMsgFrame = BuildRndisMessageCommon(pAdapter, 
                                                NULL,
                                                REMOTE_NDIS_KEEPALIVE_MSG,
                                                0,
                                                NULL,
                                                0);

            if (pMsgFrame)
            {
                RNDISMP_ACQUIRE_ADAPTER_LOCK(pAdapter);

                pAdapter->KeepAliveMessagePending = TRUE;
                pAdapter->KeepAliveMessagePendingId = pMsgFrame->RequestId;

                RNDISMP_RELEASE_ADAPTER_LOCK(pAdapter);

                // send the message to the microport
                RNDISMP_SEND_TO_MICROPORT(pAdapter, pMsgFrame, FALSE, CompleteSendKeepAlive);
            }
        }
        else
        {
            RNDISMP_RELEASE_ADAPTER_LOCK(pAdapter);
        }
    }
    while (FALSE);

    // see if the timer was cancelled somewhere
    if (!pAdapter->TimerCancelled)
    {
        // restart timer
        NdisSetTimer(&pAdapter->KeepAliveTimer, KEEP_ALIVE_TIMER / 2);
    }
} // KeepAliveTimerHandler


/****************************************************************************/
/*                          CompleteSendKeepAlive                           */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Callback routine to handle completion of send by the microport, for     */
/*  a keepalive message.                                                    */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pMsgFrame - Pointer to message frame describing the message             */
/*  SendStatus - Status returned by microport                               */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  VOID                                                                    */
/*                                                                          */
/****************************************************************************/
VOID
CompleteSendKeepAlive(IN PRNDISMP_MESSAGE_FRAME pMsgFrame,
                      IN NDIS_STATUS SendStatus)
{
    PRNDISMP_ADAPTER    pAdapter;

    pAdapter = pMsgFrame->pAdapter;

    DereferenceMsgFrame(pMsgFrame);

    if (SendStatus != NDIS_STATUS_SUCCESS)
    {
        TRACE1(("KeepAlive send failure %x on Adapter %x\n",
                SendStatus, pAdapter));

        RNDISMP_ACQUIRE_ADAPTER_LOCK(pAdapter);

        pAdapter->KeepAliveMessagePending = FALSE;
        pAdapter->NeedReset = FALSE;

        RNDISMP_RELEASE_ADAPTER_LOCK(pAdapter);
    }

} // CompleteSendKeepAlive


/****************************************************************************/
/*                          BuildRndisMessageCommon                         */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*    Allocate resources for meesage and frame and build RNDIS message      */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*    pAdapter - adapter object                                             */
/*    pVc - optionally, VC on which this message is sent.                   */
/*    NdisMessageType - RNDIS message type                                  */
/*    Oid - the NDIS_OID to process.                                        */
/*    InformationBuffer - Holds the data to be set.                         */
/*    InformationBufferLength - The length of InformationBuffer.            */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    PRNDISMP_MESSAGE_FRAME                                                */
/*                                                                          */
/****************************************************************************/
PRNDISMP_MESSAGE_FRAME
BuildRndisMessageCommon(IN  PRNDISMP_ADAPTER  pAdapter, 
                        IN  PRNDISMP_VC       pVc OPTIONAL,
                        IN  UINT              NdisMessageType,
                        IN  NDIS_OID          Oid,
                        IN  PVOID             InformationBuffer,
                        IN  ULONG             InformationBufferLength)
{
    PRNDIS_MESSAGE              pMessage;
    UINT                        MessageSize;
    PRNDISMP_MESSAGE_FRAME      pMsgFrame;

    TRACE2(("BuildRndisMessageCommon\n"));

    pMsgFrame = NULL;

    switch(NdisMessageType)
    {
        case REMOTE_NDIS_INITIALIZE_MSG:
        {
            PRNDIS_INITIALIZE_REQUEST   pInitRequest;

            MessageSize = RNDIS_MESSAGE_SIZE(RNDIS_INITIALIZE_REQUEST);

            // get a message and request frame
            pMsgFrame = AllocateMessageAndFrame(pAdapter,
                                                MessageSize);

            if (pMsgFrame == NULL)
            {
                break;
            }

            pMessage = RNDISMP_GET_MSG_FROM_FRAME(pMsgFrame);
            pMessage->NdisMessageType = NdisMessageType;
            pMsgFrame->NdisMessageType = NdisMessageType;
            TRACE1(("RNDISMP: Init Req message %x, Type %d, Length %d, MaxRcv %d\n",
                    pMessage, pMessage->NdisMessageType, pMessage->MessageLength, pAdapter->MaxReceiveSize));

            pInitRequest = &pMessage->Message.InitializeRequest;
            pInitRequest->RequestId = pMsgFrame->RequestId;
            pInitRequest->MajorVersion = RNDIS_MAJOR_VERSION;
            pInitRequest->MinorVersion = RNDIS_MINOR_VERSION;
            pInitRequest->MaxTransferSize = pAdapter->MaxReceiveSize;

            break;
        }
        case REMOTE_NDIS_HALT_MSG:
        {
            PRNDIS_HALT_REQUEST   pHaltRequest;

            MessageSize = RNDIS_MESSAGE_SIZE(RNDIS_HALT_REQUEST);

            // get a message and request frame
            pMsgFrame = AllocateMessageAndFrame(pAdapter,
                                                MessageSize);

            if (pMsgFrame == NULL)
            {
                break;
            }

            pMessage = RNDISMP_GET_MSG_FROM_FRAME(pMsgFrame);
            pMessage->NdisMessageType = NdisMessageType;
            pMsgFrame->NdisMessageType = NdisMessageType;
            pHaltRequest = &pMessage->Message.HaltRequest;
            pHaltRequest->RequestId = pMsgFrame->RequestId;

            break;
        }
        case REMOTE_NDIS_QUERY_MSG:
        {
            PRNDIS_QUERY_REQUEST   pQueryRequest;

            MessageSize = RNDIS_MESSAGE_SIZE(RNDIS_QUERY_REQUEST) + InformationBufferLength;

            // get a message and request frame
            pMsgFrame = AllocateMessageAndFrame(pAdapter,
                                                MessageSize);

            if (pMsgFrame == NULL)
            {
                break;
            }

            pMessage = RNDISMP_GET_MSG_FROM_FRAME(pMsgFrame);
            pMessage->NdisMessageType = NdisMessageType;
            pMsgFrame->NdisMessageType = NdisMessageType;

            pQueryRequest = &pMessage->Message.QueryRequest;
            pQueryRequest->RequestId = pMsgFrame->RequestId;
            pQueryRequest->Oid = Oid;
            pQueryRequest->InformationBufferLength = InformationBufferLength;
            pQueryRequest->InformationBufferOffset = sizeof(RNDIS_QUERY_REQUEST);

            if (pVc == NULL)
            {
                pQueryRequest->DeviceVcHandle = NULL_DEVICE_CONTEXT;
            }
            else
            {
                pQueryRequest->DeviceVcHandle = pVc->DeviceVcContext;
            }

            TRACE2(("Query OID %x, Len %d, RequestId %08X\n",
                    Oid, InformationBufferLength, pQueryRequest->RequestId));

            // copy information buffer
            RNDISMP_MOVE_MEM(RNDISMP_GET_INFO_BUFFER_FROM_QUERY_MSG(pQueryRequest),
                             InformationBuffer,
                             InformationBufferLength);
            break;
        }
        case REMOTE_NDIS_SET_MSG:
        {
            PRNDIS_SET_REQUEST   pSetRequest;

            MessageSize = RNDIS_MESSAGE_SIZE(RNDIS_SET_REQUEST) + InformationBufferLength;

            // get a message and request frame
            pMsgFrame = AllocateMessageAndFrame(pAdapter,
                                                MessageSize);

            if (pMsgFrame == NULL)
            {
                break;
            }

            pMessage = RNDISMP_GET_MSG_FROM_FRAME(pMsgFrame);
            pMessage->NdisMessageType = NdisMessageType;
            pMsgFrame->NdisMessageType = NdisMessageType;

            pSetRequest = &pMessage->Message.SetRequest;
            pSetRequest->RequestId = pMsgFrame->RequestId;
            pSetRequest->Oid = Oid;
            pSetRequest->InformationBufferLength = InformationBufferLength;
            pSetRequest->InformationBufferOffset = sizeof(RNDIS_SET_REQUEST);

            if (pVc == NULL)
            {
                pSetRequest->DeviceVcHandle = NULL_DEVICE_CONTEXT;
            }
            else
            {
                pSetRequest->DeviceVcHandle = pVc->DeviceVcContext;
            }

            // copy information buffer
            RNDISMP_MOVE_MEM(RNDISMP_GET_INFO_BUFFER_FROM_QUERY_MSG(pSetRequest),
                             InformationBuffer,
                             InformationBufferLength);
            break;
        }
        case REMOTE_NDIS_RESET_MSG:
        {
            PRNDIS_RESET_REQUEST   pResetRequest;

            MessageSize = RNDIS_MESSAGE_SIZE(RNDIS_RESET_REQUEST);

            // get a message and request frame
            pMsgFrame = AllocateMessageAndFrame(pAdapter,
                                                MessageSize);

            if (pMsgFrame == NULL)
            {
                break;
            }

            pMessage = RNDISMP_GET_MSG_FROM_FRAME(pMsgFrame);
            pMessage->NdisMessageType = NdisMessageType;
            pMsgFrame->NdisMessageType = NdisMessageType;

            pResetRequest = &pMessage->Message.ResetRequest;
            pResetRequest->Reserved = 0;
            break;
        }
        case REMOTE_NDIS_KEEPALIVE_MSG:
        {
            PRNDIS_KEEPALIVE_REQUEST   pKeepAliveRequest;

            MessageSize = RNDIS_MESSAGE_SIZE(RNDIS_KEEPALIVE_REQUEST);

            // get a message and request frame
            pMsgFrame = AllocateMessageAndFrame(pAdapter,
                                                MessageSize);

            if (pMsgFrame == NULL)
            {
                break;
            }

            pMessage = RNDISMP_GET_MSG_FROM_FRAME(pMsgFrame);
            pMessage->NdisMessageType = NdisMessageType;
            pMsgFrame->NdisMessageType = NdisMessageType;

            pKeepAliveRequest = &pMessage->Message.KeepaliveRequest;
            pKeepAliveRequest->RequestId = pMsgFrame->RequestId;
            break;
        }
        case REMOTE_NDIS_KEEPALIVE_CMPLT:
        {
            PRNDIS_KEEPALIVE_COMPLETE   pKeepAliveComplete;

            MessageSize = RNDIS_MESSAGE_SIZE(RNDIS_KEEPALIVE_COMPLETE);

            // get a message and request frame
            pMsgFrame = AllocateMessageAndFrame(pAdapter,
                                                MessageSize);

            if (pMsgFrame == NULL)
            {
                break;
            }

            pMessage = RNDISMP_GET_MSG_FROM_FRAME(pMsgFrame);
            pMessage->NdisMessageType = NdisMessageType;
            pMsgFrame->NdisMessageType = NdisMessageType;

            pKeepAliveComplete = &pMessage->Message.KeepaliveComplete;
            pKeepAliveComplete->RequestId = *(RNDIS_REQUEST_ID *)InformationBuffer;
            pKeepAliveComplete->Status = NDIS_STATUS_SUCCESS;
            break;
        }

        default:
            TRACE2(("Invalid NdisMessageType (%08X)\n", NdisMessageType));
            ASSERT(FALSE);
            break;
    }

    return pMsgFrame;
} // BuildRndisMessageCommon


/****************************************************************************/
/*                          AllocateMessageAndFrame                         */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Allocate a message and frame for an RNDIS message                       */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - pAdapter object                                              */
/*  MessageSize - size of RNDIS message                                     */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  PRNDISMP_MESSAGE_FRAME                                                  */
/*                                                                          */
/****************************************************************************/
PRNDISMP_MESSAGE_FRAME
AllocateMessageAndFrame(IN PRNDISMP_ADAPTER pAdapter, 
                        IN UINT MessageSize)
{
    PRNDIS_MESSAGE          pMessage = NULL;
    PRNDISMP_MESSAGE_FRAME  pMsgFrame = NULL;
    NDIS_STATUS             Status = NDIS_STATUS_SUCCESS;
    PMDL                    pMdl = NULL;

    TRACE3(("AllocateMessageAndFrame\n"));

    do
    {
        // allocate a buffer for RNDIS message
        Status = MemAlloc(&pMessage, MessageSize);

        // see if we got our buffer
        if (Status != NDIS_STATUS_SUCCESS)
        {
            break;
        }

        // allocate an MDL to describe this message.
        pMdl = IoAllocateMdl(
                    pMessage,
                    MessageSize,
                    FALSE,
                    FALSE,
                    NULL);

        if (pMdl == NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        MmBuildMdlForNonPagedPool(pMdl);

        // got the message buffer, now allocate a frame
        pMsgFrame = AllocateMsgFrame(pAdapter);

        if (pMsgFrame == NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        // got everything, so fill in some frame things
        pMsgFrame->pMessageMdl = pMdl;

        pMessage->MessageLength = MessageSize;

    }
    while (FALSE);

    if (Status != NDIS_STATUS_SUCCESS)
    {
        if (pMdl)
        {
            IoFreeMdl(pMdl);
        }

        if (pMessage)
        {
            MemFree(pMessage, MessageSize);
        }
    }

    return pMsgFrame;

} // AllocateMessageAndFrame


/****************************************************************************/
/*                          FreeAdapter                                     */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Free all memory allocations to do with an Adapter structure             */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - pointer to the adapter to be freed.                          */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  VOID                                                                    */
/****************************************************************************/
VOID
FreeAdapter(IN PRNDISMP_ADAPTER Adapter)
{
    // free up transport resources
    FreeTransportResources(Adapter);

    if (Adapter->DriverOIDList)
    {
        MemFree(Adapter->DriverOIDList, RndismpSupportedOidsNum*sizeof(NDIS_OID));
    }

    if (Adapter->FriendlyNameAnsi.Buffer)
    {
        MemFree(Adapter->FriendlyNameAnsi.Buffer, Adapter->FriendlyNameAnsi.MaximumLength);
    }

    if (Adapter->FriendlyNameUnicode.Buffer)
    {
        MemFree(Adapter->FriendlyNameUnicode.Buffer, Adapter->FriendlyNameUnicode.MaximumLength);
    }

#if DBG
    if (Adapter->pSendLogBuffer)
    {
        MemFree(Adapter->pSendLogBuffer, Adapter->LogBufferSize);
        Adapter->pSendLogBuffer = NULL;
    }
#endif // DBG

    MemFree(Adapter, sizeof(RNDISMP_ADAPTER));
}


/****************************************************************************/
/*                          AllocateVc                                      */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Allocate a VC structure                                                 */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - adapter object                                               */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  PRNDISMP_VC                                                             */
/*                                                                          */
/****************************************************************************/
PRNDISMP_VC
AllocateVc(IN PRNDISMP_ADAPTER      pAdapter)
{
    PRNDISMP_VC     pVc;
    NDIS_STATUS     Status;

    Status = MemAlloc(&pVc, sizeof(RNDISMP_VC));
    if (Status == NDIS_STATUS_SUCCESS)
    {
        pVc->pAdapter = pAdapter;
        pVc->VcState = RNDISMP_VC_ALLOCATED;
        pVc->CallState = RNDISMP_CALL_IDLE;
        pVc->RefCount = 0;
        RNDISMP_INIT_LOCK(&pVc->Lock);

        EnterVcIntoHashTable(pAdapter, pVc);
    }
    else
    {
        pVc = NULL;
    }

    return pVc;
}

/****************************************************************************/
/*                          DeallocateVc                                    */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Deallocate a VC structure.                                              */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pVc - Pointer to VC being deallocated.                                  */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  VOID                                                                    */
/*                                                                          */
/****************************************************************************/
VOID
DeallocateVc(IN PRNDISMP_VC         pVc)
{
    ASSERT(pVc->RefCount == 0);
    ASSERT(pVc->VcState == RNDISMP_VC_ALLOCATED);

    RemoveVcFromHashTable(pVc->pAdapter, pVc);

    MemFree(pVc, sizeof(RNDISMP_VC));
}
    
/****************************************************************************/
/*                          LookupVcId                                      */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Search for a VC structure that matches a given VC Id.                   */
/*  If we find the VC, we reference it and return it.                       */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  Adapter - adapter object                                                */
/*  VcId - Id to search for                                                 */
/*                                                                          */
/* Notes:                                                                   */
/*                                                                          */
/*  This routine is called with the adapter lock held!                      */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  PRNDISMP_VC - pointer to VC, if one exists                              */
/*                                                                          */
/****************************************************************************/
PRNDISMP_VC
LookupVcId(IN PRNDISMP_ADAPTER  pAdapter,
           IN UINT32            VcId)
{
    PLIST_ENTRY             pVcEnt;
    PRNDISMP_VC             pVc;
    ULONG                   VcIdHash;
    PRNDISMP_VC_HASH_TABLE  pVcHashTable;
    BOOLEAN                 bFound = FALSE;

    VcIdHash = RNDISMP_HASH_VCID(VcId);

    pVcHashTable = pAdapter->pVcHashTable;

    do
    {
        if (pVcHashTable == NULL)
        {
            pVc = NULL;
            break;
        }

        for (pVcEnt = pVcHashTable->HashEntry[VcIdHash].Flink;
             pVcEnt != &pVcHashTable->HashEntry[VcIdHash];
             pVcEnt = pVcEnt->Flink)
        {
            pVc = CONTAINING_RECORD(pVcEnt, RNDISMP_VC, VcList);
            if (pVc->VcId == VcId)
            {
                bFound = TRUE;

                RNDISMP_REF_VC(pVc);

                break;
            }
        }

        if (!bFound)
        {
            pVc = NULL;
        }
    }
    while (FALSE);

    return pVc;
}


/****************************************************************************/
/*                          EnterVcIntoHashTable                            */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Link a VC into the hash table after assigning it a VC Id.               */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - adapter object                                               */
/*  pVc - VC to link to the above adapter                                   */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  VOID                                                                    */
/*                                                                          */
/****************************************************************************/
VOID
EnterVcIntoHashTable(IN PRNDISMP_ADAPTER    pAdapter,
                     IN PRNDISMP_VC         pVc)
{
    PRNDISMP_VC             pExistingVc;
    PRNDISMP_VC_HASH_TABLE  pVcHashTable;
    UINT32                  VcId;
    ULONG                   VcIdHash;

    RNDISMP_ACQUIRE_ADAPTER_LOCK(pAdapter);

    //
    //  We pick the next sequentially higher Vc Id value for this VC,
    //  but check to see if it is already in use...
    //
    do
    {
        pAdapter->LastVcId++;

        // Never allocate the value 0.
        if (pAdapter->LastVcId == 0)
        {
            pAdapter->LastVcId++;
        }

        VcId = pAdapter->LastVcId;

        pExistingVc = LookupVcId(pAdapter, VcId);
    }
    while (pExistingVc != NULL);

    pVcHashTable = pAdapter->pVcHashTable;
    pVc->VcId = VcId;
    VcIdHash = RNDISMP_HASH_VCID(VcId);

    InsertTailList(&pVcHashTable->HashEntry[VcIdHash], &pVc->VcList);
    pVcHashTable->NumEntries++;

    RNDISMP_RELEASE_ADAPTER_LOCK(pAdapter);
}


/****************************************************************************/
/*                        RemoveVcFromHashTable                             */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Unlink a VC from the adapter hash table.                                */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pAdapter - adapter object                                               */
/*  pVc - VC to be unlinked.                                                */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*  VOID                                                                    */
/*                                                                          */
/****************************************************************************/
VOID
RemoveVcFromHashTable(IN PRNDISMP_ADAPTER   pAdapter,
                      IN PRNDISMP_VC        pVc)
{
    RNDISMP_ACQUIRE_ADAPTER_LOCK(pAdapter);

    RemoveEntryList(&pVc->VcList);

    pAdapter->pVcHashTable->NumEntries--;

    RNDISMP_RELEASE_ADAPTER_LOCK(pAdapter);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rndis\rndismp\wdmutil.c ===
/***************************************************************************

Copyright (c) 1999  Microsoft Corporation

Module Name:

    WDMUTIL.C

Abstract:

    Stuff that does not fit well with NDIS header files
    
Environment:

    kernel mode only

Notes:

    THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
    KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
    PURPOSE.

    Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.


Revision History:

    5/17/99 : created

Author:

    Tom Green

    
****************************************************************************/


#include "precomp.h"


/****************************************************************************/
/*                          DeviceObjectToDriverObject                      */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Get driver object associated with device object. NDIS has no notion     */
/*  of the shape of a device object, so we put this here for ease of        */
/*  building                                                                *
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  DeviceObject - device object we to get associated driver object for     */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    PDRIVER_OBJECT                                                        */
/*                                                                          */
/****************************************************************************/
PDRIVER_OBJECT
DeviceObjectToDriverObject(IN PDEVICE_OBJECT DeviceObject)
{
    return DeviceObject->DriverObject;
} // DeviceObjectToDriverObject


/****************************************************************************/
/*                          GetDeviceFriendlyName                           */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Return the friendly name associated with the given device object.       */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pDeviceObject - device object we to get associated driver object for    */
/*  ppName - Place to return a pointer to an ANSI string containing name    */
/*  pNameLength - Place to return length of above string                    */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    NTSTATUS                                                              */
/*                                                                          */
/****************************************************************************/
NTSTATUS
GetDeviceFriendlyName(IN PDEVICE_OBJECT pDeviceObject,
                      OUT PANSI_STRING pAnsiName,
                      OUT PUNICODE_STRING pUnicodeName)
{
    NTSTATUS                    NtStatus;
    NDIS_STATUS                 Status;
    ULONG                       ResultLength;
    DEVICE_REGISTRY_PROPERTY    Property;
    UNICODE_STRING              UnicodeString;
    ANSI_STRING                 AnsiString;
    USHORT                      AnsiMaxLength;
    PWCHAR                      pValueInfo;
    ULONG                       i;

    pValueInfo = NULL;
    AnsiString.Buffer = NULL;

    do
    {
        Property = DevicePropertyFriendlyName;

        for (i = 0; i < 2; i++)
        {
            NtStatus = IoGetDeviceProperty(pDeviceObject,
                                           Property,
                                           0,
                                           NULL,
                                           &ResultLength);

            if (NtStatus != STATUS_BUFFER_TOO_SMALL)
            {
                ASSERT(!NT_SUCCESS(NtStatus));
                Property = DevicePropertyDeviceDescription;
            }
        }

        Status = MemAlloc(&pValueInfo, ResultLength);
        if (Status != NDIS_STATUS_SUCCESS)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        NtStatus = IoGetDeviceProperty(pDeviceObject,
                                       Property,
                                       ResultLength,
                                       pValueInfo,
                                       &ResultLength);

        if (NtStatus != STATUS_SUCCESS)
        {
            TRACE1(("IoGetDeviceProperty returned %x\n", NtStatus));
            break;
        }

        RtlInitUnicodeString(&UnicodeString, pValueInfo);

        //
        //  Allocate space for ANSI version.
        //
        AnsiMaxLength = UnicodeString.MaximumLength / sizeof(WCHAR);
        Status = MemAlloc(&AnsiString.Buffer, AnsiMaxLength);

        if (Status != NDIS_STATUS_SUCCESS)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        RtlFillMemory(AnsiString.Buffer, AnsiMaxLength, 0);
        AnsiString.MaximumLength = AnsiMaxLength;
        AnsiString.Length = 0;

        NtStatus = RtlUnicodeStringToAnsiString(&AnsiString, &UnicodeString, FALSE);

        if (!NT_SUCCESS(NtStatus))
        {
            ASSERT(FALSE);
            break;
        }

        *pAnsiName = AnsiString;
        *pUnicodeName = UnicodeString;
        break;
    }
    while (FALSE);

    if (!NT_SUCCESS(NtStatus))
    {
        if (pValueInfo)
        {
            MemFree(pValueInfo, -1);
        }

        if (AnsiString.Buffer)
        {
            MemFree(AnsiString.Buffer, AnsiString.MaximumLength);
        }
    }

    return (NtStatus);
}


/****************************************************************************/
/*                          HookPnpDispatchRoutine                          */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Set up the driver object for the specified microport driver to          */
/*  intercept the IRP_MJ_PNP dispatch routine before it gets to NDIS.       */
/*  This is in order to support surprise removal on platforms where we      */
/*  don't have NDIS 5.1 support. If we are running on >= NDIS 5.1, don't    */
/*  do anything.                                                            */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  DriverBlock - pointer to driver block structure for this microport.     */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    VOID                                                                  */
/*                                                                          */
/****************************************************************************/
VOID
HookPnpDispatchRoutine(IN PDRIVER_BLOCK    DriverBlock)
{
    if ((DriverBlock->MajorNdisVersion <= 5) ||
        ((DriverBlock->MajorNdisVersion == 5) && (DriverBlock->MinorNdisVersion < 1)))
    {
        DriverBlock->SavedPnPDispatch =
            DriverBlock->DriverObject->MajorFunction[IRP_MJ_PNP];
        DriverBlock->DriverObject->MajorFunction[IRP_MJ_PNP] = PnPDispatch;
    }
}

/****************************************************************************/
/*                          PnPDispatch                                     */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Dispatch routine for IRP_MJ_PNP that is called by the I/O system.       */
/*  We process surprise removal and query capabilities.                     */
/*  In all cases, we pass on the IRP to NDIS for further processing.        */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  pDeviceObject - pointer to Device Object                                */
/*  pIrp - pointer to IRP                                                   */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    VOID                                                                  */
/*                                                                          */
/****************************************************************************/
NTSTATUS
PnPDispatch(IN PDEVICE_OBJECT       pDeviceObject,
            IN PIRP                 pIrp)
{
    PIO_STACK_LOCATION      pIrpSp;
    NTSTATUS                Status;
    PDRIVER_BLOCK           DriverBlock;
    PRNDISMP_ADAPTER        pAdapter;

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    DeviceObjectToAdapterAndDriverBlock(pDeviceObject, &pAdapter, &DriverBlock);

    TRACE3(("PnPDispatch: Adapter %x, MinorFunction %x\n",
            pAdapter, pIrpSp->MinorFunction));

    switch (pIrpSp->MinorFunction)
    {
        case IRP_MN_QUERY_CAPABILITIES:
            pIrpSp->Parameters.DeviceCapabilities.Capabilities->SurpriseRemovalOK = 1;
            break;
        
        case IRP_MN_SURPRISE_REMOVAL:
            TRACE1(("PnPDispatch: PDO %p, Adapter %p, surprise removal!\n",
                    pDeviceObject, pAdapter));
            if (pAdapter)
            {
                RndismpInternalHalt((NDIS_HANDLE)pAdapter, FALSE);
            }
            break;

        default:
            break;
    }

    Status = (DriverBlock->SavedPnPDispatch)(
                    pDeviceObject,
                    pIrp);

    return (Status);
}


#ifdef BUILD_WIN9X

/****************************************************************************/
/*                          HookNtKernCMHandler                             */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Swap the CM handler routine within NDIS' data structures such that      */
/*  we get called when NDIS forwards a CM message. This can only work on    */
/*  Win98 and Win98SE.                                                      */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  Adapter - pointer to our adapter block                                  */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    VOID                                                                  */
/*                                                                          */
/****************************************************************************/
VOID
HookNtKernCMHandler(IN PRNDISMP_ADAPTER     pAdapter)
{
    PVOID   pNdisWrapperAdapterBlock;
    PVOID   pDetect;
    ULONG   WrapContextOffset;

    pDetect = (PVOID)((ULONG_PTR)pAdapter->MiniportAdapterHandle + 0x29c);

    if (*(PVOID *)pDetect == (PVOID)pAdapter->pPhysDeviceObject)
    {
        // Win98Gold
        WrapContextOffset = 0xf8;
        pAdapter->bRunningOnWin98Gold = TRUE;
    }
    else
    {
        // Win98SE
        WrapContextOffset = 0x60;
        pAdapter->bRunningOnWin98Gold = FALSE;
    }
    pAdapter->WrapContextOffset = WrapContextOffset;

    pNdisWrapperAdapterBlock = *(PVOID *)((ULONG_PTR)pAdapter->MiniportAdapterHandle + WrapContextOffset);

    // Save away the old handler:
    pAdapter->NdisCmConfigHandler = (MY_CMCONFIGHANDLER)
            (*(PVOID *)((ULONG_PTR)pNdisWrapperAdapterBlock + 0x78));

    // Insert our routine:
    (*(PVOID *)((ULONG_PTR)pNdisWrapperAdapterBlock + 0x78)) =
        (PVOID)RndisCMHandler;

    // Save the devnode to use on lookups based on devnode:
    pAdapter->DevNode = (MY_DEVNODE)
            (*(PVOID *)((ULONG_PTR)pNdisWrapperAdapterBlock + 0x38));

    TRACE1(("HookNtKernCMHandler: Adapter %p, NdisHandler %p, DevNode %x\n",
            pAdapter, pAdapter->NdisCmConfigHandler, pAdapter->DevNode));
}

/****************************************************************************/
/*                          UnHookNtKernCMHandler                           */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Put back the swapped Config Mgr handler in NDIS' data structures        */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  Adapter - pointer to our adapter block                                  */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    VOID                                                                  */
/*                                                                          */
/****************************************************************************/
VOID
UnHookNtKernCMHandler(IN PRNDISMP_ADAPTER     pAdapter)
{
    PVOID   pNdisWrapperAdapterBlock;

    if (pAdapter->NdisCmConfigHandler)
    {
        pNdisWrapperAdapterBlock = *(PVOID *)((ULONG_PTR)pAdapter->MiniportAdapterHandle + pAdapter->WrapContextOffset);
        (*(PVOID *)((ULONG_PTR)pNdisWrapperAdapterBlock + 0x78)) =
            (PVOID)pAdapter->NdisCmConfigHandler;
    }

    TRACE1(("UnhookNtKernCMHandler: Adapter %p, NdisHandler %p, DevNode %x\n",
            pAdapter, pAdapter->NdisCmConfigHandler, pAdapter->DevNode));
}

/****************************************************************************/
/*                             RndisCMHandler                               */
/****************************************************************************/
/*                                                                          */
/* Routine Description:                                                     */
/*                                                                          */
/*  Handler to intercept Config Mgr messages forwarded by NDIS. The only    */
/*  message of interest is a CONFIG_PREREMOVE, which is our only indication */
/*  on Win98 and Win98SE that the device is being removed.                  */
/*                                                                          */
/* Arguments:                                                               */
/*                                                                          */
/*  Various - documented in Win9x CFmgr header.                             */
/*                                                                          */
/* Return:                                                                  */
/*                                                                          */
/*    MY_CONFIGRET                                                          */
/*                                                                          */
/****************************************************************************/
MY_CONFIGRET __cdecl
RndisCMHandler(IN MY_CONFIGFUNC         cfFuncName,
               IN MY_SUBCONFIGFUNC      cfSubFuncName,
               IN MY_DEVNODE            cfDevNode,
               IN ULONG                 dwRefData,
               IN ULONG                 ulFlags)
{
    PRNDISMP_ADAPTER        pAdapter, pTmpAdapter;
    PDRIVER_BLOCK           pDriverBlock;
    MY_CONFIGRET            crRetCode;

    do
    {
        //
        // Find the adapter to which this is addressed.
        //
        pAdapter = NULL;
        NdisAcquireSpinLock(&RndismpGlobalLock);

        for (pDriverBlock = RndismpMiniportBlockListHead.NextDriverBlock;
             (pDriverBlock != NULL) && (pAdapter == NULL);
             pDriverBlock = pDriverBlock->NextDriverBlock)
        {
            for (pTmpAdapter = pDriverBlock->AdapterList;
                 pTmpAdapter != NULL;
                 pTmpAdapter = pTmpAdapter->NextAdapter)
            {
                if (pTmpAdapter->DevNode == cfDevNode)
                {
                    pAdapter = pTmpAdapter;
                    break;
                }
            }
        }

        NdisReleaseSpinLock(&RndismpGlobalLock);

        ASSERT(pAdapter != NULL);

        TRACE1(("CMHandler: Adapter %p, CfFuncName %x\n",
                pAdapter, cfFuncName));

        //
        //  Forward this on before acting on it.
        //
        if (pAdapter &&
            (pAdapter->NdisCmConfigHandler != NULL))
        {
            crRetCode = pAdapter->NdisCmConfigHandler(
                                    cfFuncName,
                                    cfSubFuncName,
                                    cfDevNode,
                                    dwRefData,
                                    ulFlags);

            if ((cfFuncName == MY_CONFIG_PREREMOVE) ||
                ((cfFuncName == MY_CONFIG_PRESHUTDOWN) &&
                 (pAdapter->bRunningOnWin98Gold)))
            {
                RndismpInternalHalt((NDIS_HANDLE)pAdapter, FALSE);
            }
        }
        else
        {
            crRetCode = MY_CR_SUCCESS;
        }
    }
    while (FALSE);

    return (crRetCode);
}

#endif // BUILD_WIN9X
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rndis\usb8023\debug.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    debug.c


Author:

    ervinp

Environment:

    Kernel mode

Revision History:


--*/

#include <WDM.H>

#include <usbdi.h>
#include <usbdlib.h>
#include <usbioctl.h>

#include "usb8023.h"
#include "debug.h"

#if DBG

    BOOLEAN dbgTrapOnWarn = FALSE;   
    BOOLEAN dbgVerbose = FALSE;  
    BOOLEAN dbgDumpBytes = FALSE;   // show all packets; slows us down too much to run
    BOOLEAN dbgDumpPktStatesOnEmpty = TRUE; 


    VOID InitDebug()
    {
        #if DBG_WRAP_MEMORY
            InitializeListHead(&dbgAllMemoryList);
        #endif
    }

	VOID DbgShowBytes(PUCHAR msg, PUCHAR buf, ULONG len)
	{

        #define PRNT(ch) ((((ch) < ' ') || ((ch) > '~')) ? '.' : (ch))

		if (dbgDumpBytes){
			ULONG i;
			DbgPrint("%s (len %xh @ %p): \r\n", msg, len, buf);
			
			for (i = 0; i < len; i += 16){
				DbgPrint("    ");

                if (len-i >= 16){
                    PUCHAR ptr = buf+i;
                    DbgPrint("%02x %02x %02x %02x %02x %02x %02x %02x  "
                             "%02x %02x %02x %02x %02x %02x %02x %02x "
                             "  "
                             "%c%c%c%c%c%c%c%c %c%c%c%c%c%c%c%c",
                             ptr[0], ptr[1], ptr[2], ptr[3], ptr[4], ptr[5], ptr[6], ptr[7], 
                             ptr[8], ptr[9], ptr[10], ptr[11], ptr[12], ptr[13], ptr[14], ptr[15], 
                             PRNT(ptr[0]), PRNT(ptr[1]), PRNT(ptr[2]), PRNT(ptr[3]), 
                             PRNT(ptr[4]), PRNT(ptr[5]), PRNT(ptr[6]), PRNT(ptr[7]), 
                             PRNT(ptr[8]), PRNT(ptr[9]), PRNT(ptr[10]), PRNT(ptr[11]), 
                             PRNT(ptr[12]), PRNT(ptr[13]), PRNT(ptr[14]), PRNT(ptr[15])
                            );
                }
                else {
                    ULONG j;
				    for (j = 0; j < 16; j++){
                        if (j == 8) DbgPrint(" ");
					    if (i+j < len){
						    DbgPrint("%02x ", (ULONG)buf[i+j]);
					    }
					    else {
						    DbgPrint("   ");
					    }
				    }
				    DbgPrint("  ");
				    for (j = 0; j < 16; j++){
                        if (j == 8) DbgPrint(" ");
					    if (i+j < len){
						    UCHAR ch = buf[i+j];
						    DbgPrint("%c", PRNT(ch));
					    }
					    else {
						    // DbgPrint(" ");
					    }
				    }
                }

				DbgPrint("\r\n");
			}
		}
	}

    VOID DbgShowMdlBytes(PUCHAR msg, PMDL mdl)
    {

        if (dbgDumpBytes){
			DbgPrint("\n %s (MDL @ %p): \r\n", msg, mdl);
            while (mdl){
                PVOID thisBuf = MmGetSystemAddressForMdl(mdl);
                ULONG thisBufLen = MmGetMdlByteCount(mdl);
                DbgShowBytes("    <MDL buffer>", thisBuf, thisBufLen);
                mdl = mdl->Next;
            }
        }
    }

    DbgDumpPacketList(PUCHAR msg, PLIST_ENTRY listHead)
    {
        PLIST_ENTRY listEntry;
        USBPACKET *packet;
        ULONG timeNow = DbgGetSystemTime_msec();

        DbgPrint("\n  %s: ", msg);
        for (listEntry = listHead->Flink; listEntry != listHead; listEntry = listEntry->Flink){
            packet = CONTAINING_RECORD(listEntry, USBPACKET, listEntry);
            DbgPrint("\n    packet #%d @%p - buf @%p, len=%xh, (msg:%xh), age=%d msec", packet->packetId, packet, packet->dataBuffer, packet->dataBufferCurrentLength, *(PULONG)packet->dataBuffer, timeNow-packet->timeStamp);
        }

    }

    VOID DbgDumpPacketStates(ADAPTEREXT *adapter)
    {
        if (dbgDumpPktStatesOnEmpty){
            KIRQL oldIrql;

            KeAcquireSpinLock(&adapter->adapterSpinLock, &oldIrql);

            DbgPrint("\n  *** USB8023 RAN OUT OF PACKETS, dumping packet states: *** ");

            DbgDumpPacketList("PENDING READ packets", &adapter->usbPendingReadPackets);
            DbgDumpPacketList("PENDING WRITE packets", &adapter->usbPendingWritePackets);
            DbgDumpPacketList("COMPLETED READ packets", &adapter->usbCompletedReadPackets);
            DbgDumpPacketList("FREE packets", &adapter->usbFreePacketPool);

            DbgPrint("\n hit 'g' to continue ...");
            DbgBreakPoint();

            KeReleaseSpinLock(&adapter->adapterSpinLock, oldIrql);
        }
    }


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rndis\usb8023\rndissim.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    rndissim.c


Author:

    ervinp

Environment:

    Kernel mode

Revision History:


--*/


#include <ndis.h>      
#include <ntddndis.h>  // defines OID's

#include "..\inc\rndis.h"
#include "..\inc\rndisapi.h"   

#include "usb8023.h"
#include "debug.h"


#if DO_FULL_RESET

    NTSTATUS SimulateRNDISHalt(ADAPTEREXT *adapter)
    {
        USBPACKET *packet;
        NTSTATUS status;
        
        packet = DequeueFreePacket(adapter);
        if (packet){
            PRNDIS_MESSAGE haltMsg;
            ULONG haltMsgSize;

            haltMsgSize = FIELD_OFFSET(RNDIS_MESSAGE, Message) + 
                          sizeof(RNDIS_HALT_REQUEST);

            haltMsg = (PRNDIS_MESSAGE)packet->dataBuffer;
            haltMsg->NdisMessageType = REMOTE_NDIS_HALT_MSG;
            haltMsg->MessageLength = haltMsgSize;
            haltMsg->Message.HaltRequest.RequestId = 1;

            packet->dataBufferCurrentLength = haltMsgSize;

            status = SubmitPacketToControlPipe(packet, TRUE, TRUE);
            EnqueueFreePacket(packet);
        }
        else {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }

        ASSERT(NT_SUCCESS(status));
        return status;
    }


    NTSTATUS SimulateRNDISInit(ADAPTEREXT *adapter)
    {
        USBPACKET *packet;
        NTSTATUS status;
        
        packet = DequeueFreePacket(adapter);
        if (packet){
            PRNDIS_MESSAGE initMsg;
            ULONG initMsgSize;

            initMsgSize = FIELD_OFFSET(RNDIS_MESSAGE, Message) + 
                          sizeof(RNDIS_INITIALIZE_REQUEST);

            initMsg = (PRNDIS_MESSAGE)packet->dataBuffer;
            initMsg->NdisMessageType = REMOTE_NDIS_INITIALIZE_MSG;
            initMsg->MessageLength = initMsgSize;
            initMsg->Message.InitializeRequest.RequestId = 1;
            initMsg->Message.InitializeRequest.MajorVersion = adapter->rndismpMajorVersion;
            initMsg->Message.InitializeRequest.MinorVersion = adapter->rndismpMinorVersion;
            initMsg->Message.InitializeRequest.MaxTransferSize = adapter->rndismpMaxTransferSize;

            packet->dataBufferCurrentLength = initMsgSize;

            status = SubmitPacketToControlPipe(packet, TRUE, TRUE);
            if (NT_SUCCESS(status)){
                /*
                 *  The adapter will now return a notification to indicate
                 *  that it has the init-complete response.
                 *  Read the notify pipe synchronously so as not to
                 *  restart the notify read loop.
                 */
                status = SubmitNotificationRead(adapter, TRUE);
                if (NT_SUCCESS(status)){
                    /*
                     *  Now read the init-complete message
                     *  from the control pipe and throw it away.
                     *  Do a synchronous read so the result doesn't
                     *  propagate up to RNDISMP.
                     */
                    status = ReadPacketFromControlPipe(packet, TRUE);  
                    if (NT_SUCCESS(status)){
                        PRNDIS_MESSAGE initCmpltMessage;

                        initCmpltMessage = (PRNDIS_MESSAGE)packet->dataBuffer;
                        status = initCmpltMessage->Message.InitializeComplete.Status;
                        if (NT_SUCCESS(status)){
                        }
                        else {
                            DBGERR(("SimulateRNDISInit: init-complete failed with %xh.", status));
                        }
                    }
                    else {
                        DBGERR(("SimulateRNDISInit: read for init-complete failed with %xh.", status));
                    }
                }
                else {
                    DBGERR(("SimulateRNDISInit: notification read failed with %xh.", status));
                }
            }
            else {
                DBGWARN(("SimulateRNDISInit: simulated init failed with %xh.", status));
            }

            EnqueueFreePacket(packet);
        }
        else {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }

        return status;
    }


    NTSTATUS SimulateRNDISSetPacketFilter(ADAPTEREXT *adapter)
    {
        USBPACKET *packet;
        NTSTATUS status;
        
        packet = DequeueFreePacket(adapter);
        if (packet){
            PRNDIS_MESSAGE setMsg;
            ULONG setMsgSize;

            setMsgSize = FIELD_OFFSET(RNDIS_MESSAGE, Message) + 
                         sizeof(RNDIS_SET_REQUEST) +
                         sizeof(ULONG);

            setMsg = (PRNDIS_MESSAGE)packet->dataBuffer;
            setMsg->NdisMessageType = REMOTE_NDIS_SET_MSG;
            setMsg->MessageLength = setMsgSize;
            setMsg->Message.SetRequest.RequestId = 1;
            setMsg->Message.SetRequest.Oid = OID_GEN_CURRENT_PACKET_FILTER;
            setMsg->Message.SetRequest.InformationBufferLength = sizeof(ULONG);
            setMsg->Message.SetRequest.InformationBufferOffset = sizeof(RNDIS_SET_REQUEST);
            *(PULONG)((PUCHAR)&setMsg->Message.SetRequest+sizeof(RNDIS_SET_REQUEST)) = adapter->currentPacketFilter;

            packet->dataBufferCurrentLength = setMsgSize;

            status = SubmitPacketToControlPipe(packet, TRUE, TRUE);
            if (NT_SUCCESS(status)){
                /*
                 *  The adapter will now return a notification to indicate
                 *  that it has the init-complete response.
                 *  Read the notify pipe synchronously so as not to
                 *  restart the notify read loop.
                 */
                status = SubmitNotificationRead(adapter, TRUE);
                if (NT_SUCCESS(status)){
                    /*
                     *  Now read the init-complete message
                     *  from the control pipe and throw it away.
                     *  Do a synchronous read so the result doesn't
                     *  propagate up to RNDISMP.
                     */
                    status = ReadPacketFromControlPipe(packet, TRUE);  
                    if (NT_SUCCESS(status)){
                        PRNDIS_MESSAGE setCmpltMessage;

                        setCmpltMessage = (PRNDIS_MESSAGE)packet->dataBuffer;
                        status = setCmpltMessage->Message.SetComplete.Status;
                        if (NT_SUCCESS(status)){
                        }
                        else {
                            DBGERR(("SimulateRNDISSetPacketFilter: init-complete failed with %xh.", status));
                        }
                    }
                    else {
                        DBGERR(("SimulateRNDISSetPacketFilter: read for init-complete failed with %xh.", status));
                    }
                }
                else {
                    DBGERR(("SimulateRNDISSetPacketFilter: notification read failed with %xh.", status));
                }
            }
            else {
                DBGERR(("SimulateRNDISSetPacketFilter: oid returned %xh.", status));
            }

            EnqueueFreePacket(packet);
        }
        else {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }

        ASSERT(NT_SUCCESS(status));
        return status;
    }


    NTSTATUS SimulateRNDISSetCurrentAddress(ADAPTEREXT *adapter)
    {
        NTSTATUS status;
        
        if (RtlEqualMemory(adapter->MAC_Address, "\0\0\0\0\0\0", ETHERNET_ADDRESS_LENGTH)){
            /*
             *  A 'software' MAC address was never assigned.
             *  So no need to resend it.
             */
            status = STATUS_SUCCESS;
        }
        else {
            USBPACKET *packet = DequeueFreePacket(adapter);
            if (packet){
                PRNDIS_MESSAGE setMsg;
                ULONG setMsgSize;

                setMsgSize = FIELD_OFFSET(RNDIS_MESSAGE, Message) + 
                             sizeof(RNDIS_SET_REQUEST) +
                             ETHERNET_ADDRESS_LENGTH;

                setMsg = (PRNDIS_MESSAGE)packet->dataBuffer;
                setMsg->NdisMessageType = REMOTE_NDIS_SET_MSG;
                setMsg->MessageLength = setMsgSize;
                setMsg->Message.SetRequest.RequestId = 1;
                setMsg->Message.SetRequest.Oid = OID_802_3_CURRENT_ADDRESS;
                setMsg->Message.SetRequest.InformationBufferLength = ETHERNET_ADDRESS_LENGTH;
                setMsg->Message.SetRequest.InformationBufferOffset = sizeof(RNDIS_SET_REQUEST);
                RtlMoveMemory(  (PUCHAR)&setMsg->Message.SetRequest+sizeof(RNDIS_SET_REQUEST),
                                adapter->MAC_Address,
                                ETHERNET_ADDRESS_LENGTH);

                packet->dataBufferCurrentLength = setMsgSize;

                status = SubmitPacketToControlPipe(packet, TRUE, TRUE);
                if (NT_SUCCESS(status)){
                    /*
                     *  The adapter will now return a notification to indicate
                     *  that it has the init-complete response.
                     *  Read the notify pipe synchronously so as not to
                     *  restart the notify read loop.
                     */
                    status = SubmitNotificationRead(adapter, TRUE);
                    if (NT_SUCCESS(status)){
                        /*
                         *  Now read the init-complete message
                         *  from the control pipe and throw it away.
                         *  Do a synchronous read so the result doesn't
                         *  propagate up to RNDISMP.
                         */
                        status = ReadPacketFromControlPipe(packet, TRUE);  
                        if (NT_SUCCESS(status)){
                            PRNDIS_MESSAGE setCmpltMessage;

                            setCmpltMessage = (PRNDIS_MESSAGE)packet->dataBuffer;
                            status = setCmpltMessage->Message.SetComplete.Status;
                            if (NT_SUCCESS(status)){
                            }
                            else {
                                DBGERR(("SimulateRNDISSetPacketFilter: init-complete failed with %xh.", status));
                            }
                        }
                        else {
                            DBGERR(("SimulateRNDISSetCurrentAddress: read for init-complete failed with %xh.", status));
                        }
                    }
                    else {
                        DBGERR(("SimulateRNDISSetCurrentAddress: notification read failed with %xh.", status));
                    }
                }
                else {
                    DBGERR(("SimulateRNDISSetCurrentAddress: oid returned %xh.", status));
                }

                EnqueueFreePacket(packet);
            }
            else {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        ASSERT(NT_SUCCESS(status));
        return status;
    }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rndis\usb8023\debug.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    debug.h

Abstract: ESC/POS (serial) interface for USB Point-of-Sale devices

Author:

    ervinp

Environment:

    Kernel mode

Revision History:


--*/

#define BAD_POINTER ((PVOID)0xDEADDEAD)
#define ISPTR(ptr) ((ptr) && ((ptr) != BAD_POINTER))


/*
 *  For X86 debug, wrap memory allocations so we can find leaks
 *  (causes runtime alignment errors on IA64).
 */
#define DBG_WRAP_MEMORY 0
#if DBG 
    #ifdef _X86_
        #undef DBG_WRAP_MEMORY
        #define DBG_WRAP_MEMORY 1
    #endif
#endif


#if DBG

    extern BOOLEAN dbgTrapOnWarn;
    extern BOOLEAN dbgVerbose;
    extern BOOLEAN dbgSkipSecurity;
    extern BOOLEAN dbgDumpBytes;

    #if DBG_WRAP_MEMORY
        extern ULONG dbgTotalMemCount;
        extern LIST_ENTRY dbgAllMemoryList;
    #endif

    #define DRIVERNAME "USB8023"

    #if WIN9X_BUILD
        #define DBG_LEADCHAR ' '
    #else
        #define DBG_LEADCHAR '\''
    #endif
    
    #define TRAP(msg)                                        \
        {                                               \
            DbgPrint("%c"DRIVERNAME"> Code coverage trap: '%s' file %s, line %d \n",  DBG_LEADCHAR, (msg), __FILE__, __LINE__ ); \
            DbgBreakPoint();                            \
        }

    #undef ASSERT
    #define ASSERT(fact)                                        \
        if (!(fact)){                                               \
            DbgPrint("%c"DRIVERNAME"> Assertion '%s' failed: file %s, line %d \n",  DBG_LEADCHAR, #fact, __FILE__, __LINE__ ); \
            DbgBreakPoint();                            \
        }

    #define DBGWARN(args_in_parens)                                \
        {                                               \
            DbgPrint("%c"DRIVERNAME"> *** WARNING *** (file %s, line %d)\n", DBG_LEADCHAR, __FILE__, __LINE__ ); \
            DbgPrint("%c    > ", DBG_LEADCHAR); \
            DbgPrint args_in_parens; \
            DbgPrint("\n"); \
            if (dbgTrapOnWarn){ \
                DbgBreakPoint();                            \
            } \
        }
    #define DBGERR(args_in_parens)                                \
        {                                               \
            DbgPrint("%c"DRIVERNAME"> *** ERROR *** (file %s, line %d)\n", DBG_LEADCHAR, __FILE__, __LINE__ ); \
            DbgPrint("%c    > ", DBG_LEADCHAR); \
            DbgPrint args_in_parens; \
            DbgPrint("\n"); \
            DbgBreakPoint();                            \
        }
    #define DBGOUT(args_in_parens)                                \
        {                                               \
            DbgPrint("%c"DRIVERNAME"> ", DBG_LEADCHAR); \
            DbgPrint args_in_parens; \
            DbgPrint("\n"); \
        }
    #define DBGVERBOSE(args_in_parens)                                \
        if (dbgVerbose){                                               \
            DbgPrint("%c"DRIVERNAME"> ", DBG_LEADCHAR); \
            DbgPrint args_in_parens; \
            DbgPrint("\n"); \
        }


    VOID InitDebug();
	VOID DbgShowBytes(PUCHAR msg, PUCHAR buf, ULONG len);
    VOID DbgShowMdlBytes(PUCHAR msg, PMDL mdl);
    PUCHAR DbgGetOidName(ULONG oid);
    VOID DbgDumpPacketStates(ADAPTEREXT *adapter);
    void DbgStallExecution(ULONG usec);
    ULONG DbgGetSystemTime_msec();

    #define INITDEBUG() InitDebug()
	#define DBGSHOWBYTES(msg, buf, len) DbgShowBytes(msg, buf, len)
    #define DBGSHOWMDLBYTES(msg, mdl) DbgShowMdlBytes(msg, mdl)
    #define DBGDUMPPACKETSTATES(adapterx) DbgDumpPacketStates(adapterx)
#else
    #define DBGWARN(args_in_parens)                               
    #define DBGERR(args_in_parens)                               
    #define DBGOUT(args_in_parens)                               
    #define DBGVERBOSE(args_in_parens)                               
    #define TRAP(msg)         

    #define INITDEBUG()
	#define DBGSHOWBYTES(msg, buf, len)
    #define DBGSHOWMDLBYTES(msg, mdl)
    #define DBGDUMPPACKETSTATES(adapterx) 
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rndis\usb8023\rndis.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    rndis.c


Author:

    ervinp

Environment:

    Kernel mode

Revision History:


--*/


#include <ndis.h>      
#include <ntddndis.h>  // defines OID's

#include "..\inc\rndis.h"
#include "..\inc\rndisapi.h"   

#include "usb8023.h"
#include "debug.h"


      
NDIS_STATUS RndisInitializeHandler(     OUT PNDIS_HANDLE pMiniportAdapterContext,
                                        OUT PULONG pMaxReceiveSize, 
                                        IN NDIS_HANDLE RndisMiniportHandle,
                                        IN NDIS_HANDLE NdisMiniportHandle,
                                        IN NDIS_HANDLE WrapperConfigurationContext,
                                        IN PDEVICE_OBJECT Pdo)
{
    NDIS_STATUS rndisStat;
    ADAPTEREXT *adapter;	

    DBGVERBOSE(("RndisInitializeHandler"));  

    /*
     *  Allocate a new device object to represent this connection.
     */
    adapter = NewAdapter(Pdo);
    if (adapter){

        adapter->ndisAdapterHandle = (PVOID)NdisMiniportHandle;
        adapter->rndisAdapterHandle = (PVOID)RndisMiniportHandle;


        if (InitUSB(adapter)){

            /*
             *  Figure out the buffer size required for each packet.
             *
             *  For native RNDIS, the buffer must include the rndis message and RNDIS_PACKET.
             *  For KLSI, we have to prepend a two-byte size field to each packet.
             *  For other prototypes, we have to append zeroes to round the length 
             *  up to the next multiple of the endpoint packet size.
             *
             *  We must also need one extra byte for the one-byte short packet that
             *  must follow a full-sized frame.
             */
            ASSERT(adapter->writePipeLength);
            ASSERT(adapter->readPipeLength);

            /*
             *  Allocate common resources before miniport-specific resources
             *  because we need to allocate the packet pool first.
             */
            if (AllocateCommonResources(adapter)){

                EnqueueAdapter(adapter);

                /*
                 *  Give RNDIS our adapter context, which it will use to call us.
                 */
                *pMiniportAdapterContext = (NDIS_HANDLE)adapter;

                *pMaxReceiveSize = PACKET_BUFFER_SIZE;  

                rndisStat = NDIS_STATUS_SUCCESS;
            }
            else {
                rndisStat = NDIS_STATUS_NOT_ACCEPTED;
            }
        }
        else {
            rndisStat = NDIS_STATUS_NOT_ACCEPTED;
        }

        if (rndisStat != NDIS_STATUS_SUCCESS){
            FreeAdapter(adapter);
        }
    }
    else {
	    rndisStat = NDIS_STATUS_NOT_ACCEPTED;
    }

    return rndisStat;
}


NDIS_STATUS RndisInitCompleteNotify(IN NDIS_HANDLE MicroportAdapterContext,
                                    IN ULONG DeviceFlags,
                                    IN OUT PULONG pMaxTransferSize)
{
    ADAPTEREXT *adapter = (ADAPTEREXT *)MicroportAdapterContext;

    if (*pMaxTransferSize > PACKET_BUFFER_SIZE) {

        DBGWARN(("Reducing adapter MaxTransferSize from %xh to %xh.",
            *pMaxTransferSize, PACKET_BUFFER_SIZE));

        *pMaxTransferSize = PACKET_BUFFER_SIZE;
    }

    StartUSBReadLoop(adapter);

    return NDIS_STATUS_SUCCESS;
}


VOID RndisHalt(IN NDIS_HANDLE MicroportAdapterContext)
{
    BOOLEAN workItemOrTimerPending;
    KIRQL oldIrql;
    ADAPTEREXT *adapter = (ADAPTEREXT *)MicroportAdapterContext;

    ASSERT(KeGetCurrentIrql() <= APC_LEVEL);

    DBGOUT(("> RndisHalt(%ph)", adapter));  

    ASSERT(adapter->sig == DRIVER_SIG);

    HaltAdapter(adapter);

    KeAcquireSpinLock(&adapter->adapterSpinLock, &oldIrql);
    workItemOrTimerPending = adapter->workItemOrTimerPending;
    KeReleaseSpinLock(&adapter->adapterSpinLock, oldIrql);

    if (workItemOrTimerPending){
        /*
         *  Wait until workItem fires back to us before freeing the adapter context.
         */
        KeWaitForSingleObject(&adapter->workItemOrTimerEvent, Executive, KernelMode, FALSE, NULL);
    }

    DequeueAdapter(adapter);

    FreeAdapter(adapter);

    #if DBG_WRAP_MEMORY
        if (dbgTotalMemCount != 0){
            DBGERR(("RndisHalt: unloading with %xh bytes still allocated !!", dbgTotalMemCount));
        }
    #endif

    DBGOUT(("< RndisHalt")); 
}


VOID RndisShutdown(IN NDIS_HANDLE MicroportAdapterContext)
{
    ADAPTEREXT *adapter = (ADAPTEREXT *)MicroportAdapterContext;

    DBGOUT(("RndisShutdown(%ph)", adapter)); 

    #if DBG_WRAP_MEMORY
        if (dbgTotalMemCount != 0){
            DBGERR(("RndisShutdown: unloading with %xh bytes still allocated !!", dbgTotalMemCount));
        }
    #endif
}


VOID RndisSendMessageHandler(   IN NDIS_HANDLE MicroportAdapterContext, 
                                IN PMDL pMessageMdl, 
                                IN NDIS_HANDLE RndisMessageHandle,
                                IN RM_CHANNEL_TYPE ChannelType)
{
    ADAPTEREXT *adapter = (ADAPTEREXT *)MicroportAdapterContext;

    ASSERT(adapter->sig == DRIVER_SIG);

    if (!adapter->resetting){
        /*
         *  The message header is guaranteed to be contained in the first buffer of the MDL.
         */
        PRNDIS_MESSAGE pMsg = GetSystemAddressForMdlSafe(pMessageMdl);
        if (pMsg){

            ASSERT(!adapter->halting);

            if (adapter->numActiveWritePackets <= USB_PACKET_POOL_SIZE*3/4){

                USBPACKET *packet = DequeueFreePacket(adapter);
                if (packet){

                    packet->rndisMessageHandle = (PVOID)RndisMessageHandle;

                    /*
                     *  Move our packet to the usbPendingWritePackets queue
                     *  and send it down the USB pipe.
                     *  Native RNDIS packet messages go intact to the write pipe.
                     *  All other encapsulated commands go to the control pipe.
                     */
                    EnqueuePendingWritePacket(packet);

                    if (ChannelType == RMC_DATA) {
                        ASSERT(!packet->ndisSendPktMdl);

                        #ifdef RAW_TEST
                        if (adapter->rawTest) {
                            pMessageMdl = AddDataHeader(pMessageMdl);
                            if (pMessageMdl == NULL) {
                                DequeuePendingWritePacket(packet);
                                RndisMSendComplete( (NDIS_HANDLE)adapter->rndisAdapterHandle, 
                                                    RndisMessageHandle,
                                                    NDIS_STATUS_RESOURCES);
                                return;
                            }
                            packet->dataPacket = TRUE;
                        }
                        #endif // RAW_TEST

                        packet->ndisSendPktMdl = pMessageMdl;
                        packet->dataBufferCurrentLength = CopyMdlToBuffer(packet->dataBuffer, pMessageMdl, packet->dataBufferMaxLength);

                        SubmitUSBWritePacket(packet);
                    }
                    else {
                        NTSTATUS status;
                        ULONG msgType = pMsg->NdisMessageType;
                        BOOLEAN synchronizeUSBcall = FALSE;
                        ULONG oid;
                        RNDIS_REQUEST_ID reqId;

                        switch (msgType){

                            case REMOTE_NDIS_INITIALIZE_MSG:
                                {
                                    ULONG maxXferSize = pMsg->Message.InitializeRequest.MaxTransferSize;
                                    DBGOUT(("---- REMOTE_NDIS_INITIALIZE_MSG (MaxTransferSize = %xh) ----", maxXferSize));
                                    ASSERT(maxXferSize <= PACKET_BUFFER_SIZE);
                                    adapter->rndismpMajorVersion = pMsg->Message.InitializeRequest.MajorVersion;
                                    adapter->rndismpMinorVersion = pMsg->Message.InitializeRequest.MinorVersion;
                                    adapter->rndismpMaxTransferSize = maxXferSize;
                                    synchronizeUSBcall = TRUE;
                                }
                                break;

                            case REMOTE_NDIS_SET_MSG:
                            case REMOTE_NDIS_QUERY_MSG:
                                oid = pMsg->Message.SetRequest.Oid;
                                reqId = pMsg->Message.SetRequest.RequestId;

                                DBGVERBOSE(("> %s (req#%d)", DbgGetOidName(oid), reqId));

                                if (oid == OID_GEN_CURRENT_PACKET_FILTER){
                                    ULONG pktFilter = *(PULONG)((PUCHAR)&pMsg->Message.SetRequest+pMsg->Message.SetRequest.InformationBufferOffset);
                                    adapter->currentPacketFilter = pktFilter;
                                    adapter->gotPacketFilterIndication = TRUE;
                                    DBGOUT(("---- Got OID_GEN_CURRENT_PACKET_FILTER (%xh) ----", pktFilter));
                                }
                                else if (oid == OID_802_3_CURRENT_ADDRESS){
                                    /*
                                     *  This oid can be a query or a set.
                                     *  If it's a set, save the assigned
                                     *  MAC address in case we need to simulate
                                     *  it later on a reset.
                                     */
                                    if (msgType == REMOTE_NDIS_SET_MSG){
                                        ASSERT(pMsg->Message.SetRequest.InformationBufferLength == ETHERNET_ADDRESS_LENGTH);
                                        DBGVERBOSE(("COVERAGE - OID_802_3_CURRENT_ADDRESS (SET), msg=%xh.", pMsg));
                                        RtlMoveMemory(  adapter->MAC_Address, 
                                                        ((PUCHAR)&pMsg->Message.SetRequest+pMsg->Message.SetRequest.InformationBufferOffset), 
                                                        ETHERNET_ADDRESS_LENGTH);
                                    }
                                }

                                adapter->dbgCurrentOid = oid;

                                break;
        
                            case REMOTE_NDIS_RESET_MSG:
                                DBGWARN(("---- REMOTE_NDIS_RESET_MSG ----"));
                                adapter->numSoftResets++;
                                break;

                            case REMOTE_NDIS_HALT_MSG:
                                DBGWARN(("---- REMOTE_NDIS_HALT_MSG ----"));
                                break;
                        }


                        packet->dataBufferCurrentLength = CopyMdlToBuffer(  packet->dataBuffer,
                                                                            pMessageMdl,
                                                                            packet->dataBufferMaxLength);

                        #ifdef RAW_TEST
                        packet->dataPacket = FALSE;
                        #endif
                        status = SubmitPacketToControlPipe(packet, synchronizeUSBcall, FALSE);

                        /*
                         *  If this is an init message, then start reading the notify pipe.
                         */
                        switch (msgType){

                            case REMOTE_NDIS_INITIALIZE_MSG:
                                if (NT_SUCCESS(status)){
                                    adapter->initialized = TRUE;
                                    SubmitNotificationRead(adapter, FALSE);
                                }
                                else {
                                    DBGERR(("Device failed REMOTE_NDIS_INITIALIZE_MSG with %xh.", status));
                                }
                                break;

                        }
                    }
                }
                else {
                    RndisMSendComplete( (NDIS_HANDLE)adapter->rndisAdapterHandle, 
                                        RndisMessageHandle,
                                        NDIS_STATUS_RESOURCES);
                }
            }
            else {
                DBGWARN(("RndisSendMessageHandler: throttling sends because only %d packets available for rcv ", USB_PACKET_POOL_SIZE-adapter->numActiveWritePackets));
                RndisMSendComplete( (NDIS_HANDLE)adapter->rndisAdapterHandle, 
                                    RndisMessageHandle,
                                    NDIS_STATUS_RESOURCES);
            }
        }
        else {
            DBGERR(("GetSystemAddressForMdlSafe failed"));
            RndisMSendComplete( (NDIS_HANDLE)adapter->rndisAdapterHandle, 
                                RndisMessageHandle,
                                NDIS_STATUS_INVALID_PACKET);
        }
    }
    else {
        DBGWARN(("RndisSendMessageHandler - failing send because adapter is resetting"));
        RndisMSendComplete( (NDIS_HANDLE)adapter->rndisAdapterHandle, 
                            RndisMessageHandle,
                            NDIS_STATUS_MEDIA_BUSY);
    }
}





/*
 *  RndisReturnMessageHandler
 * 
 *  This is the completion of a received packet indication call.
 */
VOID RndisReturnMessageHandler(     IN NDIS_HANDLE MicroportAdapterContext,
                                    IN PMDL pMessageMdl,
                                    IN NDIS_HANDLE MicroportMessageContext)
{
    USBPACKET *packet;

    DBGVERBOSE(("RndisReturnMessageHandler: msgMdl=%ph, msg context = %ph.", pMessageMdl, MicroportMessageContext));

    ASSERT(MicroportMessageContext);
    packet = (USBPACKET *)MicroportMessageContext;
    ASSERT(packet->sig == DRIVER_SIG);

    #ifdef RAW_TEST
    {
        ADAPTEREXT * adapter = (ADAPTEREXT *)MicroportAdapterContext;
        if (adapter->rawTest) {
            if (packet->dataPacket) {
                UnskipRcvRndisPacketHeader(packet);
            }
        }
    }
    #endif // RAW_TEST

    /*
     *  The receive indication is done.
     *  Put our packet back in the free list.
     */
    DequeueCompletedReadPacket(packet);
    EnqueueFreePacket(packet);
}



BOOLEAN RegisterRNDISMicroport(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)
{
    RNDIS_MICROPORT_CHARACTERISTICS rndisAttribs;
    NDIS_HANDLE ndisWrapperHandle;    

    DBGVERBOSE(("RegisterRNDISMicroport"));

    RtlZeroMemory(&rndisAttribs, sizeof(rndisAttribs));
    rndisAttribs.RndisVersion = RNDIS_VERSION;
    rndisAttribs.Reserved = 0;
    rndisAttribs.RmInitializeHandler = RndisInitializeHandler;
    rndisAttribs.RmInitCompleteNotifyHandler = RndisInitCompleteNotify;
    rndisAttribs.RmHaltHandler = RndisHalt;
    rndisAttribs.RmShutdownHandler = RndisShutdown;
    rndisAttribs.RmSendMessageHandler = RndisSendMessageHandler;
    rndisAttribs.RmReturnMessageHandler = RndisReturnMessageHandler;

    RndisMInitializeWrapper(    &ndisWrapperHandle, 
                                NULL, 
                                DriverObject, 
                                RegistryPath, 
                                &rndisAttribs);

    return TRUE;
}



VOID IndicateSendStatusToRNdis(USBPACKET *packet, NTSTATUS status)
{
#ifdef RAW_TEST
    ADAPTEREXT *adapter = packet->adapter;

    if (adapter->rawTest && packet->dataPacket) {
        FreeDataHeader(packet);
    }
#endif /? RAW_TEST

    packet->ndisSendPktMdl = NULL;

    ASSERT(packet->rndisMessageHandle);

    RndisMSendComplete( (NDIS_HANDLE)packet->adapter->rndisAdapterHandle, 
                        (NDIS_HANDLE)packet->rndisMessageHandle,
                        (NDIS_STATUS)status);
}


VOID RNDISProcessNotification(ADAPTEREXT *adapter)
{
    UCHAR notification = *(PUCHAR)adapter->notifyBuffer;
    UCHAR notificationCode = *((PUCHAR)adapter->notifyBuffer + 1);

    if ((notification == NATIVE_RNDIS_RESPONSE_AVAILABLE) ||
        ((notification == CDC_RNDIS_NOTIFICATION) &&
         (notificationCode == CDC_RNDIS_RESPONSE_AVAILABLE)))
    {
            /*
             *  Try to read a native RNDIS encapsulated command from the control pipe.
             */
            DBGVERBOSE(("NativeRNDISProcessNotification: NATIVE_RNDIS_RESPONSE_AVAILABLE"));
            {
                USBPACKET *packet = DequeueFreePacket(adapter);
                if (packet){
                    EnqueuePendingReadPacket(packet);
                    ReadPacketFromControlPipe(packet, FALSE);  
                }
                else {
                    DBGWARN(("couldn't get free packet in NativeRNDISProcessNotification"));
                }
            }
    }
    else {
            DBGERR(("NativeRNDISProcessNotification: unknown notification %xh.", notification));
    }
}


NTSTATUS IndicateRndisMessage(  IN USBPACKET *packet,
                                IN BOOLEAN bIsData)
{
    ADAPTEREXT *adapter = packet->adapter;
    PRNDIS_MESSAGE rndisMsg = (PRNDIS_MESSAGE)packet->dataBuffer;
    NDIS_STATUS rcvStat;

    ASSERT(packet->dataBufferCurrentLength <= packet->dataBufferMaxLength);

    /*
     *  Indicate the packet to RNDIS, and pass a pointer to our usb packet
     *  as the MicroportMessageContext.
     *  The packet/message will be returned to us via RndisReturnMessageHandler.
     */
    MyInitializeMdl(packet->dataBufferMdl, packet->dataBuffer, packet->dataBufferCurrentLength);
    if (adapter->numFreePackets < USB_PACKET_POOL_SIZE/8){
        rcvStat = NDIS_STATUS_RESOURCES;
    }
    else {
        rcvStat = NDIS_STATUS_SUCCESS;
    }

    #ifdef RAW_TEST
    if (adapter->rawTest) {
        packet->dataPacket = bIsData;
        if (bIsData) {
            SkipRcvRndisPacketHeader(packet);
        }
    }
    #endif // RAW_TEST

    RndisMIndicateReceive(  (NDIS_HANDLE)packet->adapter->rndisAdapterHandle,
                            packet->dataBufferMdl,
                            (NDIS_HANDLE)packet,
                            (bIsData? RMC_DATA: RMC_CONTROL),
                            rcvStat);

    return STATUS_PENDING;

}


#ifdef RAW_TEST

//
// Add an RNDIS_PACKET header to a sent "raw" encapsulated Ethernet frame.
//
PMDL AddDataHeader(IN PMDL pMessageMdl)
{
    PMDL pHeaderMdl, pTmpMdl;
    PRNDIS_MESSAGE	pRndisMessage;
    PRNDIS_PACKET pRndisPacket;
    ULONG TotalLength;

    //
    // Compute the total length.
    //
    TotalLength = 0;
    for (pTmpMdl = pMessageMdl; pTmpMdl != NULL; pTmpMdl = pTmpMdl->Next)
    {
        TotalLength += MmGetMdlByteCount(pTmpMdl);
    }

    //
    // Allocate an RNDIS packet header:
    //
    pRndisMessage = AllocPool(RNDIS_MESSAGE_SIZE(RNDIS_PACKET));
    if (pRndisMessage != NULL) {

        pHeaderMdl = IoAllocateMdl(pRndisMessage,
                                   RNDIS_MESSAGE_SIZE(RNDIS_PACKET),
                                   FALSE,
                                   FALSE,
                                   NULL);

        if (pHeaderMdl != NULL) {
            MmBuildMdlForNonPagedPool(pHeaderMdl);

            //
            // Fill in the RNDIS message generic header:
            //
            pRndisMessage->NdisMessageType = REMOTE_NDIS_PACKET_MSG;
            pRndisMessage->MessageLength = RNDIS_MESSAGE_SIZE(RNDIS_PACKET) + TotalLength;

            //
            // Fill in the RNDIS_PACKET structure:
            //
            pRndisPacket = (PRNDIS_PACKET)&pRndisMessage->Message;
            pRndisPacket->DataOffset = sizeof(RNDIS_PACKET);
            pRndisPacket->DataLength = TotalLength;
            pRndisPacket->OOBDataOffset = 0;
            pRndisPacket->OOBDataLength = 0;
            pRndisPacket->NumOOBDataElements = 0;
            pRndisPacket->PerPacketInfoOffset = 0;
            pRndisPacket->PerPacketInfoLength = 0;
            pRndisPacket->VcHandle = 0;
            pRndisPacket->Reserved = 0;

            //
            // Link it to the raw data frame:
            //
            pHeaderMdl->Next = pMessageMdl;
        }
        else {
            FreePool(pRndisMessage);
            pHeaderMdl = NULL;
        }
    }
    else {
        pHeaderMdl = NULL;
    }

    return (pHeaderMdl);
}

//
// Remove an RNDIS_PACKET header that we had added to a raw encapsulated
// Ethernet frame.
//
VOID FreeDataHeader(IN USBPACKET * packet)
{
    PMDL pHeaderMdl;
    PRNDIS_MESSAGE pRndisMessage;

    ASSERT(packet->dataPacket == TRUE);

    //
    // Take out the MDL we had pre-pended
    //
    pHeaderMdl = packet->ndisSendPktMdl;
    packet->ndisSendPktMdl = pHeaderMdl->Next;

    //
    // Free the RNDIS_PACKET header:
    //
    pRndisMessage = MmGetMdlVirtualAddress(pHeaderMdl);
    FreePool(pRndisMessage);

    //
    // ... and the MDL itself.
    //
    IoFreeMdl(pHeaderMdl);
}


//
// Modify a received message to skip the RNDIS_PACKET header
// before indicating this up to RNDISMP, to test raw encapsulation.
//
VOID SkipRcvRndisPacketHeader(IN USBPACKET * packet)
{
    PMDL pHeaderMdl;
    RNDIS_MESSAGE UNALIGNED * pRndisMessage;
    RNDIS_PACKET UNALIGNED * pRndisPacket;
    ULONG DataLength;
    ULONG DataOffset;

    //
    // Get some info from the received RNDIS_PACKET message.
    // Note that this may contain multiple data packets, in which
    // case we only pass up the first one.
    //
    pHeaderMdl = packet->dataBufferMdl;
    pRndisMessage = MmGetMdlVirtualAddress(pHeaderMdl);
    pRndisPacket = (RNDIS_PACKET UNALIGNED *)&pRndisMessage->Message;
    DataLength = pRndisPacket->DataLength;
    DataOffset = FIELD_OFFSET(RNDIS_MESSAGE, Message) + pRndisPacket->DataOffset;

    //
    // Save away some existing values to restore later.
    //
    packet->rcvDataOffset = DataOffset;
    packet->rcvByteCount = pHeaderMdl->ByteCount;


    //
    // This is ONLY for test purposes. Simply modify the MDL to reflect
    // a single "raw" encapsulated frame.
    //
    pHeaderMdl->ByteOffset += DataOffset;
    (ULONG_PTR)pHeaderMdl->MappedSystemVa += DataOffset;
    pHeaderMdl->ByteCount = DataLength;
}


//
// Undo for the above function.
// 
VOID UnskipRcvRndisPacketHeader(IN USBPACKET * packet)
{
    PMDL pHeaderMdl;

    ASSERT(packet->dataPacket == TRUE);

    //
    // Undo everything we did in the SkipRcv... function.
    //
    pHeaderMdl = packet->dataBufferMdl;

    pHeaderMdl->ByteOffset -= packet->rcvDataOffset;
    (ULONG_PTR)pHeaderMdl->MappedSystemVa -= packet->rcvDataOffset;
    pHeaderMdl->ByteCount = packet->rcvByteCount;

}

#endif // RAW_TEST
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rndis\usb8023\adapter.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    adapter.c


Author:

    ervinp

Environment:

    Kernel mode

Revision History:


--*/

#include <WDM.H>

#include <usbdi.h>
#include <usbdlib.h>
#include <usbioctl.h>

#include "usb8023.h"
#include "debug.h"


LIST_ENTRY allAdaptersList;

KSPIN_LOCK globalSpinLock;  

#ifdef RAW_TEST
BOOLEAN rawTest = TRUE;
#endif

ADAPTEREXT *NewAdapter(PDEVICE_OBJECT pdo)
{
    ADAPTEREXT *adapter;

    adapter = AllocPool(sizeof(ADAPTEREXT));
    if (adapter){

        adapter->sig = DRIVER_SIG;

        adapter->nextDevObj = pdo; 
        adapter->physDevObj = pdo;

        InitializeListHead(&adapter->adaptersListEntry);
        KeInitializeSpinLock(&adapter->adapterSpinLock);

        InitializeListHead(&adapter->usbFreePacketPool);
        InitializeListHead(&adapter->usbPendingReadPackets);
        InitializeListHead(&adapter->usbPendingWritePackets);
        InitializeListHead(&adapter->usbCompletedReadPackets);

        adapter->initialized = FALSE;
        adapter->halting = FALSE;
        adapter->gotPacketFilterIndication = FALSE;
        adapter->readReentrancyCount = 0;

        #ifdef RAW_TEST
        adapter->rawTest = rawTest;
        #endif

        /*
         *  Do all internal allocations.  
         *  If any of them fail, FreeAdapter will free the others.
         */
        adapter->deviceDesc = AllocPool(sizeof(USB_DEVICE_DESCRIPTOR));

        #if SPECIAL_WIN98SE_BUILD
            adapter->ioWorkItem = MyIoAllocateWorkItem(adapter->physDevObj);
        #else
            adapter->ioWorkItem = IoAllocateWorkItem(adapter->physDevObj);
        #endif

        if (adapter->deviceDesc && adapter->ioWorkItem){
        }
        else {
            FreeAdapter(adapter);
            adapter = NULL;
        }
    }

    return adapter;
}

VOID FreeAdapter(ADAPTEREXT *adapter)
{
    USBPACKET *packet;

    ASSERT(adapter->sig == DRIVER_SIG);
    adapter->sig = 0xDEADDEAD;
    
    /*
     *  All the read and write packets should have been returned to the free list.
     */
    ASSERT(IsListEmpty(&adapter->usbPendingReadPackets));
    ASSERT(IsListEmpty(&adapter->usbPendingWritePackets));
    ASSERT(IsListEmpty(&adapter->usbCompletedReadPackets));


    /*
     *  Free all the packets in the free list.
     */
    while (packet = DequeueFreePacket(adapter)){
        FreePacket(packet);
    }

    /*
     *  FreeAdapter can be called after a failed start,
     *  so check that each pointer was actually allocated before freeing it.
     */
    if (adapter->deviceDesc) FreePool(adapter->deviceDesc);
    if (adapter->configDesc) FreePool(adapter->configDesc);
    if (adapter->notifyBuffer) FreePool(adapter->notifyBuffer);
    if (adapter->notifyIrpPtr) IoFreeIrp(adapter->notifyIrpPtr);
    if (adapter->notifyUrbPtr) FreePool(adapter->notifyUrbPtr);
    if (adapter->interfaceInfo) FreePool(adapter->interfaceInfo);
    if (adapter->interfaceInfoMaster) FreePool(adapter->interfaceInfoMaster);

    if (adapter->ioWorkItem){
        #if SPECIAL_WIN98SE_BUILD
            MyIoFreeWorkItem(adapter->ioWorkItem);
        #else
            IoFreeWorkItem(adapter->ioWorkItem);
        #endif
    }

    FreePool(adapter);
}

VOID EnqueueAdapter(ADAPTEREXT *adapter)
{
    KIRQL oldIrql;

    ASSERT(adapter->sig == DRIVER_SIG);

    KeAcquireSpinLock(&globalSpinLock, &oldIrql);
    InsertTailList(&allAdaptersList, &adapter->adaptersListEntry);
    KeReleaseSpinLock(&globalSpinLock, oldIrql);
}

VOID DequeueAdapter(ADAPTEREXT *adapter)
{
    KIRQL oldIrql;

    ASSERT(adapter->sig == DRIVER_SIG);

    KeAcquireSpinLock(&globalSpinLock, &oldIrql);
    ASSERT(!IsListEmpty(&allAdaptersList));
    RemoveEntryList(&adapter->adaptersListEntry);
    InitializeListHead(&adapter->adaptersListEntry);
    KeReleaseSpinLock(&globalSpinLock, oldIrql);
}


VOID HaltAdapter(ADAPTEREXT *adapter)
{
    ASSERT(!adapter->halting);

    adapter->halting = TRUE;

    ASSERT(IsListEmpty(&adapter->usbCompletedReadPackets));

    CancelAllPendingPackets(adapter);

    adapter->initialized = FALSE;
}


VOID QueueAdapterWorkItem(ADAPTEREXT *adapter)
{
    BOOLEAN queueNow;
    KIRQL oldIrql;
    BOOLEAN useTimer;

    KeAcquireSpinLock(&adapter->adapterSpinLock, &oldIrql);
    if (adapter->workItemOrTimerPending || adapter->halting || adapter->resetting){
        queueNow = FALSE;
    }
    else {
        adapter->workItemOrTimerPending = queueNow = TRUE;
        useTimer = (adapter->numConsecutiveReadFailures >= 8);
    }
    KeReleaseSpinLock(&adapter->adapterSpinLock, oldIrql);

    if (queueNow){

        KeInitializeEvent(&adapter->workItemOrTimerEvent, NotificationEvent, FALSE);

        if (useTimer){
            /*
             *  If we're experiencing a large number of read failures,
             *  then possibly the hardware needs more time to recover
             *  than allowed by the workItem delay.
             *  This happens specifically on a surprise remove: the reads
             *  start failing, and the flurry of workItems hold off the
             *  actual remove forever.
             *  So in this case, we use a long timer instead of a workItem
             *  in order to allow a large gap before the next attempted read.
             */
            LARGE_INTEGER timerPeriod;
            const ULONG numSeconds = 10;

            DBGWARN(("Large number of READ FAILURES (%d), scheduling %d-second backoff timer ...", adapter->numConsecutiveReadFailures, numSeconds));

            /*
             *  Set the timer for 10 seconds (in negative 100 nsec units).
             */
            timerPeriod.HighPart = -1;
            timerPeriod.LowPart = numSeconds * -10000000;
            KeInitializeTimer(&adapter->backoffTimer);
            KeInitializeDpc(&adapter->backoffTimerDPC, BackoffTimerDpc, adapter);
            KeSetTimer(&adapter->backoffTimer, timerPeriod, &adapter->backoffTimerDPC);
        }
        else {

            #if SPECIAL_WIN98SE_BUILD
                MyIoQueueWorkItem(  adapter->ioWorkItem, 
                                    AdapterWorkItemCallback, 
                                    DelayedWorkQueue,
                                    adapter);
            #else
                IoQueueWorkItem(    adapter->ioWorkItem, 
                                    AdapterWorkItemCallback, 
                                    DelayedWorkQueue,
                                    adapter);
            #endif
        }
    }
}


VOID AdapterWorkItemCallback(IN PDEVICE_OBJECT devObj, IN PVOID context)
{
    ADAPTEREXT *adapter = (ADAPTEREXT *)context;
    
    ASSERT(adapter->sig == DRIVER_SIG);
    ASSERT(adapter->physDevObj == devObj);

    ProcessWorkItemOrTimerCallback(adapter);
}


VOID BackoffTimerDpc(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
{
    ADAPTEREXT *adapter = (ADAPTEREXT *)DeferredContext;
    ASSERT(adapter->sig == DRIVER_SIG);

    DBGWARN((" ... Backoff timer CALLBACK: (halting=%d, readDeficit=%d)", adapter->halting, adapter->readDeficit));
    ProcessWorkItemOrTimerCallback(adapter);
}


VOID ProcessWorkItemOrTimerCallback(ADAPTEREXT *adapter)
{
    BOOLEAN stillHaveReadDeficit;
    KIRQL oldIrql;
    
    if (adapter->initialized && !adapter->halting){
        /*
         *  Attempt to service any read deficit.
         *  If read packets are still not available, then this
         *  will NOT queue another workItem in TryReadUSB 
         *  because adapter->workItemOrTimerPending is STILL SET.
         */
        ServiceReadDeficit(adapter);

        #if DO_FULL_RESET
            if (adapter->needFullReset){
                /*
                 *  We can only do a full reset if we are not at DPC level,
                 *  so skip it if we are called from the timer DPC.
                 */
                if (KeGetCurrentIrql() <= APC_LEVEL){
                    AdapterFullResetAndRestore(adapter);
                }
            }
        #endif
    }

    KeAcquireSpinLock(&adapter->adapterSpinLock, &oldIrql);
    ASSERT(adapter->workItemOrTimerPending);
    adapter->workItemOrTimerPending = FALSE;
    KeSetEvent(&adapter->workItemOrTimerEvent, 0, FALSE);
    stillHaveReadDeficit = (adapter->readDeficit > 0);
    KeReleaseSpinLock(&adapter->adapterSpinLock, oldIrql);

    /*
     *  If we were not able to service the entire read deficit,
     *  (e.g. because no free packets have become available)
     *  then schedule another workItem so that we try again later.
     */
    if (stillHaveReadDeficit && !adapter->halting){
        QueueAdapterWorkItem(adapter);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rndis\usb8023\debugn.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    debugn.c


Author:

    ervinp

Environment:

    Kernel mode

Revision History:


--*/

#include <ndis.h>      
#include <ntddndis.h>  // defines OID's

#include "..\inc\rndis.h"
#include "..\inc\rndisapi.h"   

#include "usb8023.h"
#include "debug.h"

#if DBG

    PUCHAR DbgGetOidName(ULONG oid)
    {
        PCHAR oidName;

        switch (oid){

            #undef MAKECASE
            #define MAKECASE(oidx) case oidx: oidName = #oidx; break;

            MAKECASE(OID_GEN_SUPPORTED_LIST)
            MAKECASE(OID_GEN_HARDWARE_STATUS)
            MAKECASE(OID_GEN_MEDIA_SUPPORTED)
            MAKECASE(OID_GEN_MEDIA_IN_USE)
            MAKECASE(OID_GEN_MAXIMUM_LOOKAHEAD)
            MAKECASE(OID_GEN_MAXIMUM_FRAME_SIZE)
            MAKECASE(OID_GEN_LINK_SPEED)
            MAKECASE(OID_GEN_TRANSMIT_BUFFER_SPACE)
            MAKECASE(OID_GEN_RECEIVE_BUFFER_SPACE)
            MAKECASE(OID_GEN_TRANSMIT_BLOCK_SIZE)
            MAKECASE(OID_GEN_RECEIVE_BLOCK_SIZE)
            MAKECASE(OID_GEN_VENDOR_ID)
            MAKECASE(OID_GEN_VENDOR_DESCRIPTION)
            MAKECASE(OID_GEN_CURRENT_PACKET_FILTER)
            MAKECASE(OID_GEN_CURRENT_LOOKAHEAD)
            MAKECASE(OID_GEN_DRIVER_VERSION)
            MAKECASE(OID_GEN_MAXIMUM_TOTAL_SIZE)
            MAKECASE(OID_GEN_PROTOCOL_OPTIONS)
            MAKECASE(OID_GEN_MAC_OPTIONS)
            MAKECASE(OID_GEN_MEDIA_CONNECT_STATUS)
            MAKECASE(OID_GEN_MAXIMUM_SEND_PACKETS)
            MAKECASE(OID_GEN_VENDOR_DRIVER_VERSION)
            MAKECASE(OID_GEN_SUPPORTED_GUIDS)
            MAKECASE(OID_GEN_NETWORK_LAYER_ADDRESSES)
            MAKECASE(OID_GEN_TRANSPORT_HEADER_OFFSET)
            MAKECASE(OID_GEN_MEDIA_CAPABILITIES)
            MAKECASE(OID_GEN_PHYSICAL_MEDIUM)
            MAKECASE(OID_GEN_XMIT_OK)
            MAKECASE(OID_GEN_RCV_OK)
            MAKECASE(OID_GEN_XMIT_ERROR)
            MAKECASE(OID_GEN_RCV_ERROR)
            MAKECASE(OID_GEN_RCV_NO_BUFFER)
            MAKECASE(OID_GEN_DIRECTED_BYTES_XMIT)
            MAKECASE(OID_GEN_DIRECTED_FRAMES_XMIT)
            MAKECASE(OID_GEN_MULTICAST_BYTES_XMIT)
            MAKECASE(OID_GEN_MULTICAST_FRAMES_XMIT)
            MAKECASE(OID_GEN_BROADCAST_BYTES_XMIT)
            MAKECASE(OID_GEN_BROADCAST_FRAMES_XMIT)
            MAKECASE(OID_GEN_DIRECTED_BYTES_RCV)
            MAKECASE(OID_GEN_DIRECTED_FRAMES_RCV)
            MAKECASE(OID_GEN_MULTICAST_BYTES_RCV)
            MAKECASE(OID_GEN_MULTICAST_FRAMES_RCV)
            MAKECASE(OID_GEN_BROADCAST_BYTES_RCV)
            MAKECASE(OID_GEN_BROADCAST_FRAMES_RCV)
            MAKECASE(OID_GEN_RCV_CRC_ERROR)
            MAKECASE(OID_GEN_TRANSMIT_QUEUE_LENGTH)
            MAKECASE(OID_GEN_GET_TIME_CAPS)
            MAKECASE(OID_GEN_GET_NETCARD_TIME)
            MAKECASE(OID_GEN_NETCARD_LOAD)
            MAKECASE(OID_GEN_DEVICE_PROFILE)
            MAKECASE(OID_GEN_INIT_TIME_MS)
            MAKECASE(OID_GEN_RESET_COUNTS)
            MAKECASE(OID_GEN_MEDIA_SENSE_COUNTS)

            MAKECASE(OID_802_3_PERMANENT_ADDRESS)
            MAKECASE(OID_802_3_CURRENT_ADDRESS)
            MAKECASE(OID_802_3_MULTICAST_LIST)
            MAKECASE(OID_802_3_MAXIMUM_LIST_SIZE)
            MAKECASE(OID_802_3_MAC_OPTIONS)
            MAKECASE(OID_802_3_RCV_ERROR_ALIGNMENT)
            MAKECASE(OID_802_3_XMIT_ONE_COLLISION)
            MAKECASE(OID_802_3_XMIT_MORE_COLLISIONS)
            MAKECASE(OID_802_3_XMIT_DEFERRED)
            MAKECASE(OID_802_3_XMIT_MAX_COLLISIONS)
            MAKECASE(OID_802_3_RCV_OVERRUN)
            MAKECASE(OID_802_3_XMIT_UNDERRUN)
            MAKECASE(OID_802_3_XMIT_HEARTBEAT_FAILURE)
            MAKECASE(OID_802_3_XMIT_TIMES_CRS_LOST)
            MAKECASE(OID_802_3_XMIT_LATE_COLLISIONS)

            default: 
                oidName = "<** UNKNOWN OID **>";
                break;
        }

        return oidName;
    }


    void DbgStallExecution(ULONG usec)
    {
	    NdisStallExecution(usec);
    }

    ULONG DbgGetSystemTime_msec()
    {
	    LONGLONG systime_usec;
	    NdisGetCurrentSystemTime((PVOID)&systime_usec);  
	    return (ULONG)((*(PULONG)&systime_usec)/1000);
    }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rndis\usb8023\packet.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    packet.c


Author:

    ervinp

Environment:

    Kernel mode

Revision History:


--*/

#include <WDM.H>

#include <usbdi.h>
#include <usbdlib.h>
#include <usbioctl.h>

#include "usb8023.h"
#include "debug.h"


ULONG uniquePacketId = 0;


USBPACKET *NewPacket(ADAPTEREXT *adapter)
{
    USBPACKET *packet = AllocPool(sizeof(USBPACKET));
    if (packet){
        BOOLEAN allAllocsOk;

        packet->sig = DRIVER_SIG;
        packet->adapter = adapter;
        packet->cancelled = FALSE;

        InitializeListHead(&packet->listEntry);

        packet->irpPtr = IoAllocateIrp(adapter->nextDevObj->StackSize, FALSE);
        packet->urbPtr = AllocPool(sizeof(URB));

        packet->dataBuffer = AllocPool(PACKET_BUFFER_SIZE);
        packet->dataBufferMaxLength = PACKET_BUFFER_SIZE;
        if (packet->dataBuffer){
            packet->dataBufferMdl = IoAllocateMdl(packet->dataBuffer, PACKET_BUFFER_SIZE, FALSE, FALSE, NULL);
        }

        packet->dataBufferCurrentLength = 0;

        allAllocsOk = (packet->irpPtr && packet->urbPtr && packet->dataBuffer && packet->dataBufferMdl);

        if (allAllocsOk){
            packet->packetId = ++uniquePacketId;
        }
        else {

            if (packet->irpPtr) IoFreeIrp(packet->irpPtr);
            if (packet->urbPtr) FreePool(packet->urbPtr);
            if (packet->dataBuffer) FreePool(packet->dataBuffer);
            if (packet->dataBufferMdl) IoFreeMdl(packet->dataBufferMdl);

            FreePool(packet);
            packet = NULL;
        }
    }

    return packet;
}

VOID FreePacket(USBPACKET *packet)
{
    PIRP irp = packet->irpPtr;

    ASSERT(packet->sig == DRIVER_SIG);
    packet->sig = 0xDEADDEAD;

    ASSERT(!irp->CancelRoutine);
    IoFreeIrp(irp);

    FreePool(packet->urbPtr);

    ASSERT(packet->dataBufferMdl);
    IoFreeMdl(packet->dataBufferMdl);

    ASSERT(packet->dataBuffer);
    FreePool(packet->dataBuffer);

    FreePool(packet);
}

VOID EnqueueFreePacket(USBPACKET *packet)
{
    ADAPTEREXT *adapter = packet->adapter;
    KIRQL oldIrql;

    KeAcquireSpinLock(&adapter->adapterSpinLock, &oldIrql);

    ASSERT(IsListEmpty(&packet->listEntry));
    InsertTailList(&adapter->usbFreePacketPool, &packet->listEntry);

    adapter->numFreePackets++;
    ASSERT(adapter->numFreePackets <= USB_PACKET_POOL_SIZE);

    #if DBG
        packet->timeStamp = DbgGetSystemTime_msec();

        if (adapter->dbgInLowPacketStress){
            if (adapter->numFreePackets > USB_PACKET_POOL_SIZE/2){
                adapter->dbgInLowPacketStress = FALSE;
                DBGWARN(("recovered from low-packet stress"));
            }
        }
    #endif

    KeReleaseSpinLock(&adapter->adapterSpinLock, oldIrql);
}

USBPACKET *DequeueFreePacket(ADAPTEREXT *adapter)
{
    USBPACKET *packet;
    KIRQL oldIrql;

    KeAcquireSpinLock(&adapter->adapterSpinLock, &oldIrql);

    if (IsListEmpty(&adapter->usbFreePacketPool)){
        packet = NULL;
    }
    else {
        PLIST_ENTRY listEntry = RemoveHeadList(&adapter->usbFreePacketPool);
        packet = CONTAINING_RECORD(listEntry, USBPACKET, listEntry);
        ASSERT(packet->sig == DRIVER_SIG);
        InitializeListHead(&packet->listEntry);

        ASSERT(adapter->numFreePackets > 0);
        adapter->numFreePackets--;
    }

    #if DBG
        if (adapter->numFreePackets < USB_PACKET_POOL_SIZE/8){
            if (!adapter->dbgInLowPacketStress){
                /*
                 *  We are entering low-packet stress.
                 *  Repeated debug spew can slow the system and actually
                 *  keep the system from recovering the packets.  
                 *  So only spew a warning once.
                 */
                DBGWARN(("low on free packets (%d free, %d reads, %d writes, %d indicated)", adapter->numFreePackets, adapter->numActiveReadPackets, adapter->numActiveWritePackets, adapter->numIndicatedReadPackets));
                adapter->dbgInLowPacketStress = TRUE;
            }
        }
    #endif

    KeReleaseSpinLock(&adapter->adapterSpinLock, oldIrql);

    return packet;
}

VOID EnqueuePendingReadPacket(USBPACKET *packet)
{
    ADAPTEREXT *adapter = packet->adapter;
    KIRQL oldIrql;

    KeAcquireSpinLock(&adapter->adapterSpinLock, &oldIrql);

    ASSERT(IsListEmpty(&packet->listEntry));
    InsertTailList(&adapter->usbPendingReadPackets, &packet->listEntry);

    #if DBG
        packet->timeStamp = DbgGetSystemTime_msec();
    #endif

    adapter->numActiveReadPackets++;

    KeReleaseSpinLock(&adapter->adapterSpinLock, oldIrql);
}


/*
 *  DequeuePendingReadPacket
 *
 */
VOID DequeuePendingReadPacket(USBPACKET *packet)
{
    ADAPTEREXT *adapter = packet->adapter;
    KIRQL oldIrql;

    KeAcquireSpinLock(&adapter->adapterSpinLock, &oldIrql);

    ASSERT(!IsListEmpty(&adapter->usbPendingReadPackets));
    ASSERT(!IsListEmpty(&packet->listEntry));

    RemoveEntryList(&packet->listEntry);
    ASSERT(packet->sig == DRIVER_SIG);
    InitializeListHead(&packet->listEntry);

    ASSERT(adapter->numActiveReadPackets > 0);
    adapter->numActiveReadPackets--;

    KeReleaseSpinLock(&adapter->adapterSpinLock, oldIrql);
}


VOID EnqueuePendingWritePacket(USBPACKET *packet)
{
    ADAPTEREXT *adapter = packet->adapter;
    KIRQL oldIrql;

    KeAcquireSpinLock(&adapter->adapterSpinLock, &oldIrql);

    ASSERT(IsListEmpty(&packet->listEntry));
    InsertTailList(&adapter->usbPendingWritePackets, &packet->listEntry);

    adapter->numActiveWritePackets++;
    ASSERT(adapter->numActiveWritePackets <= USB_PACKET_POOL_SIZE);

    #if DBG
        packet->timeStamp = DbgGetSystemTime_msec();
    #endif

    KeReleaseSpinLock(&adapter->adapterSpinLock, oldIrql);
}


/*
 *  DequeuePendingWritePacket
 *
 *      Return either the indicated packet or the first packet in the pending queue.
 */
VOID DequeuePendingWritePacket(USBPACKET *packet)
{
    ADAPTEREXT *adapter = packet->adapter;
    KIRQL oldIrql;

    KeAcquireSpinLock(&adapter->adapterSpinLock, &oldIrql);

    ASSERT(!IsListEmpty(&adapter->usbPendingWritePackets));
    ASSERT(!IsListEmpty(&packet->listEntry));

    RemoveEntryList(&packet->listEntry);

    ASSERT(adapter->numActiveWritePackets > 0);
    adapter->numActiveWritePackets--;

    ASSERT(packet->sig == DRIVER_SIG);
    InitializeListHead(&packet->listEntry);

    KeReleaseSpinLock(&adapter->adapterSpinLock, oldIrql);
}


VOID EnqueueCompletedReadPacket(USBPACKET *packet)
{
    ADAPTEREXT *adapter = packet->adapter;
    KIRQL oldIrql;

    KeAcquireSpinLock(&adapter->adapterSpinLock, &oldIrql);

    ASSERT(IsListEmpty(&packet->listEntry));
    InsertTailList(&adapter->usbCompletedReadPackets, &packet->listEntry);

    #if DBG
        packet->timeStamp = DbgGetSystemTime_msec();
    #endif

    adapter->numIndicatedReadPackets++;

    KeReleaseSpinLock(&adapter->adapterSpinLock, oldIrql);
}

VOID DequeueCompletedReadPacket(USBPACKET *packet)
{
    ADAPTEREXT *adapter = packet->adapter;
    KIRQL oldIrql;
    PLIST_ENTRY listEntry;

    KeAcquireSpinLock(&adapter->adapterSpinLock, &oldIrql);

    ASSERT(!IsListEmpty(&adapter->usbCompletedReadPackets));
    ASSERT(!IsListEmpty(&packet->listEntry));

    RemoveEntryList(&packet->listEntry);
    InitializeListHead(&packet->listEntry);

    ASSERT(adapter->numIndicatedReadPackets > 0);
    adapter->numIndicatedReadPackets--;

    KeReleaseSpinLock(&adapter->adapterSpinLock, oldIrql);
}



VOID CancelAllPendingPackets(ADAPTEREXT *adapter)
{
    PLIST_ENTRY listEntry;
    USBPACKET *packet;
    PIRP irp;
    KIRQL oldIrql;

    ASSERT(KeGetCurrentIrql() <= APC_LEVEL);

    KeAcquireSpinLock(&adapter->adapterSpinLock, &oldIrql);

    /*
     *  Cancel all pending READs.
     */
    while (!IsListEmpty(&adapter->usbPendingReadPackets)){

        listEntry = RemoveHeadList(&adapter->usbPendingReadPackets);
        packet = CONTAINING_RECORD(listEntry, USBPACKET, listEntry);
        irp = packet->irpPtr;

        ASSERT(packet->sig == DRIVER_SIG);

        /*
         *  Leave the IRP in the list when we cancel it so that completion routine
         *  can move it to the free list.
         */
        InsertTailList(&adapter->usbPendingReadPackets, &packet->listEntry);

        KeInitializeEvent(&packet->cancelEvent, NotificationEvent, FALSE);

        ASSERT(!packet->cancelled);
        packet->cancelled = TRUE;

        KeReleaseSpinLock(&adapter->adapterSpinLock, oldIrql);

        DBGVERBOSE((" - cancelling pending read packet #%xh @ %ph, irp=%ph ...", packet->packetId, packet, irp));
        IoCancelIrp(irp);

        /*
         *  Wait for the completion routine to run and set the cancelEvent.
         *  By the time we get done waiting, the packet should be back in the free list. 
         */
        KeWaitForSingleObject(&packet->cancelEvent, Executive, KernelMode, FALSE, NULL);

        KeAcquireSpinLock(&adapter->adapterSpinLock, &oldIrql);
    }

    ASSERT(IsListEmpty(&adapter->usbPendingReadPackets));

    /*
     *  Cancel all pending WRITEs.
     */
    while (!IsListEmpty(&adapter->usbPendingWritePackets)){

        listEntry = RemoveHeadList(&adapter->usbPendingWritePackets);
        packet = CONTAINING_RECORD(listEntry, USBPACKET, listEntry);
        irp = packet->irpPtr;

        ASSERT(packet->sig == DRIVER_SIG);

        /*
         *  Leave the IRP in the list when we cancel it so that completion routine
         *  can move it to the free list.
         */
        InsertTailList(&adapter->usbPendingWritePackets, &packet->listEntry);

        KeInitializeEvent(&packet->cancelEvent, NotificationEvent, FALSE);

        ASSERT(!packet->cancelled);
        packet->cancelled = TRUE;

        KeReleaseSpinLock(&adapter->adapterSpinLock, oldIrql);

        DBGVERBOSE((" - cancelling pending write packet #%xh @ %ph, irp=%ph ...", packet->packetId, packet, irp));
        IoCancelIrp(irp);

        /*
         *  Wait for the completion routine to run and set the cancelEvent.
         *  By the time we get done waiting, the packet should be back in the free list. 
         */
        KeWaitForSingleObject(&packet->cancelEvent, Executive, KernelMode, FALSE, NULL);

        KeAcquireSpinLock(&adapter->adapterSpinLock, &oldIrql);
    }

    ASSERT(IsListEmpty(&adapter->usbPendingWritePackets));


    /*
     *  Cancel the read on the NOTIFY pipe.
     */
    if (adapter->notifyPipeHandle){

        /*
         *  Make sure we've actually sent the notify irp before trying
         *  to cancel it; otherwise, we hang forever waiting for it to complete.
         */
        if (adapter->initialized){
            if (adapter->notifyStopped){
                /*
                 *  The notify irp has already stopped looping because it returned with error
                 *  in NotificationCompletion.  Don't cancel it because we'll hang forever
                 *  waiting for it to complete.
                 */
                DBGVERBOSE(("CancelAllPendingPackets: notify irp already stopped, no need to cancel"));
            }
            else {
                KeInitializeEvent(&adapter->notifyCancelEvent, NotificationEvent, FALSE);
                adapter->cancellingNotify = TRUE;

                KeReleaseSpinLock(&adapter->adapterSpinLock, oldIrql);
                DBGVERBOSE((" - cancelling notify irp = %ph ...", adapter->notifyIrpPtr));
                IoCancelIrp(adapter->notifyIrpPtr);
                KeWaitForSingleObject(&adapter->notifyCancelEvent, Executive, KernelMode, FALSE, NULL);
                KeAcquireSpinLock(&adapter->adapterSpinLock, &oldIrql);

                adapter->cancellingNotify = FALSE;
            }
        }
    }

    adapter->readDeficit = 0;
    
    KeReleaseSpinLock(&adapter->adapterSpinLock, oldIrql);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rndis\usb8023\recovery.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    recovery.c


Author:

    ervinp

Environment:

    Kernel mode

Revision History:


--*/

#include <WDM.H>

#include <usbdi.h>
#include <usbdlib.h>
#include <usbioctl.h>

#include "usb8023.h"
#include "debug.h"


/*
 *  USB- and WDM- specific prototypes (won't compile in common header)
 */
NTSTATUS CallDriverSync(PDEVICE_OBJECT devObj, PIRP irp);


/*
 *  ServiceReadDeficit
 *
 *      If we "owe" the BULK IN pipe some read packets, send them down now.
 */
VOID ServiceReadDeficit(ADAPTEREXT *adapter)
{
    ULONG numReadsToTry;
    KIRQL oldIrql;

    ASSERT(adapter->sig == DRIVER_SIG);

    /*
     *  If there is a read deficit, try to fulfill it now.
     *  Careful not to get into an infinite loop, since TryReadUSB
     *  will re-increment readDeficit if there are still no packets.
     */
    KeAcquireSpinLock(&adapter->adapterSpinLock, &oldIrql);
    ASSERT(adapter->readDeficit <= NUM_READ_PACKETS);
    numReadsToTry = adapter->readDeficit;
    while ((adapter->readDeficit > 0) && (numReadsToTry > 0) && !adapter->halting){
        DBGWARN(("RndisReturnMessageHandler attempting to fill read DEFICIT (=%d)", adapter->readDeficit));

        adapter->readDeficit--;
        numReadsToTry--;

        KeReleaseSpinLock(&adapter->adapterSpinLock, oldIrql);
        TryReadUSB(adapter);
        KeAcquireSpinLock(&adapter->adapterSpinLock, &oldIrql);
    }
    KeReleaseSpinLock(&adapter->adapterSpinLock, oldIrql);
}


#if DO_FULL_RESET

    VOID AdapterFullResetAndRestore(ADAPTEREXT *adapter)
    {
        NTSTATUS status;

        DBGWARN(("AdapterFullResetAndRestore")); 

        adapter->numHardResets++;
        adapter->needFullReset = FALSE;

        if (adapter->halting){
            DBGWARN(("AdapterFullResetAndRestore - skipping since device is halting"));
        }
        else {
            ULONG portStatus;

            ASSERT(!adapter->resetting);
            adapter->resetting = TRUE;

            status = GetUSBPortStatus(adapter, &portStatus);
            if (NT_SUCCESS(status) && (portStatus & USBD_PORT_CONNECTED)){

                CancelAllPendingPackets(adapter);
           
                // RNDIS Halt seems to put the device out of whack until power cycle
                // SimulateRNDISHalt(adapter);

                AbortPipe(adapter, adapter->readPipeHandle);
                ResetPipe(adapter, adapter->readPipeHandle);

                AbortPipe(adapter, adapter->writePipeHandle);
                ResetPipe(adapter, adapter->writePipeHandle);

                if (adapter->notifyPipeHandle){
                    AbortPipe(adapter, adapter->notifyPipeHandle);
                    ResetPipe(adapter, adapter->notifyPipeHandle);
                }

                /*
                 *  Now, bring the adapter back to the run state 
                 *  if it was previously.
                 */
                if (adapter->initialized){

                    /*
                     *  Simulate RNDIS messages for INIT and set-packet-filter.
                     *  These simulation functions need to read and throw away
                     *  the response on the notify and control pipes, so do
                     *  this before starting the read loop on the notify pipe.
                     */
                    status = SimulateRNDISInit(adapter);
                    if (NT_SUCCESS(status)){
                        SimulateRNDISSetPacketFilter(adapter);
                        SimulateRNDISSetCurrentAddress(adapter);

                        /*
                         *  Restart the read loops.
                         */
                        if (adapter->notifyPipeHandle){
                            SubmitNotificationRead(adapter, FALSE);
                        }
                        StartUSBReadLoop(adapter);
                    }
                    else {
                        adapter->initialized = FALSE;
                    }
                }
            }
            else {
                DBGWARN(("AdapterFullResetAndRestore - skipping since device is no longer connected"));
            }

            adapter->resetting = FALSE;
        }

    }


    NTSTATUS GetUSBPortStatus(ADAPTEREXT *adapter, PULONG portStatus)
    {
        NTSTATUS status;
        PIRP irp;

        *portStatus = 0;

        irp = IoAllocateIrp(adapter->nextDevObj->StackSize, FALSE);
        if (irp){
            PIO_STACK_LOCATION nextSp;

            nextSp = IoGetNextIrpStackLocation(irp);
	        nextSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
	        nextSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_GET_PORT_STATUS;
            nextSp->Parameters.Others.Argument1 = portStatus;
        
            status = CallDriverSync(adapter->nextDevObj, irp);

            IoFreeIrp(irp);
        }
        else {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }

        return status;
    }


    NTSTATUS AbortPipe(ADAPTEREXT *adapter, PVOID pipeHandle)
    {
        NTSTATUS status;
        PIRP irp;
        ULONG portStatus;

        status = GetUSBPortStatus(adapter, &portStatus);
        if (NT_SUCCESS(status) && (portStatus & USBD_PORT_CONNECTED)){

            irp = IoAllocateIrp(adapter->nextDevObj->StackSize, FALSE);
            if (irp){
                PIO_STACK_LOCATION nextSp;
                URB urb = {0};

                urb.UrbHeader.Length   = sizeof (struct _URB_PIPE_REQUEST);
                urb.UrbHeader.Function = URB_FUNCTION_ABORT_PIPE;
                urb.UrbPipeRequest.PipeHandle = pipeHandle;

                nextSp = IoGetNextIrpStackLocation(irp);
	            nextSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
	            nextSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;
                nextSp->Parameters.Others.Argument1 = &urb;

                status = CallDriverSync(adapter->nextDevObj, irp);
                if (NT_SUCCESS(status)){
                }
                else {
                    DBGWARN(("AbortPipe failed with %xh (urb status %xh).", status, urb.UrbHeader.Status));
                }

                IoFreeIrp(irp);
            }
            else {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
        else {
            DBGWARN(("AbortPipe - skipping abort because device not connected (status=%xh)", status));
            status = STATUS_SUCCESS;
        }

        return status;
    }


    NTSTATUS ResetPipe(ADAPTEREXT *adapter, PVOID pipeHandle)
    {
        NTSTATUS status;
        PIRP irp;
        ULONG portStatus;

        status = GetUSBPortStatus(adapter, &portStatus);
        if (NT_SUCCESS(status) && (portStatus & USBD_PORT_CONNECTED)){

            irp = IoAllocateIrp(adapter->nextDevObj->StackSize, FALSE);
            if (irp){
                PIO_STACK_LOCATION nextSp;
                URB urb = {0};

                urb.UrbHeader.Length   = sizeof (struct _URB_PIPE_REQUEST);
                urb.UrbHeader.Function = URB_FUNCTION_RESET_PIPE;
                urb.UrbPipeRequest.PipeHandle = pipeHandle;

                nextSp = IoGetNextIrpStackLocation(irp);
	            nextSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
	            nextSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;
                nextSp->Parameters.Others.Argument1 = &urb;

                status = CallDriverSync(adapter->nextDevObj, irp);
                if (NT_SUCCESS(status)){
                }
                else {
                    DBGWARN(("ResetPipe failed with %xh (urb status %xh).", status, urb.UrbHeader.Status));
                }

                IoFreeIrp(irp);
            }
            else {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
        else {
            DBGWARN(("ResetPipe - skipping reset because device not connected (status=%xh)", status));
            status = STATUS_SUCCESS;
        }

        return status;
    }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\sources.inc ===
CM_BUILD_ROOT=$(CM_ROOT)\build\$(_OBJ_DIR)

INCLUDES=$(CM_ROOT)\inc;\
    $(CM_ROOT)\common\inc;\
    $(CM_ROOT)\common\source;\
    $(CM_ROOT)\common\strings;\
    $(CM_ROOT)\common\rc

!if !$(FREEBUILD)
C_DEFINES=$(C_DEFINES) -DDEBUG
!endif

!if "$(DEBUG_MEM)" == "1"
DEBUG_MEM=1
C_DEFINES=$(C_DEFINES) -DDEBUG_MEM
!endif

!if "$(EMULATE9x)" == "1"
C_DEFINES=$(C_DEFINES) -DEMULATE9x
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rndis\usb8023\util.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    util.c


Author:

    ervinp

Environment:

    Kernel mode

Revision History:


--*/

#include <WDM.H>

#include <usbdi.h>
#include <usbdlib.h>
#include <usbioctl.h>

#include "usb8023.h"
#include "debug.h"


#if DBG_WRAP_MEMORY
    /*
     *  Memory Allocation:
     *  To catch memory leaks, we will keep a count and list of all allocated memory
     *  and then assert that the memory is all freed when we exit.
     */
    ULONG dbgTotalMemCount = 0;
    LIST_ENTRY dbgAllMemoryList;
    #define ALIGNBYTES 32

    struct memHeader {
        PUCHAR actualPtr;
        ULONG actualSize;
        LIST_ENTRY listEntry;
    };
#endif


PVOID AllocPool(ULONG size)
/*
 *
 *  Return a 32-byte aligned pointer.
 *  Place a guard word at the end of the buffer.
 *  Cache the actual allocated pointer and size before the returned pointer.
 *
 */
{
    PUCHAR resultPtr;
    
    #if DBG_WRAP_MEMORY 
        {
            PUCHAR actualPtr = ExAllocatePoolWithTag(  
                                    NonPagedPool, 
                                    size+ALIGNBYTES+sizeof(struct memHeader)+sizeof(ULONG), 
                                    DRIVER_SIG);
            if (actualPtr){
                struct memHeader *memHdr;
                KIRQL oldIrql;

                RtlZeroMemory(actualPtr, size+32+sizeof(struct memHeader));
                *(PULONG)(actualPtr+size+ALIGNBYTES+sizeof(struct memHeader)) = GUARD_WORD;

                /*
                 *  ExAllocatePoolWithTag returns the 32-byte aligned pointer
                 *  from ExAllocatePool plus 8 bytes for the tag and kernel tracking info
                 *  (but don't depend on this).
                 *  Align the pointer we return, and cache away the actual pointer to free and
                 *  the buffer size.
                 */
                // ASSERT(((ULONG_PTR)actualPtr & 0x1F) == 0x08); NT only
                resultPtr = (PUCHAR)((ULONG_PTR)(actualPtr+ALIGNBYTES+sizeof(struct memHeader)) & ~(ALIGNBYTES-1));

                memHdr = (struct memHeader *)(resultPtr-sizeof(struct memHeader));
                memHdr->actualPtr = actualPtr;
                memHdr->actualSize = size+ALIGNBYTES+sizeof(struct memHeader)+sizeof(ULONG);

                dbgTotalMemCount += memHdr->actualSize;

                KeAcquireSpinLock(&globalSpinLock, &oldIrql);
                InsertTailList(&dbgAllMemoryList, &memHdr->listEntry);
                KeReleaseSpinLock(&globalSpinLock, oldIrql);
            }
            else {
                resultPtr = NULL;
            }
        }
    #else
        resultPtr = ExAllocatePoolWithTag(NonPagedPool, size, DRIVER_SIG);
        if (resultPtr){
            RtlZeroMemory(resultPtr, size);
        }
    #endif

    return resultPtr;
}

VOID FreePool(PVOID ptr)
{
    #if DBG_WRAP_MEMORY 
        {
            KIRQL oldIrql;
            struct memHeader *memHdr;

            ASSERT(ptr);

            memHdr = (struct memHeader *)((PUCHAR)ptr - sizeof(struct memHeader));
            ASSERT(*(PULONG)(memHdr->actualPtr+memHdr->actualSize-sizeof(ULONG)) == GUARD_WORD);
            ASSERT(dbgTotalMemCount >= memHdr->actualSize);

            KeAcquireSpinLock(&globalSpinLock, &oldIrql);
            ASSERT(!IsListEmpty(&dbgAllMemoryList));
            RemoveEntryList(&memHdr->listEntry);
            KeReleaseSpinLock(&globalSpinLock, oldIrql);

            dbgTotalMemCount -= memHdr->actualSize;
            ExFreePool(memHdr->actualPtr);
        }
    #else
        ExFreePool(ptr);
    #endif
}


/*
 ********************************************************************************
 *  MemDup
 ********************************************************************************
 *
 *  Return a fresh copy of the argument.
 *
 */
PVOID MemDup(PVOID dataPtr, ULONG length)
{
    PVOID newPtr;

    newPtr = (PVOID)AllocPool(length); 
    if (newPtr){
        RtlCopyMemory(newPtr, dataPtr, length);
    }

    ASSERT(newPtr);
    return newPtr;
}


VOID DelayMs(ULONG numMillisec)
{
    LARGE_INTEGER deltaTime;

    /*
     *  Get delay time into relative units of 100 nsec.
     */
    deltaTime.QuadPart = -10000 * numMillisec;
    KeDelayExecutionThread(KernelMode, FALSE, &deltaTime);
}


/*
 *  AllocateCommonResources
 *
 *      Allocate adapter resources that are common to RNDIS and NDIS interfaces
 *  but which for some reason can't be allocated by NewAdapter().
 *  These resources will be freed by FreeAdapter().
 */
BOOLEAN AllocateCommonResources(ADAPTEREXT *adapter)
{
    BOOLEAN result = TRUE;
    ULONG i;
                            
    /*
     *  Build the packet pool for this adapter.
     */
    for (i = 0; i < USB_PACKET_POOL_SIZE; i++){
        USBPACKET *packet = NewPacket(adapter);
        if (packet){
            EnqueueFreePacket(packet);
        }
        else {
            ASSERT(packet);
            result = FALSE;
            break;
        }
    }

    ASSERT(result);
    return result;
}



BOOLEAN GetRegValue(ADAPTEREXT *adapter, PWCHAR wValueName, OUT PULONG valuePtr, BOOLEAN hwKey)
{
    BOOLEAN success = FALSE;
    NTSTATUS status;
    HANDLE hRegDevice;
    KIRQL oldIrql;

    *valuePtr = 0;

    status = IoOpenDeviceRegistryKey(   adapter->physDevObj, 
                                        hwKey ? PLUGPLAY_REGKEY_DEVICE : PLUGPLAY_REGKEY_DRIVER, 
                                        KEY_READ, 
                                        &hRegDevice);
    if (NT_SUCCESS(status)){
        UNICODE_STRING uValueName;
        PKEY_VALUE_FULL_INFORMATION keyValueInfo;
        ULONG keyValueTotalSize, actualLength;

        RtlInitUnicodeString(&uValueName, wValueName); 
        keyValueTotalSize = sizeof(KEY_VALUE_FULL_INFORMATION) +
                            uValueName.Length*sizeof(WCHAR) +
                            sizeof(ULONG);
        keyValueInfo = AllocPool(keyValueTotalSize);
        if (keyValueInfo){
            status = ZwQueryValueKey(   hRegDevice,
                                        &uValueName,
                                        KeyValueFullInformation,
                                        keyValueInfo,
                                        keyValueTotalSize,
                                        &actualLength); 
            if (NT_SUCCESS(status)){
                ASSERT(keyValueInfo->Type == REG_DWORD);
                ASSERT(keyValueInfo->DataLength == sizeof(ULONG));
                *valuePtr = *((PULONG)(((PCHAR)keyValueInfo)+keyValueInfo->DataOffset));
                success = TRUE;
            }

            FreePool(keyValueInfo);
        }
        else {
            ASSERT(keyValueInfo);
        }

        ZwClose(hRegDevice);
    }
    else {
        DBGWARN(("IoOpenDeviceRegistryKey failed with %xh.", status));
    }

    return success;
}


BOOLEAN SetRegValue(ADAPTEREXT *adapter, PWCHAR wValueName, ULONG newValue, BOOLEAN hwKey)
{
    BOOLEAN success = FALSE;
    NTSTATUS status;
    HANDLE hRegDevice;
    KIRQL oldIrql;

    status = IoOpenDeviceRegistryKey(   adapter->physDevObj, 
                                        hwKey ? PLUGPLAY_REGKEY_DEVICE : PLUGPLAY_REGKEY_DRIVER, 
                                        KEY_READ, 
                                        &hRegDevice);
    if (NT_SUCCESS(status)){
        UNICODE_STRING uValueName;
        PKEY_VALUE_FULL_INFORMATION keyValueInfo;
        ULONG keyValueTotalSize, actualLength;

        RtlInitUnicodeString(&uValueName, wValueName); 
        keyValueTotalSize = sizeof(KEY_VALUE_FULL_INFORMATION) +
                            uValueName.Length*sizeof(WCHAR) +
                            sizeof(ULONG);
        keyValueInfo = AllocPool(keyValueTotalSize);
        if (keyValueInfo){
            status = ZwSetValueKey( hRegDevice,
                                    &uValueName,
                                    0,  
                                    REG_DWORD,
                                    &newValue,
                                    sizeof(ULONG)); 
            if (NT_SUCCESS(status)){
                success = TRUE;
            }
            else {
                DBGERR(("SetRegValue: ZwSetValueKey failed with %xh.", status));
            }

            FreePool(keyValueInfo);
        }
        else {
            ASSERT(keyValueInfo);
        }

        ZwClose(hRegDevice);
    }
    else {
        DBGOUT(("IoOpenDeviceRegistryKey failed with %xh.", status));
    }

    return success;
}


/*
 *  MyInitializeMdl
 *
 *      Wrapper for MmInitializeMdl, which doesn't compile under NDIS headers.
 */
VOID MyInitializeMdl(PMDL mdl, PVOID buf, ULONG bufLen)
{
    MmInitializeMdl(mdl, buf, bufLen);
    MmBuildMdlForNonPagedPool(mdl);
}


PVOID GetSystemAddressForMdlSafe(PMDL MdlAddress)
{
    PVOID buf;

    /*
     *  Note:  we could use MmGetSystemAddressSafe here
     *         but not for Win98SE
     */

    if (MdlAddress){
        CSHORT oldFlags = MdlAddress->MdlFlags;
        MdlAddress->MdlFlags |= MDL_MAPPING_CAN_FAIL;
        buf = MmGetSystemAddressForMdl(MdlAddress);
        MdlAddress->MdlFlags &= (oldFlags | ~MDL_MAPPING_CAN_FAIL);
    }
    else {
        ASSERT(MdlAddress);
        buf = NULL;
    }

    return buf;
}


ULONG CopyMdlToBuffer(PUCHAR buf, PMDL mdl, ULONG bufLen)
{
    ULONG totalLen = 0;

    while (mdl){
        ULONG thisBufLen = MmGetMdlByteCount(mdl);
        if (totalLen+thisBufLen <= bufLen){
            PVOID thisBuf = GetSystemAddressForMdlSafe(mdl);
            if (thisBuf){
                RtlCopyMemory(buf+totalLen, thisBuf, thisBufLen);
                totalLen += thisBufLen;
                mdl = mdl->Next;
            }
            else {
                break;
            }
        }
        else {
            DBGERR(("CopyMdlToBuffer: mdl @ %ph is too large for buffer size %xh.", mdl, bufLen));
            break;
        }
    }

    return totalLen;
}

ULONG GetMdlListTotalByteCount(PMDL mdl)
{
    ULONG totalBytes = 0;

    do {
        totalBytes += MmGetMdlByteCount(mdl);
        mdl = mdl->Next;
    } while (mdl);

    return totalBytes;
}

VOID ByteSwap(PUCHAR buf, ULONG len)
{
    while (len >= 2){
        UCHAR tmp = buf[0];
        buf[0] = buf[1];
        buf[1] = tmp;
        buf += 2;
        len -= 2;
    }
}


#if SPECIAL_WIN98SE_BUILD

    PIO_WORKITEM MyIoAllocateWorkItem(PDEVICE_OBJECT DeviceObject)
    {
        PIO_WORKITEM ioWorkItem;
        PWORK_QUEUE_ITEM exWorkItem;

        ioWorkItem = ExAllocatePool(NonPagedPool, sizeof(IO_WORKITEM));
        if (ioWorkItem) {
            ioWorkItem->DeviceObject = DeviceObject;
            exWorkItem = &ioWorkItem->WorkItem;
            #if DBG
                ioWorkItem->Size = sizeof(IO_WORKITEM);
            #endif
            ExInitializeWorkItem(exWorkItem, MyIopProcessWorkItem, ioWorkItem);
        }

        return ioWorkItem;
    }

    VOID MyIoFreeWorkItem(PIO_WORKITEM IoWorkItem)
    {
        ASSERT(IoWorkItem->Size == sizeof(IO_WORKITEM));
        ExFreePool( IoWorkItem );
    }

    VOID MyIoQueueWorkItem(IN PIO_WORKITEM IoWorkItem, IN PIO_WORKITEM_ROUTINE WorkerRoutine, IN WORK_QUEUE_TYPE QueueType, IN PVOID Context)
    {
        PWORK_QUEUE_ITEM exWorkItem;

        ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
        ASSERT(IoWorkItem->Size == sizeof(IO_WORKITEM));

        ObReferenceObject( IoWorkItem->DeviceObject );

        IoWorkItem->Routine = WorkerRoutine;
        IoWorkItem->Context = Context;

        exWorkItem = &IoWorkItem->WorkItem;
        ExQueueWorkItem( exWorkItem, QueueType );
    }


    VOID MyIopProcessWorkItem(IN PVOID Parameter)
    {
        PIO_WORKITEM ioWorkItem;
        PDEVICE_OBJECT deviceObject;

        PAGED_CODE();

        ioWorkItem = (PIO_WORKITEM)Parameter;
        deviceObject = ioWorkItem->DeviceObject;
        ioWorkItem->Routine(deviceObject, ioWorkItem->Context);
        ObDereferenceObject(deviceObject);
    }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rndis\usb8023\usb8023.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    usb8023.h


Author:

    ervinp

Environment:

    Kernel mode

Revision History:


--*/


/*
 *  If this flag is defined TRUE, then when an endpoint on the device stalls, 
 *  we will do a full USB port reset
 *  and then restore the device to a running state.
 *  Otherwise, we just send the RNDIS Reset message to the control pipe.
 */
#define DO_FULL_RESET TRUE 



#define DRIVER_SIG '208U'
#define GUARD_WORD 'draG'

#define  NUM_BYTES_PROTOCOL_RESERVED_SECTION    16
#define DEFAULT_MULTICAST_SIZE                  16


/*
 *  Total number of our irp/urb packets for sending/receiving 
 *  ethernet frames to/from the device.
 */
#define USB_PACKET_POOL_SIZE                    32

#define PACKET_BUFFER_SIZE                      0x4000  

/*
 *  The USB host controller can typically schedule 2 URBs at a time.
 *  To keep the hardware busy, keep twice this many read URBs in the pipe.
 */
#define NUM_READ_PACKETS                        (2*2)

/*
 *  - Ethernet 14-byte Header
 */
#define ETHERNET_ADDRESS_LENGTH  6
#pragma pack(1)
    typedef struct {
        UCHAR       Destination[ETHERNET_ADDRESS_LENGTH];
        UCHAR       Source[ETHERNET_ADDRESS_LENGTH];
        USHORT      TypeLength;     // note: length appears as big-endian in packet.
    } ETHERNET_HEADER;
#pragma pack()

#define MINIMUM_ETHERNET_PACKET_SIZE    60    // from e100bex driver
#define MAXIMUM_ETHERNET_PACKET_SIZE    (1500+sizeof(ETHERNET_HEADER))  // 1514 == 0x05EA

/*
 *  This is the size of a read on the control pipe.
 *  It needs to be large enough for the init-complete message and response to
 *  OID_GEN_SUPPORTED_LIST.
 */
#define MAXIMUM_DEVICE_MESSAGE_SIZE     0x400



typedef struct {

    ULONG sig;

    LIST_ENTRY adaptersListEntry;
    KSPIN_LOCK adapterSpinLock;  

    PDEVICE_OBJECT physDevObj;
    PDEVICE_OBJECT nextDevObj;

    /*
     *  All USB structures and handles must be declared as neutral types in order
     *  to compile with the NDIS/RNDIS sources.
     */
    PVOID deviceDesc;                       // PUSB_DEVICE_DESCRIPTOR
    PVOID configDesc;                       // PUSB_CONFIGURATION_DESCRIPTOR
    PVOID configHandle;                     // USBD_CONFIGURATION_HANDLE    
    PVOID interfaceInfo;                    // PUSBD_INTERFACE_INFORMATION
    PVOID interfaceInfoMaster;              // PUSBD_INTERFACE_INFORMATION

    BOOLEAN initialized;
    BOOLEAN halting;
    BOOLEAN resetting;
    BOOLEAN gotPacketFilterIndication;

    PVOID readPipeHandle;                   // USBD_PIPE_HANDLE
    PVOID writePipeHandle;                  // USBD_PIPE_HANDLE
    PVOID notifyPipeHandle;                 // USBD_PIPE_HANDLE

    ULONG readPipeLength;
    ULONG writePipeLength;
    ULONG notifyPipeLength;
   
    UCHAR readPipeEndpointAddr;
    UCHAR writePipeEndpointAddr;
    UCHAR notifyPipeEndpointAddr;

    LIST_ENTRY usbFreePacketPool;           // free packet pool
    LIST_ENTRY usbPendingReadPackets;       // reads down in the USB stack
    LIST_ENTRY usbPendingWritePackets;      // writes down in the usb stack
    LIST_ENTRY usbCompletedReadPackets;     // completed read buffers being indicated to NDIS
    
    /*
     *  Keep statistics on packet states for throttling, etc.
     *  Some fields are used only to provide history for debugging, 
     *  and we want these for retail as well as debug version.
     */
    ULONG numFreePackets;
    ULONG numActiveReadPackets;
    ULONG numActiveWritePackets;
    ULONG numIndicatedReadPackets;
    ULONG numHardResets;
    ULONG numSoftResets;
    ULONG numConsecutiveReadFailures;

    PVOID notifyIrpPtr;
    PVOID notifyUrbPtr;
    PUCHAR notifyBuffer;
    ULONG notifyBufferCurrentLength;
    BOOLEAN notifyStopped;
    BOOLEAN cancellingNotify;
    KEVENT notifyCancelEvent;

    
    /*
     *  All NDIS handles must be declared as neutral types
     *  in order to compile with the USB sources.
     */
    PVOID ndisAdapterHandle;
    PVOID rndisAdapterHandle;   // RNDIS_HANDLE

    ULONG rndismpMajorVersion;
    ULONG rndismpMinorVersion;
    ULONG rndismpMaxTransferSize;
    ULONG currentPacketFilter;
    UCHAR MAC_Address[ETHERNET_ADDRESS_LENGTH];

    ULONG dbgCurrentOid;
    ULONG readDeficit;

    PIO_WORKITEM ioWorkItem;
    BOOLEAN workItemOrTimerPending;
    KEVENT workItemOrTimerEvent;
    KTIMER backoffTimer;
    KDPC backoffTimerDPC;

    ULONG readReentrancyCount;  // used to prevent infinite loop in ReadPipeCompletion()
    
    #if DO_FULL_RESET
        BOOLEAN needFullReset;
    #endif

    #if DBG
        BOOLEAN dbgInLowPacketStress;
    #endif

    #ifdef RAW_TEST
    BOOLEAN rawTest;
    #endif

} ADAPTEREXT;


typedef struct {

    ULONG sig;
    LIST_ENTRY listEntry;

    /*
     *  All WDM and USB structures must be declared as neutral types 
     *  in order to compile with the NDIS/RNDIS sources.
     */
    PVOID irpPtr;                  // PIRP
    PVOID urbPtr;                  // PURB

    PUCHAR dataBuffer;                 
    ULONG dataBufferMaxLength;         // Actual size of the data buffer
    ULONG dataBufferCurrentLength;     // Length of data currently in buffer
    PMDL dataBufferMdl;                 // MDL for this packet's dataBuffer

    PMDL ndisSendPktMdl;               // Pointer to NDIS' MDL for a packet being sent. 

    ULONG packetId;
    ADAPTEREXT *adapter;

    BOOLEAN cancelled;
    KEVENT cancelEvent;

    PVOID rndisMessageHandle;       // RNDIS_HANDLE

    #ifdef RAW_TEST
    BOOLEAN dataPacket;
    ULONG rcvDataOffset;
    ULONG rcvByteCount;
    #endif

    #if DBG
        ULONG timeStamp;                // Time placed in current queue.
    #endif

} USBPACKET;




#define USB_DEVICE_CLASS_CDC                                    0x02
#define USB_DEVICE_CLASS_DATA                                   0x0A


/*
 *  Formats of CDC functional descriptors
 */
#pragma pack(1)
    struct cdcFunctionDescriptor_CommonHeader {
        UCHAR bFunctionLength;
        UCHAR bDescriptorType;
        UCHAR bDescriptorSubtype;
        // ...
    };
    struct cdcFunctionDescriptor_Ethernet {
        UCHAR bFunctionLength;
        UCHAR bDescriptorType;
        UCHAR bDescriptorSubtype;
        UCHAR iMACAddress;          // string index of MAC Address string
        ULONG bmEthernetStatistics;
        USHORT wMaxSegmentSize;
        USHORT wNumberMCFilters;
        UCHAR bNumberPowerFilters;
    };
#pragma pack()

#define CDC_REQUEST_SET_ETHERNET_PACKET_FILTER                  0x43

#define CDC_ETHERNET_PACKET_TYPE_PROMISCUOUS                    (1 << 0)
#define CDC_ETHERNET_PACKET_TYPE_ALL_MULTICAST                  (1 << 1)
#define CDC_ETHERNET_PACKET_TYPE_DIRECTED                       (1 << 2)
#define CDC_ETHERNET_PACKET_TYPE_BROADCAST                      (1 << 3)
#define CDC_ETHERNET_PACKET_TYPE_MULTICAST_ENUMERATED           (1 << 4)

enum notifyRequestType {
        CDC_NOTIFICATION_NETWORK_CONNECTION          = 0x00,
        CDC_NOTIFICATION_RESPONSE_AVAILABLE          = 0x01,
        CDC_NOTIFICATION_AUX_JACK_HOOK_STATE         = 0x08,
        CDC_NOTIFICATION_RING_DETECT                 = 0x09,
        CDC_NOTIFICATION_SERIAL_STATE                = 0x20,
        CDC_NOTIFICATION_CALL_STATE_CHANGE           = 0x28,
        CDC_NOTIFICATION_LINE_STATE_CHANGE           = 0x29,
        CDC_NOTIFICATION_CONNECTION_SPEED_CHANGE     = 0x2A
    };

#define CDC_RNDIS_NOTIFICATION              0xA1
#define CDC_RNDIS_RESPONSE_AVAILABLE        0x01

#pragma pack(1)
    struct cdcNotification_CommonHeader {
        UCHAR bmRequestType;
        UCHAR bNotification;
        USHORT wValue;
        USHORT wIndex;
        USHORT wLength;
        UCHAR data[0];
    };
#pragma pack()



/*
 *
 ****************************************************************************
 */



/*
 ****************************************************************************
 *
 *  Native RNDIS codes
 *
 */

#define NATIVE_RNDIS_SEND_ENCAPSULATED_COMMAND      0x00
#define NATIVE_RNDIS_GET_ENCAPSULATED_RESPONSE      0x01

#define NATIVE_RNDIS_RESPONSE_AVAILABLE             0x01

/*
 *
 ****************************************************************************
 */




#define MAX(a, b) (((a) >= (b)) ? (a) : (b))
#define MIN(a, b) (((a) <= (b)) ? (a) : (b))

#ifndef EXCEPTION_NONCONTINUABLE_EXCEPTION
    // from winbase.h
    #define EXCEPTION_NONCONTINUABLE_EXCEPTION  STATUS_NONCONTINUABLE_EXCEPTION
#endif

// from ntos\inc\ex.h
NTKERNELAPI VOID NTAPI ExRaiseException(PEXCEPTION_RECORD ExceptionRecord);

/*
 *  Function prototypes
 */
NTSTATUS DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath);
ADAPTEREXT *NewAdapter(PDEVICE_OBJECT pdo);
VOID FreeAdapter(ADAPTEREXT *adapter);
VOID EnqueueAdapter(ADAPTEREXT *adapter);
VOID DequeueAdapter(ADAPTEREXT *adapter);
VOID HaltAdapter(ADAPTEREXT *adapter);
PVOID AllocPool(ULONG size);
VOID FreePool(PVOID ptr);
PVOID MemDup(PVOID dataPtr, ULONG length);
VOID DelayMs(ULONG numMillisec);
BOOLEAN GetRegValue(ADAPTEREXT *adapter, PWCHAR wValueName, OUT PULONG valuePtr, BOOLEAN hwKey);
BOOLEAN SetRegValue(ADAPTEREXT *adapter, PWCHAR wValueName, ULONG newValue, BOOLEAN hwKey);
VOID ByteSwap(PUCHAR buf, ULONG len);
BOOLEAN AllocateCommonResources(ADAPTEREXT *adapter);
VOID MyInitializeMdl(PMDL mdl, PVOID buf, ULONG bufLen);
PVOID GetSystemAddressForMdlSafe(PMDL MdlAddress);
ULONG CopyMdlToBuffer(PUCHAR buf, PMDL mdl, ULONG bufLen);
ULONG GetMdlListTotalByteCount(PMDL mdl);

BOOLEAN InitUSB(ADAPTEREXT *adapter);
NTSTATUS GetDeviceDescriptor(ADAPTEREXT *adapter);
NTSTATUS GetConfigDescriptor(ADAPTEREXT *adapter);
NTSTATUS SelectConfiguration(ADAPTEREXT *adapter);
NTSTATUS FindUSBPipeHandles(ADAPTEREXT *adapter);
VOID StartUSBReadLoop(ADAPTEREXT *adapter);
VOID TryReadUSB(ADAPTEREXT *adapter);

USBPACKET *NewPacket(ADAPTEREXT *adapter);
VOID FreePacket(USBPACKET *packet);
VOID EnqueueFreePacket(USBPACKET *packet);
USBPACKET *DequeueFreePacket(ADAPTEREXT *adapter);
VOID EnqueuePendingReadPacket(USBPACKET *packet);
VOID DequeuePendingReadPacket(USBPACKET *packet);
VOID EnqueuePendingWritePacket(USBPACKET *packet);
VOID DequeuePendingWritePacket(USBPACKET *packet);
VOID EnqueueCompletedReadPacket(USBPACKET *packet);
VOID DequeueCompletedReadPacket(USBPACKET *packet);
VOID CancelAllPendingPackets(ADAPTEREXT *adapter);

NTSTATUS SubmitUSBReadPacket(USBPACKET *packet);
NTSTATUS SubmitUSBWritePacket(USBPACKET *packet);
NTSTATUS SubmitNotificationRead(ADAPTEREXT *adapter, BOOLEAN synchronous);
NTSTATUS SubmitPacketToControlPipe(USBPACKET *packet, BOOLEAN synchronous, BOOLEAN simulated);

BOOLEAN RegisterRNDISMicroport(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath);
VOID IndicateSendStatusToRNdis(USBPACKET *packet, NTSTATUS status);

NTSTATUS KLSIWeirdInit(ADAPTEREXT *adapter);
BOOLEAN KLSIStagePartialPacket(ADAPTEREXT *adapter, USBPACKET *packet);
NTSTATUS KLSISetEthernetPacketFilter(ADAPTEREXT *adapter, USHORT packetFilterMask);

VOID RNDISProcessNotification(ADAPTEREXT *adapter);
NTSTATUS IndicateRndisMessage(USBPACKET *packet, BOOLEAN bIsData);

#ifdef RAW_TEST
PMDL AddDataHeader(IN PMDL pMessageMdl);
VOID FreeDataHeader(IN USBPACKET * packet);
VOID SkipRcvRndisPacketHeader(IN USBPACKET * packet);
VOID UnskipRcvRndisPacketHeader(IN USBPACKET * packet);
#endif
NTSTATUS ReadPacketFromControlPipe(USBPACKET *packet, BOOLEAN synchronous);

VOID AdapterFullResetAndRestore(ADAPTEREXT *adapter);
NTSTATUS GetUSBPortStatus(ADAPTEREXT *adapter, PULONG portStatus);
NTSTATUS ResetPipe(ADAPTEREXT *adapter, PVOID pipeHandle);
NTSTATUS AbortPipe(ADAPTEREXT *adapter, PVOID pipeHandle);
NTSTATUS SimulateRNDISHalt(ADAPTEREXT *adapter);
NTSTATUS SimulateRNDISInit(ADAPTEREXT *adapter);
NTSTATUS SimulateRNDISSetPacketFilter(ADAPTEREXT *adapter);
NTSTATUS SimulateRNDISSetCurrentAddress(ADAPTEREXT *adapter);
VOID ServiceReadDeficit(ADAPTEREXT *adapter);
VOID QueueAdapterWorkItem(ADAPTEREXT *adapter);
VOID AdapterWorkItemCallback(IN PDEVICE_OBJECT devObj, IN PVOID context);
VOID BackoffTimerDpc(IN PKDPC Dpc, IN PVOID DeferredContext, IN PVOID SystemArgument1, IN PVOID SystemArgument2);
VOID ProcessWorkItemOrTimerCallback(ADAPTEREXT *adapter);

/*
 *  The Win98SE kernel does not expose IoWorkItems, so implement them internally.
 *  This introduces a slight race condition on unload, but there is no fix without externally-implemented workitems.
 */
#if SPECIAL_WIN98SE_BUILD
    typedef struct _IO_WORKITEM {
        WORK_QUEUE_ITEM WorkItem;
        PIO_WORKITEM_ROUTINE Routine;
        PDEVICE_OBJECT DeviceObject;
        PVOID Context;
        #if DBG
            ULONG Size;
        #endif
    } IO_WORKITEM, *PIO_WORKITEM;
    PIO_WORKITEM MyIoAllocateWorkItem(PDEVICE_OBJECT DeviceObject);
    VOID MyIoFreeWorkItem(PIO_WORKITEM IoWorkItem);
    VOID MyIoQueueWorkItem(IN PIO_WORKITEM IoWorkItem, IN PIO_WORKITEM_ROUTINE WorkerRoutine, IN WORK_QUEUE_TYPE QueueType, IN PVOID Context);
    VOID MyIopProcessWorkItem(IN PVOID Parameter);
#endif 


/*
 *  Externs
 */
extern LIST_ENTRY allAdaptersList;
extern KSPIN_LOCK globalSpinLock;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\ccfg9x\callout.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright (c) 1994-1998 Microsoft Corporation
//*********************************************************************

//
//  CALLOUT.C - Functions to call out to external components to install
//        devices
//

//  HISTORY:
//  
//  96/05/22  markdu  Created (from inetcfg.dll)
//

#include "pch.hpp"

/*******************************************************************

  NAME:    InstallTCPIP

  SYNOPSIS:  Installs MS TCP/IP 

  EXIT:    ERROR_SUCCESS if successful, or a standard error code

  NOTES:    calls through thunk layer to 16-bit side which calls
        Device Manager

********************************************************************/
UINT InstallTCPIP(HWND hwndParent)
{
  WAITCURSOR WaitCursor;  // waitcursor object for hourglassing

  // call down to 16-bit dll to do this
  return InstallComponent(hwndParent,IC_TCPIP,0);
}

/*******************************************************************

  NAME:    InstallPPPMAC

  SYNOPSIS:  Installs PPPMAC (PPP driver)

  EXIT:    ERROR_SUCCESS if successful, or a standard error code

  NOTES:    calls through thunk layer to 16-bit side which calls
        Device Manager

********************************************************************/
UINT InstallPPPMAC(HWND hwndParent)
{
  WAITCURSOR WaitCursor;  // waitcursor object for hourglassing

  // call down to 16-bit dll to do this
  return InstallComponent(hwndParent,IC_PPPMAC,0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\ccfg9x\cfgapi.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright (c) 1994-1999 Microsoft Corporation
//*********************************************************************

//
//  CFGAPI.C - Functions for exported config API.
//

//  HISTORY:
//  
//  96/05/22  markdu  Created (from inetcfg.dll)
//  96/05/25  markdu  Use ICFG_ flags for lpNeedDrivers and lpInstallDrivers.
//  96/05/27  markdu  Added lpGetLastInstallErrorText.
//

#include "pch.hpp"

UINT DetectModifyTCPIPBindings(DWORD dwCardFlags,LPCSTR pszBoundTo,BOOL fRemove,BOOL * pfBound);


//*******************************************************************
//
//  FUNCTION:   IcfgGetLastInstallErrorText
//
//  PURPOSE:    Get a text string that describes the last installation
//              error that occurred.  The string should be suitable
//              for display in a message box with no further formatting.
//
//  PARAMETERS: lpszErrorDesc - points to buffer to receive the string.
//              cbErrorDesc - size of buffer.
//
//  RETURNS:    The length of the string returned.
//
//*******************************************************************

extern "C" DWORD IcfgGetLastInstallErrorText(LPSTR lpszErrorDesc, DWORD cbErrorDesc)
{
  if (lpszErrorDesc)
  {
    lstrcpyn(lpszErrorDesc, gpszLastErrorText, cbErrorDesc);
    return lstrlen(lpszErrorDesc);
  }
  else
  {
    return 0;
  }
}


//*******************************************************************
//
//  FUNCTION:   IcfgNeedInetComponents
//
//  PURPOSE:    Detects whether the specified system components are
//              installed or not.
//
//  PARAMETERS: dwfOptions - a combination of ICFG_ flags that specify
//              which components to detect as follows:
//
//                ICFG_INSTALLTCP - is TCP/IP needed?
//                ICFG_INSTALLRAS - is RAS needed?
//                ICFG_INSTALLMAIL - is exchange or internet mail needed?
//
//              lpfNeedComponents - TRUE if any specified component needs
//              to be installed.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//  History:	5/8/97 ChrisK Added INSTALLLAN,INSTALLDIALUP,INSTALLTCPONLY
//
//*******************************************************************

extern "C" HRESULT IcfgNeedInetComponents(DWORD dwfOptions, LPBOOL lpfNeedComponents)
{
  CLIENTCONFIG  ClientConfig;

  DEBUGMSG("cfgapi.c::IcfgNeedInetComponents()");

  ASSERT(lpfNeedComponents);

  // read client configuration
  ZeroMemory(&ClientConfig,sizeof(CLIENTCONFIG));
  DWORD dwErrCls;
  UINT err=GetConfig(&ClientConfig,&dwErrCls);
  if (err != OK)
  {
    PrepareErrorMessage(IDS_ERRReadConfig,(UINT) err,
      dwErrCls,MB_ICONEXCLAMATION);
    return err;
  }

  // check if we are allowed to install TCP/IP
  if (dwfOptions & ICFG_INSTALLTCP)
  {
    // need TCP/IP present and bound to PPP driver
    if (!ClientConfig.fPPPBoundTCP)
    {
      if (lpfNeedComponents)
      {
        *lpfNeedComponents = TRUE;
      }
      return ERROR_SUCCESS;
    }
  }

  // check if we are allowed to install RNA
  if (dwfOptions & ICFG_INSTALLRAS)
  {
    // need PPPMAC and RNA files if using modem
    if (!ClientConfig.fRNAInstalled ||
      !ClientConfig.fPPPDriver)
    {
      if (lpfNeedComponents)
      {
        *lpfNeedComponents = TRUE;
      }
      return ERROR_SUCCESS;
    }
  }

  // need Exchange if not installed and user wants to install mail
  if ((dwfOptions & ICFG_INSTALLMAIL) &&
    (!ClientConfig.fMailInstalled || !ClientConfig.fInetMailInstalled))
  {
    if (lpfNeedComponents)
    {
      *lpfNeedComponents = TRUE;
    }
    return ERROR_SUCCESS;
  }

  //
  // ChrisK	5/8/97
  // check if we have a bound LAN adapter
  //
  if (dwfOptions & ICFG_INSTALLLAN)
  {
	  if (!ClientConfig.fNetcard ||
		  !ClientConfig.fNetcardBoundTCP)
	  {
		  if (lpfNeedComponents)
		  {
			  *lpfNeedComponents = TRUE;
		  }
		  return ERROR_SUCCESS;
	  }
  }

  //
  // ChrisK	5/8/97
  // Check if we have a bound Dial up adapter
  //
  if (dwfOptions & ICFG_INSTALLDIALUP)
  {
	  if (!ClientConfig.fPPPDriver ||
		  !ClientConfig.fPPPBoundTCP)
	  {
		  if (lpfNeedComponents)
		  {
			  *lpfNeedComponents = TRUE;
		  }
		  return ERROR_SUCCESS;
	  }
  }

  //
  // ChrisK	5/8/97
  // Check if TCP is install at all on this system
  //
  if (dwfOptions & ICFG_INSTALLTCPONLY)
  {
	  if (!ClientConfig.fTcpip)
	  {
		  if (lpfNeedComponents)
		  {
			  *lpfNeedComponents = TRUE;
		  }
		  return ERROR_SUCCESS;
	  }
  }

  // no extra drivers needed
  if (lpfNeedComponents)
  {
    *lpfNeedComponents = FALSE;
  }
  return ERROR_SUCCESS;
}


//*******************************************************************
//
//  FUNCTION:   IcfgInstallInetComponents
//
//  PURPOSE:    Install the specified system components.
//
//  PARAMETERS: hwndParent - Parent window handle.
//              dwfOptions - a combination of ICFG_ flags that controls
//              the installation and configuration as follows:
//
//                ICFG_INSTALLTCP - install TCP/IP (if needed)
//                ICFG_INSTALLRAS - install RAS (if needed)
//                ICFG_INSTALLMAIL - install exchange and internet mail
//              
//              lpfNeedsRestart - if non-NULL, then on return, this will be
//              TRUE if windows must be restarted to complete the installation.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

extern "C" HRESULT IcfgInstallInetComponents(HWND hwndParent, DWORD dwfOptions,
  LPBOOL lpfNeedsRestart)
{
  RETERR err;
  DWORD dwFiles = 0;
  BOOL  fInitNetMAC = FALSE;
  BOOL  fNeedTCPIP=FALSE;
  BOOL  fNeedPPPMAC=FALSE;
  BOOL  fNeedToRemoveTCPIP=FALSE;
  BOOL  fNeedReboot = FALSE;
  DWORD dwErrCls;
  CLIENTCONFIG  ClientConfig;

  DEBUGMSG("cfgapi.c::IcfgInstallInetComponents()");

  // read client configuration
  ZeroMemory(&ClientConfig,sizeof(CLIENTCONFIG));
  err=GetConfig(&ClientConfig,&dwErrCls);
  if (err != OK)
  {
    PrepareErrorMessage(IDS_ERRReadConfig,(UINT) err,
      dwErrCls,MB_ICONEXCLAMATION);
    return err;
  }

  // see if we initially have any kind of net card
  fInitNetMAC = (ClientConfig.fNetcard | ClientConfig.fPPPDriver);

  // install files we need

  // install mail if user wants it and not already installed
  if (dwfOptions & ICFG_INSTALLMAIL)
  {
    // need mail files (capone)? 
    if (!ClientConfig.fMailInstalled)
    {
      DEBUGMSG("Installing Exchange files");
      dwFiles |= ICIF_MAIL;
    }

    // need internet mail files (rt 66)?
    if (!ClientConfig.fInetMailInstalled)
    {
      DEBUGMSG("Installing Internet Mail files");
      dwFiles |= ICIF_INET_MAIL;
    }
  }

  // check if we are allowed to install RNA
  if (dwfOptions & ICFG_INSTALLRAS)
  {
    // install RNA if user is connecting over modem and RNA
    // not already installed
    if (!ClientConfig.fRNAInstalled)
    {
      DEBUGMSG("Installing RNA files");
      dwFiles |= ICIF_RNA;
    }
  }

  if (dwFiles)
  {
    {
      WAITCURSOR WaitCursor;  // show hourglass
      // install the component files
      err = InstallComponent(hwndParent,IC_INSTALLFILES,
        dwFiles);
      if (err == NEED_RESTART)
      {
        DEBUGMSG("Setting restart flag");
        // set restart flag so we restart the system at end
        fNeedReboot = TRUE;
        // NEED_REBOOT also implies success, so set ret code to OK
        err = OK;
      }

      // force an update of the dialog
      if (hwndParent)
      {
        HWND hParent = GetParent(hwndParent);
        UpdateWindow(hParent ? hParent : hwndParent);
      }

      // runonce.exe may get run at next boot, twiddle the
      // registry to work around a bug where it trashes the wallpaper
      PrepareForRunOnceApp();
    }

    if (err != OK)
    {
      PrepareErrorMessage(IDS_ERRInstallFiles,(UINT) err,
        ERRCLS_SETUPX,MB_ICONEXCLAMATION);
      return err;
    }

    WAITCURSOR WaitCursor;  // show hourglass

    // do some extra stuff if we just installed mail
    if (dwFiles & ICIF_MAIL)
    {
      // .inf file leaves an entry in the registry to run
      // MS Exchange wizard, which we don't need since we'll be
      // configuring exchange ourselves.  Remove the registry
      // entry.
      RemoveRunOnceEntry(IDS_MAIL_WIZARD_REG_VAL);

      // run mlset32, Exchange setup app that it needs to have run.
      // need to display error if this fails, this is fairly important.
      err=RunMlsetExe(hwndParent);
      if (err != ERROR_SUCCESS)
      {
        PrepareErrorMessage(IDS_ERRInstallFiles,(UINT) err,
          ERRCLS_STANDARD,MB_ICONEXCLAMATION);
        return err;
      }
    }

    // run the group converter to put the Inbox icon on desktop,
    // put Exchange, RNA et al on start menu
    CHAR szExecGrpconv[SMALL_BUF_LEN],szParam[SMALL_BUF_LEN];
    LoadSz(IDS_EXEC_GRPCONV,szExecGrpconv,sizeof(szExecGrpconv));
    LoadSz(IDS_EXEC_GRPCONV_PARAM,szParam,sizeof(szParam));
    ShellExecute(NULL,NULL,szExecGrpconv,szParam,NULL,SW_SHOW);

  }

  // only install PPPMAC if we are allowed to install RNA
  if (dwfOptions & ICFG_INSTALLRAS)
  {
    // install PPPMAC if not already installed
    // Note that we have to install PPPMAC *before* TCP/IP, to work
    // in the case where the user has no net installed to start with.
    // Otherwise when we install TCP/IP, user gets prompted by net setup
    // for their net card; net setup doesn't like the idea of TCP/IP lying
    // around without something to bind it to.
    fNeedPPPMAC = (!ClientConfig.fPPPDriver);
    if (fNeedPPPMAC)
    {
      DEBUGMSG("Installing PPPMAC");

      // make up a computer and workgroup name if not already set, so
      // user doesn't get prompted
      GenerateComputerNameIfNeeded();
      
      err = InstallPPPMAC(hwndParent);

      //  96/05/20  markdu  MSN  BUG 8551 Check for reboot when installing PPPMAC.

	  //
	  // ChrisK 5/29/97 Olympus 4692
	  // Even if we just rebind PPPMAC we still need to restart the machine.
	  //
      if (err == NEED_RESTART || err == OK)
      {
        // set restart flag so we restart the system at end
        DEBUGMSG("Setting restart flag");
        fNeedReboot = TRUE;

        // NEED_REBOOT also implies success, so set ret code to OK
        err = OK;
      }

      if (err != OK)
      {
        PrepareErrorMessage(IDS_ERRInstallPPPMAC,(UINT) err,
          ERRCLS_SETUPX,MB_ICONEXCLAMATION);
        return err;
      }

      // when we install PPPMAC, if there is another net card then PPPMAC
      // will automatically "grow" all the protocols that were bound to the
      // net card.  Strip these off... (netbeui and IPX)
      RETERR errTmp = RemoveProtocols(hwndParent,INSTANCE_PPPDRIVER,
        PROT_NETBEUI | PROT_IPX);
      ASSERT(errTmp == OK);
    }
  }

  // check if we are allowed to install TCP/IP
  if (dwfOptions & ICFG_INSTALLTCP)
  {
    // figure out if we need to install TCP/IP
    // we should only put TCP/IP on appropriate type of card (net card
    // or PPP adapter)
    // user is connecting via modem, need TCP if not already present
    // and bound to PPPMAC.  Want to bind to PPP adapters, 

    //
    // As of W98, PPPMAC install also binds TCP/IP to dial-up adapter. Re-read 
    // the config using a temporary instance of the structure to determine if
    // we still need the binding. 
    // nickball - 03/03/99 - Olympus #49008, Memphis #88375, NT #180684.
    //

    CLIENTCONFIG  TmpConfig;
    ZeroMemory(&TmpConfig,sizeof(CLIENTCONFIG));

	err=GetConfig(&TmpConfig,&dwErrCls);

    if (err != OK)
    {
      PrepareErrorMessage(IDS_ERRReadConfig,(UINT) err,
        dwErrCls,MB_ICONEXCLAMATION);
      return err;
    }

    fNeedTCPIP = !TmpConfig.fPPPBoundTCP;
    
    if (fNeedTCPIP && ClientConfig.fNetcard &&
      !ClientConfig.fNetcardBoundTCP)
    {
      // if we have to add TCP to PPP driver, then check if TCP is already
      // on netcard.  If not, then TCP is going to glom on to netcard as
      // well as PPP driver when we install it, need to remove it from
      // netcard later.
      fNeedToRemoveTCPIP= TRUE;
    }

    // special case: if there were any existing instances of TCP/IP and
    // we just added PPPMAC then we don't need to install TCP/IP --
    // when the PPPMAC adapter got added it automatically gets an instance
    // of all installed protocols (incl. TCP/IP) created for it
    if (ClientConfig.fTcpip && fNeedPPPMAC)
    {
      fNeedTCPIP = FALSE;
    }
  } // if (dwfOptions & ICFG_INSTALLTCP)

  // install TCP/IP if necessary
  if (fNeedTCPIP)
  {
    DEBUGMSG("Installing TCP/IP");
    // call out to device manager to install TCP/IP
    err = InstallTCPIP(hwndParent);      

    //  96/05/20  markdu  MSN  BUG 8551 Check for reboot when installing TCP/IP.
    if (err == NEED_RESTART)
    {
      // NEED_REBOOT also implies success, so set ret code to OK
      // Reboot flag is set below ALWAYS.  Should really be set here,
      // but we don't want to suddenly stop rebooting in cases
      // where we used to reboot, even if not needed.
      err = OK;
    }

     if (err != OK)
     {
      PrepareErrorMessage(IDS_ERRInstallTCPIP,(UINT) err,
        ERRCLS_SETUPX,MB_ICONEXCLAMATION);
      return err;
    }

    if (fNeedToRemoveTCPIP)
    {
      // remove TCPIP that may have glommed onto net drivers other
      // than the one we intend it for
      UINT uErrTmp;
      uErrTmp=RemoveProtocols(hwndParent,INSTANCE_NETDRIVER,PROT_TCPIP);
      ASSERT(uErrTmp == OK);
    }

    DEBUGMSG("Setting restart flag");
    // set restart flag so we restart the system at end
    fNeedReboot = TRUE;
  }

  // if we just installed TCP/IP or PPPMAC, then adjust bindings 
  if (fNeedPPPMAC || fNeedTCPIP)
  {
    UINT uErrTmp;

    // if file sharing (vserver) is installed, TCP/IP will bind
    // to it by default.  This is bad, user could be sharing
    // files to Internet without knowing it.  Unbind VSERVER
    // from TCP/IP instances that may used to connect to Internet
    // (instances of type INSTANCE_PPPDRIVER)
    uErrTmp = IcfgTurnOffFileSharing(INSTANCE_PPPDRIVER, hwndParent);
    ASSERT (uErrTmp == ERROR_SUCCESS);

    // unbind TCP/IP from VREDIR, if bound on this card type
    BOOL fBound;
    uErrTmp = DetectModifyTCPIPBindings(INSTANCE_PPPDRIVER,szVREDIR,
      TRUE,&fBound);
    ASSERT(uErrTmp == ERROR_SUCCESS);
  }

  // refresh the client configuration info
  err = GetConfig(&ClientConfig,&dwErrCls);
  if (err != OK)
  {
    PrepareErrorMessage(IDS_ERRReadConfig,(UINT) err,
      dwErrCls,MB_ICONEXCLAMATION);
    return err;
  }

  // do some special handling if there were *no* netcard devices
  // (net cards or PPP drivers) initially installed
  if (!fInitNetMAC)
  {
    ASSERT(fNeedPPPMAC);  // should have just installed PPPMAC

    // net setup adds some extra net components "by default" when
    // we add PPPMAC and there are no net card devices, go kill them
    // off.
    RETERR reterr = RemoveUnneededDefaultComponents(hwndParent);
    ASSERT(reterr == OK);

    // since there were no net card devices to begin with, we need
    // to restart the system later.  (the NDIS VxD is a static VxD
    // which needs to run, only gets added when you install a net card.)

    DEBUGMSG("Setting restart flag");
    // set restart flag so we restart the system at end
    fNeedReboot = TRUE;
  }

  // tell caller whether we need to reboot or not
  if (lpfNeedsRestart)
  {
    *lpfNeedsRestart = fNeedReboot;
  }
  return ERROR_SUCCESS;
}


/*******************************************************************

  NAME:    GetConfig

  SYNOPSIS:  Retrieves client configuration

********************************************************************/
UINT GetConfig(CLIENTCONFIG * pClientConfig,DWORD * pdwErrCls)
{
  ASSERT(pClientConfig);
  ASSERT(pdwErrCls);

  // get most the client configuration from 16-bit dll
  UINT uRet = GetClientConfig(pClientConfig);
  if (uRet != OK) {
    // GetClientConfig returns SETUPX error codes
    *pdwErrCls = ERRCLS_SETUPX;
  } 

  return uRet;
}

//*******************************************************************
//
//  FUNCTION:   IcfgStartServices
//
//  PURPOSE:    This is a NOP designed to maintain parity with the NT
//              version (icfgnt.dll).
//
//  PARAMETERS: none
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

extern "C" HRESULT IcfgStartServices()
{
	return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rndis\usb8023\usb8023.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    usb8023.c


Author:

    ervinp

Environment:

    Kernel mode

Revision History:


--*/

#include <WDM.H>


#include "usb8023.h"
#include "debug.h"

#ifdef ALLOC_PRAGMA
        #pragma alloc_text(INIT, DriverEntry)
#endif



NTSTATUS DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath)
/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.

Arguments:

    DriverObject - pointer to the driver object

    RegistryPath - pointer to a unicode string representing the path,
                   to driver-specific key in the registry.

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    BOOLEAN registered;
    PAGED_CODE();

    DBGVERBOSE(("DriverEntry")); 

    KeInitializeSpinLock(&globalSpinLock);
    InitializeListHead(&allAdaptersList);

    INITDEBUG();


	/*
	 *  Kernel drivers register themselves as the handler for 
	 *  AddDevice, UnloadDriver, and IRPs at this point.
     *  But instead, we'll register with RNDIS, so NDIS becomes the owner of all
     *  PDOs for which this driver is loaded.
	 */
    registered = RegisterRNDISMicroport(DriverObject, RegistryPath);

    ASSERT(registered);
    return (registered) ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\ccfg9x\cfgdll.cpp ===
/*****************************************************************/
/**          Microsoft Windows for Workgroups        **/
/**          Copyright (c) 1991-1998 Microsoft Corporation
/*****************************************************************/ 

//
//  CFGDLL.C - 32-bit stubs for functions that call into 16-bit DLL
//

//  HISTORY:
//  
//  96/05/22  markdu  Created (from inetcfg.dll)
//  96/05/27  markdu  Initialize and destroy gpszLastErrorText.
//

#include "pch.hpp"

// instance handle must be in per-instance data segment
#pragma data_seg(DATASEG_PERINSTANCE)
HINSTANCE ghInstance=NULL;
LPSTR gpszLastErrorText=NULL;
#pragma data_seg(DATASEG_DEFAULT)

typedef UINT RETERR;

// prototypes for functions we thunk to
#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

  extern RETERR __stdcall GetClientConfig16(LPCLIENTCONFIG pClientConfig);
  extern UINT __stdcall InstallComponent16(HWND hwndParent,DWORD dwComponent,DWORD dwParam);
  extern RETERR __stdcall BeginNetcardTCPIPEnum16(VOID);
  extern BOOL __stdcall GetNextNetcardTCPIPNode16(LPSTR pszTcpNode,WORD cbTcpNode,
    DWORD dwFlags);
  extern VOID __stdcall GetSETUPXErrorText16(DWORD dwErr,LPSTR pszErrorDesc,DWORD cbErrorDesc);
  extern RETERR __stdcall RemoveProtocols16(HWND hwndParent,DWORD dwRemoveFromCardType,DWORD dwProtocols);
  extern RETERR __stdcall RemoveUnneededDefaultComponents16(HWND hwndParent);
  extern RETERR __stdcall DoGenInstall16(HWND hwndParent,LPCSTR lpszInfFile,LPCSTR lpszInfSect);
  extern RETERR __stdcall SetInstallSourcePath16(LPCSTR szSourcePath);

  BOOL WINAPI wizthk_ThunkConnect32(LPSTR pszDll16,LPSTR pszDll32,HINSTANCE hInst,
    DWORD dwReason);
  BOOL _stdcall DllEntryPoint(HINSTANCE hInstDll, DWORD fdwReason, LPVOID lpReserved);

#ifdef __cplusplus
}
#endif // __cplusplus

#if defined(CMBUILD)
static const CHAR szDll16[] = "CNET16.DLL";
static const CHAR szDll32[] = "CCFG32.DLL";
#else
static const CHAR szDll16[] = "INET16.DLL";
static const CHAR szDll32[] = "ICFG32.DLL";
#endif

/*******************************************************************

  NAME:    DllEntryPoint

  SYNOPSIS:  Entry point for DLL.

  NOTES:    Initializes thunk layer to inet16.DLL

********************************************************************/
BOOL _stdcall DllEntryPoint(HINSTANCE hInstDll, DWORD fdwReason, LPVOID lpReserved)
{
  // initialize thunk layer to inet16.dll
  if (!(wizthk_ThunkConnect32((LPSTR)szDll16,(LPSTR)szDll32,hInstDll,
    fdwReason)))
    return FALSE;

  if( fdwReason == DLL_PROCESS_ATTACH )
  {
    ghInstance = hInstDll;
 
    // Allocate memory for the error message text for GetLastInstallErrorText()
    gpszLastErrorText = (LPSTR)LocalAlloc(LPTR, MAX_ERROR_TEXT);
    if (NULL == gpszLastErrorText)
    {
      return FALSE;
    }
  }


  if( fdwReason == DLL_PROCESS_DETACH )
  {
    LocalFree(gpszLastErrorText);
  }

  return TRUE;
}



/*******************************************************************

  NAME:    GetClientConfig

  SYNOPSIS:  Retrieves client software configration

  ENTRY:    pClientConfig - pointer to struct to fill in with config info

  EXIT:    returns a SETUPX error code

  NOTES:    This is just the 32-bit side wrapper, thunks to GetClientConfig16
        to do real work.  Information needs to be obtained from
        setupx.dll, which is 16-bit.

********************************************************************/
RETERR GetClientConfig(CLIENTCONFIG * pClientConfig)
{
  ASSERT(pClientConfig);
   
  // thunk to GetClientConfig16 to do real work

  return GetClientConfig16(pClientConfig);
}

/*******************************************************************

  NAME:    InstallComponent

  SYNOPSIS:  Installs the specified component

  ENTRY:    dwComponent - ordinal of component to install
        (IC_xxx, defined in wizglob.h)
        dwParam - component-specific parameters, defined in wizglob.h

  EXIT:    returns ERROR_SUCCESS if successful, or a standard error code

  NOTES:    This is just the 32-bit side wrapper, thunks to InstallComponent16
        to do real work.

********************************************************************/
UINT InstallComponent(HWND hwndParent,DWORD dwComponent,DWORD dwParam)
{
  // thunk to InstallComponent16 to do real work

  return InstallComponent16(hwndParent,dwComponent,dwParam);
}


/*******************************************************************

  NAME:    BeginNetcardTCPIPEnum16Enum

  SYNOPSIS:  Begins an enumeration of netcard TCP/IP nodes

  NOTES:    Subsequent calls to GetNextNetcardTCPIPNode16 will
        enumerate TCP/IP nodes

        This is just the 32-bit side wrapper, thunks to 16-bit
        side to do real work.

********************************************************************/
RETERR BeginNetcardTCPIPEnum(VOID)
{
  return BeginNetcardTCPIPEnum16();
}

/*******************************************************************

  NAME:    GetNextNetcardTCPIPNode16

  SYNOPSIS:  Enumerates the next TCP/IP node of specified type

  ENTRY:    pszTcpNode - pointer to buffer to be filled in with
          node subkey name
        cbTcpNode - size of pszTcpNode buffer
        dwFlags - some combination of INSTANCE_ flags
          indicating what kind of instance to enumerate

  EXIT:    returns TRUE if a TCPIP node was enumerated,
        FALSE if no more nodes to enumerate

  NOTES:    BeginNetcardTCPIPEnum16 must be called before each
        enumeration to start at the beginning of the list.

        This is just the 32-bit side wrapper, thunks to 16-bit
        side to do real work.

********************************************************************/
BOOL GetNextNetcardTCPIPNode(LPSTR pszTcpNode,WORD cbTcpNode, DWORD dwFlags)
{
  return GetNextNetcardTCPIPNode16(pszTcpNode,cbTcpNode,dwFlags);
}


/*******************************************************************

  NAME:    GetSETUPXErrorText

  SYNOPSIS:  Gets text corresponding to SETUPX error code

  ENTRY:    dwErr - error to get text for
        pszErrorDesc - pointer to buffer to fill in with text
        cbErrorDesc - size of pszErrorDesc buffer

  NOTES:    This is just the 32-bit side wrapper, thunks to 16-bit
        side to do real work.

********************************************************************/
extern "C" VOID GetSETUPXErrorText(DWORD dwErr,LPSTR pszErrorDesc,DWORD cbErrorDesc)
{
  GetSETUPXErrorText16(dwErr,pszErrorDesc,cbErrorDesc);
}

/*******************************************************************

  NAME:    RemoveUnneededDefaultComponents

  SYNOPSIS:  Removes network components that we don't need which
        are installed by default when an adapter is added
        to a no-net system.

  NOTES:    Removes: vredir, nwredir, netbeui, ipx
        
        This is just the 32-bit side wrapper, thunks to 16-bit
        side to do real work.

********************************************************************/
RETERR RemoveUnneededDefaultComponents(HWND hwndParent)
{
  return RemoveUnneededDefaultComponents16(hwndParent);
}

/*******************************************************************

  NAME:    RemoveProtocols

  SYNOPSIS:  Removes specified protocols from card of specified type

  NOTES:    This function is useful because if user has a net card
        and we add PPPMAC, all the protocols that were bound
        to the net card appear on PPPMAC.  We need to go through
        and strip them off.

        This is just the 32-bit side wrapper, thunks to 16-bit
        side to do real work.

********************************************************************/
RETERR RemoveProtocols(HWND hwndParent,DWORD dwRemoveFromCardType,DWORD dwProtocols)
{
  return RemoveProtocols16(hwndParent,dwRemoveFromCardType,dwProtocols);
}

/*******************************************************************

  NAME:    DoGenInstall

  SYNOPSIS:  Calls GenInstall to do file copies, registry entries,
        etc. in specified .inf file and section.

  ENTRY:    hwndParent - parent window
        lpszInfFile - name of .inf file.
        lpszInfSect - name of section in .inf file.

  EXIT:    returns OK, or a SETUPX error code.

        This is just the 32-bit side wrapper, thunks to 16-bit
        side to do real work.

********************************************************************/
RETERR DoGenInstall(HWND hwndParent,LPCSTR lpszInfFile,LPCSTR lpszInfSect)
{
  return DoGenInstall16(hwndParent,lpszInfFile,lpszInfSect);
}


//*******************************************************************
//
//  FUNCTION:   IcfgSetInstallSourcePath
//
//  PURPOSE:    Sets the path where windows looks when installing files.
//
//  PARAMETERS: lpszSourcePath - full path of location of files to install.
//              If this is NULL, default path is used.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

extern "C" HRESULT IcfgSetInstallSourcePath(LPCSTR lpszSourcePath)
{
  // thunk to InstallComponent16 to do real work

  return SetInstallSourcePath16(lpszSourcePath);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rndis\usb8023\usb.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    usb.c


Author:

    ervinp

Environment:

    Kernel mode

Revision History:


--*/

#include <wdm.h>

#include <usbdi.h>
#include <usbdlib.h>
#include <usbioctl.h>

#include "usb8023.h"
#include "debug.h"


/*
 *  USB- and WDM- specific prototypes (won't compile in common header)
 */
NTSTATUS SubmitUrb(PDEVICE_OBJECT pdo, PURB urb, BOOLEAN synchronous, PVOID completionRoutine, PVOID completionContext);
NTSTATUS SubmitUrbIrp(PDEVICE_OBJECT pdo, PIRP irp, PURB urb, BOOLEAN synchronous, PVOID completionRoutine, PVOID completionContext);
NTSTATUS CallDriverSync(PDEVICE_OBJECT devObj, PIRP irp);
NTSTATUS CallDriverSyncCompletion(IN PDEVICE_OBJECT devObjOrNULL, IN PIRP irp, IN PVOID context);
NTSTATUS ReadPipeCompletion(IN PDEVICE_OBJECT devObj, IN PIRP irp, IN PVOID context);
NTSTATUS WritePipeCompletion(IN PDEVICE_OBJECT devObj, IN PIRP irp, IN PVOID context);
NTSTATUS NotificationCompletion(IN PDEVICE_OBJECT devObj, IN PIRP irp, IN PVOID context);
NTSTATUS ControlPipeWriteCompletion(IN PDEVICE_OBJECT devObj, IN PIRP irp, IN PVOID context);
NTSTATUS ControlPipeReadCompletion(IN PDEVICE_OBJECT devObj, IN PIRP irp, IN PVOID context);



BOOLEAN InitUSB(ADAPTEREXT *adapter)
/*++

Routine Description:

    Intialize USB-related data

Arguments:

    adapter - adapter context

Return Value:

    TRUE iff successful

--*/
{
	NTSTATUS status;
    BOOLEAN result = FALSE;

	status = GetDeviceDescriptor(adapter);
	if (NT_SUCCESS(status)){
        PUSB_DEVICE_DESCRIPTOR deviceDesc = adapter->deviceDesc;
      
        if (deviceDesc->bDeviceClass == USB_DEVICE_CLASS_CDC){

		    status = GetConfigDescriptor(adapter);
		    if (NT_SUCCESS(status)){

			    status = SelectConfiguration(adapter);
                if (NT_SUCCESS(status)){

                    /* 
                     *  Find the read and write pipe handles.
                     */
                    status = FindUSBPipeHandles(adapter);
                    if (NT_SUCCESS(status)){

                        /*
                         *  Now that we know the notify length,
                         *  initialize structures for reading the notify pipe.
                         *  Add some buffer space for a guard word.
                         */
                        adapter->notifyBuffer = AllocPool(adapter->notifyPipeLength+sizeof(ULONG));
                        adapter->notifyIrpPtr = IoAllocateIrp(adapter->nextDevObj->StackSize, FALSE);
                        adapter->notifyUrbPtr = AllocPool(sizeof(URB));
                        if (adapter->notifyBuffer && adapter->notifyIrpPtr && adapter->notifyUrbPtr){
                            KeInitializeEvent(&adapter->notifyCancelEvent, NotificationEvent, FALSE);
                            adapter->cancellingNotify = FALSE;
                        }
                        else {
                            /*
                             *  Alloc failure. Memory will be cleaned up by FreeAdapter().
                             */
                            status = STATUS_INSUFFICIENT_RESOURCES;
                        }

                        if (NT_SUCCESS(status)){
                            result = TRUE;
                        }
                        else {
                            /*
                             *  Alloc failure. Memory will be cleaned up by FreeAdapter().
                             */
                            DBGERR(("Couldn't allocate notify structs"));
                        }
                    }
                }
		    }
        }
        else {
            DBGERR(("InitUSB: device descriptor has wrong bDeviceClass==%xh.", (ULONG)deviceDesc->bDeviceClass));
            status = STATUS_DEVICE_DATA_ERROR;
        }
	}

	return result;
}


VOID StartUSBReadLoop(ADAPTEREXT *adapter)
{
    ULONG i;

    for (i = 0; i < NUM_READ_PACKETS; i++){
        TryReadUSB(adapter);
    }
}



VOID TryReadUSB(ADAPTEREXT *adapter)
{
    KIRQL oldIrql;

    /*
     *  ReadPipeCompletion re-issues a read irp directly via this function.
     *  Ordinarily the hardware can't keep up fast enough to
     *  make us loop, but this check forces an unwind in extenuating circumstances.
     */
    if (InterlockedIncrement(&adapter->readReentrancyCount) > 3){
        KeAcquireSpinLock(&adapter->adapterSpinLock, &oldIrql);
        adapter->readDeficit++;
        KeReleaseSpinLock(&adapter->adapterSpinLock, oldIrql);
        QueueAdapterWorkItem(adapter);
        DBGWARN(("TryReadUSB: reentered %d times, aborting to prevent stack overflow", adapter->readReentrancyCount));
    }
    else {
        USBPACKET *packet = DequeueFreePacket(adapter);
        if (packet){
            NTSTATUS status;

            EnqueuePendingReadPacket(packet);

            status = SubmitUSBReadPacket(packet);
        }
        else {
            KeAcquireSpinLock(&adapter->adapterSpinLock, &oldIrql);
            adapter->readDeficit++;
            KeReleaseSpinLock(&adapter->adapterSpinLock, oldIrql);
            QueueAdapterWorkItem(adapter);
        }
    }

    InterlockedDecrement(&adapter->readReentrancyCount);

}




NTSTATUS GetDeviceDescriptor(ADAPTEREXT *adapter)
/*++

Routine Description:

    Function retrieves the device descriptor from the device

Arguments:

    adapter - adapter context

Return Value:

    NT status code

--*/
{
    URB urb;
    NTSTATUS status;

    UsbBuildGetDescriptorRequest(&urb,
                                 (USHORT) sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                 USB_DEVICE_DESCRIPTOR_TYPE,
                                 0,
                                 0,
                                 adapter->deviceDesc,
                                 NULL,
                                 sizeof(USB_DEVICE_DESCRIPTOR),
                                 NULL);

    status = SubmitUrb(adapter->nextDevObj, &urb, TRUE, NULL, NULL);

    if (NT_SUCCESS(status)){
        ASSERT(urb.UrbControlDescriptorRequest.TransferBufferLength == sizeof(USB_DEVICE_DESCRIPTOR));
        DBGVERBOSE(("Got device desc @ %ph.", (PVOID)&adapter->deviceDesc));
    }

    ASSERT(NT_SUCCESS(status));
    return status;
}


NTSTATUS GetConfigDescriptor(ADAPTEREXT *adapter)
/*++

Routine Description:

    Function retrieves the configuration descriptor from the device

Arguments:

    adapter - adapter context

Return Value:

    NT status code

--*/
{
    URB urb = { 0 };
    NTSTATUS status;
    USB_CONFIGURATION_DESCRIPTOR tmpConfigDesc = { 0 };


    /*
     *  First get the initial part of the config descriptor
     *  to find out how long the entire descriptor is.
     */
    UsbBuildGetDescriptorRequest(&urb,
                                 (USHORT) sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                 USB_CONFIGURATION_DESCRIPTOR_TYPE,
                                 0,
                                 0,
                                 (PVOID)&tmpConfigDesc,
                                 NULL,
                                 sizeof(USB_CONFIGURATION_DESCRIPTOR),
                                 NULL);
    status = SubmitUrb(adapter->nextDevObj, &urb, TRUE, NULL, NULL);
    if (NT_SUCCESS(status)){

        ASSERT(urb.UrbControlDescriptorRequest.TransferBufferLength == sizeof(USB_CONFIGURATION_DESCRIPTOR));
        ASSERT(tmpConfigDesc.wTotalLength > sizeof(USB_CONFIGURATION_DESCRIPTOR));

        adapter->configDesc = AllocPool((ULONG)tmpConfigDesc.wTotalLength);
        if (adapter->configDesc){
            RtlZeroMemory(adapter->configDesc, (ULONG)tmpConfigDesc.wTotalLength);
            UsbBuildGetDescriptorRequest(&urb,
                                         (USHORT) sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                         USB_CONFIGURATION_DESCRIPTOR_TYPE,
                                         0,
                                         0,
                                         adapter->configDesc,
                                         NULL,
                                         tmpConfigDesc.wTotalLength,
                                         NULL);
            status = SubmitUrb(adapter->nextDevObj, &urb, TRUE, NULL, NULL);
            if (NT_SUCCESS(status)){
                ASSERT(((PUSB_CONFIGURATION_DESCRIPTOR)adapter->configDesc)->wTotalLength == tmpConfigDesc.wTotalLength);
                ASSERT(urb.UrbControlDescriptorRequest.TransferBufferLength == (ULONG)tmpConfigDesc.wTotalLength);
                DBGVERBOSE(("Got config desc @ %ph, len=%xh.", adapter->configDesc, urb.UrbControlDescriptorRequest.TransferBufferLength)); 
            }
            else {
                ASSERT(NT_SUCCESS(status));
                FreePool(adapter->configDesc);
                adapter->configDesc = NULL;
            }
        }
        else {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    ASSERT(NT_SUCCESS(status));
    return status;
}



/*
 *  SelectConfiguration
 *
 *
 */
NTSTATUS SelectConfiguration(ADAPTEREXT *adapter)
{
	PUSB_CONFIGURATION_DESCRIPTOR configDesc = (PUSB_CONFIGURATION_DESCRIPTOR)adapter->configDesc;
	NTSTATUS status;
    PURB urb = NULL;
    ULONG i;

    ASSERT(configDesc->bNumInterfaces > 0);

    #if SPECIAL_WIN98SE_BUILD
        /*
         *  Hack to load on Win98 gold
         */
        {
            USHORT dummySize = 0;
            ASSERT(configDesc->bNumInterfaces >= 2);
            urb = USBD_CreateConfigurationRequest(configDesc, &dummySize);
        }
    #else
        if (configDesc->bNumInterfaces >= 2){
    	    PUSBD_INTERFACE_LIST_ENTRY interfaceList;
            interfaceList = AllocPool((configDesc->bNumInterfaces+1)*sizeof(USBD_INTERFACE_LIST_ENTRY));
            if (interfaceList){

                for (i = 0; i < configDesc->bNumInterfaces; i++){

                    /*
                     *  Note: try to use USBD_ParseConfigurationDescriptor instead of
                     *        USBD_ParseConfigurationDescriptorEx so that we work
                     *        on Win98 gold.
                     */
	                interfaceList[i].InterfaceDescriptor = USBD_ParseConfigurationDescriptor(
                                configDesc,
                                (UCHAR)i,      
                                (UCHAR)0);
                    if (!interfaceList[i].InterfaceDescriptor){
                        break;
                    }
                }
                interfaceList[i].InterfaceDescriptor = NULL;
                ASSERT(i == configDesc->bNumInterfaces);

		        urb = USBD_CreateConfigurationRequestEx(configDesc, interfaceList);

                FreePool(interfaceList);
            }
        }
        else {
            ASSERT(configDesc->bNumInterfaces >= 2);
        }
    #endif

	if (urb){
        PUSBD_INTERFACE_INFORMATION interfaceInfo;

        /*
         *  Fill in the interfaceInfo Class fields, 
         *  since USBD_CreateConfigurationRequestEx doesn't do that.
         */
        interfaceInfo = &urb->UrbSelectConfiguration.Interface;
        for (i = 0; i < configDesc->bNumInterfaces; i++){
            PUSB_INTERFACE_DESCRIPTOR ifaceDesc;
            ifaceDesc = USBD_ParseConfigurationDescriptor(configDesc, (UCHAR)i, (UCHAR)0);
            interfaceInfo->Class = ifaceDesc->bInterfaceClass;
            interfaceInfo = (PUSBD_INTERFACE_INFORMATION)((PUCHAR)interfaceInfo+interfaceInfo->Length);
        }

        /*
         *  Increase the transfer size for all data endpoints up to the maximum.
         *  The data interface follows the master interface.
         */
        interfaceInfo = &urb->UrbSelectConfiguration.Interface;
        if (interfaceInfo->Class != USB_DEVICE_CLASS_DATA){
            interfaceInfo = (PUSBD_INTERFACE_INFORMATION)((PUCHAR)interfaceInfo+interfaceInfo->Length);
        }
        if (interfaceInfo->Class == USB_DEVICE_CLASS_DATA){
            for (i = 0; i < interfaceInfo->NumberOfPipes; i++){
                interfaceInfo->Pipes[i].MaximumTransferSize = PACKET_BUFFER_SIZE;
            }
            status = SubmitUrb(adapter->nextDevObj, urb, TRUE, NULL, NULL);
        }
        else {
            ASSERT(interfaceInfo->Class == USB_DEVICE_CLASS_DATA);
            status = STATUS_DEVICE_DATA_ERROR;
        }

        if (NT_SUCCESS(status)){
            PUSBD_INTERFACE_INFORMATION interfaceInfo2;

            adapter->configHandle = (PVOID)urb->UrbSelectConfiguration.ConfigurationHandle;

            /*
             *  A USB RNDIS device has two interfaces:
             *      - a 'master' CDC class interface with one interrupt endpoint for notification
             *      - a Data class interface with two bulk endpoints
             *
             *  They may be in either order, so check class fields to assign
             *  pointers correctly.
             */

            interfaceInfo = &urb->UrbSelectConfiguration.Interface;
            interfaceInfo2 = (PUSBD_INTERFACE_INFORMATION)((PUCHAR)interfaceInfo+interfaceInfo->Length);

            if ((interfaceInfo->Class == USB_DEVICE_CLASS_CDC) &&
                (interfaceInfo2->Class == USB_DEVICE_CLASS_DATA)){
                adapter->interfaceInfoMaster = MemDup(interfaceInfo, interfaceInfo->Length);
                adapter->interfaceInfo = MemDup(interfaceInfo2, interfaceInfo2->Length);
            }
            else if ((interfaceInfo->Class == USB_DEVICE_CLASS_DATA) &&
                     (interfaceInfo2->Class == USB_DEVICE_CLASS_CDC)){
                DBGWARN(("COVERAGE - Data interface precedes master CDC interface"));
                adapter->interfaceInfo = MemDup(interfaceInfo, interfaceInfo->Length);
                adapter->interfaceInfoMaster = MemDup(interfaceInfo2, interfaceInfo2->Length);
            }
            else {
                DBGERR(("improper interface classes"));
                adapter->interfaceInfo = NULL;
                adapter->interfaceInfoMaster = NULL;
            }

            if (adapter->interfaceInfo && adapter->interfaceInfoMaster){
                DBGVERBOSE(("SelectConfiguration: interfaceInfo @ %ph, interfaceInfoMaster @ %ph.", adapter->interfaceInfo, adapter->interfaceInfoMaster));
            }
            else {
                if (adapter->interfaceInfoMaster) FreePool(adapter->interfaceInfoMaster);
                if (adapter->interfaceInfo) FreePool(adapter->interfaceInfo);
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
        else {
            DBGERR(("SelectConfiguration: selectConfig URB failed w/ %xh.", status));
        }

        ExFreePool(urb);
	}
	else {
		status = STATUS_INSUFFICIENT_RESOURCES;
	}

    ASSERT(NT_SUCCESS(status));
	return status;
}



NTSTATUS FindUSBPipeHandles(ADAPTEREXT *adapter)
{

    /*
     *  Algorithm for identifying the endpoints:
     *      The longest interrupt or bulk IN endpoint on the data interface
     *          is the read endpoint;
     *      The longest interrupt or bulk OUT endpoint on the data interface
     *          is the write endpoint;
     *      The first interrupt IN endpoint on the master interface
     *          is the notification endpoint.
     */
    
    PUSBD_INTERFACE_INFORMATION interfaceInfo = adapter->interfaceInfo;
    PUSBD_INTERFACE_INFORMATION notifyInterfaceInfo = adapter->interfaceInfoMaster;
    LONG pipeIndex;
    LONG longestInputPipeIndex = -1, longestOutputPipeIndex = -1, notifyPipeIndex = -1;
    ULONG longestInputPipeLength = 0, longestOutputPipeLength = 0, notifyPipeLength;
    NTSTATUS status;

    /*
     *  Find the IN and OUT endpoints.
     */
	for (pipeIndex = 0; pipeIndex < (LONG)interfaceInfo->NumberOfPipes; pipeIndex++){
		PUSBD_PIPE_INFORMATION pipeInfo = &interfaceInfo->Pipes[pipeIndex];

		if ((pipeInfo->PipeType == UsbdPipeTypeInterrupt) || 
            (pipeInfo->PipeType == UsbdPipeTypeBulk)){

    		if (pipeInfo->EndpointAddress & USB_ENDPOINT_DIRECTION_MASK){
                if (pipeInfo->MaximumPacketSize > longestInputPipeLength){
                    longestInputPipeIndex = pipeIndex;
                    longestInputPipeLength = pipeInfo->MaximumPacketSize;
                }
            }
            else {
                if (pipeInfo->MaximumPacketSize > longestOutputPipeLength){
                    longestOutputPipeIndex = pipeIndex;
                    longestOutputPipeLength = pipeInfo->MaximumPacketSize;
                }
            }
        }
    }

    /*
     *  Find the Notify endpoint.
     */
	for (pipeIndex = 0; pipeIndex < (LONG)notifyInterfaceInfo->NumberOfPipes; pipeIndex++){
		PUSBD_PIPE_INFORMATION pipeInfo = &notifyInterfaceInfo->Pipes[pipeIndex];

        if ((pipeInfo->PipeType == UsbdPipeTypeInterrupt)               &&
    		(pipeInfo->EndpointAddress & USB_ENDPOINT_DIRECTION_MASK)   &&
            ((notifyInterfaceInfo != interfaceInfo) || 
             (pipeIndex != longestInputPipeIndex))){

                notifyPipeIndex = pipeIndex;
                notifyPipeLength = pipeInfo->MaximumPacketSize;
                break;
        }
    }

    if ((longestInputPipeIndex >= 0)     && 
        (longestOutputPipeIndex >= 0)    &&
        (notifyPipeIndex >= 0)){

        adapter->readPipeHandle = interfaceInfo->Pipes[longestInputPipeIndex].PipeHandle;
        adapter->writePipeHandle = interfaceInfo->Pipes[longestOutputPipeIndex].PipeHandle;
        adapter->notifyPipeHandle = notifyInterfaceInfo->Pipes[notifyPipeIndex].PipeHandle;

        adapter->readPipeLength = longestInputPipeLength;
        adapter->writePipeLength = longestOutputPipeLength;
        adapter->notifyPipeLength = notifyPipeLength;

        adapter->readPipeEndpointAddr = interfaceInfo->Pipes[longestInputPipeIndex].EndpointAddress;
        adapter->writePipeEndpointAddr = interfaceInfo->Pipes[longestOutputPipeIndex].EndpointAddress;
        adapter->notifyPipeEndpointAddr = notifyInterfaceInfo->Pipes[notifyPipeIndex].EndpointAddress;

        DBGVERBOSE(("FindUSBPipeHandles: got readPipe %ph,len=%xh; writePipe %ph,len=%xh; notifyPipe %ph,len=%xh.",
                    adapter->readPipeHandle, adapter->readPipeLength, adapter->writePipeHandle, adapter->writePipeLength, adapter->notifyPipeHandle, adapter->notifyPipeLength));
        status = STATUS_SUCCESS;
    }
    else {
        DBGERR(("FindUSBPipeHandles: couldn't find right set of pipe handles (indices: %xh,%xh,%xh).", longestInputPipeIndex, longestOutputPipeIndex, notifyPipeIndex));
        status = STATUS_DEVICE_DATA_ERROR;
    }

    return status;
}


NTSTATUS SubmitUrb( PDEVICE_OBJECT pdo, 
                    PURB urb, 
                    BOOLEAN synchronous, 
                    PVOID completionRoutine,
                    PVOID completionContext)
/*++

Routine Description:

    Send the URB to the USB device.
	If synchronous is TRUE, ignore the completion info and synchonize the IRP;
    otherwise, don't synchronize and set the provided completion routine for the IRP.

Arguments:

    
Return Value:

    NT status code

--*/
{
    NTSTATUS status;
    PIRP irp;


    /*
     *  Allocate the IRP to send the buffer down the USB stack.
     *
     *  Don't use IoBuildDeviceIoControlRequest (because it queues
     *  the IRP on the current thread's irp list and may
     *  cause the calling process to hang if the IopCompleteRequest APC
     *  does not fire and dequeue the IRP).
     */
    irp = IoAllocateIrp(pdo->StackSize, FALSE);
    if (irp){
        PIO_STACK_LOCATION nextSp;

	    DBGVERBOSE(("SubmitUrb: submitting URB %ph on IRP %ph (sync=%d)", urb, irp, synchronous));

        nextSp = IoGetNextIrpStackLocation(irp);
	    nextSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
	    nextSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;

	    /*
	     *  Attach the URB to this IRP.
	     */
        nextSp->Parameters.Others.Argument1 = urb;

        if (synchronous){

            status = CallDriverSync(pdo, irp);

		    IoFreeIrp(irp);
        }
        else {
            /*
             *  Caller's completion routine will free the irp 
             *  when it completes.
             */
            ASSERT(completionRoutine);
            ASSERT(completionContext);

            irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
            IoSetCompletionRoutine( irp, 
                                    completionRoutine, 
                                    completionContext,
                                    TRUE, TRUE, TRUE);
            status = IoCallDriver(pdo, irp);
        }
    }
    else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }
    return status;
}


NTSTATUS SubmitUrbIrp(  PDEVICE_OBJECT pdo, 
                        PIRP irp,
                        PURB urb, 
                        BOOLEAN synchronous, 
                        PVOID completionRoutine,
                        PVOID completionContext)
/*++

Routine Description:

    Send the URB to the USB device.
	If synchronous is TRUE, ignore the completion info and synchonize the IRP;
    otherwise, don't synchronize and set the provided completion routine for the IRP.

Arguments:

    
Return Value:

    NT status code

--*/
{
    NTSTATUS status;
    PIO_STACK_LOCATION nextSp;

	DBGVERBOSE(("SubmitUrb: submitting URB %ph on IRP %ph (sync=%d)", urb, irp, synchronous));

    nextSp = IoGetNextIrpStackLocation(irp);
	nextSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
	nextSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;

    irp->Cancel = FALSE;

	/*
	 *  Attach the URB to this IRP.
	 */
    nextSp->Parameters.Others.Argument1 = urb;

    if (synchronous){
        status = CallDriverSync(pdo, irp);
        ASSERT(!irp->CancelRoutine);
    }
    else {
        ASSERT(completionRoutine);
        ASSERT(completionContext);

        irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        IoSetCompletionRoutine( irp, 
                                completionRoutine, 
                                completionContext,
                                TRUE, TRUE, TRUE);
        status = IoCallDriver(pdo, irp);
    }

    return status;
}


NTSTATUS SubmitUSBReadPacket(USBPACKET *packet)
{
    NTSTATUS status;
    PURB urb = packet->urbPtr;
    PIRP irp = packet->irpPtr;
    ULONG readLength;

    readLength = packet->dataBufferMaxLength;

    DBGVERBOSE(("SubmitUSBReadPacket: read %xh bytes, packet # %xh.", readLength, packet->packetId));

	urb->UrbBulkOrInterruptTransfer.Hdr.Function = URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER;
	urb->UrbBulkOrInterruptTransfer.Hdr.Length = sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER);
	urb->UrbBulkOrInterruptTransfer.PipeHandle = packet->adapter->readPipeHandle;
	urb->UrbBulkOrInterruptTransfer.TransferBufferLength = readLength;
	urb->UrbBulkOrInterruptTransfer.TransferBufferMDL = NULL;
	urb->UrbBulkOrInterruptTransfer.TransferBuffer = packet->dataBuffer;
	urb->UrbBulkOrInterruptTransfer.TransferFlags = USBD_SHORT_TRANSFER_OK | USBD_TRANSFER_DIRECTION_IN;
	urb->UrbBulkOrInterruptTransfer.UrbLink = NULL;

    status = SubmitUrbIrp(  packet->adapter->nextDevObj, 
                            irp,
							urb, 
							FALSE,					// asynchronous
							ReadPipeCompletion,		// completion routine
							packet				    // completion context
				            );
    return status;
}



NTSTATUS ReadPipeCompletion(IN PDEVICE_OBJECT devObj, IN PIRP irp, IN PVOID context)
{
	USBPACKET *packet = (USBPACKET *)context;
    ADAPTEREXT *adapter = packet->adapter;
	NTSTATUS status = irp->IoStatus.Status;

	ASSERT(packet->sig == DRIVER_SIG);
    ASSERT(adapter->sig == DRIVER_SIG);
    ASSERT(packet->irpPtr == irp);
    ASSERT(!irp->CancelRoutine);
    ASSERT(status != STATUS_PENDING);  // saw UHCD doing this ?

    /*
     *  Dequeue the packet from the usbPendingReadPackets queue 
     *  BEFORE checking if it was cancelled to avoid race with CancelAllPendingPackets.
     */
    DequeuePendingReadPacket(packet);

    if (packet->cancelled){
        /*
         *  This packet was cancelled because of a halt or reset.
         *  Get the packet is back in the free list first, then
         *  set the event so CancelAllPendingPackets can proceed.
         */
        DBGVERBOSE(("    ... read packet #%xh cancelled.", packet->packetId));
        packet->cancelled = FALSE;

        EnqueueFreePacket(packet);
        KeSetEvent(&packet->cancelEvent, 0, FALSE);
    }
    else if (adapter->halting){
        EnqueueFreePacket(packet);
    }
    else {
        PURB urb = packet->urbPtr;

        if (NT_SUCCESS(status)){
            BOOLEAN ethernetPacketComplete;

            adapter->numConsecutiveReadFailures = 0;

            /*
             *  Fix the packet's dataBufferCurrentLength to indicate the actual length
             *  of the returned data.
             *  Note:  the KLSI device rounds this up to a multiple of the endpoint
             *         packet size, so the returned length may actually be larger than
             *         the actual data.
             */
            packet->dataBufferCurrentLength = urb->UrbBulkOrInterruptTransfer.TransferBufferLength;
            ASSERT(packet->dataBufferCurrentLength);
            ASSERT(packet->dataBufferCurrentLength <= packet->dataBufferMaxLength);

            DBGVERBOSE(("ReadPipeCompletion: %xh bytes, packet # %xh.", packet->dataBufferCurrentLength, packet->packetId));

            ethernetPacketComplete = (packet->dataBufferCurrentLength >= MINIMUM_ETHERNET_PACKET_SIZE);

            if (ethernetPacketComplete){
                /*
                 *  A complete ethernet packet has been received.
                 *  The entire ethernet packet is now in the current (final) USB packet.
                 *  Put our USB packet on the completed list and indicate it to RNDIS.
                 */
                DBGSHOWBYTES("ReadPipeCompletion (COMPLETE packet)", packet->dataBuffer, packet->dataBufferCurrentLength);

                EnqueueCompletedReadPacket(packet);

                status = IndicateRndisMessage(packet, TRUE);
                if (status != STATUS_PENDING){
                    DequeueCompletedReadPacket(packet);
                    EnqueueFreePacket(packet);
                }
            }
            else {
                DBGWARN(("Device returned %xh-length packet @ %ph.", packet->dataBufferCurrentLength, packet->dataBuffer));
                DBGSHOWBYTES("ReadPipeCompletion (partial packet)", packet->dataBuffer, packet->dataBufferCurrentLength);
                EnqueueFreePacket(packet);
            }

            TryReadUSB(adapter);
        }
        else {
            KIRQL oldIrql;

            /*
             *  The read failed.  Put the packet back in the free list.
             */
            DBGWARN(("ReadPipeCompletion: read failed with status %xh on adapter %xh (urb status = %xh).", status, adapter, urb->UrbHeader.Status));
            #if DO_FULL_RESET
                switch (USBD_STATUS(urb->UrbBulkOrInterruptTransfer.Hdr.Status)){
                    case USBD_STATUS(USBD_STATUS_STALL_PID):
                    case USBD_STATUS(USBD_STATUS_DEV_NOT_RESPONDING):
                    case USBD_STATUS(USBD_STATUS_ENDPOINT_HALTED):
                        /*
                         *  Set a flag so we do a full reset in the workItem
                         *  (QueueAdapterWorkItem is called below)
                         */
                        adapter->needFullReset = TRUE;
                        break;
                }
            #endif

            EnqueueFreePacket(packet);

            /*
             *  We're probably halting or resetting.
             *  Don't reissue a read synchronously here because it will probably
             *  keep failing on the same thread and cause us to blow the stack.
             */
            KeAcquireSpinLock(&adapter->adapterSpinLock, &oldIrql);
            adapter->numConsecutiveReadFailures++;
            adapter->readDeficit++;
            KeReleaseSpinLock(&adapter->adapterSpinLock, oldIrql);
            QueueAdapterWorkItem(adapter);
        }

    }

	return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS SubmitUSBWritePacket(USBPACKET *packet)
{
    NTSTATUS status;
    ADAPTEREXT *adapter = packet->adapter;
    PURB urb = packet->urbPtr;
    PIRP irp = packet->irpPtr;

    /*
     *  Some device USB controllers cannot detect the end of a transfer unless there
     *  is a short packet at the end.  So if the transfer is a multiple of the
     *  endpoint's wMaxPacketSize, add a byte to force a short packet at the end.
     */
    if ((packet->dataBufferCurrentLength % adapter->writePipeLength) == 0){
        packet->dataBuffer[packet->dataBufferCurrentLength++] = 0x00;
    }

    ASSERT(packet->dataBufferCurrentLength <= PACKET_BUFFER_SIZE);
    DBGVERBOSE(("SubmitUSBWritePacket: %xh bytes, packet # %xh.", packet->dataBufferCurrentLength, packet->packetId));
    DBGSHOWBYTES("SubmitUSBWritePacket", packet->dataBuffer, packet->dataBufferCurrentLength);

    urb->UrbBulkOrInterruptTransfer.Hdr.Function = URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER;
    urb->UrbBulkOrInterruptTransfer.Hdr.Length = sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER);
    urb->UrbBulkOrInterruptTransfer.PipeHandle = adapter->writePipeHandle;
    urb->UrbBulkOrInterruptTransfer.TransferBufferLength = packet->dataBufferCurrentLength; 
    urb->UrbBulkOrInterruptTransfer.TransferBufferMDL = NULL;   
    urb->UrbBulkOrInterruptTransfer.TransferBuffer = packet->dataBuffer; 
    urb->UrbBulkOrInterruptTransfer.TransferFlags = USBD_SHORT_TRANSFER_OK | USBD_TRANSFER_DIRECTION_OUT;
    urb->UrbBulkOrInterruptTransfer.UrbLink = NULL;

    status = SubmitUrbIrp(  adapter->nextDevObj, 
                            irp,
							urb, 
							FALSE,					// asynchronous
							WritePipeCompletion,    // completion routine
							packet				    // completion context
				            );

    if (!NT_SUCCESS(status)){
        DBGERR(("SubmitUSBWritePacket: packet @ %ph status %xh.", packet, status));
    }

    return status;
}



NTSTATUS WritePipeCompletion(IN PDEVICE_OBJECT devObj, IN PIRP irp, IN PVOID context)
{
	USBPACKET *packet = (USBPACKET *)context;
    ADAPTEREXT *adapter = packet->adapter;
	NTSTATUS status = irp->IoStatus.Status;
	KIRQL oldIrql;

	ASSERT(packet->sig == DRIVER_SIG);
    ASSERT(adapter->sig == DRIVER_SIG);
    ASSERT(packet->irpPtr == irp);
    ASSERT(!irp->CancelRoutine);
    ASSERT(status != STATUS_PENDING);  // saw UHCD doing this ?

    if (NT_SUCCESS(status)){
        DBGVERBOSE(("WritePipeCompletion: packet # %xh completed.", packet->packetId));
    }
    else {
        DBGWARN(("WritePipeCompletion: packet # %xh failed with status %xh on adapter %xh.", packet->packetId, status, adapter));
    }

    IndicateSendStatusToRNdis(packet, status);

    /*
     *  Dequeue the packet from the usbPendingWritePackets queue 
     *  BEFORE checking if it was cancelled to avoid race with CancelAllPendingPackets.
     */
    DequeuePendingWritePacket(packet);

    if (packet->cancelled){
        /*
         *  This packet was cancelled because of a halt or reset.
         *  Put the packet back in the free list first, then 
         *  set the event so CancelAllPendingPackets can proceed.
         */
        DBGVERBOSE(("    ... write packet #%xh cancelled.", packet->packetId));
        packet->cancelled = FALSE;

        EnqueueFreePacket(packet);
        KeSetEvent(&packet->cancelEvent, 0, FALSE);
    }
    else {
        EnqueueFreePacket(packet);
    }


	return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS SubmitNotificationRead(ADAPTEREXT *adapter, BOOLEAN synchronous)
{
    NTSTATUS status;
    PURB urb = adapter->notifyUrbPtr;
    PIRP irp = adapter->notifyIrpPtr;
    ULONG guardWord = GUARD_WORD;
    KIRQL oldIrql;

    ASSERT(adapter->notifyPipeHandle);
    DBGVERBOSE(("SubmitNotificationRead: read %xh bytes.", adapter->notifyPipeLength));
    /*
     * Fill the notify buffer with invalid data just in case a device replies with
     * no data at all. A previously received valid message may still be there.
     * Apparently it won't be overwritten by the USB stack unless the device
     * supplies data.
     */
    RtlFillMemory(adapter->notifyBuffer, adapter->notifyPipeLength, 0xfe);

    /*
     *  Place a guard word at the end of the notify buffer
     *  to catch overwrites by the host controller (which we've seen).
     *  Use RtlCopyMemory in case pointer is unaligned.
     */
    RtlCopyMemory(adapter->notifyBuffer+adapter->notifyPipeLength, &guardWord, sizeof(ULONG));

    /*
     *  The notify pipe actually fills out a buffer with the fields given
     *  in the spec as URB fields.  Read the notify pipe like any interrupt pipe.
     */
	urb->UrbBulkOrInterruptTransfer.Hdr.Function = URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER;
	urb->UrbBulkOrInterruptTransfer.Hdr.Length = sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER);
	urb->UrbBulkOrInterruptTransfer.PipeHandle = adapter->notifyPipeHandle;
	urb->UrbBulkOrInterruptTransfer.TransferBufferLength = adapter->notifyPipeLength;
	urb->UrbBulkOrInterruptTransfer.TransferBufferMDL = NULL;
	urb->UrbBulkOrInterruptTransfer.TransferBuffer = adapter->notifyBuffer;
	urb->UrbBulkOrInterruptTransfer.TransferFlags = USBD_SHORT_TRANSFER_OK | USBD_TRANSFER_DIRECTION_IN;
	urb->UrbBulkOrInterruptTransfer.UrbLink = NULL;

    KeAcquireSpinLock(&adapter->adapterSpinLock, &oldIrql);
    adapter->notifyBufferCurrentLength = 0;
    adapter->notifyStopped = FALSE;
    KeReleaseSpinLock(&adapter->adapterSpinLock, oldIrql);

    if (synchronous){
        status = SubmitUrbIrp(adapter->nextDevObj, irp, urb, TRUE, NULL, NULL);
    }
    else {
        status = SubmitUrbIrp(  adapter->nextDevObj, 
                                irp,
							    urb, 
							    FALSE,					    // asynchronous
							    NotificationCompletion,     // completion routine
							    adapter				        // completion context
                            );
    }

    return status;
}


NTSTATUS NotificationCompletion(IN PDEVICE_OBJECT devObj, IN PIRP irp, IN PVOID context)
{
    ADAPTEREXT *adapter = context;
    PURB urb = adapter->notifyUrbPtr;
	NTSTATUS status = irp->IoStatus.Status;
    BOOLEAN notifyStopped = FALSE;
    BOOLEAN setCancelEvent = FALSE;
    ULONG guardWord;
    KIRQL oldIrql;

    ASSERT(adapter->sig == DRIVER_SIG);
    ASSERT(irp == adapter->notifyIrpPtr);
    ASSERT(!irp->CancelRoutine);
    ASSERT(status != STATUS_PENDING);  // saw UHCD doing this ?

    /*
     *  Check the guard word at the end of the notify buffer
     *  to catch overwrites by the host controller
     *  (we've seen this on VIA host controllers).
     *  Use RtlCopyMemory in case pointer is unaligned.
     */
    RtlCopyMemory(&guardWord, adapter->notifyBuffer+adapter->notifyPipeLength, sizeof(ULONG));
    if (guardWord != GUARD_WORD){
        ASSERT(guardWord == GUARD_WORD);

        #ifndef SPECIAL_WIN98SE_BUILD
        {
            /*
             *  Raise an exception so we catch this in retail builds.
             */
            EXCEPTION_RECORD exceptionRec;
            exceptionRec.ExceptionCode = STATUS_ADAPTER_HARDWARE_ERROR;
            exceptionRec.ExceptionFlags = EXCEPTION_NONCONTINUABLE_EXCEPTION;
            exceptionRec.ExceptionRecord = NULL;
            exceptionRec.ExceptionAddress = (PVOID)NotificationCompletion; // actual fault is in bus-mastering hardware
            exceptionRec.NumberParameters = 0;
            // ExRaiseException(&exceptionRec); 
            // Changed to KeBugCheckEx since ExRaiseException is not a WDM call.
            // We want to be loadable on WinMe.
            KeBugCheckEx(FATAL_UNHANDLED_HARD_ERROR,
                         STATUS_ADAPTER_HARDWARE_ERROR,
                         (ULONG_PTR)adapter,
                         (ULONG_PTR)guardWord,
                         (ULONG_PTR)NULL);
        }
        #endif
    }

    /*
     *  In order to synchronize with CancelAllPendingPackets,
     *  we need to either send the irp down again, mark the notifyIrp as stopped,
     *  or set the notifyCancelEvent.
     */
    KeAcquireSpinLock(&adapter->adapterSpinLock, &oldIrql);
    if (adapter->cancellingNotify){
        /*
         *  This irp was cancelled by CancelAllPendingPackets.
         *  After dropping the spinlock, we'll set the cancel event 
         *  so that CancelAllPendingPackets stops waiting.
         */
        notifyStopped = TRUE;
        setCancelEvent = TRUE;
    }
    else if (!NT_SUCCESS(status)){
        /*
         *  The notify irp can get failed on an unplug BEFORE we get the halted.
         *  Since we're not going to send the notify IRP down again, we need to 
         *  make sure that we don't wait for it forever in CancelAllPendingPackets.
         *  We do this by synchronously setting notifyStopped  
         *  as an indication that this irp doesn't need to be cancelled.
         */
        DBGWARN(("NotificationCompletion: read failed with status %xh on adapter %xh (urb status = %xh).", status, adapter, urb->UrbHeader.Status));
        notifyStopped = adapter->notifyStopped = TRUE;
    }
    KeReleaseSpinLock(&adapter->adapterSpinLock, oldIrql);


    if (!notifyStopped){
        ULONG notifyLen = urb->UrbBulkOrInterruptTransfer.TransferBufferLength;

        ASSERT(notifyLen <= adapter->notifyPipeLength);
        adapter->notifyBufferCurrentLength = MIN(notifyLen, adapter->notifyPipeLength);

        RNDISProcessNotification(adapter);

        SubmitNotificationRead(adapter, FALSE);
    }

    if (setCancelEvent){
        DBGVERBOSE(("    ... notify read packet cancelled."));
        KeSetEvent(&adapter->notifyCancelEvent, 0, FALSE);
    }

	return STATUS_MORE_PROCESSING_REQUIRED;
}




NTSTATUS SubmitPacketToControlPipe( USBPACKET *packet,
                                    BOOLEAN synchronous,
                                    BOOLEAN simulated)
{
    NTSTATUS status;
    ADAPTEREXT *adapter = packet->adapter;
    PURB urb = packet->urbPtr;
    PIRP irp = packet->irpPtr;
    PUSBD_INTERFACE_INFORMATION interfaceInfoControl;

    DBGVERBOSE(("SubmitPacketToControlPipe: packet # %xh.", packet->packetId));
    DBGSHOWBYTES("SubmitPacketToControlPipe", packet->dataBuffer, packet->dataBufferCurrentLength);

    ASSERT(adapter->interfaceInfoMaster);
    interfaceInfoControl = adapter->interfaceInfoMaster;

    urb->UrbHeader.Length = (USHORT) sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST);
    urb->UrbHeader.Function = URB_FUNCTION_CLASS_INTERFACE;  
    urb->UrbControlVendorClassRequest.Reserved = 0;
    urb->UrbControlVendorClassRequest.TransferFlags = USBD_TRANSFER_DIRECTION_OUT;
    urb->UrbControlVendorClassRequest.TransferBufferLength = packet->dataBufferCurrentLength;
    urb->UrbControlVendorClassRequest.TransferBuffer = packet->dataBuffer;
    urb->UrbControlVendorClassRequest.TransferBufferMDL = NULL;
    urb->UrbControlVendorClassRequest.UrbLink = NULL;
    urb->UrbControlVendorClassRequest.RequestTypeReservedBits = 0;
    urb->UrbControlVendorClassRequest.Request = NATIVE_RNDIS_SEND_ENCAPSULATED_COMMAND;
    urb->UrbControlVendorClassRequest.Value = 0;
    urb->UrbControlVendorClassRequest.Index = interfaceInfoControl->InterfaceNumber; 
    urb->UrbControlVendorClassRequest.Reserved1 = 0;

    if (synchronous){
        /*
         *  Send the URB down synchronously,
         *  then call the completion routine to clean up ourselves.
         */
        status = SubmitUrbIrp(adapter->nextDevObj, irp, urb, TRUE, NULL, NULL);
        if (!simulated){
            ControlPipeWriteCompletion(adapter->nextDevObj, irp, packet);
        }
    }
    else {
        status = SubmitUrbIrp(  adapter->nextDevObj,
                                irp,
							    urb,
							    FALSE,					// asynchronous
							    ControlPipeWriteCompletion,  // completion routine
							    packet				    // completion context
				                );
    }

    return status;
}


NTSTATUS ControlPipeWriteCompletion(IN PDEVICE_OBJECT devObj, IN PIRP irp, IN PVOID context)
{
	USBPACKET *packet = (USBPACKET *)context;
    ADAPTEREXT *adapter = packet->adapter;
	NTSTATUS status = irp->IoStatus.Status;
	KIRQL oldIrql;

	ASSERT(packet->sig == DRIVER_SIG);
    ASSERT(adapter->sig == DRIVER_SIG);
    ASSERT(packet->irpPtr == irp);
    ASSERT(!irp->CancelRoutine);
    ASSERT(status != STATUS_PENDING);  // saw UHCD doing this ?

    if (NT_SUCCESS(status)){
        DBGVERBOSE(("ControlPipeWriteCompletion: packet # %xh completed.", packet->packetId));
    }
    else {
        DBGWARN(("ControlPipeWriteCompletion: packet # %xh failed with status %xh on adapter %xh.", packet->packetId, status, adapter));
    }

    IndicateSendStatusToRNdis(packet, status);

    /*
     *  Dequeue the packet from the usbPendingWritePackets queue 
     *  BEFORE checking if it was cancelled to avoid race with CancelAllPendingPackets.
     */
    DequeuePendingWritePacket(packet);

    if (packet->cancelled){
        /*
         *  This packet was cancelled because of a halt or reset.
         *  Put the packet back in the free list first, then 
         *  set the event so CancelAllPendingPackets can proceed.
         */
        DBGVERBOSE(("    ... write packet #%xh cancelled.", packet->packetId));
        packet->cancelled = FALSE;

        EnqueueFreePacket(packet);
        KeSetEvent(&packet->cancelEvent, 0, FALSE);
    }
    else {
        EnqueueFreePacket(packet);
    }

    if (NT_SUCCESS(status)){
    }
    else {
        #if DO_FULL_RESET
            adapter->needFullReset = TRUE;
            QueueAdapterWorkItem(adapter);
        #endif
    }

	return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS ReadPacketFromControlPipe(USBPACKET *packet, BOOLEAN synchronous)
{
    NTSTATUS status;
    ADAPTEREXT *adapter = packet->adapter;
    PURB urb = packet->urbPtr;
    PIRP irp = packet->irpPtr;
    PUSBD_INTERFACE_INFORMATION interfaceInfoControl;
    ULONG bytesToRead = MAXIMUM_DEVICE_MESSAGE_SIZE+1;

    DBGVERBOSE(("ReadPacketFromControlPipe: read %xh bytes, packet #%xh.", bytesToRead, packet->packetId));

    ASSERT(adapter->interfaceInfoMaster);
    interfaceInfoControl = adapter->interfaceInfoMaster;
  
    urb->UrbHeader.Length = (USHORT) sizeof(struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST);
    urb->UrbHeader.Function = URB_FUNCTION_CLASS_INTERFACE; 
    urb->UrbControlVendorClassRequest.Reserved = 0;
    urb->UrbControlVendorClassRequest.TransferFlags = USBD_SHORT_TRANSFER_OK | USBD_TRANSFER_DIRECTION_IN;
    urb->UrbControlVendorClassRequest.TransferBufferLength = bytesToRead;
    urb->UrbControlVendorClassRequest.TransferBuffer = packet->dataBuffer;
    urb->UrbControlVendorClassRequest.TransferBufferMDL = NULL;
    urb->UrbControlVendorClassRequest.UrbLink = NULL;
    urb->UrbControlVendorClassRequest.RequestTypeReservedBits = 0;
    urb->UrbControlVendorClassRequest.Request = NATIVE_RNDIS_GET_ENCAPSULATED_RESPONSE;
    urb->UrbControlVendorClassRequest.Value = 0;
    urb->UrbControlVendorClassRequest.Index = interfaceInfoControl->InterfaceNumber; 
    urb->UrbControlVendorClassRequest.Reserved1 = 0;

    if (synchronous){
        status = SubmitUrbIrp(adapter->nextDevObj, irp, urb, TRUE, NULL, NULL);
    }
    else {
        status = SubmitUrbIrp(  adapter->nextDevObj, 
                                irp,
							    urb, 
							    FALSE,					    // asynchronous
							    ControlPipeReadCompletion,  // completion routine
							    packet				        // completion context
				                );
    }

    ASSERT(NT_SUCCESS(status));
    return status;
}



NTSTATUS ControlPipeReadCompletion(IN PDEVICE_OBJECT devObj, IN PIRP irp, IN PVOID context)
{
	USBPACKET *packet = (USBPACKET *)context;
    ADAPTEREXT *adapter = packet->adapter;
	NTSTATUS status = irp->IoStatus.Status;
	KIRQL oldIrql;

	ASSERT(packet->sig == DRIVER_SIG);
    ASSERT(adapter->sig == DRIVER_SIG);
    ASSERT(packet->irpPtr == irp);
    ASSERT(!irp->CancelRoutine);
    ASSERT(status != STATUS_PENDING);  // saw UHCD doing this ?

    /*
     *  Dequeue the packet from the usbPendingReadPackets queue 
     *  BEFORE checking if it was cancelled to avoid race with CancelAllPendingPackets.
     */
    DequeuePendingReadPacket(packet);

    if (packet->cancelled){
        /*
         *  This packet was cancelled because of a halt or reset.
         *  Get the packet is back in the free list first, then
         *  set the event so CancelAllPendingPackets can proceed.
         */
        DBGVERBOSE(("    ... read packet #%xh cancelled.", packet->packetId));
        packet->cancelled = FALSE;

        EnqueueFreePacket(packet);
        KeSetEvent(&packet->cancelEvent, 0, FALSE);
    }
    else if (adapter->halting){
        EnqueueFreePacket(packet);
    }
    else {
        if (NT_SUCCESS(status)){
            PURB urb = packet->urbPtr;
            
            /*
             *  Fix the packet's dataBufferCurrentLength to indicate the actual length
             *  of the returned data.
             *  Note:  the KLSI device rounds this up to a multiple of the endpoint
             *         packet size, so the returned length may actually be larger than
             *         the actual data.
             */
            packet->dataBufferCurrentLength = urb->UrbBulkOrInterruptTransfer.TransferBufferLength;
            ASSERT(packet->dataBufferCurrentLength);
            ASSERT(packet->dataBufferCurrentLength <= packet->dataBufferMaxLength);

            DBGVERBOSE(("ControlPipeReadCompletion: packet # %xh.", packet->packetId));
            DBGSHOWBYTES("ControlPipeReadCompletion", packet->dataBuffer, packet->dataBufferCurrentLength);

            EnqueueCompletedReadPacket(packet);

            status = IndicateRndisMessage(packet, FALSE);

            if (status != STATUS_PENDING){
                DequeueCompletedReadPacket(packet);
                EnqueueFreePacket(packet);
            }
        }
        else {
            /*
             *  The read failed.  Put the packet back in the free list.
             */
            DBGWARN(("ControlPipeReadCompletion: read failed with status %xh on adapter %xh.", status, adapter));
            EnqueueFreePacket(packet);

            #if DO_FULL_RESET
                adapter->needFullReset = TRUE;
                QueueAdapterWorkItem(adapter);
            #endif
        }

    }


	return STATUS_MORE_PROCESSING_REQUIRED;
}



NTSTATUS CallDriverSync(PDEVICE_OBJECT devObj, PIRP irp)
/*++

Routine Description:

      Call IoCallDriver to send the irp to the device object;
      then, synchronize with the completion routine.
      When CallDriverSync returns, the action has completed
      and the irp again belongs to the current driver.

      NOTE:  In order to keep the device object from getting freed
             while this IRP is pending, you should call
             IncrementPendingActionCount() and 
             DecrementPendingActionCount()
             around the CallDriverSync call.

Arguments:

    devObj - targetted device object
    irp - Io Request Packet

Return Value:

    NT status code, indicates result returned by lower driver for this IRP.

--*/
{
    KEVENT event;
    NTSTATUS status;

    ASSERT(KeGetCurrentIrql() <= APC_LEVEL);

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
    IoSetCompletionRoutine( irp, 
                            CallDriverSyncCompletion, 
                            &event,     // context
                            TRUE, TRUE, TRUE);

    status = IoCallDriver(devObj, irp);

    KeWaitForSingleObject(  &event,
                            Executive,      // wait reason
                            KernelMode,
                            FALSE,          // not alertable
                            NULL );         // no timeout

    status = irp->IoStatus.Status;

    ASSERT(status != STATUS_PENDING);
    if (!NT_SUCCESS(status)){
        DBGWARN(("CallDriverSync: irp failed w/ status %xh.", status));
    }

    return status;
}


NTSTATUS CallDriverSyncCompletion(IN PDEVICE_OBJECT devObjOrNULL, IN PIRP irp, IN PVOID context)
/*++

Routine Description:

      Completion routine for CallDriverSync.

Arguments:

    devObjOrNULL - 
            Usually, this is this driver's device object.
             However, if this driver created the IRP, 
             there is no stack location in the IRP for this driver;
             so the kernel has no place to store the device object;
             ** so devObj will be NULL in this case **.

    irp - completed Io Request Packet
    context - context passed to IoSetCompletionRoutine by CallDriverSync. 

    
Return Value:

    NT status code, indicates result returned by lower driver for this IRP.

--*/
{
    PKEVENT event = context;

    ASSERT(!irp->CancelRoutine);

    if (!NT_SUCCESS(irp->IoStatus.Status)){
        DBGWARN(("CallDriverSyncCompletion: irp failed w/ status %xh.", irp->IoStatus.Status));
    }

    KeSetEvent(event, 0, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


#if 0
    NTSTATUS GetStringDescriptor(   ADAPTEREXT *adapter, 
                                    UCHAR stringIndex, 
                                    PUCHAR buffer, 
                                    ULONG bufferLen)
    /*++

    Routine Description:

        Function retrieves a string descriptor from the device

    Arguments:

        adapter - adapter context

    Return Value:

        NT status code

    --*/
    {
        URB urb;
        NTSTATUS status;

        UsbBuildGetDescriptorRequest(&urb,
                                     (USHORT) sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                     USB_STRING_DESCRIPTOR_TYPE,
                                     stringIndex,
                                     0x0409,    // language = US English
                                     buffer,
                                     NULL,
                                     bufferLen,
                                     NULL);

        status = SubmitUrb(adapter->nextDevObj, &urb, TRUE, NULL, NULL);

        if (NT_SUCCESS(status)){
            DBGVERBOSE(("Got string desc (index %xh) @ %ph, len = %xh.", (ULONG)stringIndex, buffer, urb.UrbControlDescriptorRequest.TransferBufferLength));
            ASSERT(urb.UrbControlDescriptorRequest.TransferBufferLength <= bufferLen);
        }
        else {
            DBGERR(("GetStringDescriptor: failed to get string (index %xh) with status %xh on adapter %xh.", (ULONG)stringIndex, status, adapter));
        }

        ASSERT(NT_SUCCESS(status));
        return status;
    }


    /*
     *  CreateSingleInterfaceConfigDesc
     *
     *      Allocate a configuration descriptor that excludes all interfaces
     *  but the given interface
     *  (e.g. for multiple-interface devices like the Intel cable modem,
     *        for which we don't load on top of the generic parent).
     *
     *  Note:  interfaceDesc must point inside configDesc.
     *
     */
    PUSB_CONFIGURATION_DESCRIPTOR CreateSingleInterfaceConfigDesc(
                                    PUSB_CONFIGURATION_DESCRIPTOR configDesc, 
                                    PUSB_INTERFACE_DESCRIPTOR interfaceDesc)
    {
        PUSB_CONFIGURATION_DESCRIPTOR ifaceConfigDesc;
    
        ASSERT(interfaceDesc);
        ASSERT((PVOID)interfaceDesc > (PVOID)configDesc);
        ASSERT((PUCHAR)interfaceDesc - (PUCHAR)configDesc < configDesc->wTotalLength);

        ifaceConfigDesc = AllocPool(configDesc->wTotalLength);
        if (ifaceConfigDesc){
            PUSB_COMMON_DESCRIPTOR srcDesc, newDesc;
            USHORT totalLen;

            /*
             *  Copy the configuration descriptor itself.
             */
            RtlCopyMemory(ifaceConfigDesc, configDesc, configDesc->bLength);
            totalLen = configDesc->bLength;

            /*
             *  Copy the given interface descriptor.
             */
            srcDesc = (PUSB_COMMON_DESCRIPTOR)interfaceDesc;
            newDesc = (PUSB_COMMON_DESCRIPTOR)((PUCHAR)ifaceConfigDesc + ifaceConfigDesc->bLength);
            RtlCopyMemory(newDesc, srcDesc, srcDesc->bLength);
            totalLen += srcDesc->bLength;
            srcDesc = (PUSB_COMMON_DESCRIPTOR)((PUCHAR)srcDesc + srcDesc->bLength);
            newDesc = (PUSB_COMMON_DESCRIPTOR)((PUCHAR)newDesc + newDesc->bLength);

            /*
             *  Copy the given interface descriptors and all following descriptors
             *  up to either the next interface descriptor or the end of the original
             *  configuration descriptor.
             */
            while ((PUCHAR)srcDesc - (PUCHAR)configDesc < configDesc->wTotalLength){
                if (srcDesc->bDescriptorType == USB_INTERFACE_DESCRIPTOR_TYPE){
                    break;
                }
                else {
                    RtlCopyMemory(newDesc, srcDesc, srcDesc->bLength);
                    totalLen += srcDesc->bLength;
                    srcDesc = (PUSB_COMMON_DESCRIPTOR)((PUCHAR)srcDesc + srcDesc->bLength);
                    newDesc = (PUSB_COMMON_DESCRIPTOR)((PUCHAR)newDesc + newDesc->bLength);
                }
            }

            ifaceConfigDesc->bNumInterfaces = 1;
            ifaceConfigDesc->wTotalLength = totalLen;
            DBGVERBOSE(("CreateSingleInterfaceConfigDesc: build partial configDesc @ %ph, len=%xh.", ifaceConfigDesc, ifaceConfigDesc->wTotalLength));
        }
    
        return ifaceConfigDesc;
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\ccfg9x\clsutil.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright (c) 1994-1998 Microsoft Corporation
//*********************************************************************

//
//  CLSUTIL.C - some small, useful C++ classes to wrap memory allocation,
//        registry access, etc.
//

//  HISTORY:
//  
//  12/07/94  jeremys Borrowed from WNET common library
//  96/05/22  markdu  Borrowed (from inetcfg.dll)
//

#include "pch.hpp"

BOOL BUFFER::Alloc( UINT cbBuffer )
{
  _lpBuffer = (LPSTR)::GlobalAlloc(GPTR,cbBuffer);
  if (_lpBuffer != NULL) {
    _cb = cbBuffer;
    return TRUE;
  }
  return FALSE;
}

BOOL BUFFER::Realloc( UINT cbNew )
{
  LPVOID lpNew = ::GlobalReAlloc((HGLOBAL)_lpBuffer, cbNew,
    GMEM_MOVEABLE | GMEM_ZEROINIT);
  if (lpNew == NULL)
    return FALSE;

  _lpBuffer = (LPSTR)lpNew;
  _cb = cbNew;
  return TRUE;
}

BUFFER::BUFFER( UINT cbInitial /* =0 */ )
  : BUFFER_BASE(),
  _lpBuffer( NULL )
{
  if (cbInitial)
    Alloc( cbInitial );
}

BUFFER::~BUFFER()
{
  if (_lpBuffer != NULL) {
    GlobalFree((HGLOBAL) _lpBuffer);
    _lpBuffer = NULL;
  }
}

BOOL BUFFER::Resize( UINT cbNew )
{
  BOOL fSuccess;

  if (QuerySize() == 0)
    fSuccess = Alloc( cbNew );
  else {
    fSuccess = Realloc( cbNew );
  }
  if (fSuccess)
    _cb = cbNew;
  return fSuccess;
}

RegEntry::RegEntry(const char *pszSubKey, HKEY hkey)
{
  _error = RegCreateKey(hkey, pszSubKey, &_hkey);
  if (_error) {
    bhkeyValid = FALSE;
  }
  else {
    bhkeyValid = TRUE;
  }
}

RegEntry::~RegEntry()
{ 
    if (bhkeyValid) {
        RegCloseKey(_hkey); 
    }
}

long RegEntry::SetValue(const char *pszValue, const char *string)
{
    if (bhkeyValid) {
      _error = RegSetValueEx(_hkey, pszValue, 0, REG_SZ,
            (unsigned char *)string, lstrlen(string)+1);
    }
  return _error;
}

long RegEntry::SetValue(const char *pszValue, unsigned long dwNumber)
{
    if (bhkeyValid) {
      _error = RegSetValueEx(_hkey, pszValue, 0, REG_BINARY,
            (unsigned char *)&dwNumber, sizeof(dwNumber));
    }
  return _error;
}

long RegEntry::DeleteValue(const char *pszValue)
{
    if (bhkeyValid) {
      _error = RegDeleteValue(_hkey, (LPTSTR) pszValue);
  }
  return _error;
}


char *RegEntry::GetString(const char *pszValue, char *string, unsigned long length)
{
  DWORD   dwType = REG_SZ;
  
    if (bhkeyValid) {
      _error = RegQueryValueEx(_hkey, (LPTSTR) pszValue, 0, &dwType, (LPBYTE)string,
            &length);
    }
  if (_error) {
    *string = '\0';
     return NULL;
  }

  return string;
}

long RegEntry::GetNumber(const char *pszValue, long dwDefault)
{
   DWORD   dwType = REG_BINARY;
   long  dwNumber = 0L;
   DWORD  dwSize = sizeof(dwNumber);

    if (bhkeyValid) {
      _error = RegQueryValueEx(_hkey, (LPTSTR) pszValue, 0, &dwType, (LPBYTE)&dwNumber,
            &dwSize);
  }
  if (_error)
    dwNumber = dwDefault;
  
  return dwNumber;
}

long RegEntry::MoveToSubKey(const char *pszSubKeyName)
{
    HKEY  _hNewKey;

    if (bhkeyValid) {
        _error = RegOpenKey ( _hkey,
                              pszSubKeyName,
                              &_hNewKey );
        if (_error == ERROR_SUCCESS) {
            RegCloseKey(_hkey);
            _hkey = _hNewKey;
        }
    }

  return _error;
}

long RegEntry::FlushKey()
{
    if (bhkeyValid) {
      _error = RegFlushKey(_hkey);
    }
  return _error;
}

RegEnumValues::RegEnumValues(RegEntry *pReqRegEntry)
 : pRegEntry(pReqRegEntry),
   iEnum(0),
   pchName(NULL),
   pbValue(NULL)
{
    _error = pRegEntry->GetError();
    if (_error == ERROR_SUCCESS) {
        _error = RegQueryInfoKey ( pRegEntry->GetKey(), // Key
                                   NULL,                // Buffer for class string
                                   NULL,                // Size of class string buffer
                                   NULL,                // Reserved
                                   NULL,                // Number of subkeys
                                   NULL,                // Longest subkey name
                                   NULL,                // Longest class string
                                   &cEntries,           // Number of value entries
                                   &cMaxValueName,      // Longest value name
                                   &cMaxData,           // Longest value data
                                   NULL,                // Security descriptor
                                   NULL );              // Last write time
    }
    if (_error == ERROR_SUCCESS) {
        if (cEntries != 0) {
            cMaxValueName = cMaxValueName + 1; // REG_SZ needs one more for null
            cMaxData = cMaxData + 1;           // REG_SZ needs one more for null
            pchName = new CHAR[cMaxValueName];
            if (!pchName) {
                _error = ERROR_NOT_ENOUGH_MEMORY;
            }
            else {
                if (cMaxData) {
                    pbValue = new BYTE[cMaxData];
                    if (!pbValue) {
                        _error = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }
            }
        }
    }
}

RegEnumValues::~RegEnumValues()
{
    delete pchName;
    delete pbValue;
}

long RegEnumValues::Next()
{
    if (_error != ERROR_SUCCESS) {
        return _error;
    }
    if (cEntries == iEnum) {
        return ERROR_NO_MORE_ITEMS;
    }

    DWORD   cchName = cMaxValueName;

    dwDataLength = cMaxData;
    _error = RegEnumValue ( pRegEntry->GetKey(), // Key
                            iEnum,               // Index of value
                            pchName,             // Address of buffer for value name
                            &cchName,            // Address for size of buffer
                            NULL,                // Reserved
                            &dwType,             // Data type
                            pbValue,             // Address of buffer for value data
                            &dwDataLength );     // Address for size of data
    iEnum++;
    return _error;
}

int __cdecl _purecall(void)
{
   return(0);
}

void * _cdecl operator new(unsigned int size)
{
  return (void *)::GlobalAlloc(GPTR,size); 
}

void _cdecl operator delete(void *ptr)
{
  GlobalFree(ptr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\ccfg9x\debug.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright (c) 1994-1998 Microsoft Corporation         **
//*********************************************************************

// ############################################################################
// Debugging routines

#include "pch.hpp"

BOOL fInAssert=FALSE;

// ############################################################################
// DebugSz
//
// This function outputs debug string
// 
//  Created 1/28/96,		Chris Kauffman
// ############################################################################
void DebugSz(PCSTR psz)
{
	OutputDebugString(psz);
} // DebugSz

// ############################################################################
// Debug Printf to debug output screen
void Dprintf(PCSTR pcsz, ...)
{
#ifdef DEBUG
	va_list	argp;
	char	szBuf[1024];
	
	va_start(argp, pcsz);

	wvsprintf(szBuf, pcsz, argp);

	DebugSz(szBuf);
	va_end(argp);
#endif
} // Dprintf()

// ############################################################################
// Handle asserts
BOOL FAssertProc(PCSTR szFile,  DWORD dwLine, PCSTR szMsg, DWORD dwFlags)
{
	char szMsgEx[1024], szTitle[255], szFileName[MAX_PATH];
	int id;
	UINT fuStyle;
	BOOL fAssertIntoDebugger = FALSE;
	LPTSTR pszCommandLine = GetCommandLine();
	HANDLE	hAssertTxt;
	//BYTE	szTime[80];
	CHAR	szTime[80];
	SYSTEMTIME st;
	DWORD	cbWritten;
	
	// no recursive asserts
	if (fInAssert)
		{
		DebugSz("***Recursive Assert***\r\n");
		return(FALSE);
		}

	fInAssert = TRUE;
	
	GetModuleFileName(NULL, szFileName, MAX_PATH);
	wsprintf(szMsgEx,"%s:#%d\r\nProcess ID: %d %s, Thread ID: %d\r\n%s",
		szFile,dwLine,GetCurrentProcessId(),szFileName,GetCurrentThreadId(),szMsg);
	wsprintf(szTitle,"Assertion Failed");

	fuStyle = MB_APPLMODAL | MB_ABORTRETRYIGNORE;
	fuStyle |= MB_ICONSTOP;

	DebugSz(szTitle);		
	DebugSz(szMsgEx);		

	// dump the assert into ASSERT.TXT
	hAssertTxt = CreateFile("assert.txt", GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH, NULL);
	if (INVALID_HANDLE_VALUE != hAssertTxt) 
		{
		SetFilePointer(hAssertTxt, 0, NULL, FILE_END);
		GetLocalTime(&st);
		wsprintf(szTime, "\r\n\r\n%02d/%02d/%02d %d:%02d:%02d\r\n", st.wMonth, st.wDay, st.wYear, st.wHour, st.wMinute, st.wSecond);
		WriteFile(hAssertTxt, szTime, lstrlen(szTime), &cbWritten, NULL);
		WriteFile(hAssertTxt, szMsgEx, lstrlen(szMsgEx), &cbWritten, NULL);
		CloseHandle(hAssertTxt);
		}

    id = MessageBox(NULL, szMsgEx, szTitle, fuStyle);
    switch (id)
    	{
    	case IDABORT:
    		ExitProcess(0);
    		break;
    	case IDCANCEL:
    	case IDIGNORE:
    		break;
    	case IDRETRY:
    		fAssertIntoDebugger = TRUE;
    		break;
    	}
				
	fInAssert = FALSE;
	return(fAssertIntoDebugger);
} // AssertProc()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\ccfg9x\ids.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright (c) 1994-1998 Microsoft Corporation
//*********************************************************************

// string resource IDs
#define IDS_APPNAME                   1000
#define IDS_ERRFORMAT                 1001
#define IDS_EXEC_GRPCONV              1002
#define IDS_EXEC_GRPCONV_PARAM        1003
#define IDS_MAIL_WIZARD_REG_VAL       1004
#define IDS_DEF_COMPUTER_NAME         1005
#define IDS_DEF_WORKGROUP_NAME        1006
#define IDS_ERROutOfMemory            1100
#define IDS_ERRReadConfig             1101
#define IDS_ERRInstallTCPIP           1102
#define IDS_ERRInstallPPPMAC          1103
#define IDS_ERRInstallFiles           1104
#define IDS_ERRWriteDNS               1105

// dialog page IDs
//
// ChrisK 6/3/97 Olympus 5425
// Removed unused dialog
//
//#define IDD_SECURITY_CHECK            2000
#define IDD_DNS_WARNING               2001

#ifdef IDC_HELP
#undef IDC_HELP
#endif

// dialog control IDs
#define IDC_UNUSED                    -1
#define IDC_DISABLE_CHECK             2100
#define IDC_DISABLE_WARNING           2101

// icon IDs
#define IDI_WORLD                     2200
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\ccfg9x\fltthk.inc ===
;//*********************************************************************
;//*                  Microsoft Windows                               **
;//*            Copyright (c) 1994-1998 Microsoft Corporation         **
;//*********************************************************************

; File: fltthk.inc
;
;   Support macros and routines for the flat thunk mode of the thunk
;   compiler.
;
;   Included in *.asm files generated using the 
;   "flatthunks = true" semantic.
;





; Macro: FAPILOG16. Prints out a log message at the start of each thunk.
; Debug only.
FAPILOG16	macro	dwOffset
ifdef DEBUG
	pushd	offset FT_ThunkLogNames + dwOffset
	call	FAPILOG16_Hlp
endif ;DEBUG
endm ;FAPILOG16




ifdef DEBUG

LogApiThkLSF	proto	near stdcall, psz:dword

FAPILOG16_Hlp:
	push	ebp
	mov	ebp,[esp+8]

	invoke	LogApiThkLSF, ebp

	pop	ebp
	ret	4

endif ;DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\ccfg9x\debug.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright (c) 1994-1998 Microsoft Corporation         **
//*********************************************************************
#ifndef _PHBKDEBUG
#define _PHBKDEBUG

//#ifdef __cplusplus
//extern "C" {
//#endif // __cplusplus
	void Dprintf(PCSTR pcsz, ...);
//#ifdef __cplusplus
//}
//#endif // __cplusplus

#ifdef DEBUG
//#ifdef __cplusplus
//extern "C" {
//#endif // __cplusplus
	BOOL FAssertProc(PCSTR szFile,  DWORD dwLine, PCSTR szMsg, DWORD dwFlags);
	void DebugSz(PCSTR psz);
//#ifdef __cplusplus
//}
//#endif // __cplusplus
	#define AssertSzFlg(f, sz, dwFlg)		( (f) ? 0 : FAssertProc(__FILE__, __LINE__, sz, dwFlg) ? DebugBreak() : 1 )
	#define AssertSz(f, sz)				AssertSzFlg(f, sz, 0)
	#define Assert(f)					AssertSz((f), "!(" #f ")")
#else
	#define DebugSz(x)
	#define AssertSzFlg(f, sz, dwFlg) f
	#define AssertSz(f, sz) f
	#define Assert(f) f
#endif
#endif //_PHBKDEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\ccfg9x\cfgtcp.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright (c) 1994-1998 Microsoft Corporation
//*********************************************************************

//
//  TCPCFG.C - Functions to read and set TCP/IP configuration
//

//  HISTORY:
//  
//  96/05/22  markdu  Created (from inetcfg.dll)
//

#include "pch.hpp"
// function prototypes
UINT DetectModifyTCPIPBindings(DWORD dwCardFlags,LPCSTR pszBoundTo,BOOL fRemove,BOOL * pfBound);

//*******************************************************************
//              
//  FUNCTION:   IcfgIsGlobalDNS
//
//  PURPOSE:    Determines whether there is Global DNS set.
//
//  PARAMETERS: lpfGlobalDNS - TRUE if global DNS is set, FALSE otherwise.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//              NOTE:  This function is for Windows 95 only, and 
//              should always return ERROR_SUCCESS and set lpfGlobalDNS
//              to FALSE in Windows NT.
//
//*******************************************************************

extern "C" HRESULT IcfgIsGlobalDNS(LPBOOL lpfGlobalDNS)
{
  CHAR szDNSEnabled[2];    // big enough for "1"
  BOOL fGlobalDNS = FALSE;

  // open the global TCP/IP key
  RegEntry reTcp(szTCPGlobalKeyName,HKEY_LOCAL_MACHINE);
  HRESULT hr = reTcp.GetError();
  if (hr == ERROR_SUCCESS)
  {
    // read the registry value to see if DNS is enabled
    reTcp.GetString(szRegValEnableDNS,szDNSEnabled,sizeof(szDNSEnabled));
    hr = reTcp.GetError();
    if ((hr == ERROR_SUCCESS) && (!lstrcmpi(szDNSEnabled,sz1)))
    {
      // DNS is enabled
      fGlobalDNS = TRUE;
    }
  }

  if (NULL != lpfGlobalDNS)
  {
    *lpfGlobalDNS = fGlobalDNS;
  }

  return hr;
}


//*******************************************************************
//
//  FUNCTION:   IcfgRemoveGlobalDNS
//
//  PURPOSE:    Removes global DNS info from registry.
//
//  PARAMETERS: None.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//              NOTE:  This function is for Windows 95 only, and 
//              should always return ERROR_SUCCESS in Windows NT.
//
//*******************************************************************

extern "C" HRESULT IcfgRemoveGlobalDNS(void)
{
  HRESULT hr = ERROR_SUCCESS;

  // open the global TCP/IP key
  RegEntry reTcp(szTCPGlobalKeyName,HKEY_LOCAL_MACHINE);
  hr = reTcp.GetError();
  ASSERT(hr == ERROR_SUCCESS);

  if (ERROR_SUCCESS == hr)
  {
    // no name servers; disable DNS.  Set registry switch to "0".
    hr = reTcp.SetValue(szRegValEnableDNS,sz0);
    ASSERT(hr == ERROR_SUCCESS);
  }

  return hr;
}


//*******************************************************************
//
//  FUNCTION:   IcfgIsFileSharingTurnedOn
//
//  PURPOSE:    Determines if file server (VSERVER) is bound to TCP/IP
//              for specified driver type (net card or PPP).
//
//  PARAMETERS: dwfDriverType - a combination of DRIVERTYPE_ flags
//              that specify what driver type to check server-TCP/IP
//              bindings for as follows:
//
//                DRIVERTYPE_NET  - net card
//                DRIVERTYPE_PPP	- PPPMAC
//
//              lpfSharingOn - TRUE if bound once or more, FALSE if not bound
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

extern "C" HRESULT IcfgIsFileSharingTurnedOn(DWORD dwfDriverType, LPBOOL lpfSharingOn)
{
  BOOL fBound = FALSE;

  ASSERT(lpfSharingOn);

  // call worker function
  HRESULT hr = DetectModifyTCPIPBindings(dwfDriverType,szVSERVER,FALSE,&fBound);

  if (NULL != lpfSharingOn)
  {
    *lpfSharingOn = fBound;
  }

  return hr;
}


//*******************************************************************
//
//  FUNCTION:   IcfgTurnOffFileSharing
//
//  PURPOSE:    Unbinds file server (VSERVER) from TCP/IP for 
//              specified driver type (net card or PPP).
//
//  PARAMETERS: dwfDriverType - a combination of DRIVERTYPE_ flags
//              that specify what driver type to remove server-TCP/IP
//              bindings for as follows:
//
//                DRIVERTYPE_NET  - net card
//                DRIVERTYPE_PPP	- PPPMAC
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

extern "C" HRESULT IcfgTurnOffFileSharing(DWORD dwfDriverType, HWND hwndParent)
{
  BOOL fBound;

  // call worker function
  return DetectModifyTCPIPBindings(dwfDriverType,szVSERVER,TRUE,&fBound);

}


/*******************************************************************

  NAME:    DetectModifyTCPIPBindings

  SYNOPSIS:  Finds (and optionally removes) bindings between
        VSERVER and TCP/IP for TCP/IP instances on a particular
        card type.

  ENTRY:    dwCardFlags - an INSTANCE_xxx flag to specify what
          card type to find/remove server-TCP/IP bindings for
        pszBoundTo - name of component to look for or modify bindings
          to.  Can be VSERVER or VREDIR
        fRemove - if TRUE, all bindings are removed as we find them.
          If FALSE, bindings are left alone but *pfBound is set
          to TRUE if bindings exist.
        pfBound - pointer to BOOL to be filled in

  EXIT:    ERROR_SUCCESS if successful, or a standard error code

  NOTES:    Worker function for TurnOffFileSharing and IsFileSharingTurnedOn

********************************************************************/
UINT DetectModifyTCPIPBindings(DWORD dwCardFlags,LPCSTR pszBoundTo,
  BOOL fRemove,BOOL * pfBound)
{
  ASSERT(pfBound);
  *pfBound = FALSE;  // assume not bound until proven otherwise

  ENUM_TCP_INSTANCE EnumTcpInstance(dwCardFlags,NT_ENUMNODE);

  UINT err = EnumTcpInstance.GetError();
  if (err != ERROR_SUCCESS)
    return err;

  HKEY hkeyInstance = EnumTcpInstance.Next();

  // for every TCP/IP node in enum branch, look at bindings key.
  // Scan the bindings (values in bindings key), if they begin
  // with the string pszBoundTo ("VSERVER" or "VREDIR") then
  // the binding exists.

  while (hkeyInstance) {
    // open bindings key
    RegEntry reBindings(szRegKeyBindings,hkeyInstance);
    ASSERT(reBindings.GetError() == ERROR_SUCCESS);
    if (reBindings.GetError() == ERROR_SUCCESS) {
      RegEnumValues * preBindingVals = new RegEnumValues(&reBindings);
      ASSERT(preBindingVals);
      if (!preBindingVals)
        return ERROR_NOT_ENOUGH_MEMORY;
  
      // enumerate binding values
      while (preBindingVals->Next() == ERROR_SUCCESS) {
        ASSERT(preBindingVals->GetName()); // should always have a valid ptr
        
        // does this binding begin with the string we were passed in
        // pszBoundTo

        CHAR szBindingVal[SMALL_BUF_LEN+1];
        DWORD dwBoundToLen = lstrlen(pszBoundTo);
        lstrcpy(szBindingVal,preBindingVals->GetName());
        if (((DWORD)lstrlen(szBindingVal)) >= dwBoundToLen) {
          // NULL-terminate the copy at the appropriate place
          // so we can do a strcmp rather than a strncmp, which
          // would involve pulling in C runtime or implementing
          // our own strncmp
          szBindingVal[dwBoundToLen] = '\0';
          if (!lstrcmpi(szBindingVal,pszBoundTo)) {

            *pfBound = TRUE;
            // remove the binding if specified by caller
            if (fRemove) {
              // delete the value
              reBindings.DeleteValue(preBindingVals->GetName());

              // destroy and reconstruct RegEnumValues object, otherwise
              // RegEnumValues api gets confused because we deleted a
              // value during enum
              delete preBindingVals;
              preBindingVals = new RegEnumValues(&reBindings);
              ASSERT(preBindingVals);
              if (!preBindingVals)
                return ERROR_NOT_ENOUGH_MEMORY;
            } else {
              // caller just wants to know if binding exists, we
              // filled in pfBound above so we're done
              return ERROR_SUCCESS;
            }
          }
        }
      }
    }
    hkeyInstance = EnumTcpInstance.Next();
  }

  return ERROR_SUCCESS;
}


/*******************************************************************

  NAME:    ENUM_TCP_INSTANCE::ENUM_TCP_INSTANCE

  SYNOPSIS:  Constructor for class to enumerate TCP/IP registry nodes
        according to type of card they are bound to

  ENTRY:    dwCardFlags - combination of INSTANCE_x flags indicating
          what kind of card to enumerate instances for
        dwNodeFlags  - combination of NT_ flags indicating what
          type of node to return (driver node, enum node)

********************************************************************/
ENUM_TCP_INSTANCE::ENUM_TCP_INSTANCE(DWORD dwCardFlags,DWORD dwNodeFlags) :
  _dwCardFlags (dwCardFlags), _dwNodeFlags (dwNodeFlags)
{
  _hkeyTcpNode = NULL;
  _error = ERROR_SUCCESS;

  // init/reset netcard enumeration
  BeginNetcardTCPIPEnum();
}

/*******************************************************************

  NAME:    ENUM_TCP_INSTANCE::~ENUM_TCP_INSTANCE

  SYNOPSIS:  Destructor for class

********************************************************************/
ENUM_TCP_INSTANCE::~ENUM_TCP_INSTANCE()
{
  // close current TCP node key, if any
  CloseNode();
}

/*******************************************************************

  NAME:    ENUM_TCP_INSTANCE::Next

  SYNOPSIS:  Enumerates next TCP/IP driver node

  EXIT:    Returns an open registry key handle, or NULL if
        no more nodes.

  NOTES:    Caller should not close the HKEY that is returned.  This
        HKEY will be valid until the next time the Next() method
        is called or until the object is destructed.

********************************************************************/
HKEY ENUM_TCP_INSTANCE::Next()
{
  CHAR  szSubkeyName[MAX_PATH+1];

  // close current TCP node key, if any
  CloseNode();

  while (_error == ERROR_SUCCESS) {
    CHAR szInstancePath[SMALL_BUF_LEN+1];
    CHAR szDriverPath[SMALL_BUF_LEN+1];

    if (!GetNextNetcardTCPIPNode(szSubkeyName,sizeof(szSubkeyName),
      _dwCardFlags))
      return NULL;  // no more nodes

    // open the enum branch, find the specified subkey
    RegEntry reEnumNet(szRegPathEnumNet,HKEY_LOCAL_MACHINE);

    // if caller wanted enum node, just open that node

    if (_dwNodeFlags & NT_ENUMNODE) {
    
      _error = RegOpenKey(reEnumNet.GetKey(),szSubkeyName,
        &_hkeyTcpNode);
      // return open key
      return _hkeyTcpNode;

    } else {
      // from enum node, figure out path to driver node
      
      reEnumNet.MoveToSubKey(szSubkeyName);
      if (reEnumNet.GetError() != ERROR_SUCCESS)
        continue;
      // find the driver path to the driver node
      if (!reEnumNet.GetString(szRegValDriver,szDriverPath,
        sizeof(szDriverPath))) {
         ASSERTSZ(FALSE,"No driver path in enum branch for TCP/IP instance");
        continue;  
      }

      // build the path to registry node for this instance
      lstrcpy(szInstancePath,szRegPathClass);
      lstrcat(szInstancePath,szDriverPath);

      _error = RegOpenKey(HKEY_LOCAL_MACHINE,szInstancePath,
        &_hkeyTcpNode);
      // return open key
      return _hkeyTcpNode;
    }
  }

  // ran through all net cards of specified type w/o finding TCP/IP bound
  _error = ERROR_NO_MORE_ITEMS;
  return NULL;
}

/*******************************************************************

  NAME:    ENUM_TCP_INSTANCE::CloseNode

  SYNOPSIS:  Private worker function to close TCP/IP node handle

********************************************************************/
VOID ENUM_TCP_INSTANCE::CloseNode()
{
  if (_hkeyTcpNode) {
    RegCloseKey(_hkeyTcpNode);
    _hkeyTcpNode = NULL;
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\ccfg9x\clsutil.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright (c) 1994-1998 Microsoft Corporation
//*********************************************************************

//
//  CLSUTIL.H - header file for utility C++ classes
//

//  HISTORY:
//  
//  12/07/94  jeremys    Borrowed from WNET common library
//

#ifndef _CLSUTIL_H_
#define _CLSUTIL_H_

/*************************************************************************

    NAME:    BUFFER_BASE

    SYNOPSIS:  Base class for transient buffer classes

    INTERFACE:  BUFFER_BASE()
          Construct with optional size of buffer to allocate.

        Resize()
          Resize buffer to specified size.  Returns TRUE if
          successful.

        QuerySize()
          Return the current size of the buffer in bytes.

        QueryPtr()
          Return a pointer to the buffer.

    PARENT:    None

    USES:    None

    CAVEATS:  This is an abstract class, which unifies the interface
        of BUFFER, GLOBAL_BUFFER, etc.

    NOTES:    In standard OOP fashion, the buffer is deallocated in
        the destructor.

    HISTORY:
    03/24/93  gregj  Created base class

**************************************************************************/

class BUFFER_BASE
{
protected:
  UINT _cb;

  virtual BOOL Alloc( UINT cbBuffer ) = 0;
  virtual BOOL Realloc( UINT cbBuffer ) = 0;

public:
  BUFFER_BASE()
    { _cb = 0; }  // buffer not allocated yet
  ~BUFFER_BASE()
    { _cb = 0; }  // buffer size no longer valid
  BOOL Resize( UINT cbNew );
  UINT QuerySize() const { return _cb; };
};

#define GLOBAL_BUFFER  BUFFER

/*************************************************************************

    NAME:    BUFFER

    SYNOPSIS:  Wrapper class for new and delete

    INTERFACE:  BUFFER()
          Construct with optional size of buffer to allocate.

        Resize()
          Resize buffer to specified size.  Only works if the
          buffer hasn't been allocated yet.

        QuerySize()
          Return the current size of the buffer in bytes.

        QueryPtr()
          Return a pointer to the buffer.

    PARENT:    BUFFER_BASE

    USES:    operator new, operator delete

    CAVEATS:

    NOTES:    In standard OOP fashion, the buffer is deallocated in
        the destructor.

    HISTORY:
    03/24/93  gregj  Created

**************************************************************************/

class BUFFER : public BUFFER_BASE
{
protected:
  CHAR *_lpBuffer;

  virtual BOOL Alloc( UINT cbBuffer );
  virtual BOOL Realloc( UINT cbBuffer );

public:
  BUFFER( UINT cbInitial=0 );
  ~BUFFER();
  BOOL Resize( UINT cbNew );
  CHAR * QueryPtr() const { return (CHAR *)_lpBuffer; }
  operator CHAR *() const { return (CHAR *)_lpBuffer; }
};

class RegEntry
{
  public:
    RegEntry(const char *pszSubKey, HKEY hkey = HKEY_CURRENT_USER);
    ~RegEntry();
    
    long  GetError()  { return _error; }
    long  SetValue(const char *pszValue, const char *string);
    long  SetValue(const char *pszValue, unsigned long dwNumber);
    char *  GetString(const char *pszValue, char *string, unsigned long length);
    long  GetNumber(const char *pszValue, long dwDefault = 0);
    long  DeleteValue(const char *pszValue);
    long  FlushKey();
        long    MoveToSubKey(const char *pszSubKeyName);
        HKEY    GetKey()    { return _hkey; }

  private:
    HKEY  _hkey;
    long  _error;
        BOOL    bhkeyValid;
};

class RegEnumValues
{
  public:
    RegEnumValues(RegEntry *pRegEntry);
    ~RegEnumValues();
    long  Next();
    char *  GetName()       {return pchName;}
        DWORD   GetType()       {return dwType;}
        LPBYTE  GetData()       {return pbValue;}
        DWORD   GetDataLength() {return dwDataLength;}
    long  GetError()  { return _error; }

  private:
        RegEntry * pRegEntry;
    DWORD   iEnum;
        DWORD   cEntries;
    CHAR *  pchName;
    LPBYTE  pbValue;
        DWORD   dwType;
        DWORD   dwDataLength;
        DWORD   cMaxValueName;
        DWORD   cMaxData;
        LONG    _error;
};

/*************************************************************************

    NAME:    WAITCURSOR

    SYNOPSIS:  Sets the cursor to an hourclass until object is destructed

**************************************************************************/
class WAITCURSOR
{
private:
    HCURSOR m_curOld;
    HCURSOR m_curNew;

public:
    WAITCURSOR() { m_curNew = ::LoadCursor( NULL, IDC_WAIT ); m_curOld = ::SetCursor( m_curNew ); }
    ~WAITCURSOR() { ::SetCursor( m_curOld ); }
};

#endif  // _CLSUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\ccfg9x\wizthk.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\ccfg9x\pch.c ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright (c) 1994-1998 Microsoft Corporation         **
//*********************************************************************
#include "global.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\ccfg9x\global.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright (c) 1994-1999 Microsoft Corporation
//*********************************************************************

//
//  GLOBAL.H - central header file for Internet config library
//

//  HISTORY:
//
//  96/05/22  markdu  Created (from inetcfg.dll)
//

#ifndef _GLOBAL_H_
#define _GLOBAL_H_

#define STRICT                      // Use strict handle types
#define _SHELL32_

#ifdef DEBUG
// component name for debug spew
#define SZ_COMPNAME "ICFG32: "
#endif // DEBUG

  #include <windows.h>
  #include <windowsx.h>
  #include <commctrl.h>
  #include <prsht.h>
  #include <regstr.h>
  #include "oharestr.h"

  // various RNA header files
  #include <ras.h>

  #include "wizglob.h"
  #include "wizdebug.h"


#undef DATASEG_READONLY
#define DATASEG_READONLY  ".rdata"
#include "inetcfg.h"
#include "cfgapi.h"
#include "clsutil.h"
#include "tcpcmn.h"
#include "ids.h"
#include "strings.h"

// Terminology: ISP - Internet Service Provider

// Defines
#define MAX_RES_LEN         255 // max length of string resources
#define SMALL_BUF_LEN       48  // convenient size for small text buffers

// Globals

extern HINSTANCE  ghInstance;         // global module instance handle
extern LPSTR      gpszLastErrorText;  // hold text of last error

// Defines

// error class defines for PrepareErrorMessage
#define ERRCLS_STANDARD 0x0001
#define ERRCLS_SETUPX   0x0002
//#define ERRCLS_RNA      0x0003
//#define ERRCLS_MAPI     0x0004

#define OK        0    // success code for SETUPX class errors

// functions in PROPMGR.C
UINT GetConfig(CLIENTCONFIG * pClientConfig,DWORD * pdwErrCls);

// functions in CALLOUT.C
UINT InstallTCPIP(HWND hwndParent);
UINT InstallPPPMAC(HWND hwndParent);

// functions in UTIL.C
int MsgBox(HWND hWnd,UINT nMsgID,UINT uIcon,UINT uButtons);
int MsgBoxSz(HWND hWnd,LPSTR szText,UINT uIcon,UINT uButtons);
int _cdecl MsgBoxParam(HWND hWnd,UINT nMsgID,UINT uIcon,UINT uButtons,...);
LPSTR LoadSz(UINT idString,LPSTR lpszBuf,UINT cbBuf);
VOID _cdecl PrepareErrorMessage(UINT uStrID,UINT uError,
  UINT uErrorClass,UINT uIcon,...);
VOID GetErrorDescription(CHAR * pszErrorDesc,UINT cbErrorDesc,
  UINT uError,UINT uErrorClass);
DWORD RunMlsetExe(HWND hwndOwner);
VOID RemoveRunOnceEntry(UINT uResourceID);
BOOL GenerateDefaultName(CHAR * pszName,DWORD cbName,CHAR * pszRegValName,
  UINT uIDDefName);
BOOL GenerateComputerNameIfNeeded(VOID);
DWORD MsgWaitForMultipleObjectsLoop(HANDLE hEvent);

// 10/24/96 jmazner Normandy 6968
// No longer neccessary thanks to Valdon's hooks for invoking ICW.
//BOOL SetDesktopInternetIconToBrowser(VOID);

VOID PrepareForRunOnceApp(VOID);

// functions in INETAPI.C
BOOL DoDNSCheck(HWND hwndParent,BOOL * pfNeedRestart);

// functions in WIZDLL.C
RETERR   GetClientConfig(CLIENTCONFIG * pClientConfig);
UINT   InstallComponent(HWND hwndParent,DWORD dwComponent,DWORD dwParam);
RETERR   RemoveUnneededDefaultComponents(HWND hwndParent);
RETERR   RemoveProtocols(HWND hwndParent,DWORD dwRemoveFromCardType,DWORD dwProtocols);
RETERR   BeginNetcardTCPIPEnum(VOID);
BOOL  GetNextNetcardTCPIPNode(LPSTR pszTcpNode,WORD cbTcpNode,DWORD dwFlags);

// structure for getting proc addresses of api functions
typedef struct APIFCN {
  PVOID * ppFcnPtr;
  LPCSTR pszName;
} APIFCN;


#undef  DATASEG_PERINSTANCE
#define DATASEG_PERINSTANCE     ".instance"
#define DATASEG_SHARED          ".data"
#define DATASEG_DEFAULT    DATASEG_SHARED

#endif // _GLOBAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\ccfg9x\pch.hpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright (c) 1994-1999 Microsoft Corporation
//*********************************************************************
#include "global.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\ccfg9x\tcpcmn.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright (c) 1994-1998 Microsoft Corporation
//*********************************************************************

//
//  TCPCMN.H - central header file for TCP/IP structures and configuration
//         functions
//

//  HISTORY:
//  
//  96/05/22  markdu  Created (from inetcfg.dll)
//

#ifndef _TCPCMN_H_
#define _TCPCMN_H_

typedef DWORD IPADDRESS;

// same limits as in net setup UI
#define IP_ADDRESS_LEN          15    // big enough for www.xxx.yyy.zzz
#define MAX_GATEWAYS      8
#define MAX_DNSSERVER      3

// big enough for <ip>,<ip>,...
#define MAX_DNSSERVERLEN    MAX_DNSSERVER * (IP_ADDRESS_LEN+1)
#define MAX_GATEWAYLEN      MAX_GATEWAYS * (IP_ADDRESS_LEN+1)

// node type flags for _dwNodeFlags
#define NT_DRIVERNODE  0x0001
#define NT_ENUMNODE    0x0002

class ENUM_TCP_INSTANCE
{
private:
  DWORD       _dwCardFlags;  // INSTANCE_NETDRIVER, INSTANCE_PPPDRIVER, etc
  DWORD      _dwNodeFlags;  // NT_DRIVERNODE, NT_ENUMNODE, etc
  UINT       _error;
  HKEY       _hkeyTcpNode;
  VOID      CloseNode();
public:
  ENUM_TCP_INSTANCE(DWORD dwCardFlags,DWORD dwNodeFlags);
  ~ENUM_TCP_INSTANCE();
  HKEY Next();
  UINT GetError()  { return _error; }
};


#endif  // _TCPCMN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\ccfg9x\strings.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright (c) 1994-1998 Microsoft Corporation
//*********************************************************************

//
//  STRINGS.H - Header file for hard-coded strings
//

//  HISTORY:
//  
//  96/05/22  markdu  Created (from inetcfg.dll)

#ifndef _STRINGS_H_
#define _STRINGS_H_

// registry strings
extern const CHAR szRegPathSetup[];
extern const CHAR szRegPathClass[];
extern const CHAR szRegPathEnumNet[];
extern const CHAR szRegPathSetupRunOnce[];
extern const CHAR szRegPathSoftwareMicrosoft[];
extern const CHAR szRegValOwner[];
extern const CHAR szRegValOrganization[];
extern const CHAR szRegValDriver[];
extern const CHAR szTCPGlobalKeyName[];
extern const CHAR szRegKeyBindings[];
extern const CHAR szRegValEnableDNS[];
extern const CHAR szRegPathExchangeClientOpt[];
extern const CHAR szRegValSilentRunning[];
extern const CHAR szRegValMlSet[];
extern const CHAR szRegPathComputerName[];
extern const CHAR szRegValComputerName[];
extern const CHAR szRegPathWorkgroup[];
extern const CHAR szRegValWorkgroup[];

// 10/24/96 jmazner Normandy 6968
// No longer neccessary thanks to Valdon's hooks for invoking ICW.
//extern const CHAR szRegPathInternetIconCommand[];

extern const CHAR szRegPathIexploreAppPath[];
extern const CHAR szRegPathDesktop[];
extern const CHAR szRegPathSetupWallpaper[];
extern const CHAR szRegValWallpaper[];
extern const CHAR szRegValTileWallpaper[];

// misc strings
extern const CHAR sz0[];
extern const CHAR sz1[];
extern const CHAR szNull[];
extern const CHAR szVSERVER[];
extern const CHAR szVREDIR[];

#endif // _STRINGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\ccfg9x\i386\wizthk.asm ===
; Copyright (c) 1998 Microsoft Corporation
	page	,132

;Thunk Compiler Version 1.8  Dec 14 1994 14:53:05
;File Compiled Fri Jun 21 14:07:10 1996

;Command Line: ..\..\..\..\dev\tools\binr\thunk.exe -NC _TEXT ..\wizthk.thk 

	TITLE	$..\wizthk.asm

	.386
	OPTION READONLY
	OPTION OLDSTRUCTS

IFNDEF IS_16
IFNDEF IS_32
%out command line error: specify one of -DIS_16, -DIS_32
.err
ENDIF  ;IS_32
ENDIF  ;IS_16


IFDEF IS_32
IFDEF IS_16
%out command line error: you can't specify both -DIS_16 and -DIS_32
.err
ENDIF ;IS_16
;************************* START OF 32-BIT CODE *************************


	.model FLAT,STDCALL


;-- Import common flat thunk routines (in k32)

externDef AllocMappedBuffer	:near32
externDef FreeMappedBuffer		:near32
externDef MapHInstLS	:near32
externDef MapHInstLS_PN	:near32
externDef MapHInstSL	:near32
externDef MapHInstSL_PN	:near32
externDef FT_Prolog	:near32
externDef FT_Thunk	:near32
externDef QT_Thunk	:near32
externDef FT_Exit0	:near32
externDef FT_Exit4	:near32
externDef FT_Exit8	:near32
externDef FT_Exit12	:near32
externDef FT_Exit16	:near32
externDef FT_Exit20	:near32
externDef FT_Exit24	:near32
externDef FT_Exit28	:near32
externDef FT_Exit32	:near32
externDef FT_Exit36	:near32
externDef FT_Exit40	:near32
externDef FT_Exit44	:near32
externDef FT_Exit48	:near32
externDef FT_Exit52	:near32
externDef FT_Exit56	:near32
externDef SMapLS	:near32
externDef SUnMapLS	:near32
externDef SMapLS_IP_EBP_8	:near32
externDef SUnMapLS_IP_EBP_8	:near32
externDef SMapLS_IP_EBP_12	:near32
externDef SUnMapLS_IP_EBP_12	:near32
externDef SMapLS_IP_EBP_16	:near32
externDef SUnMapLS_IP_EBP_16	:near32
externDef SMapLS_IP_EBP_20	:near32
externDef SUnMapLS_IP_EBP_20	:near32
externDef SMapLS_IP_EBP_24	:near32
externDef SUnMapLS_IP_EBP_24	:near32
externDef SMapLS_IP_EBP_28	:near32
externDef SUnMapLS_IP_EBP_28	:near32
externDef SMapLS_IP_EBP_32	:near32
externDef SUnMapLS_IP_EBP_32	:near32
externDef SMapLS_IP_EBP_36	:near32
externDef SUnMapLS_IP_EBP_36	:near32
externDef SMapLS_IP_EBP_40	:near32
externDef SUnMapLS_IP_EBP_40	:near32

MapLS	PROTO NEAR STDCALL :DWORD
UnMapLS	PROTO NEAR STDCALL :DWORD
MapSL	PROTO NEAR STDCALL p32:DWORD

;***************** START OF KERNEL32-ONLY SECTION ******************
; Hacks for kernel32 initialization.

IFDEF FT_DEFINEFTCOMMONROUTINES

	.data
public FT_wizthkTargetTable	;Flat address of target table in 16-bit module.

public FT_wizthkChecksum32
FT_wizthkChecksum32	dd	010e07h


ENDIF ;FT_DEFINEFTCOMMONROUTINES
;***************** END OF KERNEL32-ONLY SECTION ******************



	.code 

;************************* COMMON PER-MODULE ROUTINES *************************

	.data

public wizthk_ThunkData32	;This symbol must be exported.
wizthk_ThunkData32 label dword
	dd	3130534ch	;Protocol 'LS01'
	dd	010e07h	;Checksum
	dd	0	;Jump table address.
	dd	3130424ch	;'LB01'
	dd	0	;Flags
	dd	0	;Reserved (MUST BE 0)
	dd	0	;Reserved (MUST BE 0)
	dd	offset QT_Thunk_wizthk - offset wizthk_ThunkData32
	dd	offset FT_Prolog_wizthk - offset wizthk_ThunkData32



	.code 


externDef ThunkConnect32@24:near32

public wizthk_ThunkConnect32@16
wizthk_ThunkConnect32@16:
	pop	edx
	push	offset wizthk_ThkData16
	push	offset wizthk_ThunkData32
	push	edx
	jmp	ThunkConnect32@24
wizthk_ThkData16 label byte
	db	"wizthk_ThunkData16",0


		


pfnQT_Thunk_wizthk	dd offset QT_Thunk_wizthk
pfnFT_Prolog_wizthk	dd offset FT_Prolog_wizthk
	.data
QT_Thunk_wizthk label byte
	db	32 dup(0cch)	;Patch space.

FT_Prolog_wizthk label byte
	db	32 dup(0cch)	;Patch space.


	.code 




ebp_top		equ	<[ebp + 8]>	;First api parameter
ebp_retval	equ	<[ebp + -64]>	;Api return value
FT_ESPFIXUP	macro	dwSpOffset
	or	dword ptr [ebp + -20], 1 SHL ((dwSpOffset) SHR 1)
endm


ebp_qttop	equ	<[ebp + 8]>


include fltthk.inc	;Support definitions
include wizthk.inc



;************************ START OF THUNK BODIES************************




;
public GetClientConfig16@4
GetClientConfig16@4:
	FAPILOG16	212
	mov	cx, (1 SHL 10) + (0 SHL 8) + 8
; GetClientConfig16(16) = GetClientConfig16(32) {}
;
; dword ptr [ebp+8]:  pClientConfig
;
public IIGetClientConfig16@4
IIGetClientConfig16@4:
	call	dword ptr [pfnFT_Prolog_wizthk]
	sub	esp,24
	mov	esi,[ebp+8]
	or	esi,esi
	jnz	L0
	push	esi
	jmp	L1
L0:
	lea	edi,[ebp-88]
	push	edi	;pClientConfig: lpstruct32->lpstruct16
	or	dword ptr [ebp-20],01h	;Set flag to fixup ESP-rel argument.
	mov	ecx,12
@@:
	lodsd
	stosw
	loop	@B
L1:
	call	FT_Thunk
	movzx	ebx,ax
	mov	edi,[ebp+8]
	or	edi,edi
	jz	L2
	lea	esi,[ebp-88]	;pClientConfig  Struct16->Struct32
	mov	ecx,12
@@:
	lodsw
	cwde
	stosd
	loop	@B
L2:
	jmp	FT_Exit4





;
public BeginNetcardTCPIPEnum16@0
BeginNetcardTCPIPEnum16@0:
	FAPILOG16	161
	mov	cl,6
; BeginNetcardTCPIPEnum16(16) = BeginNetcardTCPIPEnum16(32) {}
;
;
public IIBeginNetcardTCPIPEnum16@0
IIBeginNetcardTCPIPEnum16@0:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	call	dword ptr [pfnQT_Thunk_wizthk]
	movzx	eax,ax
	leave
	retn





;
public GetNextNetcardTCPIPNode16@12
GetNextNetcardTCPIPNode16@12:
	FAPILOG16	131
	mov	cl,5
; GetNextNetcardTCPIPNode16(16) = GetNextNetcardTCPIPNode16(32) {}
;
; dword ptr [ebp+8]:  pszTcpNode
; dword ptr [ebp+12]:  cbTcpNode
; dword ptr [ebp+16]:  dwFlags
;
public IIGetNextNetcardTCPIPNode16@12
IIGetNextNetcardTCPIPNode16@12:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	call	SMapLS_IP_EBP_8
	push	eax
	push	word ptr [ebp+12]	;cbTcpNode: dword->word
	push	dword ptr [ebp+16]	;dwFlags: dword->dword
	call	dword ptr [pfnQT_Thunk_wizthk]
	cwde
	call	SUnMapLS_IP_EBP_8
	leave
	retn	12





;
public GetSETUPXErrorText16@12
GetSETUPXErrorText16@12:
	FAPILOG16	106
	mov	cl,4
; GetSETUPXErrorText16(16) = GetSETUPXErrorText16(32) {}
;
; dword ptr [ebp+8]:  dwErr
; dword ptr [ebp+12]:  pszErrorDesc
; dword ptr [ebp+16]:  cbErrorDesc
;
public IIGetSETUPXErrorText16@12
IIGetSETUPXErrorText16@12:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	dword ptr [ebp+8]	;dwErr: dword->dword
	call	SMapLS_IP_EBP_12
	push	eax
	push	dword ptr [ebp+16]	;cbErrorDesc: dword->dword
	call	dword ptr [pfnQT_Thunk_wizthk]
	call	SUnMapLS_IP_EBP_12
	leave
	retn	12





;
public RemoveUnneededDefaultComponents16@4
RemoveUnneededDefaultComponents16@4:
	FAPILOG16	68
	mov	cl,3
; RemoveUnneededDefaultComponents16(16) = RemoveUnneededDefaultComponents16(32) {}
;
; dword ptr [ebp+8]:  hwndParent
;
public IIRemoveUnneededDefaultComponents16@4
IIRemoveUnneededDefaultComponents16@4:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;hwndParent: dword->word
	call	dword ptr [pfnQT_Thunk_wizthk]
	movzx	eax,ax
	leave
	retn	4





;
public RemoveProtocols16@12
RemoveProtocols16@12:
	FAPILOG16	46
	mov	cl,2
	jmp	IIRemoveProtocols16@12
public InstallComponent16@12
InstallComponent16@12:
	FAPILOG16	189
	mov	cl,7
; RemoveProtocols16(16) = RemoveProtocols16(32) {}
;
; dword ptr [ebp+8]:  hwndParent
; dword ptr [ebp+12]:  dwRemoveFromCardType
; dword ptr [ebp+16]:  dwProtocols
;
public IIRemoveProtocols16@12
IIRemoveProtocols16@12:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;hwndParent: dword->word
	push	dword ptr [ebp+12]	;dwRemoveFromCardType: dword->dword
	push	dword ptr [ebp+16]	;dwProtocols: dword->dword
	call	dword ptr [pfnQT_Thunk_wizthk]
	movzx	eax,ax
	leave
	retn	12





;
public DoGenInstall16@12
DoGenInstall16@12:
	FAPILOG16	27
	mov	cl,1
; DoGenInstall16(16) = DoGenInstall16(32) {}
;
; dword ptr [ebp+8]:  hwndParent
; dword ptr [ebp+12]:  lpszInfFile
; dword ptr [ebp+16]:  lpszInfSect
;
public IIDoGenInstall16@12
IIDoGenInstall16@12:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;hwndParent: dword->word
	call	SMapLS_IP_EBP_12
	push	eax
	call	SMapLS_IP_EBP_16
	push	eax
	call	dword ptr [pfnQT_Thunk_wizthk]
	movzx	eax,ax
	call	SUnMapLS_IP_EBP_12
	call	SUnMapLS_IP_EBP_16
	leave
	retn	12





;
public SetInstallSourcePath16@4
SetInstallSourcePath16@4:
	FAPILOG16	0
	mov	cl,0
; SetInstallSourcePath16(16) = SetInstallSourcePath16(32) {}
;
; dword ptr [ebp+8]:  szSourcePath
;
public IISetInstallSourcePath16@4
IISetInstallSourcePath16@4:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	call	SMapLS_IP_EBP_8
	push	eax
	call	dword ptr [pfnQT_Thunk_wizthk]
	movzx	eax,ax
	call	SUnMapLS_IP_EBP_8
	leave
	retn	4




;-----------------------------------------------------------
ifdef DEBUG
FT_ThunkLogNames label byte
	db	'[F] SetInstallSourcePath16',0
	db	'[F] DoGenInstall16',0
	db	'[F] RemoveProtocols16',0
	db	'[F] RemoveUnneededDefaultComponents16',0
	db	'[F] GetSETUPXErrorText16',0
	db	'[F] GetNextNetcardTCPIPNode16',0
	db	'[F] BeginNetcardTCPIPEnum16',0
	db	'[F] InstallComponent16',0
	db	'[F] GetClientConfig16',0
endif ;DEBUG
;-----------------------------------------------------------



ELSE
;************************* START OF 16-BIT CODE *************************




	OPTION SEGMENT:USE16
	.model LARGE,PASCAL


	.code	_TEXT



externDef SetInstallSourcePath16:far16
externDef DoGenInstall16:far16
externDef RemoveProtocols16:far16
externDef RemoveUnneededDefaultComponents16:far16
externDef GetSETUPXErrorText16:far16
externDef GetNextNetcardTCPIPNode16:far16
externDef BeginNetcardTCPIPEnum16:far16
externDef InstallComponent16:far16
externDef GetClientConfig16:far16


FT_wizthkTargetTable label word
	dw	offset SetInstallSourcePath16
	dw	   seg SetInstallSourcePath16
	dw	offset DoGenInstall16
	dw	   seg DoGenInstall16
	dw	offset RemoveProtocols16
	dw	   seg RemoveProtocols16
	dw	offset RemoveUnneededDefaultComponents16
	dw	   seg RemoveUnneededDefaultComponents16
	dw	offset GetSETUPXErrorText16
	dw	   seg GetSETUPXErrorText16
	dw	offset GetNextNetcardTCPIPNode16
	dw	   seg GetNextNetcardTCPIPNode16
	dw	offset BeginNetcardTCPIPEnum16
	dw	   seg BeginNetcardTCPIPEnum16
	dw	offset InstallComponent16
	dw	   seg InstallComponent16
	dw	offset GetClientConfig16
	dw	   seg GetClientConfig16




	.data

public wizthk_ThunkData16	;This symbol must be exported.
wizthk_ThunkData16	dd	3130534ch	;Protocol 'LS01'
	dd	010e07h	;Checksum
	dw	offset FT_wizthkTargetTable
	dw	seg    FT_wizthkTargetTable
	dd	0	;First-time flag.



	.code _TEXT


externDef ThunkConnect16:far16

public wizthk_ThunkConnect16
wizthk_ThunkConnect16:
	pop	ax
	pop	dx
	push	seg    wizthk_ThunkData16
	push	offset wizthk_ThunkData16
	push	seg    wizthk_ThkData32
	push	offset wizthk_ThkData32
	push	cs
	push	dx
	push	ax
	jmp	ThunkConnect16
wizthk_ThkData32 label byte
	db	"wizthk_ThunkData32",0





ENDIF
END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\ccfg9x\util.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright (c) 1994-1998 Microsoft Corporation
//*********************************************************************

//
//  UTIL.C - common utility functions
//

//  HISTORY:
//  
//  96/05/22  markdu  Created (from inetcfg.dll)
//

#include "pch.hpp"
#if 0
#include "string.h"
#endif

#define MAX_MSG_PARAM     8

// function prototypes
VOID _cdecl FormatErrorMessage(CHAR * pszMsg,DWORD cbMsg,CHAR * pszFmt,va_list ArgList);

/*******************************************************************

  NAME:    MsgBox

  SYNOPSIS:  Displays a message box with the specified string ID

********************************************************************/
int MsgBox(HWND hWnd,UINT nMsgID,UINT uIcon,UINT uButtons)
{
    CHAR szMsgBuf[MAX_RES_LEN+1];
  CHAR szSmallBuf[SMALL_BUF_LEN+1];

    LoadSz(IDS_APPNAME,szSmallBuf,sizeof(szSmallBuf));
    LoadSz(nMsgID,szMsgBuf,sizeof(szMsgBuf));

    MessageBeep(uIcon);
    return (MessageBox(hWnd,szMsgBuf,szSmallBuf,uIcon | uButtons));

}

/*******************************************************************

  NAME:    MsgBoxSz

  SYNOPSIS:  Displays a message box with the specified text

********************************************************************/
int MsgBoxSz(HWND hWnd,LPSTR szText,UINT uIcon,UINT uButtons)
{
  CHAR szSmallBuf[SMALL_BUF_LEN+1];
  LoadSz(IDS_APPNAME,szSmallBuf,sizeof(szSmallBuf));

    MessageBeep(uIcon);
    return (MessageBox(hWnd,szText,szSmallBuf,uIcon | uButtons));
}

/*******************************************************************

  NAME:    MsgBoxParam

  SYNOPSIS:  Displays a message box with the specified string ID

  NOTES:    extra parameters are string pointers inserted into nMsgID.

********************************************************************/
int _cdecl MsgBoxParam(HWND hWnd,UINT nMsgID,UINT uIcon,UINT uButtons,...)
{
  BUFFER Msg(3*MAX_RES_LEN+1);  // nice n' big for room for inserts
  BUFFER MsgFmt(MAX_RES_LEN+1);

  if (!Msg || !MsgFmt) {
    return MsgBox(hWnd,IDS_ERROutOfMemory,MB_ICONSTOP,MB_OK);
  }

    LoadSz(nMsgID,MsgFmt.QueryPtr(),MsgFmt.QuerySize());

  FormatErrorMessage(Msg.QueryPtr(),Msg.QuerySize(),
    MsgFmt.QueryPtr(),((CHAR *) &uButtons) + sizeof(uButtons));

  return MsgBoxSz(hWnd,Msg.QueryPtr(),uIcon,uButtons);
}


/*******************************************************************

  NAME:    LoadSz

  SYNOPSIS:  Loads specified string resource into buffer

  EXIT:    returns a pointer to the passed-in buffer

  NOTES:    If this function fails (most likely due to low
        memory), the returned buffer will have a leading NULL
        so it is generally safe to use this without checking for
        failure.

********************************************************************/
LPSTR LoadSz(UINT idString,LPSTR lpszBuf,UINT cbBuf)
{
  ASSERT(lpszBuf);

  // Clear the buffer and load the string
    if ( lpszBuf )
    {
        *lpszBuf = '\0';
        LoadString( ghInstance, idString, lpszBuf, cbBuf );
    }
    return lpszBuf;
}

/*******************************************************************

  NAME:    GetErrorDescription

  SYNOPSIS:  Retrieves the text description for a given error code
        and class of error (standard, setupx)

********************************************************************/
VOID GetErrorDescription(CHAR * pszErrorDesc,UINT cbErrorDesc,
  UINT uError,UINT uErrorClass)
{
  ASSERT(pszErrorDesc);

  // set a leading null in error description
  *pszErrorDesc = '\0';
  
  switch (uErrorClass) {

    case ERRCLS_STANDARD:

      if (!FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,NULL,
        uError,0,pszErrorDesc,cbErrorDesc,NULL)) {
        // if getting system text fails, make a string a la
        // "error <n> occurred"
        CHAR szFmt[SMALL_BUF_LEN+1];
        LoadSz(IDS_ERRFORMAT,szFmt,sizeof(szFmt));
        wsprintf(pszErrorDesc,szFmt,uError);
      }

      break;

    case ERRCLS_SETUPX:

      GetSETUPXErrorText(uError,pszErrorDesc,cbErrorDesc);
      break;

    default:

      DEBUGTRAP("Unknown error class %lu in GetErrorDescription",
        uErrorClass);

  }

}
  
/*******************************************************************

  NAME:    FormatErrorMessage

  SYNOPSIS:  Builds an error message by calling FormatMessage

  NOTES:    Worker function for PrepareErrorMessage

********************************************************************/
VOID _cdecl FormatErrorMessage(CHAR * pszMsg,DWORD cbMsg,CHAR * pszFmt,va_list ArgList)
{
  ASSERT(pszMsg);
  ASSERT(pszFmt);

  // build the message into the pszMsg buffer
  DWORD dwCount = FormatMessage(FORMAT_MESSAGE_FROM_STRING,
    pszFmt,0,0,pszMsg,cbMsg,&ArgList);
  ASSERT(dwCount > 0);
}

/*******************************************************************

  NAME:    PrepareErrorMessage

  SYNOPSIS:  Displays an error message for given error 

  ENTRY:    hWnd - parent window
        uStrID - ID of string resource with message format.
          Should contain %1 to be replaced by error text,
          additional parameters can be specified as well.
        uError - error code for error to display
        uErrorClass - ERRCLS_xxx ID of class of error that
          uError belongs to (standard, setupx)
        uIcon - icon to display
        ... - additional parameters to be inserted in string
          specified by uStrID

********************************************************************/
VOID _cdecl PrepareErrorMessage(UINT uStrID,UINT uError,
  UINT uErrorClass,UINT uIcon,...)
{
  // dynamically allocate buffers for messages
  BUFFER ErrorDesc(MAX_RES_LEN+1);
  BUFFER ErrorFmt(MAX_RES_LEN+1);

  if (!ErrorDesc || !ErrorFmt)
  {
    return;
  }

  // get a text description based on the error code and the class
  // of error it is
  GetErrorDescription(ErrorDesc.QueryPtr(),
    ErrorDesc.QuerySize(),uError,uErrorClass);

  // load the string for the message format
  LoadSz(uStrID,ErrorFmt.QueryPtr(),ErrorFmt.QuerySize());

  LPSTR args[MAX_MSG_PARAM];
  args[0] = (LPSTR) ErrorDesc.QueryPtr();
  memcpy(&args[1],((CHAR *) &uIcon) + sizeof(uIcon),(MAX_MSG_PARAM - 1) * sizeof(LPSTR));

  FormatErrorMessage(gpszLastErrorText, MAX_ERROR_TEXT,
    ErrorFmt.QueryPtr(),(va_list) &args[0]);
}

/*******************************************************************

  NAME:    RunMlsetExe

  SYNOPSIS:  Runs mlset32.exe, an Exchange app that needs to be
        run after files are installed otherwise Exchange
        barfs

  NOTES:    We look in registry to find path to mlset32.exe

********************************************************************/
DWORD RunMlsetExe(HWND hwndOwner)
{
  DWORD dwRet = ERROR_SUCCESS;

  // get path to mlset32 out of registry
  RegEntry re(szRegPathSoftwareMicrosoft,HKEY_LOCAL_MACHINE);

  CHAR szAppPath[MAX_PATH+1];
  if (re.GetString(szRegValMlSet,szAppPath,sizeof(szAppPath))) {
    PROCESS_INFORMATION pi;
    STARTUPINFO sti;

    // set "SilentRunning" registry switch to make mlset32
    // not display the Exchange wizard
    RegEntry reSilent(szRegPathExchangeClientOpt,HKEY_LOCAL_MACHINE);
    reSilent.SetValue(szRegValSilentRunning,(DWORD) 1);

    ZeroMemory(&sti,sizeof(STARTUPINFO));
    sti.cb = sizeof(STARTUPINFO);
            
    // launch mlset32.exe
    BOOL fRet = CreateProcess(NULL, (LPSTR) szAppPath,
                           NULL, NULL, FALSE, 0, NULL, NULL,
                           &sti, &pi);
    if (fRet) {
      CloseHandle(pi.hThread);

      // wait for mlset to complete
      MsgWaitForMultipleObjectsLoop(pi.hProcess);

      CloseHandle(pi.hProcess);
    } else {
      dwRet = GetLastError();
    }

    // put our window in front of mlset32's
    SetForegroundWindow(hwndOwner);
  
  } else {
    dwRet = ERROR_FILE_NOT_FOUND;
  }

  return dwRet;
}

/*******************************************************************

  NAME:    RemoveRunOnceEntry

  SYNOPSIS:  Removes the specified value from setup runonce key

  ENTRY:    uResourceID - ID of value name in resource
          (may be localized)

********************************************************************/
VOID RemoveRunOnceEntry(UINT uResourceID)
{
  RegEntry re(szRegPathSetupRunOnce,HKEY_LOCAL_MACHINE);
  CHAR szValueName[SMALL_BUF_LEN+1];
  ASSERT(re.GetError() == ERROR_SUCCESS);
  re.DeleteValue(LoadSz(uResourceID,
    szValueName,sizeof(szValueName)));
}

/*******************************************************************

  NAME:    GenerateComputerNameIfNeeded

  SYNOPSIS:  Makes up and stores in the registry a computer and/or
        workgroup name if not already set.

  NOTES:    If we don't do this, user will get prompted for computer
        name and workgroup.  These aren't meaningful to the user
        so we'll just make something up if these aren't set.

********************************************************************/
BOOL GenerateComputerNameIfNeeded(VOID)
{
  CHAR szComputerName[CNLEN+1]="";
  CHAR szWorkgroupName[DNLEN+1]="";
  BOOL fNeedToSetComputerName = FALSE;

  // get the computer name out of the registry
  RegEntry reCompName(szRegPathComputerName,HKEY_LOCAL_MACHINE);
  if (reCompName.GetError() == ERROR_SUCCESS) {
    reCompName.GetString(szRegValComputerName,szComputerName,
      sizeof(szComputerName));
    if (!lstrlen(szComputerName)) {
      // no computer name set!  make one up
      GenerateDefaultName(szComputerName,sizeof(szComputerName),
        (CHAR *) szRegValOwner,IDS_DEF_COMPUTER_NAME);
      // store the generated computer name in the registry
      reCompName.SetValue(szRegValComputerName,szComputerName);

      // also need to store the computer name in the workgroup key
      // which we will open below... set a flag so we know to do this.
      // (don't ask me why they store the computer name in two places...
      // but we need to set both.)
      fNeedToSetComputerName = TRUE;
    }
  }

  // get the workgroup name out of the registry
  RegEntry reWorkgroup(szRegPathWorkgroup,HKEY_LOCAL_MACHINE);
  if (reWorkgroup.GetError() == ERROR_SUCCESS) {

    // if we set a new computer name up above, then we have to set
    // a 2nd copy of the new name now, in the workgroup key
    if (fNeedToSetComputerName) {
      reWorkgroup.SetValue(szRegValComputerName,szComputerName);
    }


    reWorkgroup.GetString(szRegValWorkgroup,szWorkgroupName,
      sizeof(szWorkgroupName));
    if (!lstrlen(szWorkgroupName)) {
      // no workgroup name set!  make one up
      GenerateDefaultName(szWorkgroupName,sizeof(szWorkgroupName),
        (CHAR *) szRegValOrganization,IDS_DEF_WORKGROUP_NAME);
      // store the generated workgroup name in the registry
      reWorkgroup.SetValue(szRegValWorkgroup,szWorkgroupName);
    }
  }

  return TRUE;
}

/*******************************************************************

  NAME:    GenerateDefaultName

  SYNOPSIS:  Generates default computer or workgroup name

  ENTRY:    pszName - buffer to be filled in with name
        cbName - size of cbName buffer
        pszRegValName - name of registry value in ...Windows\CurrentVersion
          key to generate name from
        uIDDefName - ID of string resource to use if no value is
          present in registry to generate name from

********************************************************************/
BOOL GenerateDefaultName(CHAR * pszName,DWORD cbName,CHAR * pszRegValName,
  UINT uIDDefName)
{
  ASSERT(pszName);
  ASSERT(pszRegValName);

  *pszName = '\0';  // NULL-terminate buffer

  // look for registered owner/organization name in registry
  RegEntry reSetup(szRegPathSetup,HKEY_LOCAL_MACHINE);
  if (reSetup.GetError() == ERROR_SUCCESS) {
    if (reSetup.GetString(pszRegValName,pszName,cbName) &&
      lstrlen(pszName)) {
      // got string from registry... now terminate at first whitespace
      CHAR * pch = pszName;
      while (*pch) {
        if (*pch == ' ') {
          // found a space, terminate here and stop
          *pch = '\0';           
        } else {
          // advance to next char, keep going
          pch = CharNext(pch);
        }
      }
      // all done!
      return TRUE; 
    }
  }
  
  // couldn't get this name from registry, go for our fallback name
  // from resource

  LoadSz(uIDDefName,pszName,cbName);
  return TRUE;
}

/*******************************************************************

  NAME:    MsgWaitForMultipleObjectsLoop

  SYNOPSIS:  Blocks until the specified object is signaled, while
        still dispatching messages to the main thread.

********************************************************************/
DWORD MsgWaitForMultipleObjectsLoop(HANDLE hEvent)
{
    MSG msg;
    DWORD dwObject;
    while (1)
    {
        // NB We need to let the run dialog become active so we have to half handle sent
        // messages but we don't want to handle any input events or we'll swallow the
        // type-ahead.
        dwObject = MsgWaitForMultipleObjects(1, &hEvent, FALSE,INFINITE, QS_ALLINPUT);
        // Are we done waiting?
        switch (dwObject) {
        case WAIT_OBJECT_0:
        case WAIT_FAILED:
            return dwObject;

        case WAIT_OBJECT_0 + 1:
      // got a message, dispatch it and wait again
      while (PeekMessage(&msg, NULL,0, 0, PM_REMOVE)) {
        DispatchMessage(&msg);
      }
            break;
        }
    }
    // never gets here
}


/*******************************************************************
// 10/24/96 jmazner Normandy 6968
// No longer neccessary thanks to Valdon's hooks for invoking ICW.


  NAME:    SetDesktopInternetIconToBrowser

  SYNOPSIS:  "Points" The Internet desktop icon to web browser
        (Internet Explorer)

  NOTES:    The Internet icon may initially "point" at this wizard,
        we need to set it to launch web browser once we complete
        successfully.

********************************************************************/
/********BOOL SetDesktopInternetIconToBrowser(VOID)
{
	CHAR szAppPath[MAX_PATH+1]="";
	BOOL fRet = FALSE;

	// look in the app path section in registry to get path to internet
	// explorer

	RegEntry reAppPath(szRegPathIexploreAppPath,HKEY_LOCAL_MACHINE);
	ASSERT(reAppPath.GetError() == ERROR_SUCCESS);
	if (reAppPath.GetError() == ERROR_SUCCESS) {

		reAppPath.GetString(szNull,szAppPath,sizeof(szAppPath));
		ASSERT(reAppPath.GetError() == ERROR_SUCCESS);

	}

	// set the path to internet explorer as the open command for the 
	// internet desktop icon
	if (lstrlen(szAppPath)) {
		RegEntry reIconOpenCmd(szRegPathInternetIconCommand,HKEY_CLASSES_ROOT);
		ASSERT(reIconOpenCmd.GetError() == ERROR_SUCCESS);
		if (reIconOpenCmd.GetError() == ERROR_SUCCESS) {
			UINT uErr = reIconOpenCmd.SetValue(szNull,szAppPath);
			ASSERT(uErr == ERROR_SUCCESS);
			
			fRet = (uErr == ERROR_SUCCESS);
		}
	}

	return fRet;
}
******/

/*******************************************************************

  NAME:    PrepareForRunOnceApp

  SYNOPSIS:  Copies wallpaper value in registry to make the runonce
        app happy

  NOTES:    The runonce app (the app that displays a list of apps
        that are run once at startup) has a bug.  At first boot,
        it wants to change the wallpaper from the setup wallpaper
        to what the user had before running setup.  Setup tucks
        the "old" wallpaper away in a private key, then changes
        the wallpaper to the setup wallpaper.  After the runonce
        app finishes, it looks in the private key to get the old
        wallpaper and sets that to be the current wallpaper.
        However, it does this all the time, not just at first boot!
        The end effect is that whenever you do anything that
        causes runonce.exe to run (add stuff thru add/remove
        programs control panel), your wallpaper gets set back to
        whatever it was when you installed win 95.  This is
        especially bad for Plus!, since wallpaper settings are an
        important part of the product.

        To work around this bug, we copy the current wallpaper settings
        (which we want preserved) to setup's private key.  When
        runonce runs it will say "aha!" and copy those values back
        to the current settings.

********************************************************************/
VOID PrepareForRunOnceApp(VOID)
{
  // open a key to the current wallpaper settings
  RegEntry reDesktop(szRegPathDesktop,HKEY_CURRENT_USER);
  ASSERT(reDesktop.GetError() == ERROR_SUCCESS);

  // open a key to the private setup section
  RegEntry reSetup(szRegPathSetupWallpaper,HKEY_LOCAL_MACHINE);
  ASSERT(reSetup.GetError() == ERROR_SUCCESS);

  if (reDesktop.GetError() == ERROR_SUCCESS &&
    reSetup.GetError() == ERROR_SUCCESS) {
    CHAR szWallpaper[MAX_PATH+1]="";
    CHAR szTiled[10]="";  // big enough for "1" + slop

    // get the current wallpaper name
    if (reDesktop.GetString(szRegValWallpaper,szWallpaper,
      sizeof(szWallpaper))) {

      // set the current wallpaper name in setup's private section
      UINT uRet=reSetup.SetValue(szRegValWallpaper,szWallpaper);
      ASSERT(uRet == ERROR_SUCCESS);

      // get the current 'tiled' value. 
      reDesktop.GetString(szRegValTileWallpaper,szTiled,
        sizeof(szTiled));

      // set the 'tiled' value in setup's section
      if (lstrlen(szTiled)) {
        uRet=reSetup.SetValue(szRegValTileWallpaper,szTiled);
        ASSERT(uRet == ERROR_SUCCESS);
      }
    }
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\ccfg9x\strings.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright (c) 1994-1998 Microsoft Corporation
//*********************************************************************

//
//  STRINGS.C - String literals for hard-coded strings
//

//  HISTORY:
//  
//  96/05/22  markdu  Created (from inetcfg.dll)

#include "pch.hpp"

#pragma data_seg(DATASEG_READONLY)

//////////////////////////////////////////////////////
// registry strings
//////////////////////////////////////////////////////

// "Software\\Microsoft\\Windows\\CurrentVersion"
static const CHAR szRegPathSetup[] =       REGSTR_PATH_SETUP;

// "Software\\Microsoft\\Windows\\CurrentVersion\\"
static const CHAR szRegPathClass[] =       REGSTR_PATH_CLASS "\\";

// "Enum\\Network\\"
static const CHAR szRegPathEnumNet[] =      REGSTR_PATH_ENUM "\\Network\\";

// "Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce\\Setup"
static const CHAR szRegPathSetupRunOnce[] =   REGSTR_PATH_RUNONCE "\\Setup";

static const CHAR szRegPathSoftwareMicrosoft[]= "Software\\Microsoft";

// "RegisteredOwner"
static const CHAR szRegValOwner[] =       REGSTR_VAL_REGOWNER;

// "RegisteredOrganization"
static const CHAR szRegValOrganization[] =     REGSTR_VAL_REGORGANIZATION;

static const CHAR szRegValDriver[] =      "Driver";

// "System\\CurrentControlSet\\Services\\VxD\\MSTCP"
static const CHAR szTCPGlobalKeyName[] =     REGSTR_PATH_VXD "\\MSTCP";

// "RemoteAccess"
static const CHAR szRegKeyBindings[] =      "Bindings";
static const CHAR szRegValEnableDNS[] =     "EnableDNS";

static const CHAR szRegPathExchangeClientOpt[] = "Software\\Microsoft\\Exchange\\Client\\Options";
static const CHAR szRegValSilentRunning[] =    "SilentRunning";
static const CHAR szRegValMlSet[] =        "MlSet";

// "System\\CurrentControlSet\\Control\\ComputerName\\ComputerName"
static const CHAR szRegPathComputerName[] =     REGSTR_PATH_COMPUTRNAME;

// "ComputerName"
static const CHAR szRegValComputerName[] =      REGSTR_VAL_COMPUTRNAME;

// "System\\CurrentControlSet\\Services\\VxD\\VNETSUP"
static const CHAR szRegPathWorkgroup[] =    REGSTR_PATH_VNETSUP;

// "Workgroup"
static const CHAR szRegValWorkgroup[] =      REGSTR_VAL_WORKGROUP;

// 10/24/96 jmazner Normandy 6968
// No longer neccessary thanks to Valdon's hooks for invoking ICW.
//static const CHAR szRegPathInternetIconCommand[] = "CLSID\\{FBF23B42-E3F0-101B-8488-00AA003E56F8}\\Shell\\Open\\Command";
static const CHAR szRegPathIexploreAppPath[] =  "Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\IEXPLORE.EXE";

// "Control Panel\\Desktop"
static const CHAR szRegPathDesktop[] =      REGSTR_PATH_DESKTOP;

// "Software\\Microsoft\\Windows\\CurrentVersion\\Setup"
static const CHAR szRegPathSetupWallpaper[] =  REGSTR_PATH_SETUP REGSTR_KEY_SETUP;

static const CHAR szRegValWallpaper[] =      "Wallpaper";
static const CHAR szRegValTileWallpaper[] =    "TileWallpaper";


//////////////////////////////////////////////////////
// misc strings
//////////////////////////////////////////////////////
static const CHAR sz0[]  =       "0";
static const CHAR sz1[]  =        "1";
static const CHAR szNull[] =       "";
static const CHAR szVSERVER[] =     "VSERVER";
static const CHAR szVREDIR[] =      "VREDIR";

#pragma data_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\ccfgnt\debug.cpp ===
/*-----------------------------------------------------------------------------
	debug.cpp

	This file implements the debuggin features

	Copyright (c) 1996-1998 Microsoft Corporation
	All rights reserved

	Authors:
		ChrisK	Chris Kauffman

	Histroy:
		7/22/96	ChrisK	Cleaned and formatted
		7/31/96 ValdonB Changes for Win16
	
-----------------------------------------------------------------------------*/

#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <stdarg.h>

#if defined(WIN16)
extern HINSTANCE g_hInst;
extern LPSTR g_lpszCommandLine;
extern LPSTR GetCommandLine(void);
#endif 

BOOL fInAssert=FALSE;

// ############################################################################
// DebugSz
//
// This function outputs debug string
// 
//  Created 1/28/96,		Chris Kauffman
// ############################################################################
void DebugSz(LPCSTR psz)
{
#if defined(_DEBUG)
	OutputDebugString(psz);
#endif	
} // DebugSz

// ############################################################################
// Debug Printf to debug output screen
void Dprintf(LPCSTR pcsz, ...)
{
#ifdef _DEBUG
	va_list	argp;
	char	szBuf[1024];
	
	va_start(argp, pcsz);

#if 0
	vsprintf(szBuf, pcsz, argp);
#else
	wvsprintf(szBuf, pcsz, argp);
#endif
	

	DebugSz(szBuf);
	va_end(argp);
#endif
} // Dprintf()

// ############################################################################
// Handle asserts
BOOL FAssertProc(LPCSTR szFile,  DWORD dwLine, LPCSTR szMsg, DWORD dwFlags)
{

	BOOL fAssertIntoDebugger = FALSE;

	char szMsgEx[1024], szTitle[255], szFileName[MAX_PATH];
	int id;
	UINT fuStyle;
	LPTSTR pszCommandLine = GetCommandLine();
	//BYTE	szTime[80];
#if !defined(WIN16)
	CHAR	szTime[80];
	HANDLE	hAssertTxt;
	SYSTEMTIME st;
	DWORD	cbWritten;
#endif
	
	// no recursive asserts
	if (fInAssert)
		{
		DebugSz("***Recursive Assert***\r\n");
		return(FALSE);
		}

	fInAssert = TRUE;
	
#if defined(WIN16)
	GetModuleFileName(g_hInst, szFileName, MAX_PATH);
	wsprintf(szMsgEx,"%s:#%ld\r\n%s,\r\n%s", szFile, dwLine, szFileName, szMsg);
#else
	GetModuleFileName(NULL, szFileName, MAX_PATH);
	wsprintf(szMsgEx,"%s:#%d\r\nProcess ID: %d %s, Thread ID: %d\r\n%s",
		szFile,dwLine,GetCurrentProcessId(),szFileName,GetCurrentThreadId(),szMsg);
#endif
	wsprintf(szTitle,"Assertion Failed");

	fuStyle = MB_APPLMODAL | MB_ABORTRETRYIGNORE;
	fuStyle |= MB_ICONSTOP;

	DebugSz(szTitle);		
	DebugSz(szMsgEx);		

	// dump the assert into ASSERT.TXT
#if !defined(WIN16)
	hAssertTxt = CreateFile("assert.txt", GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH, NULL);
	if (INVALID_HANDLE_VALUE != hAssertTxt) 
		{
		SetFilePointer(hAssertTxt, 0, NULL, FILE_END);
		GetLocalTime(&st);   
		wsprintf(szTime, "\r\n\r\n%02d/%02d/%02d %d:%02d:%02d\r\n", st.wMonth, st.wDay, st.wYear, st.wHour, st.wMinute, st.wSecond);
		WriteFile(hAssertTxt, szTime, lstrlen(szTime), &cbWritten, NULL);
		WriteFile(hAssertTxt, szMsgEx, lstrlen(szMsgEx), &cbWritten, NULL);
		CloseHandle(hAssertTxt);
		}
#endif

    id = MessageBox(NULL, szMsgEx, szTitle, fuStyle);
    switch (id)
    	{
    	case IDABORT:
#if defined(WIN16)
			exit(0);
#else
    		ExitProcess(0);
#endif
    		break;
    	case IDCANCEL:
    	case IDIGNORE:
    		break;
    	case IDRETRY:
    		fAssertIntoDebugger = TRUE;
    		break;
    	}
				
	fInAssert = FALSE;  
	
	return(fAssertIntoDebugger);
} // AssertProc()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\ccfgnt\debug.h ===
/****************************************************************************
 *
 *	debug.h
 *
 *	Microsoft Confidential
 *	Copyright (c) 1998-1999 Microsoft Corporation
 *	All rights reserved
 *
 *	Debug support
 *
 *	09/02/99    quintinb    Created Header
 *
 ***************************************************************************/

#ifndef _PHBKDEBUG
#define _PHBKDEBUG

void Dprintf(LPCSTR pcsz, ...);
BOOL FAssertProc(LPCSTR szFile,  DWORD dwLine, LPCSTR szMsg, DWORD dwFlags);
void DebugSz(LPCSTR psz);


#ifdef _DEBUG
	#define AssertSzFlg(f, sz, dwFlg)		( (f) ? 0 : FAssertProc(__FILE__, __LINE__, sz, dwFlg) ? DebugBreak() : 1 )
	#define AssertSz(f, sz)					AssertSzFlg(f, sz, 0)
	#define Assert(f)						AssertSz((f), "!(" #f ")")
#else
	#define AssertSzFlg(f, sz, dwFlg)
	#define AssertSz(f, sz)
	#define Assert(f)
#endif
#endif //_PHBKDEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmcfg\cmcfg.h ===
//+----------------------------------------------------------------------------
//
// File:     cmcfg.h
//
// Module:   CMCFG32.DLL
//
// Synopsis: This source header file contains definitions for the CmConfig and CmConfigEx APIs
//
// Copyright (c) 1998 Microsoft Corporation
//
// Author:   henryt       Created      08/27/99
//
//+----------------------------------------------------------------------------

#ifndef _CMCFG_H_
#define _CMCFG_H_

//
// Define string resources
//
#define IDS_NO_I386_ON_IA64 1000

#endif  // _CMCFG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\ccfgnt\icfgnt4.cpp ===
/****************************************************************************
 *
 *  icfg32.cpp
 *
 *  Microsoft Confidential
 *  Copyright (c) 1992-1998 Microsoft Corporation
 *  All rights reserved
 *
 *  This module provides the implementation of the methods for
 *  the NT specific functionality of inetcfg
 *
 *  6/5/97  ChrisK  Inherited from AmnonH
 *
 ***************************************************************************/

#define INITGUID
#include <windows.h>
#include <wtypes.h>
#include <cfgapi.h>
#include <stdio.h>
#include <stdlib.h>
#include <setupapi.h>
#include <basetyps.h>
#include <devguid.h>
#include <lmsname.h>
#include "debug.h"

const DWORD INFINSTALL_PRIMARYINSTALL = 0x00000001;
const DWORD INFINSTALL_INPROCINTERP   = 0x00000002;

#define REG_DATA_EXTRA_SPACE 255

DWORD (WINAPI *pfnNetSetupReviewBindings)(HWND hwndParent,
                DWORD dwBindFlags);
DWORD (WINAPI *pfnNetSetupComponentInstall)(HWND   hwndParent,
                PCWSTR pszInfOption,
                PCWSTR pszInfName,
                PCWSTR pszInstallPath,
                PCWSTR plszInfSymbols,
                DWORD  dwInstallFlags,
                PDWORD dwReturn);
DWORD (WINAPI *pfnNetSetupComponentRemove)(HWND hwndParent,
                PCWSTR pszInfOption,
                DWORD dwInstallFlags,
                PDWORD pdwReturn);
DWORD (WINAPI *pfnNetSetupComponentProperties)(HWND hwndParent,
                PCWSTR pszInfOption,
                DWORD dwInstallFlags,
                PDWORD pdwReturn);
DWORD (WINAPI *pfnNetSetupFindHardwareComponent)(PCWSTR pszInfOption,
                PWSTR pszInfName,
                PDWORD pcchInfName,
                PWSTR pszRegBase,     // optional, may be NULL
                PDWORD pcchRegBase ); // optional, NULL if pszRegBase is NULL
DWORD (WINAPI *pfnNetSetupFindSoftwareComponent)(PCWSTR pszInfOption,
                PWSTR pszInfName,
                PDWORD pcchInfName,
                PWSTR pszRegBase = NULL,
                PDWORD pcchRegBase = NULL);
DWORD (WINAPI *pfnRegCopyTree)();

HINSTANCE g_hNetcfgInst = NULL;
LPWSTR    g_wszInstallPath = 0;
DWORD     g_dwLastError = ERROR_SUCCESS;
extern DWORD EnumerateTapiModemPorts(DWORD dwBytes, LPSTR szPortsBuf, 
                                        BOOL bWithDelay = FALSE);

typedef struct tagFunctionTableEntry {
    LPVOID  *pfn;
    LPSTR   szEntryPoint;
} FunctionTableEntry;

#define REGISTRY_NT_CURRENTVERSION "SOFTWARE\\MICROSOFT\\WINDOWS NT\\CurrentVersion"

FunctionTableEntry NetcfgTable[] = {
    { (LPVOID *) &pfnNetSetupComponentInstall, "NetSetupComponentInstall" },
    { (LPVOID *) &pfnNetSetupFindSoftwareComponent, "NetSetupFindSoftwareComponent" },
    { (LPVOID *) &pfnNetSetupReviewBindings, "NetSetupReviewBindings" },
    { (LPVOID *) &pfnNetSetupComponentRemove, "NetSetupComponentRemove" },
    { (LPVOID *) &pfnNetSetupComponentProperties, "NetSetupComponentProperties" },
    { (LPVOID *) &pfnNetSetupFindHardwareComponent, "NetSetupFindHardwareComponent" },
    { 0, 0 }
};

typedef struct tagNetSetup
{
   WCHAR szOption[16];
   WCHAR szInfName[16];
} NETSETUP;

NETSETUP g_netsetup[] = { L"WKSTA", L"OEMNSVWK.INF",
                        L"SRV", L"OEMNSVSV.INF",
                        L"NETBIOS", L"OEMNSVNB.INF",
                        L"RPCLOCATE", L"OEMNSVRP.INF" };

#define NSERVICES (sizeof g_netsetup / sizeof g_netsetup[0])

inline stricmp(LPSTR s1, LPSTR s2) {
    while(*s1 && *s2) {
        char c1, c2;
        c1 = islower(*s1) ? toupper(*s1) : *s1;
        c2 = islower(*s2) ? toupper(*s2) : *s2;
        if(c1 != c2)
        {
            break;
        }
        s1++; s2++;
    }

    return(*s1 - *s2);
}

//+----------------------------------------------------------------------------
//
//  Function:   LoadLibraryToFunctionTable
//
//  Synopsis:   Load structure with function pointers from FunctionTable
//
//  Arguments:  pTab - array of function to be loaded
//              szDLL - name of DLL to load function from
//
//  Returns:    Handle to szDLL (NULL indicates failure)
//
//  History:    6/5/97  Chrisk  Inherited
//
//-----------------------------------------------------------------------------
HINSTANCE
LoadLibraryToFunctionTable(FunctionTableEntry *pTab, LPSTR szDLL)
{
    HINSTANCE hInst;

    Dprintf("ICFGNT: LoadLibraryToFunctionTable\n");
    hInst = LoadLibrary(szDLL);
    if(hInst == 0)
    {
        return(hInst);
    }

    while(pTab->pfn) {
        *pTab->pfn = (LPVOID) GetProcAddress(hInst, pTab->szEntryPoint);
        if(*pTab->pfn == 0) 
        {
            FreeLibrary(hInst);
            return(0);
        }
        pTab++;
    }

    return(hInst);
}

//+----------------------------------------------------------------------------
//
//  Function:   LoadNetcfg
//
//  Synopsis:   Load netcfg.dll and function poiners
//
//  Arguments:  none
//
//  Returns:    ERROR_SUCCESS if sucessfull and !ERROR_SUCCESS otherwise
//
//  History:    6/5/97 ChrisK   Inherited
//
//-----------------------------------------------------------------------------
DWORD
LoadNetcfg()
{
    if(g_hNetcfgInst == NULL)
    {
        g_hNetcfgInst = LoadLibraryToFunctionTable(NetcfgTable, 
                                                 "NETCFG.DLL");
    }

    if(g_hNetcfgInst == NULL)
    {
        return(!ERROR_SUCCESS);
    }
    else
    {
        return(ERROR_SUCCESS);
    }
}


//+----------------------------------------------------------------------------
//
//  Function:   IcfgSetInstallSourcePath
//
//  Synopsis:   Set the path that will be used to install system components
//
//  Arguments:  lpszSourcePath - path to be used as install source (ANSI)
//
//  Returns:    HRESULT - S_OK is success
//
//  History:    6/5/97  ChrisK  Inherited
//
//-----------------------------------------------------------------------------
HRESULT WINAPI
IcfgSetInstallSourcePath(LPSTR lpszSourcePath)
{
    Dprintf("ICFGNT: IcfgSetInstallSourcePath\n");
    if(g_wszInstallPath)
    {
        HeapFree(GetProcessHeap(), 0, (LPVOID) g_wszInstallPath);
    }

    DWORD dwLen = lstrlen(lpszSourcePath);
    g_wszInstallPath = (LPWSTR) HeapAlloc(GetProcessHeap(), 0, dwLen * 2 + 2);
    if(g_wszInstallPath == 0)
    {
        return(g_dwLastError = ERROR_OUTOFMEMORY);
    }

    mbstowcs(g_wszInstallPath, lpszSourcePath, dwLen + 1);
    return(ERROR_SUCCESS);
}

//+----------------------------------------------------------------------------
//
//  Function:   GetLocationOfSetupFiles
//
//  Synopsis:   Get the location of the files used to install windows.
//
//  Arguments:  hwndParent - handle of parent window
//
//  Returns:    win32 error code
//
//  History:    ChrisK  6/30/97 Created
//-----------------------------------------------------------------------------
DWORD GetLocationOfSetupFiles(HWND hwndParent)
{
    DWORD   dwRC = ERROR_SUCCESS;
    HKEY    hkey = NULL;
    HINF    hInf = INVALID_HANDLE_VALUE;
    UINT    DiskId = 0;
    CHAR    TagFile[128];
    CHAR    lpBuffer[MAX_PATH];
    DWORD   dwLen = MAX_PATH;
    lpBuffer[0] = '\0';

    if( ERROR_SUCCESS == RegOpenKey( HKEY_LOCAL_MACHINE,
                                    REGISTRY_NT_CURRENTVERSION,
                                    &hkey))
    {

        hInf = SetupOpenMasterInf();
        if (hInf == INVALID_HANDLE_VALUE) 
        {
            dwRC = GetLastError();
            goto GetLocationOfSetupFilesExit;
        }

        if (!SetupGetSourceFileLocation(hInf,NULL,"RASCFG.DLL",&DiskId,NULL,0,NULL))
        {
            dwRC = GetLastError();
            goto GetLocationOfSetupFilesExit;
        }

        if (!SetupGetSourceInfo(hInf,DiskId,SRCINFO_TAGFILE,TagFile,MAX_PATH,NULL))
        {
            dwRC = GetLastError();
            goto GetLocationOfSetupFilesExit;
        }

        SetupCloseInfFile(hInf);
        hInf = INVALID_HANDLE_VALUE;

        if( RegQueryValueEx( hkey,
                            "SourcePath",
                            NULL,
                            NULL,
                            (LPBYTE)lpBuffer,
                            &dwLen) == 0)
        {
            RegCloseKey( hkey );
            hkey = NULL;

            // Ask the user to provide the drive\path of the sources. We pass this information
            // down to NetSetupComponentInstall so that the user is not prompted several times
            // for the same information. If the path is correct (IDF_CHECKFIRST) then the user
            // is not prompted at all.

            if( (dwRC = SetupPromptForDisk(hwndParent,
                                                NULL,
                                                NULL,
                                                lpBuffer,
                                                "RASCFG.DLL",
                                                TagFile,  // tag file
                                                IDF_CHECKFIRST,
                                                lpBuffer,
                                                MAX_PATH,
                                                &dwLen
                                                )) != DPROMPT_SUCCESS )
            {
                Dprintf("ICFG: Install: SetupPromptForDisk failed.\n");
                dwRC = GetLastError();
                goto GetLocationOfSetupFilesExit;
            }
        }

        // If we failed to get SourcePath from registry, then prompt the user once and use
        // this information for subsequent installs.

        else
        {
            if( (dwRC = SetupPromptForDisk(hwndParent,
                                                NULL,
                                                NULL,
                                                NULL,
                                                "RASCFG.DLL",
                                                TagFile,  // tag file
                                                IDF_CHECKFIRST,
                                                lpBuffer,
                                                MAX_PATH,
                                                &dwLen
                                                )) != DPROMPT_SUCCESS )
            {
                Dprintf("ICFG: Install: SetupPromptForDisk failed.\n");
                dwRC = GetLastError();
                goto GetLocationOfSetupFilesExit;
            }
        }
    }
GetLocationOfSetupFilesExit:
    if (ERROR_SUCCESS == dwRC)
    {
        IcfgSetInstallSourcePath(lpBuffer);
    }
    
    if (INVALID_HANDLE_VALUE != hInf)
    {
        SetupCloseInfFile(hInf);
        hInf = NULL;
    }

    if (NULL != hkey)
    {
        RegCloseKey(hkey);
    }
    return dwRC;
}

//+----------------------------------------------------------------------------
//
//  Function:   InstallNTNetworking
//
//  Synopsis:   Install NT Server, workstation, netbios, and RPC locator
//              services as needed
//
//  Arguemtns:  hwndParent - parent window
//
//  Returns:    win32 error code
//
//  History:    ChrisK  6/27/97 Created
//
//-----------------------------------------------------------------------------
DWORD InstallNTNetworking(HWND hwndParent)
{
    DWORD       dwRC = ERROR_SUCCESS;
    UINT        index = 0;
    DWORD       cchInfName = MAX_PATH;
    WCHAR       pszInfName[MAX_PATH+1];
    SC_HANDLE   hscman, hsvc;
    DWORD       dwReturn;

    Dprintf("ICFGNT.DLL: InstallNTNetworking.\n");

    Assert(NULL == hwndParent || IsWindow(hwndParent));

    if(ERROR_SUCCESS != (dwRC = LoadNetcfg()))
    {
        Dprintf("ICFGNT.DLL: Failed load Netcfg API's, error %d\n",dwRC);
        goto InstallNTNetworkingExit;
    }

    //
    // Check for and install services
    //
    for (index = 0; index < NSERVICES; index++)
    {
        Dprintf("ICFGNT.DLL: Check service %d\n",index);

        //
        // Install service if it is not installed
        //
        if(pfnNetSetupFindSoftwareComponent(
                g_netsetup[index].szOption,   // OPTION
                pszInfName,                 // INF Name
                &cchInfName,
                NULL,
                NULL) != ERROR_SUCCESS )
        {

            if (0 == g_wszInstallPath || 0 == lstrlenW(g_wszInstallPath))
            {
                GetLocationOfSetupFiles(hwndParent);
            }

            Dprintf("ICFGNT.DLL: Need service %d.\n",index);
            if((dwRC = pfnNetSetupComponentInstall(
                    hwndParent,
                    g_netsetup[index].szOption,   // OPTION
                    g_netsetup[index].szInfName,  // INF Name
                    g_wszInstallPath,             // Install path optional
                    NULL,                       // symbols, optional
                    2,                          // INFINSTALL_INPROCINTERP
                    &dwReturn)) != ERROR_SUCCESS )
             {
                Dprintf("ICFGNT.DLL: Installing service %d failed with error %d.\n",
                    index,
                    dwRC);
                 goto InstallNTNetworkingExit;
             }

             if (!lstrcmpiW(g_netsetup[index].szOption, L"WKSTA"))
             {                
                // if we installed the Workstation service, then we should disable
                // Netlogon service. We need to do this because netlogon service should
                // not be set to autostart if the user has not joined a domain.
                // 

                hscman = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS | GENERIC_WRITE );
                if( hscman == NULL) 
                {
                    dwRC = GetLastError();
                    Dprintf("ICFGNT.DLL: Failed to open serviceManager, error %d\n",dwRC);
                    goto InstallNTNetworkingExit;
                }

                hsvc = OpenService( hscman, SERVICE_NETLOGON, SERVICE_CHANGE_CONFIG );
                if ( hsvc == NULL) 
                {
                    dwRC = GetLastError();
                    Dprintf("ICFGNT.DLL: Failed to open service, error %d\n",dwRC);
                    goto InstallNTNetworkingExit;
                }
                ChangeServiceConfig( hsvc, SERVICE_NO_CHANGE, SERVICE_DEMAND_START, SERVICE_NO_CHANGE, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
                CloseServiceHandle(hsvc);
                CloseServiceHandle(hscman);
            }
        }
    }
InstallNTNetworkingExit:

    return dwRC;
}

//+----------------------------------------------------------------------------
//
//  Function:   GetRegValue
//
//  Synopsis:   Dynamically allocate memory and read value from registry
//
//  Arguments:  hKey - handle to key to be read
//              lpValueName - pointer to value name to be read
//              lpData - pointer to pointer to data
//
//  Returns:    Win32 error, ERROR_SUCCESS is it worked
//
//  History:    6/5/97  ChrisK  Inherited
//
//-----------------------------------------------------------------------------
inline LONG GetRegValue(HKEY hKey, LPSTR lpValueName, LPBYTE *lpData)
{
    LONG dwError;
    DWORD cbData;

    Dprintf("ICFGNT: GetRegValue\n");
    dwError = RegQueryValueExA(hKey,
                               lpValueName,
                               NULL,
                               NULL,
                               NULL,
                               &cbData);
    if(dwError != ERROR_SUCCESS)
    {
        return(dwError);
    }

    //
    // Allocate space and buffer incase we need to add more info later
    // see turn off the printing binding
    //
    *lpData = (LPBYTE) GlobalAlloc(GPTR,cbData + REG_DATA_EXTRA_SPACE);
    if(*lpData == 0)
    {
        return(ERROR_OUTOFMEMORY);
    }

    dwError = RegQueryValueExA(hKey,
                               lpValueName,
                               NULL,
                               NULL,
                               *lpData,
                               &cbData);
    if(dwError != ERROR_SUCCESS)
    {
        GlobalFree(*lpData);
    }

    return(dwError);
}

//+----------------------------------------------------------------------------
//
//  Function:   ParseNetSetupReturn
//
//  Synopsis:   Interprit return values from NetSetup* functions
//
//  Arguments:  dwReturn - return value from NetSetup* function
//
//  Returns:    fReboot - TRUE means reboot required
//              fBindReview - TRUE means binding review is required
//
//  History:    6/5/97  ChrisK  Inherited
//
//-----------------------------------------------------------------------------
inline void
ParseNetSetupReturn(DWORD dwReturn, BOOL &fReboot, BOOL &fBindReview)
{
    Dprintf("ICFGNT: ParseNetSetupReturn\n");
    if(dwReturn == 0 || dwReturn == 4)
    {
        fBindReview = TRUE;
    }
    if(dwReturn == 0 || dwReturn == 5)
    {
        fReboot = TRUE;
    }
}


//+----------------------------------------------------------------------------
//
//  Function:   ReviewBindings
//
//  Synopsis:   Force WinNT to review network bindings
//
//  Arguments:  hwndParent - handle to parent window
//
//  Returns:    win32 error code (ERROR_SUCCESS means it worked)
//
//  History:    6/5/97  ChrisK  Inherited
//
//-----------------------------------------------------------------------------
DWORD
ReviewBindings(HWND hwndParent)
{
    DWORD dwErr;

    Dprintf("ICFGNT: ReviewBindings\n");
    dwErr = LoadNetcfg();
    if(dwErr != ERROR_SUCCESS)
    {
        return(dwErr);
    }

    return(pfnNetSetupReviewBindings(hwndParent, 0));
}


//+----------------------------------------------------------------------------
//
//  Function:   CallModemInstallWizard
//
//  Synopsis:   Invoke modem install wizard via SetupDi interfaces
//
//  Arguments:  hwnd - handle to parent window
//
//  Returns:    TRUE - success, FALSE - failed
//
//  History:    6/5/97  ChrisK  Inherited
//
//-----------------------------------------------------------------------------
//
// The following code was stolen from RAS
//

BOOL
CallModemInstallWizard(HWND hwnd)
   /* call the Modem.Cpl install wizard to enable the user to install one or more modems
   **
   ** Return TRUE if the wizard was successfully invoked, FALSE otherwise
   **
   */
{
   HDEVINFO hdi;
   BOOL     fReturn = FALSE;
   // Create a modem DeviceInfoSet

   Dprintf("ICFGNT: CallModemInstallWizard\n");
   hdi = SetupDiCreateDeviceInfoList((LPGUID)&GUID_DEVCLASS_MODEM, hwnd);
   if (hdi)
   {
      SP_INSTALLWIZARD_DATA iwd;

      // Initialize the InstallWizardData

      ZeroMemory(&iwd, sizeof(iwd));
      iwd.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
      iwd.ClassInstallHeader.InstallFunction = DIF_INSTALLWIZARD;
      iwd.hwndWizardDlg = hwnd;

      // Set the InstallWizardData as the ClassInstallParams

      if (SetupDiSetClassInstallParams(hdi, NULL, (PSP_CLASSINSTALL_HEADER)&iwd, sizeof(iwd)))
      {
         // Call the class installer to invoke the installation
         // wizard.
         if (SetupDiCallClassInstaller(DIF_INSTALLWIZARD, hdi, NULL))
         {
            // Success.  The wizard was invoked and finished.
            // Now cleanup.
            fReturn = TRUE;

            SetupDiCallClassInstaller(DIF_DESTROYWIZARDDATA, hdi, NULL);
         }
      }

      // Clean up
      SetupDiDestroyDeviceInfoList(hdi);
   }
   return fReturn;
}

//+----------------------------------------------------------------------------
//
//  Function:   IsDialableISDNAdapters
//
//  Synopsis:   Some ISDN adapters can be installed as RAS devices, but not as
//              unimodem devices, so we have to walk through the rest of the
//              TAPI devices looking for these.
//
//  Arguments:  None
//
//  Returns:    TRUE - there is a device available
//
//  History:    7/22/97 ChrisK  Created
//
//-----------------------------------------------------------------------------
#define REG_TAPIDEVICES "software\\microsoft\\ras\\tapi devices"
LPSTR szAddress = "Address";
LPSTR szUsage = "Usage";
LPSTR szMediaType = "Media Type";
BOOL IsDialableISDNAdapters()
{
    BOOL bRC = FALSE;

    HKEY    hkey = NULL, hsubkey = NULL;
    DWORD   dwIdx = 0;
    CHAR    szBuffer[MAX_PATH + 1];
    CHAR    szSubKey[MAX_PATH + 1];
    LPBYTE  lpData = NULL;
    LPSTR   lpsUsage = NULL;
    szBuffer[0] = '\0';

    //
    // Open TAPI device key
    //
    if (ERROR_SUCCESS != RegOpenKey(HKEY_LOCAL_MACHINE,
                                    REG_TAPIDEVICES,
                                    &hkey))
    {
        Dprintf("ICFGNT Can not open TAPI key.\n");
        goto IsDialableISDNAdaptersExit;
    }

    //
    // Scan for non unimodem device
    //
    
    while (FALSE == bRC)
    {
        szBuffer[0] = '\0';
        if (ERROR_SUCCESS != RegEnumKey(hkey,dwIdx,szBuffer,MAX_PATH))
        {
            goto IsDialableISDNAdaptersExit;
        }
        Dprintf("ICFGNT sub key (%s) found.\n",szBuffer);

        if (0 != lstrcmpi(szBuffer,"unimodem"))
        {
            //
            // Open other TAPI device reg key
            //
            szSubKey[0] = '\0';
            wsprintf(szSubKey,"%s\\%s",REG_TAPIDEVICES,szBuffer);
            Dprintf("ICFGNT opening (%s).\n",szSubKey);
            if (ERROR_SUCCESS != RegOpenKey(HKEY_LOCAL_MACHINE,
                                            szSubKey,
                                            &hsubkey))
            {
                Dprintf("ICFGNT Can not open TAPI SUB key.\n");
                goto IsDialableISDNAdaptersExit;
            }

            if (ERROR_SUCCESS != GetRegValue(hsubkey,szUsage,&lpData))
            {
                Dprintf("ICFGNT Can not get TAPI SUB key.\n");
                goto IsDialableISDNAdaptersExit;
            }

            //
            // Scan for "client"
            //
            lpsUsage = (LPSTR)lpData;
            while (*lpsUsage != '\0')
            {
                if(NULL != strstr(lpsUsage, "Client"))
                {
                    Dprintf("ICFGNT client found for device.\n");
                    //
                    // We found a client device, now check that it is ISDN
                    //
                    GlobalFree(lpData);
                    lpData = NULL;
                    if (ERROR_SUCCESS != GetRegValue(hsubkey,szMediaType,&lpData))
                    {
                        Dprintf("ICFGNT Can not get TAPI SUB value key.\n");
                        goto IsDialableISDNAdaptersExit;
                    }
                    
                    if (0 == lstrcmpi((LPSTR)lpData,"ISDN"))
                    {
                        Dprintf("ICFGNT ISDN media type found.\n");
                        //
                        // This is a valid dial-out ISDN device!!!  Wahoo!!
                        //
                        bRC = TRUE;
                    }
                    else
                    {
                        Dprintf("ICFGNT ISDN media type NOT found.\n");
                    }
                }
                else
                {
                    lpsUsage += lstrlen(lpsUsage)+1;
                }
            }

            if (lpData)
            {
                GlobalFree(lpData);
                lpData = NULL;
                lpsUsage = NULL;
            }
        }

        //
        // Move to the next REG key
        //
        dwIdx++;
    }

IsDialableISDNAdaptersExit:
    if (hkey)
    {
        RegCloseKey(hkey);
        hkey = NULL;
    }
    if (hsubkey)
    {
        RegCloseKey(hsubkey);
        hsubkey = NULL;
    }
    if (lpData)
    {
        GlobalFree(lpData);
        lpData = NULL;
        lpsUsage = NULL;
    }

    return bRC;
}

//+----------------------------------------------------------------------------
//
//  Function:   IcfgNeedModem
//
//  Synopsis:   Check system configuration to determine if there is at least
//              one physical modem installed
//
//  Arguments:  dwfOptions - currently not used
//
//  Returns:    HRESULT - S_OK if successfull
//              lpfNeedModem - TRUE if no modems are available
//
//  History:    6/5/97  ChrisK  Inherited
//
//-----------------------------------------------------------------------------
LPSTR szRasUnimodemSubKey =
        "Software\\Microsoft\\ras\\TAPI DEVICES\\Unimodem";

HRESULT WINAPI
IcfgNeedModemNT4 (DWORD dwfOptions, LPBOOL lpfNeedModem) 
{
    //
    // Ras is insatlled, and ICW wants to know if it needs to
    // install a modem.
    //
    *lpfNeedModem = TRUE;

    //
    //  ChrisK 7/22/97
    //  Added return code in order to provide centralized place to check
    //  for ISDN installations
    //
    HRESULT hRC = ERROR_SUCCESS;

    //
    // Check what modems are available to RAS
    //

    HKEY    hUnimodem;
    LONG    dwError;

    Dprintf("ICFGNT: IcfgNeedModem\n");

    dwError = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           szRasUnimodemSubKey,
                           0,
                           KEY_READ,
                           &hUnimodem);

    if(dwError != ERROR_SUCCESS)
    {
        goto IcfgNeedModemExit;
    }
    else
    {
        LPBYTE   lpData;

        dwError = GetRegValue(hUnimodem, szUsage, &lpData);
        if(dwError != ERROR_SUCCESS)
            goto IcfgNeedModemExit;

        LPBYTE  lpData2;
        dwError = GetRegValue(hUnimodem, szAddress, &lpData2);
        if(dwError != ERROR_SUCCESS)
        {
            hRC = dwError;
            goto IcfgNeedModemExit;
        }
        else
        {
            //
            // Try finding a Client or ClientAndServer Modem
            // Also, make sure all modems have corresponding TAPI devices
            //

            LPSTR   pUsage = (LPSTR) lpData;
            LPSTR   pAddress = (LPSTR) lpData2;
            char    portsbuf[1000];

            dwError = EnumerateTapiModemPorts(sizeof(portsbuf), portsbuf);
            if(dwError)
            {
                hRC = dwError;
                goto IcfgNeedModemExit;
            }

            while(*pUsage != '\0') {
                if(lstrcmp(pUsage, "Client") == 0 ||
                    lstrcmp(pUsage, "ClientAndServer") == 0 ||
                    lstrcmp(pUsage, "ClientAndServerAndRouter") == 0) 

                {
                        *lpfNeedModem = FALSE;
                }

                //
                // Make sure a corresponding TAPI port exists
                //

                LPSTR pPorts = portsbuf;
                while(*pPorts != '\0')
                    if(stricmp(pAddress, pPorts) == 0)
                    {
                        break;
                    }
                    else
                    {
                        pPorts += lstrlen(pPorts) + 1;
                    }

                if(*pPorts == '\0')
                {
                    hRC = ERROR_INTERNAL_ERROR;
                    goto IcfgNeedModemExit;
                }

                pUsage += lstrlen(pUsage) + 1;
                pAddress += lstrlen(pAddress) + 1;
            }
        }
    }

IcfgNeedModemExit:
    //
    // If there was some problem finding a typical dial out device,
    // then try again and check for dialing ISDN devices.
    //
    if (ERROR_SUCCESS != hRC ||
        FALSE != *lpfNeedModem)
    {
        if (IsDialableISDNAdapters())
        {
            hRC = ERROR_SUCCESS;
            *lpfNeedModem = FALSE;
        }
    }

    return(hRC);
}

//+----------------------------------------------------------------------------
//
//  Function:   IcfgInstallModem
//
//  Synopsis:
//              This function is called when ICW verified that RAS is installed,
//              but no modems are avilable. It needs to make sure a modem is availble.
//              There are two possible scenarios:
//
//              a.  There are no modems installed.  This happens when someone deleted
//                  a modem after installing RAS. In this case we need to run the modem
//                  install wizard, and configure the newly installed modem to be a RAS
//                  dialout device.
//
//              b.  There are modems installed, but non of them is configured as a dial out
//                  device.  In this case, we silently convert them to be DialInOut devices,
//                  so ICW can use them.
//
//  Arguments:  hwndParent - handle to parent window
//              dwfOptions - not used
//
//  Returns:    lpfNeedsStart - not used
//
//  History:    6/5/97  ChrisK  Inherited
//
//-----------------------------------------------------------------------------
HRESULT WINAPI
IcfgInstallModemNT4 (HWND hwndParent, DWORD dwfOptions, LPBOOL lpfNeedsStart) 
{
    //
    // Check what modems are available to RAS
    //

    HKEY    hUnimodem;
    LONG    dwError;
    BOOL    fInstallModem = FALSE;

    Dprintf("ICFGNT: IcfgInstallModem\n");

    dwError = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           szRasUnimodemSubKey,
                           0,
                           KEY_READ,
                           &hUnimodem);

    if(dwError != ERROR_SUCCESS)
    {
        fInstallModem = TRUE;
    }
    else 
    {
            LPBYTE   lpData;

            dwError = GetRegValue(hUnimodem, szUsage, &lpData);
            if(dwError != ERROR_SUCCESS)
            {
                fInstallModem = TRUE;
            }
            else 
            {
                // Make sure at least one modem exists
                if(*lpData == '\0')
                {
                    fInstallModem = TRUE;
                }
            }
    }

    if(fInstallModem) 
    {
        //
        // Fire up the modem install wizard
        //

        if(!CallModemInstallWizard(hwndParent))
        {
            return(g_dwLastError = GetLastError());
        }

        //
        // Now configure the new modem to be a dial out device.
        //

        //
        // Install ras again with unattneded file!
        //

        return(ERROR_SUCCESS);

    }
    else 
    {
        //
        // We need to reconfigure dial in devices to be dialinout
        //

        //
        // install ras again with unattended file!
        //
        return(ERROR_SUCCESS);
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   IcfgNeedInetComponets
//
//  Synopsis:   Check to see if the components marked in the options are
//              installed on the system
//
//  Arguements: dwfOptions - set of bit flag indicating which components to
//              check for
//
//  Returns;    HRESULT - S_OK if successfull
//              lpfNeedComponents - TRUE is some components are not installed
//
//  History:    6/5/97  ChrisK  Inherited
//
//-----------------------------------------------------------------------------
HRESULT WINAPI
IcfgNeedInetComponentsNT4(DWORD dwfOptions, LPBOOL lpfNeedComponents) {
    DWORD dwErr;

    //
    // Assume need nothing
    //
    *lpfNeedComponents = FALSE;

    Dprintf("ICFGNT: IcfgNeedInetComponents\n");
    dwErr = LoadNetcfg();
    if(dwErr != ERROR_SUCCESS)
    {
        return(g_dwLastError = dwErr);          // Shouldn't we map to hResult?
    }

    WCHAR wszInfNameBuf[512];
    DWORD cchInfName = sizeof(wszInfNameBuf) / sizeof(WCHAR);

    if(dwfOptions & ICFG_INSTALLTCP) 
    {
        dwErr = pfnNetSetupFindSoftwareComponent(L"TC",
                                          wszInfNameBuf,
                                          &cchInfName,
                                          0,
                                          0);
        if(dwErr != ERROR_SUCCESS)
            *lpfNeedComponents = TRUE;
    }

    if(dwfOptions & ICFG_INSTALLRAS) 
    {
       dwErr = pfnNetSetupFindSoftwareComponent(L"RAS",
                                          wszInfNameBuf,
                                          &cchInfName,
                                          0,
                                          0);
       if(dwErr != ERROR_SUCCESS)
            *lpfNeedComponents = TRUE;
    }

    if(dwfOptions & ICFG_INSTALLMAIL) 
    {
        // How do we do this?
    }

    return(ERROR_SUCCESS);
}

//+----------------------------------------------------------------------------
//
//  Function:   GenerateRasUnattendedFile
//
//  Synopsis:   Create the file that will provide RAS setup the necessary
//              setting to install in an unattended mode
//
//  Arguments:  wszTmpFile - name of file to create
//              szPortsBuf
//
//  Returns:    FALSE - failure, TRUE - success
//
//  History:    6/5/97  ChrisK  Inherited
//
//-----------------------------------------------------------------------------
BOOL
GenerateRasUnattendedFile(LPWSTR wszTmpFile, LPSTR szPortsBuf)
{
    WCHAR wszTmpPath[MAX_PATH+1];
    WCHAR wszTmpShortPath[MAX_PATH+1];

    //
    // Create temporary file name and convert to non-wide form
    //

    Dprintf("ICFGNT: GenerateRasUnattendedFile\n");

    if (GetTempPathW(MAX_PATH, wszTmpPath) == 0)
    {
        return(FALSE);
    }

    //
    // always attempt to create the temp dir as the temp dir may not exist if 
    // the user logs in with a roaming profile
    //
    CreateDirectoryW(wszTmpPath, NULL);

    //
    // need to convert this to a short path since pfnNetSetupComponentInstall()
    // doesn't like to have a long path in the InfSymbols param.
    //
    if (!GetShortPathNameW(wszTmpPath, wszTmpShortPath, MAX_PATH))
    {
        return FALSE;
    }

    if (GetTempFileNameW(wszTmpPath, L"icw", 0, wszTmpFile) == 0)
    {
        return(FALSE);
    }

    //
    // need to convert the temp filename to shortpath too!
    //
    if (!GetShortPathNameW(wszTmpFile, wszTmpShortPath, MAX_PATH))
    {
        return FALSE;
    }
    wcscpy(wszTmpFile, wszTmpShortPath); 

    char szTmpFile[MAX_PATH+1];
    wcstombs(szTmpFile, wszTmpFile, wcslen(wszTmpFile) + 1);

#if 0
/*
    FILE *fp = fopen(szTmpFile, "w");

    if(fp == 0)
    {
        return(FALSE);
    }

    fprintf(fp, "[RemoteAccessParameters]\n");
    fprintf(fp, "PortSections    = ");

    LPSTR szPorts = szPortsBuf;

    while(*szPorts) {
        if(szPorts != szPortsBuf)
        {
            fprintf(fp, ",");
        }
        fprintf(fp, "%s", szPorts);
        szPorts += lstrlen(szPorts) + 1;
    }

    fprintf(fp, "\n");
    fprintf(fp, "DialoutProtocols    = TCP/IP\n");
    fprintf(fp, "\n");
    fprintf(fp, "[Modem]\n");
    fprintf(fp, "InstallModem=ModemSection\n");
    fprintf(fp, "\n");

    szPorts = szPortsBuf;

    while(*szPorts) {
        fprintf(fp, "[%s]\n", szPorts);
        fprintf(fp, "PortName        = %s\n", szPorts);
        fprintf(fp, "DeviceType      = Modem\n");
        fprintf(fp, "PortUsage       = DialOut\n");
        fprintf(fp, "\n");
        szPorts += lstrlen(szPorts) + 1;
    }

    fprintf(fp, "[ModemSection]\n");

    fclose(fp);
*/

#else

    //
    // Open the file for writing, bail on fail.
    //

    BOOL bRet = FALSE;

    HANDLE hFile = CreateFile(szTmpFile,GENERIC_WRITE,0,NULL,OPEN_EXISTING, 
                       FILE_ATTRIBUTE_NORMAL,NULL);

    if (INVALID_HANDLE_VALUE == hFile)
    {
        return FALSE;
    }

    LPSTR szPorts = szPortsBuf;
    char szFileBuf[MAX_PATH];
    DWORD dwWrite;
    
    lstrcpy(szFileBuf, "[RemoteAccessParameters]\nPortSections    = ");

    if (!WriteFile(hFile, szFileBuf, lstrlen(szFileBuf), &dwWrite, NULL))
    {
        goto closefile;
    }

    while (*szPorts) 
    {
        //
        // Delimit each item with a comma
        //

        if (szPorts != szPortsBuf)
        {
            lstrcpy(szFileBuf, ",");
            if (!WriteFile(hFile, szFileBuf, lstrlen(szFileBuf), &dwWrite, NULL))
            {
                goto closefile;
            }
        }

        //
        // Write each port 
        //

        wsprintf(szFileBuf, "%s", szPorts);

        if (!WriteFile(hFile, szFileBuf, lstrlen(szFileBuf), &dwWrite, NULL))
        {
            goto closefile;
        }
                     
        szPorts += lstrlen(szPorts) + 1;
    }
 
    //
    // Write DialoutProtocol TCP/IP and InstallModem
    //

    lstrcpy(szFileBuf, "\nDialoutProtocols    = TCP/IP\n\n[Modem]\nInstallModem=ModemSection\n\n");

    if (!WriteFile(hFile, szFileBuf, lstrlen(szFileBuf), &dwWrite, NULL))
    {
        goto closefile;
    }

    //
    // Enumerate ports again
    //

    szPorts = szPortsBuf;

    while (*szPorts) 
    {
        //
        // Write PortName section and entry
        //

        wsprintf(szFileBuf, "[%s]\n", szPorts);

        if (!WriteFile(hFile, szFileBuf, lstrlen(szFileBuf), &dwWrite, NULL))
        {
            goto closefile;
        }

        wsprintf(szFileBuf, "PortName        = %s\n", szPorts);

        if (!WriteFile(hFile, szFileBuf, lstrlen(szFileBuf), &dwWrite, NULL))
        {
            goto closefile;
        }

        //
        // Write DeviceType and PortUsage entry for each port
        //
        
        lstrcpy(szFileBuf, "DeviceType      = Modem\nPortUsage       = DialOut\n\n");

        if (!WriteFile(hFile, szFileBuf, lstrlen(szFileBuf), &dwWrite, NULL))
        {
            goto closefile;
        }

        szPorts += lstrlen(szPorts) + 1;
    }

    lstrcpy(szFileBuf, "[ModemSection]\n");

    if (!WriteFile(hFile, szFileBuf, lstrlen(szFileBuf), &dwWrite, NULL))
    {
        goto closefile;
    }

    bRet = TRUE;

closefile:

    CloseHandle(hFile);

#endif

    return(bRet);
}

//+----------------------------------------------------------------------------
//
//  Function:   InstallRAS
//
//  Synopsis:   Invoke unattended RAS installation
//
//  Arguments:  hwndParent - handle to parent window
//              szFile - name of unattended settings file
//              szSection -
//
//  Returns:    DWORD - win32 error
//              pdwReturn - return code from last parameter of
//                  pfnNetSetupComponentInstall
//
//  History:    6/5/97  ChrisK  Inherited
//
//-----------------------------------------------------------------------------
DWORD
InstallRAS(HWND hwndParent, LPWSTR szFile, LPWSTR szSection, LPDWORD pdwReturn) 
{
    WCHAR InfSymbols[1024];
    LPWSTR szInfSymbols = InfSymbols;

    Dprintf("ICFGNT: InstallRAS\n");

    DWORD dwRC = InstallNTNetworking(hwndParent);
    if (ERROR_SUCCESS != dwRC)
    {
        return dwRC;
    }

    LPWSTR szString1 = L"!STF_GUI_UNATTENDED";
    wcscpy(szInfSymbols, szString1);
    szInfSymbols += wcslen(szString1) + 1;

    LPWSTR szString2 = L"YES";
    wcscpy(szInfSymbols, szString2);
    szInfSymbols += wcslen(szString2) + 1;

    LPWSTR szString3 = L"!STF_UNATTENDED";
    wcscpy(szInfSymbols, szString3);
    szInfSymbols += wcslen(szString3) + 1;

    //
    // Unattneded file.
    //

    wcscpy(szInfSymbols, szFile);
    szInfSymbols += wcslen(szFile) + 1;

    LPWSTR szString4 = L"!STF_UNATTENDED_SECTION";
    wcscpy(szInfSymbols, szString4);
    szInfSymbols += wcslen(szString4) + 1;

    //
    // Unattnded section
    //

    wcscpy(szInfSymbols, szSection);
    szInfSymbols += wcslen(szSection) + 1;

    *szInfSymbols++ = 0;
    *szInfSymbols++ = 0;

    return(pfnNetSetupComponentInstall(hwndParent,
                                       L"RAS",
                                       L"OEMNSVRA.INF",
                                       g_wszInstallPath,
                                       InfSymbols,
                                       INFINSTALL_INPROCINTERP,     // Install Flags
                                       pdwReturn));
}


//+----------------------------------------------------------------------------
//
//  Function:   IcfgInstallInetComponents
//
//  Synopsis:   Install the components as specified by the dwfOptions values
//
//  Arguments   hwndParent - handle to parent window
//              dwfOptions - set of bit flags indicating which components to
//                  install
//
//  Returns:    HRESULT - S_OK if success
//              lpfNeedsReboot - TRUE if reboot is required
//
//  History:    6/5/97  ChrisK  Inherited
//
//-----------------------------------------------------------------------------
HRESULT WINAPI
IcfgInstallInetComponentsNT4(HWND hwndParent, DWORD dwfOptions, LPBOOL lpfNeedsRestart)
{
    DWORD dwErr;
    DWORD dwReturn;
    BOOL fNeedsReview;
    BOOL fNeedsRestart;
    BOOL fDoReview = FALSE;
    WCHAR wszInfNameBuf[512];
    DWORD cchInfName = sizeof(wszInfNameBuf) / sizeof(WCHAR);

    Dprintf("ICFGNT: IcfgInstallInetComponents\n");
    //
    // Assume don't need restart
    //
    *lpfNeedsRestart = FALSE;

    dwErr = LoadNetcfg();
    if(dwErr != ERROR_SUCCESS)
    {
        return(g_dwLastError = dwErr);          // Review: Shouldn't we map to hResult?
    }

    if(dwfOptions & ICFG_INSTALLTCP) 
    {
        dwErr = pfnNetSetupFindSoftwareComponent(L"TC",
                                          wszInfNameBuf,
                                          &cchInfName,
                                          0,
                                          0);
        if(dwErr != ERROR_SUCCESS) 
        {
            dwErr = pfnNetSetupComponentInstall(hwndParent,
                                            L"TC",
                                            L"OEMNXPTC.INF",
                                            g_wszInstallPath,
                                            L"\0\0",
                                            INFINSTALL_INPROCINTERP,     // Install Flags
                                            &dwReturn);
            if(dwErr != ERROR_SUCCESS)
            {
                return(g_dwLastError = dwErr);      // Review: Shouldn't we map to hResult?
            }

            ParseNetSetupReturn(dwReturn, fNeedsRestart, fNeedsReview);
            if(fNeedsRestart)
            {
                *lpfNeedsRestart = TRUE;
            }
            if(fNeedsReview)
            {
                fDoReview = TRUE;
            }
        }
    }

    if(dwfOptions & ICFG_INSTALLRAS) 
    {
        dwErr = pfnNetSetupFindSoftwareComponent(L"RAS",
                                          wszInfNameBuf,
                                          &cchInfName,
                                          0,
                                          0);
       if(dwErr != ERROR_SUCCESS) 
       {
            //
            // Before we install RAS, we have to make have to make sure a modem
            // is installed, because RAS will try to run the modem detection wizard
            // in unattneded mode if there are no modems, and we don't want that.
            //
            // The way we do that is we enumerate devices through TAPI, and if there are
            // no modems installed, we call the modem install wizard.  Only after
            // we make sure a modem was installed, we call ras install.
            //

            DWORD   DoTapiModemsExist(LPBOOL pfTapiModemsExist);
            char    portsbuf[1000];

            dwErr = EnumerateTapiModemPorts(sizeof(portsbuf), portsbuf);
            if(dwErr)
                return(g_dwLastError = dwErr);

            if(*portsbuf == 0) 
            {
                if(!CallModemInstallWizard(hwndParent))
                {
                    //
                    // if CallModemInstallWizard returned FALSE and 
                    // GetLastError() is ERROR_SUCCESS, it is actually
                    // a user cancelled case
                    //
                    if (ERROR_SUCCESS == (g_dwLastError = GetLastError()))
                        g_dwLastError = ERROR_CANCELLED;
                    return(g_dwLastError);
                }

                //
                // In this invocation of EnumerateTapiModemPorts
                // we have to wait for a 1 second before we start
                // enumerating the modems - hence set the last parameter
                // to TRUE  -- VetriV
                //
                dwErr = EnumerateTapiModemPorts(sizeof(portsbuf), portsbuf, 
                                                    TRUE);
                if(dwErr)
                {
                    return(g_dwLastError = dwErr);
                }

                if(*portsbuf == 0)
                {
                    return(g_dwLastError = ERROR_CANCELLED);
                }
            }

            WCHAR wszUnattFile[MAX_PATH];

            if(!GenerateRasUnattendedFile(wszUnattFile, portsbuf))
            {
                return(g_dwLastError = GetLastError());
            }

            dwErr = InstallRAS(hwndParent,
                           wszUnattFile,
                           L"RemoteAccessParameters",
                           &dwReturn);
            DeleteFileW(wszUnattFile);

            if(dwErr != ERROR_SUCCESS)
            {
                return(g_dwLastError = dwErr);      // Review: Shouldn't we map to hResult?
            }

            ParseNetSetupReturn(dwReturn, fNeedsRestart, fNeedsReview);
            if(fNeedsRestart)
            {
                *lpfNeedsRestart = TRUE;
            }
            if(fNeedsReview)
            {
                fDoReview = TRUE;
            }
       }
    }

    if(fDoReview)
    {
        return(g_dwLastError = ReviewBindings(hwndParent));  // Review: Shouldn't we map to hresult?
    }
    else
    {
        return(ERROR_SUCCESS);
    }
}


//+----------------------------------------------------------------------------
//
//  Function:   IcfgIsFileSharingTurnedOn
//
//  Synopsis:   Check network bindings to determine if "Server" service is
//              bound to ndiswan adapter
//
//  Arguments:  dwfDriverType -
//
//  Returns:    HRESULT - S_OK is success
//              lpfSharingOn - TRUE if sharing is bound
//
//  History:    6/5/97  ChrisK  Inherited
//
//-----------------------------------------------------------------------------
LPSTR szLanManServerSubKey = "SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\Linkage";
LPSTR szBind = "Bind";
LPSTR szExport = "Export";
LPSTR szRoute = "Route";
LPSTR szLanManServerDisabledSubKey = "SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\Linkage\\Disabled";
LPSTR szNdisWan4 = "NdisWan";
struct BINDDATA
{
    CHAR *startb;
    CHAR *currb;
    CHAR *starte;
    CHAR *curre;
    CHAR *startr;
    CHAR *currr;
} net_bindings;

HRESULT WINAPI
IcfgIsFileSharingTurnedOn(DWORD dwfDriverType, LPBOOL lpfSharingOn)
{
    HRESULT hr = ERROR_SUCCESS;
    HKEY hKey = NULL;
    LPBYTE lpData = NULL;
    CHAR *p;

    Dprintf("ICFGNT: IcfgIsFileSharingTurnedOn\n");
    Assert(lpfSharingOn);
    if (NULL == lpfSharingOn)
    {
        hr = ERROR_INVALID_PARAMETER;
        goto IcfgIsFileSharingTurnedOnExit;
    }

    *lpfSharingOn = FALSE;

    //
    // Open lanmanServer registry key
    //
    if (ERROR_SUCCESS != RegOpenKey(HKEY_LOCAL_MACHINE,
                                szLanManServerSubKey,
                                &hKey))
    {
        Dprintf("ICFGNT: Failed to open lanmanServer key\n");
        goto IcfgIsFileSharingTurnedOnExit;
    }

    if (ERROR_SUCCESS != GetRegValue(hKey, szBind, &lpData))
    {
        Dprintf("ICFGNT: Failed to read binding information\n");
        goto IcfgIsFileSharingTurnedOnExit;
    }
    Assert(lpData);
    
    //
    // Look for a particular string in the data returned
    // Note: data is terminiated with two NULLs
    //
    p = (CHAR *)lpData;
    while (*p)
    {
        if (strstr( p, szNdisWan4)) 
        {
            Dprintf("ICFGNT: NdisWan4 binding found in %s\n",p);
            *lpfSharingOn = TRUE;
            break;
        }
        p += (lstrlen( p ) + 1);
    }

    
IcfgIsFileSharingTurnedOnExit:
    if (hKey)
    {
        RegCloseKey(hKey);
        hKey = NULL;
    }

    if (lpData)
    {
        GlobalFree(lpData);
        lpData = NULL;
    }
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   MoveNextBinding
//
//  Synopsis:   Move to the next string in a MULTISZ data buffer
//
//  Arguments:  lpcBinding - pointer to address of current buffer position
//
//  Returns:    lpcBinding - pointer to next string
//
//  History:    6/5/97 ChrisK Created
//
//-----------------------------------------------------------------------------
inline void MoveNextBinding(CHAR **lplpcBinding)
{
    Dprintf("ICFGNT: MoveNextBinding\n");
    Assert(lplpcBinding && *lplpcBinding);
    if (lplpcBinding && *lplpcBinding)
    {
        *lplpcBinding += (lstrlen(*lplpcBinding)+1);
    }
    else
    {
        Dprintf("ICFGNT: MoveNextBinding received invalid parameter\n");
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   CompactLinkage
//
//  Synopsis:   Compact a list of Multi_SZ data
//
//  Arguments:  lpBinding - point to the string of an Multi_Sz list that should
//              be over written
//
//  Returns:    none
//
//  History:    6/5/97  ChrisK Created
//
//-----------------------------------------------------------------------------
inline void CompactLinkage(CHAR *lpBinding)
{
    Dprintf("ICFGNT: CompactLinkage\n");
    Assert(lpBinding && *lpBinding);
    CHAR *lpLast = lpBinding;
    BOOL fNULLChar = FALSE;

    MoveNextBinding(&lpBinding);

    //
    // ChrisK Olympus 6311 6/11/97
    // Do not compact on a per string basis.  This causes the data to become
    // corrupted if the string being removed is shorter than the string being
    // added.  Instead compact on a per character basis, since those are always
    // the same size (on a given machine).
    //
    while (!fNULLChar || *lpBinding)
    {
        if (NULL == *lpBinding)
        {
            fNULLChar = TRUE;
        }
        else
        {
            fNULLChar = FALSE;
        }
        *lpLast++ = *lpBinding++;
    }

    //while (*lpBinding)
    //{
    //  lstrcpy(lpLast,lpBinding);
    //  lpLast = lpBinding;
    //  MoveNextBinding(&lpBinding);
    //}

    //
    // Add second terminating NULL
    //
    *lpLast = '\0';
}

//+----------------------------------------------------------------------------
//
//  Function:   SizeOfMultiSz
//
//  Synopsis:   determine the total size of a Multi_sz list, including
//              terminating NULLs
//
//  Arguments:  s - pointer to list
//
//  Returns:    DWORD - size of s
//
//  History:    6/5/97  ChrisK  created
//
//-----------------------------------------------------------------------------
DWORD SizeOfMultiSz(CHAR *s)
{
    Dprintf("ICFGNT: SizeOfMultiSz\n");
    Assert(s);
    DWORD dwLen = 0;
    //
    // total size of all strings
    //

    //
    // ChrisK Olympus 6311 6/11/97
    // Add special case for empty MultiSZ strings
    //

    //
    // Special case for empty MultiSz.
    // Note: even "empty" MultiSZ strings still have the two null terminating characters
    //
    if (!(*s))
    {
        //
        // Make sure we actually have two terminating NULLs in this case.
        //
        Assert(s[1] == '\0');
        //
        // Count terminating NULL.
        //
        dwLen = 1;
    }

    while (*s)
    {
        dwLen += lstrlen(s) + 1;
        s += lstrlen(s) + 1;
    }
    //
    // plus one for the extra terminating NULL
    //
    dwLen++;
    Dprintf("ICFGNT: SizeOfMultiSz returns %d\n", dwLen);

    return dwLen;
}

//+----------------------------------------------------------------------------
//
//  Function:   WriteBindings
//
//  Synopsis:   Write the data from a BINDDATA structure to the key given
//
//  Arguments:  bd - BINDDATA structure with data to be written
//              hKey - handle of registry key to get data
//
//  Returns:    win32 error code
//
//  History:    6/5/97  ChrisK  created
//
//-----------------------------------------------------------------------------
DWORD WriteBindings(BINDDATA bd, HKEY hKey)
{
    DWORD dwRC = ERROR_SUCCESS;
    DWORD dwSize;

    Assert (hKey &&
        bd.startb &&
        bd.starte &&
        bd.startr);

    Dprintf("ICFGNT: WriteBindings\n");

    //
    // Bind
    //
    dwSize = SizeOfMultiSz(bd.startb);
    if (ERROR_SUCCESS != (dwRC = RegSetValueEx(hKey,
                                    szBind,
                                    NULL,
                                    REG_MULTI_SZ,
                                    (LPBYTE)bd.startb,
                                    dwSize)))
    {
        Dprintf("ICFGNT: Failed to write Bind key\n");
        goto WriteBindingsExit;
    }
    
    //
    // Export
    //
    dwSize = SizeOfMultiSz(bd.starte);
    if (ERROR_SUCCESS != (dwRC = RegSetValueEx(hKey,
                                    szExport,
                                    NULL,
                                    REG_MULTI_SZ,
                                    (LPBYTE)bd.starte,
                                    dwSize)))
    {
        Dprintf("ICFGNT: Failed to write export key\n");
        goto WriteBindingsExit;
    }

    //
    // Route
    //
    dwSize = SizeOfMultiSz(bd.startr);
    if (ERROR_SUCCESS != (dwRC = RegSetValueEx(hKey,
                                    szRoute,
                                    NULL,
                                    REG_MULTI_SZ,
                                    (LPBYTE)bd.startr,
                                    dwSize)))
    {
        Dprintf("ICFGNT: Failed to write route key\n");
        goto WriteBindingsExit;
    }

WriteBindingsExit:
    return dwRC;
}

//+----------------------------------------------------------------------------
//
//  Function:   IcfgTurnOffFileSharing
//
//  Synopsis;   Disable the binding between the "server" net service and the
//              ndiswan4 device
//
//  Arguments:  dwfDriverType - 
//              hwndParent - parent window
//
//  Returns:    HRESULT - S_OK if success
//
//  History:    6/5/97  ChrisK  Inherited
//
//-----------------------------------------------------------------------------
HRESULT WINAPI
IcfgTurnOffFileSharing(DWORD dwfDriverType, HWND hwndParent)
{
    BINDDATA LinkData = {NULL, NULL, NULL, NULL, NULL, NULL};
    BINDDATA DisData = {NULL, NULL, NULL, NULL, NULL, NULL};
    HKEY hKeyLink = NULL;
    HKEY hKeyDis = NULL;
    HRESULT hr = ERROR_SUCCESS;
    BOOL bUpdateReg = FALSE;

    Dprintf("ICFGNT: IcfgTurnOffFileSharing\n");
    Assert(hwndParent);
    if (NULL == hwndParent)
    {
        hr = ERROR_INVALID_PARAMETER;
        goto IcfgTurnOffFileSharingExit;
    }

    //
    // Open Keys and read binding data
    //
    if (ERROR_SUCCESS != RegOpenKey(HKEY_LOCAL_MACHINE,
                            szLanManServerSubKey,
                            &hKeyLink))
    {
        Dprintf("ICFGNT: failed to open linkdata key\n");
        goto IcfgTurnOffFileSharingExit;
    }

    if (ERROR_SUCCESS != RegOpenKey(HKEY_LOCAL_MACHINE,
                            szLanManServerDisabledSubKey,
                            &hKeyDis))
    {
        Dprintf("ICFGNT: failed to open linkdata key\n");
        goto IcfgTurnOffFileSharingExit;
    }

    GetRegValue(hKeyLink,szBind,(LPBYTE*)&LinkData.startb);
    GetRegValue(hKeyLink,szExport,(LPBYTE*)&LinkData.starte);
    GetRegValue(hKeyLink,szRoute,(LPBYTE*)&LinkData.startr);
    GetRegValue(hKeyDis,szBind,(LPBYTE*)&DisData.startb);
    GetRegValue(hKeyDis,szExport,(LPBYTE*)&DisData.starte);
    GetRegValue(hKeyDis,szRoute,(LPBYTE*)&DisData.startr);

    //
    // Initialize all current pointers
    //
    LinkData.currb = LinkData.startb;
    LinkData.curre = LinkData.starte;
    LinkData.currr = LinkData.startr;

    DisData.currb = DisData.startb;
    while (*DisData.currb)
    {
        MoveNextBinding(&DisData.currb);
    }

    DisData.curre = DisData.starte;
    while (*DisData.curre)
    {
        MoveNextBinding(&DisData.curre);
    }

    DisData.currr = DisData.startr;
    while (*DisData.currr)
    {
        MoveNextBinding(&DisData.currr);
    }

    //
    // Scan linkages for NdisWan4 bindings
    //

    while (*LinkData.currb)
    {
        if (strstr(LinkData.currb, szNdisWan4))
        {
            Dprintf("ICFGNT: server binding found in %s\n",LinkData.currb);

            //
            // move binding to disabled list
            //
 
            lstrcpy(DisData.currb,LinkData.currb);
            lstrcpy(DisData.curre,LinkData.curre);
            lstrcpy(DisData.currr,LinkData.currr);

            //
            // Advanve current pointers in DisData
            //
            MoveNextBinding(&DisData.currb);
            MoveNextBinding(&DisData.curre);
            MoveNextBinding(&DisData.currr);

            //
            // Compact remaining linkage
            //
            CompactLinkage(LinkData.currb);
            CompactLinkage(LinkData.curre);
            CompactLinkage(LinkData.currr);

            bUpdateReg = TRUE;
        }
        else
        {
            //
            // Advance to next binding
            //
            MoveNextBinding(&LinkData.currb);
            MoveNextBinding(&LinkData.curre);
            MoveNextBinding(&LinkData.currr);
        }
    }
    
    if (bUpdateReg)
    {
        WriteBindings(LinkData,hKeyLink);
        WriteBindings(DisData,hKeyDis);

        RegCloseKey(hKeyDis);
        hKeyDis = NULL;

        RegCloseKey(hKeyLink);
        hKeyLink = NULL;

#if defined(_DEBUG)
        Dprintf("ICFGNT: ReviewBindings returnded %d\n",ReviewBindings(hwndParent));
#else
        ReviewBindings(hwndParent);
#endif
    }

IcfgTurnOffFileSharingExit:
    if (hKeyDis)
    {
        RegCloseKey(hKeyDis);
        hKeyDis = NULL;
    }

    if (hKeyLink)
    {
        RegCloseKey(hKeyLink);
        hKeyLink = NULL;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\ccfgnt\icfg32.cpp ===
/****************************************************************************
 *
 *	icfg32.cpp
 *
 *	Microsoft Confidential
 *	Copyright (c) 1992-1998 Microsoft Corporation
 *	All rights reserved
 *
 *	This module provides the implementation of the methods for
 *  the NT specific functionality of inetcfg
 *
 *	6/5/97	ChrisK	Inherited from AmnonH
 *
 ***************************************************************************/

#include <windows.h>
#include <wtypes.h>
#include <cfgapi.h>
#include <stdio.h>
#include <stdlib.h>
#include <setupapi.h>
#include <basetyps.h>
#include <devguid.h>
#include <lmsname.h>
#include "debug.h"

#define REG_DATA_EXTRA_SPACE 255

extern DWORD g_dwLastError;



//+----------------------------------------------------------------------------
//
//	Function	GetOSBuildNumber
//
//	Synopsis	Get the build number of Operating system
//
//	Arguments	None
//
//	Returns		Build Number of OS
//
//	History		3/5/97		VetriV		Created
//
//-----------------------------------------------------------------------------
DWORD GetOSMajorVersionNumber(void)
{
	OSVERSIONINFO oviVersion;

	ZeroMemory(&oviVersion,sizeof(oviVersion));
	oviVersion.dwOSVersionInfoSize = sizeof(oviVersion);
	GetVersionEx(&oviVersion);
	return(oviVersion.dwMajorVersion);
}



//+----------------------------------------------------------------------------
//
//	Function:	IcfgNeedModem
//
//	Synopsis:	Check system configuration to determine if there is at least
//				one physical modem installed
//
//	Arguments:	dwfOptions - currently not used
//
//	Returns:	HRESULT - S_OK if successfull
//				lpfNeedModem - TRUE if no modems are available
//
//	History:	6/5/97	ChrisK	Inherited
//
//-----------------------------------------------------------------------------
HRESULT WINAPI
IcfgNeedModem (DWORD dwfOptions, LPBOOL lpfNeedModem) 
{
	if (GetOSMajorVersionNumber() == 5)
	{
		return IcfgNeedModemNT5(dwfOptions, lpfNeedModem);
	}
	else
	{
		return IcfgNeedModemNT4(dwfOptions, lpfNeedModem);
	}
}



//+----------------------------------------------------------------------------
//
//	Function:	IcfgInstallModem
//
//	Synopsis:
//				This function is called when ICW verified that RAS is installed,
//				but no modems are avilable. It needs to make sure a modem is availble.
//				There are two possible scenarios:
//
//				a.  There are no modems installed.  This happens when someone deleted
//					a modem after installing RAS. In this case we need to run the modem
//				    install wizard, and configure the newly installed modem to be a RAS
//				    dialout device.
//
//				b.  There are modems installed, but non of them is configured as a dial out
//				    device.  In this case, we silently convert them to be DialInOut devices,
//				    so ICW can use them.
//
//	Arguments:	hwndParent - handle to parent window
//				dwfOptions - not used
//
//	Returns:	lpfNeedsStart - not used
//
//	History:	6/5/97	ChrisK	Inherited
//
//-----------------------------------------------------------------------------
HRESULT WINAPI
IcfgInstallModem (HWND hwndParent, DWORD dwfOptions, LPBOOL lpfNeedsStart) 
{
	if (GetOSMajorVersionNumber() == 5)
	{
		return IcfgInstallModemNT5(hwndParent, dwfOptions, lpfNeedsStart);
	}
	else
	{
		return IcfgInstallModemNT4(hwndParent, dwfOptions, lpfNeedsStart);
	}
}



//+----------------------------------------------------------------------------
//
//	Function:	IcfgNeedInetComponets
//
//	Synopsis:	Check to see if the components marked in the options are
//				installed on the system
//
//	Arguements:	dwfOptions - set of bit flag indicating which components to
//				check for
//
//	Returns;	HRESULT - S_OK if successfull
//				lpfNeedComponents - TRUE is some components are not installed
//
//	History:	6/5/97	ChrisK	Inherited
//
//-----------------------------------------------------------------------------
HRESULT WINAPI
IcfgNeedInetComponents(DWORD dwfOptions, LPBOOL lpfNeedComponents) 
{
	if (GetOSMajorVersionNumber() == 5)
	{
		return IcfgNeedInetComponentsNT5(dwfOptions, lpfNeedComponents);
	}
	else
	{
		return IcfgNeedInetComponentsNT4(dwfOptions, lpfNeedComponents);
	}
}




//+----------------------------------------------------------------------------
//
//	Function:	IcfgInstallInetComponents
//
//	Synopsis:	Install the components as specified by the dwfOptions values
//
//	Arguments	hwndParent - handle to parent window
//				dwfOptions - set of bit flags indicating which components to
//					install
//
//	Returns:	HRESULT - S_OK if success
//				lpfNeedsReboot - TRUE if reboot is required
//
//	History:	6/5/97	ChrisK	Inherited
//
//-----------------------------------------------------------------------------
HRESULT WINAPI
IcfgInstallInetComponents(HWND hwndParent, DWORD dwfOptions, LPBOOL lpfNeedsRestart)
{
	if (GetOSMajorVersionNumber() == 5)
	{
		return IcfgInstallInetComponentsNT5(hwndParent, dwfOptions, lpfNeedsRestart);
	}
	else
	{
		return IcfgInstallInetComponentsNT4(hwndParent, dwfOptions, lpfNeedsRestart);
	}
}



//+----------------------------------------------------------------------------
//
//	Function:	IcfgGetLastInstallErrorText
//
//	Synopsis:	Format error message for most recent error
//
//	Arguments:	none
//
//	Returns:	DWORD - win32 error code
//				lpszErrorDesc - string containing error message
//				cbErrorDesc - size of lpszErrorDesc
//
//	History:	6/5/97	ChrisK	Inherited
//
//-----------------------------------------------------------------------------
DWORD WINAPI
IcfgGetLastInstallErrorText(LPSTR lpszErrorDesc, DWORD cbErrorDesc)
{
	Dprintf("ICFGNT: IcfgGetLastInstallErrorText\n");
    return(FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM,
							  NULL,
							  g_dwLastError,
							  MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), //The user default language
							  lpszErrorDesc,
							  cbErrorDesc,
							  NULL));
}




//+----------------------------------------------------------------------------
//
//	Function:	DoStartService
//
//	Synopsis:	Start a particular service
//
//	Arguments:	hManager - handle to open service manager
//				szServiceName - name of service to start
//
//	Returns:	DWORD - win32 error code
//
//	History:	6/5/97	ChrisK	Inherited
//				7/28/97	ChrisK	Added query section
//-----------------------------------------------------------------------------
DWORD
DoStartService(SC_HANDLE hManager, LPTSTR szServiceName)
{
    SC_HANDLE hService = NULL;
	DWORD dwRC = ERROR_SUCCESS;

	//
	// Validate parameters
	//
	Assert(hManager && szServiceName);

	Dprintf("ICFGNT: DoStartService\n");
    hService = OpenService(hManager, szServiceName, SERVICE_START);
    if(hService != NULL)
	{
		if(!StartService(hService, 0, NULL)) 
		{
			dwRC = GetLastError();
			if(dwRC == ERROR_SERVICE_ALREADY_RUNNING) 
			{
				//
				// If the service is already running, great, we're done.
				//
				dwRC = ERROR_SUCCESS;
				goto DoStartServiceExit;
			}
		}

		CloseServiceHandle(hService);
		hService = NULL;
	}

	//
	// Try to simply see if the service is running
	//
	Dprintf("ICFGNT: Failed to start service, try just querying it.\n");
    hService = OpenService(hManager, szServiceName, SERVICE_QUERY_STATUS);
    if(hService != NULL)
	{
		SERVICE_STATUS sstatus;
		ZeroMemory(&sstatus,sizeof(sstatus));

		if(QueryServiceStatus(hService,&sstatus))
		{
			if ((SERVICE_RUNNING == sstatus.dwCurrentState)	|| 
				(SERVICE_START_PENDING == sstatus.dwCurrentState))
			{
				//
				// The service is running
				//
				dwRC = ERROR_SUCCESS;
				goto DoStartServiceExit;
			}
			else
			{
				//
				// The service not running and we can't access it.
				//
				Dprintf("ICFGNT: Queried service is not running.\n");
				dwRC = ERROR_ACCESS_DENIED;
				goto DoStartServiceExit;
			}
		}
		else
		{
			//
			// Can not query service
			//
			Dprintf("ICFGNT: QueryServiceStatus failed.\n");
			dwRC = GetLastError();
			goto DoStartServiceExit;
		}
	}
	else
	{
		//
		// Can't open the service
		//
		Dprintf("ICFGNT: Cannot OpenService.\n");
		dwRC = GetLastError();
		goto DoStartServiceExit;
	}

DoStartServiceExit:
	if (hService)
	{
		CloseServiceHandle(hService);
	}

    return(dwRC);
}



//+----------------------------------------------------------------------------
//
//	Function:	ValidateProductSuite
//
//	Synopsis:	Check registry for a particular Product Suite string
//
//	Arguments:	SuiteName - name of product suite to look for
//
//	Returns:	TRUE - the suite exists
//
//	History:	6/5/97	ChrisK	Inherited
//
//-----------------------------------------------------------------------------
BOOL 
ValidateProductSuite(LPSTR SuiteName)
{
    BOOL rVal = FALSE;
    LONG Rslt;
    HKEY hKey = NULL;
    DWORD Type = 0;
    DWORD Size = 0;
    LPSTR ProductSuite = NULL;
    LPSTR p;

	Dprintf("ICFGNT: ValidateProductSuite\n");
	//
	// Determine the size required to read registry values
	//
    Rslt = RegOpenKey(
        HKEY_LOCAL_MACHINE,
        "System\\CurrentControlSet\\Control\\ProductOptions",
        &hKey
        );
    if (Rslt != ERROR_SUCCESS)
	{
        goto exit;
    }

    Rslt = RegQueryValueEx(
        hKey,
        "ProductSuite",
        NULL,
        &Type,
        NULL,
        &Size
        );
    if (Rslt != ERROR_SUCCESS) 
	{
        goto exit;
    }

    if (!Size) 
	{
        goto exit;
    }

    ProductSuite = (LPSTR) GlobalAlloc( GPTR, Size );
    if (!ProductSuite) 
	{
        goto exit;
    }

	//
	// Read ProductSuite information
	//
    Rslt = RegQueryValueEx(
        hKey,
        "ProductSuite",
        NULL,
        &Type,
        (LPBYTE) ProductSuite,
        &Size
        );
    if (Rslt != ERROR_SUCCESS) 
	{
        goto exit;
    }

    if (Type != REG_MULTI_SZ) 
	{
        goto exit;
    }

	//
	// Look for a particular string in the data returned
	// Note: data is terminiated with two NULLs
	//
    p = ProductSuite;
    while (*p) {
        if (strstr( p, SuiteName )) 
		{
            rVal = TRUE;
            break;
        }
        p += (lstrlen( p ) + 1);
    }

exit:
    if (ProductSuite) 
	{
        GlobalFree( ProductSuite );
    }

    if (hKey) 
	{
        RegCloseKey( hKey );
    }

    return rVal;
}


//+----------------------------------------------------------------------------
//
//	Function:	IcfgStartServices
//
//	Synopsis:	Start all services required by system
//
//	Arguments:	none
//
//	Returns:	HRESULT - S_OK if success
//
//	History:	6/5/97	ChrisK	Iherited
//
//-----------------------------------------------------------------------------
HRESULT WINAPI
IcfgStartServices()
{
    //
    // returns ERROR_SERVICE_DISABLED if the service is disabled
    //

    SC_HANDLE hManager;

    Dprintf("ICFGNT: IcfgStartServices\n");
    hManager = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
    if(hManager == NULL)
    {
        return(GetLastError());
    }

    DWORD dwErr;


/* 
    //
    // Don't start RASAUTO anymore, it isn't necessary for RAS to be running.
    //
    if (!ValidateProductSuite( "Small Business" )) 
	{
		dwErr = DoStartService(hManager, TEXT("RASAUTO"));

        //
        // Ignore the return value, CM should proceed even if RASAUTO failed to launch
        //
	}
*/
    dwErr = DoStartService(hManager, TEXT("RASMAN"));
    CloseServiceHandle(hManager);
    return(dwErr);
}



//+----------------------------------------------------------------------------
//
//	Function:	IcfgIsGlobalDNS
//
//	Note: these functions are not needed on an NT system and it therefore not 
//	implemented
//
//-----------------------------------------------------------------------------
HRESULT WINAPI
IcfgIsGlobalDNS(LPBOOL lpfGlobalDNS) 
{
    *lpfGlobalDNS = FALSE;
    return(ERROR_SUCCESS);
}



HRESULT WINAPI
IcfgRemoveGlobalDNS() 
{
    return(ERROR_SUCCESS);
}


HRESULT WINAPI
InetGetSupportedPlatform(LPDWORD pdwPlatform) 
{
    *pdwPlatform = VER_PLATFORM_WIN32_NT;
    return(ERROR_SUCCESS);
}


HRESULT WINAPI
InetSetAutodial(BOOL fEnable, LPCSTR lpszEntryName) 
{
    return(ERROR_INVALID_FUNCTION);
}


HRESULT WINAPI
InetGetAutodial(LPBOOL lpfEnable, LPSTR lpszEntryName,  DWORD cbEntryName) 
{
    return(ERROR_INVALID_FUNCTION);
}


HRESULT WINAPI
InetSetAutodialAddress(DWORD dwDialingLocation, LPSTR szEntry) 
{
    return(ERROR_SUCCESS);
}


#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

void __cdecl main() {};

#ifdef __cplusplus
}
#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\ccfgnt\tapi.cpp ===
/****************************************************************************
 *
 *	tapi.cpp
 *
 *	Microsoft Confidential
 *	Copyright (c) 1998 Microsoft Corporation
 *	All rights reserved
 *
 *	Implementation of ICW's interaction with TAPI on NT
 *
 *	09/02/99    quintinb    Created Header
 *
 ***************************************************************************/
#include <windows.h>
#include <wtypes.h>
#include <cfgapi.h>
#include <stdio.h>
#include <stdlib.h>
#include <setupapi.h>
#include <basetyps.h>
#include <devguid.h>
#include <tapi.h>


//
// The code below is stolen from private/net/ras/src/ui/setup/src/tapiconf.cxx
//

#define REGISTRY_INSTALLED_TAPI  SZ("HARDWARE\\DEVICEMAP\\TAPI DEVICES\\")
#define REGISTRY_ALTERNATE_TAPI  SZ("SOFTWARE\\MICROSOFT\\TAPI DEVICES\\")

// note that this definition DOES NOT have trailing \\, because DeleteTree
// doesn't like it.
#define REGISTRY_CONFIGURED_TAPI SZ("SOFTWARE\\MICROSOFT\\RAS\\TAPI DEVICES")

#define TAPI_MEDIA_TYPE          SZ("Media Type")
#define TAPI_PORT_ADDRESS        SZ("Address")
#define TAPI_PORT_NAME           SZ("Friendly Name")
#define TAPI_PORT_USAGE          SZ("Usage")

#define LOW_MAJOR_VERSION   0x0001
#define LOW_MINOR_VERSION   0x0003
#define HIGH_MAJOR_VERSION  0x0002
#define HIGH_MINOR_VERSION  0x0000

#define LOW_VERSION  ((LOW_MAJOR_VERSION  << 16) | LOW_MINOR_VERSION)
#define HIGH_VERSION ((HIGH_MAJOR_VERSION << 16) | HIGH_MINOR_VERSION)

#define MAX_DEVICE_TYPES 64

VOID RasTapiCallback (HANDLE, DWORD, DWORD, DWORD, DWORD, DWORD);
DWORD EnumerateTapiModemPorts(DWORD dwBytes, LPSTR szPortsBuf, 
								BOOL bWithDelay = FALSE);



DWORD
EnumerateTapiModemPorts(DWORD dwBytes, LPSTR szPortsBuf, BOOL bWithDelay) {
    LINEINITIALIZEEXPARAMS params;
    LINEADDRESSCAPS        *lineaddrcaps ;
    LINEDEVCAPS            *linedevcaps ;
    LINEEXTENSIONID        extensionid ;
    HLINEAPP               RasLine ;
    HINSTANCE              RasInstance = GetModuleHandle(TEXT("ICFGNT.DLL"));
    DWORD                  NegotiatedApiVersion ;
    DWORD                  NegotiatedExtVersion = 0;
    WORD                   i, k ;
    DWORD                  lines = 0 ;
    BYTE                   buffer[1000] ;
    DWORD                  totaladdress = 0;
    CHAR                   *address ;
    CHAR                   szregkey[512];
    LONG                   lerr;
    DWORD                  dwApiVersion = HIGH_VERSION;
    LPSTR                  szPorts = szPortsBuf;

    *szPorts = '\0';
    dwBytes--;

    ZeroMemory(&params, sizeof(params));

    params.dwTotalSize = sizeof(params);
    params.dwOptions   = LINEINITIALIZEEXOPTION_USEEVENT;

    /* the sleep is necessary here because if this routine is called just after a modem
    ** has been added from modem.cpl & unimdm.tsp is running,
    ** then a new modem added doesn't show up in the tapi enumeration.
    */

    //
	// We should not always sleep here - should sleep only if ModemWizard was
	// launched recently  -- VetriV
	//
	if (bWithDelay)
		Sleep(1000L);

    if (lerr = lineInitializeExW (&RasLine,
                                 RasInstance,
                                 (LINECALLBACK) RasTapiCallback,
                                 NULL,
                                 &lines,
                                 &dwApiVersion,
                                 &params))
    {
         return lerr;
    }

    // Go through all lines to see if we can find a modem
    for (i=0; i<lines; i++)
    {  // for all lines we are interested in get the addresses -> ports

       if (lineNegotiateAPIVersion(RasLine, i, LOW_VERSION, HIGH_VERSION, &NegotiatedApiVersion, &extensionid))
       {
           continue ;
       }

       memset (buffer, 0, sizeof(buffer)) ;

       linedevcaps = (LINEDEVCAPS *)buffer ;
       linedevcaps->dwTotalSize = sizeof (buffer) ;

       // Get a count of all addresses across all lines
       //
       if (lineGetDevCapsW (RasLine, i, NegotiatedApiVersion, NegotiatedExtVersion, linedevcaps))
       {
           continue ;
       }

       // is this a modem?
       if ( linedevcaps->dwMediaModes & LINEMEDIAMODE_DATAMODEM )  {
            // first convert all nulls in the device class string to non nulls.
            //
            DWORD  j ;
            WCHAR *temp ;

            for (j=0, temp = (WCHAR*)((BYTE *)linedevcaps+linedevcaps->dwDeviceClassesOffset); j<linedevcaps->dwDeviceClassesSize; j++, temp++)
            {
              if (*temp == L'\0')
                 *temp = L' ' ;
            }

            //
            // select only those devices that have comm/datamodem as a device class
            //

            LPWSTR wszClassString = wcsstr((WCHAR*)((CHAR *)linedevcaps+linedevcaps->dwDeviceClassesOffset), L"comm/datamodem");
            if(wszClassString == NULL)
                continue;
        }

        LONG lRet;
        HLINE lhLine = 0;

        lRet = lineOpen(RasLine, i, &lhLine, dwApiVersion, 0, 0, LINECALLPRIVILEGE_NONE, 0, NULL);
        if(lRet != 0)
            continue;

        LPVARSTRING lpVarString;
        char buf[1000];
        lpVarString = (LPVARSTRING) buf;
        lpVarString->dwTotalSize = 1000;

        lRet = lineGetID(lhLine, 0, 0, LINECALLSELECT_LINE,
                (LPVARSTRING) lpVarString, TEXT("comm/datamodem/portname"));

        if(lRet != 0)
            continue;

        LPSTR szPortName;

        if (lpVarString->dwStringSize)
            szPortName = (LPSTR) ((LPBYTE) lpVarString + ((LPVARSTRING) lpVarString) -> dwStringOffset);
        //
        // Append port name to port list
        //

        UINT len = strlen(szPortName) + 1;
        if(dwBytes < len)
            return(ERROR_SUCCESS);

        strcpy(szPorts, szPortName);
        szPorts += len;
        *szPorts = '\0';

        if (lhLine) lineClose(lhLine);
    }

    lineShutdown(RasLine);
    return ERROR_SUCCESS ;
}

VOID FAR PASCAL
RasTapiCallback (HANDLE context, DWORD msg, DWORD instance, DWORD param1, DWORD param2, DWORD param3)
{
   // dummy callback routine because the full blown TAPI now demands that
   // lineinitialize provide this routine.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\ccfgnt\icfgnt5.cpp ===
/****************************************************************************
 *
 *  icfg32.cpp
 *
 *  Microsoft Confidential
 *  Copyright (c) 1992-1999 Microsoft Corporation
 *  All rights reserved
 *
 *  This module provides the implementation of the methods for
 *  the NT specific functionality of inetcfg
 *
 *  6/5/97  ChrisK  Inherited from AmnonH
 *  7/3/97  ShaunCo Modfied for NT5
 *
 ***************************************************************************/
#define UNICODE
#define _UNICODE

#include <wtypes.h>
#include <cfgapi.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>
#include <setupapi.h>
#include <basetyps.h>
#include <devguid.h>
#include <lmsname.h>
#include "debug.h"

#include <netcfgx.h>

const LPTSTR gc_szIsdnSigature = TEXT("\\NET\\");

#define REG_DATA_EXTRA_SPACE 255
#define DEVICE_INSTANCE_SIZE 128

extern DWORD g_dwLastError;


typedef BOOL (WINAPI *PFNINSTALLNEWDEVICE) (HWND hwndParent,
                                                LPGUID ClassGuid,
                                                PDWORD pReboot);
/*++

Routine Description:

   Exported Entry point from newdev.cpl. Installs a new device. A new Devnode is
   created and the user is prompted to select the device. If the class guid
   is not specified then then the user begins at class selection.

Arguments:

   hwndParent - Window handle of the top-level window to use for any UI related
                to installing the device.

   LPGUID ClassGuid - Optional class of the new device to install.
                      If ClassGuid is NULL we start at detection choice page.
                      If ClassGuid == GUID_NULL or GUID_DEVCLASS_UNKNOWN
                         we start at class selection page.

   pReboot - Optional address of variable to receive reboot flags (DI_NEEDRESTART,DI_NEEDREBOOT)


Return Value:

   BOOL TRUE for success (does not mean device was installed or updated),
        FALSE unexpected error. GetLastError returns the winerror code.
*/


// For the code that was copied from netcfg, make the TraceError stuff
// go away.  Likewise for existing debug statements.
//
#define TraceError
#define Dprintf

ULONG
ReleaseObj (
        IUnknown* punk)
{
    return (punk) ? punk->Release () : 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrCreateAndInitializeINetCfg
//
//  Purpose:    Cocreate and initialize the root INetCfg object.  This will
//              optionally initialize COM for the caller too.
//
//  Arguments:
//      pfInitCom       [in,out]   TRUE to call CoInitialize before creating.
//                                 returns TRUE if COM was successfully
//                                 initialized FALSE if not.  If NULL, means
//                                 don't initialize COM.
//      ppnc            [out]  The returned INetCfg object.
//      fGetWriteLock   [in]   TRUE if a writable INetCfg is needed
//      cmsTimeout      [in]   See INetCfg::AcquireWriteLock
//      szwClientDesc   [in]   See INetCfg::AcquireWriteLock
//      pbstrClientDesc [in]   See INetCfg::AcquireWriteLock
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   7 May 1997
//
//  Notes:
//
HRESULT
HrCreateAndInitializeINetCfg (
    BOOL*       pfInitCom,
    INetCfg**   ppnc,
    BOOL        fGetWriteLock,
    DWORD       cmsTimeout,
    LPCWSTR     szwClientDesc,
    BSTR*       pbstrClientDesc)
{
    Assert (ppnc);

    // Initialize the output parameter.
    *ppnc = NULL;

    // Initialize COM if the caller requested.
    HRESULT hr = S_OK;
    if (pfInitCom && *pfInitCom)
    {
        hr = CoInitializeEx( NULL,
                COINIT_DISABLE_OLE1DDE | COINIT_MULTITHREADED );
        if (RPC_E_CHANGED_MODE == hr)
        {
            hr = S_OK;
            if (pfInitCom)
            {
                *pfInitCom = FALSE;
            }
        }
    }
    if (SUCCEEDED(hr))
    {
        // Create the object implementing INetCfg.
        //
        INetCfg* pnc;
        hr = CoCreateInstance(CLSID_CNetCfg, NULL, CLSCTX_INPROC_SERVER,
                              IID_INetCfg, reinterpret_cast<void**>(&pnc));
        if (SUCCEEDED(hr))
        {
            INetCfgLock * pnclock = NULL;
            if (fGetWriteLock)
            {
                // Get the locking interface
                hr = pnc->QueryInterface(IID_INetCfgLock,
                                         reinterpret_cast<LPVOID *>(&pnclock));
                if (SUCCEEDED(hr))
                {
                    // Attempt to lock the INetCfg for read/write
                    hr = pnclock->AcquireWriteLock(cmsTimeout, szwClientDesc,
                                               pbstrClientDesc);
                    if (S_FALSE == hr)
                    {
                        // Couldn't acquire the lock
                        hr = NETCFG_E_NO_WRITE_LOCK;
                    }
                }
            }

            if (SUCCEEDED(hr))
            {
                // Initialize the INetCfg object.
                //
                hr = pnc->Initialize (NULL);
                if (SUCCEEDED(hr))
                {
                    *ppnc = pnc;
                    pnc->AddRef ();
                }
                else
                {
                    if (pnclock)
                    {
                        pnclock->ReleaseWriteLock();
                    }
                }
                // Transfer reference to caller.
            }
            ReleaseObj(pnclock);

            ReleaseObj(pnc);
        }

        // If we failed anything above, and we've initialized COM,
        // be sure an uninitialize it.
        //
        if (FAILED(hr) && pfInitCom && *pfInitCom)
        {
            CoUninitialize ();
        }
    }
    TraceError("HrCreateAndInitializeINetCfg", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrUninitializeAndUnlockINetCfg
//
//  Purpose:    Uninitializes and unlocks the INetCfg object
//
//  Arguments:
//      pnc [in]    INetCfg to uninitialize and unlock
//
//  Returns:    S_OK if success, OLE or Win32 error otherwise
//
//  Author:     danielwe   13 Nov 1997
//
//  Notes:
//
HRESULT
HrUninitializeAndUnlockINetCfg (
    INetCfg*    pnc)
{
    HRESULT     hr = S_OK;

    hr = pnc->Uninitialize();
    if (SUCCEEDED(hr))
    {
        INetCfgLock *   pnclock;

        // Get the locking interface
        hr = pnc->QueryInterface(IID_INetCfgLock,
                                 reinterpret_cast<LPVOID *>(&pnclock));
        if (SUCCEEDED(hr))
        {
            // Attempt to lock the INetCfg for read/write
            hr = pnclock->ReleaseWriteLock();

            ReleaseObj(pnclock);
        }
    }

    TraceError("HrUninitializeAndUnlockINetCfg", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrUninitializeAndReleaseINetCfg
//
//  Purpose:    Unintialize and release an INetCfg object.  This will
//              optionally uninitialize COM for the caller too.
//
//  Arguments:
//      fUninitCom [in] TRUE to uninitialize COM after the INetCfg is
//                      uninitialized and released.
//      pnc        [in] The INetCfg object.
//      fHasLock   [in] TRUE if the INetCfg was locked for write and
//                          must be unlocked.
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   7 May 1997
//
//  Notes:      The return value is the value returned from
//              INetCfg::Uninitialize.  Even if this fails, the INetCfg
//              is still released.  Therefore, the return value is for
//              informational purposes only.  You can't touch the INetCfg
//              object after this call returns.
//
HRESULT
HrUninitializeAndReleaseINetCfg (
    BOOL        fUninitCom,
    INetCfg*    pnc,
    BOOL        fHasLock)
{
    Assert (pnc);
    HRESULT hr = S_OK;

    if (fHasLock)
    {
        hr = HrUninitializeAndUnlockINetCfg(pnc);
    }
    else
    {
        hr = pnc->Uninitialize ();
    }

    ReleaseObj (pnc);

    if (fUninitCom)
    {
        CoUninitialize ();
    }
    TraceError("HrUninitializeAndReleaseINetCfg", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrInstallComponent
//
//  Purpose:    Install the component with a specified id.
//
//  Arguments:
//      pnc             [in] INetCfg pointer.
//      pguidClass      [in] Class guid of the component to install.
//      pszwComponentId [in] Component id to install.
//      ppncc           [out] (Optional) Returned component that was
//                            installed.
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco     4 Jan 1998
//
//  Notes:      nickball    7 May 1999 - Removed unused pszwOboToken parameter  
//
HRESULT
HrInstallComponent (
    INetCfg*                        pnc,
    const GUID*                     pguidClass,
    LPCWSTR                         pszwComponentId,
    INetCfgComponent**              ppncc)
{
    OBO_TOKEN   oboToken;

    Assert (pnc);
    Assert (pszwComponentId);

    // Initialize output parameter.
    //
    if (ppncc)
    {
        *ppncc = NULL;
    }

    // Get the class setup object.
    //
    INetCfgClassSetup* pncclasssetup;

    ZeroMemory((PVOID)&oboToken, sizeof(oboToken));
    oboToken.Type = OBO_USER;
    
    //NT #330252 
    //oboToken.pncc = *ppncc;
    //oboToken. fRegistered = TRUE;

    HRESULT hr = pnc->QueryNetCfgClass (pguidClass, IID_INetCfgClassSetup,
                    reinterpret_cast<void**>(&pncclasssetup));
    if (SUCCEEDED(hr))
    {
        hr = pncclasssetup->Install (pszwComponentId,
                &oboToken, 0, 0, NULL, NULL, ppncc);

        ReleaseObj (pncclasssetup);
    }
    TraceError("HrInstallComponent", hr);
    return hr;
}



//+----------------------------------------------------------------------------
//
//  Function:   CallModemInstallWizard
//
//  Synopsis:   Invoke modem install wizard via SetupDi interfaces
//
//  Arguments:  hwnd - handle to parent window
//
//  Returns:    TRUE - success, FALSE - failed
//
//  History:    6/5/97  ChrisK  Inherited
//
//-----------------------------------------------------------------------------
//
// The following code was stolen from RAS
//

BOOL
CallModemInstallWizardNT5(HWND hwnd)
{
   BOOL     fReturn = FALSE;
   PFNINSTALLNEWDEVICE pfn;
   HINSTANCE hInst;

   Dprintf("ICFGNT: CallModemInstallWizard\n");

   //
   // Load newdev.dll can call the InstallNewDevice method with Modem device class
   //
   hInst = LoadLibrary((LPCTSTR) L"newdev.dll");
   if (NULL == hInst)
   {
       goto CleanupAndExit;
   }

   pfn = (PFNINSTALLNEWDEVICE) GetProcAddress(hInst, (LPCSTR)"InstallNewDevice");
   if (NULL == pfn)
   {
       goto CleanupAndExit;
   }

   //
   // Call the function - on NT5 modem installation should not require
   // reboot; so that last parameter, which is used to return if restart/reboot
   // is required can be NULL
   //
   fReturn = pfn(hwnd, (LPGUID) &GUID_DEVCLASS_MODEM, NULL);


CleanupAndExit:

   if (NULL != hInst)
   {
       FreeLibrary(hInst);
   }
   return fReturn;
}



//+----------------------------------------------------------------------------
//
//  Function:   IcfgNeedModem
//
//  Synopsis:   Check system configuration to determine if there is at least
//              one physical modem installed
//
//  Arguments:  dwfOptions - currently not used
//
//  Returns:    HRESULT - S_OK if successfull
//              lpfNeedModem - TRUE if no modems are available
//
//  History:    6/5/97  ChrisK  Inherited
//
//-----------------------------------------------------------------------------
HRESULT WINAPI
IcfgNeedModemNT5(DWORD dwfOptions, LPBOOL lpfNeedModem)
{
    //
    // Ras is installed, and ICW wants to know if it needs to
    // install a modem.
    //
    *lpfNeedModem = TRUE;

    // Get the device info set for modems.
    //
    HDEVINFO hdevinfo = SetupDiGetClassDevs((GUID*)&GUID_DEVCLASS_MODEM,
                                            NULL,
                                            NULL,
                                            DIGCF_PRESENT);
    if (hdevinfo)
    {
        SP_DEVINFO_DATA diData;
        diData.cbSize = sizeof(diData);

        // Look for at least one modem.
        //
        if (SetupDiEnumDeviceInfo(hdevinfo, 0, &diData))
        {
            *lpfNeedModem = FALSE;
        }

        SetupDiDestroyDeviceInfoList (hdevinfo);
    }

    if (*lpfNeedModem)
    {
        //
        // check for ISDN adaptors
        //
        // Get the device info set for modems.
        //
        hdevinfo = SetupDiGetClassDevs((GUID*)&GUID_DEVCLASS_NET,
                                       NULL,
                                       NULL,
                                       DIGCF_PRESENT);
        if (hdevinfo)
        {
            TCHAR   szDevInstanceId[DEVICE_INSTANCE_SIZE];
            DWORD   dwIndex = 0;
            DWORD   dwRequiredSize;
            SP_DEVINFO_DATA diData;
            diData.cbSize = sizeof(diData);

            //
            // look for an ISDN device
            //
            while (SetupDiEnumDeviceInfo(hdevinfo, dwIndex, &diData))
            {
                if (SetupDiGetDeviceInstanceId(hdevinfo,
                                               &diData,
                                               szDevInstanceId,
                                               sizeof(szDevInstanceId) / sizeof(szDevInstanceId[0]),
                                               &dwRequiredSize))
                {
                    HKEY    hReg, hInterface;
                    TCHAR   szLowerRange[MAX_PATH + 1];
                    DWORD   cb = sizeof(szLowerRange);

                    hReg = SetupDiOpenDevRegKey(hdevinfo, &diData, DICS_FLAG_GLOBAL, 0, DIREG_DRV, KEY_READ);
                    if (hReg != INVALID_HANDLE_VALUE)
                    {
                        if (RegOpenKey(hReg, TEXT("Ndi\\Interfaces"), &hInterface) == ERROR_SUCCESS)
                        {
                            if (RegQueryValueEx(hInterface, TEXT("LowerRange"), 0, NULL, (PBYTE) szLowerRange, &cb) == ERROR_SUCCESS)
                            {
                                if (lstrcmpi(szLowerRange, TEXT("isdn")) == 0)
                                {
                                    *lpfNeedModem = FALSE;
                                    break;
                                }
                            }
                            RegCloseKey(hInterface);
                        }
                        RegCloseKey(hReg);
                    }

                    //
                    // ISDN adaptors are in the form XXX\NET\XXX
                    //
                    if (_tcsstr(szDevInstanceId, gc_szIsdnSigature))
                    {
                        *lpfNeedModem = FALSE;
                        break;
                    }
                }

                dwIndex++;
            }

            SetupDiDestroyDeviceInfoList (hdevinfo);
        }
    }

    return(ERROR_SUCCESS);
}

//+----------------------------------------------------------------------------
//
//  Function:   IcfgInstallModem
//
//  Synopsis:
//              This function is called when ICW verified that RAS is installed,
//              but no modems are avilable. It needs to make sure a modem is availble.
//              There are two possible scenarios:
//
//              a.  There are no modems installed.  This happens when someone deleted
//                  a modem after installing RAS. In this case we need to run the modem
//                  install wizard, and configure the newly installed modem to be a RAS
//                  dialout device.
//
//              b.  There are modems installed, but non of them is configured as a dial out
//                  device.  In this case, we silently convert them to be DialInOut devices,
//                  so ICW can use them.
//
//  Arguments:  hwndParent - handle to parent window
//              dwfOptions - not used
//
//  Returns:    lpfNeedsStart - not used
//
//  History:    6/5/97  ChrisK  Inherited
//
//-----------------------------------------------------------------------------
HRESULT WINAPI
IcfgInstallModemNT5(HWND hwndParent, DWORD dwfOptions, LPBOOL lpfNeedsStart)
{
    //
    // Fire up the modem install wizard
    //
    if (!CallModemInstallWizardNT5(hwndParent))
    {
        return(g_dwLastError = GetLastError());
    }

    return(ERROR_SUCCESS);
}

//+----------------------------------------------------------------------------
//
//  Function:   IcfgNeedInetComponets
//
//  Synopsis:   Check to see if the components marked in the options are
//              installed on the system
//
//  Arguements: dwfOptions - set of bit flag indicating which components to
//              check for
//
//  Returns;    HRESULT - S_OK if successfull
//              lpfNeedComponents - TRUE is some components are not installed
//
//  History:    6/5/97  ChrisK  Inherited
//
//-----------------------------------------------------------------------------
HRESULT WINAPI
IcfgNeedInetComponentsNT5(DWORD dwfOptions, LPBOOL lpfNeedComponents)
{
    Dprintf("ICFGNT: IcfgNeedInetComponents\n");

    //
    // Assume we have what we need.
    //
    *lpfNeedComponents = FALSE;

    HRESULT     hr          = S_OK;
    INetCfg*    pnc         = NULL;
    BOOL        fInitCom    = TRUE;

    // If the optiona are such that we need an INetCfg interface pointer,
    // get one.
    //
    if ((dwfOptions & ICFG_INSTALLTCP) ||
        (dwfOptions & ICFG_INSTALLRAS))
    {
        hr = HrCreateAndInitializeINetCfg (&fInitCom, &pnc,
                FALSE, 0, NULL, NULL);
    }

    // Look for TCP/IP using the INetCfg interface.
    //
    if (SUCCEEDED(hr) && (dwfOptions & ICFG_INSTALLTCP))
    {
        Assert (pnc);

        hr = pnc->FindComponent (NETCFG_TRANS_CID_MS_TCPIP, NULL);
        if (S_FALSE == hr)
        {
            *lpfNeedComponents = TRUE;
        }
    }

    // We no longer need the INetCfg interface pointer, so release it.
    //
    if (pnc)
    {
        (void) HrUninitializeAndReleaseINetCfg (fInitCom, pnc, FALSE);
    }

    // Normalize the HRESULT.
    if (SUCCEEDED(hr))
    {
        hr = S_OK;
    }

    return hr;
}



//+----------------------------------------------------------------------------
//
//  Function:   IcfgInstallInetComponentsNT5
//
//  Synopsis:   Install the components as specified by the dwfOptions values
//
//  Arguments   hwndParent - handle to parent window
//              dwfOptions - set of bit flags indicating which components to
//                  install
//
//  Returns:    HRESULT - S_OK if success
//              lpfNeedsReboot - TRUE if reboot is required
//
//  History:    6/5/97  ChrisK  Inherited
//
//-----------------------------------------------------------------------------
HRESULT WINAPI
IcfgInstallInetComponentsNT5(HWND hwndParent, DWORD dwfOptions, LPBOOL lpfNeedsRestart)
{
    Dprintf("ICFGNT: IcfgInstallInetComponents\n");

    //
    // Assume don't need restart
    //
    *lpfNeedsRestart = FALSE;

    HRESULT     hr          = S_OK;
    INetCfg*    pnc         = NULL;
    BOOL        fInitCom    = TRUE;

    // If the optiona are such that we need an INetCfg interface pointer,
    // get one.
    //
    if ((dwfOptions & ICFG_INSTALLTCP) ||
        (dwfOptions & ICFG_INSTALLRAS))
    {
        BSTR bstrClient;
        hr = HrCreateAndInitializeINetCfg (&fInitCom, &pnc, TRUE,
                0, L"", &bstrClient);
    }

    // Install TCP/IP on behalf of the user.
    //
    if (SUCCEEDED(hr) && (dwfOptions & ICFG_INSTALLTCP))
    {
        hr = HrInstallComponent (pnc, &GUID_DEVCLASS_NETTRANS,
                    NETCFG_TRANS_CID_MS_TCPIP, NULL);
    }

    // We no longer need the INetCfg interface pointer, so release it.
    //
    if (pnc)
    {
        // Apply the changes if everything was successful.
        //
        if (SUCCEEDED(hr))
        {
            hr = pnc->Apply();

            if (NETCFG_S_REBOOT == hr)
            {
                *lpfNeedsRestart = TRUE;
            }
        }
        (void) HrUninitializeAndReleaseINetCfg (fInitCom, pnc, TRUE);
    }

    // Normalize the HRESULT.
    if (SUCCEEDED(hr))
    {
        hr = S_OK;
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmcfg\cmmaster.h ===
//+----------------------------------------------------------------------------
//
// File:     cmmaster.h
//
// Module:   CMCFG32.DLL
//
// Synopsis: Master include file for precompiled headers.
//
// Copyright (c) 1998 Microsoft Corporation
//
// Author:   quintinb   Created Header      08/17/99
//
//+----------------------------------------------------------------------------

#ifndef _CMMASTER_H_
#define _CMMASTER_H_

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

//
// WIN32 specfic includes
//
#include <ras.h>
#include <raserror.h>
#include "cmras.h"

#include "cmdebug.h"
#include "cmcfg.h"
#include "cmutil.h"

#include "base_str.h"
#include "mgr_str.h"
#include "reg_str.h"
#include "inf_str.h"
#include "stp_str.h"
#include "ras_str.h"

#include "cmsetup.h"

#include "allcmdir.h"

extern HINSTANCE  g_hInst;

#endif // _CMMASTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmcfg\cmcfgex.cpp ===
//+----------------------------------------------------------------------------
//
// File:     cmcfgex.cpp
//
// Module:   CMCFG32.DLL
//
// Synopsis: Source for the CmConfigEx API.
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb       Created Header      08/17/99
//           quintinb       deprecated the CMConfigEx private interface  03/23/01
//
//+----------------------------------------------------------------------------
#include "cmmaster.h"
//+---------------------------------------------------------------------------
//
//	Function:	CMConfigEx
//
//	Synopsis:	Given the correct info in an INS file, this function extracts
//              the CMP, CMS, PBK, PBR, and INF files and invoke cmstp.exe
//              to install the profile.
//
//	Arguments:	pszInfFile      full path to the INS file
//
//	Returns:	BOOL            TRUE = success, FALSE = failure
//
//----------------------------------------------------------------------------
extern "C" BOOL WINAPI CMConfigEx(
    LPCTSTR pszInsFile
) 
{
    CMASSERTMSG(FALSE, TEXT("CMConfigEx -- The CMConfigEx Private Interface has been deprecated -- returning failure."));
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmcfg\cmcfg.cpp ===
//+----------------------------------------------------------------------------
//
// File:     cmcfg.cpp
//
// Module:   CMCFG32.DLL
//
// Synopsis: This DLL contains the call CMConfig that transfers information from
//           a connectoid created by Connection Wizard to a Connection Manager
//           profile. The phone number, username, and password are transferred.
//           If a backup phone number exists in the pszInsFile, it also transferss
//           The backup file. The name of the connectoid to translate is pszDUN.
//           The format of the .ins file includes:
//
//           [Backup Phone]
//           Phone_Number=<TAPI phone number starting with + or literal dial string>
//
//           If the number starts with a +, it is assumed to be TAPI formatted
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   a-frankh   created         05/06/97
//           nickball   cleaned-up      04/08/98
//           quintinb   deprecated the CMConfig private interface  03/23/01
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"

HINSTANCE g_hInst;

//+---------------------------------------------------------------------------
//
//	Function:	CMConfig
//
//	Synopsis:	Transfers user information to CM profile
//				
//	Arguments:	LPCSTR pszInsFile - full pathname of .ins file, pass NULL if no .ins file
//				LPCSTR pszDUN - name of connectoid/CM profile
//				THE NAME OF THE CONNECTOID AND SERVICE NAME OF THE CM PROFILE MUST MATCH!
//  
//	Notes: Operates by finding the location of the CM directory. Looks for .cmp files and
//	gets the .cms file. Looks in the .cms file for the service name and compares it.	
//
//
//	Returns:	TRUE if successful.
//
//	History:	a-frankh - Created - 5/6/97
//----------------------------------------------------------------------------

extern "C" BOOL WINAPI CMConfig(LPSTR pszInsFile, LPSTR pszDUN ) 
{
    CMASSERTMSG(FALSE, TEXT("CMConfig -- The CMConfig Private Interface has been deprecated -- returning failure."));
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

//+----------------------------------------------------------------------------
//
// Function:  DllMain
//
// Synopsis:  Main entry point into the DLL.
//
// Arguments: HINSTANCE  hinstDLL - Our HINSTANCE
//            DWORD  fdwReason - The reason we are being called.
//            LPVOID  lpvReserved - Reserved
//
// Returns:   BOOL WINAPI - TRUE - always
//
// History:   nickball    Created Header    4/8/98
//
//+----------------------------------------------------------------------------
extern "C" BOOL WINAPI DllMain(HINSTANCE  hinstDLL, DWORD  fdwReason, LPVOID  lpvReserved) 
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        g_hInst = hinstDLL;

        //
        // Disable thread attach notification
        //

        DisableThreadLibraryCalls(hinstDLL);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmcfg\makefile.inc ===
$(O)\cmcfg32.def: cmcfg32.src
    $(C_PREPROCESSOR) $** > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmcontbl\setacl.cpp ===
//+----------------------------------------------------------------------------
//
// File:    setacl.cpp
//
// Module:  PBSERVER.DLL
//
// Synopsis: Security/SID/ACL stuff for CM
//
// Copyright (c) 1998-2000 Microsoft Corporation
//
// Author:  09-Mar-2000 SumitC  Created
//
//+----------------------------------------------------------------------------

#include <windows.h>
#include "cmdebug.h"
#include "cmutil.h"

//+----------------------------------------------------------------------------
//
// Func:    SetAclPerms
//
// Desc:    Sets appropriate permissions for CM/CPS's shared objects
//
// Args:    [ppAcl] - location to return an allocated ACL
//
// Return:  BOOL, TRUE for success, FALSE for failure
//
// Notes:   fix for 30991: Security issue, don't use NULL DACLs.
//
// History: 09-Mar-2000   SumitC    Created
//          04-Apr-2000   SumitC    Give perms to Authenticated_Users as well
//
//-----------------------------------------------------------------------------
BOOL
SetAclPerms(PACL * ppAcl)
{
    DWORD                       dwError = 0;
    SID_IDENTIFIER_AUTHORITY    siaWorld = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY    siaNtAuth = SECURITY_NT_AUTHORITY;
    PSID                        psidWorldSid = NULL;
    PSID                        psidAdminSid = NULL;
    PSID                        psidUserSid = NULL;
    int                         cbAcl;
    PACL                        pAcl = NULL;

    MYDBGASSERT(OS_NT);

    // Create a SID for all users
    if ( !AllocateAndInitializeSid(  
            &siaWorld,
            1,
            SECURITY_WORLD_RID,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            &psidWorldSid))
    {
        dwError = GetLastError();
        goto Cleanup;
    }

    // Create a SID for Authenticated Users
    if ( !AllocateAndInitializeSid(  
            &siaNtAuth,
            1,
            SECURITY_AUTHENTICATED_USER_RID,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            &psidUserSid))
    {
        dwError = GetLastError();
        goto Cleanup;
    }

    // Create a SID for Local System account
    if ( !AllocateAndInitializeSid(  
            &siaNtAuth,
            2,
            SECURITY_BUILTIN_DOMAIN_RID,
            DOMAIN_ALIAS_RID_ADMINS,
            0,
            0,
            0,
            0,
            0,
            0,
            &psidAdminSid))
    {
        dwError = GetLastError();
        goto Cleanup;
    }

    // Calculate the length of required ACL buffer
    // with 3 ACEs.
    cbAcl =     sizeof(ACL)
            +   3 * sizeof(ACCESS_ALLOWED_ACE)
            +   GetLengthSid(psidWorldSid)
            +   GetLengthSid(psidAdminSid)
            +   GetLengthSid(psidUserSid);

    pAcl = (PACL) LocalAlloc(0, cbAcl);
    if (NULL == pAcl)
    {
        dwError = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    if ( ! InitializeAcl(pAcl, cbAcl, ACL_REVISION2))
    {
        dwError = GetLastError();
        goto Cleanup;
    }

    // Add ACE with EVENT_ALL_ACCESS for all users
    if ( ! AddAccessAllowedAce(pAcl,
                               ACL_REVISION2,
                               GENERIC_READ | GENERIC_EXECUTE,
                               psidWorldSid))
    {
        dwError = GetLastError();
        goto Cleanup;
    }

    // Add ACE with EVENT_ALL_ACCESS for Authenticated Users
    if ( ! AddAccessAllowedAce(pAcl,
                               ACL_REVISION2,
                               GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE,
                               psidUserSid))
    {
        dwError = GetLastError();
        goto Cleanup;
    }

    // Add ACE with EVENT_ALL_ACCESS for Admins
    if ( ! AddAccessAllowedAce(pAcl,
                               ACL_REVISION2,
                               GENERIC_ALL,
                               psidAdminSid))
    {
        dwError = GetLastError();
        goto Cleanup;
    }

Cleanup:

    if (dwError)
    {
        if (pAcl)
        {
           LocalFree(pAcl);
        }
    }
    else
    {
        *ppAcl = pAcl;
    }

    if (psidWorldSid)
    {
        FreeSid(psidWorldSid);
    }

    if (psidUserSid)
    {
        FreeSid(psidUserSid);
    }

    if (psidAdminSid)
    {
        FreeSid(psidAdminSid);
    }
        
    return dwError ? FALSE : TRUE;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmcfg\cmstpex.cpp ===
//+----------------------------------------------------------------------------
//
// File:     cmstpex.cpp
//
// Module:   CMCFG
//
// Synopsis: This file is the implementation of the CMSTP Extension Proc that
//           resides in cmcfg32.dll.  This proc is used to modify the install
//           behavior of cmstp.exe based profile installs.
//
// Copyright (c) 1996-1999 Microsoft Corporation
//
// Author:   quintinb      Created    5-1-99
//
// History: 
//+----------------------------------------------------------------------------

#include "cmmaster.h"

//
//  For ProfileNeedsMigration
//
#include "needsmig.cpp"

//
//  For GetPhoneBookPath
//
#include "getpbk.cpp"

//
//  For GetAllUsersCmDir
//
#include <shlobj.h>
#include "allcmdir.cpp"

//
//  Duplicated from processcmdln.h
//
#include "cmstpex.h"
#include "ver_str.h"
#include <shellapi.h>

//+----------------------------------------------------------------------------
//
// Function:  RenameOldCmBits
//
// Synopsis:  This function renames all of the old CM bits so that they will not
//            be loaded by the system during the launch of CM after the install.
//            This was to prevent problems with missing entry points (either things
//            we had removed or added to dlls like cmutil or cmpbk32).  The problem
//            is that cmdial32.dll is loaded explicitly from system32 by RAS (which 
//            has a fully qualified path).  However, any other dlls first check the
//            load directory of the exe file . . . which was cmstp.exe in the temp
//            dir.  Thus we were getting the newest cmdial32 but older versions of
//            cmutil, cmpbk, etc.  Thus to fix it we now rename the CM bits to .old
//            (cmmgr32.exe becomes cmmgr32.exe.old for instance).  This forces the
//            loader to pick the next best place to look for dlls, the system dir.
//
// Arguments: LPCTSTR szTempDir -- the temp dir path where the CM bits are
//
// Returns:   BOOL - TRUE if Successful
//
// History:   quintinb Created     6/2/99
//
//+----------------------------------------------------------------------------
BOOL RenameOldCmBits (LPCTSTR szTempDir)
{
    //
    //  Note that we don't rename cmstp.exe because it is doing the install.  We have no need to
    //  rename it because it is already executing and we are just trying to prevent old bits
    //  from being loaded and executed.
    //

    //
    //  Note that cmcfg32.dll will load the old cmutil.dll while the extension proc is running.
    //  Please be careful when you are adding cmutil entry points to cmcfg32.dll.
    //
  
    BOOL bReturn = TRUE;

    if (szTempDir)
    {

        //
        //  Sanity Check -- make sure we are not renaming the bits in system32
        //
        TCHAR szTemp[MAX_PATH+1];
        if (GetSystemDirectory(szTemp, MAX_PATH))
        {
            if (0 == lstrcmpi(szTemp, szTempDir))
            {
                return FALSE;
            }
        }

        TCHAR szSrc[MAX_PATH + 1];
        TCHAR szDest[MAX_PATH + 1];

        LPCTSTR ArrayOfCmFiles[] = 
        {
             TEXT("cmmgr32.exe"),
             TEXT("cmpbk32.dll"),
             TEXT("cmdial32.dll"),
             TEXT("cmdl32.exe"),
             TEXT("cnetcfg.dll"),
             TEXT("cmmon32.exe"),
             TEXT("cmutil.dll"),
             TEXT("instcm.inf"),
             TEXT("cmcfg32.dll"),
             TEXT("cnet16.dll"),
             TEXT("ccfg95.dll"),
             TEXT("cmutoa.dll"), // this probably won't ever exist in an older profile but delete anyway for interim build reasons
             TEXT("ccfgnt.dll")
        };
        const DWORD c_dwNumFiles = (sizeof(ArrayOfCmFiles)/sizeof(LPCTSTR));

        DWORD dwGreatestNumberOfChars = lstrlen(szTempDir) + 17; // 8.3 plus one for the NULL and one to count the dot and 4 for .old
        if (MAX_PATH > dwGreatestNumberOfChars)
        {
            for (int i = 0; i < c_dwNumFiles; i++)
            {
                wsprintf(szSrc, TEXT("%s\\%s"), szTempDir, ArrayOfCmFiles[i]);
                wsprintf(szDest, TEXT("%s\\%s.old"), szTempDir, ArrayOfCmFiles[i]);

                if (!MoveFile(szSrc, szDest))
                {
                    DWORD dwError = GetLastError();

                    //
                    //  Don't report an error because a file doesn't exist.
                    //
                    if (ERROR_FILE_NOT_FOUND != dwError)
                    {
                        bReturn = FALSE;
                    }
                }
            }        
        }
    }
    else
    {
        bReturn = FALSE;
    }

    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  IsIeak5Cm
//
// Synopsis:  This function compares the given version and build numbers against
//            known constants to figure out if this is an IEAK5 profile or not.
//
// Arguments: DWORD dwMajorAndMinorVersion -- a DWORD containing the Major Version number
//                                            in the HIWORD and the Minor Version number
//                                            in the LOWORD.
//            DWORD dwBuildAndQfeNumber -- a DWORD containing the Build number in the 
//                                         HIWORD and the QFE number in the LOWORD.
//
// Returns:   BOOL -- TRUE if the version numbers passed in correspond to an IEAK5 profile
//
// History:   quintinb Created     8/2/99
//
//+----------------------------------------------------------------------------
BOOL IsIeak5Cm(DWORD dwMajorAndMinorVersion, DWORD dwBuildAndQfeNumber)
{
    BOOL bReturn = FALSE;
    const int c_Ieak5CmBuild = 1976;
    const int c_Ieak5CmMajorVer = 7;
    const int c_Ieak5CmMinorVer = 0;
    const DWORD c_dwIeak5Version = (c_Ieak5CmMajorVer << c_iShiftAmount) + c_Ieak5CmMinorVer;

    if ((c_dwIeak5Version == dwMajorAndMinorVersion) &&
        (c_Ieak5CmBuild == HIWORD(dwBuildAndQfeNumber)))

    {
        bReturn = TRUE;  
    }

    return bReturn;
}

//
//  RasTypeDefs
//
typedef DWORD (WINAPI *pfnRasSetEntryPropertiesSpec)(LPCTSTR, LPCTSTR, LPRASENTRY, DWORD, LPBYTE, DWORD);

//+----------------------------------------------------------------------------
//
// Function:  EnumerateAndPreMigrateAllUserProfiles
//
// Synopsis:  This function is called through the cmstp.exe extension proc.  It
//            is used to pre-migrate 1.0 profiles.  Any profile that needs migration
//            and hasn't been migrated yet (when the extension proc is called on an
//            install from an older profile), the connectoid is cleared so that the
//            CustomDialDll part of the connectoid entry is blanked out.  This 
//            prevents RasDeleteEntry being called on the connectoid by older versions
//            of cmstp.exe that don't know to clear the entry before calling it.
//            Otherwise, the RasCustomDeleteEntryNotify function is called and the whole
//            profile is deleted.  This will only happen on 1.0 profiles that have
//            been dialed with but not migrated/upgraded.  Please see NTRAID 379667
//            for further details.
//
// Arguments: BOOL bIeak5Profile -- If the calling profile is an IEAK5 CM profile or not
//
// Returns:   TRUE if successful
//
// History:   quintinb Created     8/2/99
//
//+----------------------------------------------------------------------------
BOOL EnumerateAndPreMigrateAllUserProfiles(BOOL bIeak5Profile)
{
    DWORD dwValueSize;
    HKEY hKey;
    DWORD dwType;
    DWORD dwDataSize;
    TCHAR szCurrentValue[MAX_PATH+1];
    TCHAR szCurrentData[MAX_PATH+1];

    //
    //  Load RasApi32.dll and get RasSetEntryProperties from it.
    //
    pfnRasSetEntryPropertiesSpec pfnSetEntryProperties = NULL;

    HMODULE hRasApi32 = LoadLibrary(TEXT("RASAPI32.DLL"));

    if (hRasApi32)
    {
        pfnSetEntryProperties = (pfnRasSetEntryPropertiesSpec)GetProcAddress(hRasApi32, 
                                                                             "RasSetEntryPropertiesA");
        if (NULL == pfnSetEntryProperties)
        {
            CMTRACE(TEXT("EnumerateAndPreMigrateAllUserProfiles -- Couldn't get RasSetEntryProperties."));
            return FALSE;
        }
    }
    else
    {
        CMTRACE(TEXT("EnumerateAndPreMigrateAllUserProfiles -- Couldn't load rasapi32.dll."));
        return FALSE;
    }

    //
    //  Get the all user CM and all user PBK directories
    //
    TCHAR szCmAllUsersDir[MAX_PATH+1] = {0};
    LPTSTR pszPhonebook = NULL;

    if (GetAllUsersCmDir(szCmAllUsersDir, g_hInst))
    {
        //
        // TRUE is for an All-User profile
        //
        if (!GetPhoneBookPath(szCmAllUsersDir, &pszPhonebook, TRUE))
        {
            CMTRACE(TEXT("EnumerateAndPreMigrateAllUserProfiles -- GetPhoneBookPath Failed, returning."));
            return FALSE;
        }
    }
    else
    {
        CMTRACE(TEXT("EnumerateAndPreMigrateAllUserProfiles -- GetAllUsersCmDir Failed, returning."));
        return FALSE;
    }

    //
    //  If its and IEAK5 profile then we need to get the System Directory
    //
    TCHAR szSysDir[MAX_PATH+1];
    if (bIeak5Profile)
    {
        if (0 == GetSystemDirectory(szSysDir, MAX_PATH))
        {
            CMTRACE(TEXT("EnumerateAndPreMigrateAllUserProfiles -- GetSystemDirectory Failed, returning."));
            return FALSE;
        }
    }

    //
    //  Now enumerate all of the All User Profiles and see if they need any
    //  Pre-Migration.
    //  
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_pszRegCmMappings, 0, KEY_READ, &hKey))
    {
        DWORD dwIndex = 0;
        dwValueSize = MAX_PATH;
        dwDataSize = MAX_PATH;
                
        while (ERROR_SUCCESS == RegEnumValue(hKey, dwIndex, szCurrentValue, &dwValueSize, NULL, &dwType, 
               (LPBYTE)szCurrentData, &dwDataSize))
        {
            if (REG_SZ == dwType)
            {
                MYDBGASSERT(0 != szCurrentValue[0]);
                MYDBGASSERT(0 != szCurrentData[0]);

                if (ProfileNeedsMigration(szCurrentValue, szCurrentData))
                {
                    //
                    //  Use GetPhoneBookPath to get the path to the phonebook.
                    //
                    TCHAR szCmAllUsersDir[MAX_PATH+1] = {0};

                    //
                    //  Use RasSetEntryProperties to clear the connectoid
                    //
                    RASENTRY_V500 RasEntryV5 = {0};

                    RasEntryV5.dwSize = sizeof(RASENTRY_V500);
                    RasEntryV5.dwType = RASET_Internet;

                    if (bIeak5Profile)
                    {
                        //
                        //  Since IEAK5 didn't migrate 1.0 connectoids
                        //  properly (it writes them in %windir%\system32\pbk\rasphone.pbk
                        //  instead of under the all users profile as appropriate),
                        //  we need to set the szCustomDialDll instead of clearing it.
                        //
                        wsprintf(RasEntryV5.szCustomDialDll, TEXT("%s\\cmdial32.dll"), szSysDir);
                    }
                    // else zero the szCustomDialDll part of the entry
                    // RasEntryV5.szCustomDialDll[0] = TEXT('\0'); -- already zero-ed

                    DWORD dwRet = ((pfnSetEntryProperties)(pszPhonebook, szCurrentValue, 
                                                           (RASENTRY*)&RasEntryV5, 
                                                           RasEntryV5.dwSize, NULL, 0));
                    if (ERROR_SUCCESS != dwRet)
                    {
                        CMTRACE3(TEXT("EnumerateAndPreMigrateAllUserProfiles -- RasSetEntryProperties failed on entry %s in %s, dwRet = %u"), szCurrentValue, MYDBGSTR(pszPhonebook), dwRet);
                    }
                }
            }
            dwValueSize = MAX_PATH;
            dwDataSize = MAX_PATH;
            dwIndex++;
        }
        MYVERIFY(ERROR_SUCCESS == RegCloseKey(hKey));
    }
    else
    {
       CMTRACE(TEXT("EnumerateAndPreMigrateAllUserProfiles -- No CM mappings key to migrate."));
    }

    CmFree(pszPhonebook);

    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:  RunningUnderWow64
//
// Synopsis:  This function is used to tell if a 32-bit process is running under
//            Wow64 on an ia64 machine.  Note that if we are compiled 64-bit this
//            is always false.  We make the determination by trying to call
//            GetSystemWow64Directory.  If this function doesn't exist or returns
//            ERROR_CALL_NOT_IMPLEMENTED we know we are running on 32-bit.  If the
//            function returns successfully we know we are running under wow64.
//
// Arguments: None
//
// Returns:   BOOL - whether we are executing under wow64 or not
//
// History:   quintinb      Created     08/18/00
//
//+----------------------------------------------------------------------------
BOOL RunningUnderWow64 ()
{
#ifdef _WIN64
    return FALSE;
#else

    BOOL bReturn = FALSE;

    //
    //  First get a module handle for kernel32.dll.  Note it isn't necessary
    //  to free this handle as GetModuleHandle doesn't change the ref count.
    //
    HMODULE hKernel32 = GetModuleHandle(TEXT("kernel32.dll"));
    if (hKernel32)
    {
        //
        //  Next get the function pointer for GetSystemWow64Directory
        //
        typedef UINT (WINAPI *pfnGetSystemWow64DirectorySpec)(LPTSTR, UINT);
#ifdef UNICODE
        const CHAR* const c_pszGetSystemWow64FuncName = "GetSystemWow64DirectoryW";
#else
        const CHAR* const c_pszGetSystemWow64FuncName = "GetSystemWow64DirectoryA";
#endif

        pfnGetSystemWow64DirectorySpec pfnGetSystemWow64Directory = (pfnGetSystemWow64DirectorySpec)GetProcAddress(hKernel32, c_pszGetSystemWow64FuncName);

        if (pfnGetSystemWow64Directory)
        {
            TCHAR szSysWow64Path[MAX_PATH+1] = TEXT("");

            //
            //  GetSystemWow64Directory returns the number of chars copied to the buffer.
            //  If we get zero back, then we need to check the last error code to see what the
            //  reason for failure was.  If it was call not implemented then we know we are
            //  running on native x86.
            //
            UINT uReturn = pfnGetSystemWow64Directory(szSysWow64Path, MAX_PATH);

            DWORD dwError = GetLastError();

            CMTRACE2(TEXT("RunningUnderWow64 -- GetSystemWow64Directory returned \"%s\" and %d"), szSysWow64Path, uReturn);

            if (uReturn)
            {
                bReturn = TRUE;
            }
            else
            {
                CMTRACE1(TEXT("RunningUnderWow64 -- GetSystemWow64Directory returned zero, checking GLE=%d"), dwError);

                if (ERROR_CALL_NOT_IMPLEMENTED == dwError)
                {
                    bReturn = FALSE;
                }
                else
                {
                    //
                    //  We got an error, the return value is indeterminant.  Let's take a backup method
                    //  of looking for %windir%\syswow64 and see if we can find one.
                    //
                    if (GetWindowsDirectory (szSysWow64Path, MAX_PATH))
                    {
                        lstrcat(szSysWow64Path, TEXT("\\syswow64"));

                        HANDLE hDir = CreateFile(szSysWow64Path, GENERIC_READ, 
                                                 FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, 
                                                 OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);

                        CMTRACE2(TEXT("RunningUnderWow64 -- Fall back algorithm.  Does \"%s\" exist? %d"), szSysWow64Path, (INVALID_HANDLE_VALUE != hDir));
        
                        if (INVALID_HANDLE_VALUE != hDir)
                        {
                            bReturn = TRUE;
                            CloseHandle(hDir);
                        }
                    }
                }
            }
        }
    }

    return bReturn;

#endif
}

//+----------------------------------------------------------------------------
//
// Function:  CmstpExtensionProc
//
// Synopsis:  This function is called by cmstp.exe right after it processes the command
//            line and again after it completes its action.  It is most useful for modifying
//            the install behavior of profiles.  Since the cmstp.exe that shipped with the profile,
//            not the current version of cmstp.exe is used for the install, this proc
//            allows us to change the install flags, change the inf path, and tell cmstp
//            to continue or silently fail the install.  This version of the proc looks for
//            old versions of cmstp.exe and then copies the installation files to a temporary
//            directory and then launches the system's version of cmstp.exe with the new
//            install directory and parameters (we add the /c switch so that cmstp.exe knows to
//            cleanup after itself and to wait on the mutex).
//
// Arguments: LPDWORD pdwFlags - command line flags parsed by cmstp.exe
//            LPTSTR pszInfFile - Path to the original INF file
//            HRESULT hrRet - Return value of the action, only really used for POST
//            EXTENSIONDLLPROCTIMES PreOrPost - PRE or POST, tells when we are being called.
//
// Returns:   BOOL - Whether Cmstp.exe should continue the existing install or not.
//
// History:   quintinb Created     6/2/99
//
//+----------------------------------------------------------------------------
BOOL CmstpExtensionProc(LPDWORD pdwFlags, LPTSTR pszInfFile, HRESULT hrRet, EXTENSIONDLLPROCTIMES PreOrPost)
{
    //
    //  We don't want 32-bit profiles installing on 64-bit.  Note that the 32-bit version of cmcfg32.dll will be
    //  in the syswow64 dir on a 64-bit machine.  Thus the code below will kick in when a 32-bit version of this
    //  function is used on a 64-bit machine.  We also don't want 32-bit profiles trying to do migration, uninstalling,
    //  etc.
    //

    if (RunningUnderWow64())
    {
        //
        //  If this is an install, show an error message about not being able to install 32-bit profiles
        //  on 64-bit.
        //
        if (0 == ((*pdwFlags) & 0xFF))
        {
            //
            //  Get the long service name from the Inf
            //
            TCHAR szServiceName[MAX_PATH+1] = TEXT("");
            TCHAR szMsg[MAX_PATH+1] = TEXT("");

            MYVERIFY(0 != GetPrivateProfileString(c_pszInfSectionStrings, c_pszCmEntryServiceName, TEXT(""), szServiceName, CELEMS(szServiceName), pszInfFile));
            MYVERIFY(0 != LoadString(g_hInst, IDS_NO_I386_ON_IA64, szMsg, MAX_PATH));

            MYVERIFY(IDOK == MessageBox(NULL, szMsg, szServiceName, MB_OK));
        }

        //
        //  Fail whatever operation we were called to do
        //
        return FALSE;
    }

    //
    //  If the first two Hex digits in the flags value are Zero, then we have an install.
    //  Otherwise we have some other command that we wish to ignore.  We also are only
    //  interested in processing PRE install calls.
    //

    if ((0 == ((*pdwFlags) & 0xFF)) && (PRE == PreOrPost))
    {
        CMTRACE(TEXT("CmstpExtensionProc -- Entering the cmstpex processing loop."));
        //
        //  We only wish to re-launch the install with the current cmstp.exe if we are dealing with an
        //  older install.  Thus check the version stamp in the inf file.  We will re-launch any
        //  profiles with the version number less than the current version number of cmdial32.dll.
        //
        CmVersion CmVer;

        DWORD dwProfileVersionNumber = (DWORD)GetPrivateProfileInt(c_pszSectionCmDial32, c_pszVersion, 0, 
                                                                   pszInfFile);

        DWORD dwProfileBuildNumber = (DWORD)GetPrivateProfileInt(c_pszSectionCmDial32, c_pszVerBuild, 0, 
                                                                   pszInfFile);
       
        if ((CmVer.GetVersionNumber() > dwProfileVersionNumber) ||
            ((CmVer.GetVersionNumber() == dwProfileVersionNumber) && 
             (CmVer.GetBuildAndQfeNumber() > dwProfileBuildNumber)))
        {
            //
            //  Then we need to delete the CM bits included with the profile because
            //  otherwise we will get install errors due to the fact that the profile
            //  will be launched with the cmdial32.dll from system32 (the path is
            //  explicitly specified in the connectoid for the custom dial dll), but
            //  the load path used by the system is the directory from which the exe
            //  module loaded (the temp dir in this case).  Thus we will get a mixed
            //  set of bits (cmdial32.dll from system32 and cmutil.dll, cmpbk32.dll, etc.
            //  from the cab).
            //

            TCHAR szTempDir[MAX_PATH+1];

            lstrcpy (szTempDir, pszInfFile);
            LPTSTR pszSlash = CmStrrchr(szTempDir, TEXT('\\'));

            if (pszSlash)
            {
                //
                //  Then we found a last slash, Zero Terminate.
                //
                *pszSlash = TEXT('\0');

                //
                //  Now we have the old temp dir path.  Lets delete the old
                //  CM bits
                //
                MYVERIFY(0 != RenameOldCmBits (szTempDir));
            }

            //
            //  We also need to make sure that there aren't any 1.0 profiles that have a
            //  1.2 connectoid but only have a 1.0 registry format (thus they still have
            //  a 1.0 desktop GUID interface).  The problem here is that installation will try
            //  to run profile migration on these connectoids.  Older versions of cmstp.exe
            //  would delete the existing connectoids and make new ones during profile migration.
            //  The problem is that on NT5 we now respond to the RasCustomDeleteEntryNotify call, and
            //  thus will uninstall profiles that have RasDeleteEntry called on their main connectoid.
            //  To prevent this, we must pre-migrate older profiles and delete the new connectoid
            //  properly.
            //
            EnumerateAndPreMigrateAllUserProfiles(IsIeak5Cm(dwProfileVersionNumber, dwProfileBuildNumber));
        }
    }

    return TRUE; // always return TRUE so that cmstp.exe continues.  Only change this if you want cmstp.exe
                 // to fail certain actions.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmdebug\cmdebug.cpp ===
//+----------------------------------------------------------------------------
//
// File:     cmdebug.cpp
//
// Module:   CMDEBUG.LIB
//
// Synopsis: This source file contains the debugging routines common to all 
//           of the CM components.
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   nickball   Created    02/04/98
//
//+----------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif

#include <windows.h>

#ifdef DEBUG

#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include "cmdebug.h"
//
//  Ansi Versions
//
void MyDbgPrintfA(const char *pszFmt, ...) 
{
    va_list valArgs;
    char szTmp[512];
    CHAR szOutput[512];

    va_start(valArgs, pszFmt);
    wvsprintfA(szTmp, pszFmt, valArgs);
    va_end(valArgs);
	
    wsprintfA(szOutput, "0x%x: 0x%x: %s\r\n", GetCurrentProcessId(), GetCurrentThreadId(), szTmp);

    OutputDebugStringA(szOutput);

    //
    // Attempt to log output
    //

    CHAR szFileName[MAX_PATH + 1];
    DWORD dwBytes;
    
    GetSystemDirectoryA(szFileName, MAX_PATH);
    lstrcatA(szFileName, "\\CMTRACE.TXT");
    
    HANDLE hFile = CreateFileA(szFileName, 
                               GENERIC_WRITE,
                               FILE_SHARE_WRITE,
                               NULL,
                               OPEN_EXISTING,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL);

    if (hFile != INVALID_HANDLE_VALUE)
    {
        if (INVALID_SET_FILE_POINTER != SetFilePointer(hFile, 0, 0, FILE_END))
        {
            WriteFile(hFile, szOutput, sizeof(CHAR)*lstrlenA(szOutput), &dwBytes, NULL);
        }
        CloseHandle(hFile);
    }   
}

void MyDbgAssertA(const char *pszFile, unsigned nLine, const char *pszMsg) 
{
    char szOutput[1024];

    wsprintfA(szOutput, "%s(%u) - %s", pszFile, nLine, pszMsg);

    MyDbgPrintfA(szOutput);

    //
    // Prompt user
    //

    wsprintfA(szOutput, "%s(%u) - %s\n( Press Retry to debug )", pszFile, nLine, pszMsg);
    int nCode = IDIGNORE;

    static long dwAssertCount = -1;  // Avoid another assert while the messagebox is up

    //
    // If there is no Assertion meesagebox, popup one
    //
    if (InterlockedIncrement(&dwAssertCount) == 0)
    {
        nCode = MessageBoxExA(NULL, szOutput, "Assertion Failed",
            MB_SYSTEMMODAL | MB_ICONHAND | MB_ABORTRETRYIGNORE, LANG_USER_DEFAULT);
    }

    InterlockedDecrement(&dwAssertCount);

    if (nCode == IDIGNORE)
    {
        return;     // ignore
    }
    else if (nCode == IDRETRY)
    {
        // break into the debugger (or Dr Watson log)
#ifdef _X86_
        _asm { int 3 };
#else
        DebugBreak();
#endif
        return; // ignore and continue in debugger to diagnose problem
    }
    else if (0 == nCode)
    {
        //
        //  MessageBoxEx Failed.  Lets call GLE
        //
        DWORD dwError = GetLastError();

        //
        //  Fall through and exit process anyway
        //
    }
    // else fall through and call Abort

    ExitProcess((DWORD)-1);

}

//
//    Unicode Versions
//

void MyDbgPrintfW(const WCHAR *pszFmt, ...) 
{
    va_list valArgs;
    CHAR szOutput[512];   
    CHAR szTmp[512];

    va_start(valArgs, pszFmt);
    int iRet = wvsprintfWtoAWrapper(szTmp, pszFmt, valArgs);
    va_end(valArgs);
	
    if (0 == iRet)
    {
        //
        //  We weren't able to write the Unicode string as expected.  Lets
        //  try just putting a failure string in the szTmp buffer instead.
        //
        lstrcpyA(szTmp, "MyDbgPrintfW -- wvsprintfWtoAWrapper failed.  Unsure of original message, please investigate.");
    }


    wsprintfA(szOutput, "0x%x: 0x%x: %s\r\n", GetCurrentProcessId(), GetCurrentThreadId(), szTmp);

    OutputDebugStringA(szOutput);

    //
    // Attempt to log output
    //

    CHAR szFileName[MAX_PATH + 1];
    DWORD dwBytes;
    
    GetSystemDirectoryA(szFileName, MAX_PATH);
    lstrcatA(szFileName, "\\CMTRACE.TXT");
    
    HANDLE hFile = CreateFileA(szFileName, 
                              GENERIC_WRITE,
                              FILE_SHARE_WRITE,
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL);

    if (hFile != INVALID_HANDLE_VALUE)
    {
        if (INVALID_SET_FILE_POINTER != SetFilePointer(hFile, 0, 0, FILE_END))
        {
            WriteFile(hFile, szOutput, sizeof(CHAR)*lstrlen(szOutput), &dwBytes, NULL);
        }
        CloseHandle(hFile);
    }   
}

void MyDbgAssertW(const char *pszFile, unsigned nLine, WCHAR *pszMsg) 
{
    CHAR szOutput[1024];

    wsprintfA(szOutput, "%s(%u) - %S", pszFile, nLine, pszMsg);

    MyDbgPrintfA(szOutput);

    //
    // Prompt user
    //

    wsprintfA(szOutput, "%s(%u) - %S\n( Press Retry to debug )", pszFile, nLine, pszMsg);
    int nCode = IDIGNORE;

    static long dwAssertCount = -1;  // Avoid another assert while the messagebox is up

    //
    // If there is no Assertion meesagebox, popup one
    //
    if (InterlockedIncrement(&dwAssertCount) == 0)
    {
        nCode = MessageBoxExA(NULL, szOutput, "Assertion Failed",
            MB_SYSTEMMODAL | MB_ICONHAND | MB_ABORTRETRYIGNORE, LANG_USER_DEFAULT);
    }

    InterlockedDecrement(&dwAssertCount);

    if (nCode == IDIGNORE)
    {
        return;     // ignore
    }
    else if (nCode == IDRETRY)
    {
        // break into the debugger (or Dr Watson log)
#ifdef _X86_
        _asm { int 3 };
#else
        DebugBreak();
#endif
        return; // ignore and continue in debugger to diagnose problem
    }
    // else fall through and call Abort

    ExitProcess((DWORD)-1);

}

#endif //DEBUG

//
//  Included to make MyDbgPrintfW work on win9x.  Please note that it steps through the string
//  byte by byte (doesn't deal with MBCS chars) but since this is really called on Format strings
//  this shouldn't be a problem.
//

void InvertPercentSAndPercentC(LPSTR pszFormat)
{
    if (pszFormat)
    {
        LPSTR pszTmp = pszFormat;
        BOOL bPrevCharPercent = FALSE;

        while(*pszTmp)
        {
            switch (*pszTmp)
            {
            case '%':
                //
                //  if we have %% then we must ignore the percent, otherwise save it.
                //
                bPrevCharPercent = !bPrevCharPercent;
                break;

            case 'S':
                if (bPrevCharPercent)
                {
                    *pszTmp = 's';
                }
                break;

            case 's':
                if (bPrevCharPercent)
                {
                    *pszTmp = 'S';
                }
                break;

            case 'C':
                if (bPrevCharPercent)
                {
                    *pszTmp = 'c';
                }
                break;

            case 'c':
                if (bPrevCharPercent)
                {
                    *pszTmp = 'C';
                }
                break;

            default:
                //
                //  don't fool ourselves by always keeping this set.
                //
                bPrevCharPercent = FALSE;
                break;
            }
            pszTmp++;
        }
    }
}

//
//  This function takes Unicode input strings (potentially in the va_list as well)
//  and uses the fact that wvsprintfA will print Unicode strings into an Ansi
//  output string if the special char %S is used instead of %s.  Thus we will convert
//  the input parameter string and then replace all the %s chars with %S chars (and vice versa).
//  This will allow us to call wvsprintfA since wvsprintfW isn't available on win9x.
//
int WINAPI wvsprintfWtoAWrapper(OUT LPSTR pszAnsiOut, IN LPCWSTR pszwFmt, IN va_list arglist)
{
    int iRet = 0;
    LPSTR pszAnsiFormat = NULL;

    if ((NULL != pszAnsiOut) && (NULL != pszwFmt) && (L'\0' != pszwFmt[0]))
    {
        //
        //  Convert pszwFmt to Ansi
        //
        DWORD dwSize = WideCharToMultiByte(CP_ACP, 0, pszwFmt, -1, pszAnsiFormat, 0, NULL, NULL);

        if (0 != dwSize)
        {
            pszAnsiFormat = (LPSTR)LocalAlloc(LPTR, dwSize*sizeof(CHAR));

            if (pszAnsiFormat)
            {
                if (WideCharToMultiByte(CP_ACP, 0, pszwFmt, -1, pszAnsiFormat, dwSize, NULL, NULL))
                {
                    //
                    //  Now change the little s's and c's to their capital equivalent and vice versa
                    //
                    InvertPercentSAndPercentC(pszAnsiFormat);
                    
                    //
                    //  Finally construct the string
                    //

                    iRet = wvsprintfA(pszAnsiOut, pszAnsiFormat, arglist);
                }
            }
        }
    }

    LocalFree(pszAnsiFormat);
    return iRet;
}

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmcontbl\contable.cpp ===
//+----------------------------------------------------------------------------
//
// File:    CONTABLE.CPP    
//
// Module:  CMCONTBL.LIB
//
// Synopsis: Implements the CM connection table (CConnectionTable). The connection
//           table is a list of active conenctions stored in a (memory only) memory 
//           mapped file, and shared by the various CM components in order to 
//           manage CM connections.
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:  nickball   Created    02/02/98
//
//+----------------------------------------------------------------------------

#include <windows.h>

#include "contable.h"
#include "cmdebug.h"
#include "cmutil.h"
#include "uapi.h"
#include "setacl.h"

#if 0
#include "DumpSecInfo.cpp"
#endif

#define CONN_TABLE_NAME TEXT("CmConnectionTable")
#define CONN_TABLE_OPEN TEXT("CmConnectionOpen")

static const int MAX_LOCK_WAIT = 1000; // wait timeout in milliseconds

//
// Constructor and destructor
//
CConnectionTable::CConnectionTable()
{
    CMTRACE(TEXT("CConnectionTable::CConnectionTable()"));

    //
    // Initialize our data members
    //

    m_hMap = NULL;
    m_pConnTable = NULL;
    m_fLocked = FALSE;
    m_hEvent = NULL;
}

CConnectionTable::~CConnectionTable()
{
    CMTRACE(TEXT("CConnectionTable::~CConnectionTable()"));

    //
    // Data should have been cleaned up in Close, etc. Double-Check
    //

    MYDBGASSERT(NULL == m_pConnTable);
    MYDBGASSERT(NULL == m_hMap);
    MYDBGASSERT(FALSE == m_fLocked);
    MYDBGASSERT(NULL == m_hEvent);

    //
    // Release handles and pointers
    //

    if (m_pConnTable)
    {
        MYVERIFY(NULL != UnmapViewOfFile(m_pConnTable));
        m_pConnTable = NULL;
    }

    if (m_hMap)
    {
        MYVERIFY(NULL != CloseHandle(m_hMap));
        m_hMap = NULL;
    }

    if (m_hEvent)
    {
        MYVERIFY(NULL != CloseHandle(m_hEvent));
        m_hEvent = NULL;
    }
}

//+----------------------------------------------------------------------------
//
// Function:  CConnectionTable::LockTable
//
// Synopsis:  Sets the internal lock on the table. Should be called internally
//            prior to any table access.
//
// Arguments: None
//
// Returns:   HRESULT - Failure code or S_OK
//
// History:   nickball    Created    2/2/98
//
//+----------------------------------------------------------------------------
HRESULT CConnectionTable::LockTable()
{
    MYDBGASSERT(m_pConnTable);
    MYDBGASSERT(m_hMap);
    MYDBGASSERT(m_hEvent);
    CMTRACE(TEXT("CConnectionTable::LockTable()"));

    HRESULT hrRet = S_OK;

    //
    // Validate our current state
    //

    if (NULL == m_hEvent)
    {
        MYDBGASSERT(FALSE);
        return E_ACCESSDENIED;
    }

    //
    // Wait for the open event to be signaled
    //

    DWORD dwWait = WaitForSingleObject(m_hEvent, MAX_LOCK_WAIT);

    //
    // If our records indicate that we are already locked at this point
    // then something is wrong within the class implementation
    //

    MYDBGASSERT(FALSE == m_fLocked); // no double locks please

    if (TRUE == m_fLocked)
    {
        SetEvent(m_hEvent);    // cleat the signal that we just set by clearing the wait
        return E_ACCESSDENIED;
    }

    //
    // Check the
    //

    if (WAIT_FAILED == dwWait)
    {
        MYDBGASSERT(FALSE);
        hrRet = GetLastError();
        return HRESULT_FROM_WIN32(hrRet);
    }

    //
    // If not signaled, bail
    //

    MYDBGASSERT(WAIT_OBJECT_0 == dwWait);

    if (WAIT_OBJECT_0 != dwWait)
    {
        if (WAIT_TIMEOUT == dwWait)
        {
            hrRet = HRESULT_FROM_WIN32(ERROR_TIMEOUT);
        }
        else
        {
            hrRet = E_ACCESSDENIED;
        }
    }
    else
    {
        //
        // The event is signaled automatically by virtue of the
        // fact that we cleared the wait on the event. Its locked.
        //

        m_fLocked = TRUE;
    }

    return hrRet;
}

//+----------------------------------------------------------------------------
//
// Function:  CConnectionTable::UnlockTable
//
// Synopsis:  Clears the internal lock on the table. Should be cleared
//            following any access to the table.
//
// Arguments: None
//
// Returns:   HRESULT - Failure code or S_OK
//
// History:   nickball    Created    2/2/98
//
//+----------------------------------------------------------------------------
HRESULT CConnectionTable::UnlockTable()
{
    MYDBGASSERT(m_pConnTable);
    MYDBGASSERT(m_hMap);
    MYDBGASSERT(m_hEvent);
    MYDBGASSERT(TRUE == m_fLocked);
    CMTRACE(TEXT("CConnectionTable::UnlockTable()"));

    HRESULT hrRet = S_OK;

    //
    // Validate our current state
    //

    if (FALSE == m_fLocked || NULL == m_hEvent)
    {
        return E_ACCESSDENIED;
    }

    //
    // Signal the open event, allowing access
    //

    if (SetEvent(m_hEvent))
    {
        m_fLocked = FALSE;
    }
    else
    {
        MYDBGASSERT(FALSE);

        hrRet = GetLastError();
        hrRet = HRESULT_FROM_WIN32(hrRet);
    }

    return hrRet;
}

//+----------------------------------------------------------------------------
//
// Function:  CConnectionTable::FindEntry - pszEntry
//
// Synopsis:  Determines the ID (index) of an entry in the table. Table should
//            be locked before making this call.
//
// Arguments: LPCTSTR pszEntry - Ptr to the name of the entry we are seeking.
//            LPINT piID - Ptr to buffer for ID (index) of connection
//
// Returns:   HRESULT - Failure code, or S_OK if piID filled.
//
// History:   nickball    Created    2/2/98
//
//+----------------------------------------------------------------------------
HRESULT CConnectionTable::FindEntry(LPCTSTR pszEntry, LPINT piID)
{
    MYDBGASSERT(m_pConnTable);
    MYDBGASSERT(m_hMap);
    MYDBGASSERT(pszEntry);
    MYDBGASSERT(piID);
    MYDBGASSERT(TRUE == m_fLocked);
    CMTRACE1(TEXT("CConnectionTable::FindEntry(%s)"), pszEntry);

    if (FALSE == m_fLocked || NULL == m_pConnTable)
    {
        return E_ACCESSDENIED;
    }

    if (NULL == pszEntry || NULL == piID)
    {
        return E_POINTER;
    }

    if (0 == pszEntry[0])
    {
        return E_INVALIDARG;
    }

    //
    // Look for the entry
    //

    for (int i = 0; i < MAX_CM_CONNECTIONS; i++)
    {
        //
        // Name compare for a match
        //

        if (0 == lstrcmpU(pszEntry, m_pConnTable->Connections[i].szEntry))
        {
            MYDBGASSERT(m_pConnTable->Connections[i].dwUsage);
            MYDBGASSERT(m_pConnTable->Connections[i].CmState);

            *piID = i;

            return S_OK;
        }

    }

    return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
}

//+----------------------------------------------------------------------------
//
// Function:  CConnectionTable::FindEntry - hRasConn
//
// Synopsis:  Determines the ID (index) of an entry in the table. Table should
//            be locked before making this call.
//
// Arguments: HRASCONN hRasConn - Tunnel or dial handle of the entry we are seeking.
//            LPINT piID - Ptr to buffer for ID (index) of connection
//
// Returns:   HRESULT - Failure code, or S_OK if piID filled.
//
// History:   nickball    Created    2/2/98
//
//+----------------------------------------------------------------------------
HRESULT CConnectionTable::FindEntry(HRASCONN hRasConn, LPINT piID)
{
    MYDBGASSERT(m_pConnTable);
    MYDBGASSERT(m_hMap);
    MYDBGASSERT(hRasConn);
    MYDBGASSERT(piID);
    MYDBGASSERT(TRUE == m_fLocked);
    CMTRACE1(TEXT("CConnectionTable::FindEntry(%u)"), (DWORD_PTR) hRasConn);

    if (FALSE == m_fLocked || NULL == m_pConnTable)
    {
        return E_ACCESSDENIED;
    }

    if (NULL == piID)
    {
        return E_POINTER;
    }

    if (NULL == hRasConn)
    {
        return E_INVALIDARG;
    }

    //
    // Look for the entry
    //

    for (int i = 0; i < MAX_CM_CONNECTIONS; i++)
    {
        //
        // Compare for either handle for a match
        //

        if (hRasConn == m_pConnTable->Connections[i].hDial ||
            hRasConn == m_pConnTable->Connections[i].hTunnel)
        {
            MYDBGASSERT(m_pConnTable->Connections[i].dwUsage);
            MYDBGASSERT(m_pConnTable->Connections[i].CmState);

            *piID = i;

            return S_OK;
        }

    }

    return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
}

//+----------------------------------------------------------------------------
//
// Function:  CConnectionTable::FindUnused
//
// Synopsis:  Determines the ID (index) of the first unused entry in the table.
//            Table should be locked before making this call.
//
// Arguments: LPINT piID - Ptr to buffer for ID (index) of connection
//
// Returns:   HRESULT - Failure code, or S_OK if piID filled.
//
// History:   nickball    Created    2/2/98
//
//+----------------------------------------------------------------------------
HRESULT CConnectionTable::FindUnused(LPINT piID)
{
    MYDBGASSERT(m_pConnTable);
    MYDBGASSERT(m_hMap);
    MYDBGASSERT(piID);
    MYDBGASSERT(TRUE == m_fLocked);
    CMTRACE(TEXT("CConnectionTable::FindUnused()"));

    if (FALSE == m_fLocked || NULL == m_pConnTable)
    {
        return E_ACCESSDENIED;
    }

    if (NULL == piID)
    {
        return E_POINTER;
    }

    //
    // Look for an unused slot
    //

    for (int i = 0; i < MAX_CM_CONNECTIONS; i++)
    {
        if (0 == m_pConnTable->Connections[i].dwUsage)
        {
            MYDBGASSERT(CM_DISCONNECTED == m_pConnTable->Connections[i].CmState);

            *piID = i;

            return S_OK;
        }
    }

    return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
}


//+----------------------------------------------------------------------------
//
// Function:  Create
//
// Synopsis:  Creates a new table. This function will fail if the table already exists.
//            The table should be released by calling Close.
//
// Arguments: None
//
// Returns:   HRESULT - Failure code or S_OK
//
// History:   nickball    Created    2/2/98
//
//+----------------------------------------------------------------------------
HRESULT CConnectionTable::Create()
{
    MYDBGASSERT(NULL == m_hMap);
    MYDBGASSERT(NULL == m_pConnTable);
    MYDBGASSERT(FALSE == m_fLocked);
    CMTRACE(TEXT("CConnectionTable::Create()"));

    if (m_hMap || m_pConnTable)
    {
        return E_ACCESSDENIED;
    }

    SECURITY_ATTRIBUTES sa;
    PACL                pAcl = NULL;

    // Initialize a default Security attributes, giving world permissions,
    // this is basically prevent Semaphores and other named objects from
    // being created because of default acls given by winlogon when perfmon
    // is being used remotely.
    sa.bInheritHandle = FALSE;
    sa.nLength = sizeof(SECURITY_ATTRIBUTES);
    sa.lpSecurityDescriptor = CmMalloc(sizeof(SECURITY_DESCRIPTOR));
    
    if ( !sa.lpSecurityDescriptor )
    {
        return E_OUTOFMEMORY;
    }

    if ( !InitializeSecurityDescriptor(sa.lpSecurityDescriptor,SECURITY_DESCRIPTOR_REVISION) ) 
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    if (OS_NT)
    {
        if (FALSE == SetAclPerms(&pAcl))
        {
            return HRESULT_FROM_WIN32(GetLastError());
        }
    }

    if (FALSE == SetSecurityDescriptorDacl(sa.lpSecurityDescriptor, TRUE, pAcl, FALSE)) 
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    //
    //  Now use this 'sa' for the mapped file as well as the event (below)
    //
    m_hMap = CreateFileMappingU(INVALID_HANDLE_VALUE, &sa, PAGE_READWRITE,
                                0, sizeof(CM_CONNECTION_TABLE), CONN_TABLE_NAME);

    DWORD dwRet = GetLastError();

    if (NULL == m_hMap)
    {
        if (dwRet == ERROR_ALREADY_EXISTS)
        {
            if (m_hMap)
            {
                MYVERIFY(NULL != CloseHandle(m_hMap));
                m_hMap = NULL;
            }
        }
        else
        {
            CMTRACE1(TEXT("CreateFileMapping failed with error %d"), dwRet);
            MYDBGASSERT(FALSE);
        }
    }
    else
    {
#if 0 // DBG
        DumpAclInfo(m_hMap);
#endif
        //
        // File mapping created successfully, map a view of it
        //

        m_pConnTable = (LPCM_CONNECTION_TABLE) MapViewOfFile(m_hMap,
                                      FILE_MAP_READ | FILE_MAP_WRITE, 0, 0, 0);
        if (NULL == m_pConnTable)
        {
            dwRet = GetLastError();
            MYVERIFY(NULL != CloseHandle(m_hMap));
            m_hMap = NULL;
        }
        else
        {
            //
            // Success, make sure mapping is empty becuase we are paranoid
            //

            ZeroMemory(m_pConnTable, sizeof(CM_CONNECTION_TABLE));

            //
            // Create the named event to be used for locking the file
            // Note: We use auto-reset.
            //

            m_hEvent = CreateEventU(&sa, FALSE, TRUE, CONN_TABLE_OPEN);

            if (NULL == m_hEvent)
            {
                MYDBGASSERT(FALSE);
                dwRet = GetLastError();
                m_hEvent = NULL;
            }
        }
    }

    CmFree(sa.lpSecurityDescriptor);

    if (pAcl)
    {
        LocalFree(pAcl);
    }
    
    return HRESULT_FROM_WIN32(dwRet);
}

//+----------------------------------------------------------------------------
//
// Function:  CConnectionTable::Open
//
// Synopsis:  Opens an existing table. This function will fail if no table exists.
//            The table should be released by calling Close.
//
// Arguments: None
//
// Returns:   HRESULT - Failure code on S_OK
//
// History:   nickball    Created    2/2/98
//
//+----------------------------------------------------------------------------
HRESULT CConnectionTable::Open()
{
    MYDBGASSERT(NULL == m_hMap);
    MYDBGASSERT(NULL == m_pConnTable);
    MYDBGASSERT(FALSE == m_fLocked);
    CMTRACE(TEXT("CConnectionTable::Open()"));

    if (m_hMap || m_pConnTable)
    {
        return E_ACCESSDENIED;
    }

    LRESULT lRet = ERROR_SUCCESS;

    //
    // Open the file mapping
    //

    m_hMap = OpenFileMappingU(FILE_MAP_READ | FILE_MAP_WRITE, FALSE, CONN_TABLE_NAME);

    if (NULL == m_hMap)
    {
        lRet = GetLastError();
    }
    else
    {
        //
        // File mapping opened successfully, map a view of it.
        //

        m_pConnTable = (LPCM_CONNECTION_TABLE) MapViewOfFile(m_hMap,
                                      FILE_MAP_READ | FILE_MAP_WRITE, 0, 0, 0);
        MYDBGASSERT(m_pConnTable);

        if (NULL == m_pConnTable)
        {
            MYVERIFY(NULL != CloseHandle(m_hMap));
            m_hMap = NULL;
            lRet = GetLastError();
        }
        else
        {
            //
            // Open the named event used for locking the file
            //

            m_hEvent = OpenEventU(GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE,
                                  NULL, CONN_TABLE_OPEN);

            if (NULL == m_hEvent)
            {
                MYDBGASSERT(FALSE);
                lRet = GetLastError();
            }
        }
    }

    return HRESULT_FROM_WIN32(lRet);
}

//+----------------------------------------------------------------------------
//
// Function:  CConnectionTable::Close
//
// Synopsis:  Closes an opened table. This function will fail if the table is
//            not open.
//
// Arguments: None
//
// Returns:   HRESULT - Failure code or S_OK
//
// History:   nickball    Created    2/2/98
//
//+----------------------------------------------------------------------------
HRESULT CConnectionTable::Close()
{
    MYDBGASSERT(m_pConnTable);
    MYDBGASSERT(m_hMap);
    MYDBGASSERT(FALSE == m_fLocked);
    CMTRACE(TEXT("CConnectionTable::Close()"));

    if (m_pConnTable)
    {
        MYVERIFY(NULL != UnmapViewOfFile(m_pConnTable));
        m_pConnTable = NULL;
    }

    if (m_hMap)
    {
        MYVERIFY(NULL != CloseHandle(m_hMap));
        m_hMap = NULL;
    }

    if (m_hEvent)
    {
        MYVERIFY(NULL != CloseHandle(m_hEvent));
        m_hEvent = NULL;
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
// Function:  CConnectionTable::AddEntry
//
// Synopsis:  Creates a new entry in the table with the specified name. Adding
//            an entry implies that the connection is being attempted, so the
//            connection state is set to CM_CONNECTING. If an entry for the
//            connection already exists, the usage count is incremented.
//
// Arguments: LPCTSTR pszEntry - The name of connection for which we're creating an entry.
//            BOOL fAllUser - The All User attribute of the profile
//
// Returns:   HRESULT - Failure code or S_OK
//
// History:   nickball    Created    2/2/98
//
//+----------------------------------------------------------------------------
HRESULT CConnectionTable::AddEntry(LPCTSTR pszEntry, BOOL fAllUser)
{
    MYDBGASSERT(m_pConnTable);
    MYDBGASSERT(m_hMap);
    MYDBGASSERT(pszEntry);
    CMTRACE1(TEXT("CConnectionTable::AddEntry(%s)"), pszEntry);

    if (NULL == pszEntry)
    {
        return E_POINTER;
    }

    if (0 == pszEntry[0])
    {
        return E_INVALIDARG;
    }

    if (NULL == m_pConnTable)
    {
        return E_ACCESSDENIED;
    }

    HRESULT hrRet = LockTable();

    if (FAILED(hrRet))
    {
        return hrRet;
    }

    //
    // See if we already have an entry by this name
    //

    int iID = -1;
    hrRet = FindEntry(pszEntry, &iID);

    if (SUCCEEDED(hrRet))
    {
        //
        // We do, bump the usage count.
        //

        MYDBGASSERT(iID >= 0 && iID < MAX_CM_CONNECTIONS);

        //
        // Don't bump ref count when reconnecting the same connection.
        //
        if (m_pConnTable->Connections[iID].CmState != CM_RECONNECTPROMPT)
        {
            m_pConnTable->Connections[iID].dwUsage += 1;
        }

        //
        // Unless this entry is already connected, make sure
        // its now in the connecting state. This allows us
        // to preserve the usage count across prompt reconnect
        // events.
        //

        if (m_pConnTable->Connections[iID].CmState != CM_CONNECTED)
        {
            m_pConnTable->Connections[iID].CmState = CM_CONNECTING;
        }

        MYDBGASSERT(m_pConnTable->Connections[iID].dwUsage < 1000); // Sanity check
    }
    else
    {
        if (HRESULT_CODE(hrRet) == ERROR_NOT_FOUND)
        {
            //
            // Its a new entry, find the first unused slot
            //

            hrRet = FindUnused(&iID);

            MYDBGASSERT(SUCCEEDED(hrRet));

            if (SUCCEEDED(hrRet))
            {
                MYDBGASSERT(iID >= 0 && iID < MAX_CM_CONNECTIONS);

                ZeroMemory(&m_pConnTable->Connections[iID], sizeof(CM_CONNECTION));

                //
                // Set usage count, state and name
                //

                m_pConnTable->Connections[iID].dwUsage = 1;
                m_pConnTable->Connections[iID].CmState = CM_CONNECTING;

                lstrcpyU(m_pConnTable->Connections[iID].szEntry, pszEntry);

                m_pConnTable->Connections[iID].fAllUser = fAllUser;
            }
        }
    }

    MYVERIFY(SUCCEEDED(UnlockTable()));

    return hrRet;
}

//+----------------------------------------------------------------------------
//
// Function:  CConnectionTable::RemoveEntry
//
// Synopsis:  Decrements the usage count for the specified connection. If the
//            usage count falls to 0 the entire entry is cleared.
//
// Arguments: LPCTSTR pszEntry - The name of the entry to be removed
//
// Returns:   HRESULT - Failure code or S_OK
//
//  Note:     If the entry does not exists the request fails.
//
// History:   nickball    Created    2/2/98
//
//+----------------------------------------------------------------------------
HRESULT CConnectionTable::RemoveEntry(LPCTSTR pszEntry)
{
    MYDBGASSERT(m_pConnTable);
    MYDBGASSERT(m_hMap);
    MYDBGASSERT(pszEntry);
    CMTRACE1(TEXT("CConnectionTable::RemoveEntry(%s)"), pszEntry);

    if (NULL == pszEntry)
    {
        return E_POINTER;
    }

    if (0 == pszEntry[0])
    {
        return E_INVALIDARG;
    }

    if (NULL == m_pConnTable)
    {
        return E_ACCESSDENIED;
    }

    //
    // Lock the table and locate the entry
    //

    HRESULT hrRet = LockTable();

    if (FAILED(hrRet))
    {
        return hrRet;
    }

    int iID = -1;
    hrRet = FindEntry(pszEntry, &iID);

    if (SUCCEEDED(hrRet))
    {
        MYDBGASSERT(iID >= 0 && iID < MAX_CM_CONNECTIONS);

        if (m_pConnTable->Connections[iID].dwUsage == 1)
        {
            ZeroMemory(&m_pConnTable->Connections[iID], sizeof(CM_CONNECTION));
        }
        else
        {
            m_pConnTable->Connections[iID].dwUsage -= 1;
            MYDBGASSERT(m_pConnTable->Connections[iID].dwUsage != 0xFFFFFFFF);
        }
    }

    MYVERIFY(SUCCEEDED(UnlockTable()));

    return hrRet;
}

//+----------------------------------------------------------------------------
//
// Function:  CConnectionTable::GetMonitorWnd
//
// Synopsis:  Simple accessor to retrieve the hwnd of the CM Connection
//            Monitor from the table.
//
// Arguments: phWnd - Ptr to buffer to receive hWnd
//
// Returns:   Failure code or S_OK
//
// History:   nickball    Created    2/2/98
//
//+----------------------------------------------------------------------------
HRESULT CConnectionTable::GetMonitorWnd(HWND *phWnd)
{
    MYDBGASSERT(m_pConnTable);
    MYDBGASSERT(m_hMap);
    CMTRACE(TEXT("CConnectionTable::GetMonitorWnd()"));

    if (NULL == m_pConnTable)
    {
        return E_ACCESSDENIED;
    }

    if (NULL == phWnd)
    {
        return E_POINTER;
    }

    //
    // Lock the table and retrieve the HWND
    //

    HRESULT hrRet = LockTable();

    if (FAILED(hrRet))
    {
        return hrRet;
    }

    *phWnd = m_pConnTable->hwndCmMon;

    MYVERIFY(SUCCEEDED(UnlockTable()));

    return S_OK;
}

//+----------------------------------------------------------------------------
//
// Function:  CConnectionTable::SetMonitorWnd
//
// Synopsis:  Simple assignment method for setting the CMMON HWND in the table
//            .
// Arguments: HWND hwndMonitor - The HWND of CMMON
//
// Returns:   HRESULT - Failure code or S_OK
//
//  Note:     hwndMonitor CAN be NULL.  It is possible CMMON is unloaded, but
//            the table statys in memory
// History:   nickball    Created    2/2/98
//            fengsun 2/20/98 change to allow NULL phwndMonitor
//
//+----------------------------------------------------------------------------
HRESULT CConnectionTable::SetMonitorWnd(HWND hwndMonitor)
{
    MYDBGASSERT(m_pConnTable);
    MYDBGASSERT(m_hMap);
    CMTRACE(TEXT("CConnectionTable::SetMonitorWnd()"));

    if (NULL == m_pConnTable)
    {
        return E_ACCESSDENIED;
    }

    //
    // Lock the table and set the HWND
    //

    HRESULT hrRet = LockTable();

    if (FAILED(hrRet))
    {
        return hrRet;
    }

    m_pConnTable->hwndCmMon = hwndMonitor;

    MYVERIFY(SUCCEEDED(UnlockTable()));

    return S_OK;
}

//+----------------------------------------------------------------------------
//
// Function:  CConnectionTable::GetEntry - pszEntry
//
// Synopsis:  Retrieves a copy the data for the specified connection based on
//            the entry name provided.
//
// Arguments: LPCTSTR pszEntry - The name of the connection
//            LPCM_CONNECTION pConnection - Ptr to a CM_CONNECTION sturct to be filled
//
// Returns:   HRESULT - Failure Code or S_OK.
//
// Note:      A NULL ptr may be passed for pConnection, if the existence of the
//            entry is the only information required.
//
// History:   nickball    Created    2/2/98
//
//+----------------------------------------------------------------------------
HRESULT CConnectionTable::GetEntry(LPCTSTR pszEntry,
    LPCM_CONNECTION pConnection)
{
    MYDBGASSERT(m_pConnTable);
    MYDBGASSERT(m_hMap);
    MYDBGASSERT(pszEntry);
    CMTRACE1(TEXT("CConnectionTable::GetEntry(%s)"), pszEntry);

    if (NULL == m_pConnTable)
    {
        return E_ACCESSDENIED;
    }

    if (NULL == pszEntry)
    {
        return E_POINTER;
    }

    if (0 == pszEntry[0])
    {
        return E_INVALIDARG;
    }

    //
    // Lock the table and retrieve the entry
    //

    HRESULT hrRet = LockTable();

    if (FAILED(hrRet))
    {
        return hrRet;
    }

    int iID = -1;
    hrRet = FindEntry(pszEntry, &iID);

    if (SUCCEEDED(hrRet))
    {
        MYDBGASSERT(iID >= 0 && iID < MAX_CM_CONNECTIONS);

        //
        // If a buffer was given fill it.
        //

        if (pConnection)
        {
            memcpy(pConnection, &m_pConnTable->Connections[iID], sizeof(CM_CONNECTION));
        }
    }

    MYVERIFY(SUCCEEDED(UnlockTable()));

    return hrRet;
}

//+----------------------------------------------------------------------------
//
// Function:  CConnectionTable::GetEntry - hRasConn
//
// Synopsis:  Retrieves a copy the data for the specified connection based on the
//            Ras handle provided
//
// Arguments: HRASCONN hRasConn - Either the tunnel or dial handle of the connection
//            LPCM_CONNECTION pConnection - Ptr to a CM_CONNECTION sturct to be filled
//
// Returns:   HRESULT - Failure Code or S_OK.
//
// Note:      A NULL ptr may be passed for pConnection, if the existence of the
//            entry is the only information required.
//
// History:   nickball    Created    2/2/98
//
//+----------------------------------------------------------------------------
HRESULT CConnectionTable::GetEntry(HRASCONN hRasConn,
    LPCM_CONNECTION pConnection)
{
    MYDBGASSERT(m_pConnTable);
    MYDBGASSERT(m_hMap);
    MYDBGASSERT(hRasConn);
    CMTRACE1(TEXT("CConnectionTable::GetEntry(%u)"), (DWORD_PTR) hRasConn);

    if (NULL == m_pConnTable)
    {
        return E_ACCESSDENIED;
    }

    if (NULL == hRasConn)
    {
        return E_INVALIDARG;
    }

    //
    // Lock the table and retrieve the entry
    //

    HRESULT hrRet = LockTable();

    if (FAILED(hrRet))
    {
        return hrRet;
    }

    int iID = -1;
    hrRet = FindEntry(hRasConn, &iID);

    if (SUCCEEDED(hrRet))
    {
        MYDBGASSERT(iID >= 0 && iID < MAX_CM_CONNECTIONS);

        //
        // If a buffer was given fill it.
        //

        if (pConnection)
        {
            memcpy(pConnection, &m_pConnTable->Connections[iID], sizeof(CM_CONNECTION));
        }
    }

    MYVERIFY(SUCCEEDED(UnlockTable()));

    return hrRet;
}

//+----------------------------------------------------------------------------
//
// Function:  CConnectionTable::SetConnected
//
// Synopsis:  Sets the connection to CM_CONNECTED indicating that a connection
//            has been established. The caller must provide either the hDial or
//            the hTunnel parameter or both in order for the function to succeed.
//
// Arguments: LPCTSTR pszEntry - The name of the connection.
//            HRASCONN hDial - A Dial-up connection handle.
//            HRASCONN hTunnel - A tunnel connection handle.
//
// Returns:   HRESULT - Failure code or S_OK.
//
// History:   nickball    Created    2/2/98
//
//+----------------------------------------------------------------------------
HRESULT CConnectionTable::SetConnected(LPCTSTR pszEntry,
    HRASCONN hDial,
    HRASCONN hTunnel)
{
    MYDBGASSERT(m_pConnTable);
    MYDBGASSERT(m_hMap);
    MYDBGASSERT(pszEntry);
    CMTRACE1(TEXT("CConnectionTable::SetConnected(%s)"), pszEntry);

    if (NULL == m_pConnTable)
    {
        return E_ACCESSDENIED;
    }

    if (NULL == pszEntry)
    {
        return E_POINTER;
    }

    if (0 == pszEntry[0] || (NULL == hDial && NULL == hTunnel))
    {
        return E_INVALIDARG;
    }

    //
    // Lock the table and retrieve the entry
    //

    HRESULT hrRet = LockTable();

    if (FAILED(hrRet))
    {
        return hrRet;
    }

    int iID = -1;
    hrRet = FindEntry(pszEntry, &iID);

    MYDBGASSERT(SUCCEEDED(hrRet));

    if (SUCCEEDED(hrRet))
    {
        //
        // Found, set the state and Ras handles
        //

        MYDBGASSERT(iID >= 0 && iID < MAX_CM_CONNECTIONS);
        MYDBGASSERT(m_pConnTable->Connections[iID].CmState != CM_CONNECTED);

        m_pConnTable->Connections[iID].CmState = CM_CONNECTED;
        m_pConnTable->Connections[iID].hDial = hDial;
        m_pConnTable->Connections[iID].hTunnel = hTunnel;
    }

    MYVERIFY(SUCCEEDED(UnlockTable()));

    return hrRet;
}

//+----------------------------------------------------------------------------
//
// Function:  CConnectionTable::SetDisconnecting
//
// Synopsis:  Set the state of the connection to CM_DISCONNECTING
//
// Arguments: LPCTSTR pszEntry - The name of the connection to be set.
//
// Returns:   HRESULT - Failure code or S_OK
//
// History:   nickball    Created    2/2/98
//
//+----------------------------------------------------------------------------
HRESULT CConnectionTable::SetDisconnecting(LPCTSTR pszEntry)
{
    MYDBGASSERT(m_pConnTable);
    MYDBGASSERT(m_hMap);
    MYDBGASSERT(pszEntry);
    CMTRACE1(TEXT("CConnectionTable::Disconnecting(%s)"), pszEntry);

    if (NULL == m_pConnTable)
    {
        return E_ACCESSDENIED;
    }

    if (NULL == pszEntry)
    {
        return E_POINTER;
    }

    if (0 == pszEntry[0])
    {
        return E_INVALIDARG;
    }

    //
    // Lock the table and retrieve the entry
    //

    HRESULT hrRet = LockTable();

    if (FAILED(hrRet))
    {
        return hrRet;
    }

    int iID = -1;
    hrRet = FindEntry(pszEntry, &iID);

    //MYDBGASSERT(SUCCEEDED(hrRet));

    if (SUCCEEDED(hrRet))
    {
        //
        // Found, set the state
        //

        MYDBGASSERT(iID >= 0 && iID < MAX_CM_CONNECTIONS);
        m_pConnTable->Connections[iID].CmState = CM_DISCONNECTING;
    }

    MYVERIFY(SUCCEEDED(UnlockTable()));

    return hrRet;
}

//+----------------------------------------------------------------------------
//
// Function:  SetPrompting
//
// Synopsis:  Set the state of the connection to CM_RECONNECTPROMPT
//
// Arguments: LPCTSTR pszEntry - The name of the connection to be set.
//
// Returns:   HRESULT - Failure code or S_OK
//
// History:   nickball    Created    2/2/98
//
//+----------------------------------------------------------------------------
HRESULT CConnectionTable::SetPrompting(LPCTSTR pszEntry)
{
    MYDBGASSERT(m_pConnTable);
    MYDBGASSERT(m_hMap);
    MYDBGASSERT(pszEntry);
    CMTRACE1(TEXT("CConnectionTable::SetPrompting(%s)"), pszEntry);

    if (NULL == m_pConnTable)
    {
        return E_ACCESSDENIED;
    }

    if (NULL == pszEntry)
    {
        return E_POINTER;
    }

    if (0 == pszEntry[0])
    {
        return E_INVALIDARG;
    }

    //
    // Lock the table and retrieve the entry
    //

    HRESULT hrRet = LockTable();

    if (FAILED(hrRet))
    {
        return hrRet;
    }

    int iID = -1;
    hrRet = FindEntry(pszEntry, &iID);

    //MYDBGASSERT(SUCCEEDED(hrRet));

    if (SUCCEEDED(hrRet))
    {
        //
        // Found, set the state
        //

        MYDBGASSERT(iID >= 0 && iID < MAX_CM_CONNECTIONS);
        m_pConnTable->Connections[iID].CmState = CM_RECONNECTPROMPT;
    }

    MYVERIFY(SUCCEEDED(UnlockTable()));

    return hrRet;
}


//+----------------------------------------------------------------------------
//
// Function:  CConnectionTable::ClearEntry
//
// Synopsis:  Clears the specified entry regardless of the usage count.
//
// Arguments: LPCTSTR pszEntry - The name of the entry to be cleared.
//
// Returns:   HRESULT - Failure code or S_OK
//
// History:   nickball    Created    2/2/98
//
//+----------------------------------------------------------------------------
HRESULT CConnectionTable::ClearEntry(LPCTSTR pszEntry)
{
    MYDBGASSERT(m_pConnTable);
    MYDBGASSERT(m_hMap);
    MYDBGASSERT(pszEntry);
    CMTRACE1(TEXT("CConnectionTable::ClearEntry(%s)"), pszEntry);

    if (NULL == m_pConnTable)
    {
        return E_ACCESSDENIED;
    }

    if (NULL == pszEntry)
    {
        return E_POINTER;
    }

    if (0 == pszEntry[0])
    {
        return E_INVALIDARG;
    }

    //
    // Lock the table and retrieve the entry
    //

    HRESULT hrRet = LockTable();

    if (FAILED(hrRet))
    {
        return hrRet;
    }

    int iID = -1;
    hrRet = FindEntry(pszEntry, &iID);

    if (SUCCEEDED(hrRet))
    {
        //
        // Found, clear it
        //

        MYDBGASSERT(iID >= 0 && iID < MAX_CM_CONNECTIONS);
        ZeroMemory(&m_pConnTable->Connections[iID], sizeof(CM_CONNECTION));
    }

    MYVERIFY(SUCCEEDED(UnlockTable()));

    return hrRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmdial\actlist.cpp ===
//+----------------------------------------------------------------------------
//
// File:     ActList.cpp     
//
// Module:   CMDIAL32.DLL
//
// Synopsis: Implement the two connect action list class
//           CAction and CActionList
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Author:   fengsun Created    11/14/97
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"
#include "ActList.h"
#include "stp_str.h"

//
//  Include the custom action parsing routine that CM and CMAK now share, HrParseCustomActionString
//
#include "parseca.cpp"

//
// Constructor and destructor
//

CActionList::CActionList()
{
    m_pActionList = NULL;
    m_nNum = 0;
    m_nSize = 0;
    m_pszType = NULL;
}

CActionList::~CActionList()
{
    for (UINT i = 0; i < m_nNum; i++)
    {
        delete m_pActionList[i];
    }

    CmFree(m_pActionList);
}


//+----------------------------------------------------------------------------
//
// Function:  CActionList::Add
//
// Synopsis:  Dynamic array function. Append the element at the end of the array
//            Grow the array if nessesary
//
// Arguments: CAction* pAction - element to be added
//
// Returns:   Nothing
//
// History:   Fengsun Created Header        11/14/97
//            tomkel  Fixed PREFIX issues   11/21/2000
//
//+----------------------------------------------------------------------------
void CActionList::Add(CAction* pAction)
{
    MYDBGASSERT(m_nNum <= m_nSize);
    MYDBGASSERT(m_nSize == 0 || m_pActionList!=NULL); // if (m_nSize!=0) ASSERT(m_pActionList!=NULL);

    m_nNum++;

    if (m_nNum > m_nSize)
    {
        //
        // Either there is not enough room OR m_pActionList is NULL (this 
        // is the first call to Add). Need to allocate memory
        //
        
        CAction** pNewList = (CAction**)CmMalloc((m_nSize + GROW_BY)*sizeof(CAction*));
        MYDBGASSERT(pNewList);

        if (m_pActionList && pNewList)
        {
            //
            // Memory was allocated and there is something to copy from m_pActionList 
            //
            CopyMemory(pNewList, m_pActionList, (m_nSize)*sizeof(CAction*));
        }

        if (pNewList)
        {
            //
            // Memory was allocated
            //
            CmFree(m_pActionList);
            m_pActionList = pNewList;
            m_nSize += GROW_BY; 
            
            //
            // Add the action
            //
            m_pActionList[m_nNum - 1] = pAction; 
        }
        else
        {
            //
            // Memory was not allocated, so Add did not happen
            // Need to decrement the number of items in list (m_nNum) 
            // since it was inceremented at the beginning.
            //
            m_nNum--;
        }
    }
    else
    {
        //
        // Just add the action to the end
        //
        m_pActionList[m_nNum - 1] = pAction; 
    }
}



//+----------------------------------------------------------------------------
//
// Function:  CActionList::GetAt
//
// Synopsis:  Dynamic array fuction.  Get the element at nIndex
//
// Arguments: UINT nIndex - 
//
// Returns:   inline CAction* - 
//
// History:   fengsun Created Header    11/14/97
//
//+----------------------------------------------------------------------------
inline CAction* CActionList::GetAt(UINT nIndex)
{
    MYDBGASSERT(nIndex<m_nNum);
    MYDBGASSERT(m_pActionList);
    MYDBGASSERT(m_nNum <= m_nSize);
    
    return m_pActionList[nIndex];
}


//+----------------------------------------------------------------------------
//
// Function:  CActionList::Append
//
// Synopsis:  Append new actions to the list from profile
//
// Arguments: const CIni* piniService - The service file containing actions information
//            LPCTSTR pszSection - The section name 
//
// Returns:   TRUE if an action was appended to the list
//
// History:   fengsun   Created Header    11/14/97
//            nickball  Removed current directory assumptions, and added piniProfile
//            nickball  Added Return code 03/22/99
//
//+----------------------------------------------------------------------------
BOOL CActionList::Append(const CIni* piniService, LPCTSTR pszSection) 
{
    MYDBGASSERT(piniService);
    
    BOOL bRet = FALSE;

    //
    // Read each of the entries and add to our list
    // Start from 0 till the first empty entry
    //

    for (DWORD dwIdx=0; ; dwIdx++) 
    {
        TCHAR szEntry[32]; // hold the entry name

        wsprintfU(szEntry, TEXT("%u"), dwIdx);
        LPTSTR pszCmd = piniService->GPPS(pszSection, szEntry); // Command line

        if (*pszCmd == TEXT('\0')) 
        {
            //
            // No more entries
            //
            CmFree(pszCmd);
            break;
        }

        //
        // Read the flag
        //
    
        UINT iFlag = 0;

        if (pszSection && pszSection[0])
        {
            wsprintfU(szEntry, c_pszCmEntryConactFlags, dwIdx); //0&Flags
            iFlag = (UINT)piniService->GPPI(pszSection, szEntry, 0);
        }

        //
        // Read the description
        //
        LPTSTR pszDescript = NULL;

        wsprintfU(szEntry, c_pszCmEntryConactDesc, dwIdx); //0&Description
        pszDescript = piniService->GPPS(pszSection, szEntry);

        //
        // CAction is responsible for releasing pszDescript
        //
        CAction* pAction = new CAction(pszCmd, iFlag, pszDescript);
        CmFree(pszCmd);
       
        if (pAction)
        {
            pAction->ConvertRelativePath(piniService);
            ASSERT_VALID(pAction);
            pAction->ExpandEnvironmentStringsInCommand();
            Add(pAction);
            bRet = TRUE;
        }
    }

    if (bRet)
    {
        m_pszType = pszSection;
    }
    
    return bRet;
}

//+----------------------------------------------------------------------------
//
// Function:  CActionList::RunAccordType
//
// Synopsis:  Run the action list according to the connection type
//
// Arguments: HWND hwndDlg - The parent window
//            _ArgsStruct *pArgs - 
//            BOOL fStatusMsgOnFailure - Whether to display a status message 
//                                       to the user in the event of failure
//            BOOL fOnError - are we running OnError connect action?
//
// Returns:   BOOL - FALSE, if some sync action failed to start or returns failed
//
// History:   Fengsun Created Header    12/5/97
//
//+----------------------------------------------------------------------------
BOOL CActionList::RunAccordType(HWND hwndDlg, _ArgsStruct *pArgs, BOOL fStatusMsgOnFailure, BOOL fOnError)
{
    //
    // Set the flag, so CM will not handle  WM_TIMER and RAS messages
    //
    pArgs->fIgnoreTimerRasMsg = TRUE;
    BOOL fRetValue = Run(hwndDlg, pArgs, FALSE, fStatusMsgOnFailure, fOnError);//fAddWatch = FALSE
    pArgs->fIgnoreTimerRasMsg = FALSE;

    return fRetValue;
}

//+----------------------------------------------------------------------------
//
// Function:  CActionList::Run
//
// Synopsis:  Run the action list
//
// Arguments: HWND hwndDlg - The parent window, which is diabled during the process
//            ArgsStruct *pArgs - 
//            BOOL fAddWatch - If true, will add the process as watch process, 
//            BOOL fStatusMsgOnFailure - Whether to display a status message 
//                                       to the user in the event of failure
//            BOOL fOnError - are we running OnError connect action?
//
// Returns:   BOOL - FALSE, if some sync action failed to start or returns failed
//
// History:   fengsun Created Header    11/14/97
//
//+----------------------------------------------------------------------------
BOOL CActionList::Run(HWND hwndDlg, ArgsStruct *pArgs, BOOL fAddWatch, BOOL fStatusMsgOnFailure, BOOL fOnError) 
{
    //
    // Disable the window, and enable it on return
    //
    
    CFreezeWindow FreezeWindow(hwndDlg);

    for (UINT i = 0; i < GetSize(); i++)
    {
        CAction* pAction = (CAction*)GetAt(i);
        
        DWORD dwLoadType = (DWORD)-1;
        ASSERT_VALID(pAction);
        MYDBGASSERT(m_pszType);

        //
        //  Lets check the flags value to see if this connect action should
        //  run for this type of connection.
        //
        if (FALSE == pAction->RunConnectActionForCurrentConnection(pArgs))
        {
            continue;
        }

        //
        // Replace %xxxx% with the value
        //
        pAction->ExpandMacros(pArgs);
        
        //
        //  Also expand any environment variables
        //  NOTE: the order (macros vs. env vars) is deliberate.  Macros get
        //        expanded first.
        //
        pAction->ExpandEnvironmentStringsInParams();

        //
        // Check to see if we can run the action @ this moment
        //

        if (FALSE == pAction->IsAllowed(pArgs, &dwLoadType))
        {
            //
            // If not allowed, log the fact that we didn't run this connect action
            // and then just skip it.
            //
            pArgs->Log.Log(CUSTOMACTION_NOT_ALLOWED, m_pszType, SAFE_LOG_ARG(pAction->GetDescription()), pAction->GetProgram());

            continue;
        }

        //
        //  If this customaction might bring up UI
        //
        if (pAction->HasUI())
        {
            //
            //  If we are in unattended mode, don't run any connect actions
            //
            if (pArgs->dwFlags & FL_UNATTENDED)
            {
                pArgs->Log.Log(CUSTOMACTION_NOT_ALLOWED, m_pszType, SAFE_LOG_ARG(pAction->GetDescription()), pAction->GetProgram());
                CMTRACE(TEXT("Run: skipped past a customaction because we are in unattended mode"));
                continue;
            }

            //
            //  Custom actions processed during a Fast User Switch can put up UI requiring
            //  user input, effectively blocking CM.
            //
            if (pArgs->fInFastUserSwitch)
            {
                CMASSERTMSG((CM_CREDS_GLOBAL != pArgs->dwCurrentCredentialType),
                            TEXT("CActionList::Run - in FUS disconnect, but connectoid has global creds!"));

                pArgs->Log.Log(CUSTOMACTION_NOT_ALLOWED, m_pszType, SAFE_LOG_ARG(pAction->GetDescription()), pAction->GetProgram());
                CMTRACE(TEXT("Run: skipped past a singleuser DLL connectaction because of FUS"));
                continue;
            }
        }

        if (pAction->IsDll())
        {
            DWORD dwActionRetValue=0; // the connect action return value, in COM format
            BOOL bLoadSucceed = FALSE; 
            
            if (hwndDlg)
            {
                //
                // Display description for DLL
                //
                if (pAction->GetDescription())
                {
                    LPTSTR lpszText = CmFmtMsg(g_hInst, IDMSG_CONN_ACTION_RUNNING, pAction->GetDescription());
                    //
                    // Update the main dialog status window
                    //
                    SetDlgItemTextU(hwndDlg, IDC_MAIN_STATUS_DISPLAY, lpszText); 
                    CmFree(lpszText);
                }
            }
           
            bLoadSucceed = pAction->RunAsDll(hwndDlg, dwActionRetValue, dwLoadType);

            if (bLoadSucceed)
            {
                pArgs->Log.Log(CUSTOMACTIONDLL, m_pszType, SAFE_LOG_ARG(pAction->GetDescription()),
                               pAction->GetProgram(), dwActionRetValue);
            }
            else
            {
                pArgs->Log.Log(CUSTOMACTION_WONT_RUN, m_pszType, SAFE_LOG_ARG(pAction->GetDescription()),
                               pAction->GetProgram());
            }

            //
            // Failed to start the action, or the action returned failure
            //
            
            if (FAILED(dwActionRetValue) || !bLoadSucceed)
            {
                LPTSTR lpszText = NULL;

                if (fStatusMsgOnFailure && 
                    hwndDlg &&
                    pAction->GetDescription())
                {
                    if (bLoadSucceed)
                    {
                        lpszText = CmFmtMsg(g_hInst, IDMSG_CONN_ACTION_FAILED, 
                            pAction->GetDescription(), dwActionRetValue);
                    }
                    else
                    {
                        lpszText = CmFmtMsg(g_hInst, IDMSG_CONN_ACTION_NOTFOUND, 
                            pAction->GetDescription());
                    }
                    //
                    // Update the main dialog status window
                    //
                    SetDlgItemTextU(hwndDlg, IDC_MAIN_STATUS_DISPLAY, lpszText); 
                }

                if (!fOnError)
                {
                    if (bLoadSucceed)
                    {
                        pArgs->dwExitCode = dwActionRetValue;
                    }
                    else
                    {
                        pArgs->dwExitCode = ERROR_DLL_NOT_FOUND;
                    }

                    lstrcpynU(pArgs->szLastErrorSrc, pAction->GetDescription(), MAX_LASTERR_LEN);

                    pArgs->Log.Log(ONERROR_EVENT, pArgs->dwExitCode, pArgs->szLastErrorSrc);
                    
                    //
                    // We'll run On-Error connect actions if we are not already running OnError
                    // connect action.  This is to prevent infinite loops.
                    //
                    CActionList OnErrorActList;
                    OnErrorActList.Append(pArgs->piniService, c_pszCmSectionOnError);
                
                    //
                    // fStatusMsgOnFailure = FALSE
                    //
                    OnErrorActList.RunAccordType(hwndDlg, pArgs, FALSE, TRUE);
                }

                if (lpszText)
                {
                    //
                    // restore the failure msg of the previous connect action
                    //
                    SetDlgItemTextU(hwndDlg, IDC_MAIN_STATUS_DISPLAY, lpszText); 
                    CmFree(lpszText);
                }

                //
                // Note that if a DLL connect action fails, we will stop processing connect actions.
                // If the fStatusMsgOnFailure flag is set, then we won't show an error message
                // but connect action processing will still halt (we do this in cases where the user
                // isn't going to care such as oncancel actions, onerror actions, and cases where
                // disconnect action fail).
                //

                return FALSE;
            }
        }
        else
        {
            HANDLE  hProcess = NULL;;
            TCHAR   szDesktopName[MAX_PATH];
            TCHAR   szWinDesktop[MAX_PATH];

            if (IsLogonAsSystem())
            {
                DWORD   cb;
                HDESK   hDesk = GetThreadDesktop(GetCurrentThreadId());

                //
                // Get the name of the desktop. Normally returns default or Winlogon or system or WinNT
                // On Win95/98 GetUserObjectInformation is not supported and thus the desktop name
                // will be empty so we will use the good old API
                //  
                szDesktopName[0] = 0;
                
                if (GetUserObjectInformation(hDesk, UOI_NAME, szDesktopName, sizeof(szDesktopName), &cb))
                {
                    lstrcpyU(szWinDesktop, TEXT("Winsta0\\"));
                    lstrcatU(szWinDesktop, szDesktopName);
                
                    CMTRACE1(TEXT("CActionList::Run - Desktop = %s"), MYDBGSTR(szWinDesktop));
                
                    hProcess = pAction->RunAsExeFromSystem(&pArgs->m_ShellDll, szWinDesktop, dwLoadType);

                    if (NULL != hProcess)
                    {
                        pArgs->Log.Log(CUSTOMACTIONEXE, m_pszType, SAFE_LOG_ARG(pAction->GetDescription()), pAction->GetProgram());
                    }
                    else
                    {
                        pArgs->Log.Log(CUSTOMACTION_WONT_RUN, m_pszType, SAFE_LOG_ARG(pAction->GetDescription()), pAction->GetProgram());
                    }
                }
                else
                {
                    //
                    // Don't run action if we don't have desktop
                    //

                    CMTRACE1(TEXT("CActionList::Run/GetUserObjectInformation failed, GLE=%u"), GetLastError());
                    continue;
                }

            }
            else
            {
                hProcess = pAction->RunAsExe(&pArgs->m_ShellDll);

                if (NULL != hProcess)
                {
                    pArgs->Log.Log(CUSTOMACTIONEXE, m_pszType, SAFE_LOG_ARG(pAction->GetDescription()), pAction->GetProgram());
                }
                else
                {
                    pArgs->Log.Log(CUSTOMACTION_WONT_RUN, m_pszType, SAFE_LOG_ARG(pAction->GetDescription()), pAction->GetProgram());
                }
            }

            if (hProcess)
            {
                if (fAddWatch) 
                {
                    AddWatchProcess(pArgs,hProcess); // watch for process termination
                }
                else 
                {
                    CloseHandle(hProcess);
                }
            }
        }
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:  CAction::ParseCmdLine
//
// Synopsis:  This function parses the given command line into the program,
//            dll function name (if required), and the parameters (if any).
//            The individual command line parts are stored in member vars.
//
// Arguments: LPTSTR pszCmdLine - connect action command line to parse
//
// Returns:   Nothing
//
// History:   quintinb original code in Profwiz.cpp ReadConList()
//            fengsun copied and modified   4/16/98
//            quintinb  Rewrote and commonized with the Profwiz version 04/21/00
//
//+----------------------------------------------------------------------------
void CAction::ParseCmdLine(LPTSTR pszCmdLine)
{
    m_pszFunction = m_pszProgram = m_pszParams = NULL;

    CmStrTrim(pszCmdLine);

    HRESULT hr = HrParseCustomActionString(pszCmdLine, &m_pszProgram, &m_pszParams, &m_pszFunction);

    MYDBGASSERT(SUCCEEDED(hr));

    if (NULL == m_pszProgram)
    {
        MYDBGASSERT(FALSE); // we should never have a NULL program
        m_pszProgram = CmStrCpyAlloc(TEXT(""));        
    }

    if (NULL == m_pszParams)
    {
        m_pszParams = CmStrCpyAlloc(TEXT(""));
    }

    if (NULL == m_pszFunction)
    {
        m_pszFunction = CmStrCpyAlloc(TEXT(""));
    }

    //
    //  If we have a function, then the program was a Dll
    //
    m_fIsDll = (m_pszFunction && (TEXT('\0') != m_pszFunction[0]));
}

//+----------------------------------------------------------------------------
//
// Function:  CAction::CAction
//
// Synopsis:  Constructor
//
// Arguments: LPTSTR lpCommandLine - The command read from the profile
//                                    CAction is responsible to free it
//            UINT dwFlags - The flags read from the profile
//            LPTSTR lpDescript - The description of the connect action read from
//                      profile.  CAction is responsible to free it.
//
// Returns:   Nothing
//
// History:   fengsun Created Header    4/15/98
//
//+----------------------------------------------------------------------------
CAction::CAction(LPTSTR lpCommandLine, UINT dwFlags, LPTSTR lpDescript) 
{
    m_dwFlags = dwFlags;
    m_pszDescription = lpDescript;

    //
    // Get all information from command line, including 
    // Program name, function name, parameters
    //
    ParseCmdLine(lpCommandLine);

    //
    // If this is a DLL, but there is no description, use the name of the file
    // Can not use C Run Time routine _tsplitpath()
    //

    if (m_fIsDll && (m_pszDescription == NULL || m_pszDescription[0]==TEXT('\0')))
    {
        //
        // Find the last '\\' to get only the file name
        //
        LPTSTR pszTmp = CmStrrchr(m_pszProgram, '\\');
        if (pszTmp == NULL)
        {
            pszTmp = m_pszProgram;
        }
        else
        {
            pszTmp++;
        }

        CmFree(m_pszDescription);
        m_pszDescription = CmStrCpyAlloc(pszTmp);
    }
}

CAction::~CAction() 
{
    CmFree(m_pszProgram); 
    CmFree(m_pszParams);
    CmFree(m_pszFunction);
    CmFree(m_pszDescription);
}

//+----------------------------------------------------------------------------
//
// Function:  CAction::RunAsDll
//
// Synopsis:  Run the action as a Dll
//            Format is: DllName.dll FunctionName Argument
//                      Long file name is enclosed by '+'
//
// Arguments: HWND hwndDlg          - The parent window
//            DWORD& dwReturnValue  - The return value of the dll fuction
//            DWORD dwLoadType      - The permitted load location 
//
// Returns:   BOOL - TRUE, if the action is a Dll
//
// History:   fengsun Created Header    11/14/97
//
//+----------------------------------------------------------------------------
BOOL CAction::RunAsDll(HWND hwndDlg, OUT DWORD& dwReturnValue, DWORD dwLoadType) const
{
    MYDBGASSERT(IsDll());

    dwReturnValue = FALSE;

    LPWSTR pszwModuleName = NULL;

    //
    // Determine the module name to be used
    //

    if (!GetLoadDirWithAlloc(dwLoadType, &pszwModuleName))
    {
        CMASSERTMSG(FALSE, TEXT("CAction::RunAsDll -- GetLoadDirWithAlloc Failed."));
        CmFree(pszwModuleName);
        return FALSE;
    }
    
    //
    // Load the module
    //

    HINSTANCE hLibrary = LoadLibraryExU(pszwModuleName, NULL, 0);

    if (NULL == hLibrary)
    {
        CMTRACE2(TEXT("RunAsDll() LoadLibrary(%s) failed, GLE=%u."),
                 MYDBGSTR(pszwModuleName), GetLastError());
        
        CmFree(pszwModuleName);
        return FALSE;
    }

    pfnCmConnectActionFunc pfnFunc;
    LPSTR pszFunctionName = NULL;
    LPSTR pszParams = NULL;

#ifdef UNICODE
    pszFunctionName = WzToSzWithAlloc(m_pszFunction);
#else
    pszFunctionName = m_pszFunction;
#endif

    //
    //  Get the Procedure Address
    //
    pfnFunc = (pfnCmConnectActionFunc)GetProcAddress(hLibrary, pszFunctionName);

#ifdef UNICODE
    CmFree(pszFunctionName);
#endif


    if (pfnFunc) 
    {
#if !defined (DEBUG)
        __try 
        {
#endif

#ifdef UNICODE
    pszParams = WzToSzWithAlloc(m_pszParams);
#else
    pszParams = m_pszParams;
#endif

        //
        //  Execute the Function
        //
        dwReturnValue = pfnFunc(hwndDlg, hLibrary, pszParams, SW_SHOW);

#ifdef UNICODE
        CmFree(pszParams);
#endif
        
        CMTRACE1(TEXT("RunAsDll() Executed module: %s"), MYDBGSTR(pszwModuleName));
        CMTRACE1(TEXT("\tFunction:  %s"), MYDBGSTR(m_pszFunction));
        CMTRACE1(TEXT("\tParams:  %s"), MYDBGSTR(m_pszParams));
        CMTRACE1(TEXT("\t Return Value:  %u"), dwReturnValue);

#if !defined (DEBUG)
        }
        __except(EXCEPTION_EXECUTE_HANDLER) 
        {   
        }
#endif
    }
    else
    {
        dwReturnValue = HRESULT_FROM_WIN32(ERROR_INVALID_FUNCTION);

        CMTRACE3(TEXT("RunAsDll() GetProcAddress(*pszwModuleName=%s,*m_pszFunction=%s) failed, GLE=%u."), 
            MYDBGSTR(pszwModuleName), MYDBGSTR(m_pszFunction), GetLastError());
    }

    CmFree(pszwModuleName);
    FreeLibrary(hLibrary);

    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:  CAction::RunAsExe
//
// Synopsis:  Run the action as an exe or other shell object
//
// Arguments: CShellDll* pShellDll, pointer to the link to shell32.dll
//
// Returns:   HANDLE - The action Process handle, for Win32 only
//
// History:   fengsun Created Header    11/14/97
//
//+----------------------------------------------------------------------------
HANDLE CAction::RunAsExe(CShellDll* pShellDll) const
{
    // Now we have the exe name and args separated, execute it
    
    SHELLEXECUTEINFO seiInfo;

    ZeroMemory(&seiInfo,sizeof(seiInfo));
    seiInfo.cbSize = sizeof(seiInfo);
    seiInfo.fMask |= SEE_MASK_FLAG_NO_UI | SEE_MASK_NOCLOSEPROCESS;
    seiInfo.lpFile = m_pszProgram;
    seiInfo.lpParameters = m_pszParams;
    seiInfo.nShow = SW_SHOW;

    MYDBGASSERT(pShellDll);

    if (!pShellDll->ExecuteEx(&seiInfo))
    {
        CMTRACE3(TEXT("RunAsExe() ShellExecuteEx() of %s %s GLE=%u."), 
            MYDBGSTR(m_pszProgram), MYDBGSTR(m_pszParams), GetLastError());

        return NULL;
    }

    return seiInfo.hProcess;
}

//+----------------------------------------------------------------------------
//
// Function:  CAction::GetLoadDirWithAlloc
//
// Synopsis:  Uses the dwLoadType parameter to decide how the path should be
//            modified.  This is used in the WinLogon context to prevent just
//            any executable from being executed.  Must be from the profile dir
//            or the system dir.
//
// Arguments: DWORD dwLoadType - Load type, currently 0 == system dir, 1 == profile dir (default)
//            LPWSTR pszwPath - string buffer to put the modified path in
//
// Returns:   BOOL - TRUE if successful
//
// History:   quintinb      Created                 01/11/2000
//            sumitc        Change to alloc retval  05/08/2000
//
//+----------------------------------------------------------------------------
BOOL CAction::GetLoadDirWithAlloc(IN DWORD dwLoadType, OUT LPWSTR * ppszwPath) const
{
    LPWSTR  psz = NULL;
    UINT    cch = 0;
    
    //
    //  Check that we have an output buffer
    //
    if (NULL == ppszwPath)
    {
        return FALSE;
    }

    //
    //  Compute how much space we need
    //
    if (dwLoadType)
    {
        // 1 = profile dir
        cch += lstrlen(m_pszProgram) + 1;
    }
    else
    {
        // 0 = system dir
        cch = GetSystemDirectoryU(NULL, 0);
        cch += lstrlen(TEXT("\\"));
        cch += lstrlen(m_pszProgram) + 1;   // is the +1 already in the GetSystemDir retval?
    }

    //
    //  Allocate it
    //
    psz = (LPWSTR) CmMalloc(sizeof(TCHAR) * cch);
    if (NULL == psz)
    {
        return FALSE;
    }

    //
    //  Process the load type
    //
    if (dwLoadType)
    {
        //
        // If relative path, this will already be expanded.
        //

        lstrcpyU(psz, m_pszProgram);
    }
    else
    {
        //
        //  Force the system directory
        //
        if (0 == GetSystemDirectoryU(psz, cch))
        {
            CmFree(psz);
            return FALSE;
        }

        lstrcatU(psz, TEXT("\\"));
        lstrcatU(psz, m_pszProgram);
    }

    *ppszwPath = psz;
    
    return TRUE;    
}

//+----------------------------------------------------------------------------
//
// Function:  CAction::RunAsExeFromSystem
//
// Synopsis:  Run the action as an exe or other shell object on the choosen desktop
//
// Arguments: CShellDll* pShellDll  - pointer to the link to shell32.dll
//            LPTSTR pszDesktop     - name of the desktop to execute the exe on
//            DWORD dwLoadType      - location from which to load the exe
//
// Returns:   HANDLE - The action Process handle, for Win32 only
//
// History:   v-vijayb          Created                 07/19/99
//            nickball          Removed fSecurity       07/27/99
//
//+----------------------------------------------------------------------------
HANDLE CAction::RunAsExeFromSystem(CShellDll* pShellDll, LPTSTR pszDesktop, DWORD dwLoadType)
{
    STARTUPINFO         StartupInfo = {0};
    PROCESS_INFORMATION ProcessInfo = {0};
    LPWSTR              pszwFullPath = NULL;
    LPWSTR              pszwCommandLine = NULL;

    MYDBGASSERT(OS_NT); 

    StartupInfo.cb = sizeof(StartupInfo);
    if (pszDesktop)
    {
        StartupInfo.lpDesktop = pszDesktop;
        StartupInfo.wShowWindow = SW_SHOW;
    }

    //
    // Use an explicit path to the modules to be launched, this
    // prevents CreateProcess from picking something up on the path.
    //
    if (!GetLoadDirWithAlloc(dwLoadType, &pszwFullPath))
    {
        CMASSERTMSG(FALSE, TEXT("CAction::RunAsExeFromSystem -- GetLoadDirWithAlloc Failed."));
        goto Cleanup;
    }

    pszwCommandLine = CmStrCpyAlloc(m_pszProgram);
    if (NULL == pszwCommandLine)
    {
        CMASSERTMSG(FALSE, TEXT("CAction::RunAsExeFromSystem -- CmStrCpyAlloc Failed."));
        goto Cleanup;
    }

    //
    // Add parameters
    //

    if (NULL == CmStrCatAlloc(&pszwCommandLine, TEXT(" ")))
    {
        goto Cleanup;
    }

    if (NULL == CmStrCatAlloc(&pszwCommandLine, m_pszParams))
    {
        goto Cleanup;
    }

    CMTRACE1(TEXT("RunAsExeFromSystem/CreateProcess() - Launching %s"), pszwCommandLine);

    //
    // Launch the modules
    //
    
    if (NULL == CreateProcess(pszwFullPath, pszwCommandLine,
                              NULL, NULL, FALSE, 0,
                              NULL, NULL,
                              &StartupInfo, &ProcessInfo))
    {
        CMTRACE2(TEXT("RunAsExeFromSystem() CreateProcess() of %s failed, GLE=%u."), pszwCommandLine, GetLastError());
        
        ProcessInfo.hProcess = NULL;
    }

Cleanup:
    CmFree(pszwFullPath);
    CmFree(pszwCommandLine);

    return ProcessInfo.hProcess;
}

//+----------------------------------------------------------------------------
//
// Function:  CAction::ExpandMacros
//
// Synopsis:  Replace the %xxxxx% in command line with the corresponding value
//
// Arguments: ArgsStruct *pArgs - 
//
// Returns:   Nothing
//
// History:   fengsun Created Header    11/14/97
//
//+----------------------------------------------------------------------------
void CAction::ExpandMacros(ArgsStruct *pArgs) 
{
    MYDBGASSERT(pArgs);

    LPTSTR pszCurr = m_pszParams;
    BOOL bValidPropertyName;

    while (*pszCurr) 
    {
        if (*pszCurr == TEXT('%'))
        {
            LPTSTR pszNextPercent = CmStrchr(pszCurr + 1, TEXT('%'));
            if (pszNextPercent) 
            {
                LPTSTR pszTmp = (LPTSTR) CmMalloc((DWORD)((pszNextPercent-pszCurr))*sizeof(TCHAR));
                if (pszTmp)
                {
                    CopyMemory(pszTmp,pszCurr+1,(pszNextPercent-pszCurr-1)*sizeof(TCHAR));

                    //
                    // Get the value from name
                    //
                    LPTSTR pszMid = pArgs->GetProperty(pszTmp, &bValidPropertyName);  

                    //
                    // If the property does not exist, use "NULL"
                    //
                    if (pszMid == NULL)
                    {
                        pszMid = CmStrCpyAlloc(TEXT("NULL"));
                    }
                    else if (pszMid[0] == TEXT('\0'))
                    {
                        CmFree(pszMid);
                        pszMid = CmStrCpyAlloc(TEXT("NULL"));
                    }
                    else if ( (lstrcmpiU(pszTmp,TEXT("Profile")) == 0) || 
                        CmStrchr(pszMid, TEXT(' ')) != NULL)
                    {
                        //
                        // If the name is %Profile% or the value has a space in it,
                        // Put the string in double quote
                        //
                        LPTSTR pszValueInQuote = (LPTSTR)CmMalloc((lstrlenU(pszMid)+3)*sizeof(pszMid[0]));
                        if (pszValueInQuote)
                        {
                            lstrcpyU(pszValueInQuote, TEXT("\""));
                            lstrcatU(pszValueInQuote, pszMid);
                            lstrcatU(pszValueInQuote, TEXT("\""));

                            CmFree(pszMid);
                            pszMid = pszValueInQuote;
                        }
                        else
                        {
                            CMTRACE1(TEXT("ExpandMacros() malloc failed, can't put string in double quotes, GLE=%u."), GetLastError());
                        }
                    }

                    // 
                    // if bValidPropertyName is FALSE then leave untouched.
                    // 

                    if (FALSE == bValidPropertyName)
                    {
                        pszCurr = pszNextPercent + 1;
                    }
                    else
                    {
                        //
                        // Replace %xxxx% with the value
                        //
                        DWORD dwLenPre = (DWORD)(pszCurr - m_pszParams);
                        DWORD dwLenMid = lstrlenU(pszMid);
                        DWORD dwLenPost = lstrlenU(pszNextPercent+1);
                        CmFree(pszTmp);
                        pszTmp = m_pszParams;
                        m_pszParams = (LPTSTR) CmMalloc((dwLenPre + dwLenMid + dwLenPost + 1)*sizeof(TCHAR));
                        if (m_pszParams)
                        {
                            CopyMemory(m_pszParams, pszTmp, dwLenPre*sizeof(TCHAR));  // before %
                            lstrcatU(m_pszParams, pszMid);       //append value
                            lstrcatU(m_pszParams, pszNextPercent+1); // after %
                            pszCurr = m_pszParams + dwLenPre + dwLenMid;                
                        }
                        else
                        {
                            // we're out of memory
                            CMTRACE1(TEXT("ExpandMacros() malloc failed, can't strip off %% signs, GLE=%u."), GetLastError());
                            m_pszParams = pszTmp;
                        }
                    }
                    CmFree(pszMid);
                }
                CmFree(pszTmp);
            }
            else
            {
                pszCurr++;            
            }
        }
        else
        {
            pszCurr++;
        }
    }
}

#ifdef DEBUG
//+----------------------------------------------------------------------------
//
// Function:  CAction::AssertValid
//
// Synopsis:  For debug purpose only, assert the connection object is valid
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   Created Header    2/12/98
//
//+----------------------------------------------------------------------------
void CAction::AssertValid() const
{
    MYDBGASSERT(m_pszProgram && m_pszProgram[0]);
    MYDBGASSERT(m_fIsDll == TRUE  || m_fIsDll == FALSE);
}
#endif


//+----------------------------------------------------------------------------
//
// Function:  CAction::ExpandEnvironmentStrings
//
// Synopsis:  Utility fn to expand environment variables in the given string
//
// Arguments: ppsz - ptr to string (usually member variable)
//
// Returns:   Nothing
//
// History:   SumitC    Created     29-Feb-2000
//
//+----------------------------------------------------------------------------
void CAction::ExpandEnvironmentStrings(LPTSTR * ppsz)
{
    DWORD cLen;

    MYDBGASSERT(*ppsz);

    //
    //  find out how much memory we need to allocate
    //
    cLen = ExpandEnvironmentStringsU(*ppsz, NULL, 0);

    if (cLen)
    {
        LPTSTR pszTemp = (LPTSTR) CmMalloc((cLen + 1) * sizeof(TCHAR));
 
        if (pszTemp)
        {
            DWORD cLen2 = ExpandEnvironmentStringsU(*ppsz, pszTemp, cLen);
            MYDBGASSERT(cLen == cLen2);

            if (cLen2)
            {
                CmFree(*ppsz);
                *ppsz = pszTemp;
            }
        }
    }
}


//+----------------------------------------------------------------------------
//
// Function:  CAction::IsAllowed
//
// Synopsis:  checks Registry to see if a command is allowed to run
//
// Arguments: _ArgsStruct *pArgs    - Ptr to global args struct
//            LPDWORD lpdwLoadType  - Ptr to DWORD to be filled with load type
//
// Returns:   TRUE if action is allowed @ this time
//
// Notes:     Checks SOFTWARE\Microsoft\Connection Manager\<ServiceName>
//             Under which you will have the Values for each command
//              0 - system32 directory
//              1 - profile directory
// History:   v-vijayb    Created Header    7/20/99
//
//+----------------------------------------------------------------------------
BOOL CAction::IsAllowed(_ArgsStruct *pArgs, LPDWORD lpdwLoadType)
{
    return IsActionEnabled(m_pszProgram, pArgs->szServiceName, pArgs->piniService->GetFile(), lpdwLoadType);
}

//+----------------------------------------------------------------------------
//
// Function:  CAction::RunConnectActionForCurrentConnection
//
// Synopsis:  This function compares the flags value of the connect action
//            with the current connection type (from pArgs->GetTypeOfConnection).
//            It returns TRUE if the connect action should be run for this type
//            and FALSE if the connect action should be skipped.
//
// Arguments: _ArgsStruct *pArgs    - Ptr to global args struct
//
// Returns:   TRUE if action should be executed
//
// History:   quintinb    Created       04/20/00
//
//+----------------------------------------------------------------------------
BOOL CAction::RunConnectActionForCurrentConnection(_ArgsStruct *pArgs)
{
    BOOL bReturn = TRUE;
    DWORD dwType = pArgs->GetTypeOfConnection();

    if (DIAL_UP_CONNECTION == dwType)
    {
        //
        //  Don't run direct only or tunnel connect actions
        //  on a dialup connection.
        //
        if ((m_dwFlags & DIRECT_ONLY) || (m_dwFlags & ALL_TUNNEL))
        {
            bReturn = FALSE;
        }
    }
    else if (DIRECT_CONNECTION == dwType)
    {
        //
        //  Don't run dialup only or dialup connect actions
        //  on a direct connection.
        //
        if ((m_dwFlags & DIALUP_ONLY) || (m_dwFlags & ALL_DIALUP))
        {
            bReturn = FALSE;
        }
    }
    else if (DOUBLE_DIAL_CONNECTION == dwType)
    {
        //
        //  Don't run dialup only or dialup connect actions
        //  on a direct connection.
        //
        if ((m_dwFlags & DIALUP_ONLY) || (m_dwFlags & DIRECT_ONLY))
        {
            bReturn = FALSE;
        }        
    }
    else
    {
        CMASSERTMSG(FALSE, TEXT("CActionList::Run -- unknown connection type, skipping action"));
        bReturn = FALSE;
    }

    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmdial\ary.cxx ===
//+----------------------------------------------------------------------------
//
// File:	 ary.cxx
//
// Module:	 CMDIAL32.DLL
//
// Synopsis: Generic dynamic array class -- CFormsAry
//
// Copyright (c) 1992-1998 Microsoft Corporation
//
// Author:	 quintinb    Created Header   8/17/99
//
//+----------------------------------------------------------------------------
#include "cmmaster.h"
#include "cm_misc.h"
#include "ary.hxx"

#define CFORMSARY_MAXELEMSIZE    128

//  CFormsAry class
//
//


//+------------------------------------------------------------------------
//
//  Member: CFormsAry::~CFormsAry
//
//  Synopsis:   Resizeable array destructor. Frees storage allocated for the
//      array.
//
//-------------------------------------------------------------------------
CFormsAry::~CFormsAry( )
{
    MemFree(PData());
}


//+------------------------------------------------------------------------
//
//  Member: CFormsAry::EnsureSize
//
//  Synopsis:   Ensures that the array is at least the given size. That is,
//      if EnsureSize(c) succeeds, then (c-1) is a valid index. Note
//      that the array maintains a separate count of the number of
//      elements logically in the array, which is obtained with the
//      Size/SetSize methods. The logical size of the array is never
//      larger than the allocated size of the array.
//
//  Arguments:  cb    Element size
//              c     New allocated size for the array.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
CFormsAry::EnsureSize(size_t cb, int c)
{
    HRESULT hr;
    unsigned cbAlloc = ((c + 7) & ~7) * cb;

    MYDBGASSERT(c >= 0);

    if (c > ((_c + 7) & ~7) && cbAlloc > MemGetSize(PData()))
    {
        hr = MemRealloc((void **)&PData(), cbAlloc);
    }
    else
    {
        hr = S_OK;
    }

    return hr;
}


//+------------------------------------------------------------------------
//
//  Member: CFormsAry::AppendIndirect
//
//  Synopsis:   Appends the given element to the end of the array, incrementing
//      the array's logical size, and growing the array's allocated
//      size if necessary.  Note that the element is passed with a
//      pointer, rather than directly.
//
//  Arguments:  cb  Element size
//              pv  Pointer to the element to be appended
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
CFormsAry::AppendIndirect(size_t cb, void * pv)
{
    HRESULT hr;

    hr = EnsureSize(cb, _c + 1);
    if (hr)
        return hr;

    memcpy(Deref(cb, _c), pv, cb);
    _c++;

    return NOERROR;
}

#if 0
/*

//+------------------------------------------------------------------------
//
//  Member: CFormsAry::Delete
//
//  Synopsis:   Removes the i'th element of the array, shuffling all
//              elements that follow one slot towards the beginning of the
//              array.
//
//  Arguments:  cb  Element size
//              i   Element to delete
//
//-------------------------------------------------------------------------
void
CFormsAry::Delete(size_t cb, int i)
{
    MYDBGASSERT(i >= 0);
    MYDBGASSERT(i < _c);

    memmove(((BYTE *) PData()) + (i * cb),
            ((BYTE *) PData()) + ((i + 1) * cb),
            (_c - i - 1) * cb);

    _c--;
}

//+------------------------------------------------------------------------
//
//  Member: CFormsAry::DeleteByValueIndirect
//
//  Synopsis:   Removes the element matching the given value.
//
//  Arguments:  cb  Element size
//              pv  Element to delete
//
//  Returuns:   True if found & deleted.
//
//-------------------------------------------------------------------------
BOOL
CFormsAry::DeleteByValueIndirect(size_t cb, void *pv)
{
    int i = FindIndirect(cb, pv);
    if (i >= 0)
    {
        Delete(cb, i);
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


//+------------------------------------------------------------------------
//
//  Member: CFormsAry::DeleteMultiple
//
//  Synopsis:   Removes a range of elements of the array, shuffling all
//              elements that follow the last element being deleted slot
//              towards the beginning of the array.
//
//  Arguments:  cb    Element size
//              start First element to delete
//              end   Last element to delete
//
//-------------------------------------------------------------------------
void
CFormsAry::DeleteMultiple(size_t cb, int start, int end)
{
    MYDBGASSERT((start >= 0) && (end >= 0));
    MYDBGASSERT((start < _c) && (end < _c));
    MYDBGASSERT(end >= start);

    if (end < (_c - 1))
    {
        memmove(((BYTE *) PData()) + (start * cb),
                ((BYTE *) PData()) + ((end + 1) * cb),
                (_c - end - 1) * cb);
    }

    _c -= (end - start) + 1;
}

//+------------------------------------------------------------------------
//
//  Member: CFormsAry::DeleteAll
//
//  Synopsis:   Efficient method for emptying array of any contents
//
//-------------------------------------------------------------------------
void
CFormsAry::DeleteAll(void)
{
    MemFree(PData());
    PData() = NULL;
    _c = 0;
}


//+------------------------------------------------------------------------
//
//  Member: CFormsAry::InsertIndirect
//
//  Synopsis:   Inserts a pointer pv at index i. The element previously at
//      index i, and all elements that follow it, are shuffled one
//      slot away towards the end of the array.Note that the
//      clement is passed with a pointer, rather than directly.
//
//  Arguments:  cb    Element size
//              i     Index to insert...
//              pv        ...this pointer at
//
//-------------------------------------------------------------------------
HRESULT
CFormsAry::InsertIndirect(size_t cb, int i, void *pv)
{
    HRESULT hr;

    hr = EnsureSize(cb, _c + 1);
    if (hr)
        return hr;

    memmove(((BYTE *) PData()) + ((i + 1) * cb),
            ((BYTE *) PData()) + (i * cb),
            (_c - i ) * cb);

    memcpy(Deref(cb, i), pv, cb);
    _c++;
    return NOERROR;

}

//+------------------------------------------------------------------------
//
//  Member: CFormsAry::BringToFront
//
//  Synopsis:   Moves the i'th element to the front of the array, shuffling
//              intervening elements to make room.
//
//  Arguments:  i
//
//-------------------------------------------------------------------------
void
CFormsAry::BringToFront(size_t cb, int i)
{
    BYTE    rgb[CFORMSARY_MAXELEMSIZE];

    MYDBGASSERT(cb <= CFORMSARY_MAXELEMSIZE);

    memcpy(rgb, ((BYTE *) PData()) + (i * cb), cb);
    memmove(((BYTE *) PData()) + cb, PData(), i * cb);
    memcpy(PData(), rgb, cb);
}



//+------------------------------------------------------------------------
//
//  Member: CFormsAry::SendToBack
//
//  Synopsis:   Moves the i'th element to the back of the array (that is,
//      the largest index less than the logical size.) Any intervening
//      elements are shuffled out of the way.
//
//  Arguments:  i
//
//-------------------------------------------------------------------------
void
CFormsAry::SendToBack(size_t cb, int i)
{
    BYTE    rgb[CFORMSARY_MAXELEMSIZE];

    MYDBGASSERT(cb <= CFORMSARY_MAXELEMSIZE);

    memcpy(rgb, ((BYTE *) PData()) + (i * cb), cb);
    memmove(((BYTE *) PData()) + (i * cb),
            ((BYTE *) PData()) + ((i + 1) * cb),
            (_c - i - 1) * cb);

    memcpy(((BYTE *) PData()) + ((_c - 1) * cb), rgb, cb);
}


//+---------------------------------------------------------------------------
//
//  Member:     CFormsAry::Swap
//
//  Synopsis:   swap two members of array with each other.
//
//  Arguments:  cb  size of elements
//              i1  1st element
//              i2  2nd element
//----------------------------------------------------------------------------
void
CFormsAry::Swap(size_t cb, int i1, int i2)
{
    BYTE    rgb[CFORMSARY_MAXELEMSIZE];

    MYDBGASSERT(cb <= CFORMSARY_MAXELEMSIZE);

    if (i1 >= _c)
        i1 = _c - 1;
    if (i2 >= _c)
        i2 = _c - 1;

    if (i1 != i2)
    {
        memcpy(rgb, ((BYTE *) PData()) + (i1 * cb), cb);
        memcpy(((BYTE *) PData()) + (i1 * cb), ((BYTE *) PData()) + (i2 * cb), cb);
        memcpy(((BYTE *) PData()) + (i2 * cb), rgb, cb);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CFormsAry::FindIndirect
//
//  Synopsis:   Finds an element of a non-pointer array.
//
//  Arguments:  cb  The size of the element.
//              pv  Pointer to the element.
//
//  Returns:    The index of the element if found, otherwise -1.
//
//----------------------------------------------------------------------------

int
CFormsAry::FindIndirect(size_t cb, void * pv)
{
    int     i;
    void *  pvT;

    pvT = PData();
    for (i = _c; i > 0; i--)
    {
        if (!memcmp(pv, pvT, cb))
            return _c - i;

        pvT = (char *) pvT + cb;
    }

    return -1;
}



//+---------------------------------------------------------------------------
//
//  Member:     CFormsAry::CopyAppend
//
//  Synopsis:   Copies the entire contents of another CFormsAry object and
//              appends it to the end of the array.
//
//  Arguments:  ary     Object to copy.
//              fAddRef Addref the elements on copy?
//
//----------------------------------------------------------------------------

HRESULT
CFormsAry::CopyAppend(size_t cb, const CFormsAry& ary, BOOL fAddRef)
{
    return (CopyAppendIndirect(cb, ary._c, ((CFormsAry *)&ary)->PData(), fAddRef));
}


HRESULT
CFormsAry::CopyAppendIndirect(size_t cb, int c, void * pv, BOOL fAddRef)
{
    IUnknown ** ppUnk;                  // elem to addref

    if (EnsureSize(cb, _c + c))
        return E_OUTOFMEMORY;

    if (pv)
    {
        memcpy((BYTE*) PData() + (_c * cb), pv, c * cb);
    }

    _c += c;

    if (fAddRef)
    {
        for (ppUnk = (IUnknown **) pv; c > 0; c--, ppUnk++)
        {
            (*ppUnk)->AddRef();
        }
    }

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CFormsAry::Copy
//
//  Synopsis:   Creates a copy from another CFormsAry object.
//
//  Arguments:  ary     Object to copy.
//              fAddRef Addref the elements on copy?
//
//----------------------------------------------------------------------------

HRESULT
CFormsAry::Copy(size_t cb, const CFormsAry& ary, BOOL fAddRef)
{
    return (CopyIndirect(cb, ary._c, ((CFormsAry *)&ary)->PData(), fAddRef));
}



//+------------------------------------------------------------------------
//
//  Member:     CFormsAry::CopyIndirect
//
//  Synopsis:   Fills a forms array from a C-style array of raw data
//
//  Arguments:  [cb]
//              [c]
//              [pv]
//              [fAddRef]
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CFormsAry::CopyIndirect(size_t cb, int c, void * pv, BOOL fAddRef)
{
    size_t          cbArray;
    IUnknown **     ppUnk;

    if (pv == PData())
        return S_OK;

    DeleteAll();
    if (pv)
    {
        cbArray = c * cb;
        PData() = MemAlloc(cbArray);
        if (!PData())
            return E_OUTOFMEMORY;

        memcpy(PData(), pv, cbArray);
    }

    _c = c;

    if (fAddRef)
    {
        for (ppUnk = (IUnknown **) PData(); c > 0; c--, ppUnk++)
        {
            (*ppUnk)->AddRef();
        }
    }

    return S_OK;
}

HRESULT
CFormsPtrAry::ClearAndReset()
{
    //  why does this function reallocate memory, rather than
    //  just memset'ing to 0? (chrisz)

    PData() = NULL;
    HRESULT hr = EnsureSize(_c);
    _c = 0;

    return hr;
}

//+------------------------------------------------------------------------
//
//  Member:     CFormsPtrAry::*
//
//  Synopsis:   CFormsPtrAry elements are always of size four.
//              The following functions encode this knowledge.
//
//-------------------------------------------------------------------------

HRESULT
CFormsPtrAry::EnsureSize(int c)
{
    return CFormsAry::EnsureSize(sizeof(void *), c);
}

HRESULT
CFormsPtrAry::Append(void * pv)
{
    return CFormsAry::AppendIndirect(sizeof(void *), &pv);
}

HRESULT
CFormsPtrAry::Insert(int i, void * pv)
{
    return CFormsAry::InsertIndirect(sizeof(void *), i, &pv);
}

int
CFormsPtrAry::Find(void * pv)
{
    int     i;
    void ** ppv;

    for (i = 0, ppv = (void **) PData(); i < _c; i++, ppv++)
    {
        if (pv == *ppv)
            return i;
    }

    return -1;
}


void
CFormsPtrAry::Delete(int i)
{
    CFormsAry::Delete(sizeof(void *), i);
}

BOOL
CFormsPtrAry::DeleteByValue(void *pv)
{
    int i = Find(pv);
    if (i >= 0)
    {
        CFormsAry::Delete(sizeof(void *), i);
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

void
CFormsPtrAry::DeleteMultiple(int start, int end)
{
    CFormsAry::DeleteMultiple(sizeof(void*), start, end);
}

void
CFormsPtrAry::ReleaseAndDelete(int idx)
{
    IUnknown * pUnk;

    MYDBGASSERT(idx <= _c);

    // grab element at idx
    pUnk = ((IUnknown **) PData())[idx];
    if (pUnk)
        (pUnk)->Release();

    Delete(idx);
}


void
CFormsPtrAry::ReleaseAll(void)
{
    int         i;
    IUnknown ** ppUnk;

    for (i = 0, ppUnk = (IUnknown **) PData(); i < _c; i++, ppUnk++)
    {
        if (*ppUnk)
            (*ppUnk)->Release();
    }

    DeleteAll();
}

void
CFormsPtrAry::BringToFront(int i)
{
    CFormsAry::BringToFront(sizeof(void *), i);
}


void
CFormsPtrAry::SendToBack(int i)
{
    CFormsAry::SendToBack(sizeof(void *), i);
}

void
CFormsPtrAry::Swap(int i1, int i2)
{
    CFormsAry::Swap(sizeof(void *), i1, i2);
}


HRESULT
CFormsPtrAry::CopyAppendIndirect(int c, void * pv, BOOL fAddRef)
{
    return CFormsAry::CopyAppendIndirect(sizeof(void *), c, pv, fAddRef);
}

HRESULT
CFormsPtrAry::CopyAppend(const CFormsAry& ary, BOOL fAddRef)
{
    return CFormsAry::CopyAppend(sizeof(void *), ary, fAddRef);
}

HRESULT
CFormsPtrAry::CopyIndirect(int c, void * pv, BOOL fAddRef)
{
    return CFormsAry::CopyIndirect(sizeof(void *), c, pv, fAddRef);
}

HRESULT
CFormsPtrAry::Copy(const CFormsAry& ary, BOOL fAddRef)
{
    return CFormsAry::Copy(sizeof(void *), ary, fAddRef);
}

HRESULT
CFormsPtrAry::EnumElements(
        REFIID iid,
        void ** ppv,
        BOOL fAddRef,
        BOOL fCopy,
        BOOL fDelete)
{
    return CFormsAry::EnumElements(
            sizeof(void *),
            iid,
            ppv,
            fAddRef,
            fCopy,
            fDelete);
}

HRESULT
CFormsPtrAry::EnumVARIANT(
        VARTYPE vt,
        IEnumVARIANT ** ppenum,
        BOOL fCopy,
        BOOL fDelete)
{
    return CFormsAry::EnumVARIANT(
            sizeof(void *),
            vt,
            ppenum,
            fCopy,
            fDelete);
}
*/
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmdial\actlist.h ===
//+----------------------------------------------------------------------------
//
// File:     ActList.h
//
// Module:   CMDIAL32.DLL
//
// Synopsis: Define the two connect action list class
//           CAction and CActionList
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Author:   fengsun Created    11/14/97
//
//+----------------------------------------------------------------------------

#include <windows.h>
#include "cm_misc.h"
#include "conact_str.h"
#include "conact.h"

//
// Class used
//
class CIni;
class CAction;
struct _ArgsStruct;


//+---------------------------------------------------------------------------
//
//  class CActionList
//
//  Description: A list of CAction objects
//
//  History:    fengsun Created     11/14/97
//
//----------------------------------------------------------------------------
class CActionList
{
public:
    CActionList();
    ~CActionList();
    BOOL Append(const CIni* piniService, LPCTSTR pszSection);

    void RunAutoApp(HWND hwndDlg, _ArgsStruct *pArgs); // not check return value, add as watch process
    BOOL RunAccordType(HWND hwndDlg, _ArgsStruct *pArgs, BOOL fStatusMsgOnFailure = TRUE, BOOL fOnError = FALSE); //No watch process, Check connection type

protected:
    BOOL Run(HWND hwndDlg, _ArgsStruct *pArgs, BOOL fAddWatch, BOOL fStatusMsgOnFailure, BOOL fOnError);
    
    //
    // Since we do not have a dynamic array class, here is the simple implementation
    //
    void        Add(CAction* pAction);
    CAction *   GetAt(UINT nIndex);
    UINT        GetSize() {return m_nNum;}


    CAction **  m_pActionList;      // This is a list of CAction*
    UINT        m_nNum;             // number of elements in pActionList
    UINT        m_nSize;            // The memory size of the m_pActionList
    LPCTSTR     m_pszType;          // "type" of the connect action (actually, the section name)

    enum {GROW_BY = 10}; // the dynamic array grow
};

//+---------------------------------------------------------------------------
//
//  class CAction
//
//  Description: A single action object
//
//  History:    fengsun Created     11/14/97
//
//----------------------------------------------------------------------------
class CAction
{
public:
    CAction(LPTSTR lpCommandLine, UINT dwFlags, LPTSTR lpDescript = NULL);
    ~CAction();

    HANDLE RunAsExe(CShellDll* pShellDll) const;
    HANDLE RunAsExeFromSystem(CShellDll* pShellDll, LPTSTR pszDesktop, DWORD dwLoadType);
    BOOL RunAsDll(HWND hWndParent, OUT DWORD& dwReturnValue, DWORD dwLoadType) const;
    const TCHAR* GetDescription() const {return m_pszDescription;}
    const TCHAR* GetProgram() const {return m_pszProgram;}
    void ExpandMacros(_ArgsStruct *pArgs);

    BOOL IsDll() const { return m_fIsDll; }
    void ConvertRelativePath(const CIni *piniService); 
    void ExpandEnvironmentStringsInCommand();
    void ExpandEnvironmentStringsInParams();
    
    BOOL IsAllowed(_ArgsStruct *pArgs, LPDWORD lpdwLoadType);
    BOOL RunConnectActionForCurrentConnection(_ArgsStruct *pArgs);
    BOOL HasUI() const { return ((m_dwFlags & NONINTERACTIVE) ? FALSE : TRUE); }

protected:
    BOOL GetLoadDirWithAlloc(DWORD dwLoadType, LPWSTR * ppszwPath) const;
    void ParseCmdLine(LPTSTR pszCmdLine);
    void ExpandEnvironmentStrings(LPTSTR * ppsz);

    //
    // Flags for CAction
    //
    enum { ACTION_DIALUP =      0x00000001,
           ACTION_DIRECT =      0x00000002
    };


    BOOL m_fIsDll;        // whether the action is a dll
    LPTSTR m_pszProgram;  // The program name or the dll name
    LPTSTR m_pszParams;   // The parameters of the program/dll
    LPTSTR m_pszFunction; // The function name of the dll
    LPTSTR m_pszDescription; // the description
    UINT m_dwFlags;       // a bit ORed flag

#ifdef DEBUG
public:
    void AssertValid() const;
#endif
};

inline void CActionList::RunAutoApp(HWND hwndDlg, _ArgsStruct *pArgs)
{
    Run(hwndDlg, pArgs, TRUE, FALSE, FALSE); //fAddWatch = TRUE, fStatusMsgOnFailure = FALSE
}

inline void CAction::ConvertRelativePath(const CIni *piniService)
{
    //
    // Convert the relative path to full path
    //
    LPTSTR pszTmp = ::CmConvertRelativePath(piniService->GetFile(), m_pszProgram);
    CmFree(m_pszProgram);
    m_pszProgram = pszTmp;
}

inline void CAction::ExpandEnvironmentStringsInCommand()
{
    CAction::ExpandEnvironmentStrings(&m_pszProgram);
}

inline void CAction::ExpandEnvironmentStringsInParams()
{
    CAction::ExpandEnvironmentStrings(&m_pszParams);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmdial\cmmaster.h ===
//+----------------------------------------------------------------------------
//
// File:     cmmaster.h     
//
// Module:   CMDIAL32.DLL
//
// Synopsis: Master include file for precompiled headers.
//
// Copyright (c) 1996-1999 Microsoft Corporation
//
// Author:   quintinb   Created Header   08/17/99
//
//+----------------------------------------------------------------------------

#ifndef _CMMASTER_H_
#define _CMMASTER_H_

#include "icm.h"

#endif // _CMMASTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmdial\cmfmtstr.h ===
//+----------------------------------------------------------------------------
//
// File:     cmfmtstr.h     
//
// Module:   CMDIAL32.DLL
//
// Synopsis: Message IDs for cmfmtstr.rc
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   nickball Created    02/10/98
//
//+----------------------------------------------------------------------------

// String IDs for cmfmtstr.rc

#define IDMSG_PORTNOTCONFIGURED         11000
#define IDMSG_RESTRICTEDLOGONHOURS      11001
#define IDMSG_ACCTDISABLED              11002
#define IDMSG_PASSWDEXPIRED             11003
#define IDMSG_NODIALINPERMISSION        11004
#define IDMSG_ABOUT_BUILDVERSION        11005
#define IDMSG_ABOUT_WARNING_PART1       11006
#define IDMSG_ABOUT_WARNING_PART2       11007
#define IDMSG_EDIT_BUTTON               11009
#define IDMSG_EDIT_NEED_PHONE           11010
#define IDMSG_CMMON_LAUNCH_FAIL         11011
#define IDS_DEFAULT_ACCESSPOINT         11013
#define IDMSG_NEED_USERNAME             11014
#define IDMSG_NEED_PASSWORD             11015
#define IDMSG_NEED_DOMAIN               11016
#define IDMSG_CANTFORMAT                11017
#define IDMSG_NEED_PHONE_DIRECT         11018
#define IDMSG_NEED_PHONE_DIAL           11019
#define IDMSG_ALREADY_CONNECTED         11020
#define IDMSG_ALREADY_CONNECTING        11021
#define IDMSG_ALREADY_DISCONNECTING     11022
#define IDMSG_UNSUPPORTED_SETTING       11023
#define IDMSG_DISCONNECTING             11024
#define IDMSG_INITIALIZING              11025
#define IDMSG_DIALING                   11026
#define IDMSG_TUNNELDIALING             11027
#define IDMSG_CHECKINGPASSWORD          11028
#define IDMSG_LINEBUSY                  11029
#define IDMSG_NOANSWER                  11030
#define IDMSG_PAUSING                   11031
#define IDMSG_TITLESERVICE              11032
#define IDMSG_UNSUPPORTED_SETTING_NUM   11033
#define IDMSG_CANCELED                  11034
#define IDMSG_UNSUPPORTED_DEVICE        11035
#define IDMSG_NOTRESPONDING             11036
#define IDMSG_PICK_VPN_ADDRESS          11037
#define IDMSG_NODIALTONE                11038
#define IDMSG_VOICEANSWER               11039
#define IDMSG_BADPASSWORD               11040
#define IDMSG_PORTINUSE                 11041
#define IDMSG_REMOTEDISCONNECTED        11042
#define IDMSG_NORAS_MSG                 11043
#define IDMSG_DISCONNECT                11044
#define IDMSG_WORKING                   11045
#define IDMSG_PPPPROBLEM                11046
#define IDMSG_TCPIPPROBLEM              11047
#define IDMSG_REBOOT_MSG                11048
//                                      11049
#define IDMSG_NOMATCHPASSWORD           11050
#define IDMSG_EFFECTIVE_NEXT_TIME       11051
#define IDS_TUNNEL_SUFFIX               11052
#define IDS_NEW_PASSWORD_TOOLTIP        11053
#define IDS_RESETPASSWORD               11054
#define IDMSG_RAS_ERROR                 11055
#define IDMSG_SYS_ERROR_DEC             11056
#define IDMSG_CM_ERROR_DEC              11057
#define IDMSG_SYS_ERROR_HEX             11058
#define IDMSG_CM_ERROR_HEX              11059
#define IDMSG_WAITING_FOR_CALLBACK      11060
#define IDMSG_NO_SCRIPT_INST_MSG_95     11061
//                                      11062
//                                      11063
//                                      11064
//                                      11065
//                                      11066
//                                      11067
//                                      11068
//                                      11069
//                                      11070
//                                      11071
//                                      11072
//                                      11073
//                                      11074
//                                      11075
//                                      11076
//                                      11077
//                                      11078
//                                      11079
//                                      11080
//                                      11081
//                                      11082
//                                      11083
//                                      11084
//                                      11085
//                                      11086
//                                      11087
//                                      11088
//                                      11089
//                                      11090
//                                      11091
//                                      11092
//                                      11093
//                                      11094
//                                      11095
//                                      11096
//                                      11097
//                                      11098   
//                                      11099
//                                      11100
//                                      11101
#define IDMSG_NO_CMP_PBK_ACCESS         11102
#define IDMSG_READY                     11103
#define IDMSG_CONFIG_FAILED_MSG         11104
#define IDMSG_DAMAGED_PROFILE           11105
#define IDMSG_WRONG_PROFILE_VERSION     11106
#define IDMSG_PROTOCOL_NOT_CONFIGURED   11107
//                                      11108
#define IDMSG_PORTNOTAVAILABLE          11109
#define IDMSG_DEVICEERROR               11110
#define IDMSG_LINEBUSYREDIAL            11111
#define IDMSG_NOANSWERREDIAL            11112
#define IDMSG_NEED_CONFIGURE_TAPI       11113
#define IDMSG_INSTALLMODEM_MANUALLY_MSG 11114
#define IDMSG_INSTALLSP_MSG             11115
#define IDMSG_TUNNEL_NOANSWER           11116
#define IDMSG_TUNNEL_NOANSWERREDIAL     11117
#define IDMSG_NOMODEM_MSG               11118
#define IDMSG_CONN_ACTION_RUNNING       11119
#define IDMSG_CONN_ACTION_FAILED        11120
#define IDMSG_CONN_ACTION_NOTFOUND      11121
#define IDMSG_TUNNELINUSE               11122
#define IDMSG_TUNNELNOTAVAILABLE        11123
#define IDMSG_NO_LOG_FILE               11124    
#define IDMSG_CANT_VIEW_LOG             11125
//                                      11126
#define IDMSG_NOPPTPINST_MSG_NT         11127
#define IDMSG_NOPPTPINST_MSG_95         11128
#define IDMSG_NOPPTPINST_MSG_98         11129
#define IDMSG_NOPPTPINST_MSG_NT_SP      11130
//                                      11131
#define IDMSG_NEED_PPTP_WIN95           11132
#define IDMSG_NEED_PPTP_NT              11133
#define IDMSG_NEED_PPTP_NT_SP           11134
#define IDMSG_COMPONENTS_CHECKING_INPROCESS 11135
#define IDS_REG_DIALUP_ADAPTER          11300
#define IDS_WANTTOEXIT                  11301
#define IDS_SERVICENOTINSTALLED         11302
#define IDS_SERVICEDISABLED             11303
#define IDS_PHONE_NUM_LABEL             11304
#define IDS_BACKUP_NUM_LABEL            11305
#define IDS_IDLETIME_NEVER              11306
#define IDS_IDLETIME_1MINUTE            11307
#define IDS_IDLETIME_5MINUTE            11308
#define IDS_IDLETIME_10MINUTE           11309
#define IDS_IDLETIME_30MINUTE           11310
#define IDS_IDLETIME_1HOUR              11311
#define IDS_IDLETIME_2HOURS             11312
#define IDS_IDLETIME_4HOURS             11313
#define IDS_IDLETIME_8HOURS             11314
#define IDS_IDLETIME_24HOURS            11315
#define IDS_PROPERTIES_SUFFIX           11316
#define IDMSG_SAVE_ACCESSPOINT          11317
#define IDMSG_DELETE_ACCESSPOINT        11318
#define IDMSG_BALLOON_TITLE_DIALINGRULES 11319
#define IDMSG_BALLOON_MSG_DIALINGRULES	11320
#define IDMSG_BALLOON_TITLE_ACCESSPOINT	11321
#define IDMSG_BALLOON_MSG_ACCESSPOINT	11322
#define IDMSG_DELETE_GLOBAL_CREDS   	11323
#define IDMSG_DELETE_ALL_CREDS          11324
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmdial\cm_misc.h ===
//+----------------------------------------------------------------------------
//
// File:     cm_misc.h     
//
// Module:   CMDIAL32.DLL
//
// Synopsis: Implements the CFreezeWindow Class
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   henryt Created    01/13/98
//
//+----------------------------------------------------------------------------
#ifndef _CM_MISC_INC
#define _CM_MISC_INC

extern  HINSTANCE   g_hInst; // the instance handle for resource

//
// A helper class to auto disable/enable window
// The constructor will disable the window, the distructor will enable the window
//
class CFreezeWindow
{
public:
    CFreezeWindow(HWND hWnd, BOOL fDisableParent = FALSE) 
    {
        //
        // Disable the window
        // To disable a property page, the property sheet also need to be disabled
        //

        m_hWnd = hWnd; 

        if (m_hWnd)
        {
             m_fDisableParent = fDisableParent; 
             
             //
             // Store the currently focuse window
             //

             m_hFocusWnd = GetFocus();

             EnableWindow(m_hWnd, FALSE);

             if (fDisableParent)
             {
                EnableWindow(GetParent(m_hWnd), FALSE);
             }
        }
    }

    ~CFreezeWindow()
    {
        if (m_hWnd)
        {
            EnableWindow(m_hWnd, TRUE);
            if (m_fDisableParent)
            {
                EnableWindow(GetParent(m_hWnd), TRUE);
            }

            //
            // Restore focus to the previously focuses window if any.
            // Its just the right thing to do.
            //

            if (m_hFocusWnd)
            {
                SetFocus(m_hFocusWnd);
            }

        }
    }
protected:
    HWND m_hWnd;
    HWND m_hFocusWnd;
    BOOL m_fDisableParent;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmdial\compchck.h ===
//+----------------------------------------------------------------------------
//
// File:     CompChck.h
//
// Module:	 CMDIAL32.DLL
//
// Synopsis: Provide the win32 only component checking and installing interface
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:	 fengsun Created    10/21/97
//
//+----------------------------------------------------------------------------

#ifndef COMPCHCK_H
#define COMPCHCK_H

//
// By default, perform checks specified by dwComponentsToCheck, ignore reg key
//             install missed components
//
DWORD CheckAndInstallComponents(DWORD dwComponentsToCheck, 
    HWND hWndParent, 
    LPCTSTR pszServiceName,
    BOOL fIgnoreRegKey = TRUE, 
    BOOL fUnattended = FALSE);

void ClearComponentsChecked();
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmdial\compchck.cpp ===
//+----------------------------------------------------------------------------
//
// File:     CompChck.cpp     
//
// Module:   CMDIAL32.DLL
//
// Synopsis: This module contains win32 only conponents checking and installing
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   Fengsun Created    10/21/97
//
//+----------------------------------------------------------------------------


/////////////////////////////////////////////////////////////////////
//
//  All the functions in this file are WIN32 implementation only
//

#include "cmmaster.h"
#include "CompChck.h"
#include "cmexitwin.cpp"
#include "winuserp.h"

//
// CSDVersion key contains the service pack that has been installed 
//

const TCHAR* const c_pszRegRas                  = TEXT("SOFTWARE\\Microsoft\\RAS");
const TCHAR* const c_pszCheckComponentsMutex    = TEXT("Connection Manager Components Checking");
const TCHAR* const c_pszRegComponentsChecked    = TEXT("ComponentsChecked");

const TCHAR* const c_pszSetupPPTPCommand        = TEXT("rundll.exe rnasetup.dll,InstallOptionalComponent VPN");

//
// Functions internal to this file
//

static HRESULT CheckComponents(HWND hWndParent, LPCTSTR pszServiceName, DWORD dwComponentsToCheck, OUT DWORD& dwComponentsMissed, 
                      BOOL fIgnoreRegKey, BOOL fUnattended );
static BOOL  InstallComponents(DWORD dwComponentsToInstall, HWND hWndParent, LPCTSTR pszServiceName);
static BOOL MarkComponentsChecked(DWORD dwComponentsChecked);
static BOOL ReadComponentsChecked(LPDWORD pdwComponentsChecked);
static BOOL IsPPTPInstalled(void);
static BOOL InstallPPTP(void);
static BOOL IsScriptingInstalled(void);
static HRESULT ConfigSystem(HWND hwndParent, 
                     DWORD dwfOptions, 
                     LPBOOL pbReboot);
static HRESULT InetNeedSystemComponents(DWORD dwfOptions,
                                 LPBOOL pbNeedSysComponents);
static HRESULT InetNeedModem(LPBOOL pbNeedModem);
static void DisplayMessageToInstallServicePack(HWND hWndParent, LPCTSTR pszServiceName);
static inline HINSTANCE LoadInetCfg(void) 
{   
    return (LoadLibraryExA("cnetcfg.dll", NULL, 0));
}


//+----------------------------------------------------------------------------
//
//  Function    IsPPTPInstalled
//
//  Synopsis    Check to see if PPTP is already installed
//
//  Arguments   None
//
//  Returns     TRUE - PPTP has been installed
//              FALSE - otherwise
//
//  History     3/25/97     VetriV      Created
//
//-----------------------------------------------------------------------------
BOOL IsPPTPInstalled(void)
{
    BOOL bReturnCode = FALSE;


    HKEY hKey = NULL;
    DWORD dwSize = 0, dwType = 0;
    LONG lrc = 0;
    TCHAR szData[MAX_PATH+1];

    
    if (OS_NT)
    {
        if (GetOSMajorVersion() >= 5)
        {
            //
            // PPTP is always installed on NT5
            //
            bReturnCode = TRUE;
        }
        else
        {
            if (RegOpenKeyExU(HKEY_LOCAL_MACHINE,
                            TEXT("SOFTWARE\\Microsoft\\RASPPTP"),
                            0,
                            KEY_READ,
                            &hKey) == 0)
            {
                RegCloseKey(hKey);
                bReturnCode = TRUE;
            }
        }
    }
    else
    {
        hKey = NULL;
        lrc = RegOpenKeyExU(HKEY_LOCAL_MACHINE,
                           TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Setup\\OptionalComponents\\VPN"),
                           0,
                           KEY_READ,
                           &hKey);

        if (ERROR_SUCCESS == lrc)
        {
            dwSize = MAX_PATH;
            lrc = RegQueryValueExU(hKey, TEXT("Installed"), 0, 
                                    &dwType, (LPBYTE)szData, &dwSize);

            if (ERROR_SUCCESS == lrc)
            {
                if (0 == lstrcmpiU(szData, TEXT("1")))
                {                                                         
                    //
                    // On 9X, we need to check for Dial-Up Adapter #2. If its 
                    // not present then tunneling won't work unless we install
                    // PPTP to install the Adapter #2.
                    //

                    //
                    //  On early versions of Win9x Dial-up Adapter was localized, but on WinME, WinSE, 
                    //  or machines that have DUN 1.3 installed it isn't.  Thus, lets try the unlocalized
                    //  first and then if that fails we can try the localized version.
                    //
                    const TCHAR * const c_pszDialupAdapter = TEXT("Dial-up Adapter");
                    LPTSTR pszAdapter = NULL;

                    LPTSTR pszKey = CmStrCpyAlloc(TEXT("System\\CurrentControlSet\\Control\\PerfStats\\Enum\\"));
                    CmStrCatAlloc(&pszKey, c_pszDialupAdapter);
                    CmStrCatAlloc(&pszKey, TEXT(" #2"));

                    //
                    // Close the key that we opened above, and try the one for the adapter
                    //

                    RegCloseKey(hKey);
                    hKey = NULL;

                    if (ERROR_SUCCESS == RegOpenKeyExU(HKEY_LOCAL_MACHINE, 
                                                      pszKey, 
                                                      0, 
                                                      KEY_QUERY_VALUE, 
                                                      &hKey))
                    {
                        bReturnCode = TRUE;
                    }
                    else
                    {

                        CmFree (pszKey);
                        pszAdapter = CmLoadString(g_hInst, IDS_REG_DIALUP_ADAPTER);

                        pszKey = CmStrCpyAlloc(TEXT("System\\CurrentControlSet\\Control\\PerfStats\\Enum\\"));
                        CmStrCatAlloc(&pszKey, pszAdapter);
                        CmStrCatAlloc(&pszKey, TEXT(" #2"));
                   
                        //
                        // Close the key that we opened above, and try the one for the adapter
                        //

                        RegCloseKey(hKey);
                        hKey = NULL;

                        if (ERROR_SUCCESS == RegOpenKeyExU(HKEY_LOCAL_MACHINE, 
                                                          pszKey, 
                                                          0, 
                                                          KEY_QUERY_VALUE, 
                                                          &hKey))
                        {
                            bReturnCode = TRUE;
                        }
                    }

                    CmFree(pszKey);
                    CmFree(pszAdapter);                    
                }
            }
        }
            
        if (hKey)
        {
            RegCloseKey(hKey);
            hKey = NULL;
        }
    }

    return bReturnCode;
}


//+----------------------------------------------------------------------------
//
//  Function    InstallPPTP
//
//  Synopsis    Install PPTP on Windows 95 and NT
//
//  Arguments   None
//
//  Returns     TRUE  --  if was successfully installed
//              FALSE --  Otherwise
//
//  History     3/25/97     VetriV      Created
//              7/8/97      VetriV      Added code to setup PPTP on Memphis
//
//-----------------------------------------------------------------------------
BOOL InstallPPTP(void)
{
    BOOL bReturnCode = FALSE;

    STARTUPINFO         si;
    PROCESS_INFORMATION pi;
    MSG                 msg ;
    
    if (OS_NT || OS_W95)
    {
        //
        // Don't know how to install/configure PPTP on NT. 
        // We let the admin wrestle with MSDUNXX on W95
        //

        return FALSE;
    }
    else
    {
        
        TCHAR szCommand[128];
    
        ZeroMemory(&pi, sizeof(pi));
        ZeroMemory(&si, sizeof(si));
        si.cb = sizeof(STARTUPINFO);
        
        //
        // NOTE: The original version called "msdun12.exe /q /R:N" to install tunneling
        // on Windows 95. Now we use 98 approach only and call the following:
        // "rundll.exe rnasetup.dll,InstallOptionalComponent VPN".
        //

        MYDBGASSERT(1353 < LOWORD(GetOSBuildNumber()));

        lstrcpyU(szCommand, c_pszSetupPPTPCommand);
       
        if (NULL == CreateProcessU(NULL, szCommand, 
                                    NULL, NULL, FALSE, 0, 
                                    NULL, NULL, &si, &pi))
        {
            CMTRACE1(TEXT("InstallPPTP() CreateProcess() failed, GLE=%u."), GetLastError());
        }
        else
        {
            CMTRACE(TEXT("InstallPPTP() Launched PPTP Install. Waiting for exit."));
            
            //
            // wait for event or msgs. Dispatch msgs. Exit when event is signalled.
            //
            while((MsgWaitForMultipleObjects(1, &pi.hProcess, 
                                                FALSE, INFINITE, 
                                                QS_ALLINPUT) == (WAIT_OBJECT_0 + 1)))
            {
                //
                // read all of the messages in this next loop
                // removing each message as we read it
                //
                while (PeekMessageU(&msg, NULL, 0, 0, PM_REMOVE))
                {
                    CMTRACE(TEXT("InstallPPTP() Got Message"));
                    
                    //
                    // how to handle quit message?
                    //
                    DispatchMessageU(&msg);
                    if (msg.message == WM_QUIT)
                    {
                        CMTRACE(TEXT("InstallPPTP() Got Quit Message"));
                        goto done;
                    }
                }
            }
done:
            CloseHandle(pi.hThread);
            CloseHandle(pi.hProcess);
            //
            // PPTP was successfully installed
            //
            bReturnCode = TRUE;
            CMTRACE(TEXT("InstallPPTP() done"));
        }
    }

    return bReturnCode;
}


//+----------------------------------------------------------------------------
//
//  Function    IsMSDUN12Installed
//
//  Synopsis    Check if MSDUN 1.2 or higher is installed.
//
//  Arguments   none
//
//  Returns     TRUE - MSDUN 1.2 is installed
//
//  History     8/12/97     nickball    from ICW for 11900
//
//-----------------------------------------------------------------------------
#define DUN_12_Version "1.2"

BOOL IsMSDUN12Installed()
{
    CHAR szBuffer[MAX_PATH] = {"\0"};
    HKEY hkey = NULL;
    BOOL bRC = FALSE;
    DWORD dwType = 0;
    DWORD dwSize = sizeof(szBuffer);

    //
    // Try to open the Version key
    //

    if (ERROR_SUCCESS != RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                                       "System\\CurrentControlSet\\Services\\RemoteAccess",
                                       0,
                                       KEY_READ,
                                       &hkey))
    {
        return FALSE;
    }

    //
    // The key exists, check the value
    //

    if (ERROR_SUCCESS == RegQueryValueExA(hkey, "Version", NULL, &dwType, 
                                          (LPBYTE)szBuffer, &dwSize))
    {               
        //
        // If the entry starts with "1.2", (eg. "1.2c") its a hit
        //
        
        bRC = (szBuffer == CmStrStrA(szBuffer, DUN_12_Version));
    }

    RegCloseKey(hkey);

    return bRC;
}

//+----------------------------------------------------------------------------
//
//  Function    IsISDN11Installed
//
//  Synopsis    Check if ISDN 1.1 is installed
//
//  Arguments   none
//
//  Returns     TRUE - ISDN 1.1 is installed
//
//  Note:       MSDUN12 superscedes ISDN1.1, but ISDN1.1 does provide scripting
//
//  History     8/12/97     nickball    
//
//-----------------------------------------------------------------------------

BOOL IsISDN11Installed()
{
    CHAR szBuffer[MAX_PATH] = {"\0"};
    HKEY hkey = NULL;
    BOOL bRC = FALSE;
    DWORD dwType = 0;
    DWORD dwSize = sizeof(szBuffer);

    if (ERROR_SUCCESS != RegOpenKeyExA(HKEY_LOCAL_MACHINE, 
        "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OptionalComponents\\MSISDN",
        0,
        KEY_READ,
        &hkey))
    {
        goto IsISDN11InstalledExit;
    }

    if (ERROR_SUCCESS != RegQueryValueExA(hkey,
        "Installed",
        NULL,
        &dwType,
        (LPBYTE)szBuffer,
        &dwSize))
    {
        goto IsISDN11InstalledExit;
    }

    if (0 == lstrcmpA("1", szBuffer))
    {
        bRC = TRUE;
    }

IsISDN11InstalledExit:
    return bRC;
}


//+----------------------------------------------------------------------------
//
//  Function    IsScriptingInstalled
//
//  Synopsis    Check to see if scripting is already installed
//
//  Arguments   None
//
//  Returns     TRUE - scripting has been installed
//
//  History     3/5/97      VetriV      From ICW code
//
//-----------------------------------------------------------------------------
BOOL IsScriptingInstalled(void)
{
    BOOL bReturnCode = FALSE;

    HKEY hkey = NULL;
    DWORD dwSize = 0, dwType = 0;
    LONG lrc = 0;
    HINSTANCE hInst = NULL;
    CHAR szData[MAX_PATH+1];

    
    if (OS_NT)
    {
        //
        // NT comes with Scripting installed
        //
        bReturnCode = TRUE;
    }
    else
    {
        //
        // OSR2 and higher releases of Windows 95 have scripting installed
        //
        if (1111 <= LOWORD(GetOSBuildNumber()))
        {
            bReturnCode = TRUE;
        }
        else
        {
            //
            // Must be Gold 95, check for installed scripting
            //
            
            if (IsMSDUN12Installed() || IsISDN11Installed())
            {
                bReturnCode = TRUE;
            }
            else
            {
                hkey = NULL;
                lrc = RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                                "System\\CurrentControlSet\\Services\\RemoteAccess\\Authentication\\SMM_FILES\\PPP",
                                0,
                                KEY_READ,
                                &hkey);

                if (ERROR_SUCCESS == lrc)
                {
                    dwSize = MAX_PATH;
                    lrc = RegQueryValueExA(hkey, "Path", 0, &dwType, (LPBYTE)szData, &dwSize);

                    if (ERROR_SUCCESS == lrc)
                    {
                        if (0 == lstrcmpiA(szData,"smmscrpt.dll"))
                        {
                            bReturnCode = TRUE;
                        }
                    }
                }
                
                if (hkey)
                {
                    RegCloseKey(hkey);
                    hkey = NULL;
                }

                //
                // Verify that the DLL can be loaded
                //
                if (bReturnCode)
                {
                    hInst = LoadLibraryExA("smmscrpt.dll", NULL, 0);
                    
                    if (hInst)
                    {
                        FreeLibrary(hInst);
                    }
                    else
                    {
                        bReturnCode = FALSE;
                    }

                    hInst = NULL;
                }
            }
        }
    }

    return bReturnCode;
}

//+----------------------------------------------------------------------------
//  Function    VerifyRasServicesRunning
//
//  Synopsis    Make sure that the RAS services are enabled and running
//
//  Arguments   hWndDlg:        - Window Handle of parent window
//              pszServiceName  - Service name for titles
//              fUnattended:    - if TRUE, do not do not popup any UI
//
//  Return      FALSE - if the services couldn't be started
//
//  History     2/26/97     VetriV      Copied from ICW code
//-----------------------------------------------------------------------------
BOOL VerifyRasServicesRunning(HWND hWndDlg, LPCTSTR pszServiceName, BOOL fUnattended)
{
    BOOL bReturnCode = FALSE;
    HINSTANCE hInstance = NULL;
    HRESULT (WINAPI *pfn)(void);

    hInstance = LoadInetCfg();
    if (!hInstance) 
    {
        CMTRACE1(TEXT("VerifyRasServicesRunning() LoadLibrary() failed, GLE=%u."), GetLastError());
    }
    else
    {
        pfn = (HRESULT (WINAPI *)(void))GetProcAddress(hInstance, "InetStartServices");

        if (pfn)
        {
            LPTSTR pszDisabledMsg;
            LPTSTR pszExitMsg;

            pszDisabledMsg = CmFmtMsg(g_hInst, IDS_SERVICEDISABLED);
            pszExitMsg = CmFmtMsg(g_hInst, IDS_WANTTOEXIT);
            
            //
            // Check RAS Services
            //
            do 
            {
                HRESULT hr = pfn();
                
                if (ERROR_SUCCESS == hr)
                {
                    bReturnCode = TRUE;
                    break;
                }
                else
                {
                    CMTRACE1(TEXT("VerifyRasServicesRunning() InetStartServices() failed, GLE=%u."), hr);
                }

                //
                // Do not retry if unattended
                //
                if (!fUnattended)
                {
                    bReturnCode = FALSE;
                    break;
                }

                //
                //  Check the error code of OpenService
                //  Do not ask user to retry for certain errors
                //
                if (hr == ERROR_SERVICE_DOES_NOT_EXIST || hr == ERROR_FILE_NOT_FOUND ||
                    hr == ERROR_ACCESS_DENIED)
                {
                    LPTSTR pszNotInstalledMsg = CmFmtMsg(g_hInst, IDS_SERVICENOTINSTALLED);

                    //
                    // Report the error and Exit
                    //
                    MessageBoxEx(hWndDlg, pszNotInstalledMsg, pszServiceName,
                                                MB_OK|MB_ICONSTOP,
                                                LANG_USER_DEFAULT);
                    CmFree(pszNotInstalledMsg);
                    bReturnCode = FALSE;
                    break;
                }

                //
                // Report the error and allow the user to retry
                //
                if (IDYES != MessageBoxEx(hWndDlg,pszDisabledMsg,pszServiceName,
                                            MB_YESNO | MB_DEFBUTTON1 
                                            | MB_ICONWARNING,
                                            LANG_USER_DEFAULT))
                {
                    //
                    // Confirm Exit
                    //
                    if (IDYES == MessageBoxEx(hWndDlg, pszExitMsg, pszServiceName,
                                                MB_APPLMODAL | MB_ICONQUESTION 
                                                | MB_YESNO | MB_DEFBUTTON2,
                                                LANG_USER_DEFAULT))
                    {
                        bReturnCode = FALSE;
                        break;
                    }
                }
            
            } while (1);

            CmFree(pszDisabledMsg);
            CmFree(pszExitMsg);
        }
        else
        {
            CMTRACE1(TEXT("VerifyRasServicesRunning() GetProcAddress() failed, GLE=%u."), GetLastError());
        }

        FreeLibrary(hInstance);
    }

    return bReturnCode;
}

//+----------------------------------------------------------------------------
//  Function    CheckAndInstallComponents
//
//  Synopsis    Make sure the system is setup for dialing
//
//  Arguments   dwComponentsToCheck - Components to be checked
//              hWndParent          - Window Handle of parent window
//              pszServiceName      - Long service name for error titles
//              fIgnoreRegKey:      - Whether ignore ComponetsChecked registry key
//                  Default is  TRUE, check the components even if their bit is set
//                  in registry
//              fUnattended: if TRUE, do not try to install missed components,
//                                    do not popup any UI
//                  Defualt is FALSE, install.
//
//  Return      Other - if system could not be configured
//                      or if the we have to reboot to continue
//              ERROR_SUCCESS  - Check and install successfully
//
//  History     3/13/97     VetriV      
//              6/24/97     byao    Modified. Set pArgs->dwExitCode accordingly
//              11/6/97     fengsun changed parameters, do not pass pArgs
//-----------------------------------------------------------------------------
DWORD CheckAndInstallComponents(DWORD dwComponentsToCheck, HWND hWndParent, LPCTSTR pszServiceName,
                                BOOL fIgnoreRegKey, BOOL fUnattended)
{
    MYDBGASSERT( (dwComponentsToCheck & 
        ~(CC_RNA | CC_TCPIP | CC_MODEM | CC_PPTP | CC_SCRIPTING | CC_RASRUNNING | CC_CHECK_BINDINGS) ) == 0 );

    if (dwComponentsToCheck == 0)
    {
        return ERROR_SUCCESS;
    }

    //
    // Open the mutex, so only one CM instance can call this function.
    // The destructor of CNamedMutex will release the mutex
    //

    CNamedMutex theMutex;
    if (!theMutex.Lock(c_pszCheckComponentsMutex))
    {
        //
        // Another instance of cm is checking components. Return here
        //

        LPTSTR pszMsg = CmLoadString(g_hInst, IDMSG_COMPONENTS_CHECKING_INPROCESS);
        MessageBoxEx(hWndParent, pszMsg, pszServiceName,
                                    MB_OK | MB_ICONERROR,
                                    LANG_USER_DEFAULT);
        CmFree(pszMsg);
        return  ERROR_CANCELLED;
    }

    //
    // Find components missed
    //
    DWORD dwComponentsMissed = 0;
    DWORD dwRet = CheckComponents(hWndParent, pszServiceName, dwComponentsToCheck, dwComponentsMissed, 
                                fIgnoreRegKey, fUnattended);

    if (dwRet == ERROR_SUCCESS)
    {
        MYDBGASSERT(dwComponentsMissed == 0);
        return ERROR_SUCCESS;
    }

    if (dwRet == E_ACCESSDENIED && OS_NT5)
    {
        //
        // On NT5, non-admin user does not have access to check components
        // Continue.
        //
        return ERROR_SUCCESS;
    }

    if (fUnattended)
    {
        //
        // Do not try to install if fUnattended is TRUE
        //
        return dwRet;
    }

    if (dwComponentsMissed & ~CC_RASRUNNING)
    {
        //
        // Prompt user before configuring system
        // If modem is not installed, expilitly say that
        //

        LPTSTR pszMsg;

        if (dwComponentsMissed == CC_MODEM)
        {
            //
            // On NT4, if RAS is installed and modem is not installed or
            // not configured for dialout, then we cannot programmatically 
            // install and configure modem for the user (limitation of NT RAS 
            // install/configuration). So, we will display a message to user
            // to manually go and install and/or configure modem from NCPA
            //
            if (OS_NT4)
            {
                pszMsg = CmFmtMsg(g_hInst, IDMSG_INSTALLMODEM_MANUALLY_MSG);
                MessageBoxEx(hWndParent, pszMsg, pszServiceName,
                                            MB_OK | MB_ICONERROR,
                                            LANG_USER_DEFAULT);
                
                CmFree(pszMsg);
                return  ERROR_CANCELLED;
            }
            else
            {
                pszMsg = CmFmtMsg(g_hInst, IDMSG_NOMODEM_MSG);
            }
        }
        else
        {
            pszMsg = CmFmtMsg(g_hInst, IDMSG_NORAS_MSG);
        }

        int iRes = MessageBoxEx(hWndParent, pszMsg, pszServiceName,
                                    MB_YESNO | MB_DEFBUTTON1 | MB_ICONWARNING,
                                    LANG_USER_DEFAULT);
        CmFree(pszMsg);

        if (IDYES != iRes)      
        {
            return ERROR_CANCELLED;
        }

        if (!InstallComponents(dwComponentsMissed, hWndParent, pszServiceName))
        {
            //
            // Some time, GetLastError returns ERROR_SUCCESS
            //
            return (GetLastError() == ERROR_SUCCESS ? ERROR_CANCELLED : GetLastError());
        }
    }

    //
    // We can not do anything if RAS can not be started on NT
    //
    if (dwComponentsMissed & CC_RASRUNNING)
    {
        return dwRet;
    }
    else
    {
        return ERROR_SUCCESS;
    }
}       
        
//+----------------------------------------------------------------------------
//  Function    MarkComponentsChecked
//
//  Synopsis    Mark(in registry) what components have been checked.
//
//  Arguments   DWORD dwComponentsInstalled - a dword(bitwise OR'ed)
//
//  Return      TRUE - success
//              FALSE  - otherwise
//
//  History     08/07/97        Fengsun  - created  
//              08/11/97        henryt   - changed return type.
//              07/03/98        nickball - create if can't open
//-----------------------------------------------------------------------------
BOOL MarkComponentsChecked(DWORD dwComponentsChecked)
{
    HKEY hKeyCm;
    
    //
    // Try to open the key for writing
    //

    LONG lRes = RegOpenKeyExU(HKEY_LOCAL_MACHINE,
                              c_pszRegCmRoot,
                              0,
                              KEY_SET_VALUE ,
                              &hKeyCm);

    //
    // If we can't open it the key may not be there, try to create it.
    //

    if (ERROR_SUCCESS != lRes)
    {
        DWORD dwDisposition;
        lRes = RegCreateKeyExU(HKEY_LOCAL_MACHINE,
                               c_pszRegCmRoot,
                               0,
                               TEXT(""),
                               REG_OPTION_NON_VOLATILE,
                               KEY_SET_VALUE,
                               NULL,
                               &hKeyCm,
                               &dwDisposition);     
    }

    //
    // On success, update the ComponentsChecked value, then close
    //

    if (ERROR_SUCCESS == lRes)
    {
        lRes = RegSetValueExU(hKeyCm, c_pszRegComponentsChecked, NULL, REG_DWORD,
                      (BYTE*)&dwComponentsChecked, sizeof(dwComponentsChecked));
        RegCloseKey(hKeyCm);
    }

    return (ERROR_SUCCESS == lRes);
}

//+----------------------------------------------------------------------------
//  Function    ReadComponentsChecked
//
//  Synopsis    Read(from registry) what components have been checked.
//
//  Arguments   LPDWORD pdwComponentsInstalled - a ptr dword(bitwise OR'ed)
//
//  Return      TRUE - success
//              FALSE  - otherwise
//
//  History     8/7/97      fengsun     original code
//              8/11/97     henryt      created the func.
//-----------------------------------------------------------------------------

BOOL ReadComponentsChecked(
    LPDWORD pdwComponentsChecked
)
{
    BOOL fSuccess = FALSE;
    HKEY hKeyCm;
    DWORD dwType;
    DWORD dwSize = sizeof(DWORD);

    *pdwComponentsChecked = 0;

    if (RegOpenKeyExU(HKEY_LOCAL_MACHINE,
                      c_pszRegCmRoot,
                      0,
                      KEY_QUERY_VALUE ,
                      &hKeyCm) == ERROR_SUCCESS)
    {
        if ((RegQueryValueExU(hKeyCm, 
                            c_pszRegComponentsChecked,
                            NULL,
                            &dwType,
                            (BYTE*)pdwComponentsChecked, 
                            &dwSize) == ERROR_SUCCESS)   &&
           (dwType == REG_DWORD)                        && 
           (dwSize == sizeof(DWORD)))
        {
            fSuccess = TRUE;
        }

        RegCloseKey(hKeyCm);
    }
    return fSuccess;
}




//+----------------------------------------------------------------------------
//
// Function:  ClearComponentsChecked
//
// Synopsis:  Clear the component checked flag in registry back to 0
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/19/98
//
//+----------------------------------------------------------------------------
void ClearComponentsChecked()
{
    MarkComponentsChecked(0);
}
        
//+----------------------------------------------------------------------------
//  Function    CheckComponents
//
//  Synopsis    Checks to see if the system has all the components 
//              required of the service profile (like PPTP, TCP,...)
//              installed and configured
//
//  Arguments   hWndParent          -Window Handle of parent window
//              pszServiceName      - Service Name for title
//              dwComponentsToCheck:- Components to check
//              dwComponentsMissed: - OUT components missed
//              fIgnoreRegKey:      - Whether ignore ComponetsChecked registry key
//                  Default is  FALSE, not check the components whose bit is set
//                  in registry
//              fUnattended: if TRUE, do not do not popup any UI
//
//  Return      ERROR_SUCCESS- system does not need configuration
//              Other - otherwise
//
//  History     5/5/97      VetriV      
//              6/26/97     byao    Modified: update pArgs->dwExitCode when 
//                                  components needed
//              8/11/97     henryt  Performance changes. Added CC_* flags.
//              9/30/97     henryt  added pfPptpNotInstalled
//              11/6/97     fengsun changed parameters, do not pass pArgs
//-----------------------------------------------------------------------------
HRESULT CheckComponents(HWND hWndParent, LPCTSTR pszServiceName, DWORD dwComponentsToCheck, OUT DWORD& dwComponentsMissed, 
                      BOOL fIgnoreRegKey, BOOL fUnattended )
{
    DWORD dwComponentsAlreadyChecked = 0;   // Components already checked, to be saved into registry
    ReadComponentsChecked(&dwComponentsAlreadyChecked);

    CMTRACE1(TEXT("CheckComponents: dwComponentsToCheck = 0x%x"), dwComponentsToCheck);
    CMTRACE1(TEXT("CheckComponents: dwComponentsAlreadyChecked = 0x%x"), dwComponentsAlreadyChecked);

    //
    // If this is NT4 and we have successfully checked RAS installation
    // previously, double-check by examining Reg key. We do this because
    // the user may have removed RAS since our last component check in 
    // which case an unpleasant message is displayed to the user when
    // we try to load RASAPI32.DLL
    // 

    if (dwComponentsAlreadyChecked & CC_RNA)
    {
        if (OS_NT4)
        {
            //
            // RAS was installed properly at some point, but if 
            // we can't open the key, then mark it as un-checked.
            //

            HKEY hKeyCm;
            DWORD dwRes = RegOpenKeyExU(HKEY_LOCAL_MACHINE,
                                        c_pszRegRas,
                                        0,
                                        KEY_QUERY_VALUE ,
                                        &hKeyCm);
            if (ERROR_SUCCESS == dwRes)
            {
                RegCloseKey(hKeyCm);            
            }
            else
            {
                dwComponentsAlreadyChecked &= ~CC_RNA;
            }
        }
    }

    if (!fIgnoreRegKey)
    {
        //
        // Do not check those components already marked as checked in the registry
        //
        dwComponentsToCheck &= ~dwComponentsAlreadyChecked;
    }

    CMTRACE1(TEXT("CheckComponents: Now only checking components = 0x%x"), dwComponentsToCheck);


    HRESULT hrRet = S_OK;   // return value
    dwComponentsMissed = 0;   // Components not installed

    //
    // Check for DUN and TCP
    //
    if (dwComponentsToCheck & (CC_RNA | CC_TCPIP | CC_CHECK_BINDINGS))
    {
        BOOL bNeedSystemComponents = FALSE;
        
        if (dwComponentsToCheck & CC_CHECK_BINDINGS)
        {
            //
            // If we to check if PPP is bound to TCP
            //
            hrRet = InetNeedSystemComponents(INETCFG_INSTALLRNA | 
                                                INETCFG_INSTALLTCP,
                                                &bNeedSystemComponents);
        }
        else
        {
            //
            // If we do not want to check if TCP is bound (in case of shims)
            // check just if TCP is installed
            //
            hrRet = InetNeedSystemComponents(INETCFG_INSTALLRNA | 
                                                INETCFG_INSTALLTCPONLY,
                                                &bNeedSystemComponents);
        }
            
        if ((FAILED(hrRet)) || (TRUE == bNeedSystemComponents))
        {
            //
            // Set the Missing components properly - RNA and/or TCP missing
            // whether binding is missing or not depends on 
            // if CC_REVIEW_BINDINGS was set or not
            //
            dwComponentsMissed |= (CC_RNA | CC_TCPIP);
            if (dwComponentsToCheck & CC_CHECK_BINDINGS)
            {
                dwComponentsMissed |= CC_CHECK_BINDINGS;
            }
            
            if (SUCCEEDED(hrRet))
            {
                hrRet = HRESULT_FROM_WIN32(ERROR_PROTOCOL_NOT_CONFIGURED);
            }
        }
    }

    //
    // Check for Modem
    // Note: Should not even run the modem check is RNA is not installed
    //
    if (dwComponentsToCheck & CC_MODEM)
    {
        BOOL bNeedModem = FALSE;

        hrRet = InetNeedModem(&bNeedModem);

        if (FAILED(hrRet)) 
        {
            dwComponentsMissed |= (CC_MODEM | CC_RNA);
        }
        else 
        {
            if (TRUE == bNeedModem)
            {
                dwComponentsMissed |= CC_MODEM;
                hrRet = HRESULT_FROM_WIN32(ERROR_PROTOCOL_NOT_CONFIGURED);
            }
        }
    }

    //
    // Check if PPTP is installed, IsPPTPInstalled always returns TRUE for NT5
    //
    if (dwComponentsToCheck & CC_PPTP)
    {
        if (FALSE == IsPPTPInstalled())
        {
            dwComponentsMissed |= CC_PPTP;
            hrRet = HRESULT_FROM_WIN32(ERROR_PROTOCOL_NOT_CONFIGURED);
        }
    }

    //
    // Check for scripting
    //      if PPTP is installed then we have scripting also
    //      - msdun12.exe (used to install PPTP on Win95 contains scripting)
    if (dwComponentsToCheck & CC_SCRIPTING)
    {
        if ((FALSE == IsScriptingInstalled()) && (FALSE == IsPPTPInstalled()))
        {
            dwComponentsMissed |= CC_SCRIPTING;
            hrRet = HRESULT_FROM_WIN32(ERROR_PROTOCOL_NOT_CONFIGURED);
        }
    }

    //
    // Check if RAS services are running 
    // This is basically for NT4 and becomes a NOP on Windows 95 or NT5
    // On NT5, CM is started by Connection Folder.  RAS is automaticlly
    // started when ConnFolder is launched or CM desktop icon is clicked.  If RAS service
    // failed to launch, CM will not be execute at all.
    //
    if  (OS_NT && (dwComponentsToCheck & CC_RASRUNNING))
    {
        if (FALSE == VerifyRasServicesRunning(hWndParent, pszServiceName, !fUnattended))
        {
            //
            // Don't let the user continue if RAS is not running
            //
            dwComponentsMissed |= CC_RASRUNNING;
            DWORD dwRet = ( GetLastError() == ERROR_SUCCESS )? 
                    ERROR_PROTOCOL_NOT_CONFIGURED : GetLastError();

            hrRet = HRESULT_FROM_WIN32(dwRet);
        }
    }

    //
    // Update the components already checked
    //      Plus Components just checked, including those failed
    //      Minus components missed
    //
    DWORD dwComponentsCheckedNew = (dwComponentsAlreadyChecked | dwComponentsToCheck) & ~dwComponentsMissed;

    //
    // Update only if there is some change
    //
    if (dwComponentsCheckedNew != dwComponentsAlreadyChecked)
    {
        MarkComponentsChecked(dwComponentsCheckedNew);
    }

    return hrRet;
}

//+----------------------------------------------------------------------------
//  Function    InstallComponents
//
//  Synopsis    Installs all components required for the profile
//                  (PPTP, TCP, DUN, Modem,...)
//
//  Arguments   hWndDlg -   Window Handle of parent window
//              pszServiceName - Name of the service for title
//              dwComponentsToInstall - Componets to install
//
//  Return      FALSE - if system could not be configured
//              TRUE  - otherwise
//
//  History     3/13/97     VetriV  Created 
//              5/5/97      VetriV  Renamed function as InstallComponents
//                                  (used to be ConfigureSystemForDialing)  
//              9/30/97     henryt  added fInstallPptpOnly
//              11/6/97     fengsun changed parameters, do not pass pArgs
//              2/3/98      VetriV  changed code to inform user to reinstall
//                                  service pack if any component was installed
//                                  by this function and user had some SP
//                                  installed in the system
//-----------------------------------------------------------------------------
BOOL InstallComponents(DWORD dwComponentsToInstall, HWND hWndDlg, LPCTSTR pszServiceName)
{
    //
    //  We are not allowed to configure the system at WinLogon because we have
    //  no idea who the user is.  It could be just a random person walking up to the box.
    //
    if (!IsLogonAsSystem())
    {
        BOOL bReboot = FALSE;

        CMTRACE1(TEXT("InstallComponents: dwComponentsToInstall = 0x%x"), dwComponentsToInstall);

        //
        // We can not do any thing if RAS is not running
        //
        MYDBGASSERT(!(dwComponentsToInstall & CC_RASRUNNING));

        //
        // Disable the window, and enable it on return
        // The property sheet also need to be disabled
        //
        CFreezeWindow FreezeWindow(hWndDlg, TRUE);

        DWORD hRes = ERROR_SUCCESS;

        //
        // Do not install modem here. Install modem after reboot
        //
        if (dwComponentsToInstall & (CC_RNA | CC_MODEM | INETCFG_INSTALLTCP | INETCFG_INSTALLTCPONLY))
        {
            DWORD dwInetComponent = 0;

            dwInetComponent |= (dwComponentsToInstall & CC_RNA   ? INETCFG_INSTALLRNA :0) |
                               (dwComponentsToInstall & CC_MODEM ? INETCFG_INSTALLMODEM :0);

            //
            // Only way to check bindings is by installing TCP
            // This case will also cover the more common case of installing TCP
            // and checking for bindings
            //
            if (CC_CHECK_BINDINGS & dwComponentsToInstall)
            {
                dwInetComponent |= INETCFG_INSTALLTCP;
            }
            else if (CC_TCPIP & dwComponentsToInstall)
            {
                    //
                    // If bindings check is not turned on
                    //
                    dwInetComponent |= INETCFG_INSTALLTCPONLY;
            }

            if (dwInetComponent)
            {
                hRes = ConfigSystem(hWndDlg,dwInetComponent, &bReboot);
            }
        }
    

        if (ERROR_SUCCESS == hRes)
        {
            //
            // Check for scripting
            //      if PPTP is installed than we have scripting also
            //      - because msdun12.exe (used to install PPTP on Win95 
            //                              contains scripting)
            // and install if it is needed
            //
            if ((dwComponentsToInstall & CC_SCRIPTING) && 
                !(dwComponentsToInstall & CC_PPTP) )
            {
                LPTSTR pszNoScriptMsg = CmFmtMsg(g_hInst, IDMSG_NO_SCRIPT_INST_MSG_95);

                if (pszNoScriptMsg)
                {
                    MessageBoxEx(hWndDlg, pszNoScriptMsg, pszServiceName, 
                                 MB_OK | MB_ICONSTOP, LANG_USER_DEFAULT);
                    CmFree(pszNoScriptMsg);
                }
                return FALSE;
            }

            //
            // Check if PPTP is required and not already installed install it
            //
            if (dwComponentsToInstall & CC_PPTP)
            {
                if (TRUE == InstallPPTP()) // Note: Always fails on 95 by design
                {
                    //
                    // We have to reboot after installing PPTP
                    //
                    bReboot = TRUE;
                }
                else
                {
                    LPTSTR pszMsg;
                
                    //
                    // Don't let the user continue PPTP is not installed
                    //              
                
                    if (OS_NT) 
                    {
                        if (IsServicePackInstalled())
                        {
                            //
                            // we need to tell the user to re-apply the service pack after manual
                            // install of PPTP.
                            //
                            pszMsg = CmFmtMsg(g_hInst, IDMSG_NOPPTPINST_MSG_NT_SP); // NT
                        }
                        else
                        {
                            pszMsg = CmFmtMsg(g_hInst, IDMSG_NOPPTPINST_MSG_NT); // NT
                        }
                    }
                    else if (OS_W98)
                    {
                        pszMsg = CmFmtMsg(g_hInst, IDMSG_NOPPTPINST_MSG_98); // W98                   
                    }
                    else
                    {
                        pszMsg = CmFmtMsg(g_hInst, IDMSG_NOPPTPINST_MSG_95); // default                   
                    }

                    if (pszMsg)
                    {

                        MessageBoxEx(hWndDlg, pszMsg, pszServiceName, 
                                     MB_OK | MB_ICONSTOP, LANG_USER_DEFAULT);
                        CmFree(pszMsg);
                    }
                    return FALSE;
                }
            }
        }

    
        if ((ERROR_SUCCESS == hRes) && bReboot) 
        {
            if (OS_NT && (TRUE == IsServicePackInstalled()))
            {
                //
                // If service pack is installed, then display message asking
                // user to re-install the service pack and exit without rebooting
                // We do this because rebooting after installing RAS, without
                // reinstalling the service pack can cause BlueScreen!
                //
                DisplayMessageToInstallServicePack(hWndDlg, pszServiceName);
                return FALSE;
            }
            else
            {
                //
                // Display reboot message and is user wants reboot the sytem
                //
                LPTSTR pszMsg = CmFmtMsg(g_hInst,IDMSG_REBOOT_MSG);

                int iRes = IDNO;
                 
                if (pszMsg)
                {
                    iRes = MessageBoxEx(hWndDlg,
                                        pszMsg,
                                        pszServiceName,
                                        MB_YESNO | MB_DEFBUTTON1 | 
                                            MB_ICONWARNING | MB_SETFOREGROUND,
                                        LANG_USER_DEFAULT);

                    CmFree(pszMsg);
                }
                else
                {
                    CMASSERTMSG(FALSE, TEXT("InstallComponents: CmFmtMsg failed to load IDMSG_REBOOT_MSG"));
                }

                if (IDYES == iRes) 
                {
                    //
                    // Shutdown Windows, CM will quit gracefully on 
                    // WM_ENDSESSION message 
                    // What shall we do if MyExitWindowsEx() fialed
                    //
                    DWORD dwReason = OS_NT51 ? (SHTDN_REASON_MAJOR_APPLICATION | SHTDN_REASON_MINOR_RECONFIG) : 0;
                    MyExitWindowsEx(EWX_REBOOT, dwReason);

                    //
                    // Caller will return failed
                    //
                    return FALSE;
                }
                else
                {
                    //
                    // If user do not want to reboot, shall we quit CM
                    //
                }
            }
        }

        if (ERROR_SUCCESS == hRes)
        {
            return TRUE;
        }
    }
    
    //
    // Configuration check failed message, if install is not canceled
    //
    LPTSTR pszMsg = CmFmtMsg(g_hInst,IDMSG_CONFIG_FAILED_MSG);
    if (pszMsg)
    {
        MessageBoxEx(hWndDlg, pszMsg, pszServiceName, MB_OK|MB_ICONSTOP, 
                                LANG_USER_DEFAULT);
        CmFree(pszMsg);
    }
    else
    {
        CMASSERTMSG(FALSE, TEXT("InstallComponents: CmFmtMsg failed to load IDMSG_CONFIG_FAILED_MSG"));
    }

    return FALSE;
}

//+----------------------------------------------------------------------------
//  Function    ConfigSystem
//
//  Synopsis    Use inetcfg.dll to configure system settings, 
//              like install modem, rna etc.
//
//  Arguments   hWndDlg -       Window Handle of parent window
//              dwfOptions -    Components to be configured
//              pbReboot    -   Will be set to true if system has to rebooted
//                                  as result of the configuration
//
//  Returns     ERROR_SUCCESS if successful
//              Failure code otherwise
//
//  History     Old code        
//-----------------------------------------------------------------------------

HRESULT ConfigSystem(HWND hwndParent, 
                     DWORD dwfOptions, 
                     LPBOOL pbReboot) 
{
    HRESULT hRes = ERROR_SUCCESS;


    HINSTANCE hLibrary = NULL;
    HRESULT (WINAPI *pfn)(HWND,DWORD,LPBOOL);

    hLibrary = LoadInetCfg();
    if (!hLibrary) 
    {
        CMTRACE1(TEXT("ConfigSystem() LoadLibrary() failed, GLE=%u."), GetLastError());
        hRes = GetLastError();
        goto done;
    }
        
    pfn = (HRESULT (WINAPI *)(HWND,DWORD,LPBOOL)) GetProcAddress(hLibrary, "InetConfigSystem");
    if (!pfn) 
    {
        CMTRACE1(TEXT("ConfigSystem() GetProcAddress() failed, GLE=%u."), GetLastError());
        hRes = GetLastError();
        goto done;
    }
    
    hRes = pfn(hwndParent,dwfOptions,pbReboot);
#ifdef DEBUG
    if (hRes != ERROR_SUCCESS)
    {
        CMTRACE1(TEXT("ConfigSystem() InetConfigSystem() failed, GLE=%u."), hRes);
    }
#endif
    

done:
    if (hLibrary) 
    {
        FreeLibrary(hLibrary);
        hLibrary = NULL;
    }

    return (hRes);
}



//+----------------------------------------------------------------------------
//  Function    InetNeedSystemComponents
//
//  Synopsis    Use inetcfg.dll to check if we need to configure system settings 
//              like rna etc.
//
//  Arguments   dwfOptions -            Components to be configured
//              pbNeedSysComponents -   Will be set to true if we need to 
//                                          configure system settings
//
//  Returns     ERROR_SUCCESS if successful
//              Failure code otherwise
//
//  History     5/5/97  VetriV  Created     
//-----------------------------------------------------------------------------
HRESULT InetNeedSystemComponents(DWORD dwfOptions, 
                                    LPBOOL pbNeedSysComponents) 
{
    HRESULT hRes = ERROR_SUCCESS;

    HINSTANCE hLibrary = NULL;
    HRESULT (WINAPI *pfnInetNeedSystemComponents)(DWORD, LPBOOL);

    hLibrary = LoadInetCfg();
    if (!hLibrary) 
    {
        hRes = GetLastError();
        CMTRACE1(TEXT("InetNeedSystemComponents() LoadLibrary() failed, GLE=%u."), hRes);
        goto done;
    }
        
    pfnInetNeedSystemComponents = (HRESULT (WINAPI *)(DWORD,LPBOOL)) GetProcAddress(hLibrary, "InetNeedSystemComponents");
    if (!pfnInetNeedSystemComponents) 
    {
        hRes = GetLastError();
        CMTRACE1(TEXT("InetNeedSystemComponents() GetProcAddress() failed, GLE=%u."), hRes);
        goto done;
    }
    
    hRes = pfnInetNeedSystemComponents(dwfOptions, pbNeedSysComponents);
#ifdef DEBUG
    if (hRes != ERROR_SUCCESS)
    {
        CMTRACE1(TEXT("InetNeedSystemComponents() failed, GLE=%u."), hRes);
    }
#endif

done:
    if (hLibrary) 
    {
        FreeLibrary(hLibrary);
        hLibrary = NULL;
    }

    return (hRes);
}




//+----------------------------------------------------------------------------
//  Function    InetNeedModem
//
//  Synopsis    Use inetcfg.dll to check if we need to install/configure modem
//
//  Arguments   pbNeedModem -   Will be set to true if we need to 
//                                  install/configure modem
//
//  Returns     ERROR_SUCCESS if successful
//              Failure code otherwise
//
//  History     5/5/97  VetriV  Created     
//-----------------------------------------------------------------------------
HRESULT InetNeedModem(LPBOOL pbNeedModem) 
{
    HRESULT hRes = ERROR_SUCCESS;

    HINSTANCE hLibrary = NULL;
    HRESULT (WINAPI *pfnInetNeedModem)(LPBOOL);

    hLibrary = LoadInetCfg();
    if (!hLibrary) 
    {
        hRes = GetLastError();
        CMTRACE1(TEXT("InetNeedModem() LoadLibrary() failed, GLE=%u."), hRes);
        goto done;
    }
        
    pfnInetNeedModem = (HRESULT (WINAPI *)(LPBOOL)) GetProcAddress(hLibrary, "InetNeedModem");
    if (!pfnInetNeedModem) 
    {
        hRes = GetLastError();
        CMTRACE1(TEXT("InetNeedModem() GetProcAddress() failed, GLE=%u."), hRes);
        goto done;
    }
    
    hRes = pfnInetNeedModem(pbNeedModem);
#ifdef DEBUG
    if (hRes != ERROR_SUCCESS)
    {
        CMTRACE1(TEXT("InetNeedModem() failed, GLE=%u."), hRes);
    }
#endif

done:
    if (hLibrary) 
    {
        FreeLibrary(hLibrary);
        hLibrary = NULL;
    }

    return (hRes);
}

//+----------------------------------------------------------------------------
//  Function    DisplayMessageToInstallServicePack
//
//  Synopsis    Display a message to user informing them to reinstall 
//              Service Pack
//
//  Arguments   hWndParent  - Window handle to parent
//              pszServiceName - Service name for title
//
//  Returns     None
//
//  History     2/4/98  VetriV  Created     
//-----------------------------------------------------------------------------
void DisplayMessageToInstallServicePack(HWND hWndParent, LPCTSTR pszServiceName)
{
    LPTSTR pszMsg = CmFmtMsg(g_hInst,IDMSG_INSTALLSP_MSG);

    if (pszMsg)
    {
        MessageBoxEx(hWndParent, pszMsg, pszServiceName, MB_OK | MB_ICONINFORMATION, 
                                LANG_USER_DEFAULT);
        CmFree(pszMsg);
    }
    else
    {
        CMASSERTMSG(FALSE, TEXT("DisplayMessageToInstallServicePack: CmFmtMsg failed to load IDMSG_INSTALLSP_MSG"));
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmdial\connstat.cpp ===
//+----------------------------------------------------------------------------
//
// File:    ConnStat.cpp	 
//
// Module:  CMDIAL32.DLL
//
// Synopsis: Implementation of class CConnStatistics
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:	 Fengsun Created    10/15/97
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"
#include "ConnStat.h"

//
// Include the constants describing the reg keys used for perf stats
// 

#include "perf_str.h"

//
// Constructor and destructor
//

CConnStatistics::CConnStatistics()
{
    MYDBGASSERT(!OS_NT4); // class is never used on NT4

    m_hKey = NULL;
    m_dwInitBytesRead = -1;
    m_dwInitBytesWrite = -1;
    m_dwBaudRate = 0;

    m_pszTotalBytesRecvd = NULL; 
    m_pszTotalBytesXmit = NULL;
    m_pszConnectSpeed = NULL;
}

CConnStatistics::~CConnStatistics()
{
    CmFree( m_pszTotalBytesRecvd );
    CmFree( m_pszTotalBytesXmit );
    CmFree( m_pszConnectSpeed );
}

//+----------------------------------------------------------------------------
//
// Function:  CConnStatistics::GetStatRegValues
//
// Synopsis:  Helper method, builds the reg value names using the localized 
//            form of the word "Dial-up Adapter".
//
// Arguments: HINSTANCE hInst
//
// Returns:   Nothing
//
// History:   nickball      Created     11/14/98
//
//+----------------------------------------------------------------------------
void CConnStatistics::GetStatRegValues(HINSTANCE hInst)
{
    //
    // bug 149367 The word "Dial-up Adapter" need to be localized.  
    // Load it from resource if no loaded yet
    //

    if (m_pszTotalBytesRecvd == NULL)
    {
        m_pszTotalBytesRecvd = CmLoadString(hInst, IDS_REG_DIALUP_ADAPTER);
        CmStrCatAlloc(&m_pszTotalBytesRecvd, m_fAdapter2 ? c_pszDialup_2_TotalBytesRcvd : c_pszDialupTotalBytesRcvd);

        m_pszTotalBytesXmit = CmLoadString(hInst, IDS_REG_DIALUP_ADAPTER);
        CmStrCatAlloc(&m_pszTotalBytesXmit, m_fAdapter2 ? c_pszDialup_2_TotalBytesXmit : c_pszDialupTotalBytesXmit);

        m_pszConnectSpeed = CmLoadString(hInst, IDS_REG_DIALUP_ADAPTER);
        CmStrCatAlloc(&m_pszConnectSpeed, m_fAdapter2 ? c_pszDialup_2_ConnectSpeed : c_pszDialupConnectSpeed);
    }
}

//+---------------------------------------------------------------------------
//
//	Function:	InitStatistics()
//
//	Synopsis:	Retrieves Performance Data. On 9x this data is pulled from 
//              the registry. Defaults are used NT5. Not used on NT4.
//
//	Arguments:	None
//
//	Returns:	TRUE  if succeed
//				FALSE otherwise
//
//	History:	byao	    07/16/97    created		
//              fengsun     10/97       make it a member fuction 
//              nickball    03/04/98    always close key 
//              nickball   03/04/00    added NT5 support
//
//----------------------------------------------------------------------------
BOOL CConnStatistics::InitStatistics()
{
    if (OS_W9X)
    {
        MYDBGASSERT(NULL == m_hKey); // Not already opened

        if (m_hKey)
        {
            RegCloseKey(m_hKey);
            m_hKey = NULL;
        }

        DWORD dwErrCode;
        BOOL bRet = FALSE;

        //
        // If there is already a connected dial up connection
        // use the adapter#2 registry key
        //
        m_fAdapter2 = RasConnectionExists();

        dwErrCode = RegOpenKeyExU(HKEY_DYN_DATA, 
						          c_pszDialupPerfKey,
						          0, 
						          KEY_ALL_ACCESS, 
						          &m_hKey );
        CMTRACE1(TEXT("OpenDAPPerfKey() RegOpenKeyEx() returned GLE=%u."), dwErrCode);

        if ( dwErrCode != ERROR_SUCCESS )
        {
            m_hKey = NULL;
        }
        else
        {
            GetStatRegValues(g_hInst);

            //
            // Get the initial statistic info
            //

            if (!GetPerfData(m_dwInitBytesRead, m_dwInitBytesWrite, m_dwBaudRate))
            {
                //
                // No dial-up statistic info
                //
                RegCloseKey(m_hKey);
                m_hKey = NULL;
            }
        }
    
        return m_hKey != NULL;
    }
    else
    {
        //
        // On NT5, there is the starting bytes is always zero because 
        // numbers aren't available to us until the connection is up.
        // Note: Adapter2 indicates the reg key to be examined on 9x
        // it is a non-issue on NT.
        //
    
        m_fAdapter2 = FALSE;

        m_dwInitBytesRead = 0;
        m_dwInitBytesWrite = 0;    
    }

	return TRUE;
}

//+---------------------------------------------------------------------------
//
//	Function:	GetPerfData
//
//	Synopsis:	Get Performance Data from DUN1.2 performance registry
//
//	Arguments:	
//
//	Returns:	TRUE: succeed
//				FALSE otherwise
//
//	History:	byao	created		7/16/97
//              fengsun change it into a member function 10/14/97
//					
//----------------------------------------------------------------------------
BOOL CConnStatistics::GetPerfData(DWORD& dwRead, DWORD& dwWrite, DWORD& dwBaudRate) const
{
    MYDBGASSERT(m_hKey != NULL);
    MYDBGASSERT(m_pszTotalBytesRecvd && *m_pszTotalBytesRecvd);

    LONG dwErrCode;

    DWORD dwValueSize, dwValueType;
	DWORD dwValue;
    LPTSTR lpKeyName;

    //
    // "Dial-up Adapter\TotalBytesRecvd"
    //
    dwValueSize = sizeof(DWORD);
	dwErrCode = RegQueryValueExU(m_hKey,
                                 m_pszTotalBytesRecvd,
				                 NULL,
				                 &dwValueType,
				                 (PBYTE)&dwValue,
				                 &dwValueSize);

	if (dwErrCode == ERROR_SUCCESS) 
	{
		dwRead = dwValue;
    }
	else 
	{
		return FALSE;
	}


    //
    // "Dial-up Adapter\TotalBytesXmit"
    //
	
	dwValueSize = sizeof(DWORD);
	dwErrCode = RegQueryValueExU(m_hKey,
                                 m_pszTotalBytesXmit,
				                 NULL,
				                 &dwValueType,
				                 (PBYTE)&dwValue,
				                 &dwValueSize);

	if (dwErrCode == ERROR_SUCCESS) 
	{
		dwWrite = dwValue;
    }
	else 
	{
		return FALSE;
	}

    //
    // "Dial-up Adapter\ConnectSpeed"
    //
	dwValueSize = sizeof(DWORD);
	dwErrCode = RegQueryValueExU(m_hKey,
                                 m_pszConnectSpeed,
				                 NULL,
				                 &dwValueType,
				                 (PBYTE)&dwValue,
				                 &dwValueSize);

	if (dwErrCode == ERROR_SUCCESS) 
	{
		dwBaudRate = dwValue;
    }
	else 
	{
		return FALSE;
	}

	return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:  CConnStatistics::RasConnectionExists
//
// Synopsis:  Whether there is a connected ras connection running on Win9x.
//
// Arguments: None 
//
// Returns:   BOOL - TRUE if there is one up and connected
//
// History:   fengsun Created     1/15/98
//
//+----------------------------------------------------------------------------
BOOL CConnStatistics::RasConnectionExists()
{
    //
    // Try RasEnumConnections to find out active connections
    //

    HINSTANCE hRasInstance = LoadLibraryExA("RASAPI32", NULL, 0);

    MYDBGASSERT(hRasInstance);
    if (!hRasInstance)
	{
        return FALSE;
	}

    typedef DWORD (WINAPI *PFN_RasEnumConnections)(LPRASCONN, LPDWORD, LPDWORD);
	PFN_RasEnumConnections lpRasEnumConnections;

    lpRasEnumConnections = (PFN_RasEnumConnections)GetProcAddress(hRasInstance, "RasEnumConnectionsA");

    MYDBGASSERT(lpRasEnumConnections);
	if (!lpRasEnumConnections)
	{
        FreeLibrary(hRasInstance);
        return FALSE;
	}

    DWORD dwConnections = 0;
    DWORD dwSizeNeeded = 0;
    if (lpRasEnumConnections(NULL,&dwSizeNeeded,&dwConnections))
    {
        MYDBGASSERT(dwConnections < 2);
        if (dwConnections > 0)
        {
            FreeLibrary(hRasInstance);
            return TRUE;
        }
    }

    FreeLibrary(hRasInstance);
    return FALSE;
}

//+----------------------------------------------------------------------------
//
// Function:  CConnStatistics::Close
//
// Synopsis:  Stop gathering statistic and close the handle
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   Anonymous     Created Header          10/15/97
//            nickball      Reduced to close key    03/04/98
//
//+----------------------------------------------------------------------------
void CConnStatistics::Close()
{
	if (m_hKey)
	{
		DWORD dwErrCode = RegCloseKey(m_hKey);
		CMTRACE1(TEXT("Close() RegCloseKey() returned GLE=%u."), dwErrCode);
        m_hKey = NULL;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmdial\ctr.cpp ===
//+----------------------------------------------------------------------------
//
// File:     ctr.cpp     
//
// Module:   CMDIAL32.DLL
//
// Synopsis: Implements the Ole Container object for the future splash 
//           Animation control.
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   nickball Created    02/10/98
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"

/*
#define STRICT
*/

// macros used to reduce verbiage in RECT handling.

#define WIDTH(r)  (r.right - r.left)
#define HEIGHT(r) (r.bottom - r.top)

// max size for LoadString.

// string constants
const WCHAR g_awchHostName[] = L"ICM FS OC Container";

//+---------------------------------------------------------------------------
//
//  Function:   LinkToOle32
//
//  Synopsis:   Initializes the specified Ole32Linkage by linking to the DLL
//              specified in pszOle32 and retrieving the proc address for the 
//              functions that we need to call
//
//  Arguments:  pOle32Link - ptr to Ole32LinkagStruct
//              pszOl32     - ptr DLL name string
//
//  Returns:    TRUE    if SUCCESS
//              FALSE   otherwise.
//
//  History:    nickball    Created     8/14/97
//
//----------------------------------------------------------------------------

BOOL LinkToOle32(
    Ole32LinkageStruct *pOle32Link,
    LPCSTR pszOle32) 
{
    MYDBGASSERT(pOle32Link);
    MYDBGASSERT(pszOle32);
    
    LPCSTR apszOle32[] = {
        "OleInitialize",
        "OleUninitialize",
        "OleSetContainedObject",
        "CoCreateInstance",
        NULL
    };

    MYDBGASSERT(sizeof(pOle32Link->apvPfnOle32)/sizeof(pOle32Link->apvPfnOle32[0])==sizeof(apszOle32)/sizeof(apszOle32[0]));

    ZeroMemory(pOle32Link, sizeof(Ole32LinkageStruct));
    
    return (LinkToDll(&pOle32Link->hInstOle32,
                        pszOle32,
                        apszOle32,
                        pOle32Link->apvPfnOle32));
}

//+---------------------------------------------------------------------------
//
//  Function:   UnlinkFromOle32
//
//  Synopsis:   The reverse of LinkToOle32().
//
//  Arguments:  pOle32Link - ptr to Ole32LinkagStruct
//
//  Returns:    Nothing
//
//  History:    nickball    Created     8/14/97
//
//----------------------------------------------------------------------------

void UnlinkFromOle32(Ole32LinkageStruct *pOle32Link) 
{
    MYDBGASSERT(pOle32Link);

    if (pOle32Link->hInstOle32) 
    {
        FreeLibrary(pOle32Link->hInstOle32);
    }

    ZeroMemory(pOle32Link, sizeof(Ole32LinkageStruct));
}

VOID CleanupCtr(LPICMOCCtr pCtr)
{
    if (pCtr)
    {
        pCtr->ShutDown();
        pCtr->Release();
    }
}


// move (translate) the rectangle by (dx, dy)
inline VOID MoveRect(LPRECT prc, int dx, int dy)
{
    prc->left += dx;
    prc->right += dx;
    prc->top += dy;
    prc->bottom += dy;
}

const ULONG MAX_STATUS_TEXT = MAX_PATH;


//+--------------------------------------------------------------------------
//
//  Member:     CDynamicOleAut::CDynamicOleAut
//
//  Synopsis:   ctor for the Dynamic OleAut class 
//
//  Arguments:  None
//
//----------------------------------------------------------------------------

CDynamicOleAut::CDynamicOleAut()
{
    //
    // Setup OLEAUT32 linkage
    //

    LPCSTR apszOleAut[] = {
        "VariantClear",
        "VariantCopy",
        "VariantInit",
        "VariantChangeType",
        "SysAllocString",
        "SysFreeString",
        NULL
    };

    MYDBGASSERT(sizeof(m_OleAutLink.apvPfnOleAut)/sizeof(m_OleAutLink.apvPfnOleAut[0]) == 
                sizeof(apszOleAut)/sizeof(apszOleAut[0]));

    ZeroMemory(&m_OleAutLink, sizeof(m_OleAutLink));

    //
    // Do the link, but make it obvious if it fails
    //

    if (!LinkToDll(&m_OleAutLink.hInstOleAut, "OLEAUT32.DLL", 
                   apszOleAut, m_OleAutLink.apvPfnOleAut))     
    {
        if (m_OleAutLink.hInstOleAut)
        {
            FreeLibrary(m_OleAutLink.hInstOleAut);
        }
        ZeroMemory(&m_OleAutLink, sizeof(m_OleAutLink));    
    }

    MYDBGASSERT(m_OleAutLink.hInstOleAut);
}

//+--------------------------------------------------------------------------
//
//  Member:     CDynamicOleAut::~CDynamicOleAut
//
//  Synopsis:   dtor for the Dynamic OleAut class 
//
//  Arguments:  None
//
//----------------------------------------------------------------------------

CDynamicOleAut::~CDynamicOleAut()
{
    if (m_OleAutLink.hInstOleAut) 
    {
        FreeLibrary(m_OleAutLink.hInstOleAut);
    }
}

//+--------------------------------------------------------------------------
//
//  Member:     CDynamicOleAut::DynVariantClear
//
//  Synopsis:   Wrapper for VariantClear in OLEAUT32.DLL
//
//  Arguments:  See OLEAUT32.DLL documentation
//
//----------------------------------------------------------------------------

HRESULT
CDynamicOleAut::DynVariantClear(VARIANTARG FAR* pVar)
{
    if (NULL == m_OleAutLink.hInstOleAut || NULL == m_OleAutLink.pfnVariantClear)
    {
        return E_FAIL;
    }

    return m_OleAutLink.pfnVariantClear(pVar);    
}

//+--------------------------------------------------------------------------
//
//  Member:     CDynamicOleAut::DynVariantCopy
//
//  Synopsis:   Wrapper for VariantCopy in OLEAUT32.DLL
//
//  Arguments:  See OLEAUT32.DLL documentation
//
//----------------------------------------------------------------------------

HRESULT
CDynamicOleAut::DynVariantCopy(
    VARIANTARG FAR* pVar1, 
    VARIANTARG FAR* pVar2)
{
    if (NULL == m_OleAutLink.hInstOleAut || NULL == m_OleAutLink.pfnVariantCopy)
    {
        return E_FAIL;
    }

    return m_OleAutLink.pfnVariantCopy(pVar1, pVar2);    
}

//+--------------------------------------------------------------------------
//
//  Member:     CDynamicOleAut::DynVariantInit
//
//  Synopsis:   Wrapper for VariantInit in OLEAUT32.DLL
//
//  Arguments:  See OLEAUT32.DLL documentation
//
//----------------------------------------------------------------------------

VOID
CDynamicOleAut::DynVariantInit(VARIANTARG FAR* pVar)
{
    if (m_OleAutLink.hInstOleAut && m_OleAutLink.pfnVariantInit)
    {
        m_OleAutLink.pfnVariantInit(pVar);    
    }
}

//+--------------------------------------------------------------------------
//
//  Member:     CDynamicOleAut::DynVariantChangeType
//
//  Synopsis:   Wrapper for VariantChangeType in OLEAUT32.DLL
//
//  Arguments:  See OLEAUT32.DLL documentation
//
//----------------------------------------------------------------------------

HRESULT
CDynamicOleAut::DynVariantChangeType(
    VARIANTARG FAR* pVar1, 
    VARIANTARG FAR* pVar2, 
    unsigned short wFlags, 
    VARTYPE vt)
{
    if (NULL == m_OleAutLink.hInstOleAut || NULL == m_OleAutLink.pfnVariantChangeType)
    {
        return E_FAIL;
    }

    return m_OleAutLink.pfnVariantChangeType(pVar1, pVar2, wFlags, vt);    
}

//+--------------------------------------------------------------------------
//
//  Member:     CDynamicOleAut::DynSysAllocString
//
//  Synopsis:   Wrapper for SysAllocString in OLEAUT32.DLL
//
//  Arguments:  See OLEAUT32.DLL documentation
//
//----------------------------------------------------------------------------
    
BSTR 
CDynamicOleAut::DynSysAllocString(OLECHAR FAR* sz)
{
    if (NULL == m_OleAutLink.hInstOleAut || NULL == m_OleAutLink.pfnSysAllocString)
    {
        return NULL;
    }

    return m_OleAutLink.pfnSysAllocString(sz);
}

//+--------------------------------------------------------------------------
//
//  Member:     CDynamicOleAut::DynSysFreeString
//
//  Synopsis:   Wrapper for SysFreeString in OLEAUT32.DLL
//
//  Arguments:  See OLEAUT32.DLL documentation
//
//----------------------------------------------------------------------------

VOID 
CDynamicOleAut::DynSysFreeString(BSTR bstr)
{
    if (m_OleAutLink.hInstOleAut && m_OleAutLink.pfnSysFreeString)
    {
        m_OleAutLink.pfnSysFreeString(bstr);
    }
}
    
//+--------------------------------------------------------------------------
//
//  Member:     CDynamicOleAut::Initialized
//
//  Synopsis:   Simple query to report if linkage is valid
//
//  Arguments:  None
//
//----------------------------------------------------------------------------
BOOL 
CDynamicOleAut::Initialized()
{
    return (NULL != m_OleAutLink.hInstOleAut);    
}

//+--------------------------------------------------------------------------
//
//  Member:     CICMOCCtr::CICMOCCtr
//
//  Synopsis:   ctor for the OLE Controls container class.
//
//  Arguments:  [hWnd] -- hWnd for the main browser
//
//----------------------------------------------------------------------------
#pragma warning(disable:4355) // this used in initialization list
CICMOCCtr::CICMOCCtr(const HWND hWndMainDlg, const HWND hWndFrame) :
    m_hWndMainDlg(hWndMainDlg),
    m_hWndFrame(hWndFrame),
    m_CS(this),
    m_AS(this),
    m_IPF(this),
    m_IPS(this),
    m_OCtr(this),
    m_PB(this),
    m_pActiveObj(0),
    m_Ref(1),
    m_pUnk(0),
    m_pOC(0),
    m_pVO(0),
    m_pOO(0),
    m_pIPO(0),
    m_pDisp(0),
    m_state(OS_PASSIVE),
    m_dwMiscStatus(0),
    m_fModelessEnabled(TRUE)
{
    ::memset(&m_rcToolSpace, 0, sizeof m_rcToolSpace);
    InitPixelsPerInch(); // initialize the HIMETRIC routines

    // init all the state mappings to -1
    for (INT i = PS_Interactive; i < PS_Last; i++)
    {
        m_alStateMappings[i] = -1;
    }
}
#pragma warning(default:4355)

CICMOCCtr::~CICMOCCtr(VOID)
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CICMOCCtr::HasLinkage
//
//  Synopsis:   Initialize - verify that we have a link to OLEAUT32.DLL
//
//----------------------------------------------------------------------------
BOOL 
CICMOCCtr::Initialized(VOID)
{   
    return m_DOA.Initialized();
}

//+---------------------------------------------------------------------------
//
//  Member:     CICMOCCtr::ShutDown
//
//  Synopsis:   cleanup all the OLE stuff.
//
//----------------------------------------------------------------------------
VOID
CICMOCCtr::ShutDown(VOID)
{
    if (m_pOC)
        m_pOC->Release();
    if (m_pIPO)
    {
        MYDBGASSERT(m_state == OS_UIACTIVE || m_state == OS_INPLACE);
        if (m_state == OS_UIACTIVE)
        {
            m_pIPO->UIDeactivate();
            // m_state = OS_INPLACE; // for documentation purposes
            if (m_pActiveObj)
            {
                m_pActiveObj->Release();
                m_pActiveObj = 0;
            }
        }

        m_pIPO->InPlaceDeactivate();
        // m_state = OS_RUNNING;
    }
    if (m_pVO)
    {
        // kill the advisory connection
        m_pVO->SetAdvise(DVASPECT_CONTENT, 0, 0);
        m_pVO->Release();
    }
    if (m_pOO)
    {
        m_pOO->Close(OLECLOSE_NOSAVE);
        m_pOO->SetClientSite(0);
        m_pOO->Release();
    }
    if (m_pDisp)
        m_pDisp->Release();
    if (m_pUnk)
        m_pUnk->Release();

    MYDBGASSERT(!m_pActiveObj);

    m_pDisp      = 0;
    m_pOC        = 0;
    m_pIPO       = 0;
    m_pActiveObj = 0;
    m_pVO        = 0;
    m_pOO        = 0;
    m_pUnk       = 0;
    m_state      = OS_PASSIVE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CICMOCCtr::AddRef
//
//  Synopsis:   bump refcount up on container.  Note that all the
//              interfaces handed out delegate to this one.
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CICMOCCtr::AddRef(VOID)
{
    return ++m_Ref;
}

//+---------------------------------------------------------------------------
//
//  Member:     CICMOCCtr::Release
//
//  Synopsis:   decrement the refcount on container, and delete when it
//              hits 0 - note that all the interfaces handed out delegate
//              to this one.
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CICMOCCtr::Release(VOID)
{
    ULONG ulRC = --m_Ref;

    if (!ulRC)
    {
        delete this;
    }

    return ulRC;
}

//+---------------------------------------------------------------------------
//
//  Member:     CICMOCCtr::QueryInterface
//
//  Synopsis:   this is where we hand out all the interfaces.  All the
//              interfaces delegate back to this.
//
//  Arguments:  [riid] -- IID of interface desired.
//              [ppv]  -- interface returned.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
STDMETHODIMP
CICMOCCtr::QueryInterface(REFIID riid, LPVOID FAR * ppv)
{
    *ppv = 0;

    LPUNKNOWN pUnk;

    if (::IsEqualIID(riid, IID_IOleClientSite))
        pUnk = &m_CS;
    else if (::IsEqualIID(riid, IID_IAdviseSink))
        pUnk = &m_AS;
    else if (::IsEqualIID(riid, IID_IUnknown))
        pUnk = this;
    else if (::IsEqualIID(riid, IID_IOleInPlaceFrame) ||
             ::IsEqualIID(riid, IID_IOleInPlaceUIWindow))
        pUnk = &m_IPF;
    else if (::IsEqualIID(riid, IID_IOleInPlaceSite))
        pUnk = &m_IPS;
    else if (::IsEqualIID(riid, IID_IPropertyBag))
        pUnk = &m_PB;
    else
        return E_NOINTERFACE;

    pUnk->AddRef();

    *ppv = pUnk;

    return S_OK;
}


extern "C" CLSID const CLSID_FS =
{
    0xD27CDB6E,
    0xAE6D,
    0x11CF,
    { 0x96, 0xB8, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00 }
};

//+---------------------------------------------------------------------------
//
//  Member:     CICMOCCtr::CreateFSOC
//
//  Synopsis:   Creates an instance of the Future Splash OC, embedding it in
//              our container.  QIs for all the relevant pointers and
//              transitions the control to the UIActive state.
//
//  Arguments:  pOle32Link - ptr to Ole32LinkageStruct containing funtion 
//                           pointers to dynamically linked OLE32 DLL
//
//----------------------------------------------------------------------------
HRESULT
CICMOCCtr::CreateFSOC(Ole32LinkageStruct *pOle32Link)
{
    MYDBGASSERT(pOle32Link);

    HRESULT hr = -1;
    RECT    rc;
    LPPERSISTPROPERTYBAG pPPB = 0;

    // GetFrameWindow() also asserts that hwnd ::IsWindow()
    MYDBGASSERT(GetFrameWindow());

    //
    // Use dyna-linked CoCreateInstance to create the OC
    //

    if (pOle32Link->hInstOle32 && pOle32Link->pfnCoCreateInstance)
    {
        hr = pOle32Link->pfnCoCreateInstance(
                CLSID_FS,
                0,
                CLSCTX_INPROC_SERVER,
                IID_IUnknown,
                (LPVOID *) &m_pUnk);
    }
    else
    {
        hr = E_FAIL;
    }

    if (hr)
        goto Cleanup;

    m_state = OS_RUNNING;

    // get the View object - although we rarely draw the OC thru this.
    // since we immediately transition it to the UIActive state, it
    // usually draws itself through its own wndproc.
    hr = m_pUnk->QueryInterface(IID_IViewObject, (LPVOID FAR *) &m_pVO);
    if (hr)
        goto Cleanup;

    // get the IOleObject pointer - the main interface through which
    // we handle the basic OLE object state transition stuff
    // for the Future Splash OC
    hr = m_pUnk->QueryInterface(IID_IOleObject, (LPVOID FAR *) &m_pOO);
    if (hr)
        goto Cleanup;

    // get status bits on the OC - we're not currently doing anything
    // with them.
    hr = m_pOO->GetMiscStatus(DVASPECT_CONTENT, &m_dwMiscStatus);
    if (hr)
        goto Cleanup;

    // set our client site into the oleobject
    hr = m_pOO->SetClientSite(&m_CS);
    if (hr)
        goto Cleanup;

    hr = m_pUnk->QueryInterface(IID_IPersistPropertyBag, (LPVOID *) &pPPB);
    if (hr)
        goto Cleanup;

    hr = pPPB->Load(&m_PB, 0);
    if (hr)
        goto Cleanup;

    // set our advise sink into the view object, so we
    // get notifications that we need to redraw.
    hr = m_pVO->SetAdvise(DVASPECT_CONTENT, 0, &m_AS);
    if (hr)
        goto Cleanup;

    //
    // Use dyna-linked OleSetContainedObject
    //
    
    if (pOle32Link->hInstOle32 && pOle32Link->pfnOleSetContainedObject)
    {
        // standard OLE protocol stuff.
        hr = pOle32Link->pfnOleSetContainedObject(m_pUnk, TRUE);
    }
    else
    {
        hr = E_FAIL;
    }
    
    if (hr)
        goto Cleanup;

    // ditto
    hr = m_pOO->SetHostNames(g_awchHostName, 0);
    if (hr)
        goto Cleanup;

    // get the IDispatch for the control.  This is for late-bound
    // access to the properties and methods.
    hr = m_pUnk->QueryInterface(IID_IDispatch, (LPVOID FAR *) &m_pDisp);
    if (hr)
        goto Cleanup;

    // get the IOleControl interface; although we use it for very little.
    hr = m_pUnk->QueryInterface(IID_IOleControl, (LPVOID FAR *) &m_pOC);
    if (hr)
        goto Cleanup;

    // transition the control to the inplace-active state - it will have
    // an hWnd after it returns from DoVerb, and will begin drawing
    // itself.

    _GetDoVerbRect(&rc); // get rect for firing verbs.

    hr = m_pOO->DoVerb(OLEIVERB_INPLACEACTIVATE, 0, &m_CS, 0, GetMainWindow(), &rc);
    if (hr)
        goto Cleanup;

    // go ahead and UI activate it.  This will cause it to QI for our
    // IOleInPlaceFrame and call SetActiveObject, which we will store
    // in m_pActiveObj
    hr = m_pOO->DoVerb(OLEIVERB_UIACTIVATE, 0, &m_CS, 0, GetMainWindow(), &rc);
    if (hr)
        goto Cleanup;

Cleanup:
    if (pPPB)
        pPPB->Release();

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CICMOCCtr::_AdjustForTools
//
//  Synopsis:   adjusts the rect passed in for any toolspace claimed by the
//              FS OC.  Currently, the FS OC always just
//              passed in a rect with four zeros in it - but if it ever
//              does decide to do this, we're ready :).
//
//  Arguments:  [prc] -- the rect we want to reduce by the BORDERWIDTHS
//                       stored in m_rcToolSpace.
//
//----------------------------------------------------------------------------
VOID
CICMOCCtr::_AdjustForTools(LPRECT prc)
{
    prc->left += m_rcToolSpace.left;
    prc->top += m_rcToolSpace.top;
    prc->bottom -= m_rcToolSpace.bottom;
    prc->right -= m_rcToolSpace.right;
}

//+---------------------------------------------------------------------------
//
//  Member:     CICMOCCtr::GetSize
//
//  Synopsis:   returns the size, in pixels, of the FS OC.
//
//  Arguments:  [prc] --  returned size.
//
//----------------------------------------------------------------------------
HRESULT
CICMOCCtr::GetSize(LPRECT prc)
{
    MYDBGASSERT(m_pOO);
    HRESULT hr;

    // if we're inplace active, just ask the frame window.
    if (m_state >= OS_INPLACE)
    {
        MYDBGASSERT(m_pIPO);
        ::GetClientRect(GetFrameWindow(), prc);
        hr = S_OK;
    }
    else  // not inplace active - probably this is never hit.
    {
        SIZEL sizel;
        hr = m_pOO->GetExtent(DVASPECT_CONTENT, &sizel);
        if (!hr)
        {
            prc->left = 0;
            prc->top = 0;
            prc->right = ::HPixFromHimetric(sizel.cx);
            prc->bottom = ::VPixFromHimetric(sizel.cy);
        }
    }

    // adjust the borders for any tools that a UIActive object
    // wants to place there.
    if (!hr)
        _AdjustForTools(prc);

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CICMOCCtr::DoLayout
//
//  Synopsis:   manages the vertical layout of things -
//              sizes the OC container itself.
//
//  Arguments:  [cxMain] -- width
//              [cyMain] -- height
//
//----------------------------------------------------------------------------
VOID
CICMOCCtr::DoLayout(INT cxMain, INT cyMain)
{
    RECT rc;

    MYDBGASSERT(m_hWndFrame && ::IsWindow(m_hWndFrame));

    ::GetClientRect(m_hWndFrame, &rc);

    SetSize(&rc, TRUE);
}

HRESULT
CICMOCCtr::_SetExtent(LPRECT prc)
{
    SIZEL   sizel;
    HRESULT hr;

    sizel.cx = ::HimetricFromHPix(prc->right - prc->left);
    sizel.cy = ::HimetricFromVPix(prc->bottom - prc->top);

    MYDBGASSERT(m_pOO);

    hr = m_pOO->SetExtent(DVASPECT_CONTENT, &sizel);
    if (hr)
        goto cleanup;

    hr = m_pOO->GetExtent(DVASPECT_CONTENT, &sizel);
    if (hr)
        goto cleanup;

    prc->right = ::HPixFromHimetric(sizel.cx);
    prc->bottom = ::VPixFromHimetric(sizel.cy);

cleanup:
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CICMOCCtr::SetSize
//
//  Synopsis:   sets the size of the FS OC space (the HTML area)
//
//  Effects:    if fMoveFrameWindow is TRUE, then it moves the whole
//              framewindow around, otherwise, it just readjusts how much
//              of the framewindow space is used by the OC itself.
//              In reality, what happens is that the OC calls us to
//              set some border space (although at this writing it still
//              is setting BORDERWIDTHS of 0,0,0,0), we allow that
//              much space, then call IOleInPlaceObject->SetObjectRects
//              to resize the object to whatever's left.
//              Otherwise, if the object is not yet active, we just
//              call IOleObject::SetExtent().
//
//  Arguments:  [prc]              -- size to set object to
//              [fMoveFrameWindow] -- is the hwnd size changing, or just
//                                    the object within?
//
//
//----------------------------------------------------------------------------
HRESULT
CICMOCCtr::SetSize(LPRECT prc, BOOL fMoveFrameWindow)
{
    HRESULT hr;
    RECT    rcClient;
    RECT    rcExtent;

     // get client coords.
    rcClient = *prc;
    ::MoveRect(&rcClient, -rcClient.left, -rcClient.top);

    if (fMoveFrameWindow)
    {
        ::SetWindowPos(
                GetFrameWindow(),
                0,
                prc->left,
                prc->top,
                prc->right - prc->left,
                prc->bottom - prc->top,
                SWP_NOZORDER | SWP_NOACTIVATE);

         if (m_pActiveObj)
            m_pActiveObj->ResizeBorder(&rcClient, &m_IPF, TRUE);
    }

    // subtract off any tools the client has around .
    _AdjustForTools(&rcClient);

    rcExtent = rcClient;
    hr = _SetExtent(&rcExtent);
    if (hr)
        goto cleanup;

    // now we need to call SetObjectRects
    if (m_pIPO && m_state >= OS_INPLACE)
        hr = m_pIPO->SetObjectRects(&rcExtent, &rcClient);

cleanup:
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CICMOCCtr::Paint
//
//  Synopsis:   Paint with no parameters
//
//----------------------------------------------------------------------------
VOID
CICMOCCtr::Paint(VOID)
{
    PAINTSTRUCT ps;
    RECT        rc;

    // we don't need to call IViewObject if the object is activated.
    // it's got an hWnd and is receiving paint messages of its own.
    if (m_state < OS_INPLACE)
    {
        if (!GetSize(&rc))
        {
            ::BeginPaint(GetFrameWindow(), &ps);
              Paint(ps.hdc, &rc);
            ::EndPaint(GetFrameWindow(), &ps);
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CICMOCCtr::Paint
//
//  Synopsis:   paint with the hdc and rect passed in.  Uses
//              IViewObject::Draw()
//
//  Arguments:  [hDC] -- dc to draw to - can be container's or
//                       even print dc (never is a print dc in
//                       our scenario -
//              [lpr] -- rect for painting.
//
//----------------------------------------------------------------------------
VOID
CICMOCCtr::Paint(HDC hDC, LPRECT lpr)
{
    // adjust the borders in to allow for any tools the OC
    // wanted to insert - so far it never does.
    _AdjustForTools(lpr);

    // have to use a RECTL instead of RECT - remnant of the
    // OLE 16 bit days.
    RECTL rcl = {lpr->left, lpr->top, lpr->right, lpr->bottom};
    if (m_pVO)
        m_pVO->Draw(DVASPECT_CONTENT, -1, 0, 0, 0, hDC, &rcl, 0, 0, 0);
}


VOID
CICMOCCtr::MapStateToFrame(ProgState ps)
{
    // if the statemappings are -1, they are unitialized, don't use them.
    LONG lFrame = m_alStateMappings[ps];
    if (-1 != lFrame)
        SetFrame(lFrame);  // ignore error - nothing we can do.
}


HRESULT
CICMOCCtr::SetFrame(LONG lFrame)
{
    HRESULT    hr;
    OLECHAR *  pFrameNum = OLESTR("FrameNum");
    OLECHAR *  pPlay     = OLESTR("Play");
    DISPPARAMS dp = {0, 0, 0, 0};
    DISPID     dispidPut = DISPID_PROPERTYPUT;
    VARIANTARG var;
    EXCEPINFO  ei;
    DISPID     id;
    UINT       uArgErr;

    m_DOA.DynVariantInit(&var);

    V_VT(&var) = VT_I4;
    V_I4(&var) = lFrame;

    dp.cArgs = 1;
    dp.rgvarg = &var;
    dp.cNamedArgs = 1;
    dp.rgdispidNamedArgs = &dispidPut;

    hr =  m_pDisp->GetIDsOfNames(
                  IID_NULL,
                  &pFrameNum,
                  1,
                  LOCALE_SYSTEM_DEFAULT,
                  &id);

    if (hr)
        goto Cleanup;

    hr = m_pDisp->Invoke(
                 id,
                 IID_NULL,
                 LOCALE_SYSTEM_DEFAULT,
                 DISPATCH_PROPERTYPUT,
                 &dp,
                 0,
                 &ei,
                 &uArgErr);

    if (hr)
        goto Cleanup;

    hr = m_pDisp->GetIDsOfNames(
                  IID_NULL,
                  &pPlay,
                  1,
                  LOCALE_SYSTEM_DEFAULT,
                  &id);

    if (hr)
        goto Cleanup;

    ::memset(&dp, 0, sizeof dp);

    hr = m_pDisp->Invoke(
                  id,
                  IID_NULL,
                  LOCALE_SYSTEM_DEFAULT,
                  DISPATCH_METHOD,
                  &dp,
                  0,
                  &ei,
                  &uArgErr);

    if (hr)
        goto Cleanup;

Cleanup:
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CICMOCCtr::OnActivateApp
//
//  Synopsis:   all WM_ACTIVATE messages (forwarded from
//              main browser hWnd wndproc) must call
//              IOleInPlaceActiveObject::OnFrameWindowActivate(),
//              per the OLE compound document spec.
//
//  Arguments:  [wParam] -- whatever the WM_ACTIVATE msg passed
//              [lParam] -- ditto
//
//  Returns:    0 - to say we handled the message.
//
//----------------------------------------------------------------------------
LRESULT
CICMOCCtr::OnActivateApp(WPARAM wParam, LPARAM lParam)
{
    if (m_pActiveObj)
        m_pActiveObj->OnFrameWindowActivate((BOOL)wParam);

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CICMOCCtr::SetFocus
//
//  Synopsis:   transfers focus from framewindow to the current
//              in-place active object.  Per OLE Compound Document spec.
//
//----------------------------------------------------------------------------
LRESULT
CICMOCCtr::SetFocus(VOID)
{
    HWND hWnd   = NULL;
    LPOLEINPLACEACTIVEOBJECT pAO = GetIPAObject();

    if (pAO)
    {
        if (!pAO->GetWindow(&hWnd))
        {
            if (hWnd && !::IsWindow(hWnd))
                hWnd = NULL;
        }
    }

    // if no inplaceactive object, set focus to frame window.
    if (!hWnd)
        hWnd = GetFrameWindow();

    ::SetFocus(hWnd);
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Class:      CAdviseSink implementations
//
//  Purpose:    to implement IAdviseSink for CICMOCCtr
//
//  Notes:      we don't do much with this interface - it's required
//              for contractual reasons only.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CAdviseSink::QueryInterface(REFIID riid, LPVOID FAR * ppv)
{
    return m_pCtr->QueryInterface(riid, ppv);
}

STDMETHODIMP_(ULONG)
CAdviseSink::AddRef(VOID)
{
    return m_pCtr->AddRef();
}

STDMETHODIMP_(ULONG)
CAdviseSink::Release(VOID)
{
    return m_pCtr->Release();
}

CAdviseSink::CAdviseSink(LPICMOCCtr pCtr) : m_pCtr(pCtr)
{
}

STDMETHODIMP_(VOID)
CAdviseSink::OnDataChange(LPFORMATETC pFEIn, LPSTGMEDIUM pSTM)
{
    return;
}

//+---------------------------------------------------------------------------
//
//  Member:     CAdviseSink::OnViewChange
//
//  Synopsis:   IAdviseSink::OnViewChange() - we do get called with this
//              occasionally, but it appears that we're better off just
//              letting the control's wndproc paint it.
//              Calling this was causing extra flicker.
//
//----------------------------------------------------------------------------
STDMETHODIMP_(VOID)
CAdviseSink::OnViewChange(DWORD dwAspect, LONG lIndex)
{
    return;
}

STDMETHODIMP_(VOID)
CAdviseSink::OnRename(LPMONIKER pmk)
{

}

STDMETHODIMP_(VOID)
CAdviseSink::OnSave(VOID)
{

}

STDMETHODIMP_(VOID)
CAdviseSink::OnClose(VOID)
{
}

//+---------------------------------------------------------------------------
//
//  Class:      COleClientSite ()
//
//  Purpose:    our implementation of IOleClientSite
//
//  Interface:  COleClientSite         -- ctor
//              QueryInterface         -- gimme an interface!
//              AddRef                 -- bump up refcount
//              Release                -- bump down refcount
//              SaveObject             -- returns E_FAIL
//              GetMoniker             -- E_NOTIMPL
//              GetContainer           -- returns our COleContainer impl
//              ShowObject             -- just say OK
//              OnShowWindow           -- just say OK
//              RequestNewObjectLayout -- E_NOTIMPL
//
//  Notes:      probably the most important thing our IOleClientSite
//              implementation does is hand off our IOleContainer
//              implementation when GetContainer() is called.
//
//----------------------------------------------------------------------------
COleClientSite::COleClientSite(LPICMOCCtr pCtr) : m_pCtr(pCtr)
{
}

STDMETHODIMP
COleClientSite::QueryInterface(REFIID riid, LPVOID FAR * ppv)
{
    return m_pCtr->QueryInterface(riid, ppv);
}

STDMETHODIMP_(ULONG)
COleClientSite::AddRef(VOID)
{
    return m_pCtr->AddRef();
}

STDMETHODIMP_(ULONG)
COleClientSite::Release(VOID)
{
    return m_pCtr->Release();
}

//+---------------------------------------------------------------------------
//
//  Member:     COleClientSite::SaveObject
//
//  Synopsis:   not implemented - makes no sense in this scenario.
//
//----------------------------------------------------------------------------
STDMETHODIMP
COleClientSite::SaveObject(VOID)
{
    return E_FAIL;
}

//+---------------------------------------------------------------------------
//
//  Member:     COleClientSite::GetMoniker
//
//  Synopsis:   Not yet implemented; never will be implemented.
//
//----------------------------------------------------------------------------
STDMETHODIMP
COleClientSite::GetMoniker(DWORD dwAssign, DWORD dwWhich, LPMONIKER FAR * ppmk)
{
    *ppmk = 0;
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
//  Member:     COleClientSite::GetContainer
//
//  Synopsis:   returns our implementation of IOleContainer.  For some
//              reason, unless we do this, frames don't work.  Note that
//              our IOleContainer implementation is stubbed out with
//              E_NOTIMPL (it seems kind of odd to implement this for
//              a container with one embedding).  But it turns out the
//              FS OC has a bug in it's error handling - it
//              QIs for IOleContainer, then QIs from that for
//              IQueryService.  In truth, we'll hand out our implementation
//              of IQueryService, from any interface - we're easy :).
//              We *want* to provide every service the OC asks for.
//              Anyway, when it can't get IOleContainer, the OC's failure
//              path seems to be constructed in such a way that frames
//              don't work thereafter.
//
//  Arguments:  [ppCtr] -- returned IOleContainer
//
//  Returns:    S_OK.  Never fails.
//
//----------------------------------------------------------------------------
STDMETHODIMP
COleClientSite::GetContainer(LPOLECONTAINER FAR * ppCtr)
{
    *ppCtr = &m_pCtr->m_OCtr;
    (*ppCtr)->AddRef();

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     COleClientSite::ShowObject
//
//  Synopsis:   IOleClientSite::ShowObject implementation.  To quote the docs:
//              "Tells the container to position the object so it is visible
//              to the user. This method ensures that the container itself
//              is visible and not minimized."
//
//              In short, we ignore it.  We're not going to un-minimize
//              the container on the embeddings' whim :).
//
//----------------------------------------------------------------------------
STDMETHODIMP
COleClientSite::ShowObject(VOID)
{
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     COleClientSite::OnShowWindow
//
//  Synopsis:   fine with us, return S_OK.
//
//----------------------------------------------------------------------------
STDMETHODIMP
COleClientSite::OnShowWindow(BOOL bShow)
{
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     COleClientSite::RequestNewObjectLayout
//
//  Synopsis:   not being called by WebBrower OC, so do not implement.
//
//----------------------------------------------------------------------------
STDMETHODIMP
COleClientSite::RequestNewObjectLayout(VOID)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CInPlaceFrame::CInPlaceFrame
//
//  Synopsis:   inits m_pCtr - pointer to MSNOCCtr
//
//----------------------------------------------------------------------------
CInPlaceFrame::CInPlaceFrame(LPICMOCCtr pCtr) : m_pCtr(pCtr)
{
}

STDMETHODIMP
CInPlaceFrame::QueryInterface(REFIID riid, LPVOID FAR * ppv)
{
    return m_pCtr->QueryInterface(riid, ppv);
}

STDMETHODIMP_(ULONG)
CInPlaceFrame::AddRef(VOID)
{
    return m_pCtr->AddRef();
}

STDMETHODIMP_(ULONG)
CInPlaceFrame::Release(VOID)
{
    return m_pCtr->Release();
}

// IOleWindow stuff

//+---------------------------------------------------------------------------
//
//  Member:     CInPlaceFrame::GetWindow
//
//  Synopsis:   returns frame window
//
//  Arguments:  [phwnd] -- place to return window
//
//----------------------------------------------------------------------------
STDMETHODIMP
CInPlaceFrame::GetWindow(HWND * phwnd)
{
    MYDBGASSERT(phwnd);

    // this can never fail if we've gotten this far.
    *phwnd = m_pCtr->GetFrameWindow();
    MYDBGASSERT(*phwnd);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CInPlaceFrame::ContextSensitiveHelp
//
//  Synopsis:   This is not implemented by design - this is for
//              the SHift+F1 context sensitive help mode and Esc
//              to exit.  Esc is already being used in the main
//              accelerator table to mean 'stop browsing' to be
//              like IE3.  We do not do help this way.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CInPlaceFrame::ContextSensitiveHelp(BOOL fEnterMode)
{
    return E_NOTIMPL;
}

// IOleInPlaceUIWindow stuff

//+---------------------------------------------------------------------------
//
//  Member:     CInPlaceFrame::GetBorder
//
//  Synopsis:   IOleInPlaceFrame::GetBorder() - let's us restrict where
//              the server can put tools.  We don't care, they can put
//              them anywhere.
//
//  Arguments:  [lprectBorder] -- return border info in here.
//
//  Returns:    S_OK always with entire frame client rect -
//              we place no restrictions.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CInPlaceFrame::GetBorder(LPRECT lprectBorder)
{
    // we have no restrictions about where the server can put tools.
    ::GetClientRect(m_pCtr->GetFrameWindow(), lprectBorder);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CInPlaceFrame::RequestBorderSpace
//
//  Synopsis:   IOleInPlaceFrame::RequestBorderSpace()
//              inplace object actually requests border space - if
//              we can satisfy the request, we return S_OK, otherwise
//              INPLACE_E_NOTOOLSPACE.  It doesn't actually use the
//              borderspace until it calls
//              IOleInPlaceFrame::SetBorderSpace().  This is used for
//              negotiation.
//
//  Arguments:  [pborderwidths] -- structure (actually a RECT) that is
//                                 interpreted differently from a RECT.
//                                 The left.top.bottom.right members
//                                 represent space on each of our four
//                                 borders the server would like to use.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
STDMETHODIMP
CInPlaceFrame::RequestBorderSpace(LPCBORDERWIDTHS pborderwidths)
{
    RECT rc;
    RECT rcBorder;

    if (!pborderwidths)
        return S_OK;   // they're telling us no toolspace necessary.

    rcBorder = *pborderwidths;

    if (GetBorder(&rc))
        return INPLACE_E_NOTOOLSPACE;

    if (rcBorder.left + rcBorder.right > WIDTH(rc) ||
        rcBorder.top + rcBorder.bottom > HEIGHT(rc))
        return INPLACE_E_NOTOOLSPACE;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CInPlaceFrame::SetBorderSpace
//
//  Synopsis:   Sets border space for tools - for some reason, the
//              FS OC always calls this with a pborderwidths
//              consisting of four zeros - it never actually uses any
//              border space (sigh).  Well, the code is here for this
//              to work.  We do a SetSize() to relayout stuff when
//              it does this.
//
//  Arguments:  [pborderwidths] --  space the OC wants to use.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
STDMETHODIMP
CInPlaceFrame::SetBorderSpace(LPCBORDERWIDTHS pborderwidths)
{
    RECT rc;

    if (!pborderwidths)
    {
        ::memset(&m_pCtr->m_rcToolSpace, 0, sizeof m_pCtr->m_rcToolSpace);
        return S_OK;
    }

    if (RequestBorderSpace(pborderwidths))
        return OLE_E_INVALIDRECT;

    // we get the entire client space to pass to setSize().
    ::GetClientRect(m_pCtr->GetFrameWindow(), &rc);
     m_pCtr->m_rcToolSpace = *pborderwidths;

    return m_pCtr->SetSize(&rc, FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CInPlaceFrame::SetActiveObject
//
//  Synopsis:   IOleInPlaceFrame::SetActiveObject().  The server calls
//              this normally whenever it transitions to the UIActive
//              state.  There can only be one UIActive object at a time.
//              This UIACtive object is represented by its
//              IOleInPlaceActiveObject implementation.  We call this
//              object's implementation of TranslateAccelerator() right
//              in the main message loop to give the current embedding
//              first shot at keyboard messages.
//
//              Normally, this is only called when the container transitions
//              an object to UIActive by calling
//              IOleObject::DoVerb(OLEIVERB_UIACTIVE) for the object,
//              transitioning all the other objects (we don't have any :))
//              to OS_INPLACE (if they're OLEMISC_ACTIVATEWHENVISIBLE is set)
//              or even just OS_RUNNING.
//
//  Effects:    sets a new active object in m_pActiveObj.  Releases the
//              old one, if any.
//
//  Arguments:  [pActiveObject] -- new active object
//              [pszObjName]    -- name of object - we don't use this.
//
//  Returns:    S_OK always.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CInPlaceFrame::SetActiveObject(
        IOleInPlaceActiveObject * pActiveObject,
        LPCOLESTR                 pszObjName)
{
    // reset the toolspace rect in case the last inplacactive object
    // forgot to.
    m_pCtr->_ResetToolSpace();

    // if it was already set, save it so we can release
    // it.  We don't want to release it before we addref
    // the new one in case they're the same thing.
    LPOLEINPLACEACTIVEOBJECT pOld = m_pCtr->m_pActiveObj;

    m_pCtr->m_pActiveObj = pActiveObject;
    if (pActiveObject)
    {
        MYDBGASSERT(OS_UIACTIVE == m_pCtr->GetState());
        m_pCtr->m_pActiveObj->AddRef();
    }

    if (pOld)
        pOld->Release();

    return S_OK;
}

// IOleInPlaceFrame stuff
//+---------------------------------------------------------------------------
//
//  Member:     CInPlaceFrame::InsertMenus
//
//  Synopsis:   OC calling us when it wants to do menu negotiation
//              It calls us with a blank hmenu that we're supposed to
//              add items to and fille out the OLEMENUGROUPWIDTHS
//              structure to let it know what we did.
//              We're not adding items to it currently.
//
//  Arguments:  [hmenuShared] -- menu to append to
//              [pMGW]        -- OLEMENUGROUPWIDTHS struct to fill out.
//
//  Returns:    S_OK
//
//
//  Note:       OC doesn't call this.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CInPlaceFrame::InsertMenus(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS pMGW)
{
    // we're not inserting anything of our own to this menu.
    pMGW->width[0] = 0;  // 'File' menu
    pMGW->width[2] = 0;  // 'View' menu
    pMGW->width[4] = 0;  // 'Window' menu
    pMGW->width[5] = 0;  // 'Help' menu

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CInPlaceFrame::SetMenu
//
//  Synopsis:   This is the OC calling the container asking us to
//              set the shared menu in its frame.  We're supposed to
//              use the HOLEMENU object passed in and the
//              hWndActiveObject to call OleSetMenuDescriptor() so
//              that OLE can do message filtering and route WM_COMMAND
//              messages.
//
//
//  Arguments:  [hmenuShared]      --  shared menu.
//              [holemenu]         --  ole menu descriptor thingy
//              [hwndActiveObject] --  hwnd of server who's merging menus
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
STDMETHODIMP
CInPlaceFrame::SetMenu(HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject)
{
    // we're not doing any menu negotiation
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CInPlaceFrame::RemoveMenus
//
//  Synopsis:   IOleInPlaceFrame::RemoveMenus(), this is where the
//              server gives us a chance to remove all our items from
//              the hMenu.  We're not adding any, so we don't remove any.
//
//  Arguments:  [hmenuShared] -- menu to clean up.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CInPlaceFrame::RemoveMenus(HMENU hmenuShared)
{
    // we aren't adding anything to this thing anyway.
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CInPlaceFrame::SetStatusText
//
//  Synopsis:   called by the FS OC to put text in our status
//              text area.
//
//  Returns:    HRESULT
//
//  Arguments:  [pszStatusText] -- text to display
//
//----------------------------------------------------------------------------
STDMETHODIMP
CInPlaceFrame::SetStatusText(LPCOLESTR pszStatusText)
{
    return m_pCtr->_DisplayStatusText(pszStatusText);
}

//+---------------------------------------------------------------------------
//
//  Member:     CICMOCCtr::_DisplayStatusText
//
//  Synopsis:   helper that displays status text.
//
//  Arguments:  [pszStatusText] -- text to display
//
//
//  Returns:    S_OK or HRESULT_FROM_WIN32(::GetLastError());
//
//----------------------------------------------------------------------------
HRESULT
CICMOCCtr::_DisplayStatusText(LPCOLESTR pszStatusText)
{
    CHAR ach[MAX_STATUS_TEXT];

    if (::WideCharToMultiByte(
            CP_ACP,
            0,
            pszStatusText,
            -1,
            ach,
            NElems(ach),
            0,
            0))
    {
        // put the status text somewhere.
        return S_OK;
    }
    else
    {
        return HRESULT_FROM_WIN32(::GetLastError());
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CInPlaceFrame::EnableModeless
//
//  Synopsis:   this is called by the embedding to let us know it's
//              putting up a modal dialog box - we should 'grey' out
//              any of our modeless dialogs.  It delegates to
//              CICMOCCtr::EnableModeless()
//
//  Arguments:  [fEnable] -- enable or disable.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CInPlaceFrame::EnableModeless(BOOL fEnable)
{
    return m_pCtr->EnableModeless(fEnable);
}

//+---------------------------------------------------------------------------
//
//  Member:     CICMOCCtr::EnableModeless
//
//  Synopsis:   delegated to from CInPlaceFrame::EnableModeless().
//              always returns S_OK - we don't have any modeless
//              dialogs (yet).
//
//  Arguments:  [fEnable] -- enable or disable.
//
//  Returns:    S_OK
//
//----------------------------------------------------------------------------
HRESULT
CICMOCCtr::EnableModeless(BOOL fEnable)
{
    m_fModelessEnabled = fEnable;  // in case anyone wants to know.
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CInPlaceFrame::TranslateAccelerator
//
//  Synopsis:   The current active object's
//              IOleInPlaceActiveObject::TranslateAccelerator() is being
//              called at the top of our main message loop.  If it
//              does *not* want to handle a message, it will call
//              this method of ours to pass the keyboard message back to
//              us.  We call ::TranslateAccelerator on the global main
//              haccel, and, if it's handled (by returning TRUE - 1),
//              we indicate it's handled by returning S_OK (0 :).
//              On the other hand, if it's *not* handled, we return
//              S_FALSE.
//
//  Arguments:  [lpmsg] -- keyboard msg to handle
//              [wID]   -- command identifier value - per spec.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
STDMETHODIMP
CInPlaceFrame::TranslateAccelerator(LPMSG lpmsg, WORD wID)
{
    // note this should never be called - only local servers
    // (out of process) should call this by using
    // OleTranslateAccelerator().
    return m_pCtr->_TransAccelerator(lpmsg, wID);
}

//+---------------------------------------------------------------------------
//
//  Member:     CICMOCCtr::_TransAccelerator
//
//  Synopsis:   handle accelerator messages coming from
//              either IOleInplaceFrame::TranslateAccelerator, or
//              IOleControlSite::TranslateAccelerator.
//
//  Effects:    forwards them to the main accelerator table.
//
//  Arguments:  [lpmsg] -- keyboard msg.
//              [wID]   -- per spec.
//
//  Returns:    S_OK if we handled it, S_FALSE otherwise.
//
//----------------------------------------------------------------------------
HRESULT
CICMOCCtr::_TransAccelerator(LPMSG lpmsg, WORD wID)
{
    // the docs suggest that this method might need to return E_INVALIDARG.
    // anyway, this is defensive.  If the FS OC
    // calls us with an 0 ptr, we just return error
    if (!lpmsg)
        return E_INVALIDARG;

    // forward the keystroke to the main accelerator table, if you have one.
    // if you handle it, say S_OK.

#if 0
    // this sample has no main accelerator table.
    if (::TranslateAccelerator(GetMainWindow(),GetMainAccel(), lpmsg))
    {
        return S_OK;      // we handled it
    }
    else
#endif
    {
        return S_FALSE;   // we didn't.
    }
}

//+---------------------------------------------------------------------------
//
//  Class:      CInPlaceSite ()
//
//  Purpose:    IOleInPlaceSite implementation.
//
//  Interface:  CInPlaceSite         -- ctor
//              QueryInterface       -- get a new interface
//              AddRef               -- bump ref count
//              Release              -- decrement ref count
//              GetWindow            -- returns frame window
//              ContextSensitiveHelp -- not implemented by design
//              CanInPlaceActivate   -- returns S_OK.
//              OnInPlaceActivate    -- caches IOleInPlaceObject ptr
//              OnUIActivate         -- returns S_OK  - sets state
//              GetWindowContext     -- returns IOleInPlaceFrame,
//                                              IOleInPlaceUIWindow,
//                                              PosRect and ClipRect
//              Scroll               -- not implemented ever
//              OnUIDeactivate       -- kills objmenu
//              OnInPlaceDeactivate  -- releases cached IOleInPlaceObject
//              DiscardUndoState     -- returns S_OK
//              DeactivateAndUndo    -- deactivates in place active object
//              OnPosRectChange      -- never implemented.
//
//----------------------------------------------------------------------------
CInPlaceSite::CInPlaceSite(LPICMOCCtr pCtr) : m_pCtr(pCtr)
{
}

STDMETHODIMP
CInPlaceSite::QueryInterface(REFIID riid, LPVOID FAR * ppv)
{
    return m_pCtr->QueryInterface(riid, ppv);
}

STDMETHODIMP_(ULONG)
CInPlaceSite::AddRef(VOID)
{
    return m_pCtr->AddRef();
}

STDMETHODIMP_(ULONG)
CInPlaceSite::Release(VOID)
{
    return m_pCtr->Release();
}

CPropertyBag::CPropertyBag(LPICMOCCtr pCtr) : m_pCtr(pCtr)
{

}

CPropertyBag::~CPropertyBag(VOID)
{
    for (INT i = 0; i < m_aryBagProps.Size(); i++)
    {
        m_pCtr->m_DOA.DynSysFreeString(m_aryBagProps[i].bstrName);
        m_pCtr->m_DOA.DynVariantClear(&m_aryBagProps[i].varValue);
    }
}

STDMETHODIMP
CPropertyBag::QueryInterface(REFIID riid, LPVOID FAR * ppv)
{
    return m_pCtr->QueryInterface(riid, ppv);
}

STDMETHODIMP_(ULONG)
CPropertyBag::AddRef(VOID)
{
    return m_pCtr->AddRef();
}

STDMETHODIMP_(ULONG)
CPropertyBag::Release(VOID)
{
    return m_pCtr->Release();
}


static LONG
LongFromValue(LPTSTR sz)
{
    if (CmIsDigit(sz))
        return CmAtol(sz);

    return -1;
}


HRESULT
CPropertyBag::AddPropertyToBag(LPTSTR szName, LPTSTR szValue)
{
    BagProp bp;
    HRESULT hr;
    LONG    lValue;
    LPWSTR  pawch;
    //WCHAR   awch[INTERNET_MAX_URL_LENGTH] = {0};

    // initialize so error cleanup can work properly.
    bp.bstrName = 0;
    
    m_pCtr->m_DOA.DynVariantInit(&bp.varValue);

    if (!(pawch = (LPWSTR)CmMalloc(INTERNET_MAX_URL_LENGTH*sizeof(WCHAR))))
    {
        goto MemoryError;
    }

    //if (-1 == ::mbstowcs(awch, szName, NElems(awch)))
#ifndef UNICODE
    if (!MultiByteToWideChar(CP_ACP, 0, szName, -1, pawch, INTERNET_MAX_URL_LENGTH)) // NElems(awch)))
    {
        hr = E_FAIL;
        goto Error;
    }
#else
    lstrcpyU(pawch, szName);
#endif

    bp.bstrName = m_pCtr->m_DOA.DynSysAllocString(pawch);

    if (!bp.bstrName)
        goto MemoryError;

    // see if it's a VT_I4.
    lValue = ::LongFromValue(szValue);

    // it's a VT_BSTR - probably most common case
    if (-1 == lValue)
    {
        //if (-1 == ::mbstowcs(awch, szValue, NElems(awch)))
#ifndef UNICODE
        if (!MultiByteToWideChar(CP_ACP, 0, szValue, -1, pawch, INTERNET_MAX_URL_LENGTH)) // NElems(awch)))
        {
            hr = E_FAIL;
            goto Error;
        }
#else
        lstrcpyU(pawch, szValue);
#endif

        V_VT(&bp.varValue) = VT_BSTR;
        
        V_BSTR(&bp.varValue) = m_pCtr->m_DOA.DynSysAllocString(pawch);
        
        if (!V_BSTR(&bp.varValue))
            goto MemoryError;
    }
    else  // it's a VT_I4
    {
        V_VT(&bp.varValue) = VT_I4;
        V_I4(&bp.varValue) = lValue;
    }

    hr = m_aryBagProps.AppendIndirect(&bp);
    if (hr)
        goto Error;

Cleanup:
    if (pawch)
    {
        CmFree(pawch);
    }
    return hr;

MemoryError:
    hr = E_OUTOFMEMORY;

Error:
    if (bp.bstrName)
            m_pCtr->m_DOA.DynSysFreeString(bp.bstrName);

    if (pawch)
    {
        CmFree(pawch);
    }

    m_pCtr->m_DOA.DynVariantClear(&bp.varValue);

    goto Cleanup;
}



STDMETHODIMP
CPropertyBag::Read(LPCOLESTR pszName, LPVARIANT pVar, LPERRORLOG pErrorLog)
{
    for (INT i = 0; i < m_aryBagProps.Size(); i++)
    {
        if (!::lstrcmpiU(m_aryBagProps[i].bstrName, pszName))
        {
            if (V_VT(pVar) == V_VT(&m_aryBagProps[i].varValue))
            {
                return m_pCtr->m_DOA.DynVariantCopy(pVar, &m_aryBagProps[i].varValue);
            }
            else
            {
                return m_pCtr->m_DOA.DynVariantChangeType(
                              pVar,
                              &m_aryBagProps[i].varValue,
                              0,
                              V_VT(pVar));
            }
        }
    }
    return E_INVALIDARG;  // we don't have the property.
}


// IOleWindow stuff

//+---------------------------------------------------------------------------
//
//  Member:     CInPlaceSite::GetWindow
//
//  Synopsis:   returns frame window.
//
//  Arguments:  [phwnd] -- return window *here*
//
//----------------------------------------------------------------------------
STDMETHODIMP
CInPlaceSite::GetWindow(HWND * phwnd)
{
    // just reuse the CInPlaceFrame impl
    return m_pCtr->m_IPF.GetWindow(phwnd);
}

//+---------------------------------------------------------------------------
//
//  Member:     CInPlaceSite::ContextSensitiveHelp
//
//  Synopsis:   This is not implemented by design - this is for
//              the SHift+F1 context sensitive help mode and Esc
//              to exit.  Esc is already being used in the main
//              accelerator table to mean 'stop browsing' to be
//              like IE3.  We do not do help this way.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CInPlaceSite::ContextSensitiveHelp(BOOL fEnterMode)
{
    return E_NOTIMPL;
}

// IOleInPlaceSite stuff

//+---------------------------------------------------------------------------
//
//  Member:     CInPlaceSite::CanInPlaceActivate
//
//  Synopsis:   just say yes.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CInPlaceSite::CanInPlaceActivate(VOID)
{
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CInPlaceSite::OnInPlaceActivate
//
//  Synopsis:   caches the IOleInPlaceObject pointer.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CInPlaceSite::OnInPlaceActivate(VOID)
{
    HRESULT hr = m_pCtr->m_pOO->QueryInterface(
                         IID_IOleInPlaceObject,
                         (LPVOID *) &m_pCtr->m_pIPO);

    if (!hr)
        m_pCtr->SetState(OS_INPLACE);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CInPlaceSite::OnUIActivate
//
//  Synopsis:   just sets state bit
//
//----------------------------------------------------------------------------
STDMETHODIMP
CInPlaceSite::OnUIActivate(VOID)
{
    m_pCtr->SetState(OS_UIACTIVE);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CInPlaceSite::GetWindowContext
//
//  Synopsis:   returns a bunch of interfaces and positioning interface
//              the inplace-active object needs to do its thang.
//
//  Arguments:  [ppFrame]     -- return our IOleInPlaceFrame implementation
//              [ppDoc]       -- return our IOleInPlaceUIWindow impl.
//              [prcPosRect]  -- position info
//              [prcClipRect] -- clip info - same as pos info for this case
//              [pFrameInfo]  -- return 0 - inproc object doesn't use this.
//
//  Notes:      note that ppFrame and ppDoc are really just the same
//              object because we're an SDI app.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CInPlaceSite::GetWindowContext(
       IOleInPlaceFrame    **ppFrame,
       IOleInPlaceUIWindow **ppDoc,
       LPRECT                prcPosRect,
       LPRECT                prcClipRect,
       LPOLEINPLACEFRAMEINFO pFrameInfo)
{
    // get the frame
    HRESULT hr = m_pCtr->QueryInterface(
                            IID_IOleInPlaceFrame,
                            (LPVOID *)ppFrame);

    MYDBGASSERT(!hr);

    // return the frame again :) - this is all per-spec.
    hr = m_pCtr->QueryInterface(
                        IID_IOleInPlaceUIWindow,
                        (LPVOID *) ppDoc);

    MYDBGASSERT(!hr);

    // get the clip and pos rect - same for this application.
    HWND hWnd = m_pCtr->GetMainWindow();
    MYDBGASSERT(hWnd);
    HWND hWndFrame = m_pCtr->GetFrameWindow();
      
    ::GetClientRect(hWndFrame, prcPosRect);
        
    //
    // NTRAID - #148143
    // Apparently the W9x implementation is different, so MapWindowPoints for
    // the clipping and position rect only on 9X. Also, make sure that the 
    // origin is NULL to keep post 2.0 versions of future splash happy on 9X.
    //

    if (OS_W9X)
    {
        ::MapWindowPoints(hWndFrame, hWnd, (LPPOINT)prcPosRect, 2);     
        prcPosRect->top = 0;
        prcPosRect->left = 0;
    }
    
    *prcClipRect = *prcPosRect;

    //
    // OLYMPUS - #156880 
    // Clipping handled differently by future splash versions > 2.0
    // so don't re-map the rect points, just use the client rect so we 
    // work with all splash versions - nickball
    //  

    //::MapWindowPoints(hWndFrame, hWnd, (LPPOINT)prcClipRect, 2); 
        
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CInPlaceSite::Scroll
//
//  Synopsis:   never implement this for FS OC.  This has
//              nothing to do with the scrollbars you see on the HTML.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CInPlaceSite::Scroll(SIZE scrollExtent)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CInPlaceSite::OnUIDeactivate
//
//  Synopsis:   set state bits
//
//  Arguments:  [fUndoable] -- not used
//
//----------------------------------------------------------------------------
STDMETHODIMP
CInPlaceSite::OnUIDeactivate(BOOL fUndoable)
{
    m_pCtr->SetState(OS_INPLACE);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CInPlaceSite::OnInPlaceDeactivate
//
//  Synopsis:   releases the IOleInPlaceObject pointer we were
//              caching for the object, and sets state to OS_RUNNING.
//              Also fires the OLEIVERB_DISCARDUNDOSTATE at the control
//              to tell it to release any undo state it's holding onto.
//              I very much doubt the FS OC has any undo state,
//              but, this is the protocol.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CInPlaceSite::OnInPlaceDeactivate(VOID)
{
    RECT rc;

    if (m_pCtr->m_pIPO)
    {
        m_pCtr->m_pIPO->Release();
        m_pCtr->SetState(OS_RUNNING);
        m_pCtr->m_pIPO = 0;
    }

    if (m_pCtr->m_pOO)
    {
        m_pCtr->_GetDoVerbRect(&rc); // get rect for firing verbs.
        m_pCtr->m_pOO->DoVerb(
            OLEIVERB_DISCARDUNDOSTATE,
            0,
            &m_pCtr->m_CS,
            0,
            m_pCtr->GetFrameWindow(),
            0);
    }

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CICMOCCtr::_GetDoVerbRect
//
//  Synopsis:   whenever firing DoVerb(), we need a rect for the object
//              that describes the area for the object in parent client coords.
//
//  Arguments:  [prc] -- rect returned.
//
//----------------------------------------------------------------------------
VOID
CICMOCCtr::_GetDoVerbRect(LPRECT prc)
{
    ::GetClientRect(GetFrameWindow(), prc);
    ::MapWindowPoints(GetFrameWindow(), GetMainWindow(), (LPPOINT)prc, 2);
}

//+---------------------------------------------------------------------------
//
//  Member:     CInPlaceSite::DiscardUndoState
//
//  Synopsis:   just say OK - we don't hold any undo state for
//              object.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CInPlaceSite::DiscardUndoState(VOID)
{
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CInPlaceSite::DeactivateAndUndo
//
//  Synopsis:   absolutely minimum implementation of deactivateandundo.
//              just calls IOleInPlaceObject::InPlaceDeactivate().
//
//  Returns:    S_OK always.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CInPlaceSite::DeactivateAndUndo(VOID)
{
    if (m_pCtr->m_pIPO)
        m_pCtr->m_pIPO->InPlaceDeactivate();

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CInPlaceSite::OnPosRectChange
//
//  Synopsis:   never implement this.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CInPlaceSite::OnPosRectChange(LPCRECT lprcPosRect)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
//  Class:      COleContainer ()
//
//  Purpose:    our implementation of IOleContainer.  does nothing.
//
//----------------------------------------------------------------------------
STDMETHODIMP
COleContainer::QueryInterface(REFIID riid, LPVOID FAR * ppv)
{
    return m_pCtr->QueryInterface(riid, ppv);
}

STDMETHODIMP_(ULONG)
COleContainer::AddRef(VOID)
{
    return m_pCtr->AddRef();
}

STDMETHODIMP_(ULONG)
COleContainer::Release(VOID)
{
    return m_pCtr->Release();
}

COleContainer::COleContainer(LPICMOCCtr pCtr) : m_pCtr(pCtr)
{

}

STDMETHODIMP
COleContainer::EnumObjects(DWORD grfFlags, IEnumUnknown **ppenum)
{
    MYDBGASSERT(FALSE);   // never called
    return E_NOTIMPL;
}

STDMETHODIMP
COleContainer::LockContainer(BOOL fLock)
{
    MYDBGASSERT(FALSE);  // never called
    return S_OK;
}

STDMETHODIMP
COleContainer::ParseDisplayName(
                  IBindCtx *pbc,
                  LPOLESTR pszDisplayName,
                  ULONG *pchEaten,
                  IMoniker **ppmkOut)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmdial\ctr.h ===
//+----------------------------------------------------------------------------
//
// File:     ctr.h     
//
// Module:   CMDIAL32.DLL
//
// Synopsis: Header for the Ole Container object to host the future splash 
//           Animation control.
//
// Copyright (c) 1998 Microsoft Corporation
//
// Author:   nickball Created    02/10/98
//
//+----------------------------------------------------------------------------
#ifndef __CTR_H_DEFINED__
#define __CTR_H_DEFINED__

#include "state.h"

//
// Typedefs for OLE32 APIs
//

typedef HRESULT (STDAPICALLTYPE *pfnOle32Initialize)(LPVOID);
typedef HRESULT (STDAPICALLTYPE *pfnOle32Uninitialize)();
typedef HRESULT (STDAPICALLTYPE *pfnOle32SetContainedObject) (LPUNKNOWN, BOOL);
typedef HRESULT (STDAPICALLTYPE *pfnOle32CoCreateInstance) (REFCLSID, LPUNKNOWN, DWORD, REFIID, LPVOID *);

typedef struct _Ole32LinkageStruct {
	HINSTANCE hInstOle32;
	union {
		struct {
			pfnOle32Initialize			pfnOleInitialize;
			pfnOle32Uninitialize		pfnOleUninitialize;
			pfnOle32SetContainedObject	pfnOleSetContainedObject;
			pfnOle32CoCreateInstance	pfnCoCreateInstance;
		};
		void *apvPfnOle32[5];  
	};
} Ole32LinkageStruct;

//
// Typedefs for OLEAUT32 APIs
//

typedef HRESULT (STDAPICALLTYPE *pfnOleAutVariantClear) (VARIANTARG FAR*);
typedef HRESULT (STDAPICALLTYPE *pfnOleAutVariantCopy) (VARIANTARG FAR*, VARIANTARG FAR*);
typedef VOID	(STDAPICALLTYPE *pfnOleAutVariantInit) (VARIANTARG FAR*);
typedef HRESULT (STDAPICALLTYPE *pfnOleAutVariantChangeType) (VARIANTARG FAR*, VARIANTARG FAR*, unsigned short, VARTYPE);
typedef BSTR	(STDAPICALLTYPE *pfnOleAutSysAllocString) (OLECHAR FAR*);
typedef VOID	(STDAPICALLTYPE *pfnOleAutSysFreeString) (BSTR);

typedef struct _OleAutLinkageStruct {
	HINSTANCE hInstOleAut;
	union {
		struct {
			pfnOleAutVariantClear       pfnVariantClear;
			pfnOleAutVariantCopy		pfnVariantCopy;
			pfnOleAutVariantInit		pfnVariantInit;
			pfnOleAutVariantChangeType	pfnVariantChangeType;
			pfnOleAutSysAllocString     pfnSysAllocString;
			pfnOleAutSysFreeString      pfnSysFreeString;
		};
		void *apvPfnOleAut[7];  
	};
} OleAutLinkageStruct;

//
// Simple wrapper class for dynamic access to OleAut32 APIs that we care about
//

class CDynamicOleAut
{
public:
    CDynamicOleAut(VOID);
   ~CDynamicOleAut(VOID);
    BOOL Initialized(VOID);

    HRESULT DynVariantClear(VARIANTARG FAR*);
    HRESULT DynVariantCopy(VARIANTARG FAR*, VARIANTARG FAR*);
    VOID DynVariantInit(VARIANTARG FAR*);
    HRESULT DynVariantChangeType(VARIANTARG FAR*, VARIANTARG FAR*, unsigned short, VARTYPE);
    BSTR DynSysAllocString(OLECHAR FAR*);
    VOID DynSysFreeString(BSTR);

private:
    OleAutLinkageStruct m_OleAutLink;
};

//---------------------------------------------------------------
//  IOleObject
//---------------------------------------------------------------

enum OLE_SERVER_STATE
{
    OS_PASSIVE,
    OS_LOADED,                          // handler but no server
    OS_RUNNING,                         // server running, invisible
    OS_INPLACE,                         // server running, inplace-active, no U.I.
    OS_UIACTIVE,                        // server running, inplace-active, w/ U.I.
    OS_OPEN                             // server running, open-edited
};

struct BagProp
{
    BSTR    bstrName;    // name of property
    VARIANT varValue;    // value of property
};

typedef BagProp FAR * LPBAGPROP;

DECLARE_FORMSDATAARY(CAryBagProps, BagProp, LPBAGPROP);



// prototypes for HIMETRIC stuff.
//

void
InitPixelsPerInch(VOID);

int
HPixFromHimetric(long lHi);

int
VPixFromHimetric(long lHi);

long
HimetricFromHPix(int iPix);

long
HimetricFromVPix(int iPix);


class CICMOCCtr;
typedef CICMOCCtr FAR * LPICMOCCtr;

//+---------------------------------------------------------------------------
//
//  Class:      COleContainer ()
//
//  Purpose:    our implementation of IOleContainer.  does nothing.  Not sure
//              if we need it for FutureSplash - needed it for Web Browser
//              OC
//
//----------------------------------------------------------------------------
class COleContainer : public IOleContainer
{
public:
    // IUnknown stuff
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID FAR * ppv);
    STDMETHOD_(ULONG, AddRef)(VOID);
    STDMETHOD_(ULONG, Release)(VOID);

    STDMETHOD(EnumObjects)(DWORD grfFlags, IEnumUnknown **ppenum);
    STDMETHOD(LockContainer)(BOOL fLock);
    STDMETHOD(ParseDisplayName)(
                      IBindCtx *pbc,
                      LPOLESTR pszDisplayName,
                      ULONG *pchEaten,
                      IMoniker **ppmkOut);

    COleContainer(LPICMOCCtr pCtr);

protected:
    LPICMOCCtr  m_pCtr;
};

//+---------------------------------------------------------------------------
//
//  Class:      COleClientSite ()
//
//  Purpose:    our implementation of IOleClientSite
//
//  Interface:  COleClientSite         -- ctor
//              QueryInterface         -- gimme an interface!
//              AddRef                 -- bump up refcount
//              Release                -- bump down refcount
//              SaveObject             -- returns E_FAIL
//              GetMoniker             -- E_NOTIMPL
//              GetContainer           -- returns our COleContainer impl
//              ShowObject             -- just say OK
//              OnShowWindow           -- just say OK
//              RequestNewObjectLayout -- E_NOTIMPL
//
//  Notes:      probably the most important thing our IOleClientSite
//              implementation does is hand off our IOleContainer
//              implementation when GetContainer() is called.
//
//----------------------------------------------------------------------------
class COleClientSite : public IOleClientSite
{
public:
    COleClientSite(LPICMOCCtr pCtr);

    // IUnknown stuff
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID FAR * ppv);
    STDMETHOD_(ULONG, AddRef)(VOID);
    STDMETHOD_(ULONG, Release)(VOID);


    // IOleClientSite stuff
    STDMETHOD(SaveObject)(VOID);
    STDMETHOD(GetMoniker)(
                 DWORD           dwAssign,
                 DWORD           dwWhichMoniker,
                 LPMONIKER FAR * ppmk);
    STDMETHOD(GetContainer)(LPOLECONTAINER FAR * pOleCtr);
    STDMETHOD(ShowObject)(VOID);
    STDMETHOD(OnShowWindow)(BOOL bShow);
    STDMETHOD(RequestNewObjectLayout)(VOID);

protected:
    LPICMOCCtr  m_pCtr;   // pointer to the CICMOCCtr object.
};

//+---------------------------------------------------------------------------
//
//  Class:      CAdviseSink ()
//
//  Purpose:    IAdviseSink implementation
//
//----------------------------------------------------------------------------
class CAdviseSink : public IAdviseSink
{
public:
    CAdviseSink(LPICMOCCtr pCtr);

   // IUnknown stuff
   STDMETHOD(QueryInterface)(REFIID riid, LPVOID FAR * ppv);
   STDMETHOD_(ULONG, AddRef)(VOID);
   STDMETHOD_(ULONG, Release)(VOID);

   // IAdviseSink stuff
   STDMETHOD_(VOID, OnDataChange)(LPFORMATETC pFE, LPSTGMEDIUM pStgMedium);
   STDMETHOD_(VOID, OnViewChange)(DWORD dwAspect, LONG lIndex);
   STDMETHOD_(VOID, OnRename)(LPMONIKER pmkNew);
   STDMETHOD_(VOID, OnSave)(VOID);
   STDMETHOD_(VOID, OnClose)(VOID);

protected:
    LPICMOCCtr  m_pCtr;   // pointer to the CICMOCCtr object.
    LPUNKNOWN   m_pUnkOuter;  // pointer to CICMOCCtr's IUnknown
};

//+---------------------------------------------------------------------------
//
//  Class:      CInPlaceFrame ()
//
//  Purpose:
//
//  Interface:  CInPlaceFrame        -- ctor
//              QueryInterface       -- gimme an interface!
//              AddRef               -- bump up refcount
//              Release              -- decrement refcount
//              GetWindow            -- from IOleWindow - returns frame hWnd
//              ContextSensitiveHelp -- never implemented by design
//              GetBorder            -- for toolbar negotiation
//              RequestBorderSpace   -- ditto
//              SetBorderSpace       -- ditto
//              SetActiveObject      -- called whenever URL changes
//              InsertMenus          -- menu negotiation
//              SetMenu              -- ditto
//              RemoveMenus          -- ditto
//              SetStatusText        -- called by OC to set status text
//              EnableModeless       -- we have no modeless dlgs.
//              TranslateAccelerator -- calls ::TranslateAccelerator
//
//----------------------------------------------------------------------------
class CInPlaceFrame : public IOleInPlaceFrame
{
public:
    CInPlaceFrame(LPICMOCCtr pCtr);

   // IUnknown stuff
   STDMETHOD(QueryInterface)(REFIID riid, LPVOID FAR * ppv);
   STDMETHOD_(ULONG, AddRef)(VOID);
   STDMETHOD_(ULONG, Release)(VOID);

   // IOleWindow stuff
   STDMETHOD(GetWindow)(HWND * phwnd);
   STDMETHOD(ContextSensitiveHelp)(BOOL fEnterMode);

   // IOleInPlaceUIWindow stuff
   STDMETHOD(GetBorder)(LPRECT lprectBorder);
   STDMETHOD(RequestBorderSpace)(LPCBORDERWIDTHS pborderwidths);
   STDMETHOD(SetBorderSpace)(LPCBORDERWIDTHS pborderwidths);
   STDMETHOD(SetActiveObject)(
        IOleInPlaceActiveObject * pActiveObject,
        LPCOLESTR                 pszObjName);

   // IOleInPlaceFrame stuff
   STDMETHOD(InsertMenus)(
        HMENU                hmenuShared,
        LPOLEMENUGROUPWIDTHS lpMenuWidths);

   STDMETHOD(SetMenu)(
        HMENU    hmenuShared,
        HOLEMENU holemenu,
        HWND     hwndActiveObject);

   STDMETHOD(RemoveMenus)(HMENU hmenuShared);
   STDMETHOD(SetStatusText)(LPCOLESTR pszStatusText);
   STDMETHOD(EnableModeless)(BOOL fEnable);
   STDMETHOD(TranslateAccelerator)(LPMSG lpmsg, WORD wID);

protected:
    LPICMOCCtr  m_pCtr;   // pointer to the CICMOCCtr object.
};

//+---------------------------------------------------------------------------
//
//  Class:      CInPlaceSite ()
//
//  Purpose:    IOleInPlaceSite implementation.
//
//  Interface:  CInPlaceSite         -- ctor
//              QueryInterface       -- get a new interface
//              AddRef               -- bump ref count
//              Release              -- decrement ref count
//              GetWindow            -- returns frame window
//              ContextSensitiveHelp -- never implemented by design
//              CanInPlaceActivate   -- returns S_OK.
//              OnInPlaceActivate    -- caches IOleInPlaceObject ptr
//              OnUIActivate         -- returns S_OK  - sets state
//              GetWindowContext     -- returns IOleInPlaceFrame,
//                                              IOleInPlaceUIWindow,
//                                              PosRect and ClipRect
//              Scroll               -- never implemented by design.
//              OnUIDeactivate       -- obvious
//              OnInPlaceDeactivate  -- releases cached IOleInPlaceObject
//              DiscardUndoState     -- returns S_OK.
//              DeactivateAndUndo    -- deactivates in place active object
//              OnPosRectChange      -- never implemented by design
//
//----------------------------------------------------------------------------
class CInPlaceSite : public IOleInPlaceSite
{
public:
    CInPlaceSite(LPICMOCCtr pCtr);

   // IUnknown stuff
   STDMETHOD(QueryInterface)(REFIID riid, LPVOID FAR * ppv);
   STDMETHOD_(ULONG, AddRef)(VOID);
   STDMETHOD_(ULONG, Release)(VOID);

   // IOleWindow stuff
   STDMETHOD(GetWindow)(HWND * phwnd);
   STDMETHOD(ContextSensitiveHelp)(BOOL fEnterMode);

   // IOleInPlaceSite stuff
   STDMETHOD(CanInPlaceActivate)(VOID);
   STDMETHOD(OnInPlaceActivate)(VOID);
   STDMETHOD(OnUIActivate)(VOID);
   STDMETHOD(GetWindowContext)(
       IOleInPlaceFrame    **ppFrame,
       IOleInPlaceUIWindow **ppDoc,
       LPRECT                prcPosRect,
       LPRECT                prcClipRect,
       LPOLEINPLACEFRAMEINFO pFrameInfo);

   STDMETHOD(Scroll)(SIZE scrollExtant);
   STDMETHOD(OnUIDeactivate)(BOOL fUndoable);
   STDMETHOD(OnInPlaceDeactivate)(VOID);
   STDMETHOD(DiscardUndoState)(VOID);
   STDMETHOD(DeactivateAndUndo)(VOID);
   STDMETHOD(OnPosRectChange)(LPCRECT lprcPosRect);

protected:
    LPICMOCCtr  m_pCtr;   // pointer to the CICMOCCtr object.
};

class CPropertyBag : public IPropertyBag
{
public:
    CPropertyBag(LPICMOCCtr pCtr);
   ~CPropertyBag(VOID);

    // IUnknown stuff
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID FAR * ppv);
    STDMETHOD_(ULONG, AddRef)(VOID);
    STDMETHOD_(ULONG, Release)(VOID);

    // IPropertyBag methods.
    STDMETHOD(Read)(LPCOLESTR pszName, LPVARIANT pVar, LPERRORLOG pErrorLog);
    STDMETHOD(Write)(LPCOLESTR pszName, LPVARIANT pVar)
    {
        return E_NOTIMPL;
    }

    HRESULT AddPropertyToBag(LPTSTR szName, LPTSTR szValue);

protected:
    CAryBagProps   m_aryBagProps;
    LPICMOCCtr     m_pCtr;
};


//+---------------------------------------------------------------------------
//
//  Class:      CICMOCCtr ()
//
//  Purpose:    This is the one, the big kahuna.  CICMOCCtr is the
//              ICM OLE Controls container that contains a single
//              OLE Control, the FutureSplash OC.  It contains
//              sub-objects which implement the various interfaces
//              we have to support (could have used multiple inheritance,
//              but this seemed more straightforward for our needs).
//
//              Conventions:  Interfaces we implement are contained objects
//                            of a class trivially derived from the interface,
//                            e.g., IOleInPlaceFrame is a contained
//                            instance of CInPlaceFrame called m_IPF.
//
//                            Interfaces we hold on the Future Splash OC
//                            are pointers to the actual OLE interface.
//                            e.g., our pointer to the control's
//                            IOleControl interface is m_pOC.
//
//                            The contained sub-objects are all friends
//                            of the container - they are all conceptually
//                            the same object, but are implemented
//                            separately so as to cause the compiler to
//                            generate the correct vtable.
//
//----------------------------------------------------------------------------
class CICMOCCtr : public IUnknown
{
public:
    friend CInPlaceSite;
    friend CInPlaceFrame;
    friend COleClientSite;
    friend CPropertyBag;

    // IUnknown stuff
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID FAR * ppv);
    STDMETHOD_(ULONG, AddRef)(VOID);
    STDMETHOD_(ULONG, Release)(VOID);

    VOID    Paint(HDC hDC, LPRECT lpr);
    VOID    Paint(VOID);
    HRESULT CreateFSOC(Ole32LinkageStruct *pOle32Link);
    HRESULT GetSize(LPRECT prc);
    HRESULT SetSize(LPRECT prc, BOOL fMoveFrameWindow = TRUE);

    HWND    GetMainWindow(VOID)
    {
        MYDBGASSERT(m_hWndMainDlg && ::IsWindow(m_hWndMainDlg));
        return m_hWndMainDlg;
    }

    HWND    GetFrameWindow(VOID)
    {
        MYDBGASSERT(m_hWndFrame && ::IsWindow(m_hWndFrame));
        return m_hWndFrame;
    }

    LRESULT OnActivateApp(WPARAM wParam, LPARAM lParam);

    //
    //  Whenever we display a modal dialog, we need to let
    //  our embeddings (the WebBrowser OC) know to disable
    //  any modeless dialogs the embedding is displaying.
    //
    VOID    EnableEmbeddingModelessDlgs(BOOL fEnable)
    {
        LPOLEINPLACEACTIVEOBJECT pIPAO = GetIPAObject();
        if (pIPAO)
            pIPAO->EnableModeless(fEnable);
    }

    VOID    DoLayout(INT cxMain, INT cyMain);

    CICMOCCtr(const HWND hWndMainDlg, const HWND hWndFrame);
   ~CICMOCCtr(VOID);
    VOID ShutDown(VOID);

    BOOL Initialized(VOID); 

    OLE_SERVER_STATE GetState(VOID) {return m_state;}
    VOID             SetState(OLE_SERVER_STATE state) {m_state = state;}
    HRESULT          EnableModeless(BOOL fEnable);
    BOOL             ModelessEnabled(VOID){return m_fModelessEnabled;}
    LRESULT          SetFocus(VOID);
    HRESULT          AddPropertyToBag(LPTSTR szName, LPTSTR szValue)
    {
        return m_PB.AddPropertyToBag(szName, szValue);
    }

    VOID MapStateToFrame(ProgState ps);

    HRESULT SetFrame(LONG lFrame);
    VOID    SetFrameMapping(ProgState ps, LONG lFrame)
    {
        m_alStateMappings[ps] = lFrame;
    }

    LPOLEINPLACEACTIVEOBJECT GetIPAObject(VOID) {return m_pActiveObj;}

protected:
    HRESULT _SetExtent(LPRECT prc);
    HRESULT _DisplayStatusText(LPCOLESTR pStrStatusText);
    VOID    _ResetToolSpace(VOID)
    {
        ::memset(&m_rcToolSpace, 0, sizeof m_rcToolSpace);
    }
    VOID    _AdjustForTools(LPRECT prc);

    VOID    _DeactivateControl(VOID);
    HRESULT _TransAccelerator(LPMSG lpmsg, WORD wID);
    VOID    _GetDoVerbRect(LPRECT prc);

                             // map states to frames.
    LONG                     m_alStateMappings[NUMSTATES];
    BORDERWIDTHS             m_rcToolSpace; // for FS OC
    COleClientSite           m_CS;          // clientsite
    CAdviseSink              m_AS;          // advise sink
    CInPlaceFrame            m_IPF;         // inplace frame
    CInPlaceSite             m_IPS;         // inplace site object
    COleContainer            m_OCtr;        // IOleContainer
    CDynamicOleAut           m_DOA;         // Dynamic OLEAUT32   
    CPropertyBag             m_PB;          // IPropertyBag - Must never precede CDynamicOleAut 
    HWND                     m_hWndMainDlg; // hwnd for ICM dialog
    HWND                     m_hWndFrame;   // hWnd that contains OC Site
    LPUNKNOWN                m_pUnk;        // the object itself.
    LPVIEWOBJECT             m_pVO;         // pointer to IViewObject
    LPOLEOBJECT              m_pOO;         // pointer to IOleObject
    LPOLEINPLACEOBJECT       m_pIPO;        // pointer to InPlaceActiveObject
    LPDISPATCH               m_pDisp;       // IDispatch to FS OC
    LPOLEINPLACEACTIVEOBJECT m_pActiveObj;  // current active object
    LPOLECONTROL             m_pOC;         // IOleControl interface for OC
    ULONG                    m_Ref;         // refcount
    OLE_SERVER_STATE         m_state;       // current OLE state of OC
    DWORD                    m_dwMiscStatus;// misc status bits for OC
    BOOL                     m_fModelessEnabled; // OC is putting up modal dlg?
};

extern "C" CLSID const CLSID_FS;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmdial\connstat.h ===
//+----------------------------------------------------------------------------
//
// File:     ConnStat.h
//
// Module:	 CMDIAL32.DLL
//
// Synopsis: Definition for the class CConnStatistics  class.  Used to collect
//           dial statistics on Win9x.
//
// Copyright (c) 1996-1998 Microsoft Corporation
//
// Author:	 quintinb    Created Header    08/17/99
//
//+----------------------------------------------------------------------------

#ifndef CONNSTAT_H
#define CONNSTAT_H

#include <windows.h>
#include <ras.h>

//+---------------------------------------------------------------------------
//
//	class CConnStatistics
//
//	Description: A class to collect connection statistics
//               Not work for NT, NT has its own ras status dialog and 
//               idle disconnect.
//               InitStatistics() will start gathering data from registry
//               OpenByDevice   will gathering data from TAPI device handle
//
//	History:	fengsun	Created		10/1/97
//
//----------------------------------------------------------------------------
class CConnStatistics
{
public:
    CConnStatistics();
    ~CConnStatistics();

    BOOL  IsDialupTwo() const;
    DWORD GetInitBytesRead() const;
    DWORD GetInitBytesWrite() const;
    BOOL  IsAvailable() const;  // whether statistic information is available
    BOOL  InitStatistics();
    void  Close();        // No more statistic information

protected:

    BOOL GetPerfData(DWORD& dwRead, DWORD& dwWrite, DWORD& dwBaudRate) const;
    BOOL RasConnectionExists();
    void GetStatRegValues(HINSTANCE hInst);

protected:

    DWORD  m_dwBaudRate;
    HKEY   m_hKey;          // Performance registry handle
    DWORD  m_dwInitBytesRead;
    DWORD  m_dwInitBytesWrite;

    //
    // Registry names are different for PPP and PPTP
    //

    BOOL m_fAdapter2;

    //
    // Localized version of 
    // "Dial-up Adapter"\TotalBytesRecvd"
    // "Dial-up Adapter"\TotalBytesXmit"
    // "Dial-up Adapter"\ConnectSpeed"
    //
    LPTSTR m_pszTotalBytesRecvd;
    LPTSTR m_pszTotalBytesXmit;
    LPTSTR m_pszConnectSpeed;
};

//
// Inline functions
//

inline DWORD CConnStatistics::GetInitBytesRead() const
{
    return m_dwInitBytesRead;
}

inline DWORD CConnStatistics::GetInitBytesWrite() const
{
    return m_dwInitBytesWrite;
}

inline BOOL CConnStatistics::IsDialupTwo() const
{
    return m_fAdapter2;
}

inline BOOL CConnStatistics::IsAvailable() const
{
    return OS_NT5 ? TRUE : (m_hKey != NULL);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmdial\connect.cpp ===
//+----------------------------------------------------------------------------
//
// File:     connect.cpp
//
// Module:   CMDIAL32.DLL
//
// Synopsis: The main code path for establishing a connection. 
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   nickball   Created    2/10/98
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"

//
// Local includes
//

#include "ConnStat.h"
#include "CompChck.h"
#include "Dialogs.h"
#include "ActList.h"
#include "dial_str.h"
#include "dun_str.h"
#include "dl_str.h"
#include "pwd_str.h"
#include "tunl_str.h"
#include "mon_str.h"
#include "conact_str.h"
#include "pbk_str.h"
#include "stp_str.h"
#include "profile_str.h"
#include "ras_str.h"

#include "cmtiming.h"

//
// .CMP and .CMS flag used only by connect.cpp
//

const TCHAR* const c_pszCmEntryMonitorCallingProgram= TEXT("MonitorCallingProgram"); 
const TCHAR* const c_pszCmEntryUserNameOptional     = TEXT("UserNameOptional"); 
const TCHAR* const c_pszCmEntryDomainOptional       = TEXT("DomainOptional"); 
const TCHAR* const c_pszCmEntryServiceType          = TEXT("ServiceType");
const TCHAR* const c_pszCmEntryRedialDelay          = TEXT("RedialDelay"); 
const TCHAR* const c_pszCmEntryRedial               = TEXT("Redial");                       
const TCHAR* const c_pszCmEntryIdle                 = TEXT("Idle");                         
const TCHAR* const c_pszCmEntryDialAutoMessage      = TEXT("DialAutoMessage");  
const TCHAR* const c_pszCmEntryCheckOsComponents    = TEXT("CheckOSComponents");     
const TCHAR* const c_pszCmEntryDoNotCheckBindings   = TEXT("DoNotCheckBindings");   
const TCHAR* const c_pszCmEntryIsdnDialMode         = TEXT("IsdnDialMode"); 
const TCHAR* const c_pszCmEntryResetPassword        = TEXT("ResetPassword");
const TCHAR* const c_pszCmEntryCustomButtonText     = TEXT("CustomButtonText");
const TCHAR* const c_pszCmEntryCustomButtonToolTip  = TEXT("CustomButtonToolTip"); 
const TCHAR* const c_pszCmDynamicPhoneNumber        = TEXT("DynamicPhoneNumber"); 
const TCHAR* const c_pszCmNoDialingRules            = TEXT("NoDialingRules"); 

const TCHAR* const c_pszCmEntryHideDialAuto         = TEXT("HideDialAutomatically"); 
const TCHAR* const c_pszCmEntryHideRememberPwd      = TEXT("HideRememberPassword"); 
const TCHAR* const c_pszCmEntryHideRememberInetPwd  = TEXT("HideRememberInternetPassword"); 
const TCHAR* const c_pszCmEntryHideInetUserName     = TEXT("HideInternetUserName"); 
const TCHAR* const c_pszCmEntryHideInetPassword     = TEXT("HideInternetPassword"); 
const TCHAR* const c_pszCmEntryHideUnattended       = TEXT("HideUnattended"); 

const TCHAR* const c_pszCmEntryRegion               = TEXT("Region");
const TCHAR* const c_pszCmEntryPhonePrefix          = TEXT("Phone"); 
const TCHAR* const c_pszCmEntryPhoneCanonical       = TEXT("PhoneCanonical"); 
const TCHAR* const c_pszCmEntryPhoneDunPrefix       = TEXT("DUN"); 
const TCHAR* const c_pszCmEntryPhoneDescPrefix      = TEXT("Description"); 
const TCHAR* const c_pszCmEntryPhoneCountryPrefix   = TEXT("PhoneCountry"); 
const TCHAR* const c_pszCmEntryPhoneSourcePrefix    = TEXT("PhoneSource"); 
const TCHAR* const c_pszCmEntryUseDialingRules      = TEXT("UseDialingRules"); 

const TCHAR* const c_pszCmEntryAnimatedLogo         = TEXT("AnimatedLogo"); 
const TCHAR* const c_pszCmSectionAnimatedLogo       = TEXT("Animated Logo"); 
const TCHAR* const c_pszCmSectionAnimatedActions    = TEXT("Animation Actions"); 
const TCHAR* const c_pszCmEntryAniMovie             = TEXT("Movie"); 
const TCHAR* const c_pszCmEntryAniPsInteractive     = TEXT("Initial"); 
const TCHAR* const c_pszCmEntryAniPsDialing0        = TEXT("Dialing0"); 
const TCHAR* const c_pszCmEntryAniPsDialing1        = TEXT("Dialing1"); 
const TCHAR* const c_pszCmEntryAniPsPausing         = TEXT("Pausing"); 
const TCHAR* const c_pszCmEntryAniPsAuthenticating  = TEXT("Authenticating"); 
const TCHAR* const c_pszCmEntryAniPsOnline          = TEXT("Connected"); 
const TCHAR* const c_pszCmEntryAniPsTunnel          = TEXT("Tunneling"); 
const TCHAR* const c_pszCmEntryAniPsError           = TEXT("Error"); 

const TCHAR* const c_pszCmEntryWriteDialParams      = TEXT("WriteRasDialUpParams"); 

//
// Used for loading EAP identity DLL
//

const TCHAR* const c_pszRasEapRegistryLocation      = TEXT("System\\CurrentControlSet\\Services\\Rasman\\PPP\\EAP");
const TCHAR* const c_pszRasEapValueNameIdentity     = TEXT("IdentityPath");
const TCHAR* const c_pszInvokeUsernameDialog        = TEXT("InvokeUsernameDialog");

//
// Definitions
//

#define MAX_OBJECT_WAIT 30000         // milliseconds to wait for cmmon launch and RNA thread return

//============================================================================

static void LoadPhoneInfoFromProfile(ArgsStruct *pArgs);

HRESULT UpdateTable(ArgsStruct *pArgs, CmConnectState CmState);
HRESULT ConnectMonitor(ArgsStruct *pArgs);
void OnMainExit(ArgsStruct *pArgs);
void ProcessCleanup(ArgsStruct* pArgs);

VOID UpdateError(ArgsStruct *pArgs, DWORD dwErr);

DWORD GetEapUserId(ArgsStruct *pArgs, 
    HWND hwndDlg, 
    LPTSTR pszRasPbk, 
    LPBYTE pbEapAuthData, 
    DWORD dwEapAuthDataSize, 
    DWORD dwCustomAuthKey,
    LPRASEAPUSERIDENTITY* ppRasEapUserIdentity);

DWORD CmEapGetIdentity(ArgsStruct *pArgs, 
    LPTSTR pszRasPbk, 
    LPBYTE pbEapAuthData, 
    DWORD dwEapAuthDataSize,
    LPRASEAPUSERIDENTITY* ppRasEapUserIdentity);

void CheckStartupInfo(HWND hwndDlg, ArgsStruct *pArgs);

BOOL InitConnect(ArgsStruct *pArgs);

void ObfuscatePasswordEdit(ArgsStruct *pArgs);

void DeObfuscatePasswordEdit(ArgsStruct *pArgs);

void GetPasswordFromEdit(ArgsStruct *pArgs);

//+----------------------------------------------------------------------------
//
// Function:  GetPasswordFromEdit
//
// Synopsis:  Updates pArgs->szPassword with contents of edit control
//
// Arguments: pArgs  -  Ptr to global Args struct
//
// Returns:   Nothing
//
// History:   nickball    Created     04/13/00
//
//+----------------------------------------------------------------------------
void GetPasswordFromEdit(ArgsStruct *pArgs)
{
    MYDBGASSERT(pArgs);

    if (NULL == pArgs)
    {
        return;
    }

    if (NULL == GetDlgItem(pArgs->hwndMainDlg, IDC_MAIN_PASSWORD_EDIT))
    {
        return;
    }

    //
    // Retrieve the password and update memory based storage.
    //
        
    LPTSTR pszPassword = CmGetWindowTextAlloc(pArgs->hwndMainDlg, IDC_MAIN_PASSWORD_EDIT);
        
    MYDBGASSERT(pszPassword);

    if (pszPassword)
    {                       
        //
        // Update pArgs with main password. 
        //

        lstrcpyU(pArgs->szPassword, pszPassword);
        CmEncodePassword(pArgs->szPassword);
    
        CmWipePassword(pszPassword);
        CmFree(pszPassword);
    }
    else
    {
        lstrcpyU(pArgs->szPassword, TEXT(""));
    }

    return;
}

//+----------------------------------------------------------------------------
//
// Function:  DeObfuscatePasswordEdit
//
// Synopsis:  Undoes the work of ObfuscatePasswordEdit by updating the password
//            edit with the plain text password 
//
// Arguments: pArgs  -  Ptr to global Args struct
//
// Returns:   Nothing
//
// History:   nickball    Created     04/13/00
//
//+----------------------------------------------------------------------------
void DeObfuscatePasswordEdit(ArgsStruct *pArgs)
{
    MYDBGASSERT(pArgs);

    if (NULL == pArgs)
    {
        return;
    }

    HWND hwndEdit = GetDlgItem(pArgs->hwndMainDlg, IDC_MAIN_PASSWORD_EDIT);

    if (NULL == hwndEdit)
    {
        return;
    }

    //
    // Make sure we don't trigger EN_CHANGE notifications
    //

    BOOL bSavedNoNotify = pArgs->fIgnoreChangeNotification;
    pArgs->fIgnoreChangeNotification = TRUE;
    
    //
    // Update the edit control
    //

    CmDecodePassword(pArgs->szPassword);
    SetWindowTextU(hwndEdit, pArgs->szPassword);
    CmEncodePassword(pArgs->szPassword);

    //
    // Restore EN_CHANGE notifications
    //

    pArgs->fIgnoreChangeNotification = bSavedNoNotify;   
}

//+----------------------------------------------------------------------------
//
// Function:  ObfuscatePasswordEdit
//
// Synopsis:  Helper routine to mangle password edit contents by replacing 
//            them with an equivalent number of *s
//
// Arguments: pArgs  -  Ptr to global Args struct
//
// Returns:   Nothing
//
// NOTE:      This function assumes that pArgs->szPassword has been previously
//            updated with GetPasswordFromEdit. This assumption is made 
//            because it is critical to the Odfuscate/DeObfuscate sequence, 
//            which will breakdown if the latest password is not cached in 
//            memory (pArgs) before the edit contents are modified.
//
// History:   nickball    Created     04/13/00
//
//+----------------------------------------------------------------------------
void ObfuscatePasswordEdit(ArgsStruct *pArgs)
{   
    MYDBGASSERT(pArgs);

    if (NULL == pArgs)
    {
        return;
    }

    HWND hwndEdit = GetDlgItem(pArgs->hwndMainDlg, IDC_MAIN_PASSWORD_EDIT);

    if (NULL == hwndEdit)
    {
        return;
    }

    //
    // Generate a buffer of the same length as the current password, but 
    // containing only asterisks.
    //
    
    LPTSTR pszDummy = CmStrCpyAlloc(pArgs->szPassword);
        
    MYDBGASSERT(pszDummy);
    
    if (pszDummy)
    {
        //
        // Make sure we don't trigger EN_CHANGE notifications
        //

        BOOL bSavedNoNotify = pArgs->fIgnoreChangeNotification;
        pArgs->fIgnoreChangeNotification = TRUE;

        LPTSTR pszTmp = pszDummy;
        
        while (*pszTmp)
        {
            *pszTmp++ = TEXT('*');
        }

        //
        // Update the edit control with the modified buffer
        //

        SetWindowTextU(hwndEdit, pszDummy);
        CmFree(pszDummy);

        //
        // Restore EN_CHANGE notifications
        //

        pArgs->fIgnoreChangeNotification = bSavedNoNotify; 
    }
}

//+----------------------------------------------------------------------------
//
// Function:  InitConnect
//
// Synopsis:  Init routine for the connection. Assumes that we have the profile
//            initialized and the basic integrity of the profile verified.
//
// Arguments: ArgStruct *pArgs  - Ptr to global Args struct
//
// Returns:   BOOL  - True if init succeeds.
//
// History:   nickball    Created     03/10/00
//
//+----------------------------------------------------------------------------
BOOL InitConnect(ArgsStruct *pArgs)
{
    //
    // If this is an AUTODIAL, add the process ID to the watch list
    //
    
    if ((pArgs->dwFlags & FL_AUTODIAL) && 
        pArgs->piniService->GPPI(c_pszCmSection, c_pszCmEntryMonitorCallingProgram, 1))
    {
        CMTRACE(TEXT("InitConnect() Adding calling process to watch list"));
        AddWatchProcessId(pArgs, GetCurrentProcessId());    
    }
    
    //
    // Do we want tunneling?
    //

    pArgs->fTunnelPrimary = (int) pArgs->piniService->GPPI(c_pszCmSection, c_pszCmEntryTunnelPrimary);
    pArgs->fTunnelReferences = (int) pArgs->piniService->GPPI(c_pszCmSection, c_pszCmEntryTunnelReferences);

    //
    // Now we can determine our connect type
    //
    
    GetConnectType(pArgs);

    //
    // Set fUseTunneling. If not obvious (eg. direct VPN) then 
    // base the initial value upon the primary phone number.
    //

    if (pArgs->IsDirectConnect())
    {
        pArgs->fUseTunneling = TRUE;
    }
    else
    {
        pArgs->fUseTunneling = UseTunneling(pArgs, 0);
    }

    //
    //  Load the path for the VPN file if we have one
    //

    LPTSTR pszTemp = pArgs->piniService->GPPS(c_pszCmSection, c_pszCmEntryTunnelFile);
    
    if (pszTemp && pszTemp[0])
    {
        //
        //  Now expand the relative path to a full path
        //
        pArgs->pszVpnFile = CmBuildFullPathFromRelative(pArgs->piniProfile->GetFile(), pszTemp);

        MYDBGASSERT(pArgs->pszVpnFile && pArgs->pszVpnFile[0]);
    }

    CmFree(pszTemp);

    TCHAR szTmp[MAX_PATH];
    MYVERIFY(GetModuleFileNameU(NULL, szTmp, MAX_PATH));
    pArgs->Log.Log(PREINIT_EVENT, szTmp);
    
     //
    // Run any init time actions that we may have.
    //

    CActionList PreInitActList;
    PreInitActList.Append(pArgs->piniService, c_pszCmSectionPreInit);
    if (!PreInitActList.RunAccordType(pArgs->hwndMainDlg, pArgs, FALSE)) // fStatusMsgOnFailure = FALSE
    {
        //
        // Fail the connection
        //
        
        return FALSE;
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:  CheckStartupInfo
//
// Synopsis:  Sub-routine to initialize startup info if necessary and perform 
//            any other functions specific to this juncture in the init sequence.
//
// Arguments: HWND      hwndDlg - HWND of main dlg
//            ArgStruct *pArgs  - Ptr to global Args struct
//
// Returns:   Nothing
//
// History:   nickball    Created     10/28/99
//
//+----------------------------------------------------------------------------

void CheckStartupInfo(IN HWND hwndDlg, IN ArgsStruct *pArgs)
{
    MYDBGASSERT(pArgs);

    if (NULL == pArgs)
    {
        return;
    }

    if (!pArgs->fStartupInfoLoaded)
    {
        //
        // When no one is logged on the IsWindowVisible will not return true when ICS is dialing
        //
        if (IsLogonAsSystem() || IsWindowVisible(hwndDlg))    
        {
            //
            // The code is here to make sure FutureSplash starts with 
            // the frame associated with Initial/Interactive state
            // and not Frame 1
            //

            if (NULL != pArgs->pCtr)
            {
                pArgs->pCtr->MapStateToFrame(PS_Interactive);
            }

            //
            // If we're doing unattended, and the behavior isn't explicitly turned off,
            // hide the UI while we do our unattended dial. Note: Be sure to set hide
            // state before first paint message is processed by system.
            //

            if (pArgs->dwFlags & FL_UNATTENDED)
            { 
                if (pArgs->piniService->GPPB(c_pszCmSection, c_pszCmEntryHideUnattended, TRUE)) 
                {
                    ShowWindow(hwndDlg, SW_HIDE);
                }
            }

            //
            // Post a message to ourselves to begin loading startup info. 
            //

            PostMessageU(hwndDlg, WM_LOADSTARTUPINFO, (WPARAM)0, (LPARAM)0);  
        }
    }
}

//+----------------------------------------------------------------------------
//
// Function:  UpdateError
//
// Synopsis:  Simple sub-routine to update the UI and program state in the 
// event of an error.
//
// Arguments: ArgStruct *pArgs - Ptr to global Args struct
//            DWORD     dwErr - The error code
//
// Returns:   Nothing
//
// History:   nickball    Created     05/31/99
//
//+----------------------------------------------------------------------------
VOID UpdateError(ArgsStruct *pArgs, DWORD dwErr)
{
    MYDBGASSERT(pArgs);

    if (pArgs)
    {
        //
        // Update the status display providing that the special case error code
        // ERROR_INVALID_DLL is not being used. This code is only used by CM to
        // designate that a Connect Action failed. Because the display is 
        // updated by the action list, we must ensure that we don't overwrite.
        // 

        if (ERROR_INVALID_DLL != dwErr)
        {
            CheckConnectionError(pArgs->hwndMainDlg, dwErr, pArgs, IsDialingTunnel(pArgs));
        }

        //
        // Update the logon dialog controls
        //

        SetInteractive(pArgs->hwndMainDlg, pArgs);

        //
        // Update the program state
        //

        pArgs->psState = PS_Error;
    }
}

//+----------------------------------------------------------------------------
//
// Function:  UpdateTable
//
// Synopsis:  Encapsulates updating to Connection Table according to our 
//            current state
//
// Arguments: ArgsStruct *pArgs - Ptr to global Args struct
//            CmConnectState CmState - The state we are now in.
//
// Returns:   HRESULT - Failure code.
//
// History:   nickball    Created Header    2/9/98
//
//+----------------------------------------------------------------------------
HRESULT UpdateTable(ArgsStruct *pArgs, CmConnectState CmState)
{
    MYDBGASSERT(pArgs);
    MYDBGASSERT(pArgs->pConnTable);

    HRESULT hrRet = E_FAIL;

    //
    // Set the state as appropriate
    //

    switch (CmState)
    {
        case CM_CONNECTING:         
            hrRet = pArgs->pConnTable->AddEntry(pArgs->szServiceName, pArgs->fAllUser);
            break;

        case CM_CONNECTED:                              
            hrRet = pArgs->pConnTable->SetConnected(pArgs->szServiceName, pArgs->hrcRasConn, pArgs->hrcTunnelConn);
            break;
            
        case CM_DISCONNECTING:         
            hrRet = pArgs->pConnTable->SetDisconnecting(pArgs->szServiceName);
            break;

        case CM_DISCONNECTED:       
            hrRet = pArgs->pConnTable->ClearEntry(pArgs->szServiceName);
            break;

        default:
            MYDBGASSERT(FALSE);
            break;
    }

    return hrRet;
}

//+----------------------------------------------------------------------------
//
// Function:  EndMainDialog
//
// Synopsis:  Simple helper to encapsulate EndDialog call and associated clean
//            up.
//
// Arguments: HWND hwndDlg - HWND of main dialog 
//            ArgsStruct *pArgs - Ptr to global Args struct
//            int nResult - int to be passed on the EndDialog
//
// Returns:   Nothing
//
// History:   nickball    Created     2/23/98
//
//+----------------------------------------------------------------------------

void EndMainDialog(HWND hwndDlg, ArgsStruct *pArgs, int nResult)
{    
    //
    // Kill timer if we have one
    //

    if (pArgs->nTimerId)
    {
        KillTimer(hwndDlg,pArgs->nTimerId);
        pArgs->nTimerId = 0;
    }

    //
    // Cleanup future splash
    //

    if (pArgs->pCtr)
    {
        CleanupCtr(pArgs->pCtr); 
        pArgs->pCtr = NULL;
    }

    //
    // Release our dialog specific data
    //

    pArgs->fStartupInfoLoaded = FALSE;

    OnMainExit(pArgs); 

    //
    // hasta la vista, final
    //

    EndDialog(hwndDlg, nResult);
}

//+----------------------------------------------------------------------------
//
// Function:  GetWatchCount
//
// Synopsis:  Determines the number of processes in the watch list by searching
//            for the first NULL entry.
//
// Arguments: ArgStruct *pArgs - Ptr to global Args struct
//
// Returns:   DWORD - Number of processes in list
//
// History:   nickball    Created Header    2/10/98
//
//+----------------------------------------------------------------------------
DWORD GetWatchCount(const ArgsStruct *pArgs)
{
    MYDBGASSERT(pArgs);

    DWORD dwCnt = 0;

    if (pArgs && pArgs->phWatchProcesses) 
    {
        for (DWORD dwIdx = 0; pArgs->phWatchProcesses[dwIdx]; dwIdx++) 
        {
            dwCnt++;
        }
    }

    return dwCnt;
}
    
//+----------------------------------------------------------------------------
//
// Function:  AddWatchProcess
//
// Synopsis:  Adds the given process handle to our list. The list is allocated
//            and reallocated as needed to accomodate new entries.
//
// Arguments: ArgsStruct *pArgs - Ptr to global Args struct
//            HANDLE hProcess - The process handle to be added to the list
//
// Returns:   Nothing
//
// History:   nickball    Created Header        2/10/98
//            tomkel      Fixed PREFIX issues   11/21/2000
//
//+----------------------------------------------------------------------------
void AddWatchProcess(ArgsStruct *pArgs, HANDLE hProcess) 
{
    MYDBGASSERT(pArgs);
    MYDBGASSERT(hProcess);
        
    if (NULL == hProcess || NULL == pArgs) 
    {
        return;
    }

    //
    // Get count and Allocate room for 2 more, 1 new, 1 NULL
    //

    DWORD dwCnt = GetWatchCount(pArgs);

    HANDLE *phTmp = (HANDLE *) CmMalloc((dwCnt+2)*sizeof(HANDLE));
    
    if (NULL != phTmp)
    {
        //
        // Copy the existing list, and add the new handle
        //
        if (NULL != pArgs->phWatchProcesses)
        {
            CopyMemory(phTmp,pArgs->phWatchProcesses,sizeof(HANDLE)*dwCnt);
        }
    
        phTmp[dwCnt] = hProcess;

        //
        // Fix up the pointers
        //

        CmFree(pArgs->phWatchProcesses);
        pArgs->phWatchProcesses = phTmp;
    }
}

//+----------------------------------------------------------------------------
//
// Function:  AddWatchProcessId
//
// Synopsis:  Given a process Id, adds a handle for the given process to the w
//            atch process list.
//
// Arguments: ArgsStruct *pArgs - Ptr to global Args struct.
//            DWORD dwProcessId - The ID of the process to be added
//
// Returns:   Nothing
//
// History:   nickball    Created Header    2/10/98
//
//+----------------------------------------------------------------------------

void AddWatchProcessId(ArgsStruct *pArgs, DWORD dwProcessId) 
{
    MYDBGASSERT(pArgs);
    MYDBGASSERT(dwProcessId);

    if (NULL == pArgs || NULL == dwProcessId)
    {
        return;
    }

    //
    // Open the process Id to obtain handle
    //

    HANDLE hProcess = OpenProcess(SYNCHRONIZE | PROCESS_DUP_HANDLE | PROCESS_QUERY_INFORMATION, FALSE, dwProcessId);
    
    //
    // Add to the watch process list 
    //
    
    if (hProcess) 
    {
        AddWatchProcess(pArgs,hProcess);
    }
    else
    {
        CMTRACE1(TEXT("AddWatchProcess() OpenProcess() failed, GLE=%u."), GetLastError());
    }
}

//+----------------------------------------------------------------------------
//
// Function:  CleanupConnect
//
// Synopsis:  Helper function encapsulating release of resource allocated duri
//            ng connect.
//
// Arguments: ArgsStruct *pArgs - Ptr to global Args struct
//
// Returns:   Nothing
//
// History:   nickball    Created    9/25/98
//
//+----------------------------------------------------------------------------
void CleanupConnect(ArgsStruct *pArgs)
{
    MYDBGASSERT(pArgs);
    
    if (NULL == pArgs)
    {
        return;
    }

    pArgs->m_ShellDll.Unload();

    //
    // Unlink RAS and TAPI DLLs
    //

    UnlinkFromRas(&pArgs->rlsRasLink);
    UnlinkFromTapi(&pArgs->tlsTapiLink);
   
    //
    // un-init password encryption, only if it is initialized
    //

    if (pArgs->fInitSecureCalled)
    {
        DeInitSecure();
        pArgs->fInitSecureCalled = FALSE;
    }
        
    //
    // Cleanup WatchProcess handles 
    //

    ProcessCleanup(pArgs);
    
    //
    // Release all paths loaded for connect. 
    //

    if (pArgs->pszRasPbk)
    {
        CmFree(pArgs->pszRasPbk);
        pArgs->pszRasPbk = NULL;
    }

    if (pArgs->pszRasHiddenPbk)
    {
        CmFree(pArgs->pszRasHiddenPbk);
        pArgs->pszRasHiddenPbk = NULL;
    }
    
    if(pArgs->pszVpnFile)
    {
        CmFree(pArgs->pszVpnFile);
        pArgs->pszVpnFile = NULL;        
    }

    if (pArgs->pRasDialExtensions)
    {
        CmFree(pArgs->pRasDialExtensions);
        pArgs->pRasDialExtensions = NULL;
    }

    if (pArgs->pRasDialParams)
    {
        CmFree(pArgs->pRasDialParams);
        pArgs->pRasDialParams = NULL;
    }

    if (pArgs->pszCurrentAccessPoint)
    {
        CmFree(pArgs->pszCurrentAccessPoint);
        pArgs->pszCurrentAccessPoint = NULL;
    }

    //
    // Cleanup Help by killing the help file window if any and releasing the help file
    // string.
    //
    if (pArgs->pszHelpFile)
    {
        CmWinHelp((HWND)NULL, (HWND)NULL, pArgs->pszHelpFile, HELP_QUIT, 0);
        CmFree(pArgs->pszHelpFile);
        pArgs->pszHelpFile = NULL;
    }

    //
    // Release Ini objects
    //
    
    ReleaseIniObjects(pArgs);

    //
    // Release OLE links if any
    //

    if (pArgs->olsOle32Link.hInstOle32 && pArgs->olsOle32Link.pfnOleUninitialize)
    {
        pArgs->olsOle32Link.pfnOleUninitialize();
    }
    
    UnlinkFromOle32(&pArgs->olsOle32Link);

    //
    // Release stats and table classes
    //

    if (pArgs->pConnStatistics)
    {
        delete pArgs->pConnStatistics;
    }

    if (pArgs->pConnTable)
    {
        MYVERIFY(SUCCEEDED(pArgs->pConnTable->Close()));
        delete pArgs->pConnTable;
    }
}

//
// Releases any resources allocated during initialization
//

void OnMainExit(ArgsStruct *pArgs) 
{
    //
    // Release bitmap resources for main dlg
    //

    ReleaseBitmapData(&pArgs->BmpData);

    if (pArgs->hMasterPalette)
    {
        UnrealizeObject(pArgs->hMasterPalette);
        DeleteObject(pArgs->hMasterPalette);
        pArgs->hMasterPalette = NULL;
    }

    //
    // Release icon resources
    //

    if (pArgs->hBigIcon) 
    {
        DeleteObject(pArgs->hBigIcon);
        pArgs->hBigIcon = NULL;
    }
    
    if (pArgs->hSmallIcon) 
    {
        DeleteObject(pArgs->hSmallIcon);
        pArgs->hSmallIcon = NULL;
    }

    if (pArgs->pszResetPasswdExe) 
    {
        CmFree(pArgs->pszResetPasswdExe);
        pArgs->pszResetPasswdExe = NULL;
    }

    if (pArgs->uiCurrentDnsTunnelAddr)
    {
        CmFree(pArgs->pucDnsTunnelIpAddr_list);
        pArgs->pucDnsTunnelIpAddr_list = NULL;
    }
    
    if (pArgs->rgwRandomDnsIndex)
    {
        CmFree(pArgs->rgwRandomDnsIndex);
        pArgs->rgwRandomDnsIndex = NULL;
    }
}

//
// GetPhoneByIdx: get phone number, etc. information from .cmp file
//
LPTSTR GetPhoneByIdx(ArgsStruct *pArgs, 
                     UINT nIdx, 
                     LPTSTR *ppszDesc, 
                     LPTSTR *ppszDUN, 
                     LPDWORD pdwCountryID,
                     LPTSTR *ppszRegionName,
                     LPTSTR *ppszServiceType,
                     LPTSTR *ppszPhoneBookFile,
                     LPTSTR *ppszCanonical,
                     DWORD  *pdwPhoneInfoFlags) 
{
    MYDBGASSERT(ppszCanonical);
    MYDBGASSERT(pdwPhoneInfoFlags);

    //
    // Note: ppszCanonical and pdwPhoneInfoFlags are now required parameters. 
    // While somewhat unfortunate, this is necessary to retain the integrity 
    // of the retrieved data as legacy handling forces us to return data
    // that may not be an exact representation of the profile contents.
    // For example, the ppszCanonical and pdwPhoneInfoFlags value may be modified
    // overridden in certain situations. Please see comments below for details.
    //

    int nMaxPhoneLen = 0;
    BOOL bTmp = FALSE;

    // service profile: .CMP file
    CIni iniTmp(pArgs->piniProfile->GetHInst(),pArgs->piniProfile->GetFile(), pArgs->piniProfile->GetRegPath());

    iniTmp.SetEntryFromIdx(nIdx);
    
    //
    // Set the read flags
    //
    if (pArgs->dwGlobalUserInfo & CM_GLOBAL_USER_INFO_READ_ICS_DATA)
    {
        LPTSTR pszICSDataReg = BuildICSDataInfoSubKey(pArgs->szServiceName);

        if (pszICSDataReg)
        {
            iniTmp.SetReadICSData(TRUE);
            iniTmp.SetICSDataPath(pszICSDataReg);
        }

        CmFree(pszICSDataReg);
    }

    LPTSTR pszTmp = iniTmp.GPPS(c_pszCmSection,c_pszCmEntryPhonePrefix);

    if (ppszDesc) 
    {
        *ppszDesc = iniTmp.GPPS(c_pszCmSection,c_pszCmEntryPhoneDescPrefix);
    }
    if (ppszDUN) 
    {
        *ppszDUN = iniTmp.GPPS(c_pszCmSection,c_pszCmEntryPhoneDunPrefix);
    }
    if (pdwCountryID) 
    {
        *pdwCountryID = iniTmp.GPPI(c_pszCmSection,c_pszCmEntryPhoneCountryPrefix);
    }
    if (ppszPhoneBookFile) 
    {
        LPTSTR pszPb = iniTmp.GPPS(c_pszCmSection,c_pszCmEntryPhoneSourcePrefix);
        
        //
        // If the value is empty, just store the ptr
        //
        
        if ((!*pszPb)) 
        {
            *ppszPhoneBookFile = pszPb;
        }
        else
        {
            *ppszPhoneBookFile = CmConvertRelativePath(pArgs->piniService->GetFile(), pszPb);
            CmFree(pszPb);
        }
    }
    if (ppszRegionName) 
    {
        *ppszRegionName = iniTmp.GPPS(c_pszCmSection, c_pszCmEntryRegion);
    }
    if (ppszServiceType) 
    {
        *ppszServiceType = iniTmp.GPPS(c_pszCmSection, c_pszCmEntryServiceType);
    }

    //
    // Get the extended form of the telephone number.
    //
    
    if (ppszCanonical) 
    {
        *ppszCanonical = iniTmp.GPPS(c_pszCmSection, c_pszCmEntryPhoneCanonical);
    }
    
    //
    // Set the phoneinfo flags
    //

    if (pdwPhoneInfoFlags)
    {
        *pdwPhoneInfoFlags = 0;

        //
        // Get the dial as long distance flag. Check CMS if no value found. 
        //

        int iTmp = iniTmp.GPPI(c_pszCmSection, c_pszCmEntryUseDialingRules, -1);
    
        if (-1 == iTmp)
        {
            iTmp = pArgs->piniService->GPPI(c_pszCmSection, c_pszCmEntryUseDialingRules, 1);                        
        }

        if (iTmp)
        {
            *pdwPhoneInfoFlags |= PIF_USE_DIALING_RULES;
        }
    }
    
    // 
    // Truncate phone string if we have one. 
    // Note: Admin can override our default, but we
    // must stay within RAS_MaxPhoneNumber chars.
    // 

    if (pszTmp && *pszTmp)
    {
        int nDefaultPhoneLen = (OS_NT ? MAX_PHONE_LENNT : MAX_PHONE_LEN95);
    
        nMaxPhoneLen = (int) pArgs->piniService->GPPI(c_pszCmSection, c_pszCmEntryMaxPhoneNumber, nDefaultPhoneLen);
    
        nMaxPhoneLen = __min(nMaxPhoneLen, RAS_MaxPhoneNumber);
    
        if ((int)lstrlenU(pszTmp) > nMaxPhoneLen)
        {
            pszTmp[nMaxPhoneLen] = TEXT('\0');
        }
    }

    //
    // Special handling for the case where we have a Phone number
    // but the CanonicalPhone value doesn't exist. This indicates 
    // that its either a legacy profile or a hand-edit. 
    //
        
    if (*pszTmp && ppszCanonical && *ppszCanonical && (!(**ppszCanonical)))
    {   
        //
        // This block is for handling LEGACY numbers only. If we detect a 
        // canonically formatted number (begins with "+"), then we re-format 
        // the number to fit our new scheme. Hand-edits are not modified, 
        // but PIF_USE_DIALING_RULES is turned off, which overrides the 
        // default setting for the flag (if any) specified in
        // the .CMS
        //

        if (pszTmp == CmStrchr(pszTmp, TEXT('+')))
        {
            *pdwPhoneInfoFlags |= PIF_USE_DIALING_RULES;

            if (*ppszCanonical)
            {
                CmFree(*ppszCanonical);
            }

            *ppszCanonical = CmStrCpyAlloc(pszTmp);

            StripCanonical(pszTmp);
        }
        else
        {
            *pdwPhoneInfoFlags &= ~PIF_USE_DIALING_RULES; // #284702
        }

    }

    return (pszTmp);
}


// write phone number dialing options to .CMP file

void PutPhoneByIdx(ArgsStruct *pArgs, 
                   UINT nIdx, 
                   LPCTSTR pszPhone, 
                   LPCTSTR pszDesc, 
                   LPCTSTR pszDUN, 
                   DWORD dwCountryID,
                   LPCTSTR pszRegionName,
                   LPCTSTR pszServiceType,
                   LPCTSTR pszPhoneBookFile,
                   LPCTSTR pszCanonical,
                   DWORD dwPhoneInfoFlags) 
{

    CIni iniTmp(pArgs->piniProfile->GetHInst(), pArgs->piniProfile->GetFile(), pArgs->piniProfile->GetRegPath());

    iniTmp.SetEntryFromIdx(nIdx);
    
    //
    // Set the write flags
    //
    if (pArgs->dwGlobalUserInfo & CM_GLOBAL_USER_INFO_WRITE_ICS_DATA)
    {
        LPTSTR pszICSDataReg = BuildICSDataInfoSubKey(pArgs->szServiceName);

        if (pszICSDataReg)
        {
            iniTmp.SetWriteICSData(TRUE);
            iniTmp.SetICSDataPath(pszICSDataReg);
        }

        CmFree(pszICSDataReg);
    }

    //
    // Store the raw form of the number
    //

    iniTmp.WPPS(c_pszCmSection, c_pszCmEntryPhonePrefix, pszPhone);

    //
    // Store the canonical form of the number
    //
    
    iniTmp.WPPS(c_pszCmSection, c_pszCmEntryPhoneCanonical, pszCanonical);

    
    iniTmp.WPPS(c_pszCmSection, c_pszCmEntryPhoneDescPrefix, pszDesc);
    iniTmp.WPPS(c_pszCmSection, c_pszCmEntryPhoneDunPrefix, pszDUN);
    iniTmp.WPPI(c_pszCmSection, c_pszCmEntryPhoneCountryPrefix, dwCountryID);
    iniTmp.WPPS(c_pszCmSection, c_pszCmEntryRegion, pszRegionName);
    iniTmp.WPPS(c_pszCmSection, c_pszCmEntryServiceType, pszServiceType);
    
    //
    // If there is a phonebookfile path, convert it to relative form
    //

    if (pszPhoneBookFile && *pszPhoneBookFile)
    {
        LPTSTR pszTmp = ReducePathToRelative(pArgs, pszPhoneBookFile);    

        if (pszTmp)
        {
            iniTmp.WPPS(c_pszCmSection, c_pszCmEntryPhoneSourcePrefix, pszTmp);
        }

        CmFree(pszTmp);
    }

    iniTmp.WPPB(c_pszCmSection, c_pszCmEntryUseDialingRules, (dwPhoneInfoFlags & PIF_USE_DIALING_RULES));
}

//+----------------------------------------------------------------------------
//
// Function:  LoadPhoneInfoFromProfile
//
// Synopsis:  Load phone number information for profile to the dial info structure
//
// Arguments: ArgsStruct *pArgs - 
//
// Returns:   Nothing
//
// History:   fengsun Created Header    3/5/98
//
//+----------------------------------------------------------------------------
void LoadPhoneInfoFromProfile(ArgsStruct *pArgs)
{
    for (int nPhoneIdx=0; nPhoneIdx<MAX_PHONE_NUMBERS; nPhoneIdx++) 
    {
        LPTSTR pszDUN = NULL;
        LPTSTR pszDesc = NULL;
        LPTSTR pszPhoneBookFile = NULL;
        LPTSTR pszRegionName = NULL;
        LPTSTR pszServiceType = NULL;
        LPTSTR pszCanonical = NULL;
        DWORD dwCountryID;
        DWORD dwPhoneInfoFlags;

        //
        // get phone number by index; Phone0, Phone1 , etc...
        //

        LPTSTR pszPhone = GetPhoneByIdx(pArgs, 
                                    nPhoneIdx, 
                                    &pszDesc, 
                                    &pszDUN, 
                                    &dwCountryID, 
                                    &pszRegionName, 
                                    &pszServiceType,
                                    &pszPhoneBookFile,
                                    &pszCanonical,
                                    &dwPhoneInfoFlags);

        (void)StringCchCopyEx(pArgs->aDialInfo[nPhoneIdx].szPhoneNumber, 
                              CELEMS(pArgs->aDialInfo[nPhoneIdx].szPhoneNumber),
                              pszPhone, NULL, NULL, STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE);

        pArgs->aDialInfo[nPhoneIdx].dwCountryID = dwCountryID;


        (void)StringCchCopyEx(pArgs->aDialInfo[nPhoneIdx].szDUN, 
                              CELEMS(pArgs->aDialInfo[nPhoneIdx].szDUN),
                              pszDUN, NULL, NULL, STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE);

        (void)StringCchCopyEx(pArgs->aDialInfo[nPhoneIdx].szPhoneBookFile, 
                              CELEMS(pArgs->aDialInfo[nPhoneIdx].szPhoneBookFile),
                              pszPhoneBookFile, NULL, NULL, STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE);

        (void)StringCchCopyEx(pArgs->aDialInfo[nPhoneIdx].szDesc, 
                              CELEMS(pArgs->aDialInfo[nPhoneIdx].szDesc),
                              pszDesc, NULL, NULL, STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE);

        (void)StringCchCopyEx(pArgs->aDialInfo[nPhoneIdx].szRegionName, 
                              CELEMS(pArgs->aDialInfo[nPhoneIdx].szRegionName),
                              pszRegionName, NULL, NULL, STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE);

        (void)StringCchCopyEx(pArgs->aDialInfo[nPhoneIdx].szServiceType, 
                              CELEMS(pArgs->aDialInfo[nPhoneIdx].szServiceType),
                              pszServiceType, NULL, NULL, STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE);
        
        (void)StringCchCopyEx(pArgs->aDialInfo[nPhoneIdx].szCanonical, 
                              CELEMS(pArgs->aDialInfo[nPhoneIdx].szCanonical),
                              pszCanonical, NULL, NULL, STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE);
                
        pArgs->aDialInfo[nPhoneIdx].dwPhoneInfoFlags = dwPhoneInfoFlags;
    

        //
        // Cleanup
        //
        CmFree(pszDUN);
        CmFree(pszPhone);
        CmFree(pszDesc);
        CmFree(pszPhoneBookFile);
        CmFree(pszRegionName); 
        CmFree(pszServiceType);
        CmFree(pszCanonical);

    } // for loop
}

//+----------------------------------------------------------------------------
//
// Function:  LoadDialInfo
//
// Synopsis: load dialup information 
//
// Arguments: ArgsStruct *pArgs     - Ptr to glbal Args struct
//            HWND hwndDlg          - HWND of main dialog
//            BOOL fInstallModem    - Whether we should check modem isntall
//            BOOL fAlwaysMunge     - Whether we should munge the phone number
//
// Returns:   DWORD - ERROR_SUCCESS if load successfuly
//                    ERROR_PORT_NOT_AVAILABLE if can not find any modem
//                    ERROR_BAD_PHONE_NUMBER either there is no primary phone #
//                                        or failed to convert it to dialable #
//
// History:   10/24/97  fengsun  Created Header and change return type to DWORD 
//            02/08/99  nickball Added fAlwaysMunge
//
//+----------------------------------------------------------------------------
DWORD LoadDialInfo(ArgsStruct *pArgs, HWND hwndDlg, BOOL fInstallModem, BOOL fAlwaysMunge) 
{
    DWORD dwRet = ERROR_SUCCESS;

    if (pArgs->bDialInfoLoaded)
    {
        if (pArgs->aDialInfo[0].szDialablePhoneNumber[0] == TEXT('\0') &&
            pArgs->aDialInfo[1].szDialablePhoneNumber[0] == TEXT('\0'))
        {
            return ERROR_BAD_PHONE_NUMBER;
        }
        else
        {            
            //
            // If fAlways munge is set, then stick around.
            //

            if (!fAlwaysMunge)
            {
                return ERROR_SUCCESS;
            }
        }   
    }

    //
    // Don't need to repeat ourselves
    //

    if (!pArgs->bDialInfoLoaded)
    {
        pArgs->fNoDialingRules = pArgs->piniService->GPPB(c_pszCmSection, c_pszCmNoDialingRules);

        //
        // Do a full test on just the modem
        //
   
        if (fInstallModem)
        {
            pArgs->dwExitCode = CheckAndInstallComponents(CC_MODEM, hwndDlg, pArgs->szServiceName);

            if (pArgs->dwExitCode != ERROR_SUCCESS)
            {      
                dwRet = ERROR_PORT_NOT_AVAILABLE;
                goto LoadDialInfoExit;
            }
        }

        //
        // Establish TAPI link before we continue
        //

        if (!LinkToTapi(&pArgs->tlsTapiLink, "TAPI32") )
        {
            //
            // Link to TAPI failed.  
            // If unattended, return with failure.
            // Otherwise, try to install components and LinkToTapi again
            //

            pArgs->dwExitCode = ERROR_PORT_NOT_AVAILABLE;

            if (!(pArgs->dwFlags & FL_UNATTENDED))
            {
                pArgs->dwExitCode = CheckAndInstallComponents(CC_MODEM | CC_RNA | CC_RASRUNNING, 
                                                              hwndDlg, pArgs->szServiceName);
            }

            if (pArgs->dwExitCode != ERROR_SUCCESS || !LinkToTapi(&pArgs->tlsTapiLink, "TAPI32"))
            {
                pArgs->szDeviceType[0] = TEXT('\0');
                pArgs->szDeviceName[0] = TEXT('\0');
                dwRet = ERROR_PORT_NOT_AVAILABLE;
                goto LoadDialInfoExit;
            }
        }

        //
        // RasEnumDevice and LineInitialize is SLOW.  It takes 50% of the start-up time
        //
        if (!PickModem(pArgs, pArgs->szDeviceType, pArgs->szDeviceName)) 
        {
            //
            // Because pick modem failed we need to check if we have RAS/Modem installed
            //
            ClearComponentsChecked();

            //
            // No modem is installed.  
            // If unattended or caller does not want to install modem, return with failure.
            // Otherwise, try to install the modem and call pick modem again
            //
            pArgs->dwExitCode = ERROR_PORT_NOT_AVAILABLE;

            if (!(pArgs->dwFlags & FL_UNATTENDED) && fInstallModem)
            {
                pArgs->dwExitCode = CheckAndInstallComponents(CC_MODEM | CC_RNA | CC_RASRUNNING, 
                                                              hwndDlg, pArgs->szServiceName);
            }

            if (pArgs->dwExitCode != ERROR_SUCCESS || 
                    !PickModem(pArgs, pArgs->szDeviceType, pArgs->szDeviceName))
            {
                pArgs->szDeviceType[0] = TEXT('\0');
                pArgs->szDeviceName[0] = TEXT('\0');
                dwRet = ERROR_PORT_NOT_AVAILABLE;
                goto LoadDialInfoExit;
            }
        }
    }

    
    //
    // See if munge is required and Cleanup as needed
    //

    if (!pArgs->bDialInfoLoaded || TRUE == fAlwaysMunge)
    {
        MungeDialInfo(pArgs);

        pArgs->bDialInfoLoaded = TRUE;
    }

    if (pArgs->aDialInfo[0].szDialablePhoneNumber[0] == TEXT('\0') &&
        pArgs->aDialInfo[1].szDialablePhoneNumber[0] == TEXT('\0'))
    {
        dwRet = ERROR_BAD_PHONE_NUMBER;
    }

LoadDialInfoExit:

    return dwRet;
}

//+----------------------------------------------------------------------------
//
// Function: MungeDialInfo
//
// Synopsis: Encapsulates the munging of the phone numbers prior to dialing
//
// Arguments: ArgsStruct *pArgs - Ptr to global Args struct
//
// Returns:   Nothing - Check Dialable string and fNeedConfigureTapi
//
// History:   02/08/99 nickball Created - pulled from LoadDialInfo
//
//+----------------------------------------------------------------------------
VOID MungeDialInfo(ArgsStruct *pArgs)
{
    for (int nPhoneIdx=0; nPhoneIdx<MAX_PHONE_NUMBERS; nPhoneIdx++) 
    {
        //
        // If dialing rules is disabled, then just use the NonCanonical #
        //

        if (pArgs->fNoDialingRules)      
        {
            lstrcpynU(pArgs->aDialInfo[nPhoneIdx].szDialablePhoneNumber,
                        pArgs->aDialInfo[nPhoneIdx].szPhoneNumber, CELEMS(pArgs->aDialInfo[nPhoneIdx].szDialablePhoneNumber));

            lstrcpynU(pArgs->aDialInfo[nPhoneIdx].szDisplayablePhoneNumber,
                        pArgs->aDialInfo[nPhoneIdx].szPhoneNumber, CELEMS(pArgs->aDialInfo[nPhoneIdx].szDisplayablePhoneNumber));

            pArgs->aDialInfo[nPhoneIdx].szCanonical[0] = TEXT('\0');

            continue;
        }
                
        LPTSTR pszDialableString= NULL;

        //
        // Retrieve the number based upon dialing rules and munge it.
        //
        
        LPTSTR pszPhone;
            
        if (pArgs->aDialInfo[nPhoneIdx].dwPhoneInfoFlags & PIF_USE_DIALING_RULES)
        {
            pszPhone = CmStrCpyAlloc(pArgs->aDialInfo[nPhoneIdx].szCanonical);
        }
        else
        {
            pszPhone = CmStrCpyAlloc(pArgs->aDialInfo[nPhoneIdx].szPhoneNumber);
        }

        if (pszPhone && pszPhone[0])
        {
            //
            // If we can't munge the number, display an error
            // 

            if (pArgs->szDeviceName[0] && 
                ERROR_SUCCESS != MungePhone(pArgs->szDeviceName,
                                            &pszPhone,
                                            &pArgs->tlsTapiLink,
                                            g_hInst,
                                            pArgs->aDialInfo[nPhoneIdx].dwPhoneInfoFlags & PIF_USE_DIALING_RULES,
                                            &pszDialableString,
                                            pArgs->fAccessPointsEnabled))
            {
                CmFree(pszPhone);
                pszPhone = CmStrCpyAlloc(TEXT(""));          // CmFmtMsg(g_hInst,IDMSG_CANTFORMAT);
                pszDialableString = CmStrCpyAlloc(TEXT("")); // CmFmtMsg(g_hInst,IDMSG_CANTFORMAT);
            }
            else if (!pszDialableString || pszDialableString[0] == '\0')
            {                
                //
                // So what happened now? pszPhone is not empty, but after
                // we munge the phone, which means applying TAPI rules, 
                // pszDialbleString becomes empty. This means only one 
                // thing: TAPI isn't intialized.
                //
                // Note: If you uninstall TAPI between launching the app.
                // and pressing connect, all bets are off with the above.
                //
                // This flag will be reset in CheckTapi(), which will put
                // up a TAPI configuration dialog and ask the user to fill
                // up such information
                //
            
                pArgs->fNeedConfigureTapi = TRUE;    
            }
        } 

        // Copy the munged number
        
        //
        // Unless explicitly disabled we always apply TAPI rules
        // in order to pick up TONE/PULSE, etc.
        //

        if (NULL != pszDialableString)
        {
            lstrcpynU(pArgs->aDialInfo[nPhoneIdx].szDialablePhoneNumber,
                    pszDialableString, CELEMS(pArgs->aDialInfo[nPhoneIdx].szDialablePhoneNumber));

            lstrcpynU(pArgs->aDialInfo[nPhoneIdx].szDisplayablePhoneNumber,
                    pszPhone, CELEMS(pArgs->aDialInfo[nPhoneIdx].szDisplayablePhoneNumber));
        }
        else
        {
            if (NULL != pszPhone)
            {
                //
                // Just do it on WIN32 because our TAPI checks were done above  
                //

                lstrcpynU(pArgs->aDialInfo[nPhoneIdx].szDialablePhoneNumber,
                        pszPhone, CELEMS(pArgs->aDialInfo[nPhoneIdx].szDialablePhoneNumber));

                lstrcpynU(pArgs->aDialInfo[nPhoneIdx].szDisplayablePhoneNumber,
                        pszPhone, CELEMS(pArgs->aDialInfo[nPhoneIdx].szDisplayablePhoneNumber));
            }
        }
        
        CmFree(pszPhone);
        CmFree(pszDialableString);

    } // for loop
}

//+---------------------------------------------------------------------------
//
//  Function:   LoadHelpFileInfo
//
//  Synopsis:   Load the help file name
//
//  Arguments:  pArgs [the ptr to ArgsStruct]
//
//  Returns:    NONE
//
//  History:    henryt  Created     3/5/97
//              byao    Modified    3/20/97     to handle empty helpfile string
//----------------------------------------------------------------------------
void LoadHelpFileInfo(ArgsStruct *pArgs) 
{
    MYDBGASSERT(pArgs);
    
    //
    // Look for a custom helpfile name, otherwise use default.
    //

    LPTSTR pszTmp = pArgs->piniService->GPPS(c_pszCmSection, c_pszCmEntryHelpFile);
   
    if (NULL == pszTmp || 0 == pszTmp[0])
    {
        CmFree(pszTmp);
        pszTmp = CmStrCpyAlloc(c_pszDefaultHelpFile);
    }

    //
    // Make sure that any relative path is converted to full
    //

    pArgs->pszHelpFile = CmConvertRelativePath(pArgs->piniService->GetFile(), pszTmp);
    
    CmFree(pszTmp);
}

//
// CopyPhone: 
//
void CopyPhone(ArgsStruct *pArgs, 
               LPRASENTRY preEntry, 
               DWORD dwEntry) 
{
    LPTSTR pszPhone = NULL;
    LPTSTR pszCanonical = NULL;
    LPTSTR pszTmp;
    LPTSTR pszDescription = NULL;
    BOOL Setcountry = FALSE;
    DWORD dwPhoneInfoFlags = 0;

    pszPhone = GetPhoneByIdx(pArgs,(UINT) dwEntry, &pszDescription, 
                                NULL, NULL, NULL, 
                                NULL, NULL, &pszCanonical, &dwPhoneInfoFlags);
    //
    // If "Use Dialing Rules" turn of CountryAndAreaCodes option
    // 

    if (dwPhoneInfoFlags & PIF_USE_DIALING_RULES)
    {
        //
        // We want to use dialing rules, so parse the canonical form 
        // of the number to get the country and area codes for the entry
        //
        
        pszTmp = CmStrchr(pszCanonical,TEXT('+'));
        if (pszTmp) 
        {
            preEntry->dwCountryCode = CmAtol(pszTmp+1);
            
            //
            // NOTE: Currently CM uses code and ID interchangeably
            // The countryID value in the .CMP is actually the country
            // code used when constructing the phone number in its
            // canonical format. This is probably not entirely correct
            // but we maitain consistency with it here by using the 
            // country code parsed from the number as the country ID.
            //

            preEntry->dwCountryID = preEntry->dwCountryCode; 

            preEntry->dwfOptions |= RASEO_UseCountryAndAreaCodes;
            Setcountry = TRUE;
        }
    
        if (Setcountry)
        {
            pszTmp = CmStrchr(pszCanonical,'('); //strip out area code
            if (pszTmp) 
            {
                (void)StringCchPrintfEx(preEntry->szAreaCode, CELEMS(preEntry->szAreaCode), NULL, NULL, 
                                        (STRSAFE_IGNORE_NULLS | STRSAFE_NULL_ON_FAILURE), TEXT("%u"), CmAtol(pszTmp+1));
            }
            pszTmp = CmStrchr(pszCanonical,')');
            if (pszTmp) 
            {
                ++pszTmp;
                while(*pszTmp == ' ') 
                    ++pszTmp; //remove whitespace
            }
            else
            { 
                // no area code

                preEntry->szAreaCode[0]=TEXT('\0');

                pszTmp = CmStrchr(pszCanonical,' ');
                if (pszTmp)
                {
                    while(*pszTmp == ' ') 
                        ++pszTmp; // skip past space - may need MBCS change
                }
            }
        }
    }
    else
    {
        //
        // Use the straight up phone number and don't apply rules
        //

        preEntry->dwfOptions &= ~RASEO_UseCountryAndAreaCodes;
        pszTmp = pszPhone;
    }

    if ((NULL != pszTmp) && *pszTmp)
    {
        lstrcpynU(preEntry->szLocalPhoneNumber, pszTmp, CELEMS(preEntry->szLocalPhoneNumber));
    }
    else
    {
        lstrcpynU(preEntry->szLocalPhoneNumber, TEXT(" "), CELEMS(preEntry->szLocalPhoneNumber));//prevent zero from appearing
    }

    CmFree(pszPhone);
    CmFree(pszCanonical);
    CmFree(pszDescription);
}


//+----------------------------------------------------------------------------
//
// Function:  AppendStatusPane
//
// Synopsis:  Append the text to the main dialog status window
//
// Arguments: HWND hwndDlg - The main dialog window handle
//            DWORD dwMsgId - The resource id of the message
//
// Returns:   Nothing
//
// History:   Created Header    10/24/97
//
//+----------------------------------------------------------------------------
void AppendStatusPane(HWND hwndDlg, 
                  DWORD dwMsgId) 
{
    LPTSTR pszTmp = CmFmtMsg(g_hInst,dwMsgId);

    if (pszTmp != NULL)
    {
        AppendStatusPane(hwndDlg,pszTmp);
        CmFree(pszTmp);
    }
}

//
// AppendStatusPane: Update the original status, append new message 'pszMsg' 
// at the end
//

void AppendStatusPane(HWND hwndDlg, 
                        LPCTSTR pszMsg) 
{
    size_t nLines;

    //
    // Get the existing message 
    //
    
    LPTSTR pszStatus = CmGetWindowTextAlloc(hwndDlg, IDC_MAIN_STATUS_DISPLAY);
   
    LPTSTR pszTmp = CmStrrchr(pszStatus, TEXT('\n'));
    
    if (!pszTmp) 
    { 
        // empty message, so simply display 'pszMsg'
        CmFree(pszStatus);
        SetDlgItemTextU(hwndDlg, IDC_MAIN_STATUS_DISPLAY,pszMsg);
        //
        // force an update right away
        //
        UpdateWindow(GetDlgItem(hwndDlg, IDC_MAIN_STATUS_DISPLAY));
        return;
    }

    pszTmp[1] = 0;
    CmStrCatAlloc(&pszStatus,pszMsg); // append pszMsg at the end of old message
    nLines = 0;
    pszTmp = pszStatus + lstrlenU(pszStatus);
    
    while (pszTmp != pszStatus) 
    {
        pszTmp--;
        if (*pszTmp == '\n') 
        {
            if (++nLines == 2) 
            {
                lstrcpyU(pszStatus,pszTmp+1);
                break;
            }
        }
    }
    
    SetDlgItemTextU(hwndDlg,IDC_MAIN_STATUS_DISPLAY,pszStatus);
    SendDlgItemMessageU(hwndDlg,IDC_MAIN_STATUS_DISPLAY,EM_SCROLL,SB_PAGEDOWN,0);
    CmFree(pszStatus);
    //
    // force an update right away
    //
    UpdateWindow(GetDlgItem(hwndDlg, IDC_MAIN_STATUS_DISPLAY));
}

// bitmap logo loading code - took this out of LoadFromFile so it can
// be called in multiple cases - like when the FS OC loading code
// fails, we can degrade gracefully with this.

VOID LoadLogoBitmap(ArgsStruct * pArgs, 
                    HWND hwndDlg)
{
    LPTSTR pszTmp;

    pszTmp = pArgs->piniService->GPPS(c_pszCmSection, c_pszCmEntryLogo);
    if (*pszTmp) 
    {
        //
        // Make sure we have a full path (if appropriate) and load logo bitmap
        //

        LPTSTR pszFile = CmConvertRelativePath(pArgs->piniService->GetFile(), pszTmp);

        pArgs->BmpData.hDIBitmap = CmLoadBitmap(g_hInst, pszFile);

        CmFree(pszFile);
    }
    
    CmFree(pszTmp);
    
    if (!pArgs->BmpData.hDIBitmap)
    {
        pArgs->BmpData.hDIBitmap = CmLoadBitmap(g_hInst, MAKEINTRESOURCE(IDB_APP));
    }

    //
    // If we have a handle, create a new Device Dependent bitmap 
    //
    
    if (pArgs->BmpData.hDIBitmap)
    {       
        pArgs->BmpData.phMasterPalette = &pArgs->hMasterPalette;
        pArgs->BmpData.bForceBackground = TRUE; // paint as a background app

        if (CreateBitmapData(pArgs->BmpData.hDIBitmap, &pArgs->BmpData, hwndDlg, TRUE))
        {
            SendDlgItemMessageU(hwndDlg,IDC_MAIN_BITMAP,STM_SETIMAGE,IMAGE_BITMAP,
                                (LPARAM) &pArgs->BmpData);
        }
    }
}

const LONG MAX_SECTION   = 512;

HRESULT LoadFutureSplash(ArgsStruct * pArgs, 
                         HWND hwndDlg)
{
    // set up the Future Splash OC container.
    LPCTSTR pszFile = pArgs->piniBoth->GetFile();
    TCHAR   achSections[MAX_SECTION] = {0};
    HRESULT hr;
    LPTSTR  pszVal = NULL;
    LPTSTR  pszTmp = NULL;
    LPICMOCCtr pCtr;

    pArgs->pCtr = new CICMOCCtr(hwndDlg, ::GetDlgItem(hwndDlg, IDC_MAIN_BITMAP));
    if (!pArgs->pCtr)
    {
        goto MemoryError;
    }

    if (!pArgs->pCtr->Initialized())
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    
    pCtr = pArgs->pCtr;

    if (!::GetPrivateProfileStringU(
            c_pszCmSectionAnimatedLogo,
            0,
            TEXT(""),
            achSections,
            NElems(achSections),
            pszFile))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    pszVal = (LPTSTR) CmMalloc(INTERNET_MAX_URL_LENGTH * sizeof(TCHAR));
    if (NULL == pszVal)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pszTmp = achSections;

    while (pszTmp[0])
    {
        // if this fails, we keep on looping, looking for
        // the next one.
        if (::GetPrivateProfileStringU(
               c_pszCmSectionAnimatedLogo,
               pszTmp,
               TEXT(""),
               pszVal,
               NElems(pszVal),
               pszFile))
        {
            if (lstrcmpiU(pszTmp, c_pszCmEntryAniMovie) == 0) // is this the 'movie' entry?
            {    
                //
                // Build full path from .CMP and relative path
                //
            
                LPTSTR pszMovieFileName = CmBuildFullPathFromRelative(pArgs->piniProfile->GetFile(), pszVal);

                if (!pszMovieFileName)
                {
                    hr = S_FALSE;
                    CmFree(pszMovieFileName);
                    goto Cleanup;           
                }

                //
                // Does this file exist?
                //

                if (FALSE == FileExists(pszMovieFileName))
                {
                    hr = S_FALSE;
                    CmFree(pszMovieFileName);
                    goto Cleanup;
                }
                lstrcpyU(pszVal, pszMovieFileName);  // store the full pathname back 
                CmFree(pszMovieFileName);
            }
            hr = pCtr->AddPropertyToBag(pszTmp, pszVal);
            if (S_OK != hr)
                goto Cleanup;
        }
        
        // get the next key name.
        pszTmp += (lstrlenU(pszTmp) + 1);
    }

    // create the Future Splash OC.
    hr = pCtr->CreateFSOC(&pArgs->olsOle32Link);
    if (S_OK != hr)
    {
        goto Cleanup;
    }

    // now, do the state mappings, no matter what happens, we won't
    // fail on this.  just keep on going.

    pCtr->SetFrameMapping(PS_Interactive, 
                          ::GetPrivateProfileIntU(c_pszCmSectionAnimatedActions, 
                                                  c_pszCmEntryAniPsInteractive, 
                                                  -1, 
                                                  pszFile));
    pCtr->SetFrameMapping(PS_Dialing, 
                          ::GetPrivateProfileIntU(c_pszCmSectionAnimatedActions, 
                                                  c_pszCmEntryAniPsDialing0, 
                                                  -1, 
                                                  pszFile));
    pCtr->SetFrameMapping(PS_RedialFrame, 
                          ::GetPrivateProfileIntU(c_pszCmSectionAnimatedActions, 
                                                  c_pszCmEntryAniPsDialing1, 
                                                  -1, 
                                                  pszFile));
    pCtr->SetFrameMapping(PS_Pausing, 
                          ::GetPrivateProfileIntU(c_pszCmSectionAnimatedActions, 
                                                  c_pszCmEntryAniPsPausing, 
                                                  -1, 
                                                  pszFile));
    pCtr->SetFrameMapping(PS_Authenticating, 
                          ::GetPrivateProfileIntU(c_pszCmSectionAnimatedActions, 
                                                  c_pszCmEntryAniPsAuthenticating, 
                                                  -1, 
                                                  pszFile));
    pCtr->SetFrameMapping(PS_Online, 
                          ::GetPrivateProfileIntU(c_pszCmSectionAnimatedActions, 
                                                  c_pszCmEntryAniPsOnline, 
                                                  -1, 
                                                  pszFile));
    pCtr->SetFrameMapping(PS_TunnelDialing, 
                          ::GetPrivateProfileIntU(c_pszCmSectionAnimatedActions, 
                                                  c_pszCmEntryAniPsTunnel, 
                                                  -1, 
                                                  pszFile));
    pCtr->SetFrameMapping(PS_Error, 
                          ::GetPrivateProfileIntU(c_pszCmSectionAnimatedActions, 
                                                  c_pszCmEntryAniPsError, 
                                                  -1, 
                                                  pszFile));    
Cleanup:
    if (pszVal)
    {
        CmFree(pszVal);
    }
    return hr;                                        

MemoryError:
    hr = E_OUTOFMEMORY;
    goto Cleanup;
}


//+---------------------------------------------------------------------------
//
//  Function:   LoadProperties
//
//  Synopsis:   This func loads CM Properties from cmp/cms, registry, password
//              cache, etc, into its internal variables.  This func should
//              only be called once.  This should not be specific to the main
//              sign-in dlg.  DO NOT do any icon/bitmap stuff, dlg specific 
//              stuff here.
//
//  Arguments:  pArgs [the ptr to ArgsStruct]
//
//  Returns:    NONE
//
//  History:    henryt  Created     5/2/97
//
//              t-urama Modified    08/02/00    Added Access Points
//----------------------------------------------------------------------------
void LoadProperties(
    ArgsStruct  *pArgs
)
{
    LPTSTR  pszTmp = NULL;
    LPTSTR  pszUserName = NULL;
    UINT    nTmp;

    CMTRACE(TEXT("Begin LoadProperties()"));

    //
    // First make sure we can use the RAS CredStore
    // This flag is used in the calls below
    //
    if (OS_NT5)
    {
        pArgs->bUseRasCredStore = TRUE;
    }

    //
    // Upgrade userinfo if necessary.  Note that we have
    // an upgrade from CM 1.0/1.1 cmp data and we also
    // have an upgrade of CM 1.2 registry data to
    // the method used in CM 1.3 on Win2k which uses both
    // the registry and RAS credential storage.
    //
    int iUpgradeType = NeedToUpgradeUserInfo(pArgs);

    if (c_iUpgradeFromRegToRas == iUpgradeType)
    {
        UpgradeUserInfoFromRegToRasAndReg(pArgs);
    }
    else if (c_iUpgradeFromCmp == iUpgradeType)
    {
        UpgradeUserInfoFromCmp(pArgs);
    }

    //
    // Need to refresh Credential support. The TRUE flag also sets the current creds
    // type inside the function. If an error occurs we can keep executing.
    //
    if(FALSE == RefreshCredentialTypes(pArgs, TRUE))
    {
        CMTRACE(TEXT("LoadProperties() - Error refreshing credential types."));
    }


    if (IsTunnelEnabled(pArgs)) 
    { 
        //
        // do we use the same username/password for tunneling?
        // This value is set by ISP, CM does not change it
        //
        pArgs->fUseSameUserName = pArgs->piniService->GPPB(c_pszCmSection, c_pszCmEntryUseSameUserName);

        //
        // read in inet username
        // Special case where the same user name isn't being used, and internet globals don't exist
        // Then we have to read the user name from the user creds store in order to pre-populate
        //
        DWORD dwRememberedCredType = pArgs->dwCurrentCredentialType;
        pszUserName = NULL;
        if ((FALSE == pArgs->fUseSameUserName) &&
            (CM_CREDS_GLOBAL == pArgs->dwCurrentCredentialType) &&
            (FALSE == (BOOL)(CM_EXIST_CREDS_INET_GLOBAL & pArgs->dwExistingCredentials)))
        {
            pArgs->dwCurrentCredentialType = CM_CREDS_USER;
        }

        GetUserInfo(pArgs, UD_ID_INET_USERNAME, (PVOID*)&pszUserName);

        //
        // Restore credential store
        //
        pArgs->dwCurrentCredentialType = dwRememberedCredType;

        if (pszUserName)
        {
            //
            // check username length
            //
            nTmp = (int) pArgs->piniService->GPPI(c_pszCmSection, c_pszCmEntryMaxUserName, UNLEN);
            if ((UINT)lstrlenU(pszUserName) > __min(UNLEN, nTmp)) 
            {
                CmFree(pszUserName);
                pArgs->szInetUserName[0] = TEXT('\0');
                SaveUserInfo(pArgs, UD_ID_INET_USERNAME, (PVOID)pArgs->szInetUserName);
            }
            else
            {
                lstrcpyU(pArgs->szInetUserName, pszUserName);
                CmFree(pszUserName);
            }
        }
        else
        {
            *pArgs->szInetUserName = TEXT('\0');
        }
        
        //
        // Read in inet password unless we are reconnecting in which case, we
        // already have the correct password, and we want to use it and dial
        // automatically. 
        //

        if (!(pArgs->dwFlags & FL_RECONNECT))
        {
            LPTSTR pszPassword = NULL;
            GetUserInfo(pArgs, UD_ID_INET_PASSWORD, (PVOID*)&pszPassword);
            if (!pszPassword)
            {
                CmWipePassword(pArgs->szInetPassword);
            }
            else 
            {
                nTmp = (int) pArgs->piniService->GPPI(c_pszCmSection, c_pszCmEntryMaxPassword, PWLEN);
                if ((UINT)lstrlenU(pszPassword) > __min(PWLEN, nTmp))
                {
                    CmFree(pszPassword);
                    pszPassword = CmStrCpyAlloc(TEXT(""));
                }
    
                lstrcpyU(pArgs->szInetPassword, pszPassword);               
                CmEncodePassword(pArgs->szInetPassword); // Never leave a PWD in plain text on heap
                
                CmWipePassword(pszPassword);
                CmFree(pszPassword);
            }
        }
    }
    
    //
    // The presence of either lpRasNoUser or lpEapLogonInfo indicates
    // that we retrieved credentials via WinLogon. We ignore cached 
    // creds in this situation.   
    //
    
    if ((!pArgs->lpRasNoUser) && (!pArgs->lpEapLogonInfo))
    {
        //
        // get username, domain, etc. from CMS file
        //

        GetUserInfo(pArgs, UD_ID_USERNAME, (PVOID*)&pszUserName);
        if (pszUserName)
        {
            //
            // check username length
            //
            nTmp = (int) pArgs->piniService->GPPI(c_pszCmSection, c_pszCmEntryMaxUserName, UNLEN);
            if ((UINT)lstrlenU(pszUserName) > __min(UNLEN, nTmp)) 
            {
                CmFree(pszUserName);
                pszUserName = CmStrCpyAlloc(TEXT(""));
                SaveUserInfo(pArgs, UD_ID_USERNAME, (PVOID)pszUserName);
            }
            lstrcpyU(pArgs->szUserName, pszUserName);
            CmFree(pszUserName);
        }
        else
        {
            *pArgs->szUserName = TEXT('\0');
        }

        //
        // Read in the standard password unless we are reconnecting in which case 
        // we already have the correct password, and we want to use it and dial
        // automatically. 
        //

        if (!(pArgs->dwFlags & FL_RECONNECT))
        {
            pszTmp = NULL;
            GetUserInfo(pArgs, UD_ID_PASSWORD, (PVOID*)&pszTmp);
            if (pszTmp) 
            {           
                //
                // max length for user password
                //
    
                nTmp = (int) pArgs->piniService->GPPI(c_pszCmSection,c_pszCmEntryMaxPassword,PWLEN);
                if ((UINT)lstrlenU(pszTmp) > __min(PWLEN,nTmp)) 
                {
                    CmFree(pszTmp);
                    pszTmp = CmStrCpyAlloc(TEXT(""));
                }
                lstrcpyU(pArgs->szPassword, pszTmp);
                CmEncodePassword(pArgs->szPassword); // Never leave a PWD in plain text on heap
                
                CmWipePassword(pszTmp);
                CmFree(pszTmp);
            }
            else
            {
                CmWipePassword(pArgs->szPassword);
            }
        }
    
        //
        // Load domain info
        //
   
        LPTSTR pszDomain = NULL;

        GetUserInfo(pArgs, UD_ID_DOMAIN, (PVOID*)&pszDomain);
        if (pszDomain)
        {
            nTmp = (int) pArgs->piniService->GPPI(c_pszCmSection, c_pszCmEntryMaxDomain, DNLEN);
        
            if (nTmp <= 0)
            {
                nTmp = DNLEN;
            }
        
            if ((UINT)lstrlenU(pszDomain) > __min(DNLEN, nTmp))
            {
                CmFree(pszDomain);
                pszDomain = CmStrCpyAlloc(TEXT(""));
            }
            lstrcpyU(pArgs->szDomain, pszDomain);
            CmFree(pszDomain);
        }
        else
        {
            *pArgs->szDomain = TEXT('\0');
        }
    } 

    //
    //  fDialAutomatically,
    //  fRememberMainPassword
    //
    if (pArgs->fHideDialAutomatically)
    {
        pArgs->fDialAutomatically = FALSE;
    }
    else
    {
        PVOID pv = &pArgs->fDialAutomatically;
        GetUserInfo(pArgs, UD_ID_NOPROMPT, &pv);
    }

    if (pArgs->fHideRememberPassword)
    {
        pArgs->fRememberMainPassword = FALSE;
    }
    else
    {
        //
        // For Win2K+ this gets trickier because we use the RAS cred store and 
        // we know which creds were saved. Thus we need to modify this flag according
        // to what credentials we actually have, insted of what was retrieved from the registry/file.
        // This needs to be done after calling the function that refreshes credential types (above).
        //
        if (OS_NT5)
        {
            if (CM_CREDS_USER == pArgs->dwCurrentCredentialType)
            {
                pArgs->fRememberMainPassword = ((BOOL)(pArgs->dwExistingCredentials & CM_EXIST_CREDS_MAIN_USER)? TRUE: FALSE);
            }
            else
            {
                pArgs->fRememberMainPassword = ((BOOL)(pArgs->dwExistingCredentials & CM_EXIST_CREDS_MAIN_GLOBAL)? TRUE: FALSE);
            }
        }
        else
        {
            PVOID pv = &pArgs->fRememberMainPassword;
            GetUserInfo(pArgs, UD_ID_REMEMBER_PWD, &pv);
        }
    }
    
    //
    // remember non-tunnel password?
    //
    if (pArgs->fHideRememberInetPassword)
    {
        pArgs->fRememberInetPassword = FALSE;
    }
    else
    {
        //
        // For Win2K+ this gets trickier because we use the RAS cred store and 
        // we know which creds were saved. Thus we need to modify this flag according
        // to what credentials we actually have, insted of what was retrieved from the registry/file.
        // This needs to be done after calling the function that refreshes credential types (above).
        //
        if (OS_NT5)
        {
            if (CM_CREDS_USER == pArgs->dwCurrentCredentialType)
            {
                pArgs->fRememberInetPassword = ((BOOL)(pArgs->dwExistingCredentials & CM_EXIST_CREDS_INET_USER)? TRUE: FALSE);
            }
            else
            {
                pArgs->fRememberInetPassword = ((BOOL)(pArgs->dwExistingCredentials & CM_EXIST_CREDS_INET_GLOBAL)? TRUE: FALSE);
            }
        }
        else
        {
            PVOID pv = &pArgs->fRememberInetPassword;
            GetUserInfo(pArgs, UD_ID_REMEMBER_INET_PASSWORD, &pv);
        }
    }

    //
    // Make sure that the passwords are empty if we don't want to remember them
    // unless we are reconnecting in which case we will just use what we have
    // from the previous connection. When the log on type is ICS don't want
    // to clear the passwords either.
    //
    if ((!(pArgs->dwFlags & FL_RECONNECT)) &&
        (!pArgs->lpRasNoUser) &&
        (!pArgs->lpEapLogonInfo) &&
        (CM_LOGON_TYPE_ICS != pArgs->dwWinLogonType))
    {
        //
        // NULL the password if dial-auto is disabled.
        //

        if (!pArgs->fRememberMainPassword)
        {
            CmWipePassword(pArgs->szPassword);
        }

        if (!pArgs->fRememberInetPassword)
        {
            CmWipePassword(pArgs->szInetPassword);
        }
    }
    
    //
    // has references
    //
    pszTmp = pArgs->piniService->GPPS(c_pszCmSectionIsp, c_pszCmEntryIspReferences);
    pArgs->fHasRefs = (pszTmp && *pszTmp ? TRUE : FALSE);
    CmFree(pszTmp);

    //
    // do we have valid pbk's?
    //
    pArgs->fHasValidTopLevelPBK = ValidTopLevelPBK(pArgs);
    if (pArgs->fHasRefs)
    {
        pArgs->fHasValidReferencedPBKs = ValidReferencedPBKs(pArgs);
    }

    //
    // Get idle settings for auto disconnect
    // 1.0 profile has a BOOL flag "Idle", if FALSE, IdleTimeout is ignored
    //

    if (!pArgs->piniBothNonFav->GPPB(c_pszCmSection, c_pszCmEntryIdle, TRUE))
    {
        //
        // If this is a 1.0 profile and Idle==0, set IdleTimeout to 0, so CMMOM works correctly
        //
        pArgs->dwIdleTimeout = 0;    // never timeout

        pArgs->piniProfile->WPPI(c_pszCmSection, c_pszCmEntryIdle, TRUE); // write back
        pArgs->piniProfile->WPPI(c_pszCmSection, c_pszCmEntryIdleTimeout, 0); // write back
    }
    else
    {
        pArgs->dwIdleTimeout = (int) pArgs->piniBothNonFav->GPPI(c_pszCmSection, 
                                                                 c_pszCmEntryIdleTimeout, 
                                                                 DEFAULT_IDLETIMEOUT);
    }

    //
    // get redial count
    // 1.0 profile has a BOOL flag "Redial", if FALSE, RedialCount is ignored
    //
    if (!pArgs->piniBothNonFav->GPPB(c_pszCmSection, c_pszCmEntryRedial, TRUE))
    {
        //
        // If this is a 1.0 profile and Redial==0, set RetryCount to 0
        //
        pArgs->nMaxRedials = 0;



        pArgs->piniBothNonFav->WPPI(c_pszCmSection, c_pszCmEntryRedialCount, 0); // write back
    }
    else
    {
        pArgs->nMaxRedials = (int) pArgs->piniBothNonFav->GPPI(c_pszCmSection, 
                                                               c_pszCmEntryRedialCount, 
                                                               DEFAULT_MAX_REDIALS);
    }
                   
    //
    // Get the redial delay value
    //
    
    pArgs->nRedialDelay = (int) pArgs->piniService->GPPI(c_pszCmSection,c_pszCmEntryRedialDelay,DEFAULT_REDIAL_DELAY);

    //
    // should we enable ISDN dial on demand?
    //
    pArgs->dwIsdnDialMode = pArgs->piniService->GPPI(c_pszCmSection, 
                                                     c_pszCmEntryIsdnDialMode,
                                                     CM_ISDN_MODE_SINGLECHANNEL);
    // 
    // Get the Tapi location from the registry
    //
    if (pArgs->fAccessPointsEnabled)
    {
        pArgs->tlsTapiLink.dwTapiLocationForAccessPoint = pArgs->piniProfile->GPPI(c_pszCmSection, 
                                                                                   c_pszCmEntryTapiLocation);
    }

    CMTRACE(TEXT("End LoadProperties()"));

}

//+---------------------------------------------------------------------------
//
//  Function:   LoadIconsAndBitmaps
//
//  Synopsis:   This func loads icon and bitmap settings.  It should be part
//              of the main dlg init.
//
//  Arguments:  pArgs [the ptr to ArgsStruct]
//              hwndDlg [the main dlg]
//
//  Returns:    NONE
//
//  History:    henryt  Copied from LoadFromFile()      5/2/97
//
//----------------------------------------------------------------------------
void LoadIconsAndBitmaps(
    ArgsStruct  *pArgs, 
    HWND        hwndDlg
) 
{
    LPTSTR  pszTmp;
    UINT    nTmp;

    // Load large icon name

    pszTmp = pArgs->piniService->GPPS(c_pszCmSection, c_pszCmEntryBigIcon);
    if (*pszTmp) 
    {
        //
        // Make sure we have a full path (if appropriate) and load big icon
        //

        LPTSTR pszFile = CmConvertRelativePath(pArgs->piniService->GetFile(), pszTmp);

        pArgs->hBigIcon = CmLoadIcon(g_hInst, pszFile);

        CmFree(pszFile);
    }
    CmFree(pszTmp);

    // Use default (EXE) large icon if no user icon found

    if (!pArgs->hBigIcon) 
    {
        pArgs->hBigIcon = CmLoadIcon(g_hInst, MAKEINTRESOURCE(IDI_APP));
    }

    SendMessageU(hwndDlg,WM_SETICON,ICON_BIG,(LPARAM) pArgs->hBigIcon); 

    // Load small icon name

    pszTmp = pArgs->piniService->GPPS(c_pszCmSection, c_pszCmEntrySmallIcon);
    if (*pszTmp) 
    {
        //
        // Make sure we have a full path (if appropriate) and load small icon
        //

        LPTSTR pszFile = CmConvertRelativePath(pArgs->piniService->GetFile(), pszTmp);

        pArgs->hSmallIcon = CmLoadSmallIcon(g_hInst, pszFile);

        CmFree(pszFile);
    }
    CmFree(pszTmp);

    // Use default (EXE) small icon if no user icon found

    if (!pArgs->hSmallIcon) 
    {
        pArgs->hSmallIcon = CmLoadSmallIcon(g_hInst, MAKEINTRESOURCE(IDI_APP));
    }
    
    SendMessageU(hwndDlg,WM_SETICON,ICON_SMALL,(LPARAM) pArgs->hSmallIcon);
   
    //
    // this is where the Bitmap gets loaded in.  Check to see first if we're doing
    // the Future Splash thang.  if so, no bitmap
    //
    //  Note that we do not load FutureSplash if this is WinLogon.  This is because
    //  Future Splash Animations can have imbedded actions and thus could be used
    //  to launch web pages, etc. from WinLogon as the system account.  Definitely
    //  would be a security hole.
    //

    nTmp = pArgs->piniService->GPPI(c_pszCmSection, c_pszCmEntryAnimatedLogo);
    if (!nTmp  || IsLogonAsSystem())
    {
        //
        // either there was no 'Animated Logo' entry, or it was 0, which means
        // we go ahead and load the bitmap.
        //

        LoadLogoBitmap(pArgs, hwndDlg);
    }
    else
    {
        //
        // if, for any reason, loading FS OC fails, go ahead and
        // degrade and load the logo bitmap.
        //

        if (S_OK != LoadFutureSplash(pArgs, hwndDlg))
        {
            LoadLogoBitmap(pArgs, hwndDlg);
        }
    }
}

//+----------------------------------------------------------------------------
//
// Function:  DoRasHangup
//
// Synopsis:  Hangup the given RAS device handle
//
// Arguments: prlsRasLink       - Ptr to RAS linkage struct
//            hRasConnection    - The RAS device to hangup
//            hwndDlg           - The main dlg to display "Disconnecting .. " msg
//                                Only used if fWaitForComplete is TRUE
//                                Optional, default = NULL
//            fWaitForComplete  - Whether to wait for Hangup to complete on 95
//                                If set to TRUE, will wait until hRasConnection 
//                                is invalid. Optional, default = FALSE
//            pfWaiting         - Ptr to boolean value indicating our wait state
//                                and whether Timer and Ras messages should be 
//                                ignored. Optional, default = NULL
//
// Returns:   DWORD - ERROR_SUCCESS if success or error code
//
// Note:      pArgs is removed so that the Disconnect path can use this function
//            thus concentrating the timing mess in one place.
//
// History:   fengsun   Created Header    10/22/97
//            fengsun   Add fWaitForComplete 12/18/97
//            nickball  Removed pArgs dependency
//
//+----------------------------------------------------------------------------

DWORD DoRasHangup(RasLinkageStruct *prlsRasLink, 
    HRASCONN hRasConnection, 
    HWND hwndDlg, 
    BOOL fWaitForComplete,
    LPBOOL pfWaiting)
{
    
    DWORD dwRes = ERROR_SUCCESS;

    MYDBGASSERT(hRasConnection != NULL);
    MYDBGASSERT(prlsRasLink->pfnHangUp != NULL);

    //
    // Do we need to check the return value 
    // now that RAS is going to disconnect modem too?
    //

    dwRes = prlsRasLink->pfnHangUp(hRasConnection);
    CMTRACE1(TEXT("DoRasHangup() RasHangup() returned %u."), dwRes);
    
    // On Win32 RasHangup returns immediately, so loop until we
    // are certain that the disconnected state had been reached

    if ((dwRes == ERROR_SUCCESS) && prlsRasLink->pfnGetConnectStatus) 
    {
        RASCONNSTATUS rcs;

        CMTRACE(TEXT("DoRasHangup() Waiting for hangup to complete"));

        //
        // On 95 Wait for HANGUP_TIMEOUT seconds
        // On NT wait until the connection is released
        // This will cause this to loop till the connection status 
        // is RASCS_Disconnected
        //

        #define HANGUP_TIMEOUT 60    // timeout for 95 hangup

        if (pfWaiting)
        {
            //
            // Keep the message looping to avoid freezing CM
            // But do not handle WM_TIMER and RAS msg
            //

            MYDBGASSERT(!*pfWaiting);
            *pfWaiting = TRUE;
        }

        if (fWaitForComplete && hwndDlg)
        {
            //
            // Display the disconnecting message, if we have to wait
            //
            LPTSTR pszTmp = CmLoadString(g_hInst,IDMSG_DISCONNECTING);
            SetDlgItemTextU(hwndDlg, IDC_MAIN_STATUS_DISPLAY, pszTmp); 
            CmFree(pszTmp);
        }

        DWORD dwStartWaitTime = GetTickCount(); 

        HCURSOR hWaitCursor = LoadCursorU(NULL,IDC_WAIT);

        ZeroMemory(&rcs,sizeof(rcs));
        rcs.dwSize = sizeof(rcs);

        while ((dwRes = prlsRasLink->pfnGetConnectStatus(hRasConnection,&rcs)) == ERROR_SUCCESS) 
        {
            //
            // If it is NT, or do not need to wait for hangup to complete,
            // RASCS_Disconnected state is considered hangup complete
            //
            if (rcs.rasconnstate == RASCS_Disconnected && 
               (!fWaitForComplete || OS_NT))
            {
                break; 
            }
               
            //
            // We only have time out for 95/98
            //
            if (OS_W9X && (GetTickCount() - dwStartWaitTime >= HANGUP_TIMEOUT * 1000))
            {
                CMTRACE(TEXT("DoRasHangup() Wait timed out"));
                break;
            }

            //
            // Try to dispatch message, however, some time the wait cursor is
            // changed back to arrow
            //

            MSG msg;
            while (PeekMessageU(&msg, NULL, 0, 0, PM_REMOVE))
            {
                if (msg.message != WM_SETCURSOR)
                {
                    TranslateMessage(&msg);
                    DispatchMessageU(&msg);

                    if (GetCursor() != hWaitCursor)
                    {
                        SetCursor(hWaitCursor);
                    }
                }
            }

            Sleep(500);
        }

        if (dwRes == ERROR_INVALID_HANDLE)
        {
            dwRes = ERROR_SUCCESS;
        }
        else
        {
            CMTRACE1(TEXT("MyRasHangup() RasGetConnectStatus(), GLE=%u."), dwRes);
        }
        
        if (pfWaiting)
        {
            *pfWaiting = FALSE;
        }
    }

    CMTRACE(TEXT("DoRasHangup() completed"));

    return dwRes;
}

//+----------------------------------------------------------------------------
//
// Function:  MyRasHangup
//
// Synopsis:  Simple wrapper for DoRasHangup, that takes pArgs as a param.
//
// Arguments: pArgs             - Ptr to global Args struct
//            hRasConnection    - The RAS device to hangup
//            hwndDlg           - The main dlg to display "Disconnecting .. " msg
//                                Only used if fWaitForComplete is TRUE
//                                Optional, default = NULL
//            fWaitForComplete  - Whether to wait for Hangup to complete on 95
//                                If set to TRUE, will wait until hRasConnection 
//                                is invalid. Optional, default = FALSE
//
// Returns:   DWORD - ERROR_SUCCESS if success or error code
//
// History:   nickball  Implemented as wrapper  2/11/98           
//
//+----------------------------------------------------------------------------
DWORD MyRasHangup(ArgsStruct *pArgs, 
    HRASCONN hRasConnection, 
    HWND ,
    BOOL fWaitForComplete)
{
    CMTRACE(TEXT("MyRasHangup() calling DoRasHangup()"));
    return DoRasHangup(&pArgs->rlsRasLink, hRasConnection, NULL, fWaitForComplete, &pArgs->fIgnoreTimerRasMsg);
}    

//+----------------------------------------------------------------------------
//
// Function:  HangupCM
//
// Synopsis:  hangup both dial-up and tunnel connection, if exist
//
// Arguments: ArgsStruct *pArgs - 
//            hwndDlg the main dlg to display "Disconnecting .. " msg
//            fWaitForComplete: Whether to wait for Hangup to complete on 95
//                              If set to TRUE, will wait until hRasConnection 
//                              is invalid.   
//
// Returns:   DWORD - 
//
// History:   fengsun Created Header    10/22/97
//            fengsun Add fWaitForComplete 12/18/97
//
//+----------------------------------------------------------------------------
DWORD HangupCM(ArgsStruct *pArgs, 
    HWND hwndDlg,
    BOOL fWaitForComplete,
    BOOL fUpdateTable) 
{
    MYDBGASSERT(pArgs);
    MYDBGASSERT(hwndDlg);
    CMTRACE(TEXT("HangupCM()"));

    if (!pArgs) 
    {
        CMTRACE(TEXT("HangupCM() invalid parameter."));
        return (ERROR_INVALID_PARAMETER);
    }

    DWORD dwRes = ERROR_SUCCESS;

    //
    // If change password dialog is up tell it to go away
    //
    if (pArgs->hWndChangePassword)
    {
        CMTRACE(TEXT("HangupCM() Terminating ChangePassword dialog"));
        PostMessage(pArgs->hWndChangePassword, WM_COMMAND, IDCANCEL, 0);
    }

    //
    // If Callback number dialog is up tell it to go away too.
    //

    if (pArgs->hWndCallbackNumber)
    {
        CMTRACE(TEXT("HangupCM() Terminating CallbackNumber dialog"));
        PostMessage(pArgs->hWndCallbackNumber, WM_COMMAND, IDCANCEL, 0);
    }
    
    //
    // If Callback number dialog is up tell it to go away too.
    //

    if (pArgs->hWndRetryAuthentication)
    {
        CMTRACE(TEXT("HangupCM() Terminating RetryAuthentication dialog"));
        PostMessage(pArgs->hWndRetryAuthentication, WM_COMMAND, IDCANCEL, 0);
    }
    
    //
    // If table updates are desired set the entry to the disconnecting state
    // Note: In the case of redial, we don't want to modify the table state
    // even though we are hanging up because technically we are still connecting.
    //
    
    if (fUpdateTable)
    {
        UpdateTable(pArgs, CM_DISCONNECTING);
    }

    //
    // Check the RasLink pointer and hang up the device, tunnel first
    //
#ifdef DEBUG
    if (!pArgs->rlsRasLink.pfnHangUp)
    {
        CMTRACE(TEXT("HangupCM() can't hang up."));
    }
#endif
    //
    // Show wait cursor before hanging up
    //
        
    HCURSOR hPrev;

    if (hwndDlg) 
    {
        hPrev = SetCursor(LoadCursorU(NULL,IDC_WAIT));
        ShowCursor(TRUE);
    }
    
    //
    // The assumption is that we have been connected, why else would we call 
    // hangup. So release statistics handles, hooks, etc.
    //

    if (pArgs->pConnStatistics)
    {
        pArgs->pConnStatistics->Close();
    }
    
    //
    // Hangup connections
    //

    if (pArgs->rlsRasLink.pfnHangUp && pArgs->hrcTunnelConn) 
    {
        //
        // first, hangup tunnel connection
        //

        CMTRACE(TEXT("HangupCM() calling MyRasHangup() for tunnel connection"));

        dwRes = MyRasHangup(pArgs, pArgs->hrcTunnelConn, hwndDlg, fWaitForComplete);
#ifdef DEBUG
        if (dwRes != ERROR_SUCCESS)
        {
            CMTRACE1(TEXT("MyRasHangup failed, GLE=%u."), GetLastError());
        }
#endif      
        pArgs->hrcTunnelConn = NULL;
    }

    //
    // If we have a valid link and handle, hangup the modem
    //

    if (pArgs->rlsRasLink.pfnHangUp && pArgs->hrcRasConn) 
    {
        CMTRACE(TEXT("HangupCM() calling MyRasHangup() for dial-up connection"));
        dwRes = MyRasHangup(pArgs, pArgs->hrcRasConn);      
    }
    
    // Restore cursor
        
    if (hwndDlg) 
    {
        ShowCursor(FALSE);
        SetCursor(hPrev);
    }

    pArgs->hrcRasConn = NULL;
    
    //
    // Update the Connection table if asked
    //
    
    if (fUpdateTable)
    {
        UpdateTable(pArgs, CM_DISCONNECTED);
    }

    return (dwRes);
}

//+----------------------------------------------------------------------------
//
// Function:  CleanupZapThread
//
// Synopsis:  Simple helper to deal with signaling an event to stop Zap thread 
//            and waiting for the thread to terminate.
//
// Arguments: HANDLE hEvent - The event handle
//            HANDLE hThread - Handle to the Zap thread.
//
// Returns:   static void - Nothing
//
// History:   nickball    Created    3/5/98
//
//+----------------------------------------------------------------------------
static void CleanupZapThread(HANDLE hEvent,
                             HANDLE hThread)
{
    MYDBGASSERT(hEvent);
    MYDBGASSERT(hThread);

    //
    // If we have an event, then it is assumed that have a Zap thread running
    //

    if (hEvent)
    {       
        //
        // Signal termination to notify thread that we are done
        //
        
        BOOL bRes = SetEvent(hEvent);
#ifdef DEBUG
        if (!bRes)
        {
            CMTRACE1(TEXT("CleanupZapThread() SetEvent() failed, GLE=%u."), GetLastError());
        }
#endif

        if (hThread)
        {
            //
            // Wait for thread to terminate, but pump messages in the mean time
            //
                        
            BOOL bDone = FALSE;
            DWORD dwWaitCode;

            while (FALSE == bDone)
            {
                dwWaitCode = MsgWaitForMultipleObjects(1, &hThread, FALSE, MAX_OBJECT_WAIT, QS_ALLINPUT);

                switch(dwWaitCode)
                {
                    //
                    // Thread has terminated, or time is up, we're done here
                    //

                    case -1:
                        CMTRACE1(TEXT("CleanupZapThread() MsgWaitForMultipleObjects returned an error GLE=%u."), 
                            GetLastError());

                    case WAIT_TIMEOUT:
                    case WAIT_OBJECT_0:
                        bDone = TRUE;
                        break;

                    //
                    // If there is a message in the queue, process it
                    //

                    case WAIT_OBJECT_0+1:
                    {                        
                        MSG msg;
                        while (PeekMessageU(&msg, 0, 0, 0, PM_REMOVE))
                        {
                            TranslateMessage(&msg);
                            DispatchMessageU(&msg);
                        }
                    
                        break;
                    }                                       
                    
                    //
                    // Unexpected, report, but continue
                    //

                    default:
                        MYDBGASSERT(FALSE);                       
                }
            }

            //
            // We are done with the thread, close the handle
            //
            
            bRes = CloseHandle(hThread);
#ifdef DEBUG
            if (!bRes)
            {
                CMTRACE1(TEXT("CleanupZapThread() CloseHandle(hThread) failed, GLE=%u."), GetLastError());
            }
#endif
        }
        
        //
        // Close our event handle
        //

        bRes = CloseHandle(hEvent);
#ifdef DEBUG
        if (!bRes)
        {
            CMTRACE1(TEXT("CleanupZapThread() CloseHandle(hEvent) failed, GLE=%u."), GetLastError());
        }
#endif
    }
}

//+----------------------------------------------------------------------------
//
// Function:  OnConnectedCM
//
// Synopsis:  Process WM_CONNECTED_CM which indicates that we are connected and
//            connect processing such as connect actions can begin
//
// Arguments: HWND hwndDlg - HWND of main dialog
//            ArgsStruct *pArgs - Ptr to global Args struct
//
// Returns:   Nothing
//
// History:   nickball      Created    03/05/98
//
//+----------------------------------------------------------------------------
void OnConnectedCM(HWND hwndDlg, ArgsStruct *pArgs)
{
    HANDLE hEvent = NULL;
    HANDLE hThread = NULL;
    CActionList ConnectActList;
    CActionList AutoActList;

    //
    // Check to see if we are in a valid state to connect. if not just abort.
    //
    MYDBGASSERT(pArgs);

    if (pArgs->hrcRasConn == NULL && pArgs->hrcTunnelConn == NULL)
    {
        CMTRACE(TEXT("Bogus OnConnectCM msg received"));
        goto OnConnectedCMExit;
    }
    
    //
    // Set state to online
    //

    if (IsDialingTunnel(pArgs))  
    {
        //
        // This is a patch, it is only a patch - #187202
        // UI should not be tied to RASENTRY type, but it is for now so we
        // have to make sure that it is set back to RASET_Internet once we 
        // have our tunnel connection connected.
        //
        
        if (OS_NT5)
        {            
            LPRASENTRY pRasEntry = MyRGEP(pArgs->pszRasPbk, pArgs->szServiceName, &pArgs->rlsRasLink);

            CMASSERTMSG(pRasEntry, TEXT("OnConnectedCM() - MyRGEP() failed."));
                
            //
            // Set the type back and save the RASENTRY
            //

            if (pRasEntry)
            {
                ((LPRASENTRY_V500)pRasEntry)->dwType = RASET_Internet;

                if (pArgs->rlsRasLink.pfnSetEntryProperties) 
                {
                    DWORD dwTmp = pArgs->rlsRasLink.pfnSetEntryProperties(pArgs->pszRasPbk,
                                                                    pArgs->szServiceName,
                                                                    pRasEntry,
                                                                    pRasEntry->dwSize,
                                                                    NULL,
                                                                    0);
                    CMTRACE2(TEXT("OnConnectedCM() RasSetEntryProperties(*lpszEntry=%s) returns %u."),
                          MYDBGSTR(pArgs->szServiceName), dwTmp);

                    CMASSERTMSG(dwTmp == ERROR_SUCCESS, TEXT("RasSetEntryProperties for VPN failed"));
                }              
            }

            CmFree(pRasEntry);
        }
        pArgs->psState = PS_TunnelOnline;        
    }
    else 
    {   
        //
        // Set dial index back to primary number
        //
        pArgs->nDialIdx = 0;
        pArgs->psState = PS_Online;

        //
        //  Make sure to update the stored username back to just the Username as RAS has saved the exact username
        //  that we dialed with including realm info.
        //
        if (OS_NT5)
        {
            if (!pArgs->fUseTunneling || pArgs->fUseSameUserName)
            {
                if (0 != lstrcmpi(pArgs->szUserName, pArgs->pRasDialParams->szUserName))
                {
                    MYVERIFY(SaveUserInfo(pArgs, UD_ID_USERNAME, pArgs->szUserName));
                }
            }
            else
            {
                if (0 != lstrcmpi(pArgs->szInetUserName, pArgs->pRasDialParams->szUserName))
                {
                    MYVERIFY(SaveUserInfo(pArgs, UD_ID_INET_USERNAME, pArgs->szInetUserName));
                }
            }
        }
    }
        
    pArgs->dwStateStartTime = GetTickCount();
    // pszMsg = GetDurMsg(g_hInst,pArgs->dwStateStartTime);  // connect duration
    pArgs->nLastSecondsDisplay = (UINT) -1;
    
    //
    // added by byao: for PPTP connection
    //

    if (pArgs->fUseTunneling && pArgs->psState == PS_Online) 
    {
        //
        // Now do the second dial: PPTP dialup
        //

        pArgs->psState = PS_TunnelDialing;
        pArgs->dwStateStartTime = GetTickCount();
        pArgs->nLastSecondsDisplay = (UINT) -1;

        DWORD dwRes = DoTunnelDial(hwndDlg, pArgs);

        if (ERROR_SUCCESS != dwRes)
        {
            HangupCM(pArgs, hwndDlg);
            UpdateError(pArgs, dwRes);
            SetLastError(dwRes);
        }
        
        goto OnConnectedCMExit;
    }

    //
    // If this W95, then we need to Zap the RNA "Connected To" dialog
    //

    if (OS_W95) 
    {
         
        // LPTSTR pszTmp = GetEntryName(pArgs, pArgs->pszRasPbk, pArgs->piniService);
        LPTSTR pszTmp = GetRasConnectoidName(pArgs, pArgs->piniService, FALSE);
        
        //
        // Create an event for signalling Zap thread to snuff itself out
        //
      
        hEvent = CreateEventU(NULL, TRUE, FALSE, NULL); 
 
        if (hEvent)
        {
            hThread = ZapRNAConnectedTo(pszTmp, hEvent);            
        }

#ifdef DEBUG
        if (!hEvent)
        {
            CMTRACE1(TEXT("OnConnectedCM() CreateEvent failed, GLE=%u."), GetLastError());
        }
#endif
        CmFree(pszTmp);
    }

    pArgs->Log.Log(CONNECT_EVENT);
    //
    // If connection actions are enabled, update the list and run it
    //

    CMTRACE(TEXT("Connect Actions enabled: processsing Run List"));

    ConnectActList.Append(pArgs->piniService, c_pszCmSectionOnConnect);

    if (!ConnectActList.RunAccordType(hwndDlg, pArgs))
    {
        //
        // Connect action failed
        // Run disconnect action
        //
        TCHAR szTmp[MAX_PATH];            
        MYVERIFY(GetModuleFileNameU(g_hInst, szTmp, MAX_PATH));          
        pArgs->Log.Log(DISCONNECT_EVENT, szTmp);
        //
        // Do not let disconnect action description overwrite the failure message
        // Save the status pane text and restore it after disconnect actions
        // 162942: Connect Action failed message is not displayed
        //
        TCHAR szFailedMsg[256] = TEXT("");
        GetWindowTextU(GetDlgItem(hwndDlg, IDC_MAIN_STATUS_DISPLAY), 
                       szFailedMsg, sizeof(szFailedMsg)/sizeof(szFailedMsg[0]));

        CActionList DisconnectActList;
        DisconnectActList.Append(pArgs->piniService, c_pszCmSectionOnDisconnect);

        DisconnectActList.RunAccordType(hwndDlg, pArgs, FALSE);  // fStatusMsgOnFailure = FALSE

        HangupCM(pArgs, hwndDlg);

        //
        // Restore the connect action failure message
        //
        if (szFailedMsg[0] != TEXT('\0'))
        {
            SetWindowTextU(GetDlgItem(hwndDlg, IDC_MAIN_STATUS_DISPLAY),szFailedMsg);
        }

        pArgs->dwExitCode = ERROR_CANCELLED;

        SetInteractive(hwndDlg,pArgs);
        
        goto OnConnectedCMExit;
    }

    //
    // Always run AutoApps if there are any. Used to only do this in the 
    // non-autodial case, which was un-intuitive to our admin users.
    //

    AutoActList.Append(pArgs->piniService, c_pszCmSectionOnIntConnect);
    AutoActList.RunAutoApp(hwndDlg, pArgs);

    //
    // Connect to the connection monitor
    //

    if (SUCCEEDED(UpdateTable(pArgs, CM_CONNECTED)))
    {
        if (SUCCEEDED(ConnectMonitor(pArgs)))
        {
             EndMainDialog(hwndDlg, pArgs, 0); // TRUE); 
             
             //
             // SUCCESS We're fully connected, update error code
             // as it may contain an interim value such as a 
             // failed primary number dial.
             //

             pArgs->dwExitCode = ERROR_SUCCESS;
        }
        else
        {
            HangupCM(pArgs, hwndDlg);

            AppendStatusPane(hwndDlg,IDMSG_CMMON_LAUNCH_FAIL);
            SetInteractive(hwndDlg,pArgs);
            goto OnConnectedCMExit;
        }
    }
    
    //
    // Update changed password if needed
    //
    
    if (pArgs->fChangedPassword && pArgs->fRememberMainPassword)
    {
        //
        // Note: fRememberMainPassword should never be set in the 
        // WinLogon case. Complain if we have WinLogon specific data. 
        //

        MYDBGASSERT(!pArgs->lpRasNoUser); 
        MYDBGASSERT(!pArgs->lpEapLogonInfo);

        //
        // If the password has changed, then update storage
        //

        CmDecodePassword(pArgs->szPassword); // convert to plain text 1st

        SaveUserInfo(pArgs, UD_ID_PASSWORD, (PVOID)pArgs->szPassword);
        
        if (pArgs->fUseSameUserName)
        {
            SaveUserInfo(pArgs, UD_ID_INET_PASSWORD, (PVOID)pArgs->szPassword);
        }
    
        CmEncodePassword(pArgs->szPassword); // restore internal encoding

        if (pArgs->fUseSameUserName)
        {
            //
            // Just in case somebody doesn't reload it. Note: Encoded above. 
            //
        
            lstrcpyU(pArgs->szInetPassword, pArgs->szPassword);
        }

        pArgs->fChangedPassword = FALSE;
    }
                
OnConnectedCMExit:

    if (hEvent)
    {
        MYDBGASSERT(OS_W9X);
        CleanupZapThread(hEvent, hThread);
    }

    return;
}

//+----------------------------------------------------------------------------
//
// Function:  SetTcpWindowSizeOnWin2k
//
// Synopsis:  This function is basically a wrapper to load the RasSetEntryTcpWindowSize
//            API (which was QFE-ed and shipped in SP3 for Win2k) and call it.
//            It should fail gracefully if the API is not present.
//
// Arguments: HMODULE hInstRas - module handle for Rasapi32.dll
//            LPCTSTR pszConnectoid - name of the connectoid to set the window size for
//            LPCTSTR pszPhonebook - phonebook that the connectoid lives in
//            DWORD dwTcpWindowSize - size to set, note that calling with 0 
//                                    sets it to the system default
//
// Returns:   DWORD - win32 error code or ERROR_SUCCESS if successful
//
// History:   quintinb    Created       02/14/2001
//
//+----------------------------------------------------------------------------
DWORD SetTcpWindowSizeOnWin2k(HMODULE hInstRas, LPCTSTR pszConnectoid, LPCTSTR pszPhonebook, DWORD dwTcpWindowSize)
{
    //
    //  Check inputs, note that pszPhonebook could be NULL
    //
    if ((NULL == hInstRas) || (NULL == pszConnectoid) || (TEXT('\0') == pszConnectoid[0]))
    {
        CMASSERTMSG(FALSE, TEXT("SetTcpWindowSizeOnWin2k -- Invalid arguments passed."));
        return ERROR_BAD_ARGUMENTS;
    }

    //
    //  Check to make sure we are only calling this on Win2k
    //
    if ((FALSE == OS_NT5) || OS_NT51)
    {
        CMASSERTMSG(FALSE, TEXT("SetTcpWindowSizeOnWin2k -- This function should only be called on Win2k."));
        return -1;
    }

    //
    //  See if we can load the new RAS function to set the Window size
    //
    LPCSTR c_pszDwSetEntryPropertiesPrivate = "DwSetEntryPropertiesPrivate";
    typedef DWORD (WINAPI *pfnDwSetEntryPropertiesPrivateSpec)(IN LPCWSTR, IN LPCWSTR, IN DWORD, IN PVOID);
    DWORD dwReturn;

    pfnDwSetEntryPropertiesPrivateSpec pfnDwSetEntryPropertiesPrivate = (pfnDwSetEntryPropertiesPrivateSpec)GetProcAddress(hInstRas, c_pszDwSetEntryPropertiesPrivate);

    if (pfnDwSetEntryPropertiesPrivate)
    {
        RASENTRY_EX_0 PrivateRasEntryExtension;

        PrivateRasEntryExtension.dwTcpWindowSize = dwTcpWindowSize;
        
        dwReturn = (pfnDwSetEntryPropertiesPrivate)(pszConnectoid, pszPhonebook, 0, &PrivateRasEntryExtension); // 0 = struct version num
        MYDBGASSERT(ERROR_SUCCESS == dwReturn);
    }
    else
    {
        dwReturn = GetLastError();
    }

    return dwReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  DoRasDial
//
// Synopsis:  Call RasDial to dial the PPP connection
//
// Arguments: HWND hwndDlg - Main signon window
//            ArgsStruct *pArgs - 
//            DWORD dwEntry - The index in pArgs->aDialInfo
//
// Returns:   DWORD - 
//              ERROR_SUCCESS if success
//              ERROR_NOT_ENOUGH_MEMORY
//              E_UNEXPECTED, unexpected error, such as tunnel address not found
//              Otherwise, RAS error
//
// History:   fengsun Created Header    3/6/98
//
//+----------------------------------------------------------------------------
DWORD DoRasDial(HWND hwndDlg, 
              ArgsStruct *pArgs, 
              DWORD dwEntry)
{
    LPRASENTRY              preRasEntry = NULL;
    LPRASSUBENTRY           rgRasSubEntry = NULL;
    LPRASEAPUSERIDENTITY    lpRasEapUserIdentity = NULL;

    DWORD   dwSubEntryCount;

    LPTSTR  pszUsername;
    LPTSTR  pszPassword;
    LPTSTR  pszDomain = NULL;
    LPTSTR  pszRasPbk;
    LPTSTR  pszTmp;

    CIni    *piniService = NULL;
    DWORD   dwRes = ERROR_SUCCESS;  // the return value of this function
    DWORD   dwTmp;

    LPBYTE pbEapAuthData = NULL;        // Ptr to Eap Data
    DWORD  dwEapAuthDataSize = 0;           // The size of the EAP blob if any

    MYDBGASSERT(pArgs->hrcRasConn == NULL);
    MYDBGASSERT(!pArgs->IsDirectConnect());
    pArgs->hrcRasConn = NULL;

    if (!pArgs->aDialInfo[dwEntry].szDialablePhoneNumber[0]) 
    {
        CMASSERTMSG(FALSE, TEXT("DoRasDial() szDialablePhoneNumber[0] is empty."));
        return ERROR_BAD_PHONE_NUMBER;
    }

    //
    // set pArgs->fUseTunneling accordingly every time DoRasDial() is called
    // since we can switch from phonenumber0 to phonenumber1 and vice versa.
    //
    pArgs->fUseTunneling = UseTunneling(pArgs, dwEntry);

    //
    //  we need to work with the correct service file(the top-level service
    //  or a referenced service).
    //
    //
    if (!(piniService = GetAppropriateIniService(pArgs, dwEntry)))
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    
    //
    // If it's NT and we're tunneling, we create the connectoid in a hidden ras pbk, not the
    // rasphone.pbk in the system.
    //

    if (OS_NT && pArgs->fUseTunneling)
    {
        if (!pArgs->pszRasHiddenPbk)
        {
            pArgs->pszRasHiddenPbk = CreateRasPrivatePbk(pArgs);
        }
        
        pszRasPbk = pArgs->pszRasHiddenPbk; 
    }
    else
    {
        pszRasPbk = pArgs->pszRasPbk;
    }

    //
    // Setup dial params
    // 

    if (!pArgs->pRasDialParams)
    {
        pArgs->pRasDialParams = AllocateAndInitRasDialParams();

        if (!pArgs->pRasDialParams)
        {
            CMTRACE(TEXT("DoRasDial: failed to alloc a ras dial params"));
            return ERROR_NOT_ENOUGH_MEMORY;
        }        
    }
    else
    {
        InitRasDialParams(pArgs->pRasDialParams);
    }

    //
    // Get the connectoid name.
    //

    LPTSTR pszConnectoid = GetRasConnectoidName(pArgs, pArgs->piniService, FALSE);
    
    if (!pszConnectoid)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    lstrcpynU(pArgs->pRasDialParams->szEntryName, pszConnectoid, sizeof(pArgs->pRasDialParams->szEntryName)/sizeof(TCHAR));

    CmFree(pszConnectoid);

    //
    // Generate the default connectoid
    //
    
    preRasEntry = CreateRASEntryStruct(pArgs, 
                        pArgs->aDialInfo[dwEntry].szDUN, 
                        piniService, 
                        FALSE,
                        pszRasPbk,
                        &pbEapAuthData,
                        &dwEapAuthDataSize);
    if (!preRasEntry) 
    {
        dwRes = GetLastError();     
        goto exit;
    }
 
    //
    // Force update of the phone number to make sure that we pick up any manual
    // changes in country, etc.
    //
    
    CopyPhone(pArgs, preRasEntry, dwEntry); 
    
    //
    // Handle NT specifics for Idle Disconnect and IDSN
    //
    
    if (OS_NT || OS_MIL)
    {
        //
        // set NT idle disconnect
        //
        if (OS_NT)
        {
            SetNtIdleDisconnectInRasEntry(pArgs, preRasEntry);
        }
        else
        {
            MYVERIFY(DisableSystemIdleDisconnect(preRasEntry));
        }
        
        //
        // if we're using isdn and we want to dial all channels/on demand, 
        // set isdn dial mode
        //
        if (pArgs->dwIsdnDialMode != CM_ISDN_MODE_SINGLECHANNEL &&
            !lstrcmpiU(pArgs->szDeviceType, RASDT_Isdn))
        {
            MYVERIFY(SetIsdnDualChannelEntries(pArgs, 
                                               preRasEntry, 
                                               &rgRasSubEntry, 
                                               &dwSubEntryCount));
        }
        else
        {
            //
            //  Delete any additional sub entries since we only need one
            //  

            if (pArgs->rlsRasLink.pfnDeleteSubEntry) // available on NT5 & Millennium currently
            {
                DWORD dwSubEntryIndex = (OS_MIL ? 1 : 2);   // NT & Millennium dual-channel differences

                DWORD dwReturn = pArgs->rlsRasLink.pfnDeleteSubEntry(pszRasPbk,
                                                                     pArgs->pRasDialParams->szEntryName,
                                                                     dwSubEntryIndex);

                CMTRACE1(TEXT("DoRasDial -- Called RasDeleteSubEntry to delete a second sub entry if it exists, dwReturn=%d"), dwReturn);
            }
        }
    }
    else if (OS_W95)
    {
        //
        // fix another Win95 RAS bug    -- byao, 8/16/97
        // The Before and After terminal window options will be switched each
        // time you call RasSetEntryProperties          
        // This is fixed in Memphis, so it's only in Win95 Golden and OSR2
        //
        BOOL fTerminalAfterDial, fTerminalBeforeDial;

        fTerminalBeforeDial = (BOOL) (preRasEntry->dwfOptions & RASEO_TerminalBeforeDial);
        fTerminalAfterDial  = (BOOL) (preRasEntry->dwfOptions & RASEO_TerminalAfterDial);

        //
        // switch them
        //
        if (fTerminalBeforeDial)
        {
            preRasEntry->dwfOptions |= RASEO_TerminalAfterDial;
        }
        else
        {
            preRasEntry->dwfOptions &= ~RASEO_TerminalAfterDial;
        }

        if (fTerminalAfterDial)
        {
            preRasEntry->dwfOptions |= RASEO_TerminalBeforeDial;
        }
        else
        {
            preRasEntry->dwfOptions &= ~RASEO_TerminalBeforeDial;
        }
    }


    if (pArgs->rlsRasLink.pfnSetEntryProperties) 
    {

#ifdef DEBUG
        
        LPRASENTRY_V500 lpRasEntry50;
        
        if (OS_NT5)
        {
            lpRasEntry50 = (LPRASENTRY_V500) preRasEntry;
        }
#endif

        //
        // use 1 on Millennium to signify that we want to use the modem cpl settings
        // for the modem speaker such instead of the cached copy that DUN keeps.
        // Note we only do this for a dialup connection and not a tunnel since there
        // is no modem speaker to worry about.  See Millennium bug 127371.
        //
        LPBYTE lpDeviceInfo = OS_MIL ? (LPBYTE)1 : NULL; 

        DWORD dwResDbg = pArgs->rlsRasLink.pfnSetEntryProperties(pszRasPbk, 
                                                                 pArgs->pRasDialParams->szEntryName, 
                                                                 preRasEntry,
                                                                 preRasEntry->dwSize,
                                                                 lpDeviceInfo,
                                                                 0);


        CMTRACE2(TEXT("DoRasDial() RasSetEntryProperties(*pszPhoneBook=%s) returns %u."), 
            MYDBGSTR(pArgs->pRasDialParams->szEntryName), dwResDbg);

        CMASSERTMSG(dwResDbg == ERROR_SUCCESS, TEXT("RasSetEntryProperties failed"));
        
        //
        // set the subentries for isdn dual channel/dial on demand
        //
        if (pArgs->dwIsdnDialMode != CM_ISDN_MODE_SINGLECHANNEL && 
            rgRasSubEntry && 
            pArgs->rlsRasLink.pfnSetSubEntryProperties)
        {
            UINT  i;
             
            for (i=0; i< dwSubEntryCount; i++)
            {
#ifdef  DEBUG
                dwResDbg = 
#endif
                pArgs->rlsRasLink.pfnSetSubEntryProperties(pszRasPbk,
                                                           pArgs->pRasDialParams->szEntryName,
                                                           i+1,
                                                           &rgRasSubEntry[i],
                                                           rgRasSubEntry[i].dwSize,
                                                           NULL,
                                                           0);

                CMTRACE2(TEXT("DoRasDial: RasSetSubEntryProps(index=%u) returned %u"), i+1, dwResDbg);
                CMASSERTMSG(!dwResDbg, TEXT("RasSetSubEntryProperties failed"));
            }

            CmFree(rgRasSubEntry);
        }
    }

    //
    //  Set the TCP Window size -- the NTT DoCoMo fix for Win2k.  The Win2k version of this fix
    //  must be written through a private RAS API that must be called after the phonebook entry 
    //  exists ie. after we call RasSetEntryProperties ... otherwise it won't work on the first
    //  dial.
    //
    if (OS_NT5 && !OS_NT51)
    {
        //
        //  Figure out the DUN setting name to use and then build up TCP/IP&DunName.
        //
        LPTSTR pszDunSetting = GetDunSettingName(pArgs, dwEntry, FALSE);
        LPTSTR pszSection = CmStrCpyAlloc(c_pszCmSectionDunTcpIp);
        pszSection = CmStrCatAlloc(&pszSection, TEXT("&"));

        if (pszDunSetting && pszSection)
        {
            pszSection = CmStrCatAlloc(&pszSection, pszDunSetting);

            if (pszSection)
            {
                DWORD dwTcpWindowSize = piniService->GPPI(pszSection, c_pszCmEntryDunTcpIpTcpWindowSize, 0);

                (void)SetTcpWindowSizeOnWin2k(pArgs->rlsRasLink.hInstRas, pArgs->szServiceName, pszRasPbk, dwTcpWindowSize);
            }
            else
            {
                CMASSERTMSG(FALSE, TEXT("DoRasDial -- unable to allocate section name for setting TcpWindowSize"));
            }
        }
        else
        {
            CMASSERTMSG(FALSE, TEXT("DoRasDial -- unable to allocate section name or dun setting name for setting TcpWindowSize"));
        }

        CmFree (pszDunSetting);
        CmFree (pszSection);
    }

    //
    // On NT5, check for EAP configuration and update the connectoid accordingly.
    //

    if (OS_NT5) 
    {
        if (pbEapAuthData && dwEapAuthDataSize && pArgs->rlsRasLink.pfnSetCustomAuthData)
        {
            dwTmp = pArgs->rlsRasLink.pfnSetCustomAuthData(pszRasPbk, 
                                                           pArgs->pRasDialParams->szEntryName,
                                                           pbEapAuthData, 
                                                           dwEapAuthDataSize);

            CMTRACE1(TEXT("DoRasDial() - SetCustomAuthData returns %u"), dwTmp);

            if (ERROR_SUCCESS != dwTmp)
            {                
                dwRes = dwTmp;
                goto exit;
            }
        }
    }

    //
    // Prepare Phone Number
    //
    
    lstrcpynU(pArgs->pRasDialParams->szPhoneNumber,
              pArgs->aDialInfo[dwEntry].szDialablePhoneNumber,
             sizeof(pArgs->pRasDialParams->szPhoneNumber)/sizeof(TCHAR));

    //
    // Prepare user info
    //
    // #165775 - RADIUS/CHAP authentication requires that we omit the 
    // user specified domain from the dial params and pre-pend it to
    // the user name instead when doing same-name logon. - nickball
    //

    if (!pArgs->fUseTunneling || pArgs->fUseSameUserName)
    {
        pszUsername = pArgs->szUserName;
        pszPassword = pArgs->szPassword;
        pszDomain = pArgs->szDomain; 
    }
    else
    {
        //
        // if there's no username or password, we need to ask the user for it.
        //

        if (!*pArgs->szInetUserName && 
            !pArgs->fHideInetUsername &&
            !pArgs->piniService->GPPB(c_pszCmSection, c_pszCmEntryUserNameOptional) || 
            !*pArgs->szInetPassword && 
            !pArgs->fHideInetPassword &&
            !pArgs->piniService->GPPB(c_pszCmSection, c_pszCmEntryPwdOptional))
        {           
            //
            // We need to collect data from user, determine the dlg template ID
            //

            UINT uiTemplateID = IDD_INTERNET_SIGNIN;

            if (pArgs->fHideInetUsername)
            {
                uiTemplateID = IDD_INTERNET_SIGNIN_NO_UID;
            }
            else if (pArgs->fHideInetPassword)
            {
                uiTemplateID = IDD_INTERNET_SIGNIN_NO_PWD;
            }

            //
            // Now load the dialog
            //

            CInetSignInDlg SignInDlg(pArgs);

            if (IDCANCEL == SignInDlg.DoDialogBox(g_hInst, uiTemplateID, hwndDlg))
            {
                dwRes = ERROR_CANCELLED; 
                goto exit;
            }
        }
        pszUsername = pArgs->szInetUserName;
        pszPassword = pArgs->szInetPassword;
    }

    //
    // Apply suffix, prefix, to username as necessary
    //
    
    pszTmp = ApplyPrefixSuffixToBufferAlloc(pArgs, piniService, pszUsername);
    MYDBGASSERT(pszTmp);

    if (pszTmp)
    {
        //
        // Apply domain to username as necessary. Note: Reassigns pszUsername
        //

        pszUsername = ApplyDomainPrependToBufferAlloc(pArgs, piniService, pszTmp, (pArgs->aDialInfo[dwEntry].szDUN));
        MYDBGASSERT(pszUsername);
   
        if (pszUsername)
        {
            lstrcpynU(pArgs->pRasDialParams->szUserName, pszUsername, sizeof(pArgs->pRasDialParams->szUserName)/sizeof(TCHAR));
        }
        
        CmFree(pszUsername);
        CmFree(pszTmp);
    }

    pszUsername = NULL;
    pszTmp = NULL;

    //
    // Update RasDialPArams with domain info if we have any
    //
        
    if (pszDomain)
    {
        lstrcpyU(pArgs->pRasDialParams->szDomain, pszDomain);
    }
    
    //
    // Prepare the password
    //
       
    CmDecodePassword(pszPassword);

    //
    // Convert password: all upper case, all lower case, or no conversion
    //

    ApplyPasswordHandlingToBuffer(pArgs, pszPassword);

    //
    // Encode password to minimize plain text exposure time, especially crucial
    // when running things like connect actions, which can both take time and 
    // potentially crash.
    //

    CmEncodePassword(pszPassword); 

    if (pArgs->rlsRasLink.pfnDial) 
    {
         LPTSTR pszDunSetting = GetDunSettingName(pArgs, dwEntry, FALSE);
         LPTSTR pszPhoneBook = GetCMSforPhoneBook(pArgs, dwEntry);
 
         pArgs->Log.Log(PREDIAL_EVENT,
                        pArgs->pRasDialParams->szUserName,
                        pArgs->pRasDialParams->szDomain,
                        SAFE_LOG_ARG(pszPhoneBook),
                        SAFE_LOG_ARG(pszDunSetting),
                        pArgs->tlsTapiLink.szDeviceName,
                        pArgs->aDialInfo[dwEntry].szDialablePhoneNumber);

        CmFree(pszDunSetting);
        CmFree(pszPhoneBook);
        //
        // Run pre-dial connect action before calling RasDial
        //

        CActionList PreDialActList;
        PreDialActList.Append(pArgs->piniService, c_pszCmSectionPreDial);

        if (!PreDialActList.RunAccordType(hwndDlg, pArgs))
        {
            //
            // Some pre-tunnel connect action failed
            //
            dwRes = ERROR_INVALID_DLL; // Only used for failed CA
        }
        else
        {
            // 
            // Set state and tick counters.
            //
            
            pArgs->psState = PS_Dialing;
            pArgs->dwStateStartTime = GetTickCount();
            pArgs->nLastSecondsDisplay = (UINT) -1;

            //
            // Record the initial Dial-Up Adapter Statistic info
            // open the registry key for the perfmon data
            //

            if (pArgs->pConnStatistics)
            {
                pArgs->pConnStatistics->InitStatistics();
            }
                        
            if (OS_NT)
            {
                BOOL    fUsePausedStates = TRUE;
                BOOL    fUseCustomScripting = !!(preRasEntry->dwfOptions & RASEO_CustomScript); // OS_NT51 (whistler+) only

                if (OS_NT4)
                {                   
                    //
                    // If a script is specified, then explcitly don't handle 
                    // pause states. This is because we can't handle the script
                    // pause state. On W2K, RAS is smart enough not to send us
                    // the scripting pause state because we have the terminal
                    // option turned off.
                    //
                                   
                    if (preRasEntry->szScript[0] != TEXT('\0'))
                    {
                        fUsePausedStates = FALSE;
                    }
                }

                dwRes = SetRasDialExtensions(pArgs, fUsePausedStates, fUseCustomScripting);
                
                if (dwRes != ERROR_SUCCESS) 
                {
                    goto exit;
                }

                //
                // On NT5, we may be getting credentials via EAP
                //

                if (OS_NT5 && ((LPRASENTRY_V500)preRasEntry)->dwCustomAuthKey)
                {
                    //
                    // We're using EAP, get credentials from EAP through RAS
                    //

                    dwRes = GetEapUserId(pArgs, 
                                         hwndDlg, 
                                         pszRasPbk, 
                                         pbEapAuthData, 
                                         dwEapAuthDataSize, 
                                         ((LPRASENTRY_V500)preRasEntry)->dwCustomAuthKey,
                                         &lpRasEapUserIdentity);

                    if (ERROR_SUCCESS != dwRes)
                    {
                        goto exit;
                    }
                }
            }

            CMTRACE1(TEXT("DoRasDial: pArgs->pRasDialParams->szUserName is %s"), pArgs->pRasDialParams->szUserName);
            CMTRACE1(TEXT("DoRasDial: pArgs->pRasDialParams->szDomain is %s"), pArgs->pRasDialParams->szDomain);
            CMTRACE1(TEXT("DoRasDial: pArgs->pRasDialParams->szPhoneNumber is %s"), pArgs->pRasDialParams->szPhoneNumber);
            
            //
            // Decode the password, and fill dial params, then re-encode both the pArgs
            // version of the password and the dial params copy.
            //

            CmDecodePassword(pszPassword);          
            
            lstrcpynU(pArgs->pRasDialParams->szPassword, pszPassword, sizeof(pArgs->pRasDialParams->szPassword)/sizeof(TCHAR));

            //
            //  Write the RasDialParams if necessary.
            //  We must keep this, even though RasSetEntryDialParams() is expensive.  Inverse uses the
            //  information stored in the DialParams structure.  However, since this can cause problems
            //  with EAP (overwriting the saved PIN for instance) we will make the storing of the 
            //  credential information configurable by a CMS flag.  Specifically, the WriteRasDialParams
            //  flag in the [Connection Manager] section. If the flag is 1, then we will write the 
            //  RasDialParams and otherwise we won't.  Note that the flag defaults to 0.
            //  Please see bug 399976 for reference.
            //
            if (piniService->GPPI(c_pszCmSection, c_pszCmEntryWriteDialParams))
            {
                //
                //  Note that since we throw the connectoid away if we are on NT and
                //  doing a double dial, there is no point in making an expensive set
                //  dial params call on it.
                //
                if ((!pArgs->fUseTunneling && pArgs->fRememberMainPassword) ||
                    (pArgs->fUseTunneling && pArgs->fRememberInetPassword && OS_W9X))
                {
                    DWORD dwResDbg = pArgs->rlsRasLink.pfnSetEntryDialParams(pszRasPbk, pArgs->pRasDialParams, FALSE);
                    CMTRACE1(TEXT("DoRasDial() SetEntryDialParams returns %u."), dwResDbg);
        
                }
                else
                {
                    //
                    // Forget the password, note that the DialParams contain the password but we set the 
                    // fRemovePassword flag to TRUE so the password will be removed anyway.
                    //
                    DWORD dwResDbg = pArgs->rlsRasLink.pfnSetEntryDialParams(pszRasPbk, 
                                                                             pArgs->pRasDialParams, TRUE);
                    CMTRACE1(TEXT("DoRasDial() SetEntryDialParams returns %u."), dwResDbg);
                }
            }
            
            //
            // Do the dial (PPP)
            //

            if (OS_NT)
            {
                lstrcpyU(pArgs->pRasDialParams->szCallbackNumber, TEXT("*"));
            }

            //
            //  check to ensure we're not already in a Cancel operation
            //
            LONG lInConnectOrCancel = InterlockedExchange(&(pArgs->lInConnectOrCancel), IN_CONNECT_OR_CANCEL);
            CMASSERTMSG(((NOT_IN_CONNECT_OR_CANCEL == lInConnectOrCancel) || (IN_CONNECT_OR_CANCEL == lInConnectOrCancel)),
                        TEXT("DoRasDial - synch variable has unexpected value!"));

            if (NOT_IN_CONNECT_OR_CANCEL == lInConnectOrCancel)
            {
                dwRes = pArgs->rlsRasLink.pfnDial(pArgs->pRasDialExtensions, 
                                                  pszRasPbk, 
                                                  pArgs->pRasDialParams, 
                                                  GetRasCallBackType(),               
                                                  GetRasCallBack(pArgs),               
                                                  &pArgs->hrcRasConn);
            }
            else
            {
                // this is a rare stress case - deliberately did not set dwRes to error value.
                CMTRACE(TEXT("DoRasDial() did not dial, we are already in a Cancel operation"));
            }

            (void) InterlockedExchange(&(pArgs->lInConnectOrCancel), NOT_IN_CONNECT_OR_CANCEL);

            CmEncodePassword(pArgs->pRasDialParams->szPassword); 
            CmEncodePassword(pszPassword);

            CMTRACE1(TEXT("DoRasDial() RasDial() returns %u."), dwRes);
            if (dwRes != ERROR_SUCCESS) 
            {
                pArgs->hrcRasConn = NULL;
                goto exit;
            }
        }
    }

exit:

    if (lpRasEapUserIdentity)
    {
        MYDBGASSERT(OS_NT5); // NO EAP down-level

        //
        // A RasEapUserIdentity struct was allocated, free it via the 
        // appropriate free mechanism. In the WinLogon case we will always
        // perform the allocation, otherwise we have to go through RAS API.
        //

        if (pArgs->lpEapLogonInfo)
        {
            CmFree(lpRasEapUserIdentity);
        }
        else
        {
            if (pArgs->rlsRasLink.pfnFreeEapUserIdentity) 
            {
                pArgs->rlsRasLink.pfnFreeEapUserIdentity(lpRasEapUserIdentity);  
            }       
        }
    }

    CmFree(pbEapAuthData);
    CmFree(preRasEntry);

    delete piniService;

    return dwRes;
}

//+---------------------------------------------------------------------------
//
//  Function:   DoTunnelDial
//
//  Synopsis:   call RasDial to dial up to the tunnel server
//
//  Arguments:  hwndDlg  [dlg window handle]
//              pargs    pointer to ArgValue structure
//
// Returns:   DWORD - 
//              ERROR_SUCCESS if success
//              ERROR_NOT_ENOUGH_MEMORY
//              E_UNEXPECTED, unexpected error, such as phone entry not found
//              Otherwise, RAS error
//
//  History:    byao        Created     3/1/97
//              fengsun     change return type to DWORD 3/6/98
//
//----------------------------------------------------------------------------
DWORD DoTunnelDial(IN HWND hwndDlg, IN ArgsStruct *pArgs)
{
    LPRASENTRY              preRasEntry = NULL;
    LPRASEAPUSERIDENTITY    lpRasEapUserIdentity = NULL;
    LPTSTR pszVpnSetting        = NULL;

    LPBYTE  pbEapAuthData       = NULL;                 // Ptr to Eap Data 
    DWORD   dwEapAuthDataSize   = 0;                    // The size of the EAP blob if any
    LPTSTR  pszPassword         = pArgs->szPassword;
    DWORD   dwRes               = (DWORD)E_UNEXPECTED;
    DWORD   dwTmp;

    MYDBGASSERT(pArgs->hrcTunnelConn == NULL);
    pArgs->hrcTunnelConn = NULL;
    
    //
    // What's the tunnel end point? Do this now so that the UI can be updated
    // properly if lana wait or pre-tunnel actions are time consuming.  
    //

    LPTSTR pszTunnelIP = pArgs->piniBothNonFav->GPPS(c_pszCmSection, c_pszCmEntryTunnelAddress);
    if (pszTunnelIP)
    {
        if (lstrlenU(pszTunnelIP) > RAS_MaxPhoneNumber) 
        {
            pszTunnelIP[0] = TEXT('\0');
        }

        pArgs->SetPrimaryTunnel(pszTunnelIP);
        CmFree(pszTunnelIP);
    }

    //
    // See if tunnel server was specified
    //

    if (!(pArgs->GetTunnelAddress()[0])) 
    { 
        CMASSERTMSG(FALSE, TEXT("DoTunnelDial() TunnelAddress is invalid."));
        return ERROR_BAD_ADDRESS_SPECIFIED;
    }

    CMTRACE1(TEXT("DoTunnelDial() - TunnelAddress is %s"), pArgs->GetTunnelAddress());
    
    //
    //  Caution should be used when changing this if statement.  We want this to happen both for direct connect
    //  and for double dial connections.  You can still get into the LANA situation with two CM
    //  connections dialed independently (one to the internet and the other a tunnel), doing the lana
    //  wait for direct connections prevents the lana registration problem from occuring in this situation.
    //  Note that the Lana wait isn't necessary on Win98 SE or Win98 Millennium because the DUN bug
    //  is fixed.  Thus we have reversed the default and will only do the LANA wait if the reg key exists
    //  and specifies that the wait should be performed.
    //
    if (OS_W9X) 
    {
        //
        // Sets us up to wait for Vredir to register LANA for connection to internet
        // Note: Returns FALSE if the user hits cancel while we are waiting. In this 
        // event, we should not continue the tunnel dial.
        //

        if (FALSE == LanaWait(pArgs, hwndDlg))
        {
            return ERROR_SUCCESS;
        }
    }

    LPTSTR pszDunSetting = GetDunSettingName(pArgs, -1, TRUE);

    pArgs->Log.Log(PRETUNNEL_EVENT,
                     pArgs->szUserName,
                     pArgs->szDomain,
                     SAFE_LOG_ARG(pszDunSetting),
                     pArgs->tlsTapiLink.szDeviceName,
                     pArgs->GetTunnelAddress());

    CmFree(pszDunSetting);

    CActionList PreTunnelActList;
    if (PreTunnelActList.Append(pArgs->piniService, c_pszCmSectionPreTunnel))
    {
        CMTRACE(TEXT("DoTunnelDial() - Running Pre-Tunnel actions"));
        
        if (!PreTunnelActList.RunAccordType(hwndDlg, pArgs))
        {
            //
            // Some pre-tunnel connect action failed
            //
            dwRes = ERROR_INVALID_DLL; // Only used for failed CA
            goto exit;
        }

        //
        // Now that pre-tunnel actions have run, what's the tunnel end point?
        // We perform this read again here in the event that the pre-tunnel 
        // action modified the tunnel address. Note: This is an exception to 
        // the rule that the .CMS should not be modified on the client side, 
        // especially by 3rd parties.
        //
// REVIEW:  It probably isn't necessary to re-read this with the new VPN tab.  However, some people might still
//          be using the connect action solution that ITG gave out and we want to be careful not to break them if
//          we haven't already.  Thus we will continue to re-read this for Whistler but we should remove it afterwards.
//          quintinb 11-01-00
        pszTunnelIP = pArgs->piniBothNonFav->GPPS(c_pszCmSection, c_pszCmEntryTunnelAddress);
      
        if (pszTunnelIP)
        {
            if (lstrlenU(pszTunnelIP) > RAS_MaxPhoneNumber) 
            {
              pszTunnelIP[0] = TEXT('\0');
            }

            pArgs->SetPrimaryTunnel(pszTunnelIP);
            CmFree(pszTunnelIP);
        }
  
        //
        // See if tunnel server was specified
        //

        if (!(pArgs->GetTunnelAddress()[0])) 
        { 
            CMASSERTMSG(FALSE, TEXT("DoTunnelDial() TunnelAddress is invalid."));
            dwRes = (DWORD)ERROR_BAD_ADDRESS_SPECIFIED;
            goto exit;
        }

        CMTRACE1(TEXT("DoTunnelDial() - TunnelAddress is %s"), pArgs->GetTunnelAddress());
    }

    //
    // Setup dial params
    //

    if (!pArgs->pRasDialParams)
    {
        pArgs->pRasDialParams = AllocateAndInitRasDialParams();

        if (!pArgs->pRasDialParams)
        {
            CMTRACE(TEXT("DoTunnelDial: failed to alloc a ras dial params"));
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }
    }
    else
    {
        InitRasDialParams(pArgs->pRasDialParams);
    }

    //
    // Get the connectoid name
    //

    LPTSTR pszConnectoid;
    pszConnectoid = GetRasConnectoidName(pArgs, pArgs->piniService, TRUE);
    
    if (!pszConnectoid)
    {
        dwRes = (DWORD)ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    lstrcpyU(pArgs->pRasDialParams->szEntryName, pszConnectoid);
    
    CmFree(pszConnectoid);

    //
    // We'll create the RAS connectoid if the RAS connectoid doesn't exist.
    // NOTE: Tunnel settings should always be taken from the top-level CMS.
    // so use it when creating the connectoid.
    //
    
    pszVpnSetting = pArgs->piniBothNonFav->GPPS(c_pszCmSection, c_pszCmEntryTunnelDun, TEXT(""));

    preRasEntry = CreateRASEntryStruct(pArgs,
                        (pszVpnSetting ? pszVpnSetting : TEXT("")),
                        pArgs->piniService,
                        TRUE,
                        pArgs->pszRasPbk,
                        &pbEapAuthData,
                        &dwEapAuthDataSize);

    CmFree(pszVpnSetting);

    if (!preRasEntry) 
    {
        dwRes = GetLastError();
        goto exit;
    }

    //
    //  If this is Millennium we need to disable Idle disconnect so that it doesn't
    //  fight with ours.
    //
    if (OS_MIL)
    {
        MYVERIFY(DisableSystemIdleDisconnect(preRasEntry));
    }

    //
    //  We need to delete a second sub entry if it exists.  See 406637 for details
    //
    if (pArgs->rlsRasLink.pfnDeleteSubEntry) // available on NT5 & Millennium currently
    {
        DWORD dwReturn = pArgs->rlsRasLink.pfnDeleteSubEntry(pArgs->pszRasPbk, 
                                                             pArgs->pRasDialParams->szEntryName, 
                                                             (OS_MIL ? 1 : 2)); // see comment in DoRasDial

        CMTRACE1(TEXT("DoTunnelDial -- Called RasDeleteSubEntry to delete a second sub entry if it exists, dwReturn=%d"), dwReturn);
    }

    //
    // On NT5, we have to set the connection type to VPN instead of Internet
    //

    if (OS_NT5)
    {
        MYDBGASSERT(preRasEntry->dwSize >= sizeof(RASENTRY_V500));
        ((LPRASENTRY_V500)preRasEntry)->dwType = RASET_Vpn;
        ((LPRASENTRY_V500)preRasEntry)->szDeviceName[0] = TEXT('\0');  // let RAS pickup the tunnel device
    }

    if (pArgs->rlsRasLink.pfnSetEntryProperties) 
    {

#ifdef DEBUG
        
        LPRASENTRY_V500 lpRasEntry50;
        
        if (OS_NT5)
        {
            lpRasEntry50 = (LPRASENTRY_V500) preRasEntry;
        }
#endif
        
        dwRes = pArgs->rlsRasLink.pfnSetEntryProperties(pArgs->pszRasPbk,
                                                        pArgs->pRasDialParams->szEntryName,
                                                        preRasEntry,
                                                        preRasEntry->dwSize,
                                                        NULL,
                                                        0);
        CMTRACE2(TEXT("DoTunnelDial() RasSetEntryProperties(*lpszEntry=%s) returns %u."),
              MYDBGSTR(pArgs->pRasDialParams->szEntryName,), dwRes);

        CMASSERTMSG(dwRes == ERROR_SUCCESS, TEXT("RasSetEntryProperties for VPN failed"));
    }

    //
    //  Set the TCP Window size -- the NTT DoCoMo fix for Win2k.  The Win2k version of this fix
    //  must be written through a private RAS API that must be called after the phonebook entry 
    //  exists ie. after we call RasSetEntryProperties ... otherwise it won't work on the first
    //  dial.
    //
    if (OS_NT5 && !OS_NT51)
    {
        //
        //  Figure out the DUN setting name to use and then build up TCP/IP&DunName.
        //
        LPTSTR pszDunSetting = GetDunSettingName(pArgs, -1, TRUE);
        LPTSTR pszSection = CmStrCpyAlloc(c_pszCmSectionDunTcpIp);
        pszSection = CmStrCatAlloc(&pszSection, TEXT("&"));

        if (pszDunSetting && pszSection)
        {
            pszSection = CmStrCatAlloc(&pszSection, pszDunSetting);

            if (pszSection)
            {
                DWORD dwTcpWindowSize = pArgs->piniService->GPPI(pszSection, c_pszCmEntryDunTcpIpTcpWindowSize, 0);

                (void)SetTcpWindowSizeOnWin2k(pArgs->rlsRasLink.hInstRas, pArgs->szServiceName, pArgs->pszRasPbk, dwTcpWindowSize);
            }
            else
            {
                CMASSERTMSG(FALSE, TEXT("DoTunnelDial -- unable to allocate section name for setting TcpWindowSize"));
            }
        }
        else
        {
            CMASSERTMSG(FALSE, TEXT("DoTunnelDial -- unable to allocate section name or dun setting name for setting TcpWindowSize"));
        }

        CmFree (pszDunSetting);
        CmFree (pszSection);
    }
    
    //
    // On NT5, check for EAP configuration and update the connectoid accordingly.
    //

    if (OS_NT5) 
    {
        if (pbEapAuthData && dwEapAuthDataSize && pArgs->rlsRasLink.pfnSetCustomAuthData)
        {
            dwTmp = pArgs->rlsRasLink.pfnSetCustomAuthData(pArgs->pszRasPbk, 
                                                           pArgs->pRasDialParams->szEntryName,
                                                           pbEapAuthData, 
                                                           dwEapAuthDataSize);
            if (ERROR_SUCCESS != dwTmp)
            {
                CMTRACE(TEXT("DoTunnelDial() - SetCustomAuthData failed"));
                dwRes = dwTmp;
                goto exit;
            }
        }
    }

    //
    // Phone Number for PPTP is the DNS name of IP addr of PPTP server
    //
    
    lstrcpynU(pArgs->pRasDialParams->szPhoneNumber,pArgs->GetTunnelAddress(), sizeof(pArgs->pRasDialParams->szPhoneNumber));

    //
    // Prepare User Name and Domain  
    //

    lstrcpyU(pArgs->pRasDialParams->szUserName, pArgs->szUserName);
    lstrcpyU(pArgs->pRasDialParams->szDomain, pArgs->szDomain);
       
    //
    // Prepare the password
    //

    CmDecodePassword(pszPassword); 

    //
    // Convert password: all upper case, all lower case, or no conversion
    //
    
    ApplyPasswordHandlingToBuffer(pArgs, pszPassword);

    //
    // Re-encode password while we take care of other business.
    //

    CmEncodePassword(pszPassword);

    if (pArgs->rlsRasLink.pfnDial) 
    {
        if (pArgs->IsDirectConnect())
        {
            //
            // Record the initial Dial-Up Adapter Statistic info.
            //

            if (pArgs->pConnStatistics)
            {
                pArgs->pConnStatistics->InitStatistics();
            }
        }            

        if (OS_NT)
        {
            MYDBGASSERT(TEXT('\0') == preRasEntry->szScript[0]); // we should never have a script on a tunnel connection

            dwRes = SetRasDialExtensions(pArgs, TRUE, FALSE); // TRUE == fUsePausedStates, FALSE == fEnableCustomScripting
            
            if (dwRes != ERROR_SUCCESS) 
            {
                goto exit;
            }

            //
            // On NT5, we may be getting credentials via EAP
            //

            if (OS_NT5 && ((LPRASENTRY_V500)preRasEntry)->dwCustomAuthKey)
            {
                //
                // We're using EAP, get credentials from EAP through RAS
                //

                dwRes = GetEapUserId(pArgs, 
                                     hwndDlg, 
                                     pArgs->pszRasPbk, 
                                     pbEapAuthData, 
                                     dwEapAuthDataSize, 
                                     ((LPRASENTRY_V500)preRasEntry)->dwCustomAuthKey,
                                     &lpRasEapUserIdentity);

                if (ERROR_SUCCESS != dwRes)
                {
                    goto exit;
                }
            }
        }

        CMTRACE1(TEXT("DoTunnelDial: pArgs->pRasDialParams->szUserName is %s"), pArgs->pRasDialParams->szUserName);
        CMTRACE1(TEXT("DoTunnelDial: pArgs->pRasDialParams->szDomain is %s"), pArgs->pRasDialParams->szDomain);
        CMTRACE1(TEXT("DoTunnelDial: pArgs->pRasDialParams->szPhoneNumber is %s"), pArgs->pRasDialParams->szPhoneNumber);
        
        //
        // Decode the password before dialing, then re-encode along
        // with the dial params, which we persist in memory for use
        // in pause states, etc.
        //

        CmDecodePassword(pszPassword); 

        lstrcpyU(pArgs->pRasDialParams->szPassword, pArgs->szPassword);

        //
        // Do the dial (PPTP or L2TP)
        //

        dwRes = pArgs->rlsRasLink.pfnDial(pArgs->pRasDialExtensions, 
                                          pArgs->pszRasPbk, 
                                          pArgs->pRasDialParams, 
                                          GetRasCallBackType(),               
                                          GetRasCallBack(pArgs),               
                                          &pArgs->hrcTunnelConn);

        CmEncodePassword(pszPassword); 
        CmEncodePassword(pArgs->pRasDialParams->szPassword);

        CMTRACE1(TEXT("DoTunnelDial() RasDial() returns %u."), dwRes);

        //
        // NT5 - Reset the connection type so that it will display properly in 
        // the Connections Folder. This is a temporary solution to #187202
        //

        if (OS_NT5)
        {
            MYDBGASSERT(preRasEntry->dwSize >= sizeof(RASENTRY_V500));
            ((LPRASENTRY_V500)preRasEntry)->dwType = RASET_Internet;

            if (pArgs->rlsRasLink.pfnSetEntryProperties) 
            {
                dwTmp = pArgs->rlsRasLink.pfnSetEntryProperties(pArgs->pszRasPbk,
                                                                pArgs->pRasDialParams->szEntryName,
                                                                preRasEntry,
                                                                preRasEntry->dwSize,
                                                                NULL,
                                                                0);

                CMTRACE2(TEXT("DoTunnelDial() RasSetEntryProperties(*lpszEntry=%s) returns %u."),
                         MYDBGSTR(pArgs->pRasDialParams->szEntryName,), dwTmp);

                CMASSERTMSG(dwTmp == ERROR_SUCCESS, TEXT("RasSetEntryProperties for VPN failed"));
            }
        }

        if (dwRes != ERROR_SUCCESS) 
        {
            pArgs->hrcTunnelConn = NULL;            
            goto exit;
        }
    }

exit:

    if (lpRasEapUserIdentity)
    {
        MYDBGASSERT(OS_NT5); // NO EAP down-level

        //
        // A RasEapUserIdentity struct was allocated, free it via the 
        // appropriate free mechanism. In the WinLogon case we will always
        // perform the allocation, otherwise we have to go through RAS API.
        //

        if (pArgs->lpEapLogonInfo)
        {
            CmFree(lpRasEapUserIdentity);
        }
        else
        {
            if (pArgs->rlsRasLink.pfnFreeEapUserIdentity) 
            {
                pArgs->rlsRasLink.pfnFreeEapUserIdentity(lpRasEapUserIdentity);  
            }       
        }
    }

    CmFree(preRasEntry); // Now we can release the RAS entry structure. #187202 
    CmFree(pbEapAuthData);

    return dwRes;
}

//+---------------------------------------------------------------------------
//
//  Function:   CheckConnect
//
//  Synopsis:   double check to make sure all required fields are filled in, such
//              as username, password, modem, etc.
//
//  Arguments:  hwndDlg         [dlg window handle]
//              pArgs           pointer to ArgValue structure
//              pnCtrlFocus:    The button whose value is missing will have the focus
//
//  Returns:    True is ready to connect
//
//  History:    byao            Modified        3/7/97
//              nickball        return BOOLEAN  9/9/98
//
//----------------------------------------------------------------------------
BOOL CheckConnect(HWND hwndDlg, 
                  ArgsStruct *pArgs, 
                  UINT *pnCtrlFocus,
                  BOOL fShowMsg) 
{
    LPTSTR pszTmp;
    BOOL bEnable = TRUE;
    int nId = 0;
    UINT nCtrlFocus;
    BOOL bSavedNoNotify = pArgs->fIgnoreChangeNotification;

    pArgs->fIgnoreChangeNotification = TRUE;
    
    MYDBGASSERT(*pArgs->piniProfile->GetFile());


     
    //
    // If tunneling, see if we have a tunneling device specified 
    //

    if (bEnable && IsTunnelEnabled(pArgs)) 
    {
        lstrcpyU(pArgs->szTunnelDeviceType, RASDT_Vpn);
        
        //
        // Get Tunnel device name from profile
        //
        
        LPTSTR pszTunnelDevice = pArgs->piniProfile->GPPS(c_pszCmSection, c_pszCmEntryTunnelDevice);
        if (pszTunnelDevice)
        {
            lstrcpyU(pArgs->szTunnelDeviceName, pszTunnelDevice);
            CmFree(pszTunnelDevice);
        }

        //
        // If we don't have a tunnel device, pick one
        //

        if (pArgs->szTunnelDeviceName[0] == TEXT('\0'))
        {
            //
            // If we can't pick a tunnel device make sure tunneling is installed
            //
            
            if (!PickTunnelDevice(pArgs,pArgs->szTunnelDeviceType,pArgs->szTunnelDeviceName)) 
            {
                //
                // Disable the connect/setting button during component checking and installation
                //

                EnableWindow(GetDlgItem(hwndDlg,IDOK),FALSE);                   
                EnableWindow(GetDlgItem(hwndDlg,IDC_MAIN_PROPERTIES_BUTTON),FALSE);                   

                //
                // Install the PPTP and pick tunnel device one more time
                //
                DWORD dwComponentsToCheck = CC_PPTP | CC_RNA | CC_RASRUNNING 
                                                | CC_TCPIP| CC_CHECK_BINDINGS;

                if (TRUE == pArgs->bDoNotCheckBindings)
                {
                    dwComponentsToCheck &= ~CC_CHECK_BINDINGS;
                }
                
                //
                // PPTP is not installed.  
                // If not unattended, try to install the PPTP and call PickTunnel again
                //

                pArgs->dwExitCode = ERROR_PORT_NOT_AVAILABLE;

                if (!(pArgs->dwFlags & FL_UNATTENDED))
                {
                    pArgs->dwExitCode = CheckAndInstallComponents(dwComponentsToCheck, 
                                                                  hwndDlg, pArgs->szServiceName);
                }

                if (pArgs->dwExitCode != ERROR_SUCCESS ||
                    !PickTunnelDevice(pArgs,pArgs->szTunnelDeviceType,pArgs->szTunnelDeviceName))
                {
                    bEnable = FALSE;                
                    nId = GetPPTPMsgId();                    
                    nCtrlFocus = IDCANCEL;
                }

                EnableWindow(GetDlgItem(hwndDlg,IDC_MAIN_PROPERTIES_BUTTON),TRUE);
            }

            pArgs->piniProfile->WPPS(c_pszCmSection, c_pszCmEntryTunnelDevice, pArgs->szTunnelDeviceName);
        }
    }

    

    //
    // Next, check the username.
    //
    
    if (GetDlgItem(hwndDlg, IDC_MAIN_USERNAME_EDIT))
    {
        if (bEnable && 
            !pArgs->piniService->GPPB(c_pszCmSection, c_pszCmEntryUserNameOptional)) 
        {
            if (!SendDlgItemMessageU(hwndDlg, IDC_MAIN_USERNAME_EDIT, WM_GETTEXTLENGTH, 0, (LPARAM)0))
            {
                bEnable = FALSE;
                nId = IDMSG_NEED_USERNAME;
                nCtrlFocus = IDC_MAIN_USERNAME_EDIT;
            }
        }
    }

    //
    // Next, check the password.
    //

    if (GetDlgItem(hwndDlg, IDC_MAIN_PASSWORD_EDIT))
    {
        if (!pArgs->piniService->GPPB(c_pszCmSection, c_pszCmEntryPwdOptional)) 
        {
            if (!SendDlgItemMessageU(hwndDlg, IDC_MAIN_PASSWORD_EDIT, WM_GETTEXTLENGTH, 0, (LPARAM)0))
            {
                if (bEnable)
                {
                    bEnable = FALSE;
                    nId = IDMSG_NEED_PASSWORD;
                    nCtrlFocus = IDC_MAIN_PASSWORD_EDIT;
                }

                //
                // Disable "Remember password" check box
                //
                if (!pArgs->fHideRememberPassword)
                {
                    pArgs->fRememberMainPassword = FALSE;
                    CheckDlgButton(hwndDlg, IDC_MAIN_NOPASSWORD_CHECKBOX, FALSE);
                    EnableWindow(GetDlgItem(hwndDlg, IDC_MAIN_NOPASSWORD_CHECKBOX), FALSE);

                    if (pArgs->fGlobalCredentialsSupported)
                    {
                        //
                        // Also disable the option buttons
                        //
                        EnableWindow(GetDlgItem(hwndDlg, IDC_OPT_CREDS_SINGLE_USER), FALSE);
                        EnableWindow(GetDlgItem(hwndDlg, IDC_OPT_CREDS_ALL_USER), FALSE);
                    }

                }
            
                //
                // disable the "dial automatically..." checkbox
                //
                if (!pArgs->fHideDialAutomatically)
                {
                    pArgs->fDialAutomatically = FALSE;
                    pArgs->fRememberMainPassword = FALSE;
                    CheckDlgButton(hwndDlg, IDC_MAIN_NOPROMPT_CHECKBOX, FALSE);
                    EnableWindow(GetDlgItem(hwndDlg, IDC_MAIN_NOPROMPT_CHECKBOX), FALSE);
                }
            }
            else
            {
                //
                // Enable the "Remember password" checkbox
                //
                if (!pArgs->fHideRememberPassword)
                {
                    EnableWindow(GetDlgItem(hwndDlg, IDC_MAIN_NOPASSWORD_CHECKBOX), TRUE);
                }

                //
                // Enable the "dial automatically..." checkbox
                // if HideDialAutomatically is not set
                // and if Password is not optional, Remember Password must be true
                //
                if ((!pArgs->fHideDialAutomatically) && 
                    (pArgs->fRememberMainPassword ||
                     pArgs->piniService->GPPB(c_pszCmSection, 
                                                c_pszCmEntryPwdOptional)))
                {
                    EnableWindow(GetDlgItem(hwndDlg, IDC_MAIN_NOPROMPT_CHECKBOX), TRUE);
                }
            }
        }
    }

    //
    // Next, check the domain.
    //
    
    if (GetDlgItem(hwndDlg, IDC_MAIN_DOMAIN_EDIT))
    {
        if (bEnable && 
            !pArgs->piniService->GPPB(c_pszCmSection, c_pszCmEntryDomainOptional, TRUE)) 
        {
            if (!SendDlgItemMessageU(hwndDlg, IDC_MAIN_DOMAIN_EDIT, WM_GETTEXTLENGTH, 0, (LPARAM)0))
            {
                bEnable = FALSE;
                nId = IDMSG_NEED_DOMAIN;
                nCtrlFocus = IDC_MAIN_DOMAIN_EDIT;
            }
        }
    }

    //
    // Check whether primary phone number is empty -- a quick fix for bug 3123  -byao (4/11/97)
    //

    if (!pArgs->IsDirectConnect())
    {
        //
        // Its not a direct connection, so we must check the phonenumber. If both 
        // szPhoneNumber and szCanonical are blank then we don't have a number.
        //
        
        if (bEnable && 
            IsBlankString(pArgs->aDialInfo[0].szPhoneNumber) &&
            IsBlankString(pArgs->aDialInfo[0].szCanonical))
        {
            bEnable = FALSE;
            
            if (pArgs->fNeedConfigureTapi)
            {
                nId = IDMSG_NEED_CONFIGURE_TAPI;
            }
            else
            {
                //
                // If direct and dial-up,the message should include the 
                // possibility of direct connection, otherwise use
                // the standard need a phone number message
                //
                
                if (pArgs->IsBothConnTypeSupported())
                {
                    nId = IDMSG_NEED_PHONE_DIRECT;
                }
                else
                {
                    nId = IDMSG_NEED_PHONE_DIAL;
                }
            }
            
            nCtrlFocus = IDC_MAIN_PROPERTIES_BUTTON;
        }
    }
    
    //
    //  If tunneling is enabled and we are using a VPN file, make sure
    //  the user has selected a tunnel endpoint.
    //
    if (bEnable && IsTunnelEnabled(pArgs) && pArgs->pszVpnFile) 
    {
        LPTSTR pszTunnelAddress = pArgs->piniBothNonFav->GPPS(c_pszCmSection, c_pszCmEntryTunnelAddress);

        if ((NULL == pszTunnelAddress) || (TEXT('\0') == pszTunnelAddress[0]))
        {
            bEnable = FALSE;
            nId = IDMSG_PICK_VPN_ADDRESS;
            nCtrlFocus = IDC_MAIN_PROPERTIES_BUTTON;
        }

        CmFree(pszTunnelAddress);
    }

    if (bEnable) 
    {
        //
        // well, now we can set the focus to the 'connect' button
        // Display ready to dial message
        //
        nCtrlFocus = IDOK;
        nId = IDMSG_READY;
    }

    if (pnCtrlFocus) 
    {
        *pnCtrlFocus = nCtrlFocus;
    }

    pszTmp = CmFmtMsg(g_hInst,nId);

    if (NULL == pszTmp)
    {
        return FALSE;
    }
    
    SetDlgItemTextU(hwndDlg, IDC_MAIN_STATUS_DISPLAY, pszTmp); 

    //
    // If necessary, throw a message box at the user.
    //

    if (!bEnable && fShowMsg)
    {
        MessageBoxEx(hwndDlg, 
                     pszTmp, 
                     pArgs->szServiceName, 
                     MB_OK|MB_ICONINFORMATION,
                     LANG_USER_DEFAULT);

    }

    CmFree(pszTmp);
    pArgs->fIgnoreChangeNotification = bSavedNoNotify;

    //
    // Something went wrong in the config.  we need to recheck the
    // configs next time we run CM.
    //

    if (GetPPTPMsgId() == nId) // not an assignment, stay left                   
    {
        ClearComponentsChecked();
    }

    return bEnable;
}

void MainSetDefaultButton(HWND hwndDlg, 
                          UINT nCtrlId) 
{
    switch (nCtrlId) 
    {
        case IDCANCEL:
        case IDC_MAIN_PROPERTIES_BUTTON:
            break;

        default:
            nCtrlId = IDOK;
            break;
    }

    SendMessageU(hwndDlg, DM_SETDEFID, (WPARAM)nCtrlId, 0);
}



//+---------------------------------------------------------------------------
//
//  Function:   SetMainDlgUserInfo
//
//  Synopsis:   Set user info in the main dlg.  
//
//  Arguments:  pArgs           - the ArgStruct *
//              hwndDlg         - the main dlg
//
//  Returns:    NONE
//
//  History:    henryt  Created     5/5/97
//
//----------------------------------------------------------------------------
void SetMainDlgUserInfo(
    ArgsStruct  *pArgs,
    HWND        hwndDlg
) 
{
    HWND hwndTemp = NULL;

    //
    // Fill in the edit controls that exist
    // Set the textbox modification flag. For Win9x compatibily issues we have to explicitly
    // call SendMessageU instead of using the Edit_SetModify macro. The flag is used to see 
    // if the user has manually changed the contents of the edit boxes.
    //
    
    if (pArgs->fAccessPointsEnabled)
    {
        //
        // This fuction populates the combo box passed to it with info from the reg
        //
        ShowAccessPointInfoFromReg(pArgs, hwndDlg, IDC_MAIN_ACCESSPOINT_COMBO);
    }

    hwndTemp = GetDlgItem(hwndDlg, IDC_MAIN_USERNAME_EDIT);
    if (hwndTemp)
    {
        SetDlgItemTextU(hwndDlg, IDC_MAIN_USERNAME_EDIT, pArgs->szUserName);
        SendMessageU(hwndTemp, EM_SETMODIFY, (WPARAM)FALSE, 0L);
    }
    
    hwndTemp = GetDlgItem(hwndDlg, IDC_MAIN_PASSWORD_EDIT);
    if (hwndTemp)
    {
        CmDecodePassword(pArgs->szPassword);
        SetDlgItemTextU(hwndDlg, IDC_MAIN_PASSWORD_EDIT, pArgs->szPassword);
        CmEncodePassword(pArgs->szPassword);
        SendMessageU(hwndTemp, EM_SETMODIFY, (WPARAM)FALSE, 0L);
    }

    hwndTemp = GetDlgItem(hwndDlg, IDC_MAIN_DOMAIN_EDIT);
    if (hwndTemp) // !pArgs->fHideDomain)
    {
        SetDlgItemTextU(hwndDlg, IDC_MAIN_DOMAIN_EDIT, pArgs->szDomain);
        SendMessageU(hwndTemp, EM_SETMODIFY, (WPARAM)FALSE, 0L);
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   OnResetPassword
//
//  Synopsis:   Handle reset password.
//
//  Arguments:  pArgs           - the ArgStruct *
//              hwndDlg         - the main dlg
//
//  Returns:    BOOL -- TRUE if SUCCEEDED
//
//  History:    henryt  Created     5/6/97
//
//----------------------------------------------------------------------------
BOOL OnResetPassword(HWND hwndDlg, ArgsStruct *pArgs)
{
    LPTSTR pszArgs = NULL;
    LPTSTR pszCmd = NULL;
    BOOL bReturn = FALSE;

    MYDBGASSERT(pArgs); 
    MYDBGASSERT(pArgs->pszResetPasswdExe);

    //
    // Get the latest password data from the edit control 
    // and obfuscate its contents so that connect actions
    // can't retrieve it.
    //

    GetPasswordFromEdit(pArgs);     // fills pArgs->szPassword            
    ObfuscatePasswordEdit(pArgs);
   
    if (pArgs && pArgs->pszResetPasswdExe)
    {    
        if (CmParsePath(pArgs->pszResetPasswdExe, pArgs->piniService->GetFile(), &pszCmd, &pszArgs))
        {
            pArgs->Log.Log(PASSWORD_RESET_EVENT, pszCmd);

            SHELLEXECUTEINFO ShellExInfo;

            ZeroMemory(&ShellExInfo, sizeof(SHELLEXECUTEINFO));

            //
            //  Fill in the Execute Struct
            //
            ShellExInfo.cbSize = sizeof(SHELLEXECUTEINFO);
            ShellExInfo.hwnd = hwndDlg;
            ShellExInfo.lpVerb = TEXT("open");
            ShellExInfo.lpFile = pszCmd;
            ShellExInfo.lpParameters = pszArgs;
            ShellExInfo.nShow = SW_SHOWNORMAL;

            bReturn = pArgs->m_ShellDll.ExecuteEx(&ShellExInfo);            
        }

        CmFree(pszCmd);
        CmFree(pszArgs);
    }

#ifdef DEBUG
    CMASSERTMSG(bReturn, TEXT("OnResetPassword() - ShellExecute failed."));
#endif

    DeObfuscatePasswordEdit(pArgs);

    return bReturn;
}

//+---------------------------------------------------------------------------
//
//  Function:   OnCustom
//
//  Synopsis:   Handle custom button
//
//  Arguments:  pArgs           - the ArgStruct *
//              hwndDlg         - the main dlg
//
//  Returns:    NONE
//
//  History:    t-adnani    Created     6/26/99
//
//----------------------------------------------------------------------------
void OnCustom(
    HWND        hwndDlg,
    ArgsStruct  *pArgs)
{
    MYDBGASSERT(pArgs); 
    
    if (NULL == pArgs)
    {
        return;
    }

    pArgs->Log.Log(CUSTOM_BUTTON_EVENT);
    //
    // Get the latest password data from the edit control 
    // and obfuscate its contents so that connect actions
    // can't retrieve it.
    //

    GetPasswordFromEdit(pArgs);     // fills pArgs->szPassword            
    ObfuscatePasswordEdit(pArgs);

    //
    // Run the CustomButton actions
    //

    int iTextBoxLength = (int) SendDlgItemMessage(hwndDlg, IDC_MAIN_STATUS_DISPLAY, WM_GETTEXTLENGTH, 0, (LPARAM)0) + 1;
    TCHAR *pszTextBoxContents = (TCHAR *) CmMalloc(iTextBoxLength * sizeof(TCHAR));

    if (pszTextBoxContents)
    {
        GetDlgItemText(hwndDlg, IDC_MAIN_STATUS_DISPLAY, pszTextBoxContents, iTextBoxLength);
    }
    CActionList CustomActList;
    CustomActList.Append(pArgs->piniService, c_pszCmSectionCustom);

    if (!CustomActList.RunAccordType(hwndDlg, pArgs))
    {
        //
        // Connect action failed
        //
    }
    else
    {
        if (pszTextBoxContents)
        {
            SetDlgItemText(hwndDlg, IDC_MAIN_STATUS_DISPLAY, pszTextBoxContents); 
        }
    }
    CmFree(pszTextBoxContents);

    DeObfuscatePasswordEdit(pArgs);
}
    
//----------------------------------------------------------------------------
//
//  Function:   SetupInternalInfo
// 
//  Synopsis:   Load system dll's and init ArgsStruct with info from cmp/cms. 
//
//  Arguments:  pArgs           - the ArgStruct *
//              hwndDlg         - the main dlg
//              
//  Returns:    NONE
//
//  History:    henryt      created 8/13/97
//
//----------------------------------------------------------------------------
BOOL SetupInternalInfo(
    ArgsStruct  *pArgs,
    HWND        hwndDlg
)
{
    HCURSOR hcursorPrev = SetCursor(LoadCursorU(NULL,IDC_WAIT));
    BOOL    fRet = FALSE;

    //
    // should we check if TCP is bound to PPP?
    //
    pArgs->bDoNotCheckBindings = pArgs->piniService->GPPB(c_pszCmSection, 
                                                            c_pszCmEntryDoNotCheckBindings,
                                                            FALSE);

    DWORD dwComponentsToCheck = CC_RNA | CC_TCPIP | CC_RASRUNNING 
                                | CC_SCRIPTING | CC_CHECK_BINDINGS;

    if (TRUE == pArgs->bDoNotCheckBindings)
    {
        //
        // Do not check if TCP is bound to PPP
        //
        dwComponentsToCheck &= ~CC_CHECK_BINDINGS;
    }

#if 0 // Don't do this until the user gets into the app.
/*    
    //
    // If current connection type is dial-up (not Direct means Dial-up), 
    // then check modem
    //
    if (!pArgs->IsDirectConnect())
    {
        dwComponentsToCheck |= CC_MODEM;
    }
*/
#endif

    if (TRUE == IsTunnelEnabled(pArgs))
    {
        dwComponentsToCheck |= CC_PPTP;
    }

    //
    // should we check OS components, regardless what is in the registry key
    // Default is use the  registry key
    //
    BOOL fIgnoreRegKey = pArgs->piniService->GPPB(c_pszCmSection, 
                                                         c_pszCmEntryCheckOsComponents,
                                                         FALSE);

    //
    // If fIgnoreRegKey is TRUE, Do not bother looking ComponentsChecked from registry.
    // in 'Unattended Dialing' mode, check only, do not try to install
    //
    pArgs->dwExitCode = CheckAndInstallComponents( dwComponentsToCheck,
            hwndDlg, pArgs->szServiceName, fIgnoreRegKey, pArgs->dwFlags & FL_UNATTENDED);

    if (pArgs->dwExitCode != ERROR_SUCCESS )
    {
        goto done;
    }
 
    //
    // If we haven't loaded RAS yet, do so now.
    //
    if (!IsRasLoaded(&(pArgs->rlsRasLink)))
    {
        if (!LinkToRas(&pArgs->rlsRasLink))
        {
            if (pArgs->dwFlags & FL_UNATTENDED)
            {
                goto done;
            }

            //
            // Something terrible happened!  We want to check our configs and install
            // necessary components now.  
            //
            dwComponentsToCheck = CC_RNA | CC_RASRUNNING | CC_TCPIP;

            if (TRUE != pArgs->bDoNotCheckBindings)
            {
                dwComponentsToCheck |= CC_CHECK_BINDINGS;
            }

            pArgs->dwExitCode = CheckAndInstallComponents(dwComponentsToCheck, hwndDlg, pArgs->szServiceName);

            if (pArgs->dwExitCode != ERROR_SUCCESS || !LinkToRas(&pArgs->rlsRasLink))
            {
                goto done;
            }
        }
    }
        
    //
    // Load properties data   
    //
   
    LoadProperties(pArgs);

    //
    // Get phone info(phone #'s, etc) 
    // CheckConnect will check for empty phone number
    //

    LoadPhoneInfoFromProfile(pArgs);

    

    fRet = TRUE;

done:
    SetCursor(hcursorPrev);
    return fRet;
}

//----------------------------------------------------------------------------
//
//  Function:   OnMainLoadStartupInfo
// 
//  Synopsis:   Load the startup info for the main dlg(after WM_INITDIALOG).
//              This includes loading system dll's and setting up the UI.
//
//  Arguments:  hwndDlg         - the main dlg
//              pArgs           - the ArgStruct *
//              
//  Returns:    NONE
//
//  History:    henryt      created 8/13/97
//
//----------------------------------------------------------------------------

void OnMainLoadStartupInfo(
    HWND hwndDlg, 
    ArgsStruct *pArgs
) 
{
    UINT    i;
    UINT    nCtrlFocus;
    BOOL    fSaveNoNotify = pArgs->fIgnoreChangeNotification;

    pArgs->fStartupInfoLoaded = TRUE;

    //
    // if failed to load dll's, etc...
    //
    if (!SetupInternalInfo(pArgs, hwndDlg))
    {
        PostMessageU(hwndDlg, WM_COMMAND, IDCANCEL,0);
        return;
    }

    //
    // Set the length limit for the edit controls that exist
    //

    if (GetDlgItem(hwndDlg, IDC_MAIN_USERNAME_EDIT)) 
    {   
        i = (UINT)pArgs->piniService->GPPI(c_pszCmSection, c_pszCmEntryMaxUserName, UNLEN);

        if (i <= 0)
        {
            i = UNLEN; // username
        }
        
        SendDlgItemMessageU(hwndDlg, IDC_MAIN_USERNAME_EDIT, EM_SETLIMITTEXT, __min(UNLEN, i), 0);
    }
    
    if (GetDlgItem(hwndDlg, IDC_MAIN_PASSWORD_EDIT)) 
    {
        i = (UINT)pArgs->piniService->GPPI(c_pszCmSection, c_pszCmEntryMaxPassword, PWLEN);
    
        if (i <= 0)
        {
            i = PWLEN; // password
        }

        SendDlgItemMessageU(hwndDlg, IDC_MAIN_PASSWORD_EDIT, EM_SETLIMITTEXT, __min(PWLEN, i), 0);
    }

    if (GetDlgItem(hwndDlg, IDC_MAIN_DOMAIN_EDIT)) // !pArgs->fHideDomain)
    {
        i = (UINT)pArgs->piniService->GPPI(c_pszCmSection, c_pszCmEntryMaxDomain, DNLEN);
    
        if (i <= 0)
        {
            i = DNLEN; // domain
        }
        
        SendDlgItemMessageU(hwndDlg, IDC_MAIN_DOMAIN_EDIT, EM_SETLIMITTEXT, __min(DNLEN, i), 0);
    }

    //
    // if there's no service msg text, we need to hide and disable the control
    // so that context help doesn't work.
    //
    if (!GetWindowTextLengthU(GetDlgItem(hwndDlg, IDC_MAIN_MESSAGE_DISPLAY)))
    {
        ShowWindow(GetDlgItem(hwndDlg, IDC_MAIN_MESSAGE_DISPLAY), SW_HIDE);
        EnableWindow(GetDlgItem(hwndDlg, IDC_MAIN_MESSAGE_DISPLAY), FALSE);
    }

    //
    // display the user info
    //
    pArgs->fIgnoreChangeNotification = TRUE;
    SetMainDlgUserInfo(pArgs, hwndDlg);
    pArgs->fIgnoreChangeNotification = fSaveNoNotify;
    

    //
    // init "Remember password"
    //
    if (pArgs->fHideRememberPassword)
    {
        //
        // disable and hide the checkbox if the ISP doesn't use this feature
        //
        //ShowWindow(GetDlgItem(hwndDlg, IDC_MAIN_NOPASSWORD_CHECKBOX), SW_HIDE);
        //EnableWindow(GetDlgItem(hwndDlg, IDC_MAIN_NOPASSWORD_CHECKBOX), FALSE);
    }
    else
    {
        CheckDlgButton(hwndDlg, IDC_MAIN_NOPASSWORD_CHECKBOX, 
                            pArgs->fRememberMainPassword);
        
        //
        // Don't care if the pArgs->fRememberMainPassword is set
        // since controls will get disabled later
        // Set the save as option buttons according to what the current
        // deafult is
        //
        SetCredentialUIOptionBasedOnDefaultCreds(pArgs, hwndDlg);
    }

    
    //
    // init "Dial automatically..."
    //
    if (pArgs->fHideDialAutomatically)
    {
        //
        // disable and hide the checkbox if the ISP doesn't use this feature
        //
        //ShowWindow(GetDlgItem(hwndDlg, IDC_MAIN_NOPROMPT_CHECKBOX), SW_HIDE);
        //EnableWindow(GetDlgItem(hwndDlg, IDC_MAIN_NOPROMPT_CHECKBOX), FALSE);
    }
    else
    {
        CheckDlgButton(hwndDlg, IDC_MAIN_NOPROMPT_CHECKBOX, pArgs->fDialAutomatically);
    }

    //
    // Check the main dlg status and set the default button and focus accordingly
    //
    
    BOOL bReady = CheckConnect(hwndDlg,pArgs,&nCtrlFocus);
    
    MainSetDefaultButton(hwndDlg, nCtrlFocus);   
    SetFocus(GetDlgItem(hwndDlg, nCtrlFocus)); 

    //
    // Check if we want to dial without prompting user
    // if so, send the button click to connect button
    // We also want to dial if the user isn't logged on (ICS case)
    //

    if (bReady) 
    {
        if (pArgs->fDialAutomatically || 
            pArgs->dwFlags & FL_RECONNECT || 
            pArgs->dwFlags & FL_UNATTENDED ||
            ((CM_LOGON_TYPE_WINLOGON == pArgs->dwWinLogonType) && (pArgs->piniService->GPPB(c_pszCmSection, c_pszCmEntryUseWinLogonCredentials, TRUE))))
        {
            PostMessageU(hwndDlg, WM_COMMAND, IDOK, 0); 
        }   
    }
    else 
    {
        //
        // there are settings missing.
        // silently fail in unattended dial, set exit code
        //

        if (pArgs->dwFlags & FL_UNATTENDED) 
        {
            pArgs->dwExitCode = ERROR_WRONG_INFO_SPECIFIED;
            PostMessageU(hwndDlg, WM_COMMAND, IDCANCEL,0);
        }
    }

    CM_SET_TIMING_INTERVAL("OnMainLoadStartupInfo - Complete");
}

//+----------------------------------------------------------------------------
//
// Function:  CreateCustomButtonNextToTextBox
//
// Synopsis:  Creates a pushbutton next to the specified text box
//
// Arguments: HWND hwndDlg - Dialog Handle
//            HWND hwndTextBox - TextBox Handle
//            LPTSTR pszTitle - Push Button Title
//            LPTSTR pszToolTip - Push Button Tooltip
//            UINT uButtonID - Control ID of Button to create
//
// Returns:   Nothing
//
// History:   t-adnani    Created Header    6/28/99
//
//+----------------------------------------------------------------------------
void CreateCustomButtonNextToTextBox(
    HWND hwndDlg,               // Dialog Handle
    HWND hwndTextBox,           // TextBox Handle
    LPTSTR pszTitle,            // Caption
    LPTSTR pszToolTip,          // ToolTip Text
    UINT uButtonID                // ButtonID
)
{
    RECT    rt;
    POINT   pt1, pt2, ptTextBox1, ptTextBox2;
    HFONT   hfont;
    HWND    hwndButton;

    //
    // Get the rectangle and convert to points before we reduce its size.
    //
    
    GetWindowRect(hwndTextBox, &rt);

    pt1.x = rt.left;
    pt1.y = rt.top;
    pt2.x = rt.right;
    pt2.y = rt.bottom;

    ScreenToClient(hwndDlg, &pt1);
    ScreenToClient(hwndDlg, &pt2);

    //
    // Then calculate the points for reduction
    //
    
    ptTextBox1.x = rt.left;
    ptTextBox1.y = rt.top;
    ptTextBox2.x = rt.right;
    ptTextBox2.y = rt.bottom;

    ScreenToClient(hwndDlg, &ptTextBox1);
    ScreenToClient(hwndDlg, &ptTextBox2);

    //
    // Make the text box smaller
    //

    MoveWindow(hwndTextBox, ptTextBox1.x, ptTextBox1.y, 
               ptTextBox2.x - ptTextBox1.x - CUSTOM_BUTTON_WIDTH - 7,
               ptTextBox2.y - ptTextBox1.y, TRUE);
    
    //
    // Create the button
    //

    hwndButton = CreateWindowExU(0,
                                 TEXT("button"), 
                                 pszTitle, 
                                 BS_PUSHBUTTON|WS_VISIBLE|WS_CHILD|WS_TABSTOP,
                                 pt2.x - CUSTOM_BUTTON_WIDTH, 
                                 ptTextBox1.y, 
                                 CUSTOM_BUTTON_WIDTH, 
                                 ptTextBox2.y-ptTextBox1.y, 
                                 hwndDlg, 
                                 (HMENU)UIntToPtr(uButtonID),
                                 g_hInst, 
                                 NULL);
    if (NULL == hwndButton)
    {
        CMTRACE1(TEXT("CreateCustomButtonNextToTextBox() CreateWindowExU() failed, GLE=%u."),GetLastError());
    }
   
    //
    // Set the font on the button
    //

    hfont = (HFONT)SendMessageU(hwndTextBox, WM_GETFONT, 0, 0);
    
    if (NULL == hfont) 
    {
        CMTRACE1(TEXT("CreateCustomButtonNextToTextBox() WM_GETFONT failed, GLE=%u."),GetLastError());
        return;
    }

    SendMessageU(hwndButton, WM_SETFONT, (WPARAM)hfont, MAKELPARAM(TRUE,0));

    if (pszToolTip == NULL)
    {
        return;
    }

    //
    // do the tool tip
    //

    HWND hwndTT = CreateWindowExU(0, TOOLTIPS_CLASS, TEXT(""), TTS_ALWAYSTIP, 
        CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, 
        hwndDlg, (HMENU) NULL, g_hInst, NULL); 

    CMTRACE2(TEXT("CreateCustomButtonNextToTextBox() hwndTT is %u and IsWindow returns %u"),hwndTT, IsWindow(hwndButton));

    if (NULL == hwndTT)
    {
        CMTRACE1(TEXT("CreateCustomButtonNextToTextBox() CreateWindowExU() failed, GLE=%u."),GetLastError());
        MYDBGASSERT(hwndTT);
        return; 
    }

    TOOLINFO ti;    // tool information 

    ti.cbSize = sizeof(TOOLINFO); 
    ti.uFlags = TTF_IDISHWND | TTF_CENTERTIP | TTF_SUBCLASS; 
    ti.hwnd = hwndDlg; 
    ti.hinst = g_hInst; 
    ti.uId = (UINT_PTR) hwndButton; 
    ti.lpszText = pszToolTip; 

    SendMessageU(hwndTT, TTM_ADDTOOL, 0, (LPARAM) (LPTOOLINFO) &ti);

    CMTRACE2(TEXT("CreateCustomButtonNextToTextBox() hwndTT is %u and IsWindow returns %u"),hwndTT, IsWindow(hwndButton));

    return;
}


//+---------------------------------------------------------------------------
//
//  Function:   OnMainInit
// 
//  Synopsis:   Process the WM_INITDIALOG message
//              initialization function for Main dialog box
//
//  Arguments:  hwndDlg         - the main dlg
//              pArgs           - the ArgStruct *
//              
//  Returns:    NONE
//
//  History:    byao        Modified    5/9/97
//                          Added code to handle "Unattended Dial" and "Dial with Connectoid"
//
//----------------------------------------------------------------------------
void OnMainInit(HWND hwndDlg, 
                ArgsStruct *pArgs) 
{
    RECT    rDlg;
    RECT    rWorkArea;
    LPTSTR  pszTitle;

    SetForegroundWindow(hwndDlg);

    //
    // load the icons and bitmaps
    //

    LoadIconsAndBitmaps(pArgs, hwndDlg);

    //
    // Use long sevice name as title text for signin window, 
    //

    pszTitle = CmStrCpyAlloc(pArgs->szServiceName);
    SetWindowTextU(hwndDlg, pszTitle);
    CmFree(pszTitle);

    //
    // Set the msg for the main dlg for profile dialing
    //

    LPTSTR pszMsg = pArgs->piniService->GPPS(c_pszCmSection, c_pszCmEntryServiceMessage);
    SetDlgItemTextU(hwndDlg, IDC_MAIN_MESSAGE_DISPLAY, pszMsg);
    CmFree(pszMsg); 
        
    //
    // Show "remember password" checkbox?
    //

    if (IsLogonAsSystem())
    {
        //
        // If the program is running in the system account, hide the checkbox
        // Bug 196184: big security hole logging onto box with cm
        //

        pArgs->fHideRememberPassword = TRUE;

        //
        //  Another big security hole by launching help files from winlogon.
        //  See NTRAID 429678 for details.
        //
        EnableWindow(GetDlgItem(hwndDlg, IDC_MAIN_HELP_BUTTON), FALSE);

    }
    else
    {        
        pArgs->fHideRememberPassword = pArgs->piniService->GPPB(c_pszCmSection, c_pszCmEntryHideRememberPwd);   
    }

    //
    // See if the Internet Password should be hidden, take HideRemember
    // value as the default if no actual value is specified in the .CMS
    // The Internet Password can be saved regardless of the logon context 
    //

    pArgs->fHideRememberInetPassword = pArgs->piniService->GPPB(c_pszCmSection, c_pszCmEntryHideRememberInetPwd, pArgs->fHideRememberPassword);

    //
    // show "dial automatically" checkbox?
    //
    // if "hide remember password", then we also want to hide "dial automatically"
    //
    
    pArgs->fHideDialAutomatically = (pArgs->fHideRememberPassword?
                                     TRUE :
                                     pArgs->piniService->GPPB(c_pszCmSection, c_pszCmEntryHideDialAuto));

    // Get the dialog rect and the available work area.

    GetWindowRect(hwndDlg,&rDlg);
    
    if (SystemParametersInfoA(SPI_GETWORKAREA,0,&rWorkArea,0))
    {

        MoveWindow(hwndDlg,
                    rWorkArea.left + ((rWorkArea.right-rWorkArea.left)-(rDlg.right-rDlg.left))/2,
                    rWorkArea.top + ((rWorkArea.bottom-rWorkArea.top)-(rDlg.bottom-rDlg.top))/2,
                    rDlg.right-rDlg.left,
                    rDlg.bottom-rDlg.top,
                    FALSE);
    }

    //
    // hide all the hidden controls asap
    //
    if (pArgs->fHideRememberPassword)
    {
        //
        // disable and hide the checkbox if the ISP doesn't use this feature
        //
        ShowWindow(GetDlgItem(hwndDlg, IDC_MAIN_NOPASSWORD_CHECKBOX), SW_HIDE);
        EnableWindow(GetDlgItem(hwndDlg, IDC_MAIN_NOPASSWORD_CHECKBOX), FALSE);

        //
        // Even though we are hiding the remember password box, 
        // we should not hide these two controls as they might not exist on the
        // dialog. fGlobalCredentialsSupported controls which dialog templates get loaded and
        // if the flag is FALSE then the dialog template doesn't have these controls 
        // thus there is no reason to hide them.
        //
        if (pArgs->fGlobalCredentialsSupported)
        {
            //
            // Also hide the option buttons
            //
            ShowWindow(GetDlgItem(hwndDlg, IDC_OPT_CREDS_SINGLE_USER), SW_HIDE);
            EnableWindow(GetDlgItem(hwndDlg, IDC_OPT_CREDS_SINGLE_USER), FALSE);

            ShowWindow(GetDlgItem(hwndDlg, IDC_OPT_CREDS_ALL_USER), SW_HIDE);
            EnableWindow(GetDlgItem(hwndDlg, IDC_OPT_CREDS_ALL_USER), FALSE);
        }
    }
    else
    {
        //
        // Here we don't care if pArgs->fRememberMainPassword is set, because 
        // these controls will get disabled later, but we still need to set 
        // the default option.
        //
        SetCredentialUIOptionBasedOnDefaultCreds(pArgs, hwndDlg );
    }

    if (pArgs->fHideDialAutomatically)
    {
        //
        // disable and hide the checkbox if the ISP doesn't use this feature
        //
        ShowWindow(GetDlgItem(hwndDlg, IDC_MAIN_NOPROMPT_CHECKBOX), SW_HIDE);
        EnableWindow(GetDlgItem(hwndDlg, IDC_MAIN_NOPROMPT_CHECKBOX), FALSE);
    }

    //
    // Show the custom button?
    //
    // NT #368810
    // If logged on in the system account, don't do dynamic buttons
    //

    if (!IsLogonAsSystem() && GetDlgItem(hwndDlg, IDC_MAIN_USERNAME_EDIT))
    {
        LPTSTR pszTmp = pArgs->piniService->GPPS(c_pszCmSection, c_pszCmEntryCustomButtonText);
        if (pszTmp && *pszTmp)
        {
            LPTSTR pszToolTip = pArgs->piniService->GPPS(c_pszCmSection, c_pszCmEntryCustomButtonToolTip);
            
            CMTRACE(TEXT("Creating Custom Button"));

            CreateCustomButtonNextToTextBox(hwndDlg, 
                                            GetDlgItem(hwndDlg, IDC_MAIN_USERNAME_EDIT), 
                                            pszTmp,
                                            *pszToolTip ? pszToolTip : NULL,
                                            IDC_MAIN_CUSTOM);
            CmFree(pszToolTip);
        }

        CmFree(pszTmp);
    }

    //
    // Show the reset password button?
    //

    if (!IsLogonAsSystem() && GetDlgItem(hwndDlg, IDC_MAIN_PASSWORD_EDIT))
    {
        LPTSTR pszTmp = pArgs->piniService->GPPS(c_pszCmSection, c_pszCmEntryResetPassword);
    
        if (pszTmp && *pszTmp)
        {
            DWORD dwTmp;
            DWORD dwLen = (MAX_PATH * 2);

            pArgs->pszResetPasswdExe = (LPTSTR) CmMalloc(sizeof(TCHAR) * dwLen);
        
            if (pArgs->pszResetPasswdExe)
            {
                //
                // Expand any environment strings that may exist
                //

                CMTRACE1(TEXT("Expanding ResetPassword environment string as %s"), pszTmp);

                dwTmp = ExpandEnvironmentStringsU(pszTmp, pArgs->pszResetPasswdExe, dwLen);   
        
                MYDBGASSERT(dwTmp <= dwLen);

                //
                // As long as expansion succeeded, pass along the result
                //

                if (dwTmp <= dwLen)
                {
                    pszTitle = CmLoadString(g_hInst, IDS_RESETPASSWORD);
                    
                    CMTRACE((TEXT("Showing ResetPassword button for %s"), pArgs->pszResetPasswdExe));
                    
                    CreateCustomButtonNextToTextBox(hwndDlg, 
                                                    GetDlgItem(hwndDlg, IDC_MAIN_PASSWORD_EDIT), 
                                                    pszTitle,
                                                    (LPTSTR)MAKEINTRESOURCE(IDS_NEW_PASSWORD_TOOLTIP),
                                                    IDC_MAIN_RESET_PASSWORD);
                    CmFree(pszTitle);
                }
            }
        }

        CmFree(pszTmp);
    }

    //
    // Notify user that we are intializing
    //
    
    AppendStatusPane(hwndDlg,IDMSG_INITIALIZING);

    //
    // Initialize system menu
    //
    HMENU hMenu = GetSystemMenu(hwndDlg, FALSE);
    MYDBGASSERT(hMenu);

    // Delete size and maximize menuitems. These are
    // not appropriate for a dialog with a no-resize frame.
    
    DeleteMenu(hMenu, SC_SIZE, MF_BYCOMMAND);
    DeleteMenu(hMenu, SC_MAXIMIZE, MF_BYCOMMAND);

    EnableMenuItem(hMenu, SC_RESTORE, MF_BYCOMMAND | MF_GRAYED);

    //
    // See if we are hiding any InetLogon controls
    //

    if (IsTunnelEnabled(pArgs) && !pArgs->fUseSameUserName)
    {
        pArgs->fHideInetUsername = pArgs->piniService->GPPB(c_pszCmSection, 
                                                            c_pszCmEntryHideInetUserName);
        
        pArgs->fHideInetPassword = pArgs->piniService->GPPB(c_pszCmSection, 
                                                            c_pszCmEntryHideInetPassword);
    }

    //
    // set timer
    //
    pArgs->nTimerId = SetTimer(hwndDlg,1,TIMER_RATE,NULL);
}

//
// map state to frame: splash????
//

VOID MapStateToFrame(ArgsStruct * pArgs)
{
    static ProgState psOldFrame = PS_Interactive;

    ProgState psNewFrame = pArgs->psState;

    if (psNewFrame == PS_Dialing || psNewFrame == PS_TunnelDialing)
    {
        //
        // If we are dialing anything other than the primary number
    // switch the state to RedialFrame
    // RedialFrame is a misnomer - this is the frame that is displayed
    // when dialing backup number. It is not used when Redialing the 
        // primary number again
        //

        if (pArgs->nDialIdx > 0)
        {
            psNewFrame = PS_RedialFrame;
        }
    }

    if (pArgs->pCtr && psNewFrame != psOldFrame)
    {
        psOldFrame = psNewFrame;

        //
        // don't check for failure here - nothing we can do.
        //

        pArgs->pCtr->MapStateToFrame(psOldFrame);
    }
}

//
// SetInteractive: enable most of the windows and buttons so user can interact with 
//                 connection manager again 
// 

void SetInteractive(HWND hwndDlg, 
                    ArgsStruct *pArgs) 
{

    if (pArgs->dwFlags & FL_UNATTENDED)
    {
        //
        //  When we are unattended mode we don't want to put the UI into
        //  interactive mode and wait for user input.  Since the unattended
        //  UI is now hidden, this would put up the UI waiting for user
        //  interaction even though the UI was invisible.  Instead we
        //  will set the state to Interactive and post a message to cancel
        //  the dialer.  
        //
        CMTRACE(TEXT("SetInteractive called while in unattended mode, posting a message to cancel"));
        pArgs->psState = PS_Interactive;
        PostMessageU(hwndDlg, WM_COMMAND, IDCANCEL, ERROR_CANCELLED);
    }
    else
    {

        pArgs->psState = PS_Interactive;
        
        MapStateToFrame(pArgs);

        pArgs->dwStateStartTime = GetTickCount();
        EnableWindow(GetDlgItem(hwndDlg,IDOK),TRUE);
        EnableWindow(GetDlgItem(hwndDlg,IDC_MAIN_PROPERTIES_BUTTON),TRUE);
        
        //
        // Enable edit controls as necessary
        //
        if (GetDlgItem(hwndDlg, IDC_MAIN_ACCESSPOINT_COMBO)) 
        {
            EnableWindow(GetDlgItem(hwndDlg,IDC_MAIN_ACCESSPOINT_STATIC),TRUE);
            EnableWindow(GetDlgItem(hwndDlg,IDC_MAIN_ACCESSPOINT_COMBO),TRUE);
        }

        if (GetDlgItem(hwndDlg, IDC_MAIN_USERNAME_EDIT)) 
        {
            EnableWindow(GetDlgItem(hwndDlg,IDC_MAIN_USERNAME_EDIT),TRUE);
            EnableWindow(GetDlgItem(hwndDlg,IDC_MAIN_USERNAME_STATIC),TRUE);
        }

        if (GetDlgItem(hwndDlg, IDC_MAIN_PASSWORD_EDIT)) 
        {
            EnableWindow(GetDlgItem(hwndDlg,IDC_MAIN_PASSWORD_EDIT),TRUE);
            EnableWindow(GetDlgItem(hwndDlg,IDC_MAIN_PASSWORD_STATIC),TRUE);
        }

        if (GetDlgItem(hwndDlg, IDC_MAIN_DOMAIN_EDIT)) // !pArgs->fHideDomain)
        {
            EnableWindow(GetDlgItem(hwndDlg,IDC_MAIN_DOMAIN_EDIT),TRUE);
            EnableWindow(GetDlgItem(hwndDlg,IDC_MAIN_DOMAIN_STATIC),TRUE);
        }

        if (pArgs->hwndResetPasswdButton)
        {
            EnableWindow(pArgs->hwndResetPasswdButton, TRUE);
        }

        if (!pArgs->fHideRememberPassword)
        {
            EnableWindow(GetDlgItem(hwndDlg, IDC_MAIN_NOPASSWORD_CHECKBOX), TRUE);
            if (pArgs->fGlobalCredentialsSupported && pArgs->fRememberMainPassword)
            {
                //
                // Also enable the option buttons
                //
                EnableWindow(GetDlgItem(hwndDlg, IDC_OPT_CREDS_SINGLE_USER), TRUE);
                EnableWindow(GetDlgItem(hwndDlg, IDC_OPT_CREDS_ALL_USER), TRUE);
            }
        }

        if ((!pArgs->fHideDialAutomatically) && 
            (pArgs->fRememberMainPassword ||
             pArgs->piniService->GPPB(c_pszCmSection, c_pszCmEntryPwdOptional)))
        {
            EnableWindow(GetDlgItem(hwndDlg, IDC_MAIN_NOPROMPT_CHECKBOX), TRUE);
        }

        //
        //  Set the default button
        //
        SendMessageU(hwndDlg, DM_SETDEFID, (WPARAM)IDOK, 0);
        SetFocus(GetDlgItem(hwndDlg,IDOK));
    }

    DeObfuscatePasswordEdit(pArgs);
}  

//+----------------------------------------------------------------------------
//
// Function:  SetWatchHandles
//
// Synopsis:  Handles the messy details of Duplicating each of the Watch 
//            handles so that they can be accessed by the CMMON process.
//            The list of handles is assumed to be NULL terminated.
//
// Arguments: HANDLE *phOldHandles - Ptr to the current handle list.
//            HANDLE *phNewHandles - Ptr to storage for duplicted handles.
//            HWND hwndMon - HWND in the target process.
//
// Returns:   BOOL - TRUE on success
//
// History:   nickball    Created    2/11/98
//
//+----------------------------------------------------------------------------
BOOL
SetWatchHandles(
    IN  HANDLE *phOldHandles,
    OUT HANDLE *phNewHandles,
    IN  HWND hwndMon)
{
    MYDBGASSERT(phOldHandles);
    MYDBGASSERT(phNewHandles);
    MYDBGASSERT(hwndMon);

    BOOL bReturn = TRUE;
    
    if (NULL == phOldHandles || NULL == phNewHandles || NULL == hwndMon)
    {
        return FALSE;
    }
    
    //
    // First we need to get the Handle of our current process
    //
    DWORD dwProcessId = GetCurrentProcessId();
    
    HANDLE hSourceProcess = OpenProcess(PROCESS_DUP_HANDLE, FALSE, dwProcessId);

    //
    // Now the handle of the target process
    //
    GetWindowThreadProcessId(hwndMon, &dwProcessId);

    HANDLE hTargetProcess = OpenProcess(PROCESS_DUP_HANDLE, FALSE, dwProcessId);
  
    //
    // Loop through our handles list and duplicate
    //

    DWORD dwIdx = 0;

    for (dwIdx = 0; phOldHandles[dwIdx]; dwIdx++)
    {
        if (FALSE == DuplicateHandle(hSourceProcess, phOldHandles[dwIdx],  // Val
                                     hTargetProcess, &phNewHandles[dwIdx], // Ptr
                                     NULL, FALSE, DUPLICATE_SAME_ACCESS))
        {
            CMTRACE1(TEXT("SetWatchHandles() - DuplicateHandles failed on item %u"), dwIdx);
            MYDBGASSERT(FALSE);
            bReturn = FALSE;
            break;
        }
    }

    MYDBGASSERT(dwIdx); // Don't call if you don't have handles to duplicate

    //
    //  Cleanup
    //
    if (!bReturn)
    {
        // we failed during Handle Duplication... must clean up
        while (dwIdx > 0)
        {
            CloseHandle(phNewHandles[--dwIdx]);
        }
    }
    CloseHandle(hTargetProcess);
    CloseHandle(hSourceProcess);
    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  ConnectMonitor
//
// Synopsis:  Encapsulates the details of launching CMMON, waiting for load
//            verification, and providing it with connect data.
//
// Arguments: ArgsStruct *pArgs - Ptr to global args struct
//
// Returns:   HRESULT - Failure code
//
// History:   nickball    Created    2/9/98
//
//+----------------------------------------------------------------------------
HRESULT ConnectMonitor(ArgsStruct *pArgs)
{
    LRESULT lRes = ERROR_SUCCESS;
    BOOL fMonReady = FALSE;
    HWND hwndMon = NULL;
    TCHAR szDesktopName[MAX_PATH];
    TCHAR szWinDesktop[MAX_PATH];

    //
    // Determine if CMMON is running
    //
       
    if (SUCCEEDED(pArgs->pConnTable->GetMonitorWnd(&hwndMon)))
    {
        fMonReady = IsWindow(hwndMon);
    }

    //
    // If not, launch it
    //
    
    if (FALSE == fMonReady)       
    {
        //
        // Create launch event 
        //
        
        HANDLE hEvent = CreateEventU(NULL, TRUE, FALSE, c_pszCmMonReadyEvent);

        if (NULL == hEvent)
        {
            MYDBGASSERT(FALSE);
            lRes = GetLastError();    
        }
        else
        {
            STARTUPINFO         StartupInfo;
            PROCESS_INFORMATION ProcessInfo;
            TCHAR szCommandLine[2 * MAX_PATH + 3];

            //
            // Launch c_pszCmMonExeName 
            //

            ZeroMemory(&ProcessInfo, sizeof(ProcessInfo));
            ZeroMemory(&StartupInfo, sizeof(StartupInfo));
            StartupInfo.cb = sizeof(StartupInfo);

            //
            //  If this is win2k or whistler, then we don't want to launch cmmon32.exe onto the users
            //  desktop since it is a security hole to have a system process with a window on the users
            //  desktop.  This window could be attacked by WM_TIMER and other messages ...
            //  But in case of ICS (no user is logged on), just launch CMMON in normally by leaving 
            //  StartupInfo.lpDesktop = NULL. By leaving this NULL the new process inherits 
            //  the desktop and window station of its parent process.This makes it work with 
            //  ICS when no user is logged-on. Otherwise CM never gets the event back from 
            //  CMMON because it's on a different desktop.
            //
            if (OS_NT5 && IsLogonAsSystem() && (CM_LOGON_TYPE_ICS != pArgs->dwWinLogonType))
            {
                DWORD   cb;
                HDESK   hDesk = GetThreadDesktop(GetCurrentThreadId());

                //
                // Get the name of the desktop. Normally returns default or Winlogon or system or WinNT
                //  
                szDesktopName[0] = 0;
            
                if (GetUserObjectInformation(hDesk, UOI_NAME, szDesktopName, sizeof(szDesktopName), &cb))
                {
                    lstrcpyU(szWinDesktop, TEXT("Winsta0\\"));
                    lstrcatU(szWinDesktop, szDesktopName);
                    
                    StartupInfo.lpDesktop = szWinDesktop;
                    StartupInfo.wShowWindow = SW_SHOW;
                    
                    CMTRACE1(TEXT("ConnectMonitor - running under system account, so launching cmmon32.exe onto Desktop = %s"), MYDBGSTR(StartupInfo.lpDesktop));            
                }
                else
                {
                    //
                    //  If we are here, cmmon32.exe probably isn't going to be able to communicate with
                    //  cmdial32.dll which means the handoff between the two will fail and the call will be
                    //  aborted.
                    //
                    CMASSERTMSG(FALSE, TEXT("ConnectMonitor -- GetUserObjectInformation failed."));
                }
            }
            else if (OS_NT4 && IsLogonAsSystem())
            {
                //
                //  We are less concerned about the security risk on NT4 and more concerned with the loss
                //  of the functionality that cmmon32.exe provides to the user.  Thus we will push the
                //  cmmon32.exe window onto the user's desktop.
                //
                StartupInfo.lpDesktop = TEXT("Winsta0\\Default");
                StartupInfo.wShowWindow = SW_SHOW;
                
                CMTRACE1(TEXT("ConnectMonitor - running on system account on NT4, so launching cmmon32.exe onto Desktop = %s"), MYDBGSTR(StartupInfo.lpDesktop ));
            }
            
            ZeroMemory(&szCommandLine, sizeof(szCommandLine));

            szCommandLine[0] = TEXT('"');
            if (0 == GetSystemDirectoryU(szCommandLine + 1, 2 * MAX_PATH))
            {
                lRes = GetLastError();
                CMTRACE1(TEXT("ConnectMonitor() GetSystemDirectoryU(), GLE=%u."), lRes);
                return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
            }

            //
            // Set Application name to NULL, set command line to the executable name
            // Thus CreateProcess will search the path for the executable
            //
            lstrcatU(szCommandLine, TEXT("\\"));
            lstrcatU(szCommandLine, c_pszCmMonExeName);
            lstrcatU(szCommandLine, TEXT("\""));
            CMTRACE1(TEXT("ConnectMonitor() - Launching %s"), szCommandLine);

            if (NULL == CreateProcessU(NULL, szCommandLine, 
                                       NULL, NULL, FALSE, 0, 
                                       NULL, NULL,
                                       &StartupInfo, &ProcessInfo))
            {
                lRes = GetLastError();
                CMTRACE2(TEXT("ConnectMonitor() CreateProcess() of %s failed, GLE=%u."), 
                    c_pszCmMonExeName, lRes);
            }
            else
            {
                //
                // Wait for event to be signaled, that CMMON is up
                //

                DWORD dwWait = WaitForSingleObject(hEvent, MAX_OBJECT_WAIT);

                if (WAIT_OBJECT_0 != dwWait)
                {       
                    if (WAIT_TIMEOUT == dwWait)
                    {
                        lRes = ERROR_TIMEOUT;
                    }
                    else
                    {
                        lRes = GetLastError();
                    }
                }
                else
                {
                    fMonReady = TRUE;
                }

                //
                // Close Process handles. Note, we don't use these handles for 
                // duplicating handles in order to maintain a common code path
                // regardless of whether CMMON was up already.
                //

                CloseHandle(ProcessInfo.hProcess);
                CloseHandle(ProcessInfo.hThread);
            }

            CloseHandle(hEvent);
        }
    }
    
    
    if (fMonReady)
    {
        //
        // Get the hwnd for CMMON. Note: CMMON is expected to set  
        // the hwnd in the table before it signals the ready event.
        //
                
        if (FAILED(pArgs->pConnTable->GetMonitorWnd(&hwndMon)))
        {
            CMTRACE(TEXT("ConnectMonitor() - No Monitor HWND in table"));
            return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
        }

        //
        // Make sure the HWND for CMMON is valid before trying to send data.
        //

        if (!IsWindow(hwndMon))
        {                        
            MSG msg;
            HANDLE hHandle = GetCurrentProcess();

            //
            // Sometimes it takes a few ticks for us to get a positive response 
            // from IsWindow, so loop and pump messages while we are waiting.
            //
            while (hHandle && (MsgWaitForMultipleObjects(1, &hHandle, FALSE, 
                                                         MAX_OBJECT_WAIT, 
                                                         QS_ALLINPUT) == (WAIT_OBJECT_0 + 1)))
            {               
                while (PeekMessageU(&msg, NULL, 0, 0, PM_REMOVE))
                {
                    CMTRACE(TEXT("ConnectMonitor() - Waiting for IsWindow(hwndMon) - got Message"));
                    
                    TranslateMessage(&msg);
                    DispatchMessageU(&msg);
                }

                //
                // If the window is valid, we can go. Otherwise, keep pumping.
                //

                if (IsWindow(hwndMon))
                {
                    break;
                }
            }
            
            if (FALSE == IsWindow(hwndMon))
            {
                CMTRACE(TEXT("ConnectMonitor() - Monitor HWND in table is not valid"));
                return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
            }
        }

        //
        // Allocate buffer for CONNECTED_INFO, including extension for Watch Process list
        //

        DWORD dwWatchCount = GetWatchCount(pArgs);
        DWORD dwDataSize = sizeof(CM_CONNECTED_INFO) + (dwWatchCount * sizeof(HANDLE));

        LPCM_CONNECTED_INFO pInfo = (LPCM_CONNECTED_INFO) CmMalloc(dwDataSize);

        // 
        // Allocate the COPYDATASTRUCT
        // 

        COPYDATASTRUCT *pCopyData = (COPYDATASTRUCT*) CmMalloc(sizeof(COPYDATASTRUCT));

        if (NULL == pInfo || NULL == pCopyData)
        {
            lRes = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {               
            //
            // Fill in the CONNECTED_INFO
            //

            lstrcpyU(pInfo->szEntryName, pArgs->szServiceName);                                  
            lstrcpyU(pInfo->szProfilePath, pArgs->piniProfile->GetFile());
            
            //
            // Provide any password data that we have
            //

            lstrcpynU(pInfo->szPassword, pArgs->szPassword, 
                sizeof(pInfo->szPassword)/sizeof(pInfo->szPassword[0]));
            
            lstrcpynU(pInfo->szUserName, pArgs->szUserName,
                sizeof(pInfo->szUserName)/sizeof(pInfo->szUserName[0]));
            
            lstrcpynU(pInfo->szInetPassword, pArgs->szInetPassword,
                sizeof(pInfo->szInetPassword)/sizeof(pInfo->szInetPassword[0]));

            //
            // And the RAS phonebook
            //

            if (pArgs->pszRasPbk)
            {
                lstrcpynU(pInfo->szRasPhoneBook, pArgs->pszRasPbk,
                    sizeof(pInfo->szRasPhoneBook)/sizeof(pInfo->szRasPhoneBook[0]));            
            }
            else
            {
                pInfo->szRasPhoneBook[0] = L'\0';
            }

            
            pInfo->dwCmFlags = pArgs->dwFlags;                               

            //
            //  Need to know about global creds for Fast User Switching
            //
            if (CM_CREDS_GLOBAL == pArgs->dwCurrentCredentialType)
            {
                pInfo->dwCmFlags |= FL_GLOBALCREDS;
                CMTRACE(TEXT("ConnectMonitor - we have globalcreds!!"));
            }
            
            //
            // For W95, we must pass initial statistics data to CMMON
            //

            pInfo->dwInitBytesRecv = -1; // default to no stats
            pInfo->dwInitBytesSend = -1; // default to no stats               
            
            if (pArgs->pConnStatistics)
            {
                //
                // Get reg based stat data if available
                //

                if (pArgs->pConnStatistics->IsAvailable())
                {
                    pInfo->dwInitBytesRecv = pArgs->pConnStatistics->GetInitBytesRead(); 
                    pInfo->dwInitBytesSend = pArgs->pConnStatistics->GetInitBytesWrite();
                }

                //
                // Note: Adapter info is good, even if stats aren't available
                //

                pInfo->fDialup2 = pArgs->pConnStatistics->IsDialupTwo();                         
            }

            //
            // Update the watch process list at the end of the CONNECTED_INFO struct
            //

            if (dwWatchCount)
            {               
                if (FALSE == SetWatchHandles(pArgs->phWatchProcesses, &pInfo->ahWatchHandles[0], hwndMon))
                {
                    pInfo->ahWatchHandles[0] = NULL;
                }
            }
            
            //
            // Send CONNECTED_INFO to CMMON
            //
          
            pCopyData->dwData = CMMON_CONNECTED_INFO;
            pCopyData->cbData = dwDataSize;                
            pCopyData->lpData = (PVOID) pInfo;

            SendMessageU(hwndMon, WM_COPYDATA, NULL, (LPARAM) pCopyData);               
        }

        //
        // Release allocations
        //

        if (pInfo)
        {
            CmFree(pInfo);
        }
        
        if (pCopyData)
        {
            CmFree(pCopyData);
        }
    }               
            
    return HRESULT_FROM_WIN32(lRes);
}

//+----------------------------------------------------------------------------
//
// Function:  CreateConnTable
//
// Synopsis:  Initializes our CConnectionTable ptr and creates a new ConnTable
//            or opens an existing one as needed
//
// Arguments: ArgsStruct *pArgs - Ptr to global args struct containing.
//
// Returns:   HRESULT - Failure code
//
// History:   nickball    Created    2/9/98
//
//+----------------------------------------------------------------------------
HRESULT CreateConnTable(ArgsStruct *pArgs)
{   
    HRESULT hrRet = E_FAIL;
    
    pArgs->pConnTable = new CConnectionTable();

    if (pArgs->pConnTable)
    {
        //
        // We have our class, now create/open the connection table.
        //

        hrRet = pArgs->pConnTable->Open();

        if (FAILED(hrRet))
        {
            hrRet = pArgs->pConnTable->Create();
            
            if (HRESULT_CODE(hrRet) == ERROR_ALREADY_EXISTS)
            {
                CMTRACE1(TEXT("CreateConnTable -- ConnTable creation failed with error 0x%x.  Strange since the Open failed too..."), hrRet);
            }
            else
            {
                CMTRACE1(TEXT("CreateConnTable -- ConnTable creation failed with error 0x%x"), hrRet);
            }
        }  
    }
    else
    {
        hrRet = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }
       
    MYDBGASSERT(SUCCEEDED(hrRet));

    return hrRet;
}

#if 0 // NT 301988
/*
//+----------------------------------------------------------------------------
//
// Function:  HandleMainConnectRequest
//
// Synopsis:  Helper routine to handle the possibility that there may be a 
//            connect in progress on this service.
//
// Arguments: HWND hwndDlg - HWND of main dialog
//            ArgsStruct *pArgs - Ptr to global Args struct
//
// Returns:   BOOL - TRUE if we have fully handled the request 
//                   and it is ok to terminate this instance.
//
// History:   nickball    Created    2/23/98
//
//+----------------------------------------------------------------------------
BOOL HandleMainConnectRequest(HWND hwndDlg, ArgsStruct *pArgs)
{
    MYDBGASSERT(pArgs);

    BOOL fResolved = FALSE;

    LPCM_CONNECTION pConnection = GetConnection(pArgs);
        
    //
    // If no conection found, then there is no work to be done here, continue.
    //

    if (pConnection)
    {
        //
        // If we are in any state besides RECONNECT, we can handle it here
        //
        
        if (CM_RECONNECTPROMPT != pConnection->CmState)
        {
            fResolved = TRUE;

            if (pArgs->dwFlags & FL_DESKTOP)
            {
                //
                // Caller is from the desktop, notify the user and we're done
                //

                NotifyUserOfExistingConnection(hwndDlg, pConnection, TRUE);        
            }
            else
            {
                BOOL fSuccess = TRUE;
 
                //
                // We have a programmatic caller, if connected just bump the ref count
                // and return successfully. Otherwise we return failure so that the
                // caller doesn't erroneously believe that there is a connection.
                //
            
                if (CM_CONNECTED != pConnection->CmState)
                {
                    fSuccess = FALSE;
                }
                else
                {                
                    UpdateTable(pArgs, CM_CONNECTING);
                }                                 

                //
                // Terminate this connect instance. 
                //

                EndMainDialog(hwndDlg, pArgs, 0); // fSuccess);
            }
        }
        else
        {
            //
            // We're in reconnect mode and going to connect. 
            //

            if (!(pArgs->dwFlags & FL_RECONNECT))
            {                
                // 
                // This request is not a reconnect request from CMMON, 
                // make that sure the dialog is no longer displayed. 
                //
            
                HangupNotifyCmMon(pArgs->pConnTable, pConnection->szEntry);
            }
            else
            {
                //
                // We are handling a reconnect for CMMON, reduce the usage
                // count so it is in sync when we begin connecting.
                //

                pArgs->pConnTable->RemoveEntry(pConnection->szEntry);
            }
        }
        
        CmFree(pConnection);
    }

    return fResolved;
}
*/
#endif

//
// OnMainConnect: Command Handler when user clicked on 'Connect' Button in 
//                Main Dialog Box
//

void OnMainConnect(HWND hwndDlg, 
                   ArgsStruct *pArgs) 
{
    CM_SET_TIMING_INTERVAL("OnMainConnect - Begin");

    //
    // If we aren't ready to dial, set focus appropriately and bail
    //

    UINT nCtrlFocus;

    if (FALSE == CheckConnect(hwndDlg, pArgs, &nCtrlFocus, TRUE))
    {
        MainSetDefaultButton(hwndDlg, nCtrlFocus);   
        SetFocus(GetDlgItem(hwndDlg, nCtrlFocus)); 
        return;
    }

    (void) InterlockedExchange(&(pArgs->lInConnectOrCancel), NOT_IN_CONNECT_OR_CANCEL);

    //
    // Access Points - Disable AP combo box before connecting
    //
    EnableWindow(GetDlgItem(hwndDlg,IDC_MAIN_ACCESSPOINT_STATIC),FALSE);
    EnableWindow(GetDlgItem(hwndDlg,IDC_MAIN_ACCESSPOINT_COMBO),FALSE);

    //
    // Store the current access point to reg.
    //
    if (pArgs->fAccessPointsEnabled)
    {
        WriteUserInfoToReg(pArgs, UD_ID_CURRENTACCESSPOINT, (PVOID)(pArgs->pszCurrentAccessPoint));
    }
    
    //
    // Assume success unless something contradictory happens
    //

    pArgs->dwExitCode = ERROR_SUCCESS;

    HCURSOR hPrev = SetCursor(LoadCursorU(NULL,IDC_WAIT));

    LPTSTR pszMsg = CmFmtMsg(g_hInst, IDMSG_WORKING);

    if (pszMsg) 
    {
        SetDlgItemTextA(hwndDlg, IDC_MAIN_STATUS_DISPLAY, ""); 

        AppendStatusPane(hwndDlg,pszMsg);
        CmFree(pszMsg);
    }

    //
    // We're connecting, update the table. 
    //

    UpdateTable(pArgs, CM_CONNECTING);            
   
    //
    // Clear out everything on the status panel
    //

    SetDlgItemTextA(hwndDlg, IDC_MAIN_STATUS_DISPLAY, ""); 

    //
    //  Set the default button to Cancel
    //
    SendMessageU(hwndDlg, DM_SETDEFID, (WPARAM)IDCANCEL, 0);
    SetFocus(GetDlgItem(hwndDlg,IDCANCEL));
 
    BOOL fSaveUPD = TRUE;
    BOOL fSaveOtherUserInfo = TRUE;
    
    //
    // We want to save and/or delete credentials only when the user is logged on.
    // This is taken care of by the functions that get called here. As long as 
    // the user is logged on, we try to mark, delete credentials and
    // potentially resave credential info. From this level we shouldn't 
    // worry if we have the ras cred store or how the creds are really stored.
    // 
    if (CM_LOGON_TYPE_USER == pArgs->dwWinLogonType)
    {
        //
        // If this is NT4 or Win9X the GetAndStoreUserInfo takes care of storing
        // the user info w/o the credential store. 
        //
        if (OS_NT5)
        {
            //
            // For Win2K+ we use the RAS API to save the credentials. The call saves 
            // and deletes user and global creds based on the current state and the 
            // user's choices (whether to save a password, etc.)
            //
            TryToDeleteAndSaveCredentials(pArgs, hwndDlg);
            
            //
            // Parameter to GetAndStoreUserInfo() - doesn't save Username, Password, Domain
            //
            fSaveUPD = FALSE; 
        }
    }
    else
    {
        //
        // User isn't logged on, thus we don't want to save anything
        //
        fSaveUPD = FALSE;
        fSaveOtherUserInfo = FALSE;
    }

    //
    // Gets the userinfo from the edit boxes into the pArgs structure ans saves the other 
    // user flags. This is also saves the credentials on NT4 & Win 9x if the 3rd parameter is true
    //
    // 3rd parameter (fSaveUPD) - used to save Username, Domain, Password.
    // 4th param (fSaveOtherUserInfo) - used to save user info flags. (remember password, 
    //                                  dial automatically, etc.)
    //
    GetAndStoreUserInfo(pArgs, hwndDlg, fSaveUPD, fSaveOtherUserInfo);

    //
    // Vars for RAS 
    //

    pArgs->nDialIdx = 0;

    // 
    // Set our redial counter with the maximum. The max value is read 
    // in when we initialize the dialog. It is just a place holder
    // nRedialCnt is the var used/modified to regulate the re-dial process.
    //

    pArgs->nRedialCnt = pArgs->nMaxRedials;

    //
    // Disable username controls before dialing
    //

    EnableWindow(GetDlgItem(hwndDlg,IDC_MAIN_USERNAME_EDIT),FALSE);
    EnableWindow(GetDlgItem(hwndDlg,IDC_MAIN_USERNAME_STATIC),FALSE);

    
    //
    // Disable password controls before dialing
    //      

    EnableWindow(GetDlgItem(hwndDlg,IDC_MAIN_PASSWORD_EDIT),FALSE);
    EnableWindow(GetDlgItem(hwndDlg,IDC_MAIN_PASSWORD_STATIC),FALSE);


    //
    // Disable domain controls before dialing
    //

    EnableWindow(GetDlgItem(hwndDlg,IDC_MAIN_DOMAIN_EDIT),FALSE);
    EnableWindow(GetDlgItem(hwndDlg,IDC_MAIN_DOMAIN_STATIC),FALSE);


    //
    // disable all other buttons
    //

    EnableWindow(GetDlgItem(hwndDlg,IDOK),FALSE);
    EnableWindow(GetDlgItem(hwndDlg,IDC_MAIN_PROPERTIES_BUTTON),FALSE);

    if (pArgs->hwndResetPasswdButton)
    {
        EnableWindow(pArgs->hwndResetPasswdButton, FALSE);
    }

    if (!pArgs->fHideRememberPassword)
    {
        EnableWindow(GetDlgItem(hwndDlg, IDC_MAIN_NOPASSWORD_CHECKBOX), FALSE);
        
        if (pArgs->fGlobalCredentialsSupported)
        {
            //
            // Also disable the option buttons
            //
            EnableWindow(GetDlgItem(hwndDlg, IDC_OPT_CREDS_SINGLE_USER), FALSE);
            EnableWindow(GetDlgItem(hwndDlg, IDC_OPT_CREDS_ALL_USER), FALSE);
        }
    }

    if (!pArgs->fHideDialAutomatically)
    {
        EnableWindow(GetDlgItem(hwndDlg, IDC_MAIN_NOPROMPT_CHECKBOX), FALSE);
    }

    //
    // Try to check the Advanced Tab settings (ICF/ICS) and see if we need to enable or disable
    // them based on what's configured in the .cms file. This is only on WinXP+ & if the user is logged in
    //
    VerifyAdvancedTabSettings(pArgs);

    //
    // Dial the number
    //

    DWORD dwResult = ERROR_SUCCESS;

    pArgs->Log.Log(PRECONNECT_EVENT, pArgs->GetTypeOfConnection());
    //
    // Run the Pre-Connect actions
    //
    CActionList PreConnActList;
    PreConnActList.Append(pArgs->piniService, c_pszCmSectionPreConnect);

    if (!PreConnActList.RunAccordType(hwndDlg, pArgs))
    {
        //
        // Connect action failed
        //

        UpdateTable(pArgs, CM_DISCONNECTED);

        dwResult = ERROR_INVALID_DLL; // Only used for failed CA
    }
    else
    {
        if (pArgs->IsDirectConnect())
        {
            MYDBGASSERT(pArgs->hrcRasConn == NULL);

            pArgs->fUseTunneling = TRUE;

            pArgs->psState = PS_TunnelDialing;
            pArgs->dwStateStartTime = GetTickCount();
            pArgs->nLastSecondsDisplay = (UINT) -1;

            dwResult = DoTunnelDial(hwndDlg,pArgs);
        }
        else
        {
            //
            // If the DynamicPhoneNumber flag is set, then we need to re-read
            // the phoneinfo from the profile and make sure it re-munged. 
            //
            
            BOOL bDynamicNum = pArgs->piniService->GPPB(c_pszCmSection, c_pszCmDynamicPhoneNumber);

            if (bDynamicNum)
            {
                LoadPhoneInfoFromProfile(pArgs);
            }

            //
            // Load dial info(phone #'s, etc)
            // In the auto-dial case we pass FALSE for fInstallModem so that
            // LoadDialInfo does not try to install a modem because it would
            // require user intervention
            //

            dwResult = LoadDialInfo(pArgs, hwndDlg, !(pArgs->dwFlags & FL_UNATTENDED), bDynamicNum);
            
            //
            // Close TAPI before we dial, this will be cleaned up when we unlink, 
            // but there is no reason to keep TAPI tied up while we're dialing.
            //
            
            CloseTapi(&pArgs->tlsTapiLink);

            if (dwResult == ERROR_SUCCESS)
            {
                dwResult = DoRasDial(hwndDlg,pArgs,pArgs->nDialIdx);
            }

            //
            // If modem is not installed and LoadDialInfo failed to install modem, dwResult will be
            // ERROR_PORT_NOT_AVAILABLE.  Ideally, we should disable the connect button and display
            // a different error message.  
            //                
        }
    }

    if (ERROR_SUCCESS != dwResult) 
    { 
        HangupCM(pArgs, hwndDlg);
        UpdateError(pArgs, dwResult);

        if (IsLogonAsSystem() && BAD_SCARD_PIN(dwResult))
        {
            //
            //  Disable the Connect button to avoid smartcard lockout.  Also propagate
            //  the error back to our caller (RAS) so that they can End the 'choose
            //  connectoid' dialog and return to winlogon, where the user can enter
            //  the correct PIN.
            //
            pArgs->dwSCardErr = dwResult;
            EnableWindow(GetDlgItem(hwndDlg, IDOK), FALSE);
            SendMessageU(hwndDlg, DM_SETDEFID, (WPARAM)IDCANCEL, 0);
            SetFocus(GetDlgItem(hwndDlg, IDCANCEL));
        }
        
        SetLastError(dwResult);
    }

    SetCursor(hPrev);

    CM_SET_TIMING_INTERVAL("OnMainConnect - End");
}

//+---------------------------------------------------------------------------
//
//  Function:   UseTunneling
//
//  Synopsis:   Check to see if we should do tunneling based on fTunnelPrimary
//              and fTunnelReferences.
//
//  Arguments:  pArgs [the ArgStruct ptr]
//              dwEntry [the phone index]
//
//  Returns:    TRUE if we tunnel, FALSE otherwise.
//
//  History:    henryt  Created     3/5/97
//
//----------------------------------------------------------------------------
BOOL UseTunneling(
    ArgsStruct  *pArgs, 
    DWORD       dwEntry
)
{
    LPTSTR  pszRefPhoneSource = NULL;
    BOOL    fPhoneNumIsFromPrimaryPBK;

    LPTSTR  pszTmp;

    CIni    iniTmp(pArgs->piniProfile->GetHInst(),pArgs->piniProfile->GetFile(), pArgs->piniProfile->GetRegPath());
    BOOL    fUseTunneling = FALSE;

    //
    // Set the read flags
    //
    if (pArgs->dwGlobalUserInfo & CM_GLOBAL_USER_INFO_READ_ICS_DATA)
    {
        LPTSTR pszICSDataReg = BuildICSDataInfoSubKey(pArgs->szServiceName);

        if (pszICSDataReg)
        {
            iniTmp.SetReadICSData(TRUE);
            iniTmp.SetICSDataPath(pszICSDataReg);
        }

        CmFree(pszICSDataReg);
    }

    iniTmp.SetEntryFromIdx(dwEntry);
    pszRefPhoneSource = iniTmp.GPPS(c_pszCmSection, c_pszCmEntryPhoneSourcePrefix);

    //
    // If PhoneSource[0|1] is not empty, verify its existence
    //

    if (*pszRefPhoneSource) 
    {        
        //
        // pszRefPhoneSource is either a relative or full path.
        // CmConvertRelativePath() will do the conversion to a full path properly
        //
        pszTmp = CmConvertRelativePath(pArgs->piniService->GetFile(), pszRefPhoneSource);
        
        if (!pszTmp || FALSE == FileExists(pszTmp))
        {
            
            CmFree(pszRefPhoneSource); 
            CmFree(pszTmp);
            return fUseTunneling;
        }

        //
        // Is the phone # from the primary(top level) phone book?
        //
        
        fPhoneNumIsFromPrimaryPBK = (lstrcmpiU(pszTmp, pArgs->piniService->GetFile()) == 0);
        CmFree(pszTmp);

        fUseTunneling = 
            ((fPhoneNumIsFromPrimaryPBK && pArgs->fTunnelPrimary) ||
             (!fPhoneNumIsFromPrimaryPBK && pArgs->fTunnelReferences));
    }
    else 
    {
        // the phone # is not from a phone book.  the user probably typed it in
        // him/herself.
        fUseTunneling = pArgs->fTunnelPrimary;
    }
    
    CmFree(pszRefPhoneSource);

    return fUseTunneling;
}

//
// OnMainProperties: command handler for 'Properties' button in the main dialog box
//

int OnMainProperties(HWND hwndDlg, 
                     ArgsStruct *pArgs) 
{
    CMTRACE(TEXT("Begin OnMainProperties()"));

    //
    // do the settings dlg.
    //

    BOOL bCachedAccessPointsEnabled = pArgs->fAccessPointsEnabled;

    int iRet = DoPropertiesPropSheets(hwndDlg, pArgs);

    //
    // We need to re-enumerate the access points and re-check connecting because
    // the user may have added or deleted an access point and then hit cancel.
    //

    if (pArgs->hwndMainDlg) 
    {
        if (bCachedAccessPointsEnabled != pArgs->fAccessPointsEnabled)
        {
            CMTRACE(TEXT("Access points state changed, returning to the main dialog which needs to relaunch itself with the proper template."));
            iRet = ID_OK_RELAUNCH_MAIN_DLG;
        }
        else
        {
            //
            //  If the user canceled, then we want to set the accesspoint back to what it was on the main dialog
            //  since the user may have changed it on the properties dialog but then canceled.
            //
            if (pArgs->fAccessPointsEnabled)
            {
                if (0 == iRet) // user hit cancel
                {
                    ChangedAccessPoint(pArgs, hwndDlg, IDC_MAIN_ACCESSPOINT_COMBO);                
                }

                ShowAccessPointInfoFromReg(pArgs, hwndDlg, IDC_MAIN_ACCESSPOINT_COMBO);
            }

            UINT nCtrlFocus;

            CheckConnect(hwndDlg,pArgs,&nCtrlFocus);
            MainSetDefaultButton(hwndDlg,nCtrlFocus);
            SetFocus(GetDlgItem(hwndDlg,nCtrlFocus));
        }
    }

    CMTRACE(TEXT("End OnMainProperties()"));

    return iRet;
}

//
// user pressed the cancel button!!!!!
//
void OnMainCancel(HWND hwndDlg, 
                  ArgsStruct *pArgs) 
{   
    CMTRACE1(TEXT("OnMainCancel(), state is %d"), pArgs->psState);

    //
    //  Re-entrancy protection.  If we're in the middle of a RasDial, wait 2 seconds.
    //  If the "semaphore" is still held, exit.  (This is only likely to happen during
    //  a stress situation, so failing the cancel is acceptable.)
    //
    LONG lInConnectOrCancel;
    int SleepTimeInMilliseconds = 0;
    do
    {
        lInConnectOrCancel = InterlockedExchange(&(pArgs->lInConnectOrCancel), IN_CONNECT_OR_CANCEL);
        CMASSERTMSG(((NOT_IN_CONNECT_OR_CANCEL == lInConnectOrCancel) || (IN_CONNECT_OR_CANCEL == lInConnectOrCancel)),
                    TEXT("OnMainCancel - synch variable has unexpected value!"));

        Sleep(50);
        SleepTimeInMilliseconds += 50;
    }
    while ((IN_CONNECT_OR_CANCEL == lInConnectOrCancel) && (SleepTimeInMilliseconds < 2000));

    if (IN_CONNECT_OR_CANCEL == lInConnectOrCancel)
    {
        CMTRACE(TEXT("OnMainCancel - waited 2 seconds for system for InRasDial mutex to be freed, leaving Cancel"));
        return;
    }

    //
    // Terminate Lana
    //

    if (PS_TunnelDialing == pArgs->psState && pArgs->uLanaMsgId)
    {
        MYDBGASSERT(OS_W9X);
        PostMessageU(hwndDlg, pArgs->uLanaMsgId, 0, 0);
    }

    if (pArgs->psState != PS_Interactive && pArgs->psState != PS_Error)
    {
        pArgs->Log.Log(ONCANCEL_EVENT);

        //
        // Run OnCancel connect actions. If we are dialing, this is a cancel 
        // dialing event. Note: The assumption here is CM never post itself 
        // an IDCANCEL message when dialing
        //

        CActionList OnCancelActList;
        OnCancelActList.Append(pArgs->piniService, c_pszCmSectionOnCancel);

        //
        // fStatusMsgOnFailure = FALSE
        //
        OnCancelActList.RunAccordType(hwndDlg, pArgs, FALSE); 
    }

    switch (pArgs->psState) 
    {
        case PS_Dialing:
        case PS_TunnelDialing:
        case PS_Authenticating:
        case PS_TunnelAuthenticating:
        
            // fall through

        case PS_Pausing:

            //
            // we should also try to hangup for ps_pausing since cm could be
            // in the middle or redialing the tunnel server.  we need to
            // hangup the first ppp connection.
            //

            //
            // Set fWaitForComplete to TRUE.
            // This will cause HangupCM to block until the ras handle is invalid.
            // Otherwise, HangupCM will return while the device is in use.
            //

            HangupCM(pArgs,hwndDlg, TRUE); // fWaitForComplete = TRUE
               
            //
            // Display cancelled message
            //
            
            AppendStatusPane(hwndDlg, IDMSG_CANCELED);
            
            SetInteractive(hwndDlg,pArgs);
            break;

        case PS_Online:
            //
            // If pArgs->fUseTunneling is TRUE, CM actually does not have the PS_Online state
            //
            MYDBGASSERT(!pArgs->fUseTunneling);
            if (pArgs->fUseTunneling) 
            {
                break;
            }

        case PS_TunnelOnline:
        {
            TCHAR szTmp[MAX_PATH];            
            MYVERIFY(GetModuleFileNameU(g_hInst, szTmp, MAX_PATH));          
            pArgs->Log.Log(DISCONNECT_EVENT, szTmp);
            CActionList DisconnectActList;
            DisconnectActList.Append(pArgs->piniService, c_pszCmSectionOnDisconnect);

            //
            // fStatusMsgOnFailure = FALSE
            //
            
            DisconnectActList.RunAccordType(hwndDlg, pArgs, FALSE);

            HangupCM(pArgs,hwndDlg);

            pArgs->dwExitCode = ERROR_CANCELLED;

            // fall through
        }

        case PS_Error:
        case PS_Interactive:
            pArgs->dwExitCode = ERROR_CANCELLED; 
            EndMainDialog(hwndDlg, pArgs, 0); // FALSE);
            break;

        default:
            MYDBGASSERT(FALSE);
            break;
    }

    //
    // We're definitely not waiting for a callback anymore.
    //

    pArgs->fWaitingForCallback = FALSE;

    //
    // We are exiting Cancel state
    //
    (void)InterlockedExchange(&(pArgs->lInConnectOrCancel), NOT_IN_CONNECT_OR_CANCEL);
}

void OnMainEnChange(HWND hwndDlg, 
                    ArgsStruct *pArgs) 
{
    CheckConnect(hwndDlg, pArgs, NULL);
}

//+----------------------------------------------------------------------------
//
// Function:  OnRasErrorMessage
//
// Synopsis:  Process RAS error message
//
// Arguments: HWND hwndDlg - Main Dialog window handle
//            ArgsStruct *pArgs - 
//            DWORD dwError - RAS error code
//
// Returns:   Nothing
//
// History:   fengsun Created Header    10/24/97
//
//+----------------------------------------------------------------------------
void OnRasErrorMessage(HWND hwndDlg, 
                   ArgsStruct *pArgs,
                   DWORD dwError) 
{
    //
    // Save off whether we are tunneling, before we change state
    //

    BOOL bTunneling = IsDialingTunnel(pArgs);
    
    //
    // Set the progstate to Error if user did not cancel dialing.
    // Note: Set here to ensure that we don't inadvertantly update the status on
    // timer ticks thereby overwriting the error message. Additionally we do this 
    // following SetInteractive in the no-redial case below.
    //
    
    if (ERROR_CANCELLED != dwError)
    {
        CMTRACE(TEXT("OnRasErrorMessage - Entering PS_Error state"));
        pArgs->psState = PS_Error;
    }

    //
    // Set the "ErrorCode" property
    //
    pArgs->dwExitCode = dwError;

    lstrcpyU(pArgs->szLastErrorSrc, TEXT("RAS"));
    
    pArgs->Log.Log(ONERROR_EVENT, pArgs->dwExitCode, pArgs->szLastErrorSrc);

    //
    // Run On-Error connect actions
    //
    CActionList OnErrorActList;
    OnErrorActList.Append(pArgs->piniService, c_pszCmSectionOnError);

    //
    // fStatusMsgOnFailure = FALSE
    //
    OnErrorActList.RunAccordType(hwndDlg, pArgs, FALSE);


    LPTSTR  pszRasErrMsg = NULL;

    //
    // See if the error is recoverable (re-dialable)
    // CheckConnectionError also display error msg in the status window
    // Get the ras err msg also.  we'll display it ourself.
    //

    BOOL bDoRedial = !CheckConnectionError(hwndDlg, dwError, pArgs, bTunneling, &pszRasErrMsg);

    //
    // Whether CM get ERROR_PORT_NOT_AVAILABLE because of modem change
    //
    BOOL fNewModem = FALSE;

    if (dwError == ERROR_PORT_NOT_AVAILABLE && !IsDialingTunnel(pArgs))
    {
        //
        // Modem is not avaliable.  See if the modem is changed
        //

        BOOL fSameModem = TRUE;
        if (PickModem(pArgs, pArgs->szDeviceType, pArgs->szDeviceName, &fSameModem))
        {
            if (!fSameModem)
            {
                //
                // If the modem is changed, use the new modem.
                // bDoRedial is still FALSE here so we will not
                // increase redial count or use the backup number
                //

                fNewModem = TRUE;
            }
        }

        // 
        // if PickModem failed, do not try to install modem here
        // cnetcfg return ERROR_CANCELLED, even if modem is intalled 
        //
    }

    //
    // should we try another tunnel dns addr?
    //

    BOOL fTryAnotherTunnelDnsAddr = FALSE;

    if (bDoRedial) 
    {
        //
        // The error is recoverable
        //
        
        CMTRACE1(TEXT("OnRasErrorMessage - Recoverable error %u received."), dwError);

        //
        // If we're dialing a tunnel, try a different IP address on failure.
        //
      
        if (PS_TunnelDialing == pArgs->psState)
        {
            fTryAnotherTunnelDnsAddr = TryAnotherTunnelDnsAddress(pArgs);
        }

        //
        // If we're trying a different IP, then don't count this as a normal 
        // redial. Otherwise, bump the indices and move on to the next number.

        if (!fTryAnotherTunnelDnsAddr)
        {
            //
            // we display the ras error only if:
            // (1) we're not redialing OR
            // (2) we're not redialing a tunnel OR
            // (3) we're redialing a tunnel but NOT redialing with a different 
            //     tunnel dns ip addr.
            //
            if (pszRasErrMsg)
            {
                AppendStatusPane(hwndDlg, pszRasErrMsg);
            }
            
            // should we redial?
            //
            if (pArgs->nRedialCnt)  
            {
                //
                // We have not reached the retry limit, try to redial
                //
                pArgs->nRedialCnt--;   
                pArgs->nDialIdx++;

                //
                // If ndx now matches count, or if the next number is empty 
                // (not dialable) this our last number to dial on this pass.
                // Adjust the re-dial counter if it applies.
                //

                if (pArgs->nDialIdx == MAX_PHONE_NUMBERS || 
                    !pArgs->aDialInfo[pArgs->nDialIdx].szDialablePhoneNumber[0]) 
                {
                    pArgs->nDialIdx = 0;
                }
            }
            else
            {
                //
                // Last redial try failed
                //
    
                bDoRedial = FALSE;
            }
        }
    }
    else
    {

        CMTRACE1(TEXT("OnRasErrorMessage - Non-recoverable error %u received."), dwError);

        //
        // we display the ras error only if:
        // (1) we're not redialing OR
        // (2) we're not redialing a tunnel OR
        // (3) we're redialing a tunnel but NOT redialing with a different 
        //     tunnel dns ip addr.
        //
        if (pszRasErrMsg)
        {
            AppendStatusPane(hwndDlg, pszRasErrMsg);
        }
    }

    bDoRedial |= fNewModem; // fNewModem only true if not dialing tunnel

    //
    // Perform Hangup here
    //
    if (IsDialingTunnel(pArgs) && bDoRedial)
    {
        //
        // For tunnel dialing, only hangup tunnel connection, Do not hangup 
        // PPP connection before retry.
        //
        MyRasHangup(pArgs,pArgs->hrcTunnelConn);  
        pArgs->hrcTunnelConn = NULL;

        if (pArgs->IsDirectConnect())
        {
            //
            // The statistic is stopped in HangupCM
            // Since we do not call HangupCM, we have to close it here
            //

            if (pArgs->pConnStatistics)
            {
                pArgs->pConnStatistics->Close();
            }
        }
    }
    else
    {
        if (OS_NT)
        {
            HangupCM(pArgs, hwndDlg, FALSE, !bDoRedial);  
        }
        else
        {
            //
            // On win9x, in some PPP case, when CM get Tunnel RAS error message, 
            // RasHangup will not release the PPP RAS handle until this
            // message returns. See bug 39718
            //
            
            PostMessageU(hwndDlg, WM_HANGUP_CM, !bDoRedial, dwError);
        }
    }

    // 
    // If we want re-dial enter pause state, otherwise just SetInteractive
    // 

    if (bDoRedial)
    {
        //
        // If the state is PS_Error, we will use the timer we set before the call.  
        // However we will not check whether the timer expired here.
        //

        if (fTryAnotherTunnelDnsAddr)
        {
            //
            // if we want to try another tunnel dns addr, we don't want to display
            // any error msg or pause, just retry with another addr without the 
            // user realizing it.
            //
            pArgs->dwStateStartTime = GetTickCount() + (pArgs->nRedialDelay * 1000);
        }
        else
        {
            //
            // NT #360488 - nickball
            // 
            // Reset the timer so that we pause for the redial delay before 
            // trying to connect again. ErrorEx (now unused), conditioned this
            // code on the error state not being PS_Error, however, this was 
            // broken when we started setting the state to PS_Error at the 
            // beginning of this function. Because ErrorEx is not longer used, 
            // we can restore the timer reset to all states.
            //

            pArgs->dwStateStartTime = GetTickCount();  
            pArgs->nLastSecondsDisplay = (UINT) -1;     
        }

        pArgs->psState = PS_Pausing;
    }
    else
    {
        SetInteractive(hwndDlg,pArgs);

        if (ERROR_CANCELLED != dwError)
        {
            CMTRACE(TEXT("OnRasErrorMessage - Restoring PS_Error state"));
            pArgs->psState = PS_Error;
        }

        pArgs->dwExitCode = dwError;

        // in 'unattended dial' mode, exit ICM
        if (pArgs->dwFlags & FL_UNATTENDED)
        {
            PostMessageU(hwndDlg, WM_COMMAND, IDCANCEL, dwError);
        }
    }

    if (pszRasErrMsg)
    {
        CmFree(pszRasErrMsg);
    }   
} 

//+----------------------------------------------------------------------------
//
// Function:  OnRasNotificationMessage
//
// Synopsis:  Message handler for RAS status/error messages.
//
// Arguments: HWND hwndDlg      - Main Dialog window handle
//            ArgsStruct *pArgs - Ptr to global Args struct
//            WPARAM wParam     - RAS status message
//            LPARAM lParam     - RAS error message. ERROR_SUCCESS if none.
//
// Returns:   Error code if applicable.
//
// History:   nickball          Created Header      05/19/99
//
//+----------------------------------------------------------------------------
DWORD OnRasNotificationMessage(HWND hwndDlg, 
                          ArgsStruct *pArgs, 
                          WPARAM wParam, 
                          LPARAM lParam)
{
    CMTRACE2(TEXT("OnRasNotificationMessage() wParam=%u, lParam=%u"), wParam, lParam);
    
    if (pArgs->fIgnoreTimerRasMsg)
    {
        CMTRACE(TEXT("OnRasNotificationMessage() ignoring Ras and Timer messages"));
        return ERROR_SUCCESS;
    }

    //
    // If we have an error notification from RAS, handle it.
    //

    if (ERROR_SUCCESS != lParam) 
    {
        //
        //  If 2nd subchannel on multilinked ISDN fails, default to single channel.
        //

        if (OS_NT5)
        {
            if ((pArgs->dwRasSubEntry > 1) &&
                (CM_ISDN_MODE_DUALCHANNEL_FALLBACK == pArgs->dwIsdnDialMode))
            {
                PostMessageU(hwndDlg, WM_CONNECTED_CM,0,0);
                return ERROR_SUCCESS;
            }
        }

        //
        // Skip PENDING notifications 
        //
        
        if (PENDING == lParam)
        {
            CMTRACE(TEXT("OnRasNotificationMessage() Skipping PENDING notification."));       
            return ERROR_SUCCESS;
        }

        //
        // If we're already in the interactive or error state, then
        // ignore any subsequent error notifications from RAS. 
        //
        // For example: RAS often sends a ERROR_USER_DISCONNECTION 
        // notification when we call RasHangup.
        //
        
        if (pArgs->psState == PS_Interactive || pArgs->psState == PS_Error)
        {
            CMTRACE1(TEXT("OnRasNotificationMessage() Ignoring error because pArgs->psState is %u."), pArgs->psState);       
            return ERROR_SUCCESS;
        }

        CMTRACE(TEXT("OnRasNotificationMessage() Handling error message."));
        OnRasErrorMessage(hwndDlg, pArgs, (DWORD)lParam);
    }
    else 
    {
        // We have a RAS status update, act accordingly

        switch (wParam) 
        {
            case RASCS_Authenticate:   
                CMTRACE(TEXT("RASCS_Authenticate"));

                if (IsDialingTunnel(pArgs))  // PPTP dialing
                    pArgs->psState = PS_TunnelAuthenticating;
                else
                    pArgs->psState = PS_Authenticating;

                pArgs->dwStateStartTime = GetTickCount();
                pArgs->nLastSecondsDisplay = (UINT) -1;
    
                break;

            case RASCS_Connected: 
            {
                CMTRACE(TEXT("RASCS_Connected"));

                //
                // Post a message to ourselves to indicate that we are connected
                //

                PostMessageU(hwndDlg, WM_CONNECTED_CM,0,0);
                break;
            }

            //
            // Pause states are dealt with explicity below
            //

            case (RASCS_PAUSED + 4): // 4100 - RASCS_InvokeEapUI   
            case RASCS_Interactive:
            case RASCS_RetryAuthentication:
            case RASCS_CallbackSetByCaller:
            case RASCS_PasswordExpired:
                break;

            //
            // Callback handling states
            //
            case RASCS_PrepareForCallback:
                pArgs->fWaitingForCallback = TRUE;
                pArgs->psState = PS_Pausing;
                break;

            case RASCS_CallbackComplete:
                pArgs->fWaitingForCallback = FALSE;               
                break;

            //
            // The following status codes are not handled explicitly
            //

            case RASCS_Disconnected:
                break;

            case RASCS_SubEntryConnected:
                break;

            case RASCS_SubEntryDisconnected:
                break;

            case RASCS_OpenPort:
                break;

            case RASCS_PortOpened:
                break;

            case RASCS_ConnectDevice:
                break;

            case RASCS_DeviceConnected:
                break;

            case RASCS_AllDevicesConnected:
                break;

            case RASCS_AuthNotify:
                break;

            case RASCS_AuthRetry:
                break;

            case RASCS_AuthCallback:
                break;

            case RASCS_AuthChangePassword:
                break;

            case RASCS_AuthProject:
                break;

            case RASCS_AuthLinkSpeed:
                break;

            case RASCS_AuthAck:
                break;

            case RASCS_ReAuthenticate:
                break;

            case RASCS_Authenticated:
                break;

            case RASCS_WaitForModemReset:
                break;

            case RASCS_WaitForCallback:
                break;

            case RASCS_Projected:
                break;

            case RASCS_StartAuthentication:
                break;

            case RASCS_LogonNetwork:
                break;

            default:  
                CMTRACE(TEXT("OnRasNotificationMessage() - message defaulted"));
                break;
        }
    }
    
    if (wParam & RASCS_PAUSED)
    {
        //
        // Screen out unsupported states
        //

        switch (wParam)
        {
            case RASCS_Interactive: // for scripts -- NTRAID 378224
            case (RASCS_PAUSED + 4): // 4100 - RASCS_InvokeEapUI
            case RASCS_PasswordExpired:
            case RASCS_RetryAuthentication:
            case RASCS_CallbackSetByCaller:
                PostMessageU(hwndDlg, WM_PAUSE_RASDIAL, wParam, lParam);
                break;
                
            default:
                MYDBGASSERT(FALSE);
                return (ERROR_INTERACTIVE_MODE); // unhandled pause state
        }
    } 
    
    return ERROR_SUCCESS;
}

// timer: check the current connection manager status, update the status message
//        on the screen

void OnMainTimer(HWND hwndDlg, 
                 ArgsStruct *pArgs) 
{
    //
    // If timer ID is null, don't process messages
    // 

    if (NULL == pArgs->nTimerId)
    {
        return;
    }

    //
    // Timer is good, check StartupInfoLoad
    //

    LPTSTR pszMsg = NULL;
    DWORD dwSeconds = (GetTickCount() - pArgs->dwStateStartTime) / 1000;

    CheckStartupInfo(hwndDlg, pArgs);

    // CMTRACE1(TEXT("OnMainTimer() pArgs->psState is %u"), pArgs->psState);

    //
    // Update future splash if any
    //
    
    MapStateToFrame(pArgs);

    switch (pArgs->psState) 
    {
        case PS_Dialing:
            if (pArgs->nLastSecondsDisplay != dwSeconds) 
            {
                pszMsg = CmFmtMsg(g_hInst,
                                  IDMSG_DIALING,
                                  pArgs->aDialInfo[pArgs->nDialIdx].szDisplayablePhoneNumber,
                                  pArgs->szDeviceName,
                                  dwSeconds);
                //
                // Clear the status window
                //
                SetDlgItemTextU(hwndDlg, IDC_MAIN_STATUS_DISPLAY, TEXT("")); 
                pArgs->nLastSecondsDisplay = (UINT) dwSeconds;
            }
            break;
                 
        case PS_TunnelDialing:
            if (pArgs->nLastSecondsDisplay != dwSeconds) 
            {
                pszMsg = CmFmtMsg(g_hInst,
                                  IDMSG_TUNNELDIALING,
                                  pArgs->GetTunnelAddress(),
                                  dwSeconds);
                
                //
                // Clear the status window
                //
                SetDlgItemText(hwndDlg, IDC_MAIN_STATUS_DISPLAY, TEXT("")); 
                pArgs->nLastSecondsDisplay = (UINT) dwSeconds;
           }
           break;
                
        case PS_Pausing:

            //
            // Special case of pausing is when we're waiting for the server to call us back.
            //
            
            if (pArgs->fWaitingForCallback)
            {
                //
                // Notify the user of this fact
                //

                pszMsg = CmFmtMsg(g_hInst,
                                  IDMSG_WAITING_FOR_CALLBACK, 
                                  (GetTickCount()-pArgs->dwStateStartTime)/1000);                                                  
                //
                // Clear the status window
                //

                SetDlgItemTextU(hwndDlg, IDC_MAIN_STATUS_DISPLAY, TEXT("")); 
                pArgs->nLastSecondsDisplay = (UINT) dwSeconds;
                break;
            }

            if (GetTickCount()-pArgs->dwStateStartTime <= pArgs->nRedialDelay * 1000) 
            {
                //
                // Update the display if not timeout
                //
                if (pArgs->nLastSecondsDisplay != dwSeconds) 
                {
                    pszMsg = CmFmtMsg(g_hInst,IDMSG_PAUSING,dwSeconds);
                    pArgs->nLastSecondsDisplay = (UINT) dwSeconds;
                }
            }
            else
            {

                DWORD dwRes;

                if (pArgs->IsDirectConnect() || pArgs->hrcRasConn != NULL)
                {
                    //
                    // For the first tunnel try, CM does not hangup ppp connection
                    //
                    MYDBGASSERT(pArgs->fUseTunneling);

                    pArgs->psState = PS_TunnelDialing;
                    pArgs->dwStateStartTime = GetTickCount();
                    pArgs->nLastSecondsDisplay = (UINT) -1;

                    dwRes = DoTunnelDial(hwndDlg,pArgs);
                
                    //
                    // Update the status right away because there are times
                    // that things happen so quickly that the main status 
                    // display doesn't have a chance to display the tunnel
                    // dialing info...
                    //
                    pszMsg = CmFmtMsg(g_hInst,
                                      IDMSG_TUNNELDIALING,
                                      pArgs->GetTunnelAddress(),
                                      0);
                    
                    //
                    // Clear the status window
                    //
                    SetDlgItemTextU(hwndDlg, IDC_MAIN_STATUS_DISPLAY, TEXT("")); 
                }
                else
                {
                    dwRes = DoRasDial(hwndDlg,pArgs,pArgs->nDialIdx);
                }

                if (dwRes == ERROR_SUCCESS) 
                {
                    MapStateToFrame(pArgs);
                    pArgs->dwStateStartTime = GetTickCount();
                    pArgs->nLastSecondsDisplay = (UINT) -1;
                } 
                else 
                {
                    HangupCM(pArgs, hwndDlg);
                    UpdateError(pArgs, dwRes);
                    SetLastError(dwRes);
                }
            }
            break;

        case PS_Authenticating:
            if (pArgs->nLastSecondsDisplay != dwSeconds) 
            {
                //
                // Get the appropriate username based on whether we're 
                // tunneling and using the same credentials for dial-up.
                //

                LPTSTR pszTmpUserName;
                    
                if (pArgs->fUseTunneling && (!pArgs->fUseSameUserName))    
                {
                    pszTmpUserName = pArgs->szInetUserName;
                }
                else
                {
                    pszTmpUserName = pArgs->szUserName;
                }

                //
                // If username is still blank, use the RasDialParams as a 
                // backup. This can occur in cases such as EAP
                //

                if (TEXT('\0') == *pszTmpUserName)
                {
                    pszTmpUserName = pArgs->pRasDialParams->szUserName;          
                }                
                                    
                pszMsg = CmFmtMsg(g_hInst,
                                  IDMSG_CHECKINGPASSWORD, 
                                  pszTmpUserName, 
                                  (GetTickCount()-pArgs->dwStateStartTime)/1000);                                                  
                //
                // Clear the status window
                //

                SetDlgItemTextU(hwndDlg, IDC_MAIN_STATUS_DISPLAY, TEXT("")); 
                pArgs->nLastSecondsDisplay = (UINT) dwSeconds;
            }
            break;

        case PS_TunnelAuthenticating:
            if (pArgs->nLastSecondsDisplay != dwSeconds) 
            {
                LPTSTR pszTmpUserName = pArgs->szUserName;
                
                //
                // If username is still blank, use the RasDialParams as a 
                // backup. This can occur in cases such as EAP
                //

                if (TEXT('\0') == *pszTmpUserName)
                {
                    pszTmpUserName = pArgs->pRasDialParams->szUserName;          
                }                

                pszMsg = CmFmtMsg(g_hInst,
                                  IDMSG_CHECKINGPASSWORD,
                                  pszTmpUserName,
                                  (GetTickCount()-pArgs->dwStateStartTime)/1000);

                //
                // Clear the status window
                //
                SetDlgItemTextU(hwndDlg, IDC_MAIN_STATUS_DISPLAY, TEXT("")); 
                pArgs->nLastSecondsDisplay = (UINT) dwSeconds;
            }
            break;
    
        case PS_Online:
            
            //
            // If pArgs->fUseTunneling is TRUE, CM actually does not have the PS_Online state
            //
             
            MYDBGASSERT(!pArgs->fUseTunneling); 

        case PS_TunnelOnline:
            
            //
            // The dialog should be ended by now
            //
            
            MYDBGASSERT(!"The dialog should be ended by now"); 
            break;          

        case PS_Error:
        case PS_Interactive:
        default:
            break;
    }
    
    // If we have a status message as a result of the above, display it

    if (pszMsg) 
    {
        AppendStatusPane(hwndDlg,pszMsg);
        CmFree(pszMsg);
    }
}
                
//
// MainDlgProc: main dialog box message processing function
//

INT_PTR CALLBACK MainDlgProc(HWND hwndDlg, 
                          UINT uMsg, 
                          WPARAM wParam, 
                          LPARAM lParam) 
{
    ArgsStruct *pArgs = (ArgsStruct *) GetWindowLongU(hwndDlg,DWLP_USER);

    static const DWORD adwHelp[] = {IDC_MAIN_NOPROMPT_CHECKBOX, IDH_LOGON_AUTOCONN,
                              IDC_MAIN_NOPASSWORD_CHECKBOX, IDH_LOGON_SAVEPW,
                              IDC_MAIN_USERNAME_STATIC,IDH_LOGON_NAME,
                              IDC_MAIN_USERNAME_EDIT,IDH_LOGON_NAME,
                              IDC_MAIN_PASSWORD_STATIC,IDH_LOGON_PSWD,
                              IDC_MAIN_PASSWORD_EDIT,IDH_LOGON_PSWD,
                              IDC_MAIN_DOMAIN_STATIC, IDH_LOGON_DOMAIN,
                              IDC_MAIN_DOMAIN_EDIT, IDH_LOGON_DOMAIN,
                              IDC_MAIN_RESET_PASSWORD, IDH_LOGON_NEW,
                              IDC_MAIN_MESSAGE_DISPLAY,IDH_LOGON_SVCMSG,
                              IDC_MAIN_STATUS_LABEL,IDH_LOGON_CONNECT_STAT,
                              IDC_MAIN_STATUS_DISPLAY,IDH_LOGON_CONNECT_STAT,
                              IDOK,IDH_LOGON_CONNECT,
                              IDCANCEL,IDH_LOGON_CANCEL,
                              IDC_MAIN_PROPERTIES_BUTTON,IDH_LOGON_PROPERTIES,
                              IDC_MAIN_HELP_BUTTON,IDH_CMHELP,
                              IDC_MAIN_ACCESSPOINT_COMBO, IDH_LOGON_ACCESSPOINTS,
                              IDC_MAIN_ACCESSPOINT_STATIC, IDH_LOGON_ACCESSPOINTS,
                              IDC_OPT_CREDS_SINGLE_USER, IDH_LOGON_SAVEFORME, 
                              IDC_OPT_CREDS_ALL_USER, IDH_LOGON_SAVEFORALL,
                              0,0};

    //
    // Dialog box message processing 
    //
    switch (uMsg) 
    {
        case WM_PAINT:

            CheckStartupInfo(hwndDlg, pArgs);
            break;

        case WM_INITDIALOG:

            CM_SET_TIMING_INTERVAL("WM_INITDIALOG - Begin");

            UpdateFont(hwndDlg);

            // 
            // Extract args and perform main initialization
            //
            
            pArgs = (ArgsStruct *) lParam;
            
            if (pArgs)
            {
                pArgs->hwndMainDlg = hwndDlg;
            }

            SetWindowLongU(hwndDlg,DWLP_USER, (LONG_PTR) pArgs);
            
            OnMainInit(hwndDlg, pArgs);

            CM_SET_TIMING_INTERVAL("WM_INITDIALOG - End");

            return (FALSE);

        case WM_ENDSESSION:
            
            // 
            // Windows system is shutting down or logging off
            //

            if ((BOOL)wParam == TRUE)
            {               
                //
                // Just cancel
                //

                OnMainCancel(hwndDlg, pArgs);
            }
            return 0;

        case WM_COMMAND:
            switch (LOWORD(wParam)) 
            {
                case IDOK:
                    OnMainConnect(hwndDlg,pArgs);

                    //
                    // Check if there is an error, and if it's unattended dial,
                    // we just exit silently  -- byao 5/9/97
                    //

                    if ((PS_Interactive == pArgs->psState || PS_Error == pArgs->psState) &&
                        (pArgs->dwFlags & FL_UNATTENDED))
                    {
                        OnMainCancel(hwndDlg, pArgs);
                    }
                    return (TRUE);

                case IDC_MAIN_PROPERTIES_BUTTON:
                    if (ID_OK_RELAUNCH_MAIN_DLG == OnMainProperties(hwndDlg,pArgs))
                    {
                        //
                        //  We want to relaunch the logon UI with Access Points enabled or disabled depending
                        //  on the change the user made in the properties dialog.
                        //
                        EndMainDialog(hwndDlg, pArgs, ID_OK_RELAUNCH_MAIN_DLG);
                    }

                    return (TRUE);

                case IDC_MAIN_HELP_BUTTON: 
                {
                    UINT nCtrlFocus = IsWindowEnabled(GetDlgItem(hwndDlg,IDOK)) ? IDOK : IDCANCEL;
                    CmWinHelp(hwndDlg,hwndDlg,pArgs->pszHelpFile,HELP_FORCEFILE,0);               
                    MainSetDefaultButton(hwndDlg,nCtrlFocus);
                    return (TRUE);
                }

                case IDC_MAIN_NOPROMPT_CHECKBOX:
                    pArgs->fDialAutomatically = !pArgs->fDialAutomatically;  
                    if (TRUE == pArgs->fDialAutomatically)
                    {
                        MYDBGASSERT(!pArgs->fHideDialAutomatically);

                        //
                        // Display message explaining Dial Automatically
                        //

                        LPTSTR pszTmp = pArgs->piniService->GPPS(c_pszCmSection, 
                                                                 c_pszCmEntryDialAutoMessage);
                        if (pszTmp && *pszTmp)
                        {
                            MessageBoxEx(hwndDlg, 
                                         pszTmp, 
                                         pArgs->szServiceName,
                                         MB_OK|MB_ICONWARNING, 
                                         LANG_USER_DEFAULT);
                        }

                        CmFree(pszTmp);
                    }
                    break;

                case IDC_MAIN_NOPASSWORD_CHECKBOX:
                    pArgs->fRememberMainPassword = !(pArgs->fRememberMainPassword);
                    if (!pArgs->piniService->GPPB(c_pszCmSection,
                                                    c_pszCmEntryPwdOptional))
                    {
                        //
                        // If password is not optional, enable/disable
                        // Dial Automatically according to state of
                        // "Remember password"
                        // 

                        EnableWindow(GetDlgItem(hwndDlg, IDC_MAIN_NOPROMPT_CHECKBOX), 
                                        pArgs->fRememberMainPassword);  
                        if (FALSE == pArgs->fRememberMainPassword) 
                        {
                            //
                            // Reset Dial Automatically if user 
                            // unchecks Save Password and password 
                            // is not optional
                            //
                            CheckDlgButton(hwndDlg, IDC_MAIN_NOPROMPT_CHECKBOX, FALSE);
                            pArgs->fDialAutomatically = FALSE;

                            if (pArgs->fGlobalCredentialsSupported)
                            {
                                //
                                // Also disable the option buttons
                                //
                                EnableWindow(GetDlgItem(hwndDlg, IDC_OPT_CREDS_SINGLE_USER), FALSE);
                                EnableWindow(GetDlgItem(hwndDlg, IDC_OPT_CREDS_ALL_USER), FALSE);
                            }

                            //
                            // Since we aren't remembering the main password
                            // see if we need to not remember Inet passwords
                            //
                            if (pArgs->fUseSameUserName)
                            {
                                pArgs->fRememberInetPassword = FALSE;
                                CmWipePassword(pArgs->szInetPassword); 
                            }

                            //
                            // If the password edit hasn't been edited by the user, then we
                            // mostly likely have 16 *'s which doesn't help the user when
                            // they try to connect. Thus we need to clear the edit box
                            //
                            HWND hwndPassword = GetDlgItem(hwndDlg, IDC_MAIN_PASSWORD_EDIT);
                            if (hwndPassword)
                            {
                                pArgs->fIgnoreChangeNotification = TRUE;
                                BOOL fPWFieldModified = (BOOL) SendMessageU(hwndPassword, EM_GETMODIFY, 0L, 0L); 
                                if (FALSE == fPWFieldModified)
                                {
                                    CmWipePassword(pArgs->szPassword);
                                    SetDlgItemTextU(hwndDlg, IDC_MAIN_PASSWORD_EDIT, TEXT(""));
                                }

                                pArgs->fIgnoreChangeNotification = FALSE;
                            }
                        }
                        else
                        {
                            // 
                            // Save Password option is Enabled
                            //
                            if (pArgs->fGlobalCredentialsSupported)
                            {
                                //
                                // Also enable the option buttons
                                //
                                EnableWindow(GetDlgItem(hwndDlg, IDC_OPT_CREDS_SINGLE_USER), TRUE);
                                EnableWindow(GetDlgItem(hwndDlg, IDC_OPT_CREDS_ALL_USER), TRUE);
                            }

                            HWND hwndPassword = GetDlgItem(hwndDlg, IDC_MAIN_PASSWORD_EDIT);
                            if (hwndPassword)
                            {
                                BOOL fPWFieldModified = (BOOL) SendMessageU(hwndPassword, EM_GETMODIFY, 0L, 0L); 

                                if (CM_CREDS_GLOBAL == pArgs->dwCurrentCredentialType)
                                {
                                    //
                                    // Try to reload current creds now that the user has enabled the save
                                    // password option, unless the password field has been edited
                                    //
                                    CheckDlgButton(hwndDlg, IDC_OPT_CREDS_ALL_USER, BST_CHECKED);
                                    CheckDlgButton(hwndDlg, IDC_OPT_CREDS_SINGLE_USER, BST_UNCHECKED);

                                    if (FALSE == fPWFieldModified)
                                    {
                                        //
                                        // Set the 3rd param to TRUE in order to bypass the check  
                                        // that it's called when we are in the local credential mode.
                                        //
                                    
                                        SwitchToGlobalCreds(pArgs, hwndDlg, TRUE);
                                    }
                                }
                                else
                                {
                                    if (pArgs->fGlobalCredentialsSupported)
                                    {
                                        CheckDlgButton(hwndDlg, IDC_OPT_CREDS_ALL_USER, BST_UNCHECKED);
                                        CheckDlgButton(hwndDlg, IDC_OPT_CREDS_SINGLE_USER, BST_CHECKED);
                                    }
                                
                                    if (FALSE == fPWFieldModified)
                                    {
                                        //
                                        // Set the 3rd param to TRUE in order to bypass the check  
                                        // that it's called when we are in the global credential mode.
                                        //
                                    
                                        SwitchToLocalCreds(pArgs, hwndDlg, TRUE);
                                    }
                                }
                            }
                        }
                    }
                    break;
                
                case IDC_OPT_CREDS_SINGLE_USER:
                {
                    //
                    // FALSE - allows the function to only execute if we are currently using
                    // the global credential store and the user now wants to switch.
                    //
                    SwitchToLocalCreds(pArgs, hwndDlg, FALSE);
                    break;
                }

                case IDC_OPT_CREDS_ALL_USER:
                {
                    //
                    // FALSE - allows the function to only execute if we are currently using
                    // the local credential store and the user now wants to switch.
                    //
                    SwitchToGlobalCreds(pArgs, hwndDlg, FALSE);
                    break;
                }

                case IDC_MAIN_RESET_PASSWORD:
                    OnResetPassword(hwndDlg, pArgs);
                    break;

                case IDC_MAIN_CUSTOM:
                    OnCustom(hwndDlg, pArgs);
                    break;

                case IDCANCEL:
                    OnMainCancel(hwndDlg,pArgs);
                    return (TRUE);

                case IDC_MAIN_PASSWORD_EDIT:
                case IDC_MAIN_USERNAME_EDIT:
                case IDC_MAIN_DOMAIN_EDIT:
                    if ((HIWORD(wParam) == EN_CHANGE))
                    {
                        if (!pArgs->fIgnoreChangeNotification) 
                        {
                            OnMainEnChange(hwndDlg,pArgs);
                            return (TRUE);
                        }
                    }
                    break;
                case IDC_MAIN_ACCESSPOINT_COMBO:
                    if (CBN_SELENDOK == HIWORD(wParam))
                    {
                        if (ChangedAccessPoint(pArgs, hwndDlg, IDC_MAIN_ACCESSPOINT_COMBO))
                        {
                            UINT nCtrlFocus;

                            CheckConnect(hwndDlg,pArgs,&nCtrlFocus);
                            MainSetDefaultButton(hwndDlg,nCtrlFocus);
                        }
                    }
                default:
                    break;
            }
            break;

        case WM_HELP:
            CmWinHelp((HWND) (((LPHELPINFO) lParam)->hItemHandle),
                    (HWND) (((LPHELPINFO) lParam)->hItemHandle),
                     pArgs->pszHelpFile,
                     HELP_WM_HELP,
                     (ULONG_PTR) (LPSTR) adwHelp);
            return (TRUE);

        case WM_CONTEXTMENU:
            {
                POINT   pt = {LOWORD(lParam), HIWORD(lParam)};
                HWND    hwndCtrl;

                ScreenToClient(hwndDlg, &pt);
                hwndCtrl = ChildWindowFromPoint(hwndDlg, pt);
                if (!hwndCtrl || HaveContextHelp(hwndDlg, hwndCtrl))
                {
                    CmWinHelp((HWND) wParam,
                             hwndCtrl,
                             pArgs->pszHelpFile,
                             HELP_CONTEXTMENU,
                             (ULONG_PTR)adwHelp);
                }
                return (TRUE);
            }

        case WM_SIZE:
            //
            // Dynamicly Enable/Disable system menu
            //
            {
                HMENU hMenu = GetSystemMenu(hwndDlg, FALSE);
                MYDBGASSERT(hMenu);

                //
                // if the dlg is minimized, then disable the minimized menu
                //
                if (wParam == SIZE_MINIMIZED)
                {
                    EnableMenuItem(hMenu, SC_MINIMIZE, MF_BYCOMMAND | MF_GRAYED);
                    EnableMenuItem(hMenu, SC_RESTORE, MF_BYCOMMAND | MF_ENABLED);
                }
                else if (wParam != SIZE_MAXHIDE && wParam != SIZE_MAXSHOW)
                {
                    EnableMenuItem(hMenu, SC_MINIMIZE, MF_BYCOMMAND | MF_ENABLED);
                    EnableMenuItem(hMenu, SC_RESTORE, MF_BYCOMMAND | MF_GRAYED);
                }
            }
            break;

        case WM_TIMER:

            //
            // Ignore the timer, if a (pre)connect action is running
            //
            
            if (!pArgs->fIgnoreTimerRasMsg)
            {
                OnMainTimer(hwndDlg,pArgs);
            }

            break;
        
        case WM_PALETTEISCHANGING:
            CMTRACE2(TEXT("MainDlgProc() got WM_PALETTEISCHANGING message, wParam=0x%x, hwndDlg=0x%x."), 
                wParam, hwndDlg);

            break;

        case WM_PALETTECHANGED: 
        {       
            //
            // If its not our window that changed the palette, and we have a bitmap
            //

            if (IsWindowVisible(hwndDlg) && (wParam != (WPARAM) hwndDlg) && pArgs->BmpData.hDIBitmap)
            {
                //
                // Handle the palette change.
                //
                // Note: We used to pass a flag indicating whether another 
                // bitmap was being displayed, but given that we select the 
                // paletted as a background app. this is no longer needed
                //
                
                CMTRACE2(TEXT("MainDlgProc() handling WM_PALETTECHANGED message, wParam=0x%x, hwndDlg=0x%x."),
                    wParam, hwndDlg);

                PaletteChanged(&pArgs->BmpData, hwndDlg, IDC_MAIN_BITMAP); 
            }
            
            return TRUE;
        }

        case WM_QUERYNEWPALETTE:
            
            if (IsWindowVisible(hwndDlg))
            {
                CMTRACE2(TEXT("MainDlgProc() handling WM_QUERYNEWPALETTE message, wParam=0x%x, hwndDlg=0x%x."), 
                    wParam, hwndDlg);

                QueryNewPalette(&pArgs->BmpData, hwndDlg, IDC_MAIN_BITMAP);
            }
            return TRUE;

        case WM_LOADSTARTUPINFO:
            OnMainLoadStartupInfo(hwndDlg, pArgs);
            break;

        case WM_HANGUP_CM:
            MYDBGASSERT(OS_W9X);
            HangupCM(pArgs, hwndDlg, FALSE, (BOOL)wParam);
            break;

        case WM_CONNECTED_CM:
            OnConnectedCM(hwndDlg, pArgs);
            break;

        case WM_PAUSE_RASDIAL:
            OnPauseRasDial(hwndDlg, pArgs, wParam, lParam);
            break;
                
        default:
            break;
    }                                
    
    if (pArgs && (uMsg == pArgs->uMsgId)) 
    {
        OnRasNotificationMessage(hwndDlg, pArgs, wParam, lParam);
        return (TRUE);
    }
    
    return (FALSE);
}

//+---------------------------------------------------------------------------
//
//  Function:   ProcessCleanup
//
//  Synopsis:   Helper function to encapsulate closing Watch process handles
//
//  Arguments:  pArgs - pointer to global args struct
//
//  Returns:    Nothing
//
//  History:    a-nichb - Created - 4/30/97
//
//----------------------------------------------------------------------------
void ProcessCleanup(ArgsStruct* pArgs)
{
    BOOL bRes;
    
    if (pArgs->phWatchProcesses) 
    {
        DWORD dwIdx;

        for (dwIdx=0;pArgs->phWatchProcesses[dwIdx];dwIdx++) 
        {
            bRes = CloseHandle(pArgs->phWatchProcesses[dwIdx]);
#ifdef DEBUG
            if (!bRes)
            {
                CMTRACE1(TEXT("ProcessCleanup() CloseHandle() failed, GLE=%u."), GetLastError());
            }
#endif            
        }
        CmFree(pArgs->phWatchProcesses);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   CheckProfileIntegrity
//
//  Synopsis:   Helper function to verify that we have valid profile.
//              Verifies that we have a .CMP file name and that the 
//              .CMS file exists.
//
//  Arguments:  pArgs - pointer to global args struct
//
//  Returns:    TRUE if profile is valid
//
//  History:    a-nichb - Created - 5/8/97
//              byao    - Modified - 6/3/97   Added CMS/CMP file version check
//----------------------------------------------------------------------------

BOOL CheckProfileIntegrity(ArgsStruct* pArgs)
{
    LPTSTR pszTmp = NULL;
    LPCTSTR pszCmsFile = NULL;
    DWORD dwCmsVersion, dwCmpVersion, dwCmVersion;

    int iMsgId = 0;

    //
    // Make sure that we have a profile name and a CMS that exists
    //
    
    if (!(*pArgs->piniProfile->GetFile())) 
    {
        iMsgId = IDMSG_DAMAGED_PROFILE;
        CMASSERTMSG(FALSE, TEXT("CheckProfileIntegrity() can't run without a .cmp file."));
    }

    //
    // If profile is good, check CMS
    //

    if (0 == iMsgId)
    {   
        pszCmsFile = pArgs->piniService->GetFile();

        if (!*pszCmsFile || FALSE == FileExists(pszCmsFile)) 
        {
            iMsgId = IDMSG_DAMAGED_PROFILE;
            CMASSERTMSG(FALSE, TEXT("CheckProfileIntegrity() can't run without a valid .cms file."));
        }
    }

    // 
    // Now check the CMS/CMP file version
    //

    if (0 == iMsgId)
    {
        dwCmsVersion = pArgs->piniService->GPPI(c_pszCmSectionProfileFormat, c_pszVersion);
        dwCmpVersion = pArgs->piniProfile->GPPI(c_pszCmSectionProfileFormat, c_pszVersion);


        if (dwCmsVersion != dwCmpVersion)
        {
            iMsgId = IDMSG_DAMAGED_PROFILE;
            CMASSERTMSG(FALSE, TEXT("CheckProfileIntegrity() can't run with different version numbers."));                                
        }
                
        if (0 == iMsgId)
        {
            if (dwCmsVersion > PROFILEVERSION || dwCmpVersion > PROFILEVERSION)
            {
                // 
                // CM has older version than either CMS or CMP file
                //

                iMsgId = IDMSG_WRONG_PROFILE_VERSION;
                CMASSERTMSG(FALSE, TEXT("CheckProfileIntegrity() can't run with a newer CMS/CMP file."));
            }
        }
    }
    
    //
    // Report any problems to the user
    //

    if (iMsgId)
    {
        pszTmp = CmFmtMsg(g_hInst, iMsgId);
        MessageBoxEx(NULL, pszTmp, pArgs->szServiceName, MB_OK|MB_ICONSTOP, LANG_USER_DEFAULT);//13309
        CmFree(pszTmp);

        pArgs->dwExitCode = ERROR_WRONG_INFO_SPECIFIED;
        return FALSE;
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:  GetConnectType
//
// Synopsis:  Encapsulates determination of connect type based upon tunneling,
//            etc.
//
// Arguments: ArgsStruct *pArgs - Ptr to global Args struct
//
// Returns:   Nothing
//
// History:   nickball    Created    2/9/98
//
//+----------------------------------------------------------------------------
void GetConnectType(ArgsStruct *pArgs)
{
    //
    // If tunneling is not enabled, the decision is a simple one
    // 

    if (!IsTunnelEnabled(pArgs))
    {
        //
        // Only support dial-up, if tunnel is not enabled
        //
        pArgs->SetBothConnTypeSupported(FALSE);
        pArgs->SetDirectConnect(FALSE);
    }
    else
    {
        //
        // Load connection type info for CM 1.1, default is support both
        //
        int iSupportDialup = pArgs->piniService->GPPI(c_pszCmSection, c_pszCmEntryDialup, 1);
        int iSupportDirect = pArgs->piniService->GPPI(c_pszCmSection, c_pszCmEntryDirect, 1);

        if (iSupportDialup == TRUE && iSupportDirect == TRUE)
        {
            pArgs->SetBothConnTypeSupported(TRUE);

            if (pArgs->piniBoth->GPPI(c_pszCmSection, c_pszCmEntryConnectionType, 0))
            {
                pArgs->SetDirectConnect(TRUE);
            }
            else
            {
                pArgs->SetDirectConnect(FALSE);
            }
        }
        else
        {
            pArgs->SetBothConnTypeSupported(FALSE);
            pArgs->SetDirectConnect(iSupportDirect == TRUE);
        }
    }
}

//+----------------------------------------------------------------------------
//
// Function:  _ArgsStruct::GetTypeOfConnection
//
// Synopsis:  Figures out what type of connection we are doing (dialup, 
//            double dial, or direct) and returns one of the connection define
//            values listed in icm.h.
//
// Arguments: None
//
// Returns:   DWORD  - value indicating the type of connection, see icm.h for values
//
// History:   quintinb  Created                 04/20/00
//
//+----------------------------------------------------------------------------
DWORD _ArgsStruct::GetTypeOfConnection()
{
    DWORD dwType = 0;

    if (this->IsDirectConnect())
    {
        return DIRECT_CONNECTION;
    }
    else
    {
        //        
        // Its not direct, so see if the primary phone 
        // number is for a tunneling scenario.
        //

        if (this->fUseTunneling) // Ambiguous during Pre-Init action.
        {
            return DOUBLE_DIAL_CONNECTION;
        }
        else
        {
            return DIAL_UP_CONNECTION;
        }
    }

}

//+----------------------------------------------------------------------------
//
// Function:  _ArgsStruct::GetProperty
//
// Synopsis:  get the cm property by name
//            This function is used by connect actions
//
// Arguments: const TCHAR* pszName       - name of the property
//            BOOL  *pbValidPropertyName - ptr to bool to indicate validity of property
//
// Returns:   LPTSTR  - Value of the property.  Caller should use CmFree 
//                      to free the memory
//
// History:   fengsun   Created Header          07/07/98
//            nickball  pbValidPropertyName     07/27/99
//
//+----------------------------------------------------------------------------
LPTSTR  _ArgsStruct::GetProperty(const TCHAR* pszName, BOOL *pbValidPropertyName)   
{
    *pbValidPropertyName = TRUE;

    //
    // This function could be called with in RasCustomHangup.
    // Some information of pArgs may bot be loaded
    //

    MYDBGASSERT(pszName);
    MYDBGASSERT(pszName[0]);

    if (pszName == NULL)
    {
        return NULL;
    }

    //
    // Type - Dial-up only, VPN only, double-dial
    //

    if (lstrcmpiU(pszName, TEXT("ConnectionType")) == 0)
    {
        LPTSTR pszValue = (LPTSTR)CmMalloc(64*sizeof(TCHAR));  // large enough to hold the error code
        MYDBGASSERT(pszValue);

        if (pszValue)
        {
            wsprintfU(pszValue, TEXT("%u"), this->GetTypeOfConnection());
        }

        return pszValue;
    }

    //
    //  UserPrefix
    //
    if (lstrcmpiU(pszName,TEXT("UserPrefix")) == 0)
    {
        LPTSTR pszUsernamePrefix = NULL;
        LPTSTR pszUsernameSuffix = NULL;

        //
        // Retrieve the suffix and prefix as they are a logical pair, 
        // but we only return the allocated PREFIX in this case.
        //

        CIni *piniService = GetAppropriateIniService(this, this->nDialIdx);

        GetPrefixSuffix(this, piniService, &pszUsernamePrefix, &pszUsernameSuffix);               
               
        CmFree(pszUsernameSuffix);
        delete piniService;

        return pszUsernamePrefix;
    }

    //
    // UserSuffix
    //
    if (lstrcmpiU(pszName,TEXT("UserSuffix")) == 0)     
    {
        LPTSTR pszUsernamePrefix = NULL;
        LPTSTR pszUsernameSuffix = NULL;

        //
        // Retrieve the suffix and prefix as they are a logical pair, 
        // but we only return the allocated SUFFIX in this case.
        //

        CIni *piniService = GetAppropriateIniService(this, this->nDialIdx);

        GetPrefixSuffix(this, piniService, &pszUsernamePrefix, &pszUsernameSuffix);               
               
        CmFree(pszUsernamePrefix);
        delete piniService;

        return pszUsernameSuffix;
    }

    //
    // UserName
    //
    if (lstrcmpiU(pszName,TEXT("UserName")) == 0)       
    {
        LPTSTR pszValue = NULL;

        //
        // We want to get the value by calling GetUserInfo so that we don't break 
        // existing scenarios. Otherwise for Winlogon and ICS case we'll just take the 
        // value directly out of the Args Structure.
        //
        if (CM_LOGON_TYPE_USER == this->dwWinLogonType)
        {
            GetUserInfo(this, UD_ID_USERNAME, (PVOID*)&pszValue);
        }
        else
        {
            pszValue = CmStrCpyAlloc(this->szUserName);
        }

        return pszValue;
    }

    //
    // InetUserName
    //
    if (lstrcmpiU(pszName,TEXT("InetUserName")) == 0)       
    {
        LPTSTR pszValue = NULL;

        //
        //  If we aren't doing a double dial, then the InetUserName doesn't make
        //  sense and thus should be zero.  Also if UseSameUserName is
        //  set then we want to return the UserName and skip trying to
        //  find the InetUserName
        //
        if (this->fUseTunneling && (FALSE == this->IsDirectConnect()))
        {
            if (this->piniService->GPPB(c_pszCmSection, c_pszCmEntryUseSameUserName))
            {
                //
                // We want to get the value by calling GetUserInfo so that we don't break 
                // existing scenarios. Otherwise for Winlogon and ICS case we'll just take the 
                // value directly out of the Args Structure.
                //
                if (CM_LOGON_TYPE_USER == this->dwWinLogonType)
                {
                    GetUserInfo(this, UD_ID_USERNAME, (PVOID*)&pszValue);
                }
                else
                {
                    pszValue = CmStrCpyAlloc(this->szUserName);
                }
            }
            else
            {
                //
                // We want to get the value by calling GetUserInfo so that we don't break 
                // existing scenarios. Otherwise for Winlogon and ICS case we'll just take the 
                // value directly out of the Args Structure.
                //
                if (CM_LOGON_TYPE_USER == this->dwWinLogonType)
                {
                    GetUserInfo(this, UD_ID_INET_USERNAME, (PVOID*)&pszValue);
                }
                else
                {
                    pszValue = CmStrCpyAlloc(this->szInetUserName);
                }
            }
        }
        
        return pszValue;
    }

    //
    // Domain
    //
    if (lstrcmpiU(pszName,TEXT("Domain")) == 0)       
    {
        LPTSTR pszValue = NULL;
        //
        // We want to get the value by calling GetUserInfo so that we don't break 
        // existing scenarios. Otherwise for Winlogon and ICS case we'll just take the 
        // value directly out of the Args Structure.
        //
        if (CM_LOGON_TYPE_USER == this->dwWinLogonType)
        {
            GetUserInfo(this, UD_ID_DOMAIN, (PVOID*)&pszValue);
        }
        else
        {
            pszValue = CmStrCpyAlloc(this->szDomain);
        }

        return pszValue;
    }

    //
    // Profile
    //
    if (lstrcmpiU(pszName,TEXT("Profile")) == 0)      
    {
        return CmStrCpyAlloc(this->piniProfile->GetFile());
    }

    //
    // ServiceDir
    //
    if (lstrcmpiU(pszName, TEXT("ServiceDir")) == 0)      
    {
        LPTSTR pszServiceDir = NULL;

        // start with the file name of the Service
        LPCTSTR pszService = this->piniService->GetFile();
        if (pszService)
        {
            // find out where the filename.cmp portion starts
            LPTSTR pszTmp = CmStrrchr(pszService, TEXT('\\'));

            size_t nSize = pszTmp - pszService + 1;

            // alloc enough space for the directory name (and terminating NULL)
            pszServiceDir = (LPTSTR)CmMalloc( nSize * sizeof(TCHAR));
            if (pszServiceDir)
            {
                lstrcpynU(pszServiceDir, pszService, nSize);
                //
                //  The Win32 lstrcpyN function enforces a terminating NULL,
                //  so the above works without requiring any further code.
                //
            }
        }

        return pszServiceDir;
    }

    //
    // ServiceName
    //
    if (lstrcmpiU(pszName,c_pszCmEntryServiceName) == 0)        
    {
        MYDBGASSERT(this->szServiceName[0]);
        return CmStrCpyAlloc(this->szServiceName);
    }

    //
    // DialRasPhoneBook
    //

    if (lstrcmpiU(pszName, TEXT("DialRasPhoneBook")) == 0)     
    {
        //
        // We want to return NULL if this was a direct connection
        // and we want to return the hidden ras phonebook path if
        // this was a double dial connection (tunnel over a PPP
        // connection that we dialed).
        //
        if (this->IsDirectConnect())
        {
            return NULL;
        }
        else
        {
            if (this->fUseTunneling)
            {
                return CreateRasPrivatePbk(this);
            }
            else
            {
                return CmStrCpyAlloc(this->pszRasPbk);
            }
        }
    }

    //
    // DialRasEntry
    //
    if (lstrcmpiU(pszName, TEXT("DialRasEntry")) == 0)        
    {
        if (this->IsDirectConnect())
        {
            return NULL;
        }
        else
        {
            return GetRasConnectoidName(this, this->piniService, FALSE);
        }
    }

    //
    // TunnelRasPhoneBook
    //
    if (lstrcmpiU(pszName, TEXT("TunnelRasPhoneBook")) == 0) 
    {
        //
        //  If we are not tunneling then we want to make sure that we
        //  return NULL for the tunnel entry name and the tunnel
        //  phonebook
        //
    
        if (this->fUseTunneling)
        {
            CMTRACE1(TEXT("GetProperty - TunnelRasPhoneBook is %s"), this->pszRasPbk);
            return CmStrCpyAlloc(this->pszRasPbk);
        }
        else
        {
            CMTRACE(TEXT("GetProperty - TunnelRasPhoneBook returns NULL"));
            return NULL;
        }
    }

    //
    // TunnelRasEntry
    //
    if (lstrcmpiU(pszName, TEXT("TunnelRasEntry")) == 0)        
    {
        //
        //  If we are not tunneling then we want to make sure that we
        //  return NULL for the tunnel entry name and the tunnel
        //  phonebook
        //
        if (this->fUseTunneling)
        {
            return GetRasConnectoidName(this, this->piniService, TRUE);
        }
        else
        {
            return NULL;
        }
    }

    //
    // AutoRedial, TRUE or FALSE
    ///
    if (lstrcmpiU(pszName, TEXT("AutoRedial")) == 0)        
    {
        //
        // Return TRUE for the first try.
        //
        return CmStrCpyAlloc( this->nRedialCnt != this->nMaxRedials 
            ? TEXT("1") : TEXT("0"));
    }

    if (lstrcmpiU(pszName, TEXT("LastErrorSource")) == 0)        
    {
        return CmStrCpyAlloc(this->szLastErrorSrc);
    }

    //
    // PopName, as the city name in phone-book
    //
    if (lstrcmpiU(pszName, TEXT("PopName")) == 0)        
    {
        if (this->IsDirectConnect())
        {
            //
            // Ensure no POP description on DirectConnect #324951
            //

            return NULL;
        }
        else
        {
            //
            // the szDesc is in the format of "CityName (BaudMin - BaudMax bps)" 
            // We could save the CityNme when we load the phone number from phonebook
            // But we have to change cmpbk code then.
            //
    
            LPTSTR pszDesc = CmStrCpyAlloc(this->aDialInfo[nDialIdx].szDesc);

            //
            // The city name is followed by " ("
            //
            LPTSTR pszEnd = CmStrStr(pszDesc, TEXT(" ("));

            if (pszEnd == NULL)
            {
                CmFree(pszDesc);
                return NULL;
            }

            *pszEnd = TEXT('\0');

            return pszDesc;
        }
    }

    //
    //  The current favorite
    //
    if (lstrcmpiU(pszName, TEXT("CurrentFavorite")) == 0)
    {
        return CmStrCpyAlloc(this->pszCurrentAccessPoint);
    }

    //
    //  The current tunnel server address
    //
    if (lstrcmpiU(pszName, TEXT("TunnelServerAddress")) == 0)
    {
        if (this->fUseTunneling)
        {
            return this->piniBothNonFav->GPPS(c_pszCmSection, c_pszCmEntryTunnelAddress);
        }
        else
        {
            return NULL;
        }
    }

    //
    //  The canonical number if there is one and if not then the szPhonenumber field itself.
    //
    if (lstrcmpiU(pszName, TEXT("PhoneNumberDialed")) == 0)
    {
        if (this->IsDirectConnect())
        {
            return NULL;
        }
        else
        {
            if (this->aDialInfo[nDialIdx].szCanonical[0])
            {
                return CmStrCpyAlloc(this->aDialInfo[nDialIdx].szCanonical);
            }
            else
            {
                return CmStrCpyAlloc(this->aDialInfo[nDialIdx].szPhoneNumber);            
            }
        }
    }

    //
    // ErrorCode in decimal
    //
    if (lstrcmpiU(pszName, TEXT("ErrorCode")) == 0)       
    {
        LPTSTR pszValue = (LPTSTR)CmMalloc(64*sizeof(TCHAR));  // large enough to hold the error code
        MYDBGASSERT(pszValue);

        if (pszValue)
        {
            wsprintfU(pszValue, TEXT("%d"), this->dwExitCode);
        }

        return pszValue;
    }

    CMTRACE1(TEXT("%%%s%% not a macro, may be environment variable"), pszName);
    *pbValidPropertyName = FALSE;

    return NULL;
}

//+----------------------------------------------------------------------------
//
// Function:  GetMainDlgTemplate
//
// Synopsis:  Encapsulates determining which template is to be used
//            for the main dialog.
//
// Arguments: ArgsStruct *pArgs - Ptr to global Args struct
//
// Returns:   UINT - Dlg template ID.
//
// History:   nickball    Created     9/25/98
//            tomkel      01/30/2001  Added support for global credentials UI   
//                                    by using pArgs->fGlobalCredentialsSupported
//
//+----------------------------------------------------------------------------
UINT GetMainDlgTemplate(ArgsStruct *pArgs)
{
    MYDBGASSERT(pArgs);
    
    if (NULL == pArgs)
    {
        MYDBGASSERT(pArgs);
        return 0;
    }

    UINT uiNewMainDlgID = 0;
    DWORD dwNewTemplateMask = 0;
    UINT i = 0;

    //
    // Currently there are 24 dialogs used in this function. If you add more dialogs
    // make sure to increase the size of the array and the loop. The dialog templates
    // aren't in any particular order, since we loop through all of them
    // comparing the masks until we find the correct one.
    //
    DWORD rdwTemplateIDs[24][2] = { 
            {CMTM_FAVS | CMTM_U_P_D | CMTM_GCOPT,           IDD_MAIN_ALL_USERDATA_FAV_GCOPT},
            {CMTM_FAVS | CMTM_U_P_D,                        IDD_MAIN_ALL_USERDATA_FAV},
            {CMTM_FAVS | CMTM_UID,                          IDD_MAIN_UID_ONLY_FAV},
            {CMTM_FAVS | CMTM_PWD | CMTM_GCOPT,             IDD_MAIN_PWD_ONLY_FAV_GCOPT},
            {CMTM_FAVS | CMTM_PWD,                          IDD_MAIN_PWD_ONLY_FAV},
            {CMTM_FAVS | CMTM_DMN,                          IDD_MAIN_DMN_ONLY_FAV},
            {CMTM_FAVS | CMTM_UID_AND_PWD | CMTM_GCOPT,     IDD_MAIN_UID_AND_PWD_FAV_GCOPT},
            {CMTM_FAVS | CMTM_UID_AND_PWD,                  IDD_MAIN_UID_AND_PWD_FAV},
            {CMTM_FAVS | CMTM_UID_AND_DMN,                  IDD_MAIN_UID_AND_DMN_FAV},
            {CMTM_FAVS | CMTM_PWD_AND_DMN | CMTM_GCOPT,     IDD_MAIN_PWD_AND_DMN_FAV_GCOPT},
            {CMTM_FAVS | CMTM_PWD_AND_DMN,                  IDD_MAIN_PWD_AND_DMN_FAV},
            {CMTM_FAVS,                                     IDD_MAIN_NO_USERDATA_FAV},
            {CMTM_U_P_D | CMTM_GCOPT,                       IDD_MAIN_ALL_USERDATA_GCOPT},
            {CMTM_U_P_D,                                    IDD_MAIN_ALL_USERDATA},
            {CMTM_UID,                                      IDD_MAIN_UID_ONLY},
            {CMTM_PWD | CMTM_GCOPT,                         IDD_MAIN_PWD_ONLY_GCOPT},
            {CMTM_PWD,                                      IDD_MAIN_PWD_ONLY},
            {CMTM_DMN,                                      IDD_MAIN_DMN_ONLY},
            {CMTM_UID_AND_PWD | CMTM_GCOPT,                 IDD_MAIN_UID_AND_PWD_GCOPT},
            {CMTM_UID_AND_PWD,                              IDD_MAIN_UID_AND_PWD},
            {CMTM_UID_AND_DMN,                              IDD_MAIN_UID_AND_DMN},
            {CMTM_PWD_AND_DMN | CMTM_GCOPT,                 IDD_MAIN_PWD_AND_DMN_GCOPT},
            {CMTM_PWD_AND_DMN,                              IDD_MAIN_PWD_AND_DMN},
            {0,                                             IDD_MAIN_NO_USERDATA}};

    //
    // Set the mask according to the pArgs flags for each value.
    //
    if (!pArgs->fHideUserName)
    {
        dwNewTemplateMask |= CMTM_UID;
    }

    //
    // If the password edit is not displayed, there is no need to 
    // check for the global creds flag since there are no such dialogs
    //
    if (!pArgs->fHidePassword)
    {
        dwNewTemplateMask |= CMTM_PWD;

        // 
        // Since we show the password field, lets check if we should display 
        // the global creds option as well.
        // 
        if (pArgs->fGlobalCredentialsSupported)
        {
            dwNewTemplateMask |= CMTM_GCOPT;
        }
    }

    if (!pArgs->fHideDomain)
    {
        dwNewTemplateMask |= CMTM_DMN;
    }

    if (pArgs->fAccessPointsEnabled)
    {
        dwNewTemplateMask |= CMTM_FAVS;
    }

    //
    // Now find the corresponding template id
    //
    for (i = 0; i < 24; i++)
    {
        if (rdwTemplateIDs[i][0] == dwNewTemplateMask)
        {
            uiNewMainDlgID = rdwTemplateIDs[i][1];
            break;
        }
    }

    if (0 == uiNewMainDlgID)
    {
        MYDBGASSERT(FALSE);
        uiNewMainDlgID = IDD_MAIN_NO_USERDATA;
    }

    return uiNewMainDlgID;
}

//+----------------------------------------------------------------------------
//
// Function:  Connect
//
// Synopsis:  The main dialing (connect path) replaces the winmain from the 
//            original CMMGR32.EXE
//
// Arguments: HWND hwndParent - window handle of parent
//            LPCTSTR lpszEntry - Ptr to the name of the connection entry
//            LPTSTR lpszPhonebook - Ptr to the name of the phonebook
//            LPRASDIALDLG lpRasDialDlg - RasDialDlg data - ignored
//            LPRASENTRYDLG lpRasEntryDlg - RasEntryDlg data - ignored
//            LPCMDIALINFO lpCmInfo - CM specific dial info such as flags
//            DWORD dwFlags - Flags for AllUser, SingleUser, EAP, etc.
//            PVOID pvLogonBlob - Ptr to blob passed by RAS at WinLogon on W2K
//
// Returns:   Nothing
//
// Note:      RasDialDlg->hwndOwner and RasDialDlg->hwndOwner are honored, but they
//            are currently passed in via the hwndParent parameter as appropriate by
//            the caller, CmCustomDialDlg.
//
// History:   nickball    Created                                   02/06/98
//            nickball    hwndParent                                11/10/98
//            nickball    Passed down dwFlags instead of BOOL       07/13/99
//
//+----------------------------------------------------------------------------
HRESULT Connect(HWND hwndParent,
    LPCTSTR pszEntry,
    LPTSTR lpszPhonebook,
    LPRASDIALDLG, // lpRasDialDlg,
    LPRASENTRYDLG, // lpRasEntryDlg,
    LPCMDIALINFO lpCmInfo,
    DWORD dwFlags,
    PVOID pvLogonBlob)
{
    MYDBGASSERT(pszEntry);
    MYDBGASSERT(pszEntry[0]);
    MYDBGASSERT(lpCmInfo);

    CMTRACE(TEXT("Connect()"));

    if (NULL == pszEntry || NULL == lpCmInfo)
    {
        return E_POINTER;
    }

    if (0 == pszEntry[0])
    {
        return E_INVALIDARG;   
    }

    HRESULT hrRes = S_OK;
   
    //
    // Allocate our args struct from the heap. Not on our stack.
    //
    
    ArgsStruct* pArgs = (ArgsStruct*) CmMalloc(sizeof(ArgsStruct));

    if (NULL == pArgs)
    {
        hrRes = HRESULT_FROM_WIN32(ERROR_ALLOCATING_MEMORY);
        goto done;
    }
    
    //
    // Clear and init global args struct
    //
    
    hrRes = InitArgsForConnect(pArgs, lpszPhonebook, lpCmInfo, (dwFlags & RCD_AllUsers));

    if (FAILED(hrRes))
    {
        goto done;
    }

    //
    // Setup the connection table
    //

    hrRes = CreateConnTable(pArgs);

    if (FAILED(hrRes))
    {
        goto done;
    }
    

    //
    // Initialize the profile
    //

    hrRes = InitProfile(pArgs, pszEntry);

    if (FAILED(hrRes))
    {
        goto done;
    }

    //
    // Make sure we have a .cmp name and that the specified .cms exists
    //

    if (FALSE == CheckProfileIntegrity(pArgs))
    {
        // CheckProfileIntegrity() will set pArgs->dwExitCode accordingly
        goto done;
    }

     //
     // Initialize logging
     //
 
     (VOID) InitLogging(pArgs, pszEntry, TRUE); // TRUE => write a banner;
     // ignore return value
    
    //
    // Pick up any pre-existing credentials (eg. WinLogon, Reconnect)
    //

    hrRes = InitCredentials(pArgs, lpCmInfo, dwFlags, pvLogonBlob);
    if (S_OK != hrRes)
    {
        goto done;
    }

    //
    // Now that credential support and existance flags are initialized we need
    // to initialize the read/write flags in order to support global user
    // info. This can only be called only after InitCredentials
    //
    SetIniObjectReadWriteFlags(pArgs);

    //
    // Calling InitConnect depends on having the Ini objects read/write flags initialized correctly  
    // thus this calls needs to happen after SetIniObjectReadWriteFlags. This is important in case
    // of ICS where it needs to be able to read data correctly from the ICSData reg key or default to
    // the .cms/.cmp files.
    //
    if (!InitConnect(pArgs))
    {
        goto done;
    }

    //
    // Register Classes
    // 

    RegisterBitmapClass(g_hInst);
    RegisterWindowClass(g_hInst);

    //
    // Get the helpfile path
    //

    LoadHelpFileInfo(pArgs);

    //
    // If we are in FL_PROPERTIES  mode, just get the settings from the 
    // profile. Otherwise go ahead and launch the MainDlgProc
    //
    
    if (pArgs->dwFlags & FL_PROPERTIES) 
    {
        if (*pArgs->piniProfile->GetFile() && SetupInternalInfo(pArgs, NULL)) 
        {
            OnMainProperties(hwndParent, pArgs);
        }
    } 
    else 
    {
        //
        // Need to call OleInitialize()? See if we need FutureSplash.  We don't display
        // animations at WinLogon because of the security implications.
        //
    
        if (pArgs->piniService->GPPB(c_pszCmSection, c_pszCmEntryAnimatedLogo) && !IsLogonAsSystem())
        {
            if (!pArgs->olsOle32Link.hInstOle32)
            {    
                if (LinkToOle32(&pArgs->olsOle32Link, "OLE32"))
                {
                    if (pArgs->olsOle32Link.pfnOleInitialize(NULL) != S_OK)
                    {
                        //
                        // Note: it's not fatal to fail OleInitialize().  
                        // We will just load the normal bitmap then.
                        //
                        CMTRACE(TEXT("Connect() OleInitialize failed"));
                    }
                }
                else
                {
                    CMTRACE(TEXT("Connect() LinkToOle32 failed"));
                }
            }
        }       
        
        //
        // Launch main dialog 
        //

        INT_PTR iMainDlgReturn = 0;
        
        do
        {
            iMainDlgReturn = DialogBoxParamU(g_hInst, 
                                             MAKEINTRESOURCE(GetMainDlgTemplate(pArgs)), 
                                             hwndParent,
                                             (DLGPROC) MainDlgProc, 
                                             (LPARAM) pArgs);

            if (0 != pArgs->dwSCardErr)
            {
                //
                //  User entered a bad smartcard PIN.  We exit immediately to avoid
                //  locking up the smartcard with multiple incorrect retries.
                //
                MYDBGASSERT(BAD_SCARD_PIN(pArgs->dwSCardErr));
                hrRes = pArgs->dwSCardErr;
                goto done;
            }

        } while (ID_OK_RELAUNCH_MAIN_DLG == iMainDlgReturn);
    }

    
done:   
    
    //
    // Now that we are done, we should clear up all the messes :)
    //

    CleanupConnect(pArgs);

    //
    // Un-initialize logging
    //
 
    (VOID) pArgs->Log.DeInit();
    // ignore return value

    //
    // If hRes isn't already set, use the exitcode value
    //

    if (S_OK == hrRes)
    {
        hrRes = HRESULT_FROM_WIN32(pArgs->dwExitCode);
    }
    
    //
    // Release pArgs, and exit completely
    //

    CmFree(pArgs);

    return hrRes;
}

//
// Define funtion prototypes for EAP functions
// that are implemented in the actual EAP dll.
//

typedef DWORD (WINAPI* pfnRasEapGetIdentity)(
    DWORD,
    HWND,
    DWORD,
    const WCHAR*,
    const WCHAR*,
    PBYTE,
    DWORD,
    PBYTE,
    DWORD,
    PBYTE*,
    DWORD*,
    WCHAR**
);

typedef DWORD (WINAPI* pfnRasEapFreeMemory)(
    PBYTE
);


//+----------------------------------------------------------------------------
//
// Function:  CmEapGetIdentity
//
// Synopsis:  Given EapUserData, looks up and calls RasEapGetIdentity for
//            the current EAP. Designed to handle the WinLogon case when we
//            want to use the EapUserData passed to us, rather then letting
//            RasGetEapUserIdentity look it up. Because it is only used in 
//            this case we pass RAS_EAP_FLAG_LOGON this enables other EAPs
//            to disregard the data if necessary. 
// 
// Arguments: ArgsStruct *pArgs - Ptr to global args struct
//            LPTSTR lpszPhonebook - Ptr to the RAS phonebook
//            LPBYTE pbEapAuthData - Eap auth data blob 
//            DWORD dwEapAuthDataSize - size of the Eap auth data blob 
//            DWORD dwCustomAuthKey - The EAP identifier
//            LPRASEAPUSERIDENTITY* ppRasEapUserIdentity - Identity data
//
// Returns:   Error Code
//
// History:   nickball    Created                   07/16/99
//            nickball    ppRasEapUserIdentity      07/30/99
//
//+----------------------------------------------------------------------------
static DWORD CmEapGetIdentity(ArgsStruct *pArgs, 
    LPTSTR pszRasPbk, 
    LPBYTE pbEapAuthData, 
    DWORD dwEapAuthDataSize,
    DWORD dwCustomAuthKey,
    LPRASEAPUSERIDENTITY* ppRasEapUserIdentity)
{
    MYDBGASSERT(OS_NT5);
    MYDBGASSERT(pArgs);
    MYDBGASSERT(ppRasEapUserIdentity);
    MYDBGASSERT(pArgs->lpEapLogonInfo);
    
    if (NULL == pArgs || NULL == pArgs->lpEapLogonInfo || NULL == ppRasEapUserIdentity)
    {
        return ERROR_INVALID_PARAMETER;
    }
  
    DWORD dwErr         = ERROR_SUCCESS;
    DWORD dwTmp         = 0;
    DWORD dwSize        = 0;
    DWORD cbDataOut     = 0;
    LPBYTE pbDataOut    = NULL;
    WCHAR* pwszIdentity = NULL;
    HKEY hKeyEap        = NULL;
    HINSTANCE hInst     = NULL;
    LPWSTR pszwPath     = NULL;

    pfnRasEapFreeMemory pfnEapFreeMemory = NULL;
    pfnRasEapGetIdentity pfnEapGetIdentity = NULL;

    //
    // First we have to locate the Identity DLL for our EAP. Step one is to
    // build the reg key name using the base path and EAP number.
    // 

    WCHAR szwTmp[MAX_PATH];
    wsprintfU(szwTmp, TEXT("%s\\%u"), c_pszRasEapRegistryLocation, dwCustomAuthKey);
    
    //
    // Now we can open the EAP key
    // 

    dwErr = RegOpenKeyExU(HKEY_LOCAL_MACHINE,
                          szwTmp,
                          0,
                          KEY_QUERY_VALUE ,
                          &hKeyEap);
    
    CMTRACE2(TEXT("CmEapGetIdentity - Opening %s returns %u"), szwTmp, dwErr);
    
    if (ERROR_SUCCESS != dwErr)
    {
        return dwErr;
    }

    //
    // See if the EAP supports RasEapGetIdentity
    //

    dwSize = sizeof(dwSize);

    dwErr = RegQueryValueExU(hKeyEap,
                             c_pszInvokeUsernameDialog,
                             NULL,
                             NULL,
                             (BYTE*)&dwTmp,
                             &dwSize);

    CMTRACE2(TEXT("CmEapGetIdentity - Opening %s returns %u"), c_pszInvokeUsernameDialog, dwErr);

    if ((dwErr) || (0 != dwTmp))
    {
        dwErr = ERROR_INVALID_FUNCTION_FOR_ENTRY;
        goto CmEapGetIdentityExit;
    }

    //
    // Next we need to retrieve the path of the EAP's identity DLL
    //
        
    dwSize = sizeof(szwTmp);

    dwErr = RegQueryValueExU(hKeyEap, c_pszRasEapValueNameIdentity, NULL, 
                             NULL, (LPBYTE) szwTmp, &dwSize);

    CMTRACE2(TEXT("CmEapGetIdentity - Opening %s returns %u"), c_pszRasEapValueNameIdentity, dwErr);

    if (ERROR_SUCCESS != dwErr)
    {
        return dwErr;
    }

    pszwPath = (LPWSTR) CmMalloc(MAX_PATH * sizeof(TCHAR));

    if (NULL == pszwPath)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto CmEapGetIdentityExit;   
    }
    
    ExpandEnvironmentStringsU(szwTmp, pszwPath, MAX_PATH);   

    //
    // Finally we have the path to the identity DLL. Now we can load the DLL 
    // and get the address of the RasEapGetIdentity and RasEapFreeMemory funcs.
    //

    CMTRACE1(TEXT("CmEapGetIdentity - Loading EAP Identity DLL %s"), pszwPath);

    hInst = LoadLibraryExU(pszwPath, NULL, 0);

    if (NULL == hInst)
    {
        dwErr = GetLastError();
        goto CmEapGetIdentityExit;
    }

    pfnEapFreeMemory = (pfnRasEapFreeMemory) GetProcAddress(hInst, "RasEapFreeMemory");
    pfnEapGetIdentity = (pfnRasEapGetIdentity) GetProcAddress(hInst, "RasEapGetIdentity"); 

    if (pfnEapGetIdentity && pfnEapFreeMemory)
    {
        dwErr = pfnEapGetIdentity(dwCustomAuthKey,
                                  pArgs->hwndMainDlg,
                                  RAS_EAP_FLAG_LOGON | RAS_EAP_FLAG_PREVIEW,
                                  pszRasPbk,
                                  pArgs->pRasDialParams->szEntryName,
                                  pbEapAuthData,
                                  dwEapAuthDataSize,
                                  (LPBYTE) pArgs->lpEapLogonInfo,
                                  pArgs->lpEapLogonInfo->dwSize,
                                  &pbDataOut,
                                  &cbDataOut,
                                  &pwszIdentity);
        
        CMTRACE3(TEXT("CmEapGetIdentity - RasEapGetIdentity returns %u, cbDataOut is %u, pwszIdentity is %s"), dwErr, cbDataOut, pwszIdentity);

        if (ERROR_SUCCESS == dwErr)
        {
            //
            // If data was returned, use it. Otherwise, use the
            // blob that was given to us by RAS at WinLogon.
            //

            if (cbDataOut)
            {
                dwSize =  cbDataOut;
            }
            else
            {
                CMTRACE(TEXT("CmEapGetIdentity - there was no pbDataOut from the EAP, using lpEapLogonInfo"));
                
                CMTRACE1(TEXT("CmEapGetIdentity - pArgs->lpEapLogonInfo->dwSize is %u"), pArgs->lpEapLogonInfo->dwSize);
                CMTRACE1(TEXT("CmEapGetIdentity - dwLogonInfoSize is %u"), pArgs->lpEapLogonInfo->dwLogonInfoSize);
                CMTRACE1(TEXT("CmEapGetIdentity - dwOffsetLogonInfo is %u"), pArgs->lpEapLogonInfo->dwOffsetLogonInfo);
                CMTRACE1(TEXT("CmEapGetIdentity - dwPINInfoSize is %u"), pArgs->lpEapLogonInfo->dwPINInfoSize);
                CMTRACE1(TEXT("CmEapGetIdentity - dwOffsetPINInfo is %u"), pArgs->lpEapLogonInfo->dwOffsetPINInfo);

                dwSize = pArgs->lpEapLogonInfo->dwSize;
                pbDataOut = (LPBYTE) pArgs->lpEapLogonInfo; // Note: pbDataOut is not our memory
            }
           
            //
            // Allocate the structure.
            //

            *ppRasEapUserIdentity = (LPRASEAPUSERIDENTITY) CmMalloc((sizeof(RASEAPUSERIDENTITY) - 1) + dwSize);

            if (NULL == *ppRasEapUserIdentity)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                goto CmEapGetIdentityExit;
            }

            if (pbDataOut) // no crashy
            {
                CMTRACE1(TEXT("CmEapGetIdentity - filling *ppRasEapUserIdentity with pbDataOut of size %u"), dwSize);

                lstrcpyn((*ppRasEapUserIdentity)->szUserName, pwszIdentity, UNLEN);
                (*ppRasEapUserIdentity)->szUserName[UNLEN] = 0;

                (*ppRasEapUserIdentity)->dwSizeofEapInfo = dwSize;
            
                CopyMemory((*ppRasEapUserIdentity)->pbEapInfo, pbDataOut, dwSize);                              
            
                CMTRACE1(TEXT("CmEapGetIdentity - *ppRasEapUserIdentity filled with pbDataOut of size %u"), dwSize);
            }
            else
            {
                dwErr = ERROR_INVALID_DATA;
                MYDBGASSERT(FALSE);
                goto CmEapGetIdentityExit;
            }
        }   
    }
    else
    {
        dwErr = GetLastError();
    }

CmEapGetIdentityExit:

    //
    // Cleanup our temporary buffers
    //

    if (NULL != pfnEapFreeMemory)
    {
        //
        // If cbDataOut is 0 then pbDataOut points at 
        // EapLogonInfo, which is not ours to free.
        // 

        if (cbDataOut && (NULL != pbDataOut)) 
        {
            pfnEapFreeMemory(pbDataOut);
        }

        if (NULL != pwszIdentity)
        {
            pfnEapFreeMemory((BYTE*)pwszIdentity);
        }
    }

    if (NULL != hKeyEap)
    {
        RegCloseKey(hKeyEap);
    }

    if (hInst)
    {
        FreeLibrary(hInst);
    }

    CmFree(pszwPath);

    CMTRACE1(TEXT("CmEapGetIdentity - returns %u"), dwErr);

    return dwErr;
}

//+----------------------------------------------------------------------------
//
// Function:  GetEapUserId
//
// Synopsis:  Helper func to deal with the details of calling out to RAS for EAP
//            credentials.
//
// Arguments: ArgsStruct *pArgs - Ptr to global args struct
//            HWND hwndDlg - Window handle of dialog to own any UI
//            LPTSTR lpszPhonebook - Ptr to the RAS phonebook
//            LPBYTE pbEapAuthData - Eap auth data blob 
//            DWORD dwEapAuthDataSize - Size of the Eap auth data blob.
//            DWORD dwCustomAuthKey - The EAP identifier
//            LPRASEAPUSERIDENTITY* ppRasEapUserIdentity - Ptr to RAS EAP identity
//            struct to be allocated on our behalf.                       
//
// Returns:   Error Code
//
// History:   nickball    Created                   05/22/99
//            nickball    ppRasEapUserIdentity      07/30/99
//
//+----------------------------------------------------------------------------
static DWORD GetEapUserId(ArgsStruct *pArgs, 
    HWND hwndDlg, 
    LPTSTR pszRasPbk, 
    LPBYTE pbEapAuthData, 
    DWORD dwEapAuthDataSize, 
    DWORD dwCustomAuthKey,
    LPRASEAPUSERIDENTITY* ppRasEapUserIdentity)
{
    MYDBGASSERT(OS_NT5);
    MYDBGASSERT(pArgs);
    MYDBGASSERT(ppRasEapUserIdentity);
    MYDBGASSERT(0 == *ppRasEapUserIdentity); // should always be NULL

    DWORD dwRet = ERROR_SUCCESS;

    if (NULL == pArgs ||         
        NULL == pArgs->rlsRasLink.pfnGetEapUserIdentity ||
        NULL == ppRasEapUserIdentity)
    {
        return ERROR_INVALID_PARAMETER;
    }

    *ppRasEapUserIdentity = 0;

    //
    // If we have data from WinLogon, then use our own version of 
    // GetEapIdentity. Under the covers, RasGetEapUserIdentity calls
    // GetEapUserData (which potentially prompts the user) and then 
    // GetEapIdentity. Because we already have the equivalent 
    // (from WinLogon) of the data retrieved by GetEapUserData, 
    // we can call RasGetEapIdentity directly. This enables us 
    // to prevent an unnecessary prompt for the identity info that 
    // the user already gave at WinLogon.
    //      

    if (pArgs->lpEapLogonInfo)
    {    
        dwRet = CmEapGetIdentity(pArgs, 
                                 pszRasPbk, 
                                 pbEapAuthData, 
                                 dwEapAuthDataSize, 
                                 dwCustomAuthKey, 
                                 ppRasEapUserIdentity);
    }
    else
    {
        DWORD dwEapIdentityFlags = 0;

        //
        // Note: In the case that we are called from WinLogon,
        // but without EAP data, but the connection is configured for EAP
        // we send the RAS_EAP_FLAG_LOGON flag down to the EAP so it knows
        // what to do.
        //
        if (IsLogonAsSystem() && (CM_LOGON_TYPE_WINLOGON == pArgs->dwWinLogonType))
        {
            dwEapIdentityFlags |= RAS_EAP_FLAG_LOGON;
        }

        //
        // In case we don't want UI set the - RAS_EAP_FLAG_NON_INTERACTIVE
        // same as RASEAPF_NonInteractive
        //
        if (pArgs->dwFlags & FL_UNATTENDED)
        { 
            dwEapIdentityFlags |= RAS_EAP_FLAG_NON_INTERACTIVE;
        }
        else
        {
            //
            // Always prompt for EAP credentials. Otherwise when the PIN is saved
            // the user has no way of un-saving it because TLS will cache it and
            // won't display the prompt if it has everything it needs.
            //

            dwEapIdentityFlags = RAS_EAP_FLAG_PREVIEW;
        }

        //
        //  Our smartcard PIN retry story:  If called from winlogon with an EAP blob,
        //  we never retry because we have no way to sending the corrected PIN back
        //  to winlogon.  In other cases, we retry once only.
        //  Retrying oftener greatly increases the chance of locking the smartcard.
        //
        DWORD dwMaxTries = 3;       // essentially arbitrary number. (If a smartcard: most do lock you out after 3 tries.)
        DWORD dwCurrentTry = 0;

        do
        {
            dwRet = pArgs->rlsRasLink.pfnGetEapUserIdentity(
                        pszRasPbk,
                        pArgs->pRasDialParams->szEntryName,
                        dwEapIdentityFlags,  // See Note above
                        hwndDlg,  
                        ppRasEapUserIdentity);
        }
        while ((dwCurrentTry++ < dwMaxTries) && (ERROR_SUCCESS != dwRet) && (ERROR_CANCELLED != dwRet));

        //
        // We also clear the password and domain in this case because
        // they become irrelevant and we don't want to mix CAD credentials
        // with smartcard credentials. Specifically, we don't want a clash
        // between the UPN username that EAP usually produces and the 
        // standard username, domain provided with CAD at WinLogon.
        //

        lstrcpy(pArgs->pRasDialParams->szPassword, TEXT(""));
        lstrcpy(pArgs->pRasDialParams->szDomain, TEXT(""));
    }

    switch (dwRet)
    {
        //
        // If user id isn't required, succeed
        //

        case ERROR_INVALID_FUNCTION_FOR_ENTRY:
            dwRet = ERROR_SUCCESS;
            break;

        //
        // Retrieve the EAP credential data and store in dial params
        //

        case ERROR_SUCCESS:

            //
            // Copy Eap info to Dial Params and Dial Extensions for dialing
            //

            CMTRACE(TEXT("GetEapUserId() setting dial extension with *ppRasEapUserIdentity->pbEapInfo"));

            lstrcpy(pArgs->pRasDialParams->szUserName, (*ppRasEapUserIdentity)->szUserName);
          
            ((LPRASDIALEXTENSIONS_V500) pArgs->pRasDialExtensions)->RasEapInfo.dwSizeofEapInfo = 
                (*ppRasEapUserIdentity)->dwSizeofEapInfo;
        
            ((LPRASDIALEXTENSIONS_V500) pArgs->pRasDialExtensions)->RasEapInfo.pbEapInfo =
                (*ppRasEapUserIdentity)->pbEapInfo;

            break;

        default:
            break;
    }

    if (ERROR_SUCCESS == dwRet)
    {
        //
        // We have a user (identity) now, update internal and external records
        // so that this information can be reported out. If we're dialing a
        // tunnel, or its not a tunneling profile, store the name in the 
        // UserName cache, otherwise its the dial-up portion of double-dial
        // and we store the identity in the InetUserName cache. #388199
        //

        if ((!UseTunneling(pArgs, pArgs->nDialIdx)) || IsDialingTunnel(pArgs))
        {
            lstrcpy(pArgs->szUserName, pArgs->pRasDialParams->szUserName);
            SaveUserInfo(pArgs, UD_ID_USERNAME, (PVOID)pArgs->pRasDialParams->szUserName);
            SaveUserInfo(pArgs, UD_ID_DOMAIN, (PVOID)pArgs->pRasDialParams->szDomain);
        }
        else
        {
            lstrcpy(pArgs->szInetUserName, pArgs->pRasDialParams->szUserName);
            SaveUserInfo(pArgs, UD_ID_INET_USERNAME, (PVOID)pArgs->szInetUserName);
        }   
    }    
    
    CMTRACE2(TEXT("GetEapUserId() returns %u (0x%x)"), dwRet, dwRet);

    return dwRet;
}

//+----------------------------------------------------------------------------
//
// Func:    ShowAccessPointInfoFromReg
//
// Desc:    Get the access points from the registry and populate the combo box
//          passed as input to the function
//
// Args:    ArgsStruct *pArgs - Ptr to global args struct 
//          HWND hwndCombo - Handle to the combo box to puopulate
//
// Return:  BOOL - Success or failure
//
// Notes:   
//
// History: t-urama     07/28/2000  Created
//-----------------------------------------------------------------------------
BOOL ShowAccessPointInfoFromReg(ArgsStruct *pArgs, HWND hwndParent, UINT uiComboID)
{
    MYDBGASSERT(pArgs);

    if ((NULL == pArgs) || (NULL == hwndParent) || (NULL == pArgs->pszCurrentAccessPoint))
    {
        return FALSE;
    }
    
    LPTSTR pszKeyName = NULL;
    DWORD dwTypeTmp;
    DWORD dwSizeTmp = 1;
    HKEY    hKeyCm;
    DWORD   dwRes = 1;
    DWORD dwIndex = 0;
    PFILETIME pftLastWriteTime = NULL;


    LPTSTR pszRegPath = BuildUserInfoSubKey(pArgs->szServiceName, pArgs->fAllUser);
        
    MYDBGASSERT(pszRegPath);

    if (NULL == pszRegPath)
    {
        return FALSE;
    }

    CmStrCatAlloc(&pszRegPath, TEXT("\\"));
    CmStrCatAlloc(&pszRegPath, c_pszRegKeyAccessPoints);

    MYDBGASSERT(pszRegPath);

    if (NULL == pszRegPath)
    {
        return FALSE;
    }
    //
    // Open the sub key under HKCU
    //
    
    dwRes = RegOpenKeyExU(HKEY_CURRENT_USER,
                          pszRegPath,
                          0,
                          KEY_READ,
                          &hKeyCm);
    //
    // If we opened the key successfully, retrieve the value
    //
    
    if (ERROR_SUCCESS == dwRes)
    {    
        HWND hwndCombo = GetDlgItem(hwndParent, uiComboID);
        if (hwndCombo)
        {
            SendDlgItemMessageU(hwndParent, uiComboID, CB_RESETCONTENT, 0, 0L);
            do
            {
                dwSizeTmp = 1;
                do
                {
                    CmFree(pszKeyName);
                    dwSizeTmp = dwSizeTmp + MAX_PATH;
                    MYDBGASSERT(dwSizeTmp < 320);
                    if (dwSizeTmp > 320)
                    {
                        RegCloseKey(hKeyCm);
                        goto ShowError;
                    }

                    pszKeyName = (LPTSTR) CmMalloc((dwSizeTmp + 1) * sizeof(TCHAR));
                
                    if (NULL == pszKeyName)
                    {
                        RegCloseKey(hKeyCm);
                        goto ShowError;
                        
                    }

                    dwRes = RegEnumKeyExU(hKeyCm, 
                                          dwIndex,
                                          pszKeyName,
                                          &dwSizeTmp,
                                          NULL, 
                                          NULL, 
                                          NULL, 
                                          pftLastWriteTime);     
                    
      
                } while (ERROR_MORE_DATA == dwRes);

                // now write the name of the sub key to the combo box
                if (ERROR_SUCCESS == dwRes )
                {
                    SendDlgItemMessageU(hwndParent, uiComboID, CB_ADDSTRING,
                                        0, (LPARAM)pszKeyName);
                }
                
                if (ERROR_SUCCESS != dwRes && ERROR_NO_MORE_ITEMS != dwRes)
                {
                    CMTRACE1(TEXT("ShowAccessPointInfoFromReg() failed, GLE=%u."), GetLastError());
                    RegCloseKey(hKeyCm);
                    goto ShowError;
                }
                dwIndex ++;
            } while(ERROR_NO_MORE_ITEMS != dwRes);
           
            DWORD dwIdx = (DWORD)SendDlgItemMessageU(hwndParent,
                                       uiComboID,
                                       CB_FINDSTRINGEXACT,
                                       0,
                                       (LPARAM)pArgs->pszCurrentAccessPoint);
      
            if (dwIdx != CB_ERR) 
            {
                SendDlgItemMessageU(hwndParent, uiComboID, CB_SETCURSEL, (WPARAM)dwIdx, 0L);
            }
            else
            {
                LPTSTR pszDefaultAccessPointName = CmLoadString(g_hInst, IDS_DEFAULT_ACCESSPOINT);

                CMASSERTMSG(pszDefaultAccessPointName, TEXT("ShowAccessPointInfoFromReg -- CmLoadString of IDS_DEFAULT_ACCESSPOINT failed"));

                if (pszDefaultAccessPointName)
                {
                    dwIdx = (DWORD)SendDlgItemMessageU(hwndParent,
                                                       uiComboID,
                                                       CB_FINDSTRINGEXACT,
                                                       0,
                                                       (LPARAM)pszDefaultAccessPointName);
                    if (dwIdx != CB_ERR) 
                    {
                        SendDlgItemMessageU(hwndParent, uiComboID, CB_SETCURSEL, (WPARAM)dwIdx, 0L);
                        ChangedAccessPoint(pArgs, hwndParent, uiComboID);             
                    }

                    CmFree(pszDefaultAccessPointName);
                }
            }
        }
        
        CmFree(pszKeyName);
        CmFree(pszRegPath);
        RegCloseKey(hKeyCm);
        return TRUE;
    }
   
ShowError:
    
    CmFree(pszRegPath);
    CmFree(pszKeyName);
    return FALSE;
   
}

//+----------------------------------------------------------------------------
//
// Func:    ChangedAccessPoint
//
// Desc:    Changes the values of access point relevant stuff in pArgs
//          if the value of the current access point changes
//
// Args:    ArgsStruct *pArgs - Ptr to global args struct 
//
// Return:  BOOL - True if the access point has changed
//
// Notes:   
//
// History: t-urama     07/28/2000  Created
//-----------------------------------------------------------------------------

BOOL ChangedAccessPoint(ArgsStruct *pArgs, HWND hwndDlg, UINT uiComboID)
{
    BOOL bReturn = FALSE;
    MYDBGASSERT(pArgs);
    MYDBGASSERT(hwndDlg);

    if ((NULL == pArgs) || (NULL == hwndDlg) || (NULL == pArgs->pszCurrentAccessPoint))
    {
        return FALSE;
    }

    HWND hwndCombo = GetDlgItem(hwndDlg, uiComboID);

    if (hwndCombo)
    {
        LPTSTR pszAccessPoint = NULL;
        LRESULT lRes = 0;
        LRESULT lResTextLen = 0;

        // 
        // Need to get the currently selected text from the combobox.
        // Previously we used GetWindowTextU(hwndCombo, szAccessPoint, MAX_PATH+1), but it
        // incorrectly returned the text. 
        // First get the selected index, find out the string length, allocate memory
        //

        lRes = SendMessageU(hwndCombo, CB_GETCURSEL, (WPARAM)0, (LPARAM)0);
        if (CB_ERR != lRes)
        {
            lResTextLen = SendMessageU(hwndCombo, CB_GETLBTEXTLEN, (WPARAM)lRes, (LPARAM)0);
            if (CB_ERR != lResTextLen)
            {
                pszAccessPoint = (LPTSTR)CmMalloc(sizeof(TCHAR)*(lResTextLen+1));

                if (NULL != pszAccessPoint)
                {
                    //
                    // Retrieve the text.
                    //
                    lRes = SendMessageU(hwndCombo, CB_GETLBTEXT, (WPARAM)lRes, (LPARAM)pszAccessPoint);
                    if (CB_ERR != lRes)
                    {
                        if (0 != lstrcmpiU(pArgs->pszCurrentAccessPoint, pszAccessPoint))
                        {
                            CmFree(pArgs->pszCurrentAccessPoint);
                            pArgs->pszCurrentAccessPoint = CmStrCpyAlloc(pszAccessPoint);

                            if (pArgs->pszCurrentAccessPoint)
                            {
                                LPTSTR pszRegPath = FormRegPathFromAccessPoint(pArgs);

                                if (pszRegPath)
                                {
                                    pArgs->piniBoth->SetPrimaryRegPath(pszRegPath);
                                    pArgs->piniProfile->SetRegPath(pszRegPath);
                                    CmFree(pszRegPath);

                                    //
                                    // First we determine our connect type
                                    //
                                    GetConnectType(pArgs);

                                    //
                                    // Set fUseTunneling. If not obvious (eg. direct VPN) then 
                                    // base the initial value upon the primary phone number.
                                    //
                                    if (pArgs->IsDirectConnect())
                                    {
                                        pArgs->fUseTunneling = TRUE;
                                    }
                                    else
                                    {
                                        pArgs->fUseTunneling = UseTunneling(pArgs, 0);
                                    }

                                    //
                                    //  Make sure we re-munge the phone number we are about to load.
                                    //
                                    pArgs->bDialInfoLoaded = FALSE;

                                    //
                                    // get new values for redial count, idle timeout, and the tapi location
                                    //
                                    LoadProperties(pArgs);

                                    //
                                    // get new values for phone info
                                    //
                                    LoadPhoneInfoFromProfile(pArgs);
        
                                    PickModem(pArgs, pArgs->szDeviceType, pArgs->szDeviceName);

                                    CMTRACE1(TEXT("ChangedAccessPoint() - Changed Access point to %s"), pArgs->pszCurrentAccessPoint);

                                    bReturn = TRUE;
                                }
                                else
                                {
                                    CMASSERTMSG(FALSE, TEXT("ChangedAccessPoint -- FormRegPathFromAccessPoint returned NULL"));
                                }
                            }
                            else
                            {
                                CMASSERTMSG(FALSE, TEXT("ChangedAccessPoint -- CmStrCpyAlloc returned NULL trying to copy the current access point."));
                            }
                        } // else, nothing to do if the favorites are the same
                    }
                    else
                    {
                        CMASSERTMSG(FALSE, TEXT("ChangedAccessPoint -- SendMessageU(hwndCombo, CB_GETLBTEXT,...) returned CB_ERR"));
                    }
                }
                else
                {
                    CMASSERTMSG(FALSE, TEXT("ChangedAccessPoint -- Unable to allocate memory"));
                }
                CmFree(pszAccessPoint);
            }
            else
            {
                CMASSERTMSG(FALSE, TEXT("ChangedAccessPoint -- SendMessageU(hwndCombo, CB_GETLBTEXTLEN,...) returned CB_ERR"));
            }
        }
        else
        {
            CMASSERTMSG(FALSE, TEXT("ChangedAccessPoint -- SendMessageU(hwndCombo, CB_GETCURSEL,...) returned CB_ERR"));
        }
    }
    else
    {
        CMASSERTMSG(FALSE, TEXT("ChangedAccessPoint -- Unable to get the combo HWND"));
    }

    return bReturn;
}

//----------------------------------------------------------------------------
//
//  Function:   FindEntryCredentialsForCM
// 
//  Synopsis:   The algorithm and most of the code is taken from RAS and modified
//              for use by CM.
//
//              This routine determines whether per-user or per-connection credentials exist or 
//              both. 
// 
//              The logic is a little complicated because RasGetCredentials had to 
//              support legacy usage of the API.
//
//              Here's how it works.  If only one set of credentials is stored for a 
//              connection, then RasGetCredentials will return that set regardless of 
//              whether the RASCM_DefaultCreds flag is set.  If two sets of credentials
//              are saved, then RasGetCredentials will return the per-user credentials
//              if the RASCM_DefaultCreds bit is set, and the per-connection credentials
//              otherwise.
//
//              Here is the algorithm for loading the credentials
//
//              1. Call RasGetCredentials with the RASCM_DefaultCreds bit cleared
//                  1a. If nothing is returned, no credentials are saved
//                  1b. If the RASCM_DefaultCreds bit is set on return, then only
//                      global credentials are saved.
//
//              2. Call RasGetCredentials with the RASCM_DefaultCreds bit set
//                  2a. If the RASCM_DefaultCreds bit is set on return, then 
//                      both global and per-connection credentials are saved.
//                  2b. Otherwise, only per-user credentials are saved.
//
//  Arguments:  pArgs           - pointer to the ArgStruct
//              pszPhoneBook    - path to the phone book. Could be NULL.
//              *pfUser         - out param set true if per user creds found
//              *pfGlobal       - out param set true if global creds found
//              
//  Returns:    BOOL            - TRUE is succeeds else FALSE
//
//  History:    01/31/2001  tomkel  Created
//
//----------------------------------------------------------------------------
DWORD FindEntryCredentialsForCM(ArgsStruct *pArgs, LPTSTR pszPhoneBook,
                                BOOL *pfUser, BOOL *pfGlobal)
{
    RASCREDENTIALS rc1 = {0};
    RASCREDENTIALS rc2 = {0};
    BOOL fUseLogonDomain = FALSE;
    DWORD dwErr = ERROR_INVALID_PARAMETER;
    LPTSTR pszConnectoid = NULL;

    CMTRACE(TEXT("FindEntryCredentialsForCM() - Begin"));

    if (NULL == pArgs || NULL == pfUser || NULL == pfGlobal)
    {
        MYDBGASSERT(pArgs && pfUser && pfGlobal);
        CMTRACE(TEXT("FindEntryCredentialsForCM() - Error! Invalid Parameter."));
        return dwErr;
    }

    //
    // Initialize the out params
    //
    *pfUser = FALSE;
    *pfGlobal = FALSE;
    
    //
    // After setting the OUT params, check if RAS dll have been loaded and if we can use the ras creds store
    //
    if (NULL == pArgs->rlsRasLink.pfnGetCredentials  || FALSE == pArgs->bUseRasCredStore)
    {
        CMTRACE(TEXT("FindEntryCredentialsForCM() - RAS Creds store not supported on this platform."));
        return ERROR_NOT_SUPPORTED;
    }

    //
    // Set the size of the structures
    // 
    rc1.dwSize = sizeof(rc1);
    rc2.dwSize = sizeof(rc2);

    //
    // The third parameter is used only on Win9x (for tunneling) thus we set it to FALSE
    // since this function is called on Win2K+
    //
    pszConnectoid = GetRasConnectoidName(pArgs, pArgs->piniService, FALSE);
    if (pszConnectoid)
    {
        do 
        {
            //
            // Look up per-user cached username, password, and domain.
            // See comment '1.' in the function header
            //
            rc1.dwMask = RASCM_UserName | RASCM_Password | RASCM_Domain;
            dwErr = pArgs->rlsRasLink.pfnGetCredentials(pszPhoneBook, pszConnectoid, &rc1);
            
            CMTRACE2(TEXT("FindEntryCredentialsForCM() - Per-User RasGetCredentials=%d,m=%d"), dwErr, rc1.dwMask);
            if (dwErr != NO_ERROR)
            {
                break;
            }

            if (0 == rc1.dwMask)
            {
                //
                // See 1a. in the function header comments
                //
                dwErr = ERROR_SUCCESS;
                break;
            }
            else if (rc1.dwMask & RASCM_DefaultCreds)
            {
                //
                // See 1b. in the function header comments
                //
                *pfGlobal = TRUE;

                //
                // Assumed password was not encoded by RasGetCredentials()
                //
                CmEncodePassword(rc1.szPassword);

                dwErr = ERROR_SUCCESS;
                break;
            }

            //
            // Look up global per-user cached username, password, domain.
            // See comment 2. in the function header
            //
            rc2.dwMask =  
                RASCM_UserName | RASCM_Password | RASCM_Domain |  RASCM_DefaultCreds; 

            dwErr = pArgs->rlsRasLink.pfnGetCredentials(pszPhoneBook, pszConnectoid, &rc2);
    
            CMTRACE2(TEXT("FindEntryCredentialsForCM() - Global RasGetCredentials=%d,m=%d"), dwErr, rc2.dwMask);
            if (dwErr != ERROR_SUCCESS)
            {
                break;
            }

            if (rc2.dwMask & RASCM_DefaultCreds) 
            {
                //
                // See 2a. in the function header comments
                //
                *pfGlobal = TRUE;

                if (rc1.dwMask & RASCM_Password)
                {
                    *pfUser = TRUE;
                }

                //
                // Assumed password was not encoded by RasGetCredentials()
                //
                CmEncodePassword(rc1.szPassword);
                CmEncodePassword(rc2.szPassword);
            }
            else
            {
                //
                // See 2b. in the function header comments
                //
                if (rc1.dwMask & RASCM_Password)
                {
                    *pfUser = TRUE;
                }

                //
                // Assumed password was not encoded by RasGetCredentials()
                //
            
                CmEncodePassword(rc1.szPassword);
            }

        }while (FALSE);
    }

    //
    // Cleanup
    //

    ZeroMemory(rc1.szPassword, sizeof(rc1.szPassword));
    ZeroMemory(rc2.szPassword, sizeof(rc2.szPassword));

    CmFree(pszConnectoid);

    CMTRACE(TEXT("FindEntryCredentialsForCM() - End"));
    return dwErr;
}


//----------------------------------------------------------------------------
//
//  Function:   InitializeCredentialSupport
// 
//  Synopsis:   Helper function to initialize user and global credential 
//              support. Some of the flags are redundantly initialized 
//              (to  FALSE). That is done on purpose for clarity.
//
//  Arguments:  pArgs           - the ArgStruct *
//              
//  Returns:    BOOL            - TRUE is succeeds else FALSE
//
//  History:    01/31/2001  tomkel  Created
//
//----------------------------------------------------------------------------
BOOL InitializeCredentialSupport(ArgsStruct *pArgs)
{
    BOOL fGlobalCreds = FALSE;
    BOOL fGlobalUserSettings = FALSE;

    if (NULL == pArgs)
    {
        MYDBGASSERT(pArgs);
        return FALSE;
    }
    
    //
    // By default the the Internet Connection Sharing & Internet Connection 
    // Firewall (ICS) tab is disabled. 
    //
    pArgs->bShowHNetCfgAdvancedTab = FALSE;
    
    //
    // User profile read/write support when user is logged off or using dial-up
    // This flag determines if the user info needs to be also saved or loaded from
    // the .cmp file
    //
    pArgs->dwGlobalUserInfo = 0;

    //
    // Credential existance flags - here we cannot yet determine which creds exist
    // that is done in a later call to RefreshCredentialTypes
    // 
    pArgs->dwExistingCredentials = 0;

    //
    // Default for which credential store to use - set based on the existance flag so 
    // this will also get set appropriatelly after a call to RefreshCredentialTypes
    // 
    pArgs->dwCurrentCredentialType = CM_CREDS_USER;

    //
    // Deletion flags - used to mark a set of creds for deletion. Since the
    // user can Cancel out of a dialog we don't want to commit the changed
    // until we actually do a dial.
    //
    pArgs->dwDeleteCredentials = 0;

    //
    // Check if this is WindowsXP. We want display the Advanced tab for single-user and
    // all-user profiles
    //
    if (OS_NT51)
    {
        if (IsLogonAsSystem())
        {
            //
            // LocalSystem - winlogon or ICS (in both cases user is logged off)
            // WinLogon - creds are passed through MSGina
            // ICS - need to use glocal creds store
            // pArgs->dwWinLogonType was intialized in InitCredentials()
            // We don't want to read ICSData info if this is a single user profile
            //

            if (CM_LOGON_TYPE_WINLOGON == pArgs->dwWinLogonType || FALSE == pArgs->fAllUser)
            {
                pArgs->fGlobalCredentialsSupported = FALSE;
                pArgs->dwCurrentCredentialType = CM_CREDS_USER;
                pArgs->dwGlobalUserInfo = 0;
            }
            else
            {
                pArgs->fGlobalCredentialsSupported = TRUE;
                pArgs->dwCurrentCredentialType = CM_CREDS_GLOBAL;
                pArgs->dwGlobalUserInfo |= CM_GLOBAL_USER_INFO_READ_ICS_DATA ;
            }
            CMTRACE(TEXT("InitializeCredentialSupport() - LocalSystem - Global creds OK."));
        }
        else 
        {
            //
            // User is logged on
            //
            
            //
            // By default we want to we want to display the tab. By negating 
            // this value we can then correctly save it in the Args structure. This 
            // needs to be initialized for everyone
            //            
            const TCHAR* const c_pszCmEntryHideICFICSAdvancedTab = TEXT("HideAdvancedTab");

            pArgs->bShowHNetCfgAdvancedTab = !(pArgs->piniService->GPPB(c_pszCmSection, 
                                                                        c_pszCmEntryHideICFICSAdvancedTab, 
                                                                        FALSE));

            //
            // If this an all-user profile then we want to see if the profile enables 
            // global user settings and displays global credential options.
            // These two features are disabled for single user profiles with the exception of 
            // showing the Advanced (ICS) tab
            //
            if (pArgs->fAllUser)
            {
                //
                // If ICS is enabled then we need to support global user settings.
                // Otherwise we read the setting from the file
                //
                if (pArgs->bShowHNetCfgAdvancedTab)
                {
                    fGlobalUserSettings = TRUE;
                }
                else
                {
                    //
                    // See if we support global user settings. By default is it off except if ICS is enabled
                    // 
                    const TCHAR* const c_pszCmEntryGlobalUserSettings = TEXT("GlobalUserSettings");
                    fGlobalUserSettings = pArgs->piniService->GPPB(c_pszCmSection, c_pszCmEntryGlobalUserSettings, FALSE);
                }

                // 
                // Read the info from the .cms file. By default global credentials are supported
                //
                const TCHAR* const c_pszCmEntryHideGlobalCredentials = TEXT("GlobalCredentials");
                fGlobalCreds = pArgs->piniService->GPPB(c_pszCmSection, c_pszCmEntryHideGlobalCredentials, TRUE);
            }

            //
            // Check to see if we are going to be hiding the Save Password option, if so then
            // we don't want to support global credentials
            //
            pArgs->fHideRememberPassword = pArgs->piniService->GPPB(c_pszCmSection, c_pszCmEntryHideRememberPwd);   

            if (fGlobalCreds && FALSE == pArgs->fHideRememberPassword)
            {
                //
                // Global creds are supported
                //
                
                //
                // Pick a default for creds type - it might change after calling RefreshCredentialTypes
                //
                pArgs->fGlobalCredentialsSupported = TRUE;
                pArgs->dwCurrentCredentialType = CM_CREDS_USER; 
                if (fGlobalUserSettings)
                {
                    pArgs->dwGlobalUserInfo |= CM_GLOBAL_USER_INFO_WRITE_ICS_DATA;
                }
                CMTRACE(TEXT("InitializeCredentialSupport() - User, global creds, show global UI."));
            }
            else
            {
                //
                // Global creds not supported
                //
                pArgs->fGlobalCredentialsSupported = FALSE;
                pArgs->dwCurrentCredentialType = CM_CREDS_USER;
                pArgs->dwGlobalUserInfo = 0;
                CMTRACE(TEXT("InitializeCredentialSupport() - User, no global creds, normal UI."));
            }
        }
    }
    else 
    {
        //
        // Single user or not WindowsXP
        //
        pArgs->fGlobalCredentialsSupported = FALSE;
        pArgs->dwCurrentCredentialType = CM_CREDS_USER;
        pArgs->dwGlobalUserInfo = 0;
        CMTRACE(TEXT("InitializeCredentialSupport() - Single User profile or not WindowsXP. Global creds not supported"));
    }
    
    return TRUE;
}

//----------------------------------------------------------------------------
//
//  Function:   RefreshCredentialTypes
// 
//  Synopsis:   This refreshes credential info. If fSetCredsDefault is TRUE 
//              then we also need to set the default type: 
//              pArgs->dwCurrentCredentialType.
//                  
//
//  Arguments:  pArgs           - the ArgStruct *
//              fSetCredsDefault- used to set the default creds type
//
//  Returns:    BOOL            - TRUE is succeeds else FALSE
//
//  History:    01/31/2001  tomkel  Created
//
//----------------------------------------------------------------------------
BOOL RefreshCredentialTypes(ArgsStruct *pArgs, BOOL fSetCredsDefault)
{
    DWORD dwRC = ERROR_INVALID_PARAMETER;
    LPTSTR pszPrivatePbk = NULL;

    if (NULL == pArgs)
    {
        MYDBGASSERT(pArgs);
        return FALSE;
    }

    //
    // This should be run on Win2K+ whether this is an all user profile or not
    // The call that actually determines which credentials exist makes sure we 
    // can use the ras cred store 
    //
    if (OS_NT5)
    {
        BOOL fUserCredsExist = FALSE;
        BOOL fGlobalCredsExist = FALSE;

        // 
        // See if the main creds exist. Inside the function we determine whether 
        // we can use the RAS cred store
        //
        dwRC = FindEntryCredentialsForCM(pArgs, 
                                         pArgs->pszRasPbk,
                                         &fUserCredsExist, 
                                         &fGlobalCredsExist);
        if (ERROR_SUCCESS == dwRC)
        {
            CMTRACE2(TEXT("RefreshCredentialTypes() - FindEntryCredentialsForCM returned: (Main)     User=%d, Global=%d"), 
                     fUserCredsExist, fGlobalCredsExist);
        }
        else
        {
            CMTRACE(TEXT("RefreshCredentialTypes() - FindEntryCredentialsForCM returned an error. (Main)"));
        }
    
        //
        // Set the existence flags
        //
        if (fUserCredsExist)
        {
            pArgs->dwExistingCredentials  |= CM_EXIST_CREDS_MAIN_USER;
        }
        else
        {
            pArgs->dwExistingCredentials  &= ~CM_EXIST_CREDS_MAIN_USER;
        }

        if (fGlobalCredsExist)
        {
            pArgs->dwExistingCredentials  |= CM_EXIST_CREDS_MAIN_GLOBAL;
        }
        else
        {
            pArgs->dwExistingCredentials  &= ~CM_EXIST_CREDS_MAIN_GLOBAL;
        }

        fUserCredsExist = FALSE;
        fGlobalCredsExist = FALSE;

        pszPrivatePbk = CreateRasPrivatePbk(pArgs);
        if (pszPrivatePbk)
        {
            //
            // See if the Internet creds exist - by using the private phonebook
            // Inside the function we determine whether we can use the RAS cred store
            //
            dwRC = FindEntryCredentialsForCM(pArgs, 
                                             pszPrivatePbk,
                                             &fUserCredsExist,
                                             &fGlobalCredsExist); 
            if (ERROR_SUCCESS == dwRC)
            {
                CMTRACE2(TEXT("RefreshCredentialTypes() - FindEntryCredentialsForCM returned: (Internet) User=%d, Global=%d"), 
                         fUserCredsExist, fGlobalCredsExist);
            }
            else
            {
                CMTRACE(TEXT("RefreshCredentialTypes() - FindEntryCredentialsForCM returned an error. (Internet)"));
            }
        }

        //
        // Set the flags whether or not we successfully created a private pbk
        //
        if (fUserCredsExist)
        {
            pArgs->dwExistingCredentials |= CM_EXIST_CREDS_INET_USER;
        }
        else
        {
            pArgs->dwExistingCredentials &= ~CM_EXIST_CREDS_INET_USER;
        }

        if (fGlobalCredsExist)
        {
            pArgs->dwExistingCredentials |= CM_EXIST_CREDS_INET_GLOBAL;
        }
        else
        {
            pArgs->dwExistingCredentials &= ~CM_EXIST_CREDS_INET_GLOBAL;
        }

        //
        // If we don't support Global Creds then explicitly set 
        // the existance to FALSE. This can occur if the .cms flag
        // is set not to support global creds, but there are actually 
        // global creds on the system.
        //
        if (FALSE == pArgs->fGlobalCredentialsSupported)
        {
            pArgs->dwExistingCredentials &= ~CM_EXIST_CREDS_MAIN_GLOBAL;
            pArgs->dwExistingCredentials &= ~CM_EXIST_CREDS_INET_GLOBAL;
            CMTRACE(TEXT("RefreshCredentialTypes() - Global Credentials are disabled."));
        }
        
        if (fSetCredsDefault)
        {
            pArgs->dwCurrentCredentialType = GetCurrentCredentialType(pArgs);
            CMTRACE1(TEXT("RefreshCredentialTypes() - Set default Credentials = %d"), pArgs->dwCurrentCredentialType);
        }
    }

    CmFree(pszPrivatePbk);

    return TRUE;
}

//----------------------------------------------------------------------------
//
//  Function:   GetCurrentCredentialType
// 
//  Synopsis:   Gets the default credentials based on which ones exist based 
//              on which flags are set. This function should be called only  
//              after RefreshCredentialTypes since that function actually
//              queries the RAS creds store. This one only looks up the cached
//              status of those creds and determines the default according to
//              what credentials exist.
//
//  Arguments:  pArgs           - the ArgStruct *
//              fSetCredsDefault- used to set the default creds type
//
//  Returns:    BOOL            - TRUE is succeeds else FALSE
//
//  History:    01/31/2001  tomkel  Created
//
//----------------------------------------------------------------------------
DWORD GetCurrentCredentialType(ArgsStruct *pArgs)
{
    DWORD dwReturn = CM_CREDS_USER;
    
    if (NULL == pArgs)
    {
        MYDBGASSERT(pArgs);
        return dwReturn;
    }

    //
    // If Global creds aren't supported as in WinLogon case or single-user 
    // profiles or anything below WinXP, the default is User Creds Store
    //
    if (FALSE == pArgs->fGlobalCredentialsSupported)
    {
        return dwReturn;
    }

    //
    // Normal Rules when a user is logged on
    //
    if (CM_LOGON_TYPE_USER == pArgs->dwWinLogonType)
    {
        if (pArgs->dwExistingCredentials & CM_EXIST_CREDS_MAIN_USER)
        {
            //
            // Doesn't matter if main global creds exist since main user credentials 
            // have precendence if both exist
            //
            dwReturn = CM_CREDS_USER;
        }
        else if (pArgs->dwExistingCredentials & CM_EXIST_CREDS_MAIN_GLOBAL)
        {
            dwReturn = CM_CREDS_GLOBAL;
        }
        else 
        {
            // 
            // If none of them exist then we want to default to user creds
            //
            dwReturn = CM_CREDS_USER;
        }
    }
    else
    {
        //
        // In any other case dafult to global creds - (ICS scenario)
        // 
        dwReturn = CM_CREDS_GLOBAL;
    }

    return dwReturn;
}

//----------------------------------------------------------------------------
//
//  Function:   DeleteSavedCredentials
// 
//  Synopsis:   Helper function to delete credentials from the RAS store. 
//
//  Arguments:  pArgs           - the ArgStruct *
//              dwCredsType     - Normal or Internet credentials
//              fDeleteGlobal   - specifies whether to delete global credentials.
//                                If TRUE we delete user, domain name, 
//                                password as well
//              fDeleteIdentity - specifies whether to delete the user and 
//                                domain names in addition to the password
//              
//  Returns:    BOOL            - TRUE is succeeds else FALSE
//
//  History:    01/31/2001  tomkel  Created
//
//----------------------------------------------------------------------------
BOOL DeleteSavedCredentials(ArgsStruct *pArgs, DWORD dwCredsType, BOOL fDeleteGlobal, BOOL fDeleteIdentity)
{
    RASCREDENTIALS rc;
    BOOL fReturn = FALSE;
    DWORD dwErr = ERROR_INVALID_PARAMETER;
    LPTSTR pszConnectoid = NULL;

    CMTRACE2(TEXT("DeleteSavedCredentials() - Begin: %d %d"), fDeleteGlobal, fDeleteIdentity );

    if (NULL == pArgs)
    {   
        MYDBGASSERT(pArgs);
        return fReturn;
    }

    //
    // Check if globals should be deleted in case globals are not supported.
    // This can be in case of global creds are disabled on WinXP or this is
    // Win2K or the platform < Win2K where RASSetCredentials isn't even supported.
    // Thus we still should return TRUE
    //
    if ((fDeleteGlobal && FALSE == pArgs->fGlobalCredentialsSupported) || 
        (NULL == pArgs->rlsRasLink.pfnSetCredentials) || 
        (FALSE == pArgs->bUseRasCredStore))
    {
        CMTRACE(TEXT("DeleteSavedCredentials() - Global Creds not supported or do not have ras store on this platform."));
        return TRUE;
    }

    //
    // We don't support deleting globals on Win2K (that is caught by the above if since Win2K
    // will not have global credentials supported. Otherwise on Win2K we can delete the main 
    // user creds. On WinXP anything is fine.
    //
    if (OS_NT5)
    {
        ZeroMemory(&rc, sizeof(rc));
        rc.dwSize = sizeof(RASCREDENTIALS);
        rc.dwMask = RASCM_Password;

        if (fDeleteIdentity)
        {
            rc.dwMask |= (RASCM_UserName | RASCM_Domain);
        }

        if (fDeleteGlobal && pArgs->fGlobalCredentialsSupported)
        {
            rc.dwMask |= RASCM_UserName | RASCM_Domain | RASCM_DefaultCreds; 
        }

        //
        // The third parameter is used only on Win9x (for tunneling) thus we set it to FALSE
        // since this function is called on Win2K+
        //
        pszConnectoid = GetRasConnectoidName(pArgs, pArgs->piniService, FALSE);
        if (pszConnectoid)
        {
            if (CM_CREDS_TYPE_INET == dwCredsType)
            {
                LPTSTR pszPrivatePbk = CreateRasPrivatePbk(pArgs);
                if (pszPrivatePbk)
                {
                    dwErr = pArgs->rlsRasLink.pfnSetCredentials(pszPrivatePbk, 
                                                                pszConnectoid,
                                                                &rc,
                                                                TRUE );
                    CmFree(pszPrivatePbk);
                }
            }
            else
            {
                dwErr = pArgs->rlsRasLink.pfnSetCredentials(pArgs->pszRasPbk, 
                                                            pszConnectoid,
                                                            &rc,
                                                            TRUE );
            }
            if (ERROR_SUCCESS == dwErr)
            {
                fReturn = TRUE;
            }
        }

        CMTRACE1(TEXT("DeleteSavedCredentials() - End: RasSetCredentials=%d"), dwErr );
    }
    else
    {
        CMTRACE(TEXT("DeleteSavedCredentials() - Platform is less than Win2K"));
    }

    CmFree(pszConnectoid);

    return fReturn;
}


//+---------------------------------------------------------------------------
//
//  Function:   SetCredentialUIOptionBasedOnDefaultCreds 
//
//  Synopsis:   Selects (checks) the appropriate UI option for saving credentials
//              based on the current credential store default.
//
//  Arguments:  pArgs           - ptr to ArgsStruct
//              hwndDlg         - handle to the dialog window
//
//  Returns:    NONE
//
//  History:    02/05/2001  tomkel      Created
//
//----------------------------------------------------------------------------
VOID SetCredentialUIOptionBasedOnDefaultCreds(ArgsStruct *pArgs, HWND hwndDlg)
{
    if (NULL == pArgs || NULL == hwndDlg)
    {
        MYDBGASSERT(pArgs && hwndDlg);
        return;
    }
        
    //
    // fGlobalCredentialsSupported controls which dialog templates get loaded and
    // if the flag is FALSE then the dialog template doesn't have these controls 
    // thus there is no reason to set them.
    //

    if (pArgs->fGlobalCredentialsSupported) 
    {
        if (CM_CREDS_GLOBAL == pArgs->dwCurrentCredentialType)
        {
            CheckDlgButton(hwndDlg, IDC_OPT_CREDS_SINGLE_USER, BST_UNCHECKED);
            CheckDlgButton(hwndDlg, IDC_OPT_CREDS_ALL_USER, BST_CHECKED);
        }
        else
        {
            //
            // CM_CREDS_USER
            //
            CheckDlgButton(hwndDlg, IDC_OPT_CREDS_SINGLE_USER, BST_CHECKED);
            CheckDlgButton(hwndDlg, IDC_OPT_CREDS_ALL_USER, BST_UNCHECKED);
        }
    }

    return;
}


//+---------------------------------------------------------------------------
//
//  Function:   RefreshCredentialInfo 
//
//  Synopsis:   This is a slimmed down version of LoadProperties. It only
//              loads user info from cmp/cms, registry, password
//              cache, etc, into its internal variables.  
//              
//
//  Arguments:  pArgs           - ptr to ArgsStruct
//              dwCredsType     - type of credentials to refresh
//
//  Returns:    NONE
//
//  History:    02/05/2001  tomkel      Created
//
//----------------------------------------------------------------------------
VOID RefreshCredentialInfo(ArgsStruct *pArgs, DWORD dwCredsType)
{
    LPTSTR  pszTmp = NULL;
    LPTSTR  pszUserName = NULL;
    UINT    nTmp;

    CMTRACE(TEXT("RefreshCredentialInfo() - Begin"));

    if (NULL == pArgs)
    {
        MYDBGASSERT(pArgs);
        return;
    }

    if (IsTunnelEnabled(pArgs)) 
    { 
        if (CM_CREDS_TYPE_BOTH == dwCredsType || CM_CREDS_TYPE_INET == dwCredsType)
        {
            //
            // read in inet username
            // Special case where the same user name isn't being used, and internet globals don't exist
            // Then we have to read the user name from the user creds store in order to pre-populate
            //
            DWORD dwRememberedCredType = pArgs->dwCurrentCredentialType;
            pszUserName = NULL;

            if ((FALSE == pArgs->fUseSameUserName) &&
                (CM_CREDS_GLOBAL == pArgs->dwCurrentCredentialType) && 
                (FALSE == (BOOL)(CM_EXIST_CREDS_INET_GLOBAL & pArgs->dwExistingCredentials)))
            {
                pArgs->dwCurrentCredentialType = CM_CREDS_USER;
            }

            GetUserInfo(pArgs, UD_ID_INET_USERNAME, (PVOID*)&pszUserName);

            //
            // Restore credential store
            //
            pArgs->dwCurrentCredentialType = dwRememberedCredType;

            if (pszUserName)
            {
                //
                // check username length
                //
                nTmp = (int) pArgs->piniService->GPPI(c_pszCmSection, c_pszCmEntryMaxUserName, UNLEN);
                if ((UINT)lstrlenU(pszUserName) > __min(UNLEN, nTmp)) 
                {
                    CmFree(pszUserName);
                    pArgs->szInetUserName[0] = TEXT('\0');
                    SaveUserInfo(pArgs, UD_ID_INET_USERNAME, (PVOID)pArgs->szInetUserName);
                }
                else
                {
                    lstrcpyU(pArgs->szInetUserName, pszUserName);
                    CmFree(pszUserName);
                }
            }
            else
            {
                *pArgs->szInetUserName = TEXT('\0');
            }
        
            //
            // Read in inet password unless we are reconnecting in which case, we
            // already have the correct password, and we want to use it and dial
            // automatically. 
            //

            if (!(pArgs->dwFlags & FL_RECONNECT))
            {
                LPTSTR pszPassword = NULL;
                GetUserInfo(pArgs, UD_ID_INET_PASSWORD, (PVOID*)&pszPassword);
                if (!pszPassword)
                {
                    CmWipePassword(pArgs->szInetPassword);
                }
                else 
                {
                    nTmp = (int) pArgs->piniService->GPPI(c_pszCmSection, c_pszCmEntryMaxPassword, PWLEN);
                    if ((UINT)lstrlenU(pszPassword) > __min(PWLEN, nTmp))
                    {
                        CmFree(pszPassword);
                        pszPassword = CmStrCpyAlloc(TEXT(""));
                    }
    
                    lstrcpyU(pArgs->szInetPassword, pszPassword);               
                    CmEncodePassword(pArgs->szInetPassword); // Never leave a PWD in plain text on heap
                
                    CmWipePassword(pszPassword);
                    CmFree(pszPassword);
                }
            }
        }
    }

    if (CM_CREDS_TYPE_BOTH == dwCredsType || CM_CREDS_TYPE_MAIN == dwCredsType)
    {
        //
        // The presence of either lpRasNoUser or lpEapLogonInfo indicates
        // that we retrieved credentials via WinLogon. We ignore cached 
        // creds in this situation.   
        //
    
        if ((!pArgs->lpRasNoUser) && (!pArgs->lpEapLogonInfo))
        {
            //
            // get username, domain, etc. from CMS file
            //

            GetUserInfo(pArgs, UD_ID_USERNAME, (PVOID*)&pszUserName);
            if (pszUserName)
            {
                //
                // check username length
                //
                nTmp = (int) pArgs->piniService->GPPI(c_pszCmSection, c_pszCmEntryMaxUserName, UNLEN);
                if ((UINT)lstrlenU(pszUserName) > __min(UNLEN, nTmp)) 
                {
                    CmFree(pszUserName);
                    pszUserName = CmStrCpyAlloc(TEXT(""));
                    SaveUserInfo(pArgs, UD_ID_USERNAME, (PVOID)pszUserName);
                }
                lstrcpyU(pArgs->szUserName, pszUserName);
                CmFree(pszUserName);
            }
            else
            {
                *pArgs->szUserName = TEXT('\0');
            }

            //
            // Read in the standard password unless we are reconnecting in which case 
            // we already have the correct password, and we want to use it and dial
            // automatically. 
            //

            if (!(pArgs->dwFlags & FL_RECONNECT))
            {
                pszTmp = NULL;
                GetUserInfo(pArgs, UD_ID_PASSWORD, (PVOID*)&pszTmp);
                if (pszTmp) 
                {           
                    //
                    // max length for user password
                    //
    
                    nTmp = (int) pArgs->piniService->GPPI(c_pszCmSection,c_pszCmEntryMaxPassword,PWLEN);
                    if ((UINT)lstrlenU(pszTmp) > __min(PWLEN,nTmp)) 
                    {
                        CmFree(pszTmp);
                        pszTmp = CmStrCpyAlloc(TEXT(""));
                    }
                    lstrcpyU(pArgs->szPassword, pszTmp);
                    CmEncodePassword(pArgs->szPassword); // Never leave a PWD in plain text on heap
                
                    CmWipePassword(pszTmp);
                    CmFree(pszTmp);
                }
                else
                {
                    CmWipePassword(pArgs->szPassword);
                }
            }
    
            //
            // Load domain info
            //
   
            LPTSTR pszDomain = NULL;

            GetUserInfo(pArgs, UD_ID_DOMAIN, (PVOID*)&pszDomain);
            if (pszDomain)
            {
                nTmp = (int) pArgs->piniService->GPPI(c_pszCmSection, c_pszCmEntryMaxDomain, DNLEN);
        
                if (nTmp <= 0)
                {
                    nTmp = DNLEN;
                }
        
                if ((UINT)lstrlenU(pszDomain) > __min(DNLEN, nTmp))
                {
                    CmFree(pszDomain);
                    pszDomain = CmStrCpyAlloc(TEXT(""));
                }
                lstrcpyU(pArgs->szDomain, pszDomain);
                CmFree(pszDomain);
            }
            else
            {
                *pArgs->szDomain = TEXT('\0');
            }
        } 
    }

    CMTRACE(TEXT("RefreshCredentialInfo() - End"));
    return;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetAndStoreUserInfo 
//
//  Synopsis:   Most of this code existed in the OnMainConnect function.
//              Gets the username, domain, password from the edit boxes and saves them
//              to the internal structure pArgs->szUserName, pArgs->szPassword, pArgs->szDomain
//              if the fSaveOtherUserInfo is TRUE then it also saves them to the appropriate 
//              place (RAS store, reg, etc.)
//
//  Arguments:  pArgs               - ptr to ArgsStruct
//              hwndDlg             - handle to the dialog window
//              fSaveUPD            - save UserName, Password, Domain (U, P, D)
//              fSaveOtherUserInfo  - flag whether to save other userinfo (excluding U, P, D)
//
//  Returns:    NONE
//
//  History:    02/05/2001  tomkel      Created
//
//----------------------------------------------------------------------------
VOID GetAndStoreUserInfo(ArgsStruct *pArgs, HWND hwndDlg, BOOL fSaveUPD, BOOL fSaveOtherUserInfo)
{
    if (NULL == pArgs || NULL == hwndDlg)
    {
        MYDBGASSERT(pArgs && hwndDlg);
        return;
    }

    //
    // Process UserName info, if any
    //

    if (GetDlgItem(hwndDlg, IDC_MAIN_USERNAME_EDIT))
    {
        LPTSTR pszUsername = CmGetWindowTextAlloc(hwndDlg, IDC_MAIN_USERNAME_EDIT);

        //
        // save the user info
        //
        if (fSaveUPD)
        {
            SaveUserInfo(pArgs, UD_ID_USERNAME, (PVOID)pszUsername);
        }

        lstrcpyU(pArgs->szUserName, pszUsername);
        CmFree(pszUsername);

    }
    else
    {
        //
        // In case the user name field is hidden then just re-save what's in the 
        // structure. This needs to be done since all of the credentials might have
        // been deleted from the ras cred store
        //
        if (fSaveUPD)
        {
            SaveUserInfo(pArgs, UD_ID_USERNAME, (PVOID)pArgs->szUserName);
        }
    }

    //
    // Update password related flags
    //

    if (!pArgs->fHideRememberPassword)
    {
        //
        // save "Remember password"
        //
        if (fSaveOtherUserInfo)
        {
            SaveUserInfo(pArgs, UD_ID_REMEMBER_PWD, 
                         (PVOID)&pArgs->fRememberMainPassword);
        }
    }

    if (!pArgs->fHideDialAutomatically)
    {
        //
        // save "Dial automatically..."
        //
        if (fSaveOtherUserInfo)
        {
            SaveUserInfo(pArgs, UD_ID_NOPROMPT, 
                         (PVOID)&pArgs->fDialAutomatically);
        }
    }

    //
    // Process Password info, if any. If field is hidden, then don't save anything.
    //
    HWND hwndPassword = GetDlgItem(hwndDlg, IDC_MAIN_PASSWORD_EDIT);

    if (hwndPassword)
    {
        BOOL fSavePassword = TRUE;

        //
        // We don't want to copy the password into pArgs structure if fSaveUPD isn't true,
        // because it will be obfuscated in this case. The password is already in the structure
        // on Win2K+
        //
        if (fSaveUPD)
        {
            //
            // Get the latest password data from the edit control 
            // and obfuscate its contents so that connect actions
            // can't retrieve it.
            //

            GetPasswordFromEdit(pArgs);     // fills pArgs->szPassword            
            ObfuscatePasswordEdit(pArgs);

            //
            // Check if we have 16 *'s
            //
            CmDecodePassword(pArgs->szPassword);
            if ((0 == lstrcmpU(c_pszSavedPasswordToken, pArgs->szPassword)) && 
                (FALSE == SendMessageU(hwndPassword, EM_GETMODIFY, 0L, 0L)))
            {
                //
                // We have 16 *'s and the user hasn't modified the editbox. This 
                // password is from the RAS cred store, so we don't want to save the 16 *'s 
                //
                fSavePassword = FALSE;
            }
            CmEncodePassword(pArgs->szPassword);
        }

        //
        // For winlogon we need to take the password from the edit box
        //
        if (CM_LOGON_TYPE_WINLOGON == pArgs->dwWinLogonType)
        {
            GetPasswordFromEdit(pArgs);     // fills pArgs->szPassword            
        }
        
        //
        // Update persistent storage
        // No need to delete the password here as it was done by the calling function
        //

        if (pArgs->fRememberMainPassword)
        {
            //
            // If the password has changed, then update storage
            // Always save password - 303382
            //

            if (fSaveUPD && fSavePassword)
            {
                CmDecodePassword(pArgs->szPassword);
                SaveUserInfo(pArgs, UD_ID_PASSWORD, (PVOID)pArgs->szPassword);
                CmEncodePassword(pArgs->szPassword);
            }
        
            //
            // Check DialAutomatically and carry remember state 
            // over to InetPassword if it isn't remembered already.
            //
            // Need to check if this is a double-dial scenario. Also need to check if we are
            // allowed to save UPD, otherwise we don't want to change the state mainly 
            // (pArgs->fRememberInetPassword)
            //
            if (pArgs->fDialAutomatically && fSaveUPD && 
                (DOUBLE_DIAL_CONNECTION == pArgs->GetTypeOfConnection()))
            {
                //
                // Carry remember state from DialAutomatically over to 
                // InetPassword if it isn't already remembered.
                //

                if (!pArgs->fRememberInetPassword)
                {
                    pArgs->fRememberInetPassword = TRUE;

                    CmDecodePassword(pArgs->szInetPassword);
                    if (fSavePassword)
                    {
                        SaveUserInfo(pArgs, UD_ID_INET_PASSWORD, (PVOID)pArgs->szInetPassword); 
                    }
                    CmEncodePassword(pArgs->szInetPassword);
                }
            }
        }
        else
        {
            //
            // If we don't have the ras cred store then the password wasn't deleted
            // so we must deleted by calling this function
            //
            if (fSavePassword) // No need to check fSaveUPD, taken care of ras creds store check
            {
                if (FALSE == pArgs->bUseRasCredStore)
                {
                    DeleteUserInfo(pArgs, UD_ID_PASSWORD);
                }
            }
        }

        if (fSaveUPD)
        {
            BOOL fSaveInetPassword = TRUE;

            //
            // Check if we have 16 *'s for Internet Password. First, decode and then encode pw
            //
            CmDecodePassword(pArgs->szInetPassword); 
            if (0 == lstrcmpU(c_pszSavedPasswordToken, pArgs->szInetPassword))
            {
                //
                // We have 16 *'s This password is from the RAS cred store, so we don't want to save the 16 *'s 
                //
                fSaveInetPassword = FALSE;
            }
            CmEncodePassword(pArgs->szInetPassword);

            //
            // Check to see if we should re-save Internet creds
            // This needs to be done here in case the user has switched between
            // global and local credentials using the option buttons while having Internet 
            // credentials set in the Internet Login (CInetPage) property sheet. By switching 
            // the options, the user switched the current credential store 
            // (pArgs->dwCurrentCredentialType) so in order not to lose that data, we need to 
            // re-save the internet creds. Re-saving puts them in the correct (global or local) 
            // ras cred store.
            // When the username is the same and we saved the main password (SaveUserInfo)
            // this also saves the password to the Internet creds store
            //
            
            if (pArgs->fUseSameUserName)
            {
                if (fSaveInetPassword)
                {
                    if (pArgs->fRememberMainPassword)
                    {
                        //
                        // Save the UserName into the InetUserName field
                        // Password has been saved when saving UD_ID_PASSWORD. There is a special
                        // case that also saves the main password as the internet password
                        //
                        SaveUserInfo(pArgs, UD_ID_INET_USERNAME, (PVOID)pArgs->szUserName);
                        pArgs->fRememberInetPassword = TRUE;
                    }
                    else
                    {
                        if (FALSE == pArgs->bUseRasCredStore)
                        {
                            DeleteUserInfo(pArgs, UD_ID_INET_PASSWORD);
                            pArgs->fRememberInetPassword = FALSE;
                        }
                    }
                }
            }
            else
            {
                if (fSaveInetPassword)
                {
                    if(pArgs->fRememberInetPassword)
                    {
                        CmDecodePassword(pArgs->szInetPassword);
                        SaveUserInfo(pArgs, UD_ID_INET_PASSWORD, (PVOID)pArgs->szInetPassword);
                        CmEncodePassword(pArgs->szInetPassword);
                    }
                    else
                    {
                        if (FALSE == pArgs->bUseRasCredStore)
                        {
                            DeleteUserInfo(pArgs, UD_ID_INET_PASSWORD);
                        }
                    }
                }

                //
                // Need to save username in either case so we can pre-populate this
                //
                SaveUserInfo(pArgs, UD_ID_INET_USERNAME, 
                             (PVOID)pArgs->szInetUserName);
            }
        }
    }

    // 
    // This should be saved in all cases except ICS
    //
    if (fSaveOtherUserInfo)
    {
        SaveUserInfo(pArgs, UD_ID_REMEMBER_INET_PASSWORD, (PVOID)&pArgs->fRememberInetPassword); 
    }

    //
    // Process Domain info, if any
    //

    if (GetDlgItem(hwndDlg, IDC_MAIN_DOMAIN_EDIT)) // !pArgs->fHideDomain)
    {
        LPTSTR pszDomain = CmGetWindowTextAlloc(hwndDlg,IDC_MAIN_DOMAIN_EDIT);
    
        //
        // save the user info
        //

        if (fSaveUPD)
        {
            SaveUserInfo(pArgs, UD_ID_DOMAIN, (PVOID)pszDomain); 
        }

        lstrcpyU(pArgs->szDomain, pszDomain);
        CmFree(pszDomain);
    }
    else
    {
        //
        // In case the domain field is hidden then just re-save what's in the 
        // structure. This needs to be done since all of the credentials might have
        // been deleted from the ras cred store.
        //
        if (fSaveUPD)
        {
            SaveUserInfo(pArgs, UD_ID_DOMAIN, (PVOID)pArgs->szDomain); 
        }
    }

    return;
}

//+---------------------------------------------------------------------------
//
//  Function:   SetIniObjectReadWriteFlags 
//
//  Synopsis:   If the read or write flags are set we need to enable reading and/or
//              writing to the .CMP file. Each instance of the CIni class may 
//              or may not use the .cmp file. It can also be using the .CMP as either 
//              the primary file or normal file. See InitProfileFromName function 
//              in init.cpp for detailed comments about these instances.
//
//              pArgs->piniProfile      - uses .CMP as a regular file
//              pArgs->piniService      - doesn't use .CMP file at all
//              pArgs->piniBoth         - uses .CMP as a primary file
//              pArgs->piniBothNonFav   - uses .CMP as a primary file
//
//  Arguments:  pArgs           - ptr to ArgsStruct
//
//  Returns:    NONE
//
//  History:    02/14/2001  tomkel      Created
//
//----------------------------------------------------------------------------
VOID SetIniObjectReadWriteFlags(ArgsStruct *pArgs)
{
    if (NULL == pArgs)
    {
        MYDBGASSERT(pArgs);
        return;
    }

    BOOL fWriteICSInfo = FALSE;
    BOOL fReadGlobalICSInfo = FALSE;

    //
    // Get the read flag
    //
    fReadGlobalICSInfo = ((BOOL)(pArgs->dwGlobalUserInfo & CM_GLOBAL_USER_INFO_READ_ICS_DATA) ? TRUE : FALSE);

    //
    // Get the write flag. 
    //
    fWriteICSInfo = ((BOOL)(pArgs->dwGlobalUserInfo & CM_GLOBAL_USER_INFO_WRITE_ICS_DATA) ? TRUE : FALSE);

    if (fReadGlobalICSInfo || fWriteICSInfo)
    {
        LPTSTR pszICSDataReg = BuildICSDataInfoSubKey(pArgs->szServiceName);
        if (pszICSDataReg)
        {
            //
            // Now that there is a reg key and at least one of the above flags is TRUE,
            // then we want to set the read and write flags in the classes. By default
            // they are set to FALSE in the constructors, so we don't have to 
            // explicitly set them if we don't need this functionality.
            //
            // Set ICSData reg key
            //
            pArgs->piniProfile->SetICSDataPath(pszICSDataReg);
            pArgs->piniBoth->SetICSDataPath(pszICSDataReg);
            pArgs->piniBothNonFav->SetICSDataPath(pszICSDataReg);

            //
            // Set Write flag since we have a reg key
            //
            pArgs->piniProfile->SetWriteICSData(fWriteICSInfo);
            pArgs->piniBoth->SetWriteICSData(fWriteICSInfo);
            pArgs->piniBothNonFav->SetWriteICSData(fWriteICSInfo);

            //
            // Set Read flag since we have a reg key
            //
            pArgs->piniProfile->SetReadICSData(fReadGlobalICSInfo);
            pArgs->piniBoth->SetReadICSData(fReadGlobalICSInfo);
            pArgs->piniBothNonFav->SetReadICSData(fReadGlobalICSInfo);
        }

        CmFree(pszICSDataReg);
    }

    return;
}

//----------------------------------------------------------------------------
//
//  Function:   TryToDeleteAndSaveCredentials 
//
//  Synopsis:   Used on Win2K and WinXP+. This function uses the RAS Credential 
//              store to save and delete credentials based on user's selection.
//              First we need to determine if the user is saving their password.
//              Then appropriately delete or prompt to delete existing credentials.
//              If we aren't saving any credentials, then delete all of them.
//              The special case is if the user is deleting his local credentials
//              and global credentials exist on the system. Then we have to prompt
//              if we should delete the global creds as well.
//              Toward the botton of the function we get the info from the UI.
//              If the password is 16 *'s then we don't save the password After 
//              getting info from the UI, we save it in the RAS Cred store. 
//              Internet credentials are saved if we are using the same user 
//              name. Otherwise we leave the Internet creds. They were saved
//              on the Inet properties page. There is a scenario where the user
//              saved the internet creds on the property page and then switched 
//              the way credentials should be saved (global vs. local) which might cause
//              the internet password to be stored under in the wrong (global vs. local)
//              ras store. If the passwords are disjoined (pArgs->fUseSameUserName is FALSE)
//              there isn't much we can do.
//              
//              NOTE: We only want to delete credentials if and only if the existence 
//              flag are set! This is to prevent from deleting mainly global credentials 
//              in a certain profile where global credentials are disabled. 
//      
//
//  Arguments:  pArgs                   - ptr to ArgsStruct
//              hwndDlg                 - HWND to dialog
//
//  Returns:    NONE
//
//  History:    03/24/2001  tomkel      Created
//
//----------------------------------------------------------------------------
VOID TryToDeleteAndSaveCredentials(ArgsStruct *pArgs, HWND hwndDlg)
{
    if (NULL == pArgs || NULL == hwndDlg)
    {
        MYDBGASSERT(pArgs && hwndDlg);
        return;
    }

    //
    // Check if this is Win2K+ (That's where RAS Creds store is supported)
    //
    if (!OS_NT5)
    {
        MYDBGASSERT(FALSE);
        return;
    }

    BOOL fSave = FALSE;
    BOOL fResaveInetUserCreds = FALSE;
    RASCREDENTIALS rc = {0};
    RASCREDENTIALS rcInet={0};
    rc.dwSize = sizeof(rc);
    rcInet.dwSize = sizeof(rcInet);
    
    //
    // See if we want to save the credentials
    //
    if (pArgs->fRememberMainPassword)
    {
        //
        // Which password are we saving?
        //
        if (CM_CREDS_GLOBAL == pArgs->dwCurrentCredentialType)
        {
            //
            // Delete User creds w/o asking. No need to check for existence since these
            // are just user (main & inet) creds.
            //
            DeleteSavedCredentials(pArgs, CM_CREDS_TYPE_MAIN, CM_DELETE_SAVED_CREDS_KEEP_GLOBALS, CM_DELETE_SAVED_CREDS_DELETE_IDENTITY);
            pArgs->dwExistingCredentials &= ~CM_EXIST_CREDS_MAIN_USER;
            rc.dwMask = RASCM_DefaultCreds;

            //
            // Delete Internet User creds w/o asking
            // It doesn't matter that we aren't using the same user name
            // If we are saving globals, then user creds must always be deleted! This applies for main and Internet.
            // 
            DeleteSavedCredentials(pArgs, CM_CREDS_TYPE_INET, CM_DELETE_SAVED_CREDS_KEEP_GLOBALS, CM_DELETE_SAVED_CREDS_DELETE_IDENTITY);
            pArgs->dwExistingCredentials &= ~CM_EXIST_CREDS_INET_USER;
        }
        else
        {
            //
            // Trying to save User creds. if there is currently no saved per-user password 
            // and the user opts to save the password himself, then ask whether the global
            // password should be deleted if it exists.
            //
            if ((CM_EXIST_CREDS_MAIN_GLOBAL & pArgs->dwExistingCredentials) &&
                !(CM_EXIST_CREDS_MAIN_USER & pArgs->dwExistingCredentials))
            {
                LPTSTR pszTmp = CmLoadString(g_hInst, IDMSG_DELETE_GLOBAL_CREDS);
                if (pszTmp)
                {
                    if (IDYES == MessageBoxEx(hwndDlg, pszTmp, pArgs->szServiceName, 
                                              MB_YESNO|MB_ICONQUESTION|MB_DEFBUTTON2,
                                              LANG_USER_DEFAULT))
                    {
                        DeleteSavedCredentials(pArgs, CM_CREDS_TYPE_MAIN, CM_DELETE_SAVED_CREDS_DELETE_GLOBALS, CM_DELETE_SAVED_CREDS_DELETE_IDENTITY);
                        pArgs->dwExistingCredentials &= ~CM_EXIST_CREDS_MAIN_GLOBAL;

                        //
                        // Check for existence before deleting. If they don't exist, no need to 
                        // delete them.
                        //
                        if ((CM_EXIST_CREDS_INET_GLOBAL & pArgs->dwExistingCredentials)) 
                        {
                            //
                            // Delete Internet Global creds if we are using the same creds
                            //
                            if (pArgs->fUseSameUserName || (FALSE == pArgs->fRememberInetPassword))
                            {
                                DeleteSavedCredentials(pArgs, CM_CREDS_TYPE_INET, CM_DELETE_SAVED_CREDS_DELETE_GLOBALS, CM_DELETE_SAVED_CREDS_DELETE_IDENTITY);
                                pArgs->dwExistingCredentials &= ~CM_EXIST_CREDS_INET_GLOBAL;
                            }
                        }
                    }
                }
                CmFree(pszTmp);            
            }
        }

        //
        // User chose to save password.  Cache username, password, and
        // domain.
        //
        fSave = TRUE;
        rc.dwMask |= RASCM_UserName | RASCM_Password | RASCM_Domain;
    }
    else
    {
        //
        // Don't save password
        //

        //
        // Check which option button is currently selected
        //
        if (CM_CREDS_USER == pArgs->dwCurrentCredentialType)
        {
            //
            // User is trying to delete his local creds. Delete the user creds.
            // No need to check if they exist since these are local user creds.
            //
            DeleteSavedCredentials(pArgs, CM_CREDS_TYPE_MAIN, CM_DELETE_SAVED_CREDS_KEEP_GLOBALS, CM_DELETE_SAVED_CREDS_KEEP_IDENTITY);
            pArgs->dwExistingCredentials &= ~CM_EXIST_CREDS_MAIN_USER;

            if (pArgs->fUseSameUserName  || (FALSE == pArgs->fRememberInetPassword))
            {
                DeleteSavedCredentials(pArgs, CM_CREDS_TYPE_INET, CM_DELETE_SAVED_CREDS_KEEP_GLOBALS, CM_DELETE_SAVED_CREDS_KEEP_IDENTITY);
                pArgs->dwExistingCredentials &= ~CM_EXIST_CREDS_INET_USER;
            }

            //
            // Check if global creds exist and if so prompt the user asking if he wants 
            // to delete the globals as well
            //
            if (CM_EXIST_CREDS_MAIN_GLOBAL & pArgs->dwExistingCredentials)
            {
                int iMsgBoxResult = 0;

                LPTSTR pszTmp = CmLoadString(g_hInst, IDMSG_DELETE_ALL_CREDS);
                if (pszTmp)
                {
                    //
                    // Set the default to the 2nd button (NO), thus the user won't 
                    // accidentally delete the global creds.
                    //
                    iMsgBoxResult = MessageBoxEx(hwndDlg, pszTmp, pArgs->szServiceName, 
                                              MB_YESNO|MB_ICONQUESTION|MB_DEFBUTTON2,
                                              LANG_USER_DEFAULT);
                
                    if (IDYES == iMsgBoxResult)
                    {
                        //
                        // Delete global creds
                        //
                        DeleteSavedCredentials(pArgs, CM_CREDS_TYPE_MAIN, CM_DELETE_SAVED_CREDS_DELETE_GLOBALS, CM_DELETE_SAVED_CREDS_DELETE_IDENTITY);
                        pArgs->dwExistingCredentials &= ~CM_EXIST_CREDS_MAIN_GLOBAL;

                        if (CM_EXIST_CREDS_INET_GLOBAL & pArgs->dwExistingCredentials)
                        {
                            if (pArgs->fUseSameUserName || (FALSE == pArgs->fRememberInetPassword))
                            {
                                DeleteSavedCredentials(pArgs, CM_CREDS_TYPE_INET, CM_DELETE_SAVED_CREDS_DELETE_GLOBALS, CM_DELETE_SAVED_CREDS_DELETE_IDENTITY);
                                pArgs->dwExistingCredentials &= ~CM_EXIST_CREDS_INET_GLOBAL;
                            }
                        }
                    }
                }
                CmFree(pszTmp);
                pszTmp = NULL;
            }

            //
            // We need to resave username or domain info, even if it existed in case the
            // user has updated it.
            //
            fSave = TRUE;
            rc.dwMask |= RASCM_UserName | RASCM_Domain;
        }
        else
        {
            //
            // Delete both sets of credentials
            //

            //
            // Check if we need to resave User Name and Domain. The call that deletes the 
            // user creds doesn't wipe out User Name and Domain so there is no need to re-save.
            //
            if (FALSE == (BOOL)(pArgs->dwExistingCredentials & CM_EXIST_CREDS_MAIN_USER))
            {
                //
                // Resave the username, and domain since user creds didn't exist
                // and we want to pre-populate this info next time CM is loaded
                //
                fSave = TRUE;
                rc.dwMask |= RASCM_UserName | RASCM_Domain;
            }

            if (CM_EXIST_CREDS_MAIN_GLOBAL & pArgs->dwExistingCredentials)
            {
                //
                // Delete the global credentials.  
                // Note from RAS codebase: Note that we have to delete the global identity 
                // as well because we do not support deleting 
                // just the global password.  This is so that 
                // RasSetCredentials can emulate RasSetDialParams.
                //

                DeleteSavedCredentials(pArgs, CM_CREDS_TYPE_MAIN, CM_DELETE_SAVED_CREDS_DELETE_GLOBALS, CM_DELETE_SAVED_CREDS_DELETE_IDENTITY);
                pArgs->dwExistingCredentials &= ~CM_EXIST_CREDS_MAIN_GLOBAL;
            }

            if (CM_EXIST_CREDS_INET_GLOBAL & pArgs->dwExistingCredentials)
            {
                if (pArgs->fUseSameUserName || (FALSE == pArgs->fRememberInetPassword))
                {
                    DeleteSavedCredentials(pArgs, CM_CREDS_TYPE_INET, CM_DELETE_SAVED_CREDS_DELETE_GLOBALS, CM_DELETE_SAVED_CREDS_DELETE_IDENTITY);
                    pArgs->dwExistingCredentials &= ~CM_EXIST_CREDS_INET_GLOBAL;

                    //
                    // If we don't have Inet user creds then we need to cache the username for Inet creds
                    //
                    if (FALSE == (BOOL)(CM_EXIST_CREDS_INET_USER & pArgs->dwExistingCredentials))
                    {
                        fResaveInetUserCreds = TRUE;
                    }
                }
            }

            //
            // Delete the password saved per-user.  Keep the user name
            // and domain saved, however.
            //

            if (CM_EXIST_CREDS_MAIN_USER & pArgs->dwExistingCredentials)
            {
                DeleteSavedCredentials(pArgs, CM_CREDS_TYPE_MAIN, CM_DELETE_SAVED_CREDS_KEEP_GLOBALS, CM_DELETE_SAVED_CREDS_KEEP_IDENTITY);
                pArgs->dwExistingCredentials &= ~CM_EXIST_CREDS_MAIN_USER;
            }

            if (CM_EXIST_CREDS_INET_USER & pArgs->dwExistingCredentials)
            {
                if (pArgs->fUseSameUserName || (FALSE == pArgs->fRememberInetPassword))
                {
                    DeleteSavedCredentials(pArgs, CM_CREDS_TYPE_INET, CM_DELETE_SAVED_CREDS_KEEP_GLOBALS, CM_DELETE_SAVED_CREDS_KEEP_IDENTITY);
                    pArgs->dwExistingCredentials &= ~CM_EXIST_CREDS_INET_USER;
                }
            }
        }
    }

    //
    // Gets the info from the UI into pArgs and copy them into the RASCREDENTIALS structure
    //
    GetUserInfoFromDialog(pArgs, hwndDlg, &rc);

    //
    // See if we need to save anything
    //
    if (fSave)
    {
        LPTSTR pszConnectoid = GetRasConnectoidName(pArgs, pArgs->piniService, FALSE);
        DWORD dwCurrentMask = rc.dwMask;
        DWORD dwInetCurrentMask = rc.dwMask & ~RASCM_Domain; // Don't need domain info

        if (pszConnectoid && pArgs->rlsRasLink.pfnSetCredentials)
        {
            DWORD dwRet = (DWORD)-1; // Some non ERROR_SUCCESS value
            DWORD dwRetInet = (DWORD)-1; // Some non ERROR_SUCCESS value

            LPTSTR pszPhoneBook = pArgs->pszRasPbk;
            LPTSTR pszPrivatePhoneBook = CreateRasPrivatePbk(pArgs);

            CopyMemory((LPVOID)&rcInet, (LPVOID)&rc, sizeof(rcInet));

            //
            // Save the creds
            //
            dwRet = pArgs->rlsRasLink.pfnSetCredentials(pszPhoneBook, pszConnectoid, &rc, FALSE);

            if (ERROR_CANNOT_FIND_PHONEBOOK_ENTRY == dwRet)
            {
                //
                //  Then the phonebook entry doesn't exist yet, lets create it.
                //
                LPRASENTRY pRasEntry = (LPRASENTRY)CmMalloc(sizeof(RASENTRY));

                if (pRasEntry && pArgs->rlsRasLink.pfnSetEntryProperties)
                {
                    pRasEntry->dwSize = sizeof(RASENTRY);
                    dwRet = pArgs->rlsRasLink.pfnSetEntryProperties(pszPhoneBook, pszConnectoid, pRasEntry, pRasEntry->dwSize, NULL, 0);

                    //
                    //  Lets try to set the credentials one more time ...
                    //
                    if (ERROR_SUCCESS == dwRet)
                    {
                        //
                        // dwMask needs to be reassigned, the previous call modified it
                        //
                        rc.dwMask = dwCurrentMask;
                        dwRet = pArgs->rlsRasLink.pfnSetCredentials(pszPhoneBook, pszConnectoid, &rc, FALSE);
                    }

                    CmFree(pRasEntry);
                }
            }

            //
            // Now try to save Internet creds
            //
            if (ERROR_SUCCESS == dwRet && pszPrivatePhoneBook)
            {
                //
                // If we aren't using the credentials for main and Inet, then there
                // is no need to resave Internet credentials, because they were saved on 
                // the Inet-Dialog page and they weren't deleted above.
                // 
                if (pArgs->fUseSameUserName)
                {
                    //
                    // dwMask needs to be reassigned, the previous call modified it
                    //
                    rcInet.dwMask = dwInetCurrentMask;
                    dwRetInet = pArgs->rlsRasLink.pfnSetCredentials(pszPrivatePhoneBook, pszConnectoid, &rcInet, FALSE);
                }
                else
                {
                    if (fResaveInetUserCreds)
                    {
                        rcInet.dwMask = dwInetCurrentMask;
                        dwRetInet = pArgs->rlsRasLink.pfnSetCredentials(pszPrivatePhoneBook, pszConnectoid, &rcInet, FALSE);
                    }

                    if (pArgs->fDialAutomatically && 
                        (DOUBLE_DIAL_CONNECTION == pArgs->GetTypeOfConnection())) 
                    {
                        //
                        // Carry remember state from DialAutomatically over to 
                        // InetPassword if it isn't already remembered.
                        //

                        if (FALSE == pArgs->fRememberInetPassword)
                        {
                            pArgs->fRememberInetPassword = TRUE;

                            CmDecodePassword(pArgs->szInetPassword);
                            
                            //
                            // Compare to 16 *'s. We don't want to resave if we have 16 *'s
                            // otherwise the user will get an auth-retry.
                            //
                            if (0 != lstrcmpU(c_pszSavedPasswordToken, pArgs->szInetPassword))
                            {
                                // 
                                // No need to save the domain
                                //
                                rcInet.dwMask = dwInetCurrentMask;
                                lstrcpyU(rcInet.szUserName, pArgs->szInetUserName);
                                lstrcpyU(rcInet.szPassword, pArgs->szInetPassword);
                                
                                dwRetInet = pArgs->rlsRasLink.pfnSetCredentials(pszPrivatePhoneBook, pszConnectoid, &rcInet, FALSE);
                            }
                            CmEncodePassword(pArgs->szInetPassword);
                        }
                    }
                }
            }
     
            
            
            if ((ERROR_CANNOT_FIND_PHONEBOOK_ENTRY == dwRetInet) && pszPrivatePhoneBook)
            {
                //
                //  Then the phonebook entry doesn't exist yet, lets create it.
                //
                LPRASENTRY pRasEntry = (LPRASENTRY)CmMalloc(sizeof(RASENTRY));

                if (pRasEntry && pArgs->rlsRasLink.pfnSetEntryProperties)
                {
                    pRasEntry->dwSize = sizeof(RASENTRY);
                    dwRetInet = pArgs->rlsRasLink.pfnSetEntryProperties(pszPrivatePhoneBook, pszConnectoid, pRasEntry, pRasEntry->dwSize, NULL, 0);

                    //
                    //  Lets try to set the credentials one more time ...
                    //
                    if (ERROR_SUCCESS == dwRetInet)
                    {
                        //
                        // dwMask needs to be reassigned, the previous call modifies the mask
                        //
                        rcInet.dwMask = dwInetCurrentMask;   
                        dwRetInet = pArgs->rlsRasLink.pfnSetCredentials(pszPrivatePhoneBook, pszConnectoid, &rcInet, FALSE);
                    }

                    CmFree(pRasEntry);
                }
            }

            if (ERROR_SUCCESS == dwRet)
            {
                //
                // Only set the existance flags if we are saving the password and everything 
                // succeeded
                //
                if (pArgs->fRememberMainPassword)
                {
                    if (CM_CREDS_GLOBAL == pArgs->dwCurrentCredentialType)
                    {
                        pArgs->dwExistingCredentials |= CM_EXIST_CREDS_MAIN_GLOBAL;
                        
                        if (pArgs->fUseSameUserName && (ERROR_SUCCESS == dwRetInet))
                        {
                            pArgs->dwExistingCredentials |= CM_EXIST_CREDS_INET_GLOBAL;
                        }
                    }
                    else
                    {
                        pArgs->dwExistingCredentials |= CM_EXIST_CREDS_MAIN_USER;
                        
                        if (pArgs->fUseSameUserName && (ERROR_SUCCESS == dwRetInet))
                        {
                            pArgs->dwExistingCredentials |= CM_EXIST_CREDS_INET_USER;
                        }
                    }
                }
            }
            CmFree(pszPrivatePhoneBook);
        }
        CmFree(pszConnectoid);
    }

    ZeroMemory(rc.szPassword, sizeof(rc.szPassword));
    ZeroMemory(rcInet.szPassword, sizeof(rcInet.szPassword));

    return;
}

//----------------------------------------------------------------------------
//
//  Function:   GetUserInfoFromDialog 
//
//  Synopsis:   Gets the user information from the editboxes into pArgs 
//              structure. Then it copies the info into rascredentials
//              structure. If the password is 16 *'s then we clear
//              the password mask in the rascredentials in order not to save
//              the password.
//
//  Arguments:  pArgs                   - ptr to ArgsStruct
//              hwndDlg                 - HWND to dialog
//              prc                     - [IN/OUT] rascredentials structure 
//
//  Returns:    NONE
//
//  History:    03/24/2001  tomkel      Created
//
//----------------------------------------------------------------------------
VOID GetUserInfoFromDialog(ArgsStruct *pArgs, HWND hwndDlg, RASCREDENTIALS *prc)
{
    if (NULL == pArgs || NULL == hwndDlg || NULL == prc)
    {
        MYDBGASSERT(pArgs && hwndDlg && prc);
        return;
    }
    
    //
    // Process Password info, if any. 
    //
    HWND hwndPassword = GetDlgItem(hwndDlg, IDC_MAIN_PASSWORD_EDIT);

    if (hwndPassword)
    {
        //
        // Get the latest password data from the edit control 
        // and obfuscate its contents so that connect actions
        // can't retrieve it.
        //

        GetPasswordFromEdit(pArgs);     // fills pArgs->szPassword            
        ObfuscatePasswordEdit(pArgs);   // sets *'s into the password edit box

        //
        // Check if we have 16 *'s
        //
        CmDecodePassword(pArgs->szPassword);
        if ((0 == lstrcmpU(c_pszSavedPasswordToken, pArgs->szPassword)) && 
            (FALSE == SendMessageU(hwndPassword, EM_GETMODIFY, 0L, 0L)))
        {
            //
            // We have 16 *'s and the user hasn't modified the editbox. This 
            // password is from the RAS cred store, so we don't want to save the 16 *'s 
            //
            prc->dwMask &= ~RASCM_Password;
        }
        CmEncodePassword(pArgs->szPassword);
    }

    //
    // Process UserName info, if any
    //

    HWND hwndUserName = GetDlgItem(hwndDlg, IDC_MAIN_USERNAME_EDIT);
    if (hwndUserName)
    {
        LPTSTR pszUsername = CmGetWindowTextAlloc(hwndDlg, IDC_MAIN_USERNAME_EDIT);

        lstrcpyU(pArgs->szUserName, pszUsername);
        
        CmFree(pszUsername);
    }
    
    //
    // Process Domain info, if any
    //
    HWND hwndDomain = GetDlgItem(hwndDlg, IDC_MAIN_DOMAIN_EDIT);
    if (hwndDomain) 
    {
        LPTSTR pszDomain = CmGetWindowTextAlloc(hwndDlg,IDC_MAIN_DOMAIN_EDIT);

        lstrcpyU(pArgs->szDomain, pszDomain);
 
        CmFree(pszDomain);
    }

    //
    // This needs to be separate because in some cases 
    // the editboxes will not exist on the dialog, but we still need to save the info
    // from the pArgs structure into RASCREDENTIALS.
    //
    lstrcpyU(prc->szUserName, pArgs->szUserName);
    lstrcpyU(prc->szDomain, pArgs->szDomain);
    CmDecodePassword(pArgs->szPassword);
    lstrcpyU(prc->szPassword, pArgs->szPassword);
    CmEncodePassword(pArgs->szPassword);
    
}

//----------------------------------------------------------------------------
//
//  Function:   SwitchToLocalCreds 
//
//  Synopsis:   Clear the password, but only if it wasn't recently modified
//              only then we can reuse and resave it. That's because when
//              we switch credential stores, the value of the szPassword 
//              is what was read from the RAS cred store (16 *'s). It doesn't 
//              make sense to save this value into a new user RAS creds store. If the 
//              password already existed there, then it's fine.
//              In case the user modified the password text box and then decided
//              to swich, the modification flag will be on, so we'll assume that the
//              user entered a valid password and that it wasn't read in from the 
//              creds store.
//              The actual deletion of credential happnes once the user clicks 
//              the connect button. Here we just clear things out of memory
//              and update the UI. We also need to update the remember Internet
//              flag based on if the Internet credential exist. This is so the
//              UI stays consistent with what credentials are loaded in memory.
//
//  Arguments:  pArgs                   - ptr to ArgsStruct
//              hwndDlg                 - HWND to dialog
//              fSwitchToGlobal         - used to ignore the check which credential
//                                        store is currently active
//
//  Returns:    NONE
//
//  History:    03/24/2001  tomkel      Created
//
//----------------------------------------------------------------------------
VOID SwitchToLocalCreds(ArgsStruct *pArgs, HWND hwndDlg, BOOL fSwitchToLocal)
{
    if (NULL == pArgs || NULL == hwndDlg)
    {
        return;   
    }

    //
    // Switching to using Single-User credentials
    //

    //
    // Check that previously the default was the Global creds store
    //
    if (CM_CREDS_GLOBAL == pArgs->dwCurrentCredentialType || fSwitchToLocal)
    {
        pArgs->dwCurrentCredentialType = CM_CREDS_USER;

        HWND hwndTemp = GetDlgItem(hwndDlg, IDC_MAIN_PASSWORD_EDIT);
        BOOL fPWChanged = FALSE;

        if (hwndTemp)
        {
            //
            // Don't use Edit_GetModify. This needs need to run on Win9x so call
            // SendMessageU
            //
            fPWChanged = (BOOL) SendMessageU(hwndTemp, EM_GETMODIFY, 0L, 0L);
            if (FALSE == fPWChanged)
            {
                pArgs->fIgnoreChangeNotification = TRUE;
                CmWipePassword(pArgs->szPassword);
                SetDlgItemTextU(hwndDlg, IDC_MAIN_PASSWORD_EDIT, TEXT(""));
                pArgs->fIgnoreChangeNotification = FALSE;
            }
        }
        
        if (FALSE == fPWChanged)
        {
            //
            // Only if Password field didn't change
            //
            if (OS_NT51)
            {
                //
                // Wipe the Internet password - since we are switching from globals
                // or we are using the same user name the Inet password will get re-populated
                // from the main password, otherwise the user needs to set this password in 
                // the InetDialog.
                //
                CmWipePassword(pArgs->szInetPassword); 
                pArgs->fRememberInetPassword = FALSE;

                //
                // Only reload if main user creds exist
                //
                if (pArgs->dwExistingCredentials & CM_EXIST_CREDS_MAIN_USER)
                {
                    if (pArgs->dwExistingCredentials & CM_EXIST_CREDS_INET_USER)
                    {
                        ReloadCredentials(pArgs, hwndDlg, CM_CREDS_TYPE_BOTH);
                        pArgs->fRememberInetPassword = TRUE;
                    }
                    else
                    {
                        ReloadCredentials(pArgs, hwndDlg, CM_CREDS_TYPE_MAIN);
                    }
                }
                else
                {
                    if (pArgs->dwExistingCredentials & CM_EXIST_CREDS_INET_USER)
                    {
                        ReloadCredentials(pArgs, hwndDlg, CM_CREDS_TYPE_INET);
                        pArgs->fRememberInetPassword = TRUE;
                    }
                    else
                    {
                        pArgs->fRememberInetPassword = FALSE;
                    }
                }
            }
            else
            {
                ReloadCredentials(pArgs, hwndDlg, CM_CREDS_TYPE_BOTH);
            }
        }
        else
        {
            if (OS_NT51)
            {
                if (pArgs->dwExistingCredentials & CM_EXIST_CREDS_INET_USER)
                {
                    ReloadCredentials(pArgs, hwndDlg, CM_CREDS_TYPE_INET);
                    pArgs->fRememberInetPassword = TRUE;
                }
                else
                {
                    pArgs->fRememberInetPassword = FALSE;
                }
            }
            else
            {
                ReloadCredentials(pArgs, hwndDlg, CM_CREDS_TYPE_INET);
            }
        }
    }
}

//----------------------------------------------------------------------------
//
//  Function:   SwitchToGlobalCreds 
//
//  Synopsis:   Clear the password and reload the credentials if they exist.
//              Otherwise we clear the password if it hasn't been modified by
//              the user.
//
//  Arguments:  pArgs                   - ptr to ArgsStruct
//              hwndDlg                 - HWND to dialog
//              fSwitchToGlobal         - used to ignore the check which credential
//                                        store is currently active
//
//  Returns:    NONE
//
//  History:    03/24/2001  tomkel      Created
//
//----------------------------------------------------------------------------
VOID SwitchToGlobalCreds(ArgsStruct *pArgs, HWND hwndDlg, BOOL fSwitchToGlobal)
{
    if (NULL == pArgs || NULL == hwndDlg)
    {
        return;   
    }

    //
    // This should only be called on WinXP+
    //
    if (!OS_NT51)
    {
        MYDBGASSERT(FALSE);        
        return;
    }

    //
    // Switching to using Global credentials
    //

    //
    // Check that previously the default was the User creds store
    //
    if (CM_CREDS_USER == pArgs->dwCurrentCredentialType || fSwitchToGlobal)
    {
        pArgs->dwCurrentCredentialType = CM_CREDS_GLOBAL;
    
        if (pArgs->dwExistingCredentials & CM_EXIST_CREDS_MAIN_GLOBAL)
        {
            CmWipePassword(pArgs->szPassword);
            CmWipePassword(pArgs->szInetPassword);
            pArgs->fRememberInetPassword = FALSE;

            //
            // Globals exist 
            //
            if (pArgs->dwExistingCredentials & CM_EXIST_CREDS_INET_GLOBAL)
            {
                //
                // Both exist - reload both
                //
                ReloadCredentials(pArgs, hwndDlg, CM_CREDS_TYPE_BOTH);
                pArgs->fRememberInetPassword = TRUE;
            }
            else
            {
                //
                // User Globals - exist, reload
                // Internet Globals - don't exist, clear password
                //
                ReloadCredentials(pArgs, hwndDlg, CM_CREDS_TYPE_MAIN);
            }
        }
        else
        {
            HWND hwndPassword = GetDlgItem(hwndDlg, IDC_MAIN_PASSWORD_EDIT);

            pArgs->fIgnoreChangeNotification = TRUE;
            CmWipePassword(pArgs->szInetPassword);
            pArgs->fRememberInetPassword = FALSE;

            if (pArgs->dwExistingCredentials & CM_EXIST_CREDS_INET_GLOBAL)
            {
                //
                // User Globals - don't exist - clear password
                // Internet Globals - exist - reload
                //
                RefreshCredentialInfo(pArgs, CM_CREDS_TYPE_INET);
                
                //
                // In case user inet creds didn't exist, we should 
                //
                pArgs->fRememberInetPassword = TRUE;
            }
            
            //
            // Clear the main password only if it wasn't recently modified
            //
            if (hwndPassword)
            {
                if (FALSE == SendMessageU(hwndPassword, EM_GETMODIFY, 0L, 0L))
                {
                    CmWipePassword(pArgs->szPassword);
                    SetDlgItemTextU(hwndDlg, IDC_MAIN_PASSWORD_EDIT, TEXT(""));
                }
            }

            pArgs->fIgnoreChangeNotification = FALSE;
        }
    }
}

//----------------------------------------------------------------------------
//
//  Function:   ReloadCredentials 
//
//  Synopsis:   Wrapper to reload credentials into the editboxes
//
//  Arguments:  pArgs                   - ptr to ArgsStruct
//              hwndDlg                 - HWND to dialog
//              dwWhichCredType         - type of credential to reload
//
//  Returns:    NONE
//
//  History:    03/24/2001  tomkel      Created
//
//----------------------------------------------------------------------------
VOID ReloadCredentials(ArgsStruct *pArgs, HWND hwndDlg, DWORD dwWhichCredType)
{
    if (NULL == pArgs || NULL == hwndDlg)
    {
        MYDBGASSERT(pArgs && hwndDlg);
        return;
    }

    pArgs->fIgnoreChangeNotification = TRUE;
    RefreshCredentialInfo(pArgs, dwWhichCredType);
    SetMainDlgUserInfo(pArgs, hwndDlg);
    pArgs->fIgnoreChangeNotification = FALSE;
}

//----------------------------------------------------------------------------
//
//  Function:   VerifyAdvancedTabSettings 
//
//  Synopsis:   Verifies and possibly modifed the connection's ICF/ICS settings
//              based on what was configured in the .cms file. These functions
//              depend on the hnetcfg objects and private/internal interfaces.
//              We got them from the homenet team.
//              Some parts of the code were taken from:
//              nt\net\homenet\config\dll\saui.cpp
//
//  Arguments:  pArgs                   - ptr to ArgsStruct
//
//  Returns:    NONE
//
//  History:    04/26/2001  tomkel      Created
//
//----------------------------------------------------------------------------
VOID VerifyAdvancedTabSettings(ArgsStruct *pArgs)
{

#ifndef _WIN64
    
    HRESULT hr;
    IHNetConnection *pHNetConn = NULL;
    IHNetCfgMgr *pHNetCfgMgr = NULL;
    INetConnectionUiUtilities* pncuu = NULL;
    BOOL fCOMInitialized = FALSE;    
    BOOL fEnableICF = FALSE;
    BOOL fDisableICS = FALSE;
    BOOL fAllowUserToModifySettings = TRUE;
    
    if (OS_NT51) 
    {
        CMTRACE(TEXT("VerifyAdvancedTabSettings()"));
        //
        // Check rights - taken from saui.cpp
        //
        if (FALSE == IsAdmin())
        {
            return;
        }

        fEnableICF = pArgs->piniService->GPPB(c_pszCmSection, 
                                                c_pszCmEntryEnableICF, 
                                                FALSE);

        fDisableICS = pArgs->piniService->GPPB(c_pszCmSection, 
                                                c_pszCmEntryDisableICS, 
                                                FALSE);

        
        if (fEnableICF || fDisableICS)
        {
            hr = CoInitialize(NULL);
            if (S_OK == hr)
            {
                CMTRACE(TEXT("VerifyAdvancedTabSettings - Correctly Initialized COM."));
                fCOMInitialized = TRUE;
            }
            else if (S_FALSE == hr)
            {
                CMTRACE(TEXT("VerifyAdvancedTabSettings - This concurrency model is already initialized. CoInitialize returned S_FALSE."));
                fCOMInitialized = TRUE;
                hr = S_OK;
            }
            else if (RPC_E_CHANGED_MODE == hr)
            {
                CMTRACE1(TEXT("VerifyAdvancedTabSettings - Using different concurrency model. Did not initialize COM - RPC_E_CHANGED_MODE. hr=0x%x"), hr);
                hr = S_OK;
            }
            else
            {
                CMTRACE1(TEXT("VerifyAdvancedTabSettings - Failed to Initialized COM. hr=0x%x"), hr);
            }
    
            if (SUCCEEDED(hr))
            {
                //
                // Check user permissions. Needed to initialize COM first
                // Check if ZAW is denying access to the Shared Access UI - taken from saui.cpp
                //
                hr = HrCreateNetConnectionUtilities(&pncuu);
                if (SUCCEEDED(hr) && pncuu)
                {
                    fEnableICF = (BOOL)(fEnableICF && pncuu->UserHasPermission(NCPERM_PersonalFirewallConfig));
                    fDisableICS = (BOOL)(fDisableICS && pncuu->UserHasPermission(NCPERM_ShowSharedAccessUi));

                    if ((FALSE == fEnableICF) && (FALSE == fDisableICS))
                    {
                        goto done;
                    }
                }

                //
                // Create the home networking configuration manager
                //
                hr = CoCreateInstance(CLSID_HNetCfgMgr, NULL, CLSCTX_ALL,
                                      IID_IHNetCfgMgr, (void**)&pHNetCfgMgr);
                if (SUCCEEDED(hr))
                {
                    //
                    // Convert the entry to an IHNetConnection
                    //
                    CMTRACE(TEXT("VerifyAdvancedTabSettings - Created CLSID_HNetCfgMgr object."));
                    GUID *pGuid = NULL;
                    LPRASENTRY pRasEntry = MyRGEP(pArgs->pszRasPbk, pArgs->szServiceName, &pArgs->rlsRasLink);

                    if (pRasEntry && sizeof(RASENTRY_V501) >= pRasEntry->dwSize)
                    {
                        //
                        // Get the pGuid value
                        //
                        pGuid = &(((LPRASENTRY_V501)pRasEntry)->guidId);
                
                        hr = pHNetCfgMgr->GetIHNetConnectionForGuid(pGuid, FALSE, TRUE, &pHNetConn);
                        if (SUCCEEDED(hr) && pHNetConn) 
                        {
                            if (fEnableICF)
                            {   
                                EnableInternetFirewall(pHNetConn);
                            }

                            if (fDisableICS)
                            {
                                DisableSharing(pHNetConn);
                            }
                        }
                        else
                        {
                            CMTRACE1(TEXT("VerifyAdvancedTabSettings() - Call to pHNetCfgMgr->GetIHNetConnectionForGuid returned an error. hr=0x%x"), hr);
                        }
                    }
                    else
                    {
                        CMTRACE(TEXT("VerifyAdvancedTabSettings - Failed to LoadRAS Entry."));
                    }
            
                    CmFree(pRasEntry);
                    pRasEntry = NULL;
                }
                else
                {
                    CMTRACE(TEXT("VerifyAdvancedTabSettings - Failed to create CLSID_HNetCfgMgr object."));
                }
            }
        }

done:
        //
        // Clean up and Uninitilize COM
        //
        if (pHNetConn)
        {
            pHNetConn->Release();
            pHNetConn = NULL;
        }

        if (pHNetCfgMgr)
        {
            pHNetCfgMgr->Release();
            pHNetCfgMgr = NULL;
        }

        if (pncuu)
        {
            pncuu->Release();
            pncuu = NULL;    
        }
    
        if (fCOMInitialized)
        {
            CoUninitialize(); 
        }
    }

#endif // _WIN64

}


//----------------------------------------------------------------------------
//
//  Function:   FindINetConnectionByGuid 
//
//  Synopsis:   Retrieves the INetConnection that corresponds to the given GUID.
//
//  Arguments:  pGuid - the guid of the connection
//              ppNetCon - receives the interface
//
//  Returns:    HRESULT
//
//  History:    04/26/2001  tomkel      Taken & modified from nt\net\homenet\config\dll\hnapi.cpp
//
//----------------------------------------------------------------------------
HRESULT FindINetConnectionByGuid(GUID *pGuid, INetConnection **ppNetCon)
{
    HRESULT hr;
    INetConnectionManager *pManager = NULL;
    IEnumNetConnection *pEnum = NULL;
    INetConnection *pConn = NULL;

    if (NULL == ppNetCon)
    {
        hr = E_INVALIDARG;
    }
    else if (NULL == pGuid)
    {
        hr = E_POINTER;
    }
    else
    {
        //
        // Get the net connections manager
        //

        hr = CoCreateInstance(
                CLSID_ConnectionManager,
                NULL,
                CLSCTX_ALL,
                IID_INetConnectionManager,
                (void**)&pManager);

        if (S_OK == hr)
        {
            //
            // Get the enumeration of connections
            //

            SetProxyBlanket(pManager);

            hr = pManager->EnumConnections(NCME_DEFAULT, &pEnum);

            pManager->Release();
        }

        if (S_OK == hr)
        {
            //
            // Search for the connection with the correct guid
            //

            ULONG ulCount;
            BOOLEAN fFound = FALSE;

            SetProxyBlanket(pEnum);

            do
            {
                NETCON_PROPERTIES *pProps = NULL;

                hr = pEnum->Next(1, &pConn, &ulCount);
                if (SUCCEEDED(hr) && 1 == ulCount)
                {
                    SetProxyBlanket(pConn);

                    hr = pConn->GetProperties(&pProps);
                    if (S_OK == hr)
                    {
                        if (IsEqualGUID(pProps->guidId, *pGuid))
                        {
                            fFound = TRUE;
                            *ppNetCon = pConn;
                            (*ppNetCon)->AddRef();
                        }

                        if (pProps)
                        {
                            CoTaskMemFree (pProps->pszwName);
                            CoTaskMemFree (pProps->pszwDeviceName);
                            CoTaskMemFree (pProps);
                        }
                    }

                    pConn->Release();
                }
            }
            while (FALSE == fFound && SUCCEEDED(hr) && 1 == ulCount);

            //
            // Normalize hr
            //

            hr = (fFound ? S_OK : E_FAIL);

            pEnum->Release();
        }
    }

    return hr;
}

//----------------------------------------------------------------------------
//
//  Function:   SetProxyBlanket 
//
//  Synopsis:   Sets the standard COM security settings on the proxy for an object.
//
//  Arguments:  pUnk - the object to set the proxy blanket on
//
//  Returns:    None. Even if the CoSetProxyBlanket calls fail, pUnk remains
//              in a usable state. Failure is expected in certain contexts, such
//              as when, for example, we're being called w/in the netman process --
//              in this case, we have direct pointers to the netman objects, instead
//              of going through a proxy.
//
//  History:    04/26/2001  tomkel      Taken & modified from nt\net\homenet\config\dll\hnapi.cpp
//
//----------------------------------------------------------------------------
VOID SetProxyBlanket(IUnknown *pUnk)
{
    HRESULT hr;

    if (NULL == pUnk)
    {
        return;
    }

    hr = CoSetProxyBlanket(
            pUnk,
            RPC_C_AUTHN_WINNT,      // use NT default security
            RPC_C_AUTHZ_NONE,       // use NT default authentication
            NULL,                   // must be null if default
            RPC_C_AUTHN_LEVEL_CALL, // call
            RPC_C_IMP_LEVEL_IMPERSONATE,
            NULL,                   // use process token
            EOAC_NONE
            );

    if (SUCCEEDED(hr))
    {
        IUnknown * pUnkSet = NULL;
        hr = pUnk->QueryInterface(&pUnkSet);
        if (SUCCEEDED(hr))
        {
            hr = CoSetProxyBlanket(
                    pUnkSet,
                    RPC_C_AUTHN_WINNT,      // use NT default security
                    RPC_C_AUTHZ_NONE,       // use NT default authentication
                    NULL,                   // must be null if default
                    RPC_C_AUTHN_LEVEL_CALL, // call
                    RPC_C_IMP_LEVEL_IMPERSONATE,
                    NULL,                   // use process token
                    EOAC_NONE
                    );

            pUnkSet->Release();
        }
    }
}

//----------------------------------------------------------------------------
//
//  Function:   EnableInternetFirewall 
//
//  Synopsis:   Taken from :  CNetSharingConfiguration::EnableInternetFirewall
//              This is part of the internal api.  
//
//  Arguments:  pHNetConn - HNetConnection
//
//  Returns:    None. 
//
//  History:    04/26/2001  tomkel      Taken & modified from nt\net\homenet\config\dll\hnapi.cpp
//
//----------------------------------------------------------------------------
VOID EnableInternetFirewall(IHNetConnection *pHNetConn)
{
    HRESULT hr = S_FALSE;
    BOOLEAN bEnabled = FALSE;

    if (NULL == pHNetConn)
    {
        return;
    }

    hr = InternalGetFirewallEnabled(pHNetConn, &bEnabled);

    if (SUCCEEDED(hr) && !bEnabled) 
    {
        IHNetFirewalledConnection* pFirewalledConnection = NULL;

        hr = pHNetConn->Firewall(&pFirewalledConnection);

        if (SUCCEEDED(hr))
        {
            if (pFirewalledConnection)
            {
                pFirewalledConnection->Release();
                pFirewalledConnection = NULL;
            }
        }
    }
}

//----------------------------------------------------------------------------
//
//  Function:   InternalGetFirewallEnabled 
//
//  Synopsis:   Taken from :  CNetSharingConfiguration::EnableInternetFirewall
//
//  Arguments:  pHNetConnection - HNetConnection
//              pbEnabled - [out] whether the Firewall is enabled
//
//  Returns:    HRESULT 
//
//  History:    04/26/2001  tomkel      Taken & modified from nt\net\homenet\config\dll\hnapi.cpp
//
//----------------------------------------------------------------------------
HRESULT InternalGetFirewallEnabled(IHNetConnection *pHNetConnection, BOOLEAN *pbEnabled)
{
    HRESULT hr;
    HNET_CONN_PROPERTIES* pProps = NULL;

    if (NULL == pHNetConnection)
    {
        hr = E_INVALIDARG;
    }
    else if (NULL == pbEnabled)
    {
        hr = E_POINTER;
    }
    else
    {
        *pbEnabled = FALSE;

        hr = pHNetConnection->GetProperties(&pProps);

        if (SUCCEEDED(hr))
        {
            if (pProps->fFirewalled)
            {
                *pbEnabled = TRUE;
            }

            CoTaskMemFree(pProps);
        }
    }

    return hr;
}

//----------------------------------------------------------------------------
//
//  Function:   DisableSharing 
//
//  Synopsis:   Taken from :  CNetSharingConfiguration::EnableInternetFirewall
//
//  Arguments:  pHNetConn - HNetConnection 
//
//  Returns:    HRESULT 
//
//  History:    04/26/2001  tomkel      Taken & modified from nt\net\homenet\config\dll\hnapi.cpp
//
//----------------------------------------------------------------------------
STDMETHODIMP DisableSharing(IHNetConnection *pHNetConn)
{
    HRESULT hr;

    BOOLEAN bEnabled = FALSE;

    SHARINGCONNECTIONTYPE Type;

    if (NULL == pHNetConn)
    {
        return E_INVALIDARG;
    }
    
    hr = InternalGetSharingEnabled(pHNetConn, &bEnabled, &Type);

    if (SUCCEEDED(hr) && bEnabled ) 
    {
        switch(Type)
        {
        case ICSSHARINGTYPE_PUBLIC:
        {
            IHNetIcsPublicConnection* pPublicConnection = NULL;

            hr = pHNetConn->GetControlInterface( 
                            __uuidof(IHNetIcsPublicConnection), 
                            reinterpret_cast<void**>(&pPublicConnection) );

            if (SUCCEEDED(hr))
            {
                hr = pPublicConnection->Unshare();

                if (pPublicConnection)
                {
                    pPublicConnection->Release();
                    pPublicConnection = NULL;
                }
            }
        }
        break;

        case ICSSHARINGTYPE_PRIVATE:
        {
            IHNetIcsPrivateConnection* pPrivateConnection = NULL;

            hr = pHNetConn->GetControlInterface( 
                        __uuidof(IHNetIcsPrivateConnection), 
                        reinterpret_cast<void**>(&pPrivateConnection) );

            if (SUCCEEDED(hr))
            {
                hr = pPrivateConnection->RemoveFromIcs();

                if (pPrivateConnection)
                {
                    pPrivateConnection->Release();
                    pPrivateConnection = NULL;
                }
            }
        }
        break;

        default:
            hr = E_UNEXPECTED;
        }
    }

    return hr;
}

//----------------------------------------------------------------------------
//
//  Function:   InternalGetSharingEnabled 
//
//  Synopsis:   Returns whether sharing is enabled on a given connection
//
//  Arguments:  pHNetConnection - HNetConnection 
//              pbEnabled - [out] returns the value
//              pType - type of connection
//
//  Returns:    HRESULT 
//
//  History:    04/26/2001  tomkel      Taken & modified from nt\net\homenet\config\dll\hnapi.cpp
//
//----------------------------------------------------------------------------
HRESULT InternalGetSharingEnabled(IHNetConnection *pHNetConnection, BOOLEAN *pbEnabled, SHARINGCONNECTIONTYPE* pType)
{
    HRESULT               hr;
    HNET_CONN_PROPERTIES* pProps;

    if (NULL == pHNetConnection)
    {
        hr = E_INVALIDARG;
    }
    else if ((NULL == pbEnabled) || (NULL == pType))
    {
        hr = E_POINTER;
    }
    else
    {
        *pbEnabled = FALSE;
        *pType     = ICSSHARINGTYPE_PUBLIC;

        hr = pHNetConnection->GetProperties(&pProps);

        if (SUCCEEDED(hr))
        {
            if (pProps->fIcsPublic)
            {
                *pbEnabled = TRUE;
                *pType     = ICSSHARINGTYPE_PUBLIC;
            }
            else if (pProps->fIcsPrivate)
            {
                *pbEnabled = TRUE;
                *pType     = ICSSHARINGTYPE_PRIVATE;
            }

            CoTaskMemFree(pProps);
        }
    }

    return hr;
}

//----------------------------------------------------------------------------
//
//  Function:   HrCreateNetConnectionUtilities 
//
//  Synopsis:   Returns the pointer to the connection ui utilities object
//
//  Arguments:  ppncuu - pointer to INetConnectionUiUtilities object
//
//  Returns:    HRESULT 
//
//  History:    04/26/2001  tomkel      Taken & modified from nt\net\homenet\config\dll\saui.cpp
//
//----------------------------------------------------------------------------
HRESULT APIENTRY HrCreateNetConnectionUtilities(INetConnectionUiUtilities ** ppncuu)
{
    HRESULT hr = E_INVALIDARG;

    if (ppncuu)
    {
        hr = CoCreateInstance (CLSID_NetConnectionUiUtilities, NULL,
                               CLSCTX_INPROC_SERVER,
                               IID_INetConnectionUiUtilities, (void**)ppncuu);
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  IsMemberOfGroup
//
// Synopsis:  This function return TRUE if the current user is a member of 
//            the passed and FALSE passed in Group RID.
//
// Arguments: DWORD dwGroupRID -- the RID of the group to check membership of
//            BOOL bUseBuiltinDomainRid -- whether the SECURITY_BUILTIN_DOMAIN_RID
//                                         RID should be used to build the Group
//                                         SID
//
// Returns:   BOOL - TRUE if the user is a member of the specified group
//
// History:   quintinb  Shamelessly stolen from MSDN            02/19/98
//            quintinb  Reworked and renamed                    06/18/99
//                      to apply to more than just Admins 
//            quintinb  Rewrote to use CheckTokenMemberShip     08/18/99
//                      since the MSDN method was no longer
//                      correct on NT5 -- 389229
//            tomkel    Taken from cmstp and modified for use   05/09/2001
//                      here
//
//+----------------------------------------------------------------------------
BOOL IsMemberOfGroup(DWORD dwGroupRID, BOOL bUseBuiltinDomainRid)
{
    PSID psidGroup = NULL;
    SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;
    BOOL bSuccess = FALSE;

    if (OS_NT5)
    {
        //
        //  Make a SID for the Group we are checking for, Note that we if we need the Built 
        //  in Domain RID (for Groups like Administrators, PowerUsers, Users, etc)
        //  then we will have two entries to pass to AllocateAndInitializeSid.  Otherwise,
        //  (for groups like Authenticated Users) we will only have one.
        //
        BYTE byNum;
        DWORD dwFirstRID;
        DWORD dwSecondRID;

        if (bUseBuiltinDomainRid)
        {
            byNum = 2;
            dwFirstRID = SECURITY_BUILTIN_DOMAIN_RID;
            dwSecondRID = dwGroupRID;
        }
        else
        {
            byNum = 1;
            dwFirstRID = dwGroupRID;
            dwSecondRID = 0;
        }

        if (AllocateAndInitializeSid(&siaNtAuthority, byNum, dwFirstRID, dwSecondRID,
                                     0, 0, 0, 0, 0, 0, &psidGroup))

        {
            //
            //  Now we need to dynamically load the CheckTokenMemberShip API from 
            //  advapi32.dll since it is a Win2k only API.
            //        
            HMODULE hAdvapi = LoadLibraryExU(TEXT("advapi32.dll"), NULL, 0);

            if (hAdvapi)
            {
                typedef BOOL (WINAPI *pfnCheckTokenMembershipSpec)(HANDLE, PSID, PBOOL);
                pfnCheckTokenMembershipSpec pfnCheckTokenMembership;

                pfnCheckTokenMembership = (pfnCheckTokenMembershipSpec)GetProcAddress(hAdvapi, "CheckTokenMembership");

                if (pfnCheckTokenMembership)
                {
                    //
                    //  Check to see if the user is actually a member of the group in question
                    //
                    if (!(pfnCheckTokenMembership)(NULL, psidGroup, &bSuccess))
                    {
                        bSuccess = FALSE;
                        CMASSERTMSG(FALSE, TEXT("CheckTokenMemberShip Failed."));
                    }            
                }   
                else
                {
                    CMASSERTMSG(FALSE, TEXT("IsMemberOfGroup -- GetProcAddress failed for CheckTokenMemberShip"));
                }
            }
            else
            {
                CMASSERTMSG(FALSE, TEXT("IsMemberOfGroup -- Unable to get the module handle for advapi32.dll"));            
            }

            FreeSid (psidGroup);

            if (hAdvapi)
            {
                FreeLibrary(hAdvapi);
            }
        }
    }

    return bSuccess;
}



//+----------------------------------------------------------------------------
//
// Function:  IsAdmin
//
// Synopsis:  Check to see if the user is a member of the Administrators group
//            or not.
//
// Arguments: None
//
// Returns:   BOOL - TRUE if the current user is an Administrator
//
// History:   quintinb Created Header    8/18/99
//            tomkel    Taken from cmstp 05/09/2001
//
//+----------------------------------------------------------------------------
BOOL IsAdmin(VOID)
{
    return IsMemberOfGroup(DOMAIN_ALIAS_RID_ADMINS, TRUE); // TRUE == bUseBuiltinDomainRid
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmdial\dialogs.cpp ===
//+----------------------------------------------------------------------------
//
// File:     dialogs.cpp
//
// Module:   CMDIAL32.DLL
//
// Synopsis: This module contains the code for the implementing the Dialog UI
//           functionality of Connection Manager.
//
// Copyright (c) 1996-1999 Microsoft Corporation
//
// Author:   quintinb    Created Header   8/17/99
//
//+----------------------------------------------------------------------------
#include "cmmaster.h"
#include "dialogs.h"
#include "pnpuverp.h"
#include "dial_str.h"
#include "mon_str.h"
#include "stp_str.h"
#include "ras_str.h"
#include "profile_str.h"
#include "log_str.h"
#include "tunl_str.h"
#include "userinfo_str.h"

//
//  Get the common function HasSpecifiedAccessToFileOrDir
//
#include "hasfileaccess.cpp"

#include <pshpack1.h>
typedef struct DLGTEMPLATEEX
{
    WORD dlgVer;
    WORD signature;
    DWORD helpID;
    DWORD exStyle;
    DWORD style;
    WORD cDlgItems;
    short x;
    short y;
    short cx;
    short cy;
} DLGTEMPLATEEX, *LPDLGTEMPLATEEX;
#include <poppack.h>

//
// Timeout for the write properties mutex, in milliseconds
//
const DWORD WRITE_PROPERTIES_MUTEX_TIMEOUT = 1000*10;

//************************************************************************
// Globals
//************************************************************************

//
// Original edit control and property sheet window procedures
//

WNDPROC CGeneralPage::m_pfnOrgEditWndProc = NULL;
WNDPROC CNewAccessPointDlg::m_pfnOrgEditWndProc = NULL;
WNDPROC CPropertiesSheet::m_pfnOrgPropSheetProc = NULL;            // prop sheet
CPropertiesSheet* CPropertiesSheet::m_pThis = NULL; 

//+---------------------------------------------------------------------------
//
//  Function:   CGeneralPage::UpdateNumberDescription
//
//  Synopsis:   Helper function to deal with updating the description edit,
//              by appending to the Phone Number: and Backup Number: labels
//
//  Arguments:  int nPhoneIdx - index of phone number to which this applies
//
//  Returns:    Nothing
//
//  History:    nickball - Created - 7/17/97
//
//----------------------------------------------------------------------------

void CGeneralPage::UpdateNumberDescription(int nPhoneIdx, LPCTSTR pszDesc)
{
    MYDBGASSERT(pszDesc);
    
    if (NULL == pszDesc)
    {
        return;
    }

    UINT nDescID = !nPhoneIdx ? IDC_GENERAL_P1_STATIC: IDC_GENERAL_P2_STATIC;
    
    LPTSTR pszTmp;

    //
    // Load the appropriate label as a base string
    //

    if (nPhoneIdx)
    {
        pszTmp = CmLoadString(g_hInst, IDS_BACKUP_NUM_LABEL);
    }
    else
    {
        pszTmp = CmLoadString(g_hInst, IDS_PHONE_NUM_LABEL);
    }
    
    MYDBGASSERT(pszTmp);

    if (pszTmp)
    {
        //
        // Append the description and display
        //

        if (*pszDesc)
        {
            pszTmp = CmStrCatAlloc(&pszTmp, TEXT("  "));
            pszTmp = CmStrCatAlloc(&pszTmp, pszDesc);
        }

        SetDlgItemTextU(m_hWnd, nDescID, pszTmp);
    }

    CmFree(pszTmp);
}

//+---------------------------------------------------------------------------
//
//  Function:   CGeneralPage::ClearUseDialingRules
//
//  Synopsis:   Helper function to deal with disabling the check box and 
//              reseting the state for UseDialingRules.
//
//  Arguments:  iPhoneNdx - index of phone number to which this applies
//
//  Returns:    Nothing
//
//  History:    nickball - Created - 7/17/97
//
//----------------------------------------------------------------------------
void CGeneralPage::ClearUseDialingRules(int iPhoneNdx)
{
    MYDBGASSERT(iPhoneNdx ==0 || iPhoneNdx ==1);
    //
    // Uncheck and disable the appropriate "Use Dialing Rules" checkbox
    //
   
    if (0 == iPhoneNdx)
    {
        CheckDlgButton(m_hWnd, IDC_GENERAL_UDR1_CHECKBOX, FALSE);
        EnableWindow(GetDlgItem(m_hWnd, IDC_GENERAL_UDR1_CHECKBOX), FALSE);
    }
    else
    {
        CheckDlgButton(m_hWnd, IDC_GENERAL_UDR2_CHECKBOX, FALSE);
        EnableWindow(GetDlgItem(m_hWnd, IDC_GENERAL_UDR2_CHECKBOX), FALSE);
    }

    m_DialInfo[iPhoneNdx].dwPhoneInfoFlags &= ~PIF_USE_DIALING_RULES;

    UpdateDialingRulesButton();
}

//+---------------------------------------------------------------------------
//
//  Function:   CGeneralPage::UpdateDialingRulesButton
//
//  Synopsis:   Helper function to deal with enabling/disabling the 
//              DialingRules button according to whether dialing rules
//              is being applied to either primary or backup number.
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//  History:    nickball - Created - 12/14/98
//
//----------------------------------------------------------------------------
void CGeneralPage::UpdateDialingRulesButton(void)
{
    BOOL fDialingRules = (IsDlgButtonChecked(m_hWnd, IDC_GENERAL_UDR1_CHECKBOX) && 
                          IsWindowEnabled(GetDlgItem(m_hWnd, IDC_GENERAL_UDR1_CHECKBOX))
                         ) ||
                         (IsDlgButtonChecked(m_hWnd, IDC_GENERAL_UDR2_CHECKBOX) && 
                          IsWindowEnabled(GetDlgItem(m_hWnd, IDC_GENERAL_UDR2_CHECKBOX))
                         );

    EnableWindow(GetDlgItem(m_hWnd, IDC_GENERAL_TAPI_BUTTON), fDialingRules);
}

//+---------------------------------------------------------------------------
//
//  Function:   DoPropertiesPropSheets
//
//  Synopsis:   Pop up the Properties property sheets.
//
//  Arguments:  hwndDlg [dlg window handle]
//              pArgs [the ptr to ArgsStruct]
//
//  Returns:    PropertySheet return value
//
//  History:    henryt  Created     3/5/97
//
//----------------------------------------------------------------------------
int DoPropertiesPropSheets(
    HWND        hwndDlg,
    ArgsStruct  *pArgs
)
{
    CPropertiesSheet PropertiesSheet(pArgs);
    CInetPage* pInetPage = NULL;
    CAboutPage* pAboutPage = NULL; 
    COptionPage* pOptionPage = NULL;
    CGeneralPage* pGeneralPage = NULL;
    CVpnPage* pVpnPage = NULL;
    HRESULT hr;
    BOOL bCOMInitialized = FALSE;
    HINSTANCE hinstDll = NULL;

    typedef HRESULT (*pfnGetPageFunction) (PROPSHEETPAGEW *, GUID *);

    CMTRACE(TEXT("Begin DoPropertiesPropSheets()"));

    //
    // Always start by adding the General page
    //

    if (pArgs->IsBothConnTypeSupported() || !pArgs->IsDirectConnect())
    {
        //
        // If both dial-up and direct is supported, use the appropriate
        // template for the general property page. 
        //

        UINT uiMainDlgID;  

        //
        // The general page is always access point aware
        //
        uiMainDlgID = pArgs->IsBothConnTypeSupported() ? IDD_GENERAL_DIRECT : IDD_GENERAL;

        pGeneralPage = new CGeneralPage(pArgs, uiMainDlgID);
        
        if (pGeneralPage)
        {
            PropertiesSheet.AddPage(pGeneralPage);

            //
            //  Create the balloon tip object
            //
            pArgs->pBalloonTip = new CBalloonTip();
        }

        //
        // Show the Internet Sign-In tab if we're tunneling and 
        // Inet username/password is different than main sign-on username/password
        // Also, if either the username or password are NOT to be hidden, we 
        // display the tab.
        //

        if (IsTunnelEnabled(pArgs) && !pArgs->fUseSameUserName) 
        {
            if (!pArgs->fHideInetUsername || !pArgs->fHideInetPassword)
            {
                //
                // Determine which template to use based hide flags
                //

                UINT uiTemplateID = IDD_INET_SIGNIN;

                if (pArgs->fHideInetUsername)
                {
                    uiTemplateID = IDD_INET_SIGNIN_NO_UID;
                }
                else if (pArgs->fHideInetPassword)
                {
                    uiTemplateID = IDD_INET_SIGNIN_NO_PWD;
                }
                
                //
                // Create the page
                //

                pInetPage = new CInetPage(pArgs, uiTemplateID);

                if (pInetPage)
                {
                    PropertiesSheet.AddPage(pInetPage);

                    if (pGeneralPage)
                    {
                        //
                        // To receive event from General Page
                        //
                        pGeneralPage->SetEventListener(pInetPage);
                    }
                }
            }
        }
    }

    //
    //  Add the VPN selector tab if we are tunneling and have a VPN phonebook
    //  specified.
    //
    if (IsTunnelEnabled(pArgs) && pArgs->pszVpnFile)
    {
        pVpnPage = new CVpnPage(pArgs, IDD_VPN);

        if (pVpnPage)
        {
            PropertiesSheet.AddPage(pVpnPage);
        }
    }

    //
    // Always include Options page
    //
    pOptionPage = new COptionPage(pArgs, IDD_OPTIONS);
    
    if (pOptionPage)
    {
        PropertiesSheet.AddPage(pOptionPage);
    }

#ifndef _WIN64
    //
    // Add the Advanced (Internet Connection Firewall & Internet Connection
    // Sharing) property page. Display only on WindowsXP and x86. If an error occurs
    // fail gracefully & continue.
    //

    //
    // Check if this is WindowsXP and/or above and if we are allowed to display the tab
    // 
    if (OS_NT51 && pArgs->bShowHNetCfgAdvancedTab && (FALSE == IsLogonAsSystem()))  
    {
        PROPSHEETPAGEW psp;
        
        ZeroMemory (&psp, sizeof(psp));
        psp.dwSize = sizeof(psp); 
        //
        // Make sure COM is initialized on this thread.
        // Win95 can't find an entry in ole32.dll for CoInitializeEx since we statically link 
        // the lib. Need to use CoInitilize because it needs to run on plain vanilla 
        // Win95. Possibly we should dynamically load the dll in this case.
        //
        hr = CoInitialize(NULL);
        if (S_OK == hr)
        {
            CMTRACE(TEXT("DoPropertiesPropSheets - Correctly Initialized COM."));
            bCOMInitialized = TRUE;
        }
        else if (S_FALSE == hr)
        {
            CMTRACE(TEXT("DoPropertiesPropSheets - This concurrency model is already initialized. CoInitialize returned S_FALSE."));
            bCOMInitialized = TRUE;
            hr = S_OK;
        }
        else if (RPC_E_CHANGED_MODE == hr)
        {
            CMTRACE1(TEXT("DoPropertiesPropSheets - Using different concurrency model. Did not initialize COM - RPC_E_CHANGED_MODE. hr=0x%x"), hr);
            hr = S_OK;
        }
        else
        {
            CMTRACE1(TEXT("DoPropertiesPropSheets - Failed to Initialized COM. hr=0x%x"), hr);
        }
    
        if (SUCCEEDED(hr))
        {
            CMTRACE(TEXT("DoPropertiesPropSheets - Get connection GUID."));
            GUID *pGuid = NULL;
            LPRASENTRY pRasEntry = MyRGEP(pArgs->pszRasPbk, pArgs->szServiceName, &pArgs->rlsRasLink);

            if (pRasEntry && sizeof(RASENTRY_V501) >= pRasEntry->dwSize)
            {
                //
                // Get the pGuid value
                //
                pGuid = &(((LPRASENTRY_V501)pRasEntry)->guidId);
            
                hinstDll = LoadLibrary (TEXT("hnetcfg.dll"));
                if (NULL == hinstDll)
                {
                    CMTRACE1(TEXT("DoPropertiesPropSheets - could not LoadLibray hnetcfg.dll GetLastError() = 0x%x"), 
                             GetLastError());
                }
                else 
                {
                    CMTRACE(TEXT("DoPropertiesPropSheets - Loaded Library hnetcfg.dll"));
                    pfnGetPageFunction pfnGetPage = (pfnGetPageFunction)GetProcAddress (hinstDll, "HNetGetFirewallSettingsPage");

                    if (!pfnGetPage)
                    {
                        CMTRACE1(TEXT("DoPropertiesPropSheets - GetProcAddress for HNetGetFirewallSettingsPage failed! 0x%x"), 
                                 GetLastError());
                    }
                    else
                    {
                        //
                        // Get the actual Property Sheet Page
                        // This function can fail if the user doesn't have the correct 
                        // security settings (eg. is not an Administrator) This is checked
                        // internally in the hnetcfg.dll 
                        //
                        CMTRACE(TEXT("DoPropertiesPropSheets - calling HNetGetFirewallSettingsPage"));
                        
                        hr = pfnGetPage(&psp, pGuid);
                        if (S_OK == hr)
                        {
                            //
                            // Add the Property Sheet Page into our PropertiesSheet object
                            //
                            PropertiesSheet.AddExternalPage(&psp);
                            CMTRACE(TEXT("DoPropertiesPropSheets - Called AddExternalPage() "));
                        }
                        else
                        {
                            //
                            // This error could be ERROR_ACCESS_DENIED which is ok
                            // so just log this. The tab will not be displayed in this case
                            // 
                            if (ERROR_ACCESS_DENIED == hr)
                            {
                                CMTRACE(TEXT("DoPropertiesPropSheets() - ERROR_ACCESS_DENIED. User does not have the security rights to view this tab."));
                            }
                            else
                            {
                                CMTRACE1(TEXT("DoPropertiesPropSheets() - Failed to get Propery Page. hr=0x%x"), hr);
                            }
                        }
                    }
                }
            }
            else
            {
                CMTRACE(TEXT("DoPropertiesPropSheets - Failed to LoadRAS Entry."));
            }
        
            CmFree(pRasEntry);
            pRasEntry = NULL;
        }
    }
#endif // _WIN64

    //
    // If NOT NT5, set the about page as the last property sheet 
    //

    if (!(OS_NT5))       
    {
        pAboutPage = new CAboutPage(pArgs, IDD_ABOUT); 
        
        if (pAboutPage)
        {
            PropertiesSheet.AddPage(pAboutPage);
        }
    }

    //
    // The service name used as mutex name
    //
    PropertiesSheet.m_lpszServiceName = CmStrCpyAlloc(pArgs->szServiceName);

    //
    // Set the title for the sheet
    //
    LPTSTR pszTitle = GetPropertiesDlgTitle(pArgs->szServiceName);

    if (OS_W9X)
    {
        //
        //  If this is Win9x then we will call the ANSI version of the
        //  property sheet function.  Thus we must pass it an ANSI title.
        //  Since the ANSI and Unicode version of the Prop Sheet Header are
        //  the same size (contains only string pointers not strings) whether
        //  ANSI or Unicode and we only have one Unicode string, lets take
        //  a shortcut and cast the title to an ANSI string and then call the
        //  A version of the API.  This saves us having to have a UtoA function
        //  for the prop sheets when we would only be doing one string conversion.
        //
        LPSTR pszAnsiTitle = WzToSzWithAlloc(pszTitle);        
        CmFree(pszTitle);
        pszTitle = (LPTSTR)pszAnsiTitle;         
    }

    //
    //  Show it!
    //

    int iRet =  PropertiesSheet.DoPropertySheet(hwndDlg, pszTitle, g_hInst);

    CmFree(pszTitle);

    switch(iRet)
    {
    case -1:
        CMTRACE(TEXT("DoPropertiesPropSheets(): PropertySheet() failed"));
        break;

    case IDOK:
        CheckConnectionAndInformUser(hwndDlg, pArgs);
        break;

    case 0 :  // Cancel
        break;

    default:
        MYDBGASSERT(FALSE);
        break;
    }

    delete pInetPage;
    delete pAboutPage;
    delete pOptionPage;
    delete pGeneralPage;
    delete pVpnPage;

    //
    //  Clean up the BalloonTip object if we have one
    //
    delete pArgs->pBalloonTip;
    pArgs->pBalloonTip = NULL;

    CmFree (PropertiesSheet.m_lpszServiceName);
    PropertiesSheet.m_lpszServiceName = NULL;


    //
    // Clean up and Uninitilize COM
    //
    if (hinstDll)
    {
        FreeLibrary (hinstDll);
    }
    
    if (bCOMInitialized)
    {
        CoUninitialize(); 
    }

    CMTRACE(TEXT("End DoPropertiesPropSheets()"));

    return iRet;
}


//+----------------------------------------------------------------------------
//
// Function:  CheckConnectionAndInformUser
//
// Synopsis:  This function is called after the user clicked OK on the 
//            Properties dialog.  The Prop dialog can be up while the same
//            profile is connected and so we need to tell the user that
//            the changes won't be effective until the next she connects.
//
// Arguments: hwnDlg - hwnd of the main dlg
//            pArgs
//
// Returns:   None
//
//+----------------------------------------------------------------------------

void CheckConnectionAndInformUser(
    HWND        hwndDlg,
    ArgsStruct  *pArgs
)
{
    CM_CONNECTION Connection;

    ZeroMemory(&Connection, sizeof(CM_CONNECTION));

    if (SUCCEEDED(pArgs->pConnTable->GetEntry(pArgs->szServiceName, &Connection)) &&
        Connection.CmState == CM_CONNECTED)
    {
        LPTSTR  pszTmp = CmLoadString(g_hInst, IDMSG_EFFECTIVE_NEXT_TIME);
        MessageBox(hwndDlg, pszTmp, pArgs->szServiceName, MB_OK | MB_ICONINFORMATION);
        CmFree(pszTmp);
    }
}



const DWORD CInetSignInDlg::m_dwHelp[] = {
        IDC_INET_USERNAME_STATIC,   IDH_INTERNET_USER_NAME,
        IDC_INET_USERNAME,          IDH_INTERNET_USER_NAME,
        IDC_INET_PASSWORD_STATIC,   IDH_INTERNET_PASSWORD,
        IDC_INET_PASSWORD,          IDH_INTERNET_PASSWORD,
        IDC_INET_REMEMBER,          IDH_INTERNET_SAVEPASS,
        0,0};



//+----------------------------------------------------------------------------
//
// Function:  CInetSignInDlg::OnInitDialog
//
// Synopsis:  Virtual function. Call upon WM_INITDIALOG message
//
// Arguments: None
//
// Returns:   BOOL - Return value of WM_INITDIALOG
//
// History:   fengsun Created Header    2/26/98
//
//+----------------------------------------------------------------------------
BOOL CInetSignInDlg::OnInitDialog()
{
    //
    // Brand the dialog
    //

    if (m_pArgs->hSmallIcon)
    {
        SendMessageU(m_hWnd, WM_SETICON, ICON_SMALL, (LPARAM) m_pArgs->hSmallIcon);
    }

    if (m_pArgs->hBigIcon)
    {        
        SendMessageU(m_hWnd, WM_SETICON, ICON_BIG, (LPARAM) m_pArgs->hBigIcon); 
        SendMessageU(GetDlgItem(m_hWnd, IDC_INET_ICON), STM_SETIMAGE, IMAGE_ICON, (LPARAM) m_pArgs->hBigIcon); 
    }

    //
    // Use should not see this dialog, if the password is optional
    //

    MYDBGASSERT(!m_pArgs->piniService->GPPB(c_pszCmSection,c_pszCmEntryPwdOptional));

    UpdateFont(m_hWnd);

    CInetPage::OnInetInit(m_hWnd, m_pArgs);

    //
    // if the username is empty, then we disable the OK button.
    //
    
    if (GetDlgItem(m_hWnd, IDC_INET_USERNAME) &&
        !SendDlgItemMessageU(m_hWnd, IDC_INET_USERNAME, WM_GETTEXTLENGTH, 0, (LPARAM)0))
    {
        EnableWindow(GetDlgItem(m_hWnd, IDOK), FALSE);
    }
        
    if (GetDlgItem(m_hWnd, IDC_INET_PASSWORD) &&
        !SendDlgItemMessageU(m_hWnd, IDC_INET_PASSWORD, WM_GETTEXTLENGTH, 0, (LPARAM)0))
    {
        EnableWindow(GetDlgItem(m_hWnd, IDOK), FALSE);
    }

    //
    // We wouldn't be here unless data was missing, so set focus accordingly
    //

    if (!m_pArgs->fHideInetUsername && !*m_pArgs->szInetUserName)
    {
        SetFocus(GetDlgItem(m_hWnd, IDC_INET_USERNAME));
    }
    else
    {
        SetFocus(GetDlgItem(m_hWnd, IDC_INET_PASSWORD));
    }

    //
    // Must return FALSE when setting focus
    //

    return FALSE; 
}



//+----------------------------------------------------------------------------
//
// Function:  CInetSignInDlg::OnOK
//
// Synopsis:  Virtual function. Called upon WM_COMMAND with IDOK
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/26/98
//
//+----------------------------------------------------------------------------
void CInetSignInDlg::OnOK()
{
    CInetPage::OnInetOk(m_hWnd, m_pArgs);   
    EndDialog(m_hWnd, TRUE);
}

//+----------------------------------------------------------------------------
//
// Function:  CInetSignInDlg::OnOtherCommand
//
// Synopsis:  Virtual function. Call upon WM_COMMAND with command other than IDOK
//            and IDCANCEL
//
// Arguments: WPARAM wParam - wParam of WM_COMMAND
//            LPARAM - 
//
// Returns:   DWORD - 
//
// History:   fengsun Created Header    2/26/98
//
//+----------------------------------------------------------------------------
DWORD CInetSignInDlg::OnOtherCommand(WPARAM wParam, LPARAM)
{
    switch (LOWORD(wParam)) 
    {
        case IDC_INET_USERNAME:
        case IDC_INET_PASSWORD:
            //
            // User typed something in username or password
            //
            if (HIWORD(wParam) == EN_CHANGE) 
            {
                BOOL fHasUserName = TRUE;
                
                if (GetDlgItem(m_hWnd, IDC_INET_USERNAME)) 
                {
                    fHasUserName = !!SendDlgItemMessageU(m_hWnd, 
                                                         IDC_INET_USERNAME, 
                                                         WM_GETTEXTLENGTH, 0, 0);
                }

                BOOL fHasPassword = TRUE;
                
                if (GetDlgItem(m_hWnd, IDC_INET_PASSWORD)) 
                {
                    fHasPassword = !!SendDlgItemMessageU(m_hWnd, 
                                                         IDC_INET_PASSWORD,
                                                         WM_GETTEXTLENGTH, 0, 0);
                }

                //
                // Enable OK button only if both user name and password is available
                //
                
                EnableWindow(GetDlgItem(m_hWnd, IDOK), fHasUserName && fHasPassword);
                
                if (!m_pArgs->fHideRememberInetPassword  && !m_pArgs->fHideInetPassword)
                {
                    //
                    // Enable/Disable check/uncheck the "Save Password" accordingly
                    // fPasswordOptional is always FALSE for the dialog
                    //
                    CInetPage::AdjustSavePasswordCheckBox(GetDlgItem(m_hWnd, IDC_INET_REMEMBER), 
                            !fHasPassword, m_pArgs->fDialAutomatically, FALSE);
                }
            }
            break;

    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   CGeneralPage::SubClassEditProc
//
//  Synopsis:   Proc to subclass the edit controls in the Dial propsheet.
//
//  Arguments:  hwnd [wnd handle]
//              uMsg [wnd msg]
//              lParam [LPARAM]
//              wParam [WPARAM]
//
//  Returns:    NONE
//
//  History:    henryt      Created     3/24/97
//              byao        Modified    4/3/97   Added new code to handle description field,
//                                               phone number field, etc.
//              henryt      Modified    5/1/97   New UI.
//              nickball    Modified    6/18/97  Moved GetParent call and added
//                                               NC_DESTROY handling for CM16
//              nickball    Modified    7/10/97  Commented out removal of description
//              nickball    Modified    7/10/97  Implemented ClearDialAsLongDistance
//              fengsun     Modified    11/3/97  Changed into static member function
//              nickball    Modified    09/16/98 Renamed ClearDialAsLongDistance to ClearUseDialingRules
//----------------------------------------------------------------------------
LRESULT CALLBACK CGeneralPage::SubClassEditProc(HWND hwnd, UINT uMsg, 
                                                WPARAM wParam, LPARAM lParam)
{
    //
    // If user types a non-tapi character Beep and do not accept that character
    //

    if ((uMsg == WM_CHAR)  && (VK_BACK != wParam))
    {
        if (!IsValidPhoneNumChar((TCHAR)wParam))
        {

            Beep(2000, 100);
            return 0;
        }
    }

    // 
    // Call the original window procedure for default processing. 
    //
    LRESULT lres = CallWindowProcU(m_pfnOrgEditWndProc, hwnd, uMsg, wParam, lParam); 

    //
    // if the user is typing a phone # in the edit control, then there is
    // no phone book file associated with the #.
    // make sure we ignore CTRL-C(VK_CANCEL) because the user is just doing a copy.
    //
    if ( ( uMsg == WM_CHAR && wParam != VK_CANCEL ) || 
         ( uMsg == WM_KEYDOWN && wParam == VK_DELETE) ||
         ( uMsg == WM_PASTE)) 
    {
        //
        // Either primary or backup edit control
        // 
        DWORD dwControlId = (DWORD) GetWindowLongU(hwnd, GWL_ID);
        MYDBGASSERT(dwControlId == IDC_GENERAL_PRIMARY_EDIT ||
                    dwControlId == IDC_GENERAL_BACKUP_EDIT);

        //
        // Get the object pointer saved by SetWindowLong
        //
        CGeneralPage* pGeneralPage = (CGeneralPage*)GetWindowLongU(hwnd, GWLP_USERDATA);
        MYDBGASSERT(pGeneralPage);

        pGeneralPage->ClearUseDialingRules(dwControlId == IDC_GENERAL_PRIMARY_EDIT ? 0 : 1);
    }

    return lres;
}

//+---------------------------------------------------------------------------
//
//  Function:   SubClassPropSheetProc
//
//  Synopsis:   Proc to subclass the parent property sheet dlg.
//
//  Arguments:  hwnd [wnd handle]
//              uMsg [wnd msg]
//              lParam [LPARAM]
//              wParam [WPARAM]
//
//  Returns:    NONE
//
//  History:    henryt  Created     6/11/97
//----------------------------------------------------------------------------
LRESULT CALLBACK CPropertiesSheet::SubClassPropSheetProc(HWND hwnd, UINT uMsg, WPARAM wParam,LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_COMMAND:
            //
            // If ok is pressed, save the index of the tab
            // So, the next time user comes to properties, the same tab will be displayed
            //

            if (LOWORD(wParam) == IDOK && HIWORD(wParam) == BN_CLICKED)
            {
                CPropertiesSheet* pPropSheet = (CPropertiesSheet*)GetWindowLongU(hwnd, GWLP_USERDATA);
                MYDBGASSERT(pPropSheet);

                //
                // Declare a mutex to prevent multi-instance write to the same profile 
                //
                CNamedMutex propertiesMutex;

                //
                // Use the profile name as the mutex name
                // If we lock timed out, go ahead and save the properties
                // The destructor of the mutex will release the lock
                //
                MYVERIFY(propertiesMutex.Lock(pPropSheet->m_lpszServiceName, TRUE, WRITE_PROPERTIES_MUTEX_TIMEOUT));

                LRESULT dwRes = CallWindowProcU(m_pfnOrgPropSheetProc, hwnd, uMsg, wParam, lParam); 

                return dwRes;
            }
        case WM_MOVING:
            {
                CPropertiesSheet* pPropSheet = (CPropertiesSheet*)GetWindowLongU(hwnd, GWLP_USERDATA);

                if (pPropSheet && pPropSheet->m_pArgs && pPropSheet->m_pArgs->pBalloonTip)
                {
                    pPropSheet->m_pArgs->pBalloonTip->HideBalloonTip();
                }
            }
            break;
    }

    // 
    // Call the original window procedure for default processing. 
    //
    return CallWindowProcU(m_pfnOrgPropSheetProc, hwnd, uMsg, wParam, lParam); 
}



//+----------------------------------------------------------------------------
//
// Function:  CPropertiesSheet::PropSheetProc
//
// Synopsis:  Callback function for the propertysheet. PSCB_INITIALIZED is 
//            called before any page is initialized.  Initialize the property 
//            page here
//
// Arguments: HWND hwndDlg - PropertySheet window handle
//            UINT uMsg - Message id
//            LPARAM - 
//
// Returns:   int CALLBACK - 
//
// History:   fengsun Created Header    2/26/98
//
//+----------------------------------------------------------------------------
int CALLBACK CPropertiesSheet::PropSheetProc(HWND hwndDlg, UINT uMsg, LPARAM lParam)
{
    if (uMsg == PSCB_INITIALIZED)
    {
        MYDBGASSERT(hwndDlg);

        //
        // Save the m_pThis pointer, so it can be accessed by SubClassPropSheetProc
        //
        MYDBGASSERT(m_pThis);
        SetWindowLongU(hwndDlg, GWLP_USERDATA, (LONG_PTR)m_pThis);
        m_pThis = NULL;

        //
        // subclass the property sheet
        //
        m_pfnOrgPropSheetProc = (WNDPROC)SetWindowLongU(hwndDlg, GWLP_WNDPROC, (LONG_PTR)SubClassPropSheetProc);
    }

    return 0;
}


//+----------------------------------------------------------------------------
//
//  Function    CGeneralPage::DisplayMungedPhone
//
//  Synopsis    Apply TAPI rules to the phone number, and then display it
//              in the edit control
//
//  Arguments   uiPhoneIdx                  The index of the phone #
//
//  Returns     FALSE if the number can't be munged
//
//  History     4/2/97          byao    Modified to current implementation
//              4/30/97         henryt  added/deleted params
//              5/17/97         VetriV  Added functionality to return
//                                      displayable number
//              11/3/97         fengsun Changed into member function
//
//-----------------------------------------------------------------------------
BOOL CGeneralPage::DisplayMungedPhone(UINT uiPhoneIdx) 
{
    LPTSTR pszPhone;
    LPTSTR pszTmpDialableString = NULL;
    BOOL bRet = TRUE;

    //
    // If DialingRules is turned off, just use what we already have, no munge.
    //
    
    if (m_pArgs->fNoDialingRules)
    {
        lstrcpynU(m_DialInfo[uiPhoneIdx].szDisplayablePhoneNumber, m_DialInfo[uiPhoneIdx].szPhoneNumber, 
                  CELEMS(m_DialInfo[uiPhoneIdx].szDisplayablePhoneNumber));

        lstrcpynU(m_DialInfo[uiPhoneIdx].szDialablePhoneNumber, m_DialInfo[uiPhoneIdx].szPhoneNumber, 
                  CELEMS(m_DialInfo[uiPhoneIdx].szDialablePhoneNumber));
        
        m_DialInfo[uiPhoneIdx].szCanonical[0] = TEXT('\0');

        SetDlgItemTextU(m_hWnd, (uiPhoneIdx? IDC_GENERAL_BACKUP_EDIT : IDC_GENERAL_PRIMARY_EDIT), m_DialInfo[uiPhoneIdx].szPhoneNumber);
        return TRUE;
    }

    //
    // Retrieve the canonical form of the number for munging
    //
    pszPhone = CmStrCpyAlloc(m_DialInfo[uiPhoneIdx].szCanonical); 

    if (pszPhone) 
    {
        if (*pszPhone && m_szDeviceName[0])
        {
            // 
            // Apply tapi rules only when there's a modem selected. We now munge the phone
            // even if there is no description because we want to pick up tone and pulse.
            //
            if (ERROR_SUCCESS != MungePhone(m_szDeviceName, 
                                            &pszPhone, 
                                            &m_pArgs->tlsTapiLink, 
                                            g_hInst,
                                            m_DialInfo[uiPhoneIdx].dwPhoneInfoFlags & PIF_USE_DIALING_RULES, 
                                            &pszTmpDialableString,
                                            m_pArgs->fAccessPointsEnabled)) 
            {
                //
                // Munge failed, make sure that ptrs are valid, albeit empty
                //

                CmFree(pszPhone);
                pszPhone = CmStrCpyAlloc(TEXT(""));             // CmFmtMsg(g_hInst, IDMSG_CANTFORMAT);
                pszTmpDialableString = CmStrCpyAlloc(TEXT(""));  // CmFmtMsg(g_hInst, IDMSG_CANTFORMAT);                    
                bRet = FALSE;
            }
        }
                       
        //
        // Standard procedure. If Dialing rule are applied, then use the 
        // canonical form (eg. pszPhone). Otherwise use the raw number form.
        //
        
        if (m_DialInfo[uiPhoneIdx].dwPhoneInfoFlags & PIF_USE_DIALING_RULES)
        {
            //
            // Unique situation in which we have read in a legacy hand-edited 
            // phone number and the default dialing-rules state is TRUE/ON. 
            // We fake out the standard procedure by slipping the raw number
            // into the otherwise blank pszPhone. Note: This occurs only the
            // first time the app. is run until a save is made at which time
            // the current storage format is used.
            //
        
            if (!*pszPhone)
            {
                pszPhone = CmStrCatAlloc(&pszPhone, m_DialInfo[uiPhoneIdx].szPhoneNumber);
            }

            //
            // In this case the pszPhone is dynamically allocated and can be very long. In order to
            // fix this, we need to trim the string if it's longer than what should fit in the UI.
            //
            LRESULT lEditLen = SendDlgItemMessageU(m_hWnd, (uiPhoneIdx? IDC_GENERAL_BACKUP_EDIT : IDC_GENERAL_PRIMARY_EDIT), EM_GETLIMITTEXT, 0, 0);

            if (lstrlenU(pszPhone) >= ((INT)lEditLen))
            {
                pszPhone[lEditLen] = TEXT('\0');
            }

            SetDlgItemTextU(m_hWnd, (uiPhoneIdx? IDC_GENERAL_BACKUP_EDIT : IDC_GENERAL_PRIMARY_EDIT), pszPhone);
        }
        else
        {
            //
            // No need to trim anything, since the structure is providing the phone number. Eventully the 
            // number from the UI will go back into the phone number structure and we know it will fit 
            // since it came from there.
            //
            SetDlgItemTextU(m_hWnd, (uiPhoneIdx? IDC_GENERAL_BACKUP_EDIT : IDC_GENERAL_PRIMARY_EDIT), m_DialInfo[uiPhoneIdx].szPhoneNumber);
        }
    }

    //
    // copy the munged phone to the caller's buffer.
    //
    
    if (pszTmpDialableString)
    {
        lstrcpynU(m_DialInfo[uiPhoneIdx].szDialablePhoneNumber, pszTmpDialableString, 
                  CELEMS(m_DialInfo[uiPhoneIdx].szDialablePhoneNumber));
    }

    if (pszPhone)
    {
        lstrcpynU(m_DialInfo[uiPhoneIdx].szDisplayablePhoneNumber, pszPhone, 
                  CELEMS(m_DialInfo[uiPhoneIdx].szDisplayablePhoneNumber));
    }

    CmFree(pszPhone);
    CmFree(pszTmpDialableString);

    return bRet;
}

//+----------------------------------------------------------------------------
//
//  Function    CGeneralPage::OnDialingProperties
//
//  Synopsis    Handler for handling the "Dialing Properties..." button-click
//              in the 'Dialing' tab.
//
//  Arguments   
//
//  History     4/30/97         henryt  modified for new UI
//              11/3/97         fengsun Change the function name and make it 
//                                  a member ffunction
//              01/29/98        cleaned up memory leak, added comments.    
//
//-----------------------------------------------------------------------------
void CGeneralPage::OnDialingProperties() 
{
    LONG   lRes;
    LPTSTR pszPhone = NULL;
  
    //
    // Use primary or backup to seed tapi dialog depending on whether dialing 
    // rules are being applied to the number. We use the check state rather 
    // than the phone-info flag because of the anomolous first time case in 
    // which the flag is set, but the controls aren't checked.
    //  
    
    if (IsDlgButtonChecked(m_hWnd, IDC_GENERAL_UDR1_CHECKBOX))
    {
        pszPhone = CmStrCpyAlloc(m_DialInfo[0].szCanonical);//szPhoneNumber);
    }
    else if (IsDlgButtonChecked(m_hWnd, IDC_GENERAL_UDR2_CHECKBOX))
    {
        pszPhone = CmStrCpyAlloc(m_DialInfo[1].szCanonical);//szPhoneNumber);   
    }
    else
    {
        pszPhone = CmStrCpyAlloc(TEXT(" "));
    }

    //
    // Launch TAPI dialog for DialingRules configuration
    //

    if (!m_pArgs->tlsTapiLink.pfnlineTranslateDialog) 
    {
        return;
    }
    
    if (!SetTapiDevice(g_hInst,&m_pArgs->tlsTapiLink,m_szDeviceName)) 
    {
        MYDBGASSERT(FALSE);
        return;
    }

    if (OS_W9X)
    {
        //
        // On win9x, we are linked to the ANSI version of lineTranslateDialog, thus
        // we need to convert the string.  In order to keep things simpler, we just
        // cast the converted LPSTR as an LPWSTR and pass it on.
        //

        LPSTR pszAnsiPhone = WzToSzWithAlloc(pszPhone);
        CmFree(pszPhone);
        pszPhone = (LPTSTR)pszAnsiPhone;
    }

    lRes = m_pArgs->tlsTapiLink.pfnlineTranslateDialog(m_pArgs->tlsTapiLink.hlaLine,
                                                       m_pArgs->tlsTapiLink.dwDeviceId,
                                                       m_pArgs->tlsTapiLink.dwApiVersion,
                                                       m_hWnd,
                                                       pszPhone);
    CmFree(pszPhone);

    CMTRACE1(TEXT("OnDialingProperties() lineTranslateDialog() returns %u"), lRes);

    
    //
    // We do not know whether user changed anything (WIN32), so re-munge anyway
    //

    if (lRes == ERROR_SUCCESS)
    {        
        DWORD dwCurrentTapiLoc = GetCurrentTapiLocation(&m_pArgs->tlsTapiLink);

        if (-1 != dwCurrentTapiLoc)
        {
            if (dwCurrentTapiLoc != m_pArgs->tlsTapiLink.dwTapiLocationForAccessPoint)
            {
                 m_bAPInfoChanged = TRUE;
            }

            m_pArgs->tlsTapiLink.dwTapiLocationForAccessPoint = dwCurrentTapiLoc;

            for (UINT i = 0; i < m_NumPhones; i++)
            {
                //
                // Only munge if Use Dialing Rules is available
                //
            
                if (m_DialInfo[i].dwPhoneInfoFlags & PIF_USE_DIALING_RULES)
                {
                    DisplayMungedPhone(i);
                }
            }
        }
    }
}

//+----------------------------------------------------------------------------
//
//  Function    CGeneralPage::OnPhoneBookButton
//
//  Synopsis    Handler for handling the "Phone Book..." button-click
//              in the 'Dialing' tab.
//
//  Arguments   nPhoneIdx       phone index
//
//  History     4/30/97         henryt  modified for new UI
//              11/3/97         fengsun Change to a member function
//
//-----------------------------------------------------------------------------
void CGeneralPage::OnPhoneBookButton(UINT nPhoneIdx) 
{
    PBArgs sArgs;
    LPTSTR pszTmp;
    UINT nEditID = !nPhoneIdx ? IDC_GENERAL_PRIMARY_EDIT: IDC_GENERAL_BACKUP_EDIT;
    //UINT nDescID = !nPhoneIdx ? IDC_GENERAL_PRIMARYDESC_DISPLAY: IDC_GENERAL_BACKUPDESC_DISPLAY;
    
    UINT nUdrID = !nPhoneIdx? IDC_GENERAL_UDR1_CHECKBOX : IDC_GENERAL_UDR2_CHECKBOX;
    BOOL bRes;
    UINT uiSrc;
    BOOL bBlankPhone = FALSE;

    memset(&sArgs,0,sizeof(sArgs));

    sArgs.pszCMSFile = m_pArgs->piniService->GetFile();
    
    //
    // Update the attributes of the users phone number selection to reflect
    // any interim changes. This ensures that we will default to the correct
    // service, country and region of the current phone number selection. (4397)
    //  

    if (nPhoneIdx && !GetWindowTextLengthU(GetDlgItem(m_hWnd, nEditID)))
    {
        //
        // if we're changing the backup # and currently the backup # is empty,
        // we use the state and country info of the primary #.
        //
        uiSrc = 0;
    }
    else
    {
        uiSrc = nPhoneIdx;
    }

    lstrcpynU(sArgs.szServiceType, m_DialInfo[uiSrc].szServiceType, CELEMS(sArgs.szServiceType));
    
    sArgs.dwCountryId = m_DialInfo[uiSrc].dwCountryID; 
    
    lstrcpynU(sArgs.szRegionName, m_DialInfo[uiSrc].szRegionName, CELEMS(sArgs.szRegionName));

    sArgs.pszMessage = m_pArgs->piniService->GPPS(c_pszCmSection, c_pszCmEntryPbMessage);

    //
    //  Check to see if the phone number is blank.  We need to save this off for 
    //  balloon tips to use later.
    //

    if(0 == GetWindowTextLengthU(GetDlgItem(m_hWnd,nEditID)))
    {
        bBlankPhone = TRUE;
    }

    //
    // Make sure that bitmap path is complete
    //

    pszTmp = m_pArgs->piniService->GPPS(c_pszCmSection, c_pszCmEntryPbLogo);  
    if (pszTmp && *pszTmp)
    {
        sArgs.pszBitmap = CmConvertRelativePath(m_pArgs->piniService->GetFile(), pszTmp);
    }
    CmFree(pszTmp);

    //
    // Include the help file name
    //

    sArgs.pszHelpFile = m_pArgs->pszHelpFile;

    //
    // Need the master palette handle also.
    //

    sArgs.phMasterPalette = &m_pArgs->hMasterPalette;

    //
    // Launch the phonebook dlg
    //

    bRes = DisplayPhoneBook(m_hWnd,&sArgs, m_pArgs->fHasValidTopLevelPBK, m_pArgs->fHasValidReferencedPBKs);

    CmFree(sArgs.pszMessage);
    CmFree(sArgs.pszBitmap);

    if (!bRes) 
    {
        return;
    }

    //
    // We have a new phone number selected, update phone number buffers.
    // and configure UI accordingly. If no dialing rules, the its a non
    // issue, leave it as is.
    //
    
    m_bAPInfoChanged = TRUE;
    if (!m_pArgs->fNoDialingRules)
    {
        EnableWindow(GetDlgItem(m_hWnd, nUdrID), TRUE);
        CheckDlgButton(m_hWnd, nUdrID, (m_DialInfo[nPhoneIdx].dwPhoneInfoFlags & PIF_USE_DIALING_RULES));

        //
        // Set TAPI button display according to dialing rules use.
        //
    
        UpdateDialingRulesButton();
    }

    //
    // Copy the new info in the tmp phone info array. First we 
    // Get the new phonebook name, which should be a full path
    //

    MYDBGASSERT(FileExists(sArgs.szPhoneBookFile));

    lstrcpynU(m_DialInfo[nPhoneIdx].szPhoneBookFile, sArgs.szPhoneBookFile, 
              CELEMS(m_DialInfo[nPhoneIdx].szPhoneBookFile));

    lstrcpynU(m_DialInfo[nPhoneIdx].szDUN, sArgs.szDUNFile, 
              CELEMS(m_DialInfo[nPhoneIdx].szDUN));

    //
    // Remove the first element (country code) from the non-canonical number
    //

    StripFirstElement(sArgs.szNonCanonical);
    
    //
    // If there was no area code, then we'll have a leading space, trim it
    //

    CmStrTrim(sArgs.szNonCanonical); 

    //
    // Update our buffers
    //
    
    lstrcpynU(m_DialInfo[nPhoneIdx].szPhoneNumber, sArgs.szNonCanonical, CELEMS(m_DialInfo[nPhoneIdx].szPhoneNumber));
    lstrcpynU(m_DialInfo[nPhoneIdx].szCanonical, sArgs.szCanonical, CELEMS(m_DialInfo[nPhoneIdx].szCanonical));
    lstrcpynU(m_DialInfo[nPhoneIdx].szDesc, sArgs.szDesc, CELEMS(m_DialInfo[nPhoneIdx].szDesc));
    
    m_DialInfo[nPhoneIdx].dwCountryID = sArgs.dwCountryId;

    //
    // Store attributes of user selection (ie.service, country, region) 
    // We will store this data permanently if the user exits with an OK.
    // It is also used if the user returns to the PB dialog (4397)
    // 

    lstrcpynU(m_DialInfo[nPhoneIdx].szServiceType, 
             sArgs.szServiceType, CELEMS(m_DialInfo[nPhoneIdx].szServiceType));
    lstrcpynU(m_DialInfo[nPhoneIdx].szRegionName, 
             sArgs.szRegionName, CELEMS(m_DialInfo[nPhoneIdx].szRegionName));    
    //
    // Display the current phone number and update the description.
    //

    DisplayMungedPhone(nPhoneIdx);

    //
    // Update the description display
    //
        
    UpdateNumberDescription(nPhoneIdx, sArgs.szDesc);

    //SetDlgItemText(m_hWnd, nDescID, sArgs.szDesc);


    
    
    //
    //  Check for and display balloon tips if enabled
    //
    if (m_pArgs->fHideBalloonTips)
    {
        CMTRACE(TEXT("Balloon tips are disabled."));
    }
    else
    {
        RECT rect;
        POINT point = {0,0};
        LPTSTR pszBalloonTitle = NULL; 
        LPTSTR pszBalloonMsg = NULL;

        HWND hwndParent = GetParent(m_hWnd);
        HWND hwndTAPIButton = GetDlgItem(m_hWnd, IDC_GENERAL_TAPI_BUTTON);
        HWND hwndPrimaryDRCheckbox = GetDlgItem(m_hWnd, IDC_GENERAL_UDR1_CHECKBOX);
        HWND hwndNewAPButton = GetDlgItem(m_hWnd, IDC_GENERAL_NEWAP_BUTTON);

        MYDBGASSERT(hwndParent);
        MYDBGASSERT(hwndTAPIButton);
        MYDBGASSERT(hwndPrimaryDRCheckbox);
        MYDBGASSERT(hwndNewAPButton);
 
        if (hwndParent && hwndTAPIButton && hwndPrimaryDRCheckbox && hwndNewAPButton)
        {
            //
            // Get the BalloonTipsDisplayed flags from the registry
            //
            DWORD dwBalloonTipsDisplayed = m_pArgs->piniBothNonFav->GPPI(c_pszCmSection, c_pszCmEntryBalloonTipsDisplayed, NULL);

            //
            //  If the primary button was clicked and the edit control is blank, we will try to display the Dialing Rules balloon tip,
            //  else we will try to display the access point balloon tip.
            //
            if (bBlankPhone)
            {
                //
                //  We only display if the primary Dialing Rules checkbox is enabled. Then if the Dialing Rules button is enabled, 
                //  we point the balloon tip to the button, otherwise we will point it to the checkbox.
                //
                if (IsWindowEnabled(hwndPrimaryDRCheckbox) && !nPhoneIdx)
                {
                    pszBalloonTitle = CmLoadString(g_hInst, IDMSG_BALLOON_TITLE_DIALINGRULES);
                    pszBalloonMsg = CmLoadString(g_hInst, IDMSG_BALLOON_MSG_DIALINGRULES);
            
                    if (IsWindowEnabled(hwndTAPIButton))
                    {
                        if (GetWindowRect(hwndTAPIButton, &rect))
                        {
                            //
                            // Get the coordinates of the Dialing Rules button.  We want the balloon tip to point
                            // to half way up the button and 10px left of the right edge.
                            //
                            point.x = rect.right - 10;                              
                            point.y = ((rect.bottom - rect.top) / 2) + rect.top;   
                        }
                    }
                    else
                    {
                        if (GetWindowRect(hwndPrimaryDRCheckbox, &rect))
                        {
                            //
                            // Get the coordinates of the Primary Dialing Rules checkbox.  We want the balloon tip to point
                            // to the center of the checkbox.
                            //
                            point.x = rect.left + 10;                               
                            point.y = ((rect.bottom - rect.top) / 2) + rect.top;    
                        }    
                    }

                    //
                    // Update the registry flag to reset the Access Point balloon tip if the dialing rules balloon tip is displayed
                    //
                    if (dwBalloonTipsDisplayed & BT_ACCESS_POINTS)
                    {
                        dwBalloonTipsDisplayed = dwBalloonTipsDisplayed & ~BT_ACCESS_POINTS;
                    }   

                }
            }
            else
            {
        
                //  We display only if Access Points are not enabled and the phone number
                //  edit control is not blank.
                //
                if(!m_pArgs->fAccessPointsEnabled && !nPhoneIdx)
                {

                    //
                    // Check to see if we have displayed this balloon tip before.
                    //
                    if (!(dwBalloonTipsDisplayed & BT_ACCESS_POINTS))
                    {
            
                        pszBalloonTitle = CmLoadString(g_hInst, IDMSG_BALLOON_TITLE_ACCESSPOINT);
                        pszBalloonMsg = CmLoadString(g_hInst, IDMSG_BALLOON_MSG_ACCESSPOINT);

                        if (GetWindowRect(hwndNewAPButton, &rect))
                        {
                            //
                            //  Get the coordinates for the New Access Point button.  We want the balloon tip to point
                            //  to half way up the button and 10px left of the right edge.
                            //
                            point.x = rect.right - 10;
                            point.y = ((rect.bottom - rect.top) / 2) + rect.top;

                            //
                            // Update registry value
                            //
                            dwBalloonTipsDisplayed = dwBalloonTipsDisplayed | BT_ACCESS_POINTS;
                        }
                    }
                }
            }

            //
            //  Verify we have the info we need and display the balloon tip
            //    
            if (pszBalloonTitle && pszBalloonMsg && point.x && point.y)
            {
                if (m_pArgs && m_pArgs->pBalloonTip)
                {
                    if (m_pArgs->pBalloonTip->DisplayBalloonTip(&point, TTI_INFO, pszBalloonTitle, pszBalloonMsg, hwndParent))
                    {
                        //
                        //  Write the updated BalloonTipsDisplay flag to the registry
                        //
                        m_pArgs->piniBothNonFav->WPPI(c_pszCmSection, c_pszCmEntryBalloonTipsDisplayed, dwBalloonTipsDisplayed);
                    }
                    else
                    {
                        CMTRACE3(TEXT("BalloonTip failed to display - %s; at coordinates{%li,%li}"),pszBalloonTitle,point.x,point.y);
                    }
                }
            }
 
            CmFree(pszBalloonTitle);
            CmFree(pszBalloonMsg);
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   HaveContextHelp
//
//  Synopsis:   Whether a specific control id has context help
//              This function very easily introducce inconsistance
//              Every dialog should manage its own control, instead having this 
//              function keep track of all the controls.
//
//  Arguments:  hwndDlg     the hwnd of parent dlg
//              hwndCtrl    the hwnd of control
//
//  Returns:    NONE
//
//  History:    henryt  Created     6/26/97
//
//----------------------------------------------------------------------------

BOOL HaveContextHelp(
    HWND    hwndDlg,
    HWND    hwndCtrl
)
{
    //
    // list of controls that we don't provide context help for
    //
    static const int rgiNoContextHelpCtrlId[] = 
    {
        IDC_MAIN_BITMAP,
        IDC_PHONEBOOK_BITMAP,
        IDC_GENERAL_PHONENUMBERS_GROUPBOX,
//        IDC_GENERAL_PRIMARYDESC_DISPLAY,
//        IDC_GENERAL_BACKUPDESC_DISPLAY,
//        IDC_ABOUT_BITMAP,
        IDC_ABOUT_FRAME,
        IDC_ABOUT_VERSION,
        IDC_ABOUT_WARNING,
        IDC_ABOUT_CM_STATIC,
        IDC_ABOUT_VERSION_STATIC,
        IDC_ABOUT_COPYRIGHT_STATIC,
        IDC_ABOUT_SHOCKWAVE_STATIC,
        IDC_INET_ICON,
        IDC_CONNSTAT_ICON,
        IDC_CONNSTAT_DURATION_DISPLAY,
        IDC_CONNSTAT_SPEED_DISPLAY,
        IDC_CONNSTAT_RECEIVED_DISPLAY,
        IDC_CONNSTAT_SENT_DISPLAY,
        IDC_CONNSTAT_DISCONNECT_DISPLAY,
        IDC_DETAILINFO,
        IDC_CONNSTAT_STATIC_CALL_DURATION,
        IDC_CONNSTAT_STATIC_CONNECT_SPEED,
        IDC_CONNSTAT_STATIC_BYTES_RECEIVED,
        IDC_CONNSTAT_STATIC_BYTES_SENT
    };

    UINT    uIdx, uLast;

    MYDBGASSERT(hwndDlg);
    MYDBGASSERT(hwndCtrl);

    for (uIdx=0, uLast=sizeof(rgiNoContextHelpCtrlId)/sizeof(rgiNoContextHelpCtrlId[0]); 
         uIdx < uLast; uIdx++)
    {
        if (GetDlgItem(hwndDlg, rgiNoContextHelpCtrlId[uIdx]) == hwndCtrl)
        {
            break;
        }
    }

    return (uIdx == uLast);
}

// check if TAPI has its information, put up dialog if not
BOOL CGeneralPage::CheckTapi(TapiLinkageStruct *ptlsTapiLink, HINSTANCE hInst) 
{
    LONG lRes;
    LPLINETRANSLATEOUTPUT pltoOutput = NULL;
    DWORD dwLen;
    BOOL bRet = FALSE;

    if (!SetTapiDevice(hInst,ptlsTapiLink,m_szDeviceName)) 
    {
        return bRet;
    }
    
    dwLen = sizeof(*pltoOutput) + (1024 * sizeof(TCHAR));
    pltoOutput = (LPLINETRANSLATEOUTPUT) CmMalloc(dwLen);
    if (NULL == pltoOutput)
    {
        return bRet;
    }
    
    pltoOutput->dwTotalSize = dwLen;

    lRes = ptlsTapiLink->pfnlineTranslateAddress(ptlsTapiLink->hlaLine,
                                                  ptlsTapiLink->dwDeviceId,
                                                  ptlsTapiLink->dwApiVersion,
                                                  TEXT("1234"),
                                                  0,
                                                  LINETRANSLATEOPTION_CANCELCALLWAITING,
                                                  pltoOutput);                                            
    //
    // If the line translate failed, then execute the Dialing Rules UI by calling
    // lineTranslateDialog (inside OnDialingProperties). Providing that the user 
    // completes the UI, TAPI will be initialized and ready for use.
    //
    
    if (ERROR_SUCCESS != lRes) 
    {
        OnDialingProperties();

        //
        // The user may have canceled, so test again before declaring success
        //
        
        lRes = ptlsTapiLink->pfnlineTranslateAddress(ptlsTapiLink->hlaLine,
                                                  ptlsTapiLink->dwDeviceId,
                                                  ptlsTapiLink->dwApiVersion,
                                                  TEXT("1234"),
                                                  0,
                                                  LINETRANSLATEOPTION_CANCELCALLWAITING,
                                                  pltoOutput);                                            
    }

    if (ERROR_SUCCESS == lRes) 
    {
        bRet = TRUE;
    }   

    CmFree(pltoOutput);

    m_pArgs->fNeedConfigureTapi = !(bRet);

    return bRet;
}

//+----------------------------------------------------------------------------
//
// Function:  CPropertiesSheet::AddExternalPage
//
// Synopsis:  Add a page to the property sheet.
//
// Arguments: PROPSHEETPAGE * pPsp - The page to add
//
// Returns:   Nothing
//
// History:   tomkel Created 01/09/2001
//
//+----------------------------------------------------------------------------
void CPropertiesSheet::AddExternalPage(PROPSHEETPAGE *pPsp)
{
    //
    // This version of AddExternalPage only work before calling DoPropertySheet
    //
    MYDBGASSERT(pPsp);

    if (!pPsp)
    {
        return;
    }
    CMTRACE1(TEXT("CPropertiesSheet::AddExternalPage - sizeof(PROPSHEETPAGE) = %d"),sizeof(PROPSHEETPAGE));
    MYDBGASSERT(m_numPages < MAX_PAGES);
    CopyMemory((LPVOID)&m_pages[m_numPages], (LPVOID)pPsp, sizeof(PROPSHEETPAGE));
    m_adwPageType[m_numPages] = CPROP_SHEET_TYPE_EXTERNAL;
    m_numPages++;

}
//+----------------------------------------------------------------------------
//
// Function:  CPropertiesSheet::AddPage
//
// Synopsis:  Add a page to the property sheet.
//
// Arguments: const CPropertiesPage* pPage - The page to add
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/26/98
//
//+----------------------------------------------------------------------------
void CPropertiesSheet::AddPage(const CPropertiesPage* pPage)
{
    //
    // This version of AddPage only work before calling DoPropertySheet
    //
    MYDBGASSERT(pPage);
    MYDBGASSERT(pPage->m_pszTemplate);

    if (!pPage)
    {
        return;
    }

    MYDBGASSERT(m_numPages < MAX_PAGES);
    m_pages[m_numPages].pszTemplate = pPage->m_pszTemplate;
    m_pages[m_numPages].lParam = (LPARAM)pPage; // save the property page object
    m_adwPageType[m_numPages] = CPROP_SHEET_TYPE_INTERNAL;
    m_numPages++;
}

//+----------------------------------------------------------------------------
//
// Function:  CPropertiesSheet::DoPropertySheet
//
// Synopsis:  Call PropertySheet to create a modal property sheet
//
// Arguments: HWND hWndParent - Parent window
//            LPTSTR pszCaption - Title string
//            HINSTANCE hInst - The resource instance
//            UINT nStartPage - The start page
//
// Returns:   int - return value of PropertySheet()
//
// History:   fengsun Created Header    2/26/98
//
//+----------------------------------------------------------------------------
int CPropertiesSheet::DoPropertySheet(HWND hWndParent, LPTSTR pszCaption, HINSTANCE hInst)
{
    for (UINT i=0; i<m_numPages; i++) 
    {
        //
        // Only do this for our CM property pages that are classes
        //
        if (m_adwPageType[i] == CPROP_SHEET_TYPE_INTERNAL)
        {
            m_pages[i].dwSize = sizeof(PROPSHEETPAGE);
            m_pages[i].hInstance = hInst;
            m_pages[i].dwFlags = 0;  // No help button or F1
            m_pages[i].pfnDlgProc = (DLGPROC)CPropertiesPage::PropPageProc;
        }
    }

    m_psh.dwSize = sizeof(PROPSHEETHEADER);
    m_psh.hwndParent = hWndParent;
    m_psh.hInstance = hInst;
    m_psh.pszIcon = 0;
    m_psh.pszCaption = pszCaption; // MAKEINTRESOURCE(nCaption);
    m_psh.nPages = m_numPages;
    m_psh.nStartPage = 0; 
    m_psh.ppsp = m_pages;
    m_psh.dwFlags = PSH_PROPSHEETPAGE|PSH_NOAPPLYNOW|PSH_USECALLBACK;
    m_psh.pfnCallback = PropSheetProc;

    //
    // Dynamiclly load comctl32.dll
    //
    int iRet = -1;

    HINSTANCE hComCtl = LoadLibraryExA("comctl32.dll", NULL, 0);

    CMASSERTMSG(hComCtl, TEXT("LoadLibrary - comctl32 failed"));

    if (hComCtl != NULL)
    {
        typedef int (*PROPERTYSHEETPROC)(LPCPROPSHEETHEADER lppsph); 
        typedef void (*INITCOMMONCONTROLSPROC)(VOID);


        PROPERTYSHEETPROC fnPropertySheet;
        INITCOMMONCONTROLSPROC fnInitCommonControls;
    
        LPSTR pszPropSheetFuncName = OS_NT ? "PropertySheetW" : "PropertySheetA";
        fnPropertySheet = (PROPERTYSHEETPROC)GetProcAddress(hComCtl, pszPropSheetFuncName);
        fnInitCommonControls = (INITCOMMONCONTROLSPROC)GetProcAddress(hComCtl, "InitCommonControls");


        if (fnPropertySheet == NULL || fnInitCommonControls == NULL)
        {
            CMTRACE(TEXT("GetProcAddress of comctl32 failed"));
        }
        else
        {
            fnInitCommonControls();

            //
            // Set m_pThis right before we call PropertySheet
            // It will be used by PropSheetProc. 
            // Note: this is not multi-thread safe.  However, there is very little chance
            // that another thread is trying to bring up settings at the same time, and 
            // a context switch happens before PropSheetProc got called
            //

            MYDBGASSERT(m_pThis == NULL);
            m_pThis = this;

            if ((iRet = fnPropertySheet(&m_psh)) == -1)
            {
                CMTRACE(TEXT("DoPropertySheet: PropertySheet() failed"));
            }
        }

        FreeLibrary(hComCtl);
    }

    return iRet;
}

//
// Implementation of class CPropertiesPage
//



//+----------------------------------------------------------------------------
//
// Function:  CPropertiesPage::CPropertiesPage
//
// Synopsis:  Constructor
//
// Arguments: UINT nIDTemplate - Resource ID of the page
//            const DWORD* pHelpPairs - The pairs of ControlID/HelpID
//            const TCHAR* lpszHelpFile - The help file name
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/26/98
//
//+----------------------------------------------------------------------------
CPropertiesPage::CPropertiesPage(UINT nIDTemplate, const DWORD* pHelpPairs, const TCHAR* lpszHelpFile )
    :CWindowWithHelp(pHelpPairs, lpszHelpFile)
{
    m_pszTemplate = MAKEINTRESOURCE(nIDTemplate);
}

CPropertiesPage::CPropertiesPage(LPCTSTR lpszTemplateName, const DWORD* pHelpPairs, 
                             const TCHAR* lpszHelpFile)
    :CWindowWithHelp(pHelpPairs, lpszHelpFile)
{
    m_pszTemplate = lpszTemplateName;
}



//+----------------------------------------------------------------------------
//
// Function:  CPropertiesPage::OnInitDialog
//
// Synopsis:  Virtual function. Called upon WM_INITDIALOG message
//
// Arguments: None
//
// Returns:   BOOL - return value of the message
//
// History:   fengsun Created Header    2/26/98
//
//+----------------------------------------------------------------------------
BOOL CPropertiesPage::OnInitDialog()
{
    return TRUE;
}



//+----------------------------------------------------------------------------
//
// Function:  CPropertiesPage::OnCommand
//
// Synopsis:  Virtual function. Called upon WM_COMMAND
//
// Arguments: WPARAM - wParam of the message
//            LPARAM - lParam of the message
//
// Returns:   DWORD - return value of the message
//
// History:   fengsun Created Header    2/26/98
//
//+----------------------------------------------------------------------------
DWORD CPropertiesPage::OnCommand(WPARAM , LPARAM  )
{
    return 0;
}


//+----------------------------------------------------------------------------
//
// Function:  CPropertiesPage::OnSetActive
//
// Synopsis:  Virtual function. Called upon WM_NOTIFY with PSN_SETACTIVE
//
// Arguments: None
//
// Returns:   BOOL - return value of the message
//
// History:   fengsun Created Header    2/26/98
//
//+----------------------------------------------------------------------------
BOOL CPropertiesPage::OnSetActive()
{
    return 0;
}



//+----------------------------------------------------------------------------
//
// Function:  CPropertiesPage::OnKillActive
//
// Synopsis:  Virtual function. Called upon WM_NOTIFY with PSN_KILLACTIVE
//            Notifies a page that it is about to lose activation either because 
//            another page is being activated or the user has clicked the OK button.
//
// Arguments: None
//
// Returns:   BOOL - return value of the message
//
// History:   fengsun Created Header    2/26/98
//
//+----------------------------------------------------------------------------
BOOL CPropertiesPage::OnKillActive()
{
    return FALSE;
}

//+----------------------------------------------------------------------------
//
// Function:  CPropertiesPage::OnApply
//
// Synopsis:  Virtual function. Called upon WM_NOTIFY with PSN_APPLY
//            Indicates that the user clicked the OK or Apply Now button 
//            and wants all changes to take effect. 
//
// Arguments: None
//
// Returns:   NONE
//
// History:   fengsun Created Header    2/26/98
//
//+----------------------------------------------------------------------------
void CPropertiesPage::OnApply()
{
    SetPropSheetResult(PSNRET_NOERROR);
}

//+----------------------------------------------------------------------------
//
// Function:  CPropertiesPage::OnReset
//
// Synopsis:  Virtual function. Called upon WM_NOTIFY with PSN_RESET
//            Notifies a page that the user has clicked the Cancel button and 
//            the property sheet is about to be destroyed. 
//
// Arguments: None
//
// Returns:   NONE
//
// History:   fengsun Created Header    2/26/98
//
//+----------------------------------------------------------------------------
void CPropertiesPage::OnReset()
{
}



//+----------------------------------------------------------------------------
//
// Function:  CPropertiesPage::OnPsnHelp
//
// Synopsis:  Virtual function. Called upon WM_NOTIFY with PSN_HELP
//
// Arguments: HWND - Window handle to the control sending a message
//            UINT - Identifier of the control sending a message
//
// Returns:   Nothing
//
// History:   Created Header    2/26/98
//
//+----------------------------------------------------------------------------
void CPropertiesPage::OnPsnHelp(HWND , UINT_PTR)
{
    if (m_lpszHelpFile && m_lpszHelpFile[0])
    {
        CmWinHelp(m_hWnd, m_hWnd, m_lpszHelpFile, HELP_FORCEFILE, 0);
    }
}




//+----------------------------------------------------------------------------
//
// Function:  CPropertiesPage::OnOtherMessage
//
// Synopsis:  Callup opun message other than WM_INITDIALOG and WM_COMMAND
//
// Arguments: UINT - Message Id
//            WPARAM - wParam of the message
//            LPARAM - lParam of the message
//
// Returns:   DWORD - return value of the message
//
// History:   fengsun Created Header    2/26/98
//
//+----------------------------------------------------------------------------
DWORD CPropertiesPage::OnOtherMessage(UINT , WPARAM , LPARAM  )
{
    return FALSE;
}

//+----------------------------------------------------------------------------
//
// Function:  CPropertiesPage::PropPageProc
//
// Synopsis:  The call back dialog procedure for all the property pages
//
// Arguments: HWND hwndDlg - Property page window handle
//            UINT uMsg - Message ID
//            WPARAM wParam - wParam of the message
//            LPARAM lParam - lParam of the message
//
// Returns:   BOOL  - return value of the message
//
// History:   fengsun Created Header    2/26/98
//
//+----------------------------------------------------------------------------
INT_PTR CALLBACK CPropertiesPage::PropPageProc(HWND hwndDlg,UINT uMsg,WPARAM wParam, LPARAM lParam)
{
    CPropertiesPage* pPage;
    NMHDR* pnmHeader = (NMHDR*)lParam;

    //
    // Save the object pointer on the first message,
    // The first message is not necessarily WM_INITDIALOG
    //
    if (uMsg == WM_INITDIALOG)
    {
        pPage = (CPropertiesPage*) ((PROPSHEETPAGE *)lParam)->lParam;

        //
        // Save the object pointer, this is implementation detail
        // The user of this class should not be aware of this
        //
        ::SetWindowLongU(hwndDlg, DWLP_USER, (LONG_PTR)pPage);

        MYDBGASSERT(pPage);
        MYDBGASSERT(pPage->m_hWnd == NULL);

        pPage->m_hWnd = hwndDlg;
    }
    else
    {
        pPage = (CPropertiesPage*) GetWindowLongU(hwndDlg,DWLP_USER);

        if (pPage == NULL)
        {
            return FALSE;
        }

        MYDBGASSERT(pPage->m_hWnd == hwndDlg);
    }

    ASSERT_VALID(pPage);

    switch(uMsg)
    {
    case WM_INITDIALOG:
        return pPage->OnInitDialog();

    case WM_COMMAND:
        return (BOOL)pPage->OnCommand(wParam, lParam);

    case WM_NOTIFY:
        {    
            if (NULL == pnmHeader)
            {
                return FALSE;
            }            

            switch (pnmHeader->code) 
            {
                case PSN_SETACTIVE:
                    pPage->OnSetActive();
                    break;

                case PSN_KILLACTIVE:
                    pPage->OnKillActive();
                    break;  

                case PSN_APPLY:
                    pPage->OnApply();
                    return TRUE;

                case PSN_RESET:
                    pPage->OnReset();
                    break;

                case PSN_HELP:
                    pPage->OnPsnHelp(pnmHeader->hwndFrom , pnmHeader->idFrom);
                    break;

                default:
                    break;
            }

            break;
        } // WM_NOTIFY

        case WM_HELP:
            pPage->OnHelp((LPHELPINFO)lParam);
            return TRUE;

        case WM_CONTEXTMENU:
            {
                POINT   pos = {LOWORD(lParam), HIWORD(lParam)};
                
                CMTRACE3(TEXT("\r\nPropPageProc() - WM_CONTEXTMENU wParam = %u pos.x = %u, pos.y = %u"),
                    wParam, pos.x, pos.y);

                pPage->OnContextMenu((HWND) wParam, pos);
                return TRUE;
            }

        default:
             return (BOOL)pPage->OnOtherMessage(uMsg, wParam, lParam);
    }

    return (FALSE);
}

//
// Help id pairs for dialing page
//
const DWORD CGeneralPage::m_dwHelp[] = {
        IDC_GENERAL_PHONENUMBERS_GROUPBOX,  IDH_GENERAL_PHONENUM,
        IDC_RADIO_DIRECT,                   IDH_GENERAL_ALREADY,
        IDC_RADIO_DIALUP,                   IDH_GENERAL_DIALTHIS,
        IDC_GENERAL_P1_STATIC,              IDH_GENERAL_PHONENUM,
        IDC_GENERAL_PRIMARY_EDIT,           IDH_GENERAL_PHONENUM,
        IDC_GENERAL_PRIMARYPB_BUTTON,       IDH_GENERAL_PHONEBOOK,
        IDC_GENERAL_UDR1_CHECKBOX,          IDH_GENERAL_USE_DIAL_RULE,
        IDC_GENERAL_P2_STATIC,              IDH_GENERAL_BACKUPNUM,
        IDC_GENERAL_BACKUP_EDIT,            IDH_GENERAL_BACKUPNUM,
        IDC_GENERAL_BACKUPPB_BUTTON,        IDH_GENERAL_PHONEBOOKB,
        IDC_GENERAL_UDR2_CHECKBOX,          IDH_GENERAL_USE_DIAL_RULEB,
        IDC_GENERAL_TAPI_BUTTON,            IDH_GENERAL_DIALRULE,
        IDC_GENERAL_MODEM_COMBO,            IDH_GENERAL_CONNECT_MODEM,
        IDC_CONNECT_USING,                  IDH_GENERAL_CONNECT_MODEM,
        IDC_GENERAL_ACCESSPOINT_COMBO,       IDH_GENERAL_ACCESSPOINTS,
        IDC_GENERAL_ACCESSPOINT_STATIC,      IDH_GENERAL_ACCESSPOINTS,
        IDC_GENERAL_NEWAP_BUTTON,            IDH_GENERAL_NEWAP,
        IDC_GENERAL_DELETEAP_BUTTON,         IDH_GENERAL_DELETEAP,
        0,0};
        
//+----------------------------------------------------------------------------
//
// Function:  CGeneralPage::CGeneralPage
//
// Synopsis:  Constructor
//
// Arguments: ArgsStruct* pArgs - Information needed for the page
//            UINT nIDTemplate - Resource ID
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/26/98
//
//+----------------------------------------------------------------------------
CGeneralPage::CGeneralPage(ArgsStruct* pArgs, UINT nIDTemplate) 
    : CPropertiesPage(nIDTemplate, m_dwHelp, pArgs->pszHelpFile)
{
    MYDBGASSERT(pArgs);
    m_pArgs = pArgs;
    m_pEventListener = NULL;

    m_NumPhones = MAX_PHONE_NUMBERS;

    m_szDeviceName[0] = TEXT('\0');
    m_szDeviceType[0] = TEXT('\0');

    m_bDialInfoInit = FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   CGeneralPage::OnInitDialog
//
//  Synopsis:   Init the General properties property sheet.
//
//  Arguments:  hwndDlg [dlg window handle]
//              pArgs [the ptr to ArgsStruct]
//
//  Returns:    NONE
//
//  History:    henryt  Created     4/30/97
//              byao    Modified    5/12/97     - disable backup phone no. in
//                                                'Dialing with Connectoid' mode
//----------------------------------------------------------------------------

BOOL CGeneralPage::OnInitDialog()
{
    UpdateFont(m_hWnd);

    //
    // Load the Access Points from the registry
    //
    if (FALSE == ShowAccessPointInfoFromReg(m_pArgs, m_hWnd, IDC_GENERAL_ACCESSPOINT_COMBO))
    {
        // 
        // If the above function fails then there is no Access Point in the registry. 
        // Need to figure out if this is the default access point.
        //
        LPTSTR pszTempDefaultAccessPointName = CmLoadString(g_hInst, IDS_DEFAULT_ACCESSPOINT);
        if (pszTempDefaultAccessPointName)
        {
            if (0 == lstrcmpiU(m_pArgs->pszCurrentAccessPoint, pszTempDefaultAccessPointName))
            {
                // 
                // This must be an old (1.0 or 1.2) profile since it's the default Access Point and it isn't 
                // in the registry yet. Need to properly display the Access Point combobox and 
                // create the reg key. Calling AddNewAPToReg does that.
                //
                AddNewAPToReg(m_pArgs->pszCurrentAccessPoint, TRUE);

                //
                // Need to clear the AccessPointEnabled Flag. This is a side effect of calling AddNewAPToReg
                // thus it needs to be cleared (set to FALSE) since we only have one Access Point and
                // the this flag is only set if we have 1+ Access Points
                //
                m_pArgs->fAccessPointsEnabled = FALSE;
                WriteUserInfoToReg(m_pArgs, UD_ID_ACCESSPOINTENABLED, (PVOID) &m_pArgs->fAccessPointsEnabled);
            }
            CmFree(pszTempDefaultAccessPointName);
        }
    }

    //
    // Set phone number descriptions
    //    
    UpdateForNewAccessPoint(TRUE);
    
    //
    // Subclass the Phone Number edit controls
    //
    HWND hwndPrimary = GetDlgItem(m_hWnd, IDC_GENERAL_PRIMARY_EDIT);
    HWND hwndBackup = GetDlgItem(m_hWnd, IDC_GENERAL_BACKUP_EDIT);

    MYDBGASSERT(hwndPrimary && hwndBackup);

    m_pfnOrgEditWndProc = (WNDPROC)SetWindowLongU(hwndPrimary, 
                GWLP_WNDPROC, (LONG_PTR)SubClassEditProc);
    WNDPROC lpEditProc = (WNDPROC)SetWindowLongU(hwndBackup, 
                GWLP_WNDPROC, (LONG_PTR)SubClassEditProc);
    MYDBGASSERT(lpEditProc == m_pfnOrgEditWndProc);

    //
    // Save the object with the window handle
    //

    SetWindowLongU(hwndPrimary, GWLP_USERDATA, (LONG_PTR)this);
    SetWindowLongU(hwndBackup, GWLP_USERDATA, (LONG_PTR)this);
    
    return (TRUE);
}


//+---------------------------------------------------------------------------
//
//  Function:   CGeneralPage::UpdateForNewAccessPoint
//
//  Synopsis:   Set the phone number description from pArgs. 
//
//  Notes:      This function was originally part of OnInitDialog. 
//              It was made into a separate function for access points
//
//  Arguments:  fSetPhoneNumberDescriptions [update phone numbers as well]
//
//  Returns:    NONE
//
//  History:    t-urama  Created     07/31/2000
//----------------------------------------------------------------------------    
void CGeneralPage::UpdateForNewAccessPoint(BOOL fSetPhoneNumberDescriptions)
{
    m_bAPInfoChanged = FALSE;
    LPTSTR pszDefaultAccessPointName = CmLoadString(g_hInst, IDS_DEFAULT_ACCESSPOINT);

    if (pszDefaultAccessPointName && m_pArgs->pszCurrentAccessPoint)
    {
        if (!lstrcmpiU(m_pArgs->pszCurrentAccessPoint, pszDefaultAccessPointName))
        {
            EnableWindow(GetDlgItem(m_hWnd, IDC_GENERAL_DELETEAP_BUTTON), FALSE);
        }
        else
        {
            EnableWindow(GetDlgItem(m_hWnd, IDC_GENERAL_DELETEAP_BUTTON), TRUE);
        }
    }
    else
    {
        CMASSERTMSG(FALSE, TEXT("UpdateForNewAccessPoint -- either CmLoadString of IDS_DEFAULT_ACCESSPOINT failed or pszCurrentAccessPoint is NULL."));
    }

    CmFree(pszDefaultAccessPointName);

    if (fSetPhoneNumberDescriptions)
    {
        UpdateNumberDescription(0, m_pArgs->aDialInfo[0].szDesc);
        UpdateNumberDescription(1, m_pArgs->aDialInfo[1].szDesc);

        if (m_pArgs->IsBothConnTypeSupported())
        {
            //
            // Set radio button according to AlwaysOn state
            //
            if (m_pArgs->IsDirectConnect())
            {              
                CheckDlgButton(m_hWnd, IDC_RADIO_DIRECT, BST_CHECKED); 
                CheckDlgButton(m_hWnd, IDC_RADIO_DIALUP, BST_UNCHECKED);
                EnableDialupControls(FALSE);
            }
            else
            {
                CheckDlgButton(m_hWnd, IDC_RADIO_DIALUP, BST_CHECKED); 
                CheckDlgButton(m_hWnd, IDC_RADIO_DIRECT, BST_UNCHECKED);
                PostMessageU(m_hWnd, WM_INITDIALINFO, 0,0);
            }
        }
        else
        {
            //
            // Note: It is assumed that this page will never be loaded in a pure direct
            // case, thus the deduction that NOT IsBothConnTypeSupported means dial only.
            //
            MYDBGASSERT(!m_pArgs->IsDirectConnect());
            PostMessageU(m_hWnd, WM_INITDIALINFO, 0,0);
        }
    }
}

//+----------------------------------------------------------------------------
//
// Function:  CGeneralPage::EnableDialupControls
//
// Synopsis:  Sets the enabled state of ALL the dialup controls on the tab
//
// Arguments: BOOL fEnable - flag indicating enable state of dial-up controls
//
// Returns:   Nothing
//
// History:   nickball  Created     04/21/98
//
//+----------------------------------------------------------------------------
void CGeneralPage::EnableDialupControls(BOOL fEnable)
{
    BOOL fState = fEnable;

    EnableWindow(GetDlgItem(m_hWnd, IDC_GENERAL_P1_STATIC), fState);
    EnableWindow(GetDlgItem(m_hWnd, IDC_GENERAL_PRIMARY_EDIT), fState);
    EnableWindow(GetDlgItem(m_hWnd, IDC_GENERAL_P2_STATIC), fState);   
    EnableWindow(GetDlgItem(m_hWnd, IDC_GENERAL_BACKUP_EDIT), fState);
    EnableWindow(GetDlgItem(m_hWnd, IDC_CONNECT_USING), fState);
    EnableWindow(GetDlgItem(m_hWnd, IDC_GENERAL_MODEM_COMBO), fState);    

    //
    // We are enabling controls check PB buttons
    //

    fState = FALSE;

    if (fEnable)
    {
        //
        // No phonebooks, no button access
        //

        if (m_pArgs->fHasValidTopLevelPBK || m_pArgs->fHasValidReferencedPBKs) 
        {
            fState = TRUE;
        }
    }
            
    EnableWindow(GetDlgItem(m_hWnd, IDC_GENERAL_PRIMARYPB_BUTTON), fState);
    EnableWindow(GetDlgItem(m_hWnd, IDC_GENERAL_BACKUPPB_BUTTON), fState);

    //
    // Examine the canonical phone number, we must have a canonical form 
    // of the number available for Use Dailing Rules to be enabled.
    //
   
    if (fEnable && *m_DialInfo[0].szCanonical)
    {
        fState = TRUE;
    }
    else
    {
        fState = FALSE;
    }
    
    EnableWindow(GetDlgItem(m_hWnd, IDC_GENERAL_UDR1_CHECKBOX), fState);            

    //
    // Examine the canonical phone number, we must have a canonical form 
    // of the number available for Use Dailing Rules to be enabled.
    //

    if (fEnable && *m_DialInfo[1].szCanonical)
    {
        fState = TRUE;
    }
    else
    {
        fState = FALSE;
    }
    
    EnableWindow(GetDlgItem(m_hWnd, IDC_GENERAL_UDR2_CHECKBOX), fState);     

    //
    // Update dialing rules state
    //
       
    if (fEnable)
    {
        UpdateDialingRulesButton();
    }
    else
    {
        EnableWindow(GetDlgItem(m_hWnd, IDC_GENERAL_TAPI_BUTTON), fEnable);
    }
}

//+----------------------------------------------------------------------------
//
// Function:  CGeneralPage::OnOtherMessage
//
// Synopsis:  Callup opun message other than WM_INITDIALOG and WM_COMMAND
//
// Arguments: UINT - Message Id
//            WPARAM - wParam of the message
//            LPARAM - lParam of the message
//
// Returns:   DWORD - return value of the message
//
// History:   fengsun Created Header    2/26/98
//
//+----------------------------------------------------------------------------
DWORD CGeneralPage::OnOtherMessage(UINT uMsg, WPARAM , LPARAM )
{
    if (uMsg == WM_INITDIALINFO)
    {
        InitDialInfo();
    }
    return FALSE;
}

//+----------------------------------------------------------------------------
//
// Function:  IsUniqueIsdnDevice
//
// Synopsis:  Checks to see if this is an ISDN device and if it was already added
//            to the ComboBox control identified by hWnd and nId
//
// Arguments: None
//
// Returns:   BOOL - Returns TRUE if a Unique ISDN Device
//
// History:   quintinb 7/14/99 created
//
//+----------------------------------------------------------------------------
BOOL IsUniqueIsdnDevice(HWND hWnd, UINT nId, LPRASDEVINFO pRasDevInfo)
{
    BOOL bReturn = FALSE;

    if (hWnd && nId && pRasDevInfo)
    {
        //
        //  First lets check to make sure that this is even an ISDN device
        //
        if (0 == lstrcmpiU(pRasDevInfo->szDeviceType, RASDT_Isdn))
        {
            //
            //  Okay, it is an ISDN device, do we have one with that name already?
            //
            if (CB_ERR == SendDlgItemMessageU(hWnd, nId, CB_FINDSTRINGEXACT,
                                              -1, (LPARAM)pRasDevInfo->szDeviceName))
            {
                bReturn = TRUE;
            }
        }
    }

    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  CGeneralPage::InitDialInfo
//
// Synopsis:  The dialing page can not call LoadDialInfo directly on WM_INITDIALOG
//            LoadDialInfo might popup some UI to install modem.  The property 
//            sheet and the property page will not be disabled, if a dialog is 
//            poped up on WM_INITDIALOG message.  Instead, we post a message
//            on WM_INITDIALOG and call LoadDialInfo here.
//            On a slow machine, there might be a period that all the control
//            are gray.
//
// Arguments: None
//
// Returns:   DWORD - Return code from LoadDialInfo
//
// History:   fengsun    2/26/98    Created Header   
//            nickball   4/24/98    Added return code
//
//+----------------------------------------------------------------------------
DWORD CGeneralPage::InitDialInfo()
{
    HCURSOR hPrev = SetCursor(LoadCursorU(NULL,IDC_WAIT));

    //
    // Make sure the dial info is loaded
    //
    
    DWORD dwRet = LoadDialInfo(m_pArgs, m_hWnd);
      
    if (dwRet == ERROR_PORT_NOT_AVAILABLE)
    {
        //
        // No modem avaliable, update direct/dial controls if any 
        //

        if (m_pArgs->IsBothConnTypeSupported())
        {
            CheckDlgButton(m_hWnd, IDC_RADIO_DIALUP, BST_UNCHECKED); 
            CheckDlgButton(m_hWnd, IDC_RADIO_DIRECT, BST_CHECKED);          
            SetFocus(GetDlgItem(m_hWnd, IDC_RADIO_DIRECT));
        }
        else
        {
            //
            // Make sure user can exit using keyboard by explicitly
            // setting cancel button as default and giving it focus.
            //
            
            HWND hwndParent = GetParent(m_hWnd);

            MYDBGASSERT(hwndParent);

            if (hwndParent)
            {
                SendMessageU(hwndParent, DM_SETDEFID, (WPARAM)IDCANCEL, 0);
                SetFocus(GetDlgItem(hwndParent, IDCANCEL));
            }
        }

        //
        // Disable everything dial-up
        //

        EnableDialupControls(FALSE);
        
        SetCursor(hPrev);

        return dwRet;
    }
    
    lstrcpynU(m_szDeviceName, m_pArgs->szDeviceName, CELEMS(m_szDeviceName));

    //
    // Init the tmp phone array, it'll possibly be modified
    //
    m_DialInfo[0] = m_pArgs->aDialInfo[0];
    m_DialInfo[1] = m_pArgs->aDialInfo[1];

    EnableDialupControls(TRUE);

    //
    // Check TAPI before translating address
    //
    
    CheckTapi(&m_pArgs->tlsTapiLink, g_hInst);
    
    //
    // Set limit for phone # length. Use OS to determine intial default, but 
    // allow admin override. 
    //
    
    UINT i = (OS_NT ? MAX_PHONE_LENNT : MAX_PHONE_LEN95);
    
    i = (int) m_pArgs->piniService->GPPI(c_pszCmSection, c_pszCmEntryMaxPhoneNumber, i);

    //
    // Even override is limited, in this case by our storage at RAS_MaxPhoneNumber
    //

    i = __min(i, RAS_MaxPhoneNumber);

    SendDlgItemMessageU(m_hWnd, IDC_GENERAL_PRIMARY_EDIT, EM_SETLIMITTEXT, i, 0);
    SendDlgItemMessageU(m_hWnd, IDC_GENERAL_BACKUP_EDIT, EM_SETLIMITTEXT, i, 0);

    //
    // display the munged phone #'s
    //

    for (i = 0; i < m_NumPhones; i++)
    {       
        DisplayMungedPhone(i);

        int iCtrl = (i? IDC_GENERAL_UDR2_CHECKBOX : IDC_GENERAL_UDR1_CHECKBOX);
       
        //
        // Set "Use Dialing Rules". If there is a canonical value then honor 
        // the USE_DIALING_RULES flag. Otherwise, its a hand edited number, 
        // so we disable the check for dialing rules. Note: this logic is also
        // used in EnableDialupControls().
        //
        
        if (!m_DialInfo[i].szCanonical[0]) 
        {
            EnableWindow(GetDlgItem(m_hWnd, iCtrl), FALSE);
        }
        else
        {
            CheckDlgButton(m_hWnd, 
                           iCtrl, 
                           (m_DialInfo[i].dwPhoneInfoFlags & PIF_USE_DIALING_RULES));
        }        
    }

    //
    // Set TAPI button display according to dialing rules use.
    //  

    UpdateDialingRulesButton();

    //
    // Standard dial: If we have no phone books, disable the buttons
    //

    if (!m_pArgs->fHasValidTopLevelPBK && !m_pArgs->fHasValidReferencedPBKs) 
    {
        EnableWindow(GetDlgItem(m_hWnd, IDC_GENERAL_PRIMARYPB_BUTTON), FALSE);
        EnableWindow(GetDlgItem(m_hWnd, IDC_GENERAL_BACKUPPB_BUTTON), FALSE);
    }
  
    DWORD           dwCnt;
    DWORD dwIdx;

    if (!m_bDialInfoInit)
    {
        // Initialize the modem combo box only once. This does not use any of the 
        // access point info.
        //
        //
        // Init the modem combo box.  ISDN devices are a special case because they
        // have two channels and thus usually enumerate each channel as a device.
        // The old style handling was to only show the first ISDN device on the machine.
        // This worked but won't allow a user to use a second ISDN device with CM should
        // they have one.  We will keep the old behavior on legacy platforms but on NT5
        // we will try to do the right thing and only not enumerate a second device if
        // we already have one of those in the list.  This will filter out second channels
        // and will give the user access to another ISDN device as long as it isn't of the same
        // name as the first.  Definitely not a great solution but this close to ship it is the
        // best we can do.  Note that for ISDN devices we want to only show
        // one device even though RAS may enumerate two (one for each channe
        //
    
        SendDlgItemMessageU(m_hWnd, IDC_GENERAL_MODEM_COMBO, CB_RESETCONTENT, 0, 0L);

        LPRASDEVINFO    prdiRasDevInfo;
        

        if (GetRasModems(&m_pArgs->rlsRasLink, &prdiRasDevInfo, &dwCnt)) 
        {
            
            //
            // add modem list to modem-combo
            // 
            for (dwIdx=0; dwIdx < dwCnt; dwIdx++) 
            {
                //
                // filter out tunnel device, IRDA, and Parallel ports.
                //
                if (!lstrcmpiU(prdiRasDevInfo[dwIdx].szDeviceType, RASDT_Modem)                  || // a modem
                    !lstrcmpiU(prdiRasDevInfo[dwIdx].szDeviceType, RASDT_Atm)                    || // an ATM device
                    IsUniqueIsdnDevice(m_hWnd, IDC_GENERAL_MODEM_COMBO, &prdiRasDevInfo[dwIdx]))    // an ISDN modem, note we 
                                                                                                    // filter out the channels
                                                                                                    // and show only one device 
                {
                    //
                    //  Add the device to the Device Combo Box
                    //
                    SendDlgItemMessageU(m_hWnd, IDC_GENERAL_MODEM_COMBO, CB_ADDSTRING,
                                        0, (LPARAM)prdiRasDevInfo[dwIdx].szDeviceName);
                }
            }
        }
        
        CmFree(prdiRasDevInfo);
    }

    dwCnt = (DWORD)SendDlgItemMessageU(m_hWnd, IDC_GENERAL_MODEM_COMBO, CB_GETCOUNT, 0, 0);
    if (dwCnt == 0) 
    {
       dwIdx = (DWORD)CB_ERR;
    } 
    else if (dwCnt == 1) 
    {
        dwIdx = 0;
    } 
    else 
    {
        dwIdx = (DWORD)SendDlgItemMessageU(m_hWnd,
                                   IDC_GENERAL_MODEM_COMBO,
                                   CB_FINDSTRINGEXACT,
                                   0,
                                   (LPARAM)m_szDeviceName);
    }
        
    if (dwIdx != CB_ERR) 
    {
        SendDlgItemMessageU(m_hWnd, IDC_GENERAL_MODEM_COMBO, CB_SETCURSEL, (WPARAM)dwIdx, 0L);
    

        //
        // Reset the tmp modem var
        //

        GetDlgItemTextU(m_hWnd, IDC_GENERAL_MODEM_COMBO, m_szDeviceName, RAS_MaxDeviceName+1);

        //
        // GetDeviceType will fill the szDeviceType according to szDeviceName
        //
        if (!GetDeviceType(m_pArgs, m_szDeviceType, CELEMS(m_szDeviceType), m_szDeviceName))
        {
            //
            // if GetDeviceType() failed, something's wrong.  just use the devicetype
            // that we've been using.
            //
            lstrcpynU(m_szDeviceType, m_pArgs->szDeviceType, CELEMS(m_szDeviceType));
        }
    }

    

    //
    // Disable DialingProperties button if no modem selected
    //
    
    if (IsWindowEnabled(GetDlgItem(m_hWnd, IDC_GENERAL_TAPI_BUTTON)))
    {
        EnableWindow(GetDlgItem(m_hWnd, IDC_GENERAL_TAPI_BUTTON), m_szDeviceName[0] != 0);
    }

    m_bDialInfoInit = TRUE;

    SetCursor(hPrev);

    return dwRet;
}

//+----------------------------------------------------------------------------
//
// Function:  CGeneralPage::OnCommand
//
// Synopsis:  Virtual function. Called upon WM_COMMAND
//
// Arguments: WPARAM - wParam of the message
//            LPARAM - lParam of the message
//
// Returns:   DWORD - return value of the message
//
// History:   fengsun Created Header    2/26/98
//
//+----------------------------------------------------------------------------
DWORD CGeneralPage::OnCommand(WPARAM wParam, LPARAM)
{
    //
    //  Hide any open balloon tips
    //
    if (m_pArgs->pBalloonTip)
    {
        m_pArgs->pBalloonTip->HideBalloonTip();
    }

    switch (LOWORD(wParam)) 
    {
        case IDC_GENERAL_UDR1_CHECKBOX:
        case IDC_GENERAL_UDR2_CHECKBOX:
        {
            int i = (LOWORD(wParam) == IDC_GENERAL_UDR1_CHECKBOX? 0 : 1);
            
            if (IsDlgButtonChecked(m_hWnd, LOWORD(wParam)))
            {
                int iEditID = i ? IDC_GENERAL_BACKUP_EDIT : IDC_GENERAL_PRIMARY_EDIT;

                m_DialInfo[i].dwPhoneInfoFlags |= PIF_USE_DIALING_RULES;
            }
            else
            {
                m_DialInfo[i].dwPhoneInfoFlags &= ~PIF_USE_DIALING_RULES;       
            }

            //
            // If neither dialing rule is on, disable button.
            //

            UpdateDialingRulesButton();

            DisplayMungedPhone(i);
            m_bAPInfoChanged = TRUE;
            return TRUE;
        }

        case IDC_GENERAL_PRIMARYPB_BUTTON:
        case IDC_GENERAL_BACKUPPB_BUTTON:       
            OnPhoneBookButton(LOWORD(wParam) == IDC_GENERAL_PRIMARYPB_BUTTON ? 0 : 1);
            return (TRUE);

        case IDC_GENERAL_TAPI_BUTTON:
            OnDialingProperties();
            return (TRUE);

        case IDC_RADIO_DIRECT:
            MYDBGASSERT(m_pArgs->IsBothConnTypeSupported());
            m_bAPInfoChanged = TRUE;
            if (BN_CLICKED == HIWORD(wParam)) // notification code 
            {
                EnableDialupControls(FALSE);
            }
            
            return TRUE;
            
        case IDC_RADIO_DIALUP:

            MYDBGASSERT(m_pArgs->IsBothConnTypeSupported());
            m_bAPInfoChanged = TRUE;
            if (BN_CLICKED == HIWORD(wParam)) // notification code 
            {           
                //
                // NT #356821 - nickball
                //
                // Make sure we don't respond until the click is fully 
                // registered as we only want to respond once and in 
                // the case of keyboard navigation a BN_CLICKED 
                // notification is sent before the button takes the 
                // click and afterwards. Mouse navigation causes 
                // one notification once the button already has the 
                // click. Responding to both clicks get us into a nasty
                // little re-entrancy in IntiDialInfo, so we filter out
                // the first notification
                //
                
                if (IsDlgButtonChecked(m_hWnd, IDC_RADIO_DIALUP))
                {                                                                         
                    //
                    // Load dialing information, and enable dial-up controls
                    //
            
                    if (ERROR_PORT_NOT_AVAILABLE != InitDialInfo())
                    {
                        EnableDialupControls(TRUE);
                        SetFocus(GetDlgItem(m_hWnd, IDC_GENERAL_PRIMARY_EDIT));
                    }
                }
            }
            
            return TRUE;
        
        case IDC_GENERAL_DELETEAP_BUTTON:
        {
            if (m_pArgs->pszCurrentAccessPoint)
            {
                LPTSTR pszMsg = CmFmtMsg(g_hInst, IDMSG_DELETE_ACCESSPOINT, m_pArgs->pszCurrentAccessPoint);

                if (pszMsg)
                {
                    if (IDYES == MessageBox(m_hWnd, 
                                            pszMsg, 
                                            m_pArgs->szServiceName, 
                                            MB_YESNO | MB_ICONEXCLAMATION | MB_DEFBUTTON2 | MB_APPLMODAL))
                    {
                        this->DeleteAccessPoint();
                    }
                }

                CmFree(pszMsg);
            }
            return TRUE;
        }

        case IDC_GENERAL_NEWAP_BUTTON:
        {
            //
            //  We need to allow for the case where the user has made a change
            //  to a phone number and has now decided to save this to a *new*
            //  Access Point (AP).  The dialog below asks the user if he/she wants
            //  to save the current changes to the "old" AP (i.e. the AP we're
            //  just leaving).  If the user says No, this means they want to
            //  use these settings for the new AP (the one we're about to ask
            //  them to name).  For this case, we apply all the current phone
            //  number information to the new AP, i.e we _don't_ clear out the
            //  old phone number settings.  See NT bug 301054 for more.
            //
            BOOL bClearOldPhoneNumberSettings = TRUE;

            BOOL bRes = AccessPointInfoChanged();
            if (bRes && m_pArgs->pszCurrentAccessPoint)
            {
                LPTSTR pszMsg = CmFmtMsg(g_hInst, IDMSG_SAVE_ACCESSPOINT, m_pArgs->pszCurrentAccessPoint);
                if (pszMsg)
                {
                    int iRet = MessageBox(m_hWnd, 
                                          pszMsg, 
                                          m_pArgs->szServiceName, 
                                          MB_YESNO | MB_ICONEXCLAMATION | MB_DEFBUTTON1 | MB_APPLMODAL);
                    if (IDYES == iRet)
                    {
                        OnApply();
                    }
                    else if (IDNO == iRet)
                    {
                        bClearOldPhoneNumberSettings = FALSE;
                    }
                    else
                    {
                        MYDBGASSERT(0);
                    }
                }
                
                CmFree(pszMsg);
            }

            LPTSTR pszAPName = NULL;
            CNewAccessPointDlg NewAccessPointDlg(m_pArgs, &pszAPName);

            if (IDOK == NewAccessPointDlg.DoDialogBox(g_hInst, IDD_NEW_ACCESSPOINT, m_hWnd))
            {
                MYDBGASSERT(pszAPName);
                AddNewAPToReg(pszAPName, bClearOldPhoneNumberSettings);
                
                if (FALSE == bClearOldPhoneNumberSettings)
                {
                    //
                    //  Since we didn't clear the phone number settings, we've
                    //  left them in place as initial values for the new AP.  We
                    //  need to mark the new AP as 'dirty' so that when the current
                    //  AP changes, the UI will ask the user to save changes.
                    //  (there's no significance attached to choosing IDC_GENERAL_PRIMARY_EDIT, I
                    //  could just as well have used the other edit control.)
                    //
                    SendDlgItemMessageU(m_hWnd, IDC_GENERAL_PRIMARY_EDIT, EM_SETMODIFY, TRUE, 0);
                }
            }

            CmFree(pszAPName);

            return TRUE;
        }

        default:
            break;
    }
    
    switch (HIWORD(wParam)) 
    {
        case CBN_SELENDOK:

            if (IDC_GENERAL_MODEM_COMBO == LOWORD(wParam))
            {
                TCHAR   szModem[RAS_MaxDeviceName+1];
                TCHAR   szDeviceType[RAS_MaxDeviceType+1];

                MYDBGASSERT(IDC_GENERAL_MODEM_COMBO == LOWORD(wParam));

                GetWindowTextU(GetDlgItem(m_hWnd, IDC_GENERAL_MODEM_COMBO), 
                    szModem, RAS_MaxDeviceName+1);

                if (lstrcmpU(m_szDeviceName, szModem) == 0)
                {
                    // there's no change in the modem
                    return FALSE;
                }
            
                m_bAPInfoChanged = TRUE;
                // 
                // If GetDeviceType fails we won't in fact change the
                // modem even though the user thinks that we did.
                // Logic could possibly be added to notify the user
                // and refresh the device list, but this is a fair
                // amount of work for little gain.
                //

                if (GetDeviceType(m_pArgs, szDeviceType, CELEMS(szDeviceType), szModem))
                { 
                    lstrcpyU(m_szDeviceName, szModem);
                    lstrcpyU(m_szDeviceType, szDeviceType);

                    //
                    // CheckTapi will check (m_szDeviceName)
                    //
                    CheckTapi(&m_pArgs->tlsTapiLink, g_hInst);
                }
            }
            else
            {
                //
                // The selection in the Access Point combo box
                // has changed. Now we have to load the dialing information for
                // the newly selected Access Point
                //
                MYDBGASSERT(IDC_GENERAL_ACCESSPOINT_COMBO == LOWORD(wParam));
                BOOL bRes = AccessPointInfoChanged();
                if (bRes && m_pArgs->pszCurrentAccessPoint)
                {
                    //
                    // If the dialing info. for the previous Access Point has changed, ask the
                    // user if he wants to save the changes
                    //
                    LPTSTR pszMsg = CmFmtMsg(g_hInst, IDMSG_SAVE_ACCESSPOINT, m_pArgs->pszCurrentAccessPoint);
                    if (pszMsg)
                    {
                        if (IDYES == MessageBox(m_hWnd, 
                                                pszMsg, 
                                                m_pArgs->szServiceName, 
                                                MB_YESNO | MB_ICONEXCLAMATION | MB_DEFBUTTON1 | MB_APPLMODAL))
                        {
                            OnApply();
                        }
                    }
                    
                    CmFree(pszMsg);
                }

                //
                // Now call the function to change the Access Point in the combo box
                // and load its parameters into pArgs
                //

                if (ChangedAccessPoint(m_pArgs, m_hWnd, IDC_GENERAL_ACCESSPOINT_COMBO))
                {
                    //
                    // Load new dialing info. into controls on the general page
                    //
                    this->UpdateForNewAccessPoint(TRUE);
                }
            }
                                
            break;

        default:
            break;
    }

   return 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   CheckAccessToCmpAndRasPbk
//
//  Synopsis:   Check to see if the user has the necessary security permissions
//              to make changes to properties. Notifies user if they do not.
//
//  Arguments:  HWND hwndDlg        - The hwnd of the calling app.
//              ArgsStruct *pArgs   - Ptr to our global args struct.
//
//  Returns:    HRESULT - indicating the particular success or failure.
//
//  History:    nickball    03/14/00    Created header 
//
//----------------------------------------------------------------------------
HRESULT CheckAccessToCmpAndRasPbk(HWND hwndDlg, ArgsStruct *pArgs)
{

    MYDBGASSERT(pArgs); // hwndDlg can be NULL

    if (NULL == pArgs)
    {
        return E_INVALIDARG;
    }

    //
    //  Check the cmp, note this could be locked with NTFS perms or just with
    //  attrib.  HasSpecifiedAccessToFileOrDir should catch both as appropriate.
    //
    LPTSTR pszCmp = CmStrCpyAlloc(pArgs->piniProfile->GetFile());
    LPTSTR pszHiddenRasPbk = NULL;
    LPTSTR pszRasPbk = NULL;
    DWORD dwDesiredAccess = FILE_GENERIC_READ | FILE_GENERIC_WRITE;
    BOOL bHasMainRasPbkAccess = FALSE;
    BOOL bHasHiddenRasPbkAccess = FALSE;

    if (pszCmp && pszCmp[0])
    {
        //
        //  Now check the RAS phonebook
        //
        if (OS_W9X)
        {
            //
            //  No phonebook on 9x so skip this check
            //
            bHasMainRasPbkAccess = TRUE;
            bHasHiddenRasPbkAccess = TRUE;
        }
        else
        {
            pszRasPbk = GetPathToPbk((LPCTSTR)pszCmp, pArgs);
            MYDBGASSERT(pszRasPbk);
            CmStrCatAlloc(&pszRasPbk, c_pszRasPhonePbk);
            MYDBGASSERT(pszRasPbk);
        
          
            if (pszRasPbk && pszRasPbk[0])
            {
                bHasMainRasPbkAccess = HasSpecifiedAccessToFileOrDir(pszRasPbk, dwDesiredAccess);

                if ((FALSE == bHasMainRasPbkAccess) && (FALSE == FileExists(pszRasPbk)))
                {
                    //
                    //  if the file doesn't exist, give them the
                    //  benefit of the doubt.  We won't get very far if
                    //  the file doesn't exist and they don't have permissions
                    //  to create it.
                    //
                    bHasMainRasPbkAccess = TRUE;
                }
            }

            //
            //  Now check the hidden RAS phonebook
            //
            if (DOUBLE_DIAL_CONNECTION == pArgs->GetTypeOfConnection())
            {
                pszHiddenRasPbk = CreateRasPrivatePbk(pArgs);

                if (pszHiddenRasPbk && HasSpecifiedAccessToFileOrDir(pszHiddenRasPbk, dwDesiredAccess))
                {
                    bHasHiddenRasPbkAccess = TRUE;
                }
            }
            
            else
            {
                bHasHiddenRasPbkAccess = TRUE;            
            }
        }
    }

    //
    //  Only set hr to success if we have access to both
    //
    HRESULT hr;

    if (bHasMainRasPbkAccess && bHasHiddenRasPbkAccess)
    {
        hr = S_OK;
    }
    else
    {
        hr = E_ACCESSDENIED;
        LPTSTR pszProblemFile = NULL;

        if (!bHasMainRasPbkAccess)
        {
            pszProblemFile = pszRasPbk;        
        }
        else if (!bHasHiddenRasPbkAccess)
        {
            pszProblemFile = pszHiddenRasPbk;
        }

        if (NULL != pszProblemFile)
        {
            LPTSTR pszMsg = CmFmtMsg(g_hInst, IDMSG_NO_CMP_PBK_ACCESS, pszProblemFile);
            if (pszMsg)
            {
                MessageBox(hwndDlg, pszMsg, pArgs->szServiceName, MB_OK | MB_ICONERROR);
                CmFree(pszMsg);
            }        
        }
    }
    //
    //  Cleanup
    //
    CmFree(pszCmp);
    CmFree(pszRasPbk);
    CmFree(pszHiddenRasPbk);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CGeneralPage::OnApply()
//
//  Synopsis:   Save the data associated with the 'Dialing' property sheet.
//              when the user clicks OK.
//
//  Returns:    NONE
//
//  History:    henryt  Created     4/30/97
//              byao    Modified    5/23/97
//                                  Always update modem when user selected OK from
//                                  'Properties' button
//----------------------------------------------------------------------------
void CGeneralPage::OnApply()
{
    BOOL fDirect = IsDlgButtonChecked(m_hWnd, IDC_RADIO_DIRECT);
    LPTSTR pszTmp = NULL;

    //
    // If access points are enabled save the current access point to the registry
    //
    if (m_pArgs->fAccessPointsEnabled)
    {  
        WriteUserInfoToReg(m_pArgs, UD_ID_CURRENTACCESSPOINT, (PVOID)(m_pArgs->pszCurrentAccessPoint));
    }

    if (!fDirect)
    {
        //
        // Before we go anywhere, make sure that the device is acceptable
        // otherwise, we won't be able to munge the phone number
        //
        if (!SetTapiDevice(g_hInst, &m_pArgs->tlsTapiLink, m_szDeviceName)) 
        {
            pszTmp = CmFmtMsg(g_hInst, IDMSG_UNSUPPORTED_DEVICE);
                        
            MessageBoxEx(m_hWnd, pszTmp, m_pArgs->szServiceName, 
                         MB_OK | MB_ICONINFORMATION, LANG_USER_DEFAULT);
            CmFree(pszTmp);
            SetPropSheetResult(PSNRET_INVALID_NOCHANGEPAGE);
            return;
        }

        //
        // Device is ok, see if TAPI is properly intialized. 
        // Don't proceed unless it is.
        //
        
        if (!CheckTapi(&m_pArgs->tlsTapiLink, g_hInst))
        {
            SetPropSheetResult(PSNRET_INVALID_NOCHANGEPAGE);
            return;
        }   
    }

    //
    // Save connection type information
    //
    
    m_pArgs->SetDirectConnect(fDirect);
    m_pArgs->piniProfile->WPPI(c_pszCmSection, c_pszCmEntryConnectionType, fDirect);
    

    //
    // If dial-up data was not initialized, there 
    // is no need to update phone number info.
    //

    if (m_bDialInfoInit)
    {

        //
        //   Store the current TAPI location
        //
        DWORD dwCurrentTapiLoc = GetCurrentTapiLocation(&m_pArgs->tlsTapiLink);
        if (-1 != dwCurrentTapiLoc)
        {
            m_pArgs->tlsTapiLink.dwTapiLocationForAccessPoint = dwCurrentTapiLoc;
            m_pArgs->piniProfile->WPPI(c_pszCmSection, c_pszCmEntryTapiLocation, dwCurrentTapiLoc);
        }

        //
        // Update device name and type
        //

        lstrcpynU(m_pArgs->szDeviceName, m_szDeviceName, CELEMS(m_pArgs->szDeviceName));
        lstrcpynU(m_pArgs->szDeviceType, m_szDeviceType, CELEMS(m_pArgs->szDeviceType));

        //
        // Update the CMP
        //
    
        m_pArgs->piniProfile->WPPS(c_pszCmSection, 
                                 c_pszCmEntryDialDevice, 
                                 m_pArgs->szDeviceName);

        //
        // Check each number to see if we need to update CMP or connectoids
        //
        
        for (UINT i = 0; i < m_NumPhones; i++) 
        {   
            int iEditID = i ? IDC_GENERAL_BACKUP_EDIT : IDC_GENERAL_PRIMARY_EDIT;
        
            //
            // If Dialing Rules aren't used, it is likely that the user has 
            // modified the phone number, get number and munge it. In the 
            // case of fNoDialingRules we skip this test to be certain that 
            // we pick up any user changes.
            //
    
            if (!(m_DialInfo[i].dwPhoneInfoFlags & PIF_USE_DIALING_RULES))           
            {                       
                pszTmp = CmGetWindowTextAlloc(m_hWnd, iEditID);
          
                if (*pszTmp) 
                {                                           
                    //
                    // Ensure that phone number doesn't exceed storage size
                    // Note: On W2K the edit limits prevent pasting an excess 
                    // amount of data, but we truncate to be positive across
                    // all versions of Windows.
                    //
                    
                    if (lstrlenU(pszTmp) > RAS_MaxPhoneNumber)
                    {
                        pszTmp[RAS_MaxPhoneNumber] = TEXT('\0');
                    }

                    //
                    // If we're ignoring dialing rules, just get our data directly
                    //

                    if (m_pArgs->fNoDialingRules)
                    {
                       lstrcpynU(m_DialInfo[i].szPhoneNumber, pszTmp, CELEMS(m_DialInfo[i].szPhoneNumber));
                       lstrcpynU(m_DialInfo[i].szDisplayablePhoneNumber, pszTmp, CELEMS(m_DialInfo[i].szDisplayablePhoneNumber));
                       lstrcpynU(m_DialInfo[i].szDialablePhoneNumber, pszTmp, CELEMS(m_DialInfo[i].szDialablePhoneNumber));
                       m_DialInfo[i].szCanonical[0] = TEXT('\0');
                    }
                    else
                    {
                        LPTSTR pszPhone = CmStrCpyAlloc(pszTmp);
                        LPTSTR pszDialable = NULL;

                        MYDBGASSERT(m_szDeviceName[0]);

                        //
                        // Munge the number to ensure that we have the correct dialable
                        //
                        if (ERROR_SUCCESS != MungePhone(m_szDeviceName, 
                                             &pszPhone, 
                                             &m_pArgs->tlsTapiLink,
                                             g_hInst, 
                                             m_DialInfo[i].dwPhoneInfoFlags & PIF_USE_DIALING_RULES,
                                             &pszDialable,
                                             m_pArgs->fAccessPointsEnabled))
                        {
                            CmFree(pszTmp);

                            //
                            // Can't format the number, notify user of the problem
                            //
                        
                            pszTmp = CmFmtMsg(g_hInst, IDMSG_CANTFORMAT);                                               
                            MessageBoxEx(m_hWnd, pszTmp, m_pArgs->szServiceName, 
                                         MB_OK | MB_ICONINFORMATION, LANG_USER_DEFAULT);
                            CmFree(pszTmp);
                            CmFree(pszPhone);
                            SetPropSheetResult(PSNRET_INVALID_NOCHANGEPAGE);
                            return;                                 
                        }

                        //
                        // Update buffers
                        //
                        if (pszDialable)
                        {
                            lstrcpynU(m_DialInfo[i].szDialablePhoneNumber, pszDialable, CELEMS(m_DialInfo[i].szDialablePhoneNumber));
                        }

                        if (pszPhone)
                        {
                            lstrcpynU(m_DialInfo[i].szDisplayablePhoneNumber, pszPhone, CELEMS(m_DialInfo[i].szDisplayablePhoneNumber));
                        }
                    
                        //
                        // If we find a plus in the first char, assume that the user is
                        // attempting canonical format by hand and treat as a dialing 
                        // rules number. Either way, update the szPhoneNumber buffer.
                        //

                        if (pszTmp == CmStrchr(pszTmp, TEXT('+')))
                        {               
                            //
                            // Its hand-edited canonical. Store the canonical
                            // form in szCanonical, then strip the canonical 
                            // formatting before we store the number normally
                            //              
                        
                            m_DialInfo[i].dwPhoneInfoFlags |= PIF_USE_DIALING_RULES;
                    
                            lstrcpynU(m_DialInfo[i].szCanonical, pszTmp, CELEMS(m_DialInfo[i].szCanonical));
                            StripCanonical(pszTmp);
                        }
                        else
                        {
                            //
                            // If UDR check is disabled, then its a hand edited number,
                            // so remove canonical form of the number - as an indicator.
                            // 
   
                            if (!IsWindowEnabled(GetDlgItem(m_hWnd, i ? 
                                                           IDC_GENERAL_UDR2_CHECKBOX : 
                                                           IDC_GENERAL_UDR1_CHECKBOX)))
                            {
                                m_DialInfo[i].szCanonical[0] = TEXT('\0');
                            }
                        }
                
                        lstrcpynU(m_DialInfo[i].szPhoneNumber, pszTmp, CELEMS(m_DialInfo[i].szPhoneNumber));          
                        CmFree(pszDialable);
                        CmFree(pszPhone);
                    }
                }
                else
                {
                    //
                    // No number, clear everything
                    //

                    ZeroMemory(&m_DialInfo[i], sizeof(PHONEINFO));              
                }

                CmFree(pszTmp);
            }   
        
            //
            // Copy the new phone #'s back to our global struct
            //

            lstrcpynU(m_pArgs->aDialInfo[i].szPhoneBookFile, 
                     m_DialInfo[i].szPhoneBookFile, CELEMS(m_pArgs->aDialInfo[i].szPhoneBookFile));
            
            lstrcpynU(m_pArgs->aDialInfo[i].szDUN, 
                     m_DialInfo[i].szDUN, CELEMS(m_pArgs->aDialInfo[i].szDUN));
        
            lstrcpynU(m_pArgs->aDialInfo[i].szPhoneNumber, 
                     m_DialInfo[i].szPhoneNumber, CELEMS(m_pArgs->aDialInfo[i].szPhoneNumber));
            
            //
            // Always store canonical as canonical
            //

            lstrcpynU(m_pArgs->aDialInfo[i].szCanonical, 
                     m_DialInfo[i].szCanonical, CELEMS(m_pArgs->aDialInfo[i].szCanonical));

            lstrcpynU(m_pArgs->aDialInfo[i].szDialablePhoneNumber, 
                     m_DialInfo[i].szDialablePhoneNumber, CELEMS(m_pArgs->aDialInfo[i].szDialablePhoneNumber));
            
            lstrcpynU(m_pArgs->aDialInfo[i].szDisplayablePhoneNumber, 
                     m_DialInfo[i].szDisplayablePhoneNumber, CELEMS(m_pArgs->aDialInfo[i].szDisplayablePhoneNumber));

            lstrcpynU(m_pArgs->aDialInfo[i].szDesc, m_DialInfo[i].szDesc, CELEMS(m_pArgs->aDialInfo[i].szDesc));
            
            m_pArgs->aDialInfo[i].dwCountryID = m_DialInfo[i].dwCountryID;
            
            lstrcpynU(m_pArgs->aDialInfo[i].szServiceType,
                     m_DialInfo[i].szServiceType, CELEMS(m_pArgs->aDialInfo[i].szServiceType));
            
            lstrcpynU(m_pArgs->aDialInfo[i].szRegionName,
                     m_DialInfo[i].szRegionName, CELEMS(m_pArgs->aDialInfo[i].szRegionName));
        
            m_pArgs->aDialInfo[i].dwPhoneInfoFlags = m_DialInfo[i].dwPhoneInfoFlags;

            //
            // Write them out to cmp
            //
        
            PutPhoneByIdx(m_pArgs,
                          i, 
                          m_pArgs->aDialInfo[i].szPhoneNumber, 
                          m_pArgs->aDialInfo[i].szDesc,
                          m_pArgs->aDialInfo[i].szDUN,
                          m_pArgs->aDialInfo[i].dwCountryID, 
                          m_pArgs->aDialInfo[i].szRegionName,
                          m_pArgs->aDialInfo[i].szServiceType,
                          m_pArgs->aDialInfo[i].szPhoneBookFile,
                          m_pArgs->aDialInfo[i].szCanonical,
                          m_pArgs->aDialInfo[i].dwPhoneInfoFlags);

        } // for {}
    }

    //
    // Update fUseTunneling by examining first phonenumber.
    //
    
    if (fDirect)
    {
        m_pArgs->fUseTunneling = TRUE;
    }
    else
    {
        m_pArgs->fUseTunneling = UseTunneling(m_pArgs, 0);
    }

    if (FAILED(CheckAccessToCmpAndRasPbk(m_hWnd, m_pArgs)))
    {
        SetPropSheetResult(PSNRET_INVALID_NOCHANGEPAGE);
        return;
    }
    else
    {
        SetPropSheetResult(PSNRET_NOERROR);
    }    

    return;
}

//+----------------------------------------------------------------------------
//
// Function:  CGeneralPage::OnKillActive
//
// Synopsis:  Virtual function. Called upon WM_NOTIFY with PSN_KILLACTIVE
//            Notifies a page that it is about to lose activation either because 
//            another page is being activated or the user has clicked the OK button.
// Arguments: None
//
// Returns:   BOOL - return value of the message
//
// History:   fengsun Created Header    2/26/98
//
//+----------------------------------------------------------------------------
BOOL CGeneralPage::OnKillActive()
{
    //
    // Notify the event listener for the current connection type selection
    //
    if (m_pEventListener)
    {
        m_pEventListener->OnGeneralPageKillActive(
            IsDlgButtonChecked(m_hWnd, IDC_RADIO_DIRECT));
    }

    //
    //  Hide any open balloon tips
    //
    if (m_pArgs->pBalloonTip)
    {
        m_pArgs->pBalloonTip->HideBalloonTip();
    }

    return 0;
}

//
// Help id pairs for the page
//
const DWORD CInetPage::m_dwHelp[] = {
        IDC_INET_USERNAME_STATIC,   IDH_INTERNET_USER_NAME,
        IDC_INET_USERNAME,          IDH_INTERNET_USER_NAME,
        IDC_INET_PASSWORD_STATIC,   IDH_INTERNET_PASSWORD,
        IDC_INET_PASSWORD,          IDH_INTERNET_PASSWORD,
        IDC_INET_REMEMBER,          IDH_INTERNET_SAVEPASS,
        0,0};

//+----------------------------------------------------------------------------
//
// Function:  CInetPage::CInetPage
//
// Synopsis:  Constructor
//
// Arguments: ArgsStruct* pArgs - Information needed for the page
//            UINT nIDTemplate - Resource ID
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/26/98
//
//+----------------------------------------------------------------------------
CInetPage::CInetPage(ArgsStruct* pArgs, UINT nIDTemplate) 
    : CPropertiesPage(nIDTemplate, m_dwHelp, pArgs->pszHelpFile)
{
    MYDBGASSERT(pArgs);
    m_pArgs = pArgs;
    m_fDirect = pArgs->IsDirectConnect();
}

//+---------------------------------------------------------------------------
//
//  Function:   OnInetInit
//
//  Synopsis:   Init the 'Internet Sign-In' properties property sheet.
//
//  Arguments:  hwndDlg [dlg window handle]
//              pArgs [the ptr to ArgsStruct]
//
//  Returns:    NONE
//
//  History:    henryt  Created     4/30/97
//
//----------------------------------------------------------------------------
void CInetPage::OnInetInit(
    HWND        hwndDlg,
    ArgsStruct  *pArgs
)
{
    //
    // The inet dialog/page is displayed only if fUseSameUserName is FALSE
    //
    MYDBGASSERT( pArgs->fUseSameUserName == FALSE);

    //
    // set the length limit for the edit controls
    //
    UINT i;
    
    HWND hwndUserName = GetDlgItem(hwndDlg, IDC_INET_USERNAME);
    if (hwndUserName)
    {
        i = (UINT)pArgs->piniService->GPPI(c_pszCmSection, c_pszCmEntryMaxUserName, UNLEN);
        SendDlgItemMessageU(hwndDlg, IDC_INET_USERNAME, EM_SETLIMITTEXT, __min(UNLEN, i), 0);
        SetDlgItemTextU(hwndDlg, IDC_INET_USERNAME, pArgs->szInetUserName);
        SendMessageU(hwndUserName, EM_SETMODIFY, (WPARAM)FALSE, 0L);
    }

    HWND hwndInetPassword = GetDlgItem(hwndDlg, IDC_INET_PASSWORD);
    if (hwndInetPassword)
    {
        i = (UINT)pArgs->piniService->GPPI(c_pszCmSection, c_pszCmEntryMaxPassword, PWLEN);
        SendDlgItemMessageU(hwndDlg, IDC_INET_PASSWORD, EM_SETLIMITTEXT, __min(PWLEN, i), 0);

        CmDecodePassword(pArgs->szInetPassword);       
        SetDlgItemTextU(hwndDlg, IDC_INET_PASSWORD, pArgs->szInetPassword);
        CmEncodePassword(pArgs->szInetPassword);
        SendMessageU(hwndInetPassword, EM_SETMODIFY, (WPARAM)FALSE, 0L);

        //
        // hide and the "remember password checkbox if needed
        //
        if (pArgs->fHideRememberInetPassword)
        {
            ShowWindow(GetDlgItem(hwndDlg, IDC_INET_REMEMBER), SW_HIDE);
        }
        else
        {
            //
            // Check the button first, then adjust it.
            //
            CheckDlgButton(hwndDlg, IDC_INET_REMEMBER, pArgs->fRememberInetPassword);

            BOOL fPasswordOptional = pArgs->piniService->GPPB(c_pszCmSection,c_pszCmEntryPwdOptional);
            BOOL fEmptyPassword = (pArgs->szInetPassword[0] == TEXT('\0') );

            //
            // Enable/Disable check/uncheck the "Save Password" accordingly
            // fPasswordOptional is always FALSE for the dialog
            //
            AdjustSavePasswordCheckBox(GetDlgItem(hwndDlg, IDC_INET_REMEMBER), 
                    fEmptyPassword, pArgs->fDialAutomatically, fPasswordOptional);
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   OnInetOk
//
//  Synopsis:   Save the data associated with the 'Internet Sign-In' property sheet.
//              when the user clicks OK.
//
//  Arguments:  hwndDlg [dlg window handle]
//              pArgs [the ptr to ArgsStruct]
//
//  Returns:    NONE
//
//  History:    henryt  Created     4/30/97
//
//----------------------------------------------------------------------------
void CInetPage::OnInetOk(
    HWND        hwndDlg,
    ArgsStruct  *pArgs
) 
{
    LPTSTR pszTmp = NULL;
 

    //
    // update password
    //
    
    if (GetDlgItem(hwndDlg, IDC_INET_PASSWORD))
    {       
        pszTmp = CmGetWindowTextAlloc(hwndDlg, IDC_INET_PASSWORD);

        if (!pArgs->fHideRememberInetPassword)
        {
            pArgs->fRememberInetPassword = IsDlgButtonChecked(hwndDlg, IDC_INET_REMEMBER);
            SaveUserInfo(pArgs,                      
                         UD_ID_REMEMBER_INET_PASSWORD, 
                         (PVOID)&pArgs->fRememberInetPassword); 
        }

        //
        // If don't remember password, then store an empty string, but keep
        // the existing one in memory. Otherwise, save the user's password.
        //

        if (pArgs->fRememberInetPassword)
        {
            if (OS_NT5)
            {
                //
                // If we are saving user creds, we can leave globals
                //
                if (CM_CREDS_GLOBAL == pArgs->dwCurrentCredentialType)
                {
                    //
                    // Delete local/user since we are saving global credentials
                    //
                    DeleteSavedCredentials(pArgs, CM_CREDS_TYPE_INET, CM_DELETE_SAVED_CREDS_KEEP_GLOBALS, CM_DELETE_SAVED_CREDS_DELETE_IDENTITY);
                    pArgs->dwExistingCredentials &= ~CM_EXIST_CREDS_INET_USER;
                }
            }

            SaveUserInfo(pArgs, UD_ID_INET_PASSWORD, (PVOID)pszTmp);
        }
        else
        {
            if (OS_NT5)
            {
                if (CM_CREDS_GLOBAL == pArgs->dwCurrentCredentialType)
                {
                    //
                    // Deleting Internet Globals
                    //
                    if (CM_EXIST_CREDS_INET_GLOBAL & pArgs->dwExistingCredentials)
                    {
                        DeleteSavedCredentials(pArgs, CM_CREDS_TYPE_INET, CM_DELETE_SAVED_CREDS_DELETE_GLOBALS, CM_DELETE_SAVED_CREDS_DELETE_IDENTITY);
                        pArgs->dwExistingCredentials &= ~CM_EXIST_CREDS_INET_GLOBAL;
                    }
                }
                else
                {
                    //
                    // Deleting Internet User
                    //
                    if (CM_EXIST_CREDS_INET_USER & pArgs->dwExistingCredentials)
                    {
                        DeleteSavedCredentials(pArgs, CM_CREDS_TYPE_INET, CM_DELETE_SAVED_CREDS_KEEP_GLOBALS, CM_DELETE_SAVED_CREDS_KEEP_IDENTITY);
                        pArgs->dwExistingCredentials &= ~CM_EXIST_CREDS_INET_USER;
                    }
                }
            }
            else
            {
                DeleteUserInfo(pArgs, UD_ID_INET_PASSWORD);
            }
        }
    
        //
        // Update pArgs
        //

        lstrcpyU(pArgs->szInetPassword, pszTmp);
        CmEncodePassword(pArgs->szInetPassword);
        CmWipePassword(pszTmp);
        CmFree(pszTmp);
        pszTmp = NULL;
    }


    DWORD dwCurrentCreds = pArgs->dwCurrentCredentialType;

    //
    // If the user isn't saving his password and the credential
    // store is global, then we need to switch to the user
    // credential store in order to cache the user name for next use
    //
    if ((FALSE == pArgs->fRememberInetPassword) && 
        (CM_CREDS_GLOBAL == pArgs->dwCurrentCredentialType))
    {
            pArgs->dwCurrentCredentialType = CM_CREDS_USER;
    }

    //
    // Get User name
    //
    if (GetDlgItem(hwndDlg, IDC_INET_USERNAME))
    {
        pszTmp = CmGetWindowTextAlloc(hwndDlg, IDC_INET_USERNAME);
        lstrcpyU(pArgs->szInetUserName, pszTmp);

        //
        // update username if we are saving credentials or
        // we are saving to the user/local credential store.
        //
        if ((pArgs->fRememberInetPassword) || (CM_CREDS_USER == pArgs->dwCurrentCredentialType))
        {
            SaveUserInfo(pArgs, UD_ID_INET_USERNAME, (PVOID)pszTmp);
        }
        CmFree(pszTmp);
        pszTmp = NULL;
    }

    //
    // In case the current credential store was changed to user, we now
    // need to switch it back to global.
    //
    pArgs->dwCurrentCredentialType = dwCurrentCreds;

    //
    // Need to refresh to see which creds now exist since we could have saved or deleted some
    //
    BOOL fReturn = RefreshCredentialTypes(pArgs, FALSE);

    CmWipePassword(pszTmp);
    CmFree(pszTmp);
}

//+----------------------------------------------------------------------------
//
// Function:  CInetPage::AdjustSavePasswordCheckBox
//
// Synopsis:  Enable/Disable, Check/Uncheck the "save Password" check box
//            according to other information
//
// Arguments: HWND hwndCheckBox - The window handle of "Save Password" check box
//            BOOL fEmptyPassword - Whether the password edit box is empty
//            BOOL fDialAutomatically - Whether dial automatically is checked
//            BOOL fPasswordOptional - Whether the password is optional
//
// Returns:   Nothing
//
// History:   fengsun Created Header    4/24/98
//
//+----------------------------------------------------------------------------
void CInetPage::AdjustSavePasswordCheckBox(HWND hwndCheckBox, BOOL fEmptyPassword, 
                           BOOL fDialAutomatically, BOOL fPasswordOptional)
{
    MYDBGASSERT(IsWindow(hwndCheckBox)); // if password hidden, no need to adjust

    //
    // Enable/Disable the check box
    //
    if (fDialAutomatically)
    {
        EnableWindow(hwndCheckBox, FALSE);
    }
    else if (fEmptyPassword && !fPasswordOptional)
    {
        EnableWindow(hwndCheckBox, FALSE);
    }
    else
    {
        EnableWindow(hwndCheckBox, TRUE);
    }

    //
    // Check/Uncheck the check box
    //
    if (fEmptyPassword && !fPasswordOptional)
    {
        //
        // If there is no password and password is not optional,
        // uncheck the checkbox
        //
        SendMessageU(hwndCheckBox, BM_SETCHECK, BST_UNCHECKED, 0);
    }
    else if (fDialAutomatically)
    {
        //
        // If dial automaticly, which means the checkbox is disabled,
        // check the box if has password or password is optional
        //
        SendMessageU(hwndCheckBox, BM_SETCHECK, BST_CHECKED, 0);
    }
}


//+----------------------------------------------------------------------------
//
// Function:  CInetPage::OnInitDialog
//
// Synopsis:  Virtual function. Called upon WM_INITDIALOG message
//
// Arguments: None
//
// Returns:   BOOL - return value of the message
//
// History:   fengsun Created Header    2/26/98
//
//+----------------------------------------------------------------------------
BOOL CInetPage::OnInitDialog()
{
    UpdateFont(m_hWnd);

    m_fPasswordOptional = m_pArgs->piniService->GPPB(c_pszCmSection, c_pszCmEntryPwdOptional);

    //
    // Initialize all the controls
    //
    OnInetInit(m_hWnd, m_pArgs);

    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:  CInetPage::OnCommand
//
// Synopsis:  Virtual function. Called upon WM_COMMAND
//
// Arguments: WPARAM - wParam of the message
//            LPARAM - lParam of the message
//
// Returns:   DWORD - return value of the message
//
// History:   fengsun Created Header    2/26/98
//
//+----------------------------------------------------------------------------
DWORD CInetPage::OnCommand(WPARAM wParam, LPARAM)
{
    switch (LOWORD(wParam)) 
    {
        case IDC_INET_PASSWORD:
            if ((HIWORD(wParam) == EN_CHANGE)) 
            {
                if (!m_pArgs->fHideRememberInetPassword && !m_pArgs->fHideInetPassword)
                {
                    //
                    // if there's no password, disable and uncheck "remember password"
                    //
                    BOOL fEmptyPassword = !SendDlgItemMessageU(m_hWnd, IDC_INET_PASSWORD, 
                        WM_GETTEXTLENGTH, 0, (LPARAM)0);

                    //
                    // Enable/Disable check/uncheck the "Save Password" accordingly
                    // fPasswordOptional is always FALSE for the dialog
                    //
                    AdjustSavePasswordCheckBox(GetDlgItem(m_hWnd, IDC_INET_REMEMBER), 
                            fEmptyPassword, m_pArgs->fDialAutomatically, m_fPasswordOptional);

                    return TRUE;
                }
            }
            break;

        case IDC_INET_REMEMBER:
            {
                // 
                // If the password wasn't modified by the user we want to clear
                // the edit box. Once the password edit box is empty the 
                // Save Password option is disabled, thus we don't ever need to 
                // reload the password from memory like on the main dialog.
                //
                BOOL fSavePW = IsDlgButtonChecked(m_hWnd, IDC_INET_REMEMBER);

                HWND hwndInetPW = GetDlgItem(m_hWnd, IDC_INET_PASSWORD);
                if (hwndInetPW)
                {
                    BOOL fInetPWChanged = (BOOL)SendMessageU(hwndInetPW, EM_GETMODIFY, 0L, 0L); 

                    if (FALSE == fSavePW && FALSE == fInetPWChanged)
                    {
                        //
                        // Didn't change thus clear the edit box
                        // 
                        SetDlgItemTextU(m_hWnd, IDC_INET_PASSWORD, TEXT(""));
                    }
                }
            }
            break;
        default:
            break;
    }
    return 0;
}

//+----------------------------------------------------------------------------
//
// Function:  CInetPage::OnApply
//
// Synopsis:  Virtual function. Called upon WM_NOTIFY with PSN_APPLY
//            Indicates that the user clicked the OK or Apply Now button 
//            and wants all changes to take effect. 
//
// Arguments: None
//
// Returns:   NONE
//
// History:   fengsun Created Header    2/26/98
//
//+----------------------------------------------------------------------------
void CInetPage::OnApply()
{
    //
    // Save information only if user chose dial-up
    //
    OnInetOk(m_hWnd, m_pArgs);

    SetPropSheetResult(PSNRET_NOERROR);
}

//+----------------------------------------------------------------------------
//
// Function:  CInetPage::OnGeneralPageKillActive
//
// Synopsis:  Receive the KillActive event from General page
//
// Arguments: BOOL fDirect - Whehter the current connection type selection in
//                  General page is Direct
//
// Returns:   Nothing
//
// History:   Created Header    4/24/98
//
//+----------------------------------------------------------------------------
void CInetPage::OnGeneralPageKillActive(BOOL fDirect)
{
    m_fDirect = fDirect;
}


//+----------------------------------------------------------------------------
//
// Function:  CInetPage::OnSetActive
//
// Synopsis:  Virtual function. Called upon WM_NOTIFY with PSN_SETACTIVE
//
// Arguments: None
//
// Returns:   BOOL - return value of the message
//
// History:   fengsun Created Header    2/26/98
//
//+----------------------------------------------------------------------------
BOOL CInetPage::OnSetActive()
{
    //
    // Enable/Disable the control according to the current connection type
    //
    EnableWindow(GetDlgItem(m_hWnd,IDC_INET_USERNAME_STATIC), !m_fDirect);
    EnableWindow(GetDlgItem(m_hWnd,IDC_INET_USERNAME), !m_fDirect);
    EnableWindow(GetDlgItem(m_hWnd,IDC_INET_PASSWORD_STATIC), !m_fDirect);
    EnableWindow(GetDlgItem(m_hWnd,IDC_INET_PASSWORD), !m_fDirect);

    if (m_fDirect)
    {
        EnableWindow(GetDlgItem(m_hWnd,IDC_INET_REMEMBER), FALSE);
    }
    else if (!m_pArgs->fHideRememberInetPassword && !m_pArgs->fHideInetPassword)
    {
        BOOL fEmptyPassword = !SendDlgItemMessageU(m_hWnd, 
                                                   IDC_INET_PASSWORD, 
                                                   WM_GETTEXTLENGTH, 
                                                   0, 
                                                   (LPARAM)0);
        //
        // Enable/Disable check/uncheck the "Save Password" accordingly
        // fPasswordOptional is always FALSE for the dialog
        //

        AdjustSavePasswordCheckBox(GetDlgItem(m_hWnd, IDC_INET_REMEMBER), 
                fEmptyPassword, m_pArgs->fDialAutomatically, m_fPasswordOptional);
    }

    return 0;
}


//
// Help id pairs
//
const DWORD COptionPage::m_dwHelp[] = {
        IDC_OPTIONS_IDLETIME_LIST,    IDH_OPTIONS_IDLEDIS,
        IDC_STATIC_MINUTES,           IDH_OPTIONS_IDLEDIS,
        IDC_OPTIONS_REDIALCOUNT_SPIN, IDH_OPTIONS_REDIAL,
        IDC_OPTIONS_REDIALCOUNT_EDIT, IDH_OPTIONS_REDIAL,
        IDC_STATIC_TIMES,             IDH_OPTIONS_REDIAL,
        IDC_OPTIONS_LOGGING,          IDH_OPTIONS_LOGGING,
        IDC_OPTIONS_CLEAR_LOG,        IDH_OPTIONS_CLEAR_LOG,
        IDC_OPTIONS_VIEW_LOG,        IDH_OPTIONS_VIEW_LOG,
        0,0};

const DWORD COptionPage::m_adwTimeConst[] = {0,1, 5, 10, 30, 1*60, 2*60, 4*60, 8*60, 24*60};
const int COptionPage::m_nTimeConstElements = sizeof(m_adwTimeConst)/sizeof(m_adwTimeConst[0]);

//+----------------------------------------------------------------------------
//
// Function:  COptionPage::COptionPage
//
// Synopsis:  Constructor
//
// Arguments: ArgsStruct* pArgs - Information needed for the page
//            UINT nIDTemplate - Resource ID
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/26/98
//
//+----------------------------------------------------------------------------
COptionPage::COptionPage(ArgsStruct* pArgs, UINT nIDTemplate) 
    : CPropertiesPage(nIDTemplate, m_dwHelp, pArgs->pszHelpFile)
{
    MYDBGASSERT(pArgs);
    m_pArgs = pArgs;
    m_fEnableLog = FALSE;
}



//+----------------------------------------------------------------------------
//
// Function:  COptionPage::InitIdleTimeList
//
// Synopsis:  Populate the IdleTime combo box and set the initial selection
//
// Arguments: HWND hwndList - Combo box window handle
//            DWORD dwMinutes - Time in minutes
//
// Returns:   Nothing
//
// History:   fengsun Created Header    4/22/98
//
//+----------------------------------------------------------------------------
void COptionPage::InitIdleTimeList(HWND hwndList, DWORD dwMinutes)
{
    MYDBGASSERT(hwndList);
    MYDBGASSERT(IsWindow(hwndList));

    //
    // Load the string from resource and populate the idle timeout list
    //
    MYDBGASSERT(IDS_IDLETIME_24HOURS - IDS_IDLETIME_NEVER == m_nTimeConstElements-1);
    for (int i= IDS_IDLETIME_NEVER; i<= IDS_IDLETIME_24HOURS; i++)
    {
        LPTSTR pszText = CmLoadString(g_hInst, i);
        MYDBGASSERT(pszText);
        SendMessageU(hwndList, CB_ADDSTRING, 0, (LPARAM)pszText);
        CmFree(pszText);
    }

    //
    // Value are round down for 1.0 profile
    // Note 0 means never.  We are safe, since there is no gap between 0 and 1 minute.
    //

    int nSel;   // the initial selection

    for (nSel=m_nTimeConstElements-1; nSel>=0;nSel--)
    {
        if (dwMinutes >= m_adwTimeConst[nSel])
        {
            break;
        }
    }

    SendMessageU(hwndList, CB_SETCURSEL, nSel, 0);
}



//+----------------------------------------------------------------------------
//
// Function:  COptionPage::GetIdleTimeList
//
// Synopsis:  Retrieve the IdleTime value selected
//
// Arguments: HWND hwndList - Combo box window handle
//
// Returns:   DWORD - User selected timeout value in minutes
//
// History:   fengsun Created Header    4/22/98
//
//+----------------------------------------------------------------------------
DWORD COptionPage::GetIdleTimeList(HWND hwndList)
{
    //
    // Get the current selection and convert it into minutes
    //

    DWORD dwSel = (DWORD)SendMessageU(hwndList, CB_GETCURSEL, 0, 0);

    MYDBGASSERT(dwSel < m_nTimeConstElements);
    if (dwSel >= m_nTimeConstElements)  // in case of CB_ERR
    {
        dwSel = 0;
    }

    return m_adwTimeConst[dwSel];
}



//+---------------------------------------------------------------------------
//
//  Function:   COptionPage::OnInitDialog()
//
//  Synopsis:   Init the Options property sheet.
//
//  Returns:    NONE
//
//  History:    henryt  Created     4/30/97
//              byao    Modified    5/12/97   - disable all controls in 
//                                              'Dialing with connectoid' mode
//----------------------------------------------------------------------------
BOOL COptionPage::OnInitDialog()
{
    UpdateFont(m_hWnd);

    //
    // init the "Idle timeout before hangup" 
    //
    InitIdleTimeList(GetDlgItem(m_hWnd, IDC_OPTIONS_IDLETIME_LIST), m_pArgs->dwIdleTimeout);

    //
    // init the "Number of redial attempt" 
    // Limit Redial edit field to 3 characters, redial spin 0-999
    //
    const int MAX_REDIAL_CHARS = 3;

    SendDlgItemMessageU(m_hWnd, IDC_OPTIONS_REDIALCOUNT_EDIT, EM_SETLIMITTEXT, MAX_REDIAL_CHARS, 0);
    SendDlgItemMessageU(m_hWnd, IDC_OPTIONS_REDIALCOUNT_SPIN, UDM_SETRANGE ,  0, MAKELONG(999,0));
    SetDlgItemInt(m_hWnd, IDC_OPTIONS_REDIALCOUNT_EDIT, m_pArgs->nMaxRedials,  FALSE);
    
    //
    // set logging state
    //
    m_fEnableLog = m_pArgs->Log.IsEnabled();
    CheckDlgButton(m_hWnd, IDC_OPTIONS_LOGGING, m_fEnableLog);

    if (IsLogonAsSystem() || (FALSE == m_fEnableLog))
    {
        EnableWindow(GetDlgItem(m_hWnd, IDC_OPTIONS_VIEW_LOG), FALSE);
        EnableWindow(GetDlgItem(m_hWnd, IDC_OPTIONS_CLEAR_LOG), FALSE);
    }

    return TRUE;
}


//+----------------------------------------------------------------------------
//
// Function:  COptionPage::OnCommand
//
// Synopsis:  Virtual function. Called upon WM_COMMAND
//
// Arguments: WPARAM - wParam of the message
//            LPARAM - lParam of the message
//
// Returns:   DWORD - return value of the message
//
// History:   SumitC  Created  7/18/00
//
//+----------------------------------------------------------------------------
DWORD COptionPage::OnCommand(WPARAM wParam, LPARAM)
{
    switch (LOWORD(wParam)) 
    {
    case IDC_OPTIONS_LOGGING:
        {
            BOOL fEnabled = ToggleLogging();

            if (FALSE == IsLogonAsSystem())
            {
                EnableWindow(GetDlgItem(m_hWnd, IDC_OPTIONS_VIEW_LOG), fEnabled);
                EnableWindow(GetDlgItem(m_hWnd, IDC_OPTIONS_CLEAR_LOG), fEnabled);
            }
        }
        break;

    case IDC_OPTIONS_CLEAR_LOG:
        MYDBGASSERT(FALSE == IsLogonAsSystem());
        if (FALSE == IsLogonAsSystem())
        {
            m_pArgs->Log.Clear();
            m_pArgs->Log.Log(CLEAR_LOG_EVENT);
        }
        break;

    case IDC_OPTIONS_VIEW_LOG:
        MYDBGASSERT(FALSE == IsLogonAsSystem());
        if (FALSE == IsLogonAsSystem())
        {
            LPCTSTR pszLogFile = m_pArgs->Log.GetLogFilePath();

            HANDLE hFile = CreateFile(pszLogFile, 0,  
                                      FILE_SHARE_READ,
                                      NULL, OPEN_EXISTING, 
                                      FILE_ATTRIBUTE_NORMAL, NULL);

            if (INVALID_HANDLE_VALUE != hFile)
            {
                BOOL                bReturn;
                SHELLEXECUTEINFO    sei;

                ZeroMemory(&sei, sizeof(SHELLEXECUTEINFO));

                //
                //  Fill in the Execute Struct
                //
                sei.cbSize = sizeof(SHELLEXECUTEINFO);
                sei.hwnd            = NULL;
                sei.lpVerb          = TEXT("open");
                sei.lpFile          = TEXT("notepad.exe");
                sei.lpParameters    = pszLogFile;
                sei.nShow           = SW_SHOWNORMAL;

                bReturn = m_pArgs->m_ShellDll.ExecuteEx(&sei);

                if (FALSE == bReturn)
                {
                    CMTRACE1(TEXT("COptionPage::OnCommand, failed to View Log, GLE=%d"), GetLastError());
                    
                    LPTSTR pszMsg = CmFmtMsg(g_hInst, IDMSG_CANT_VIEW_LOG, pszLogFile);
                    if (pszMsg)
                    {
                        MessageBox(m_hWnd, pszMsg, m_pArgs->szServiceName, MB_OK | MB_ICONERROR);
                        CmFree(pszMsg);
                    }        
                }

                CloseHandle(hFile);
            }
            else
            {
                CMTRACE(TEXT("COptionPage::OnCommand, no log file, nothing to view"));
                LPTSTR pszMsg = CmFmtMsg(g_hInst, IDMSG_NO_LOG_FILE);
                if (pszMsg)
                {
                    MessageBox(m_hWnd, pszMsg, m_pArgs->szServiceName, MB_OK | MB_ICONERROR);
                    CmFree(pszMsg);
                }        
            }
        }

        break;
    }
    
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   COptionPage::OnApply()
//
//  Synopsis:   Save the data associated with the 'Options' property sheet.
//              when the user clicks OK.
//
//  Returns:    NONE
//
//  History:    henryt  Created     4/30/97
//
//----------------------------------------------------------------------------
void COptionPage::OnApply()
{   
    //
    // Accessing RedialCount and IdleTimeout.  Make sure to use piniBothNonFav 
    // because these settings are per user, per profile.
    //

    //
    // save the "Idle timeout before hangup"
    //
    m_pArgs->dwIdleTimeout = GetIdleTimeList(GetDlgItem(m_hWnd, IDC_OPTIONS_IDLETIME_LIST));
    m_pArgs->piniBothNonFav->WPPI(c_pszCmSection, c_pszCmEntryIdleTimeout, m_pArgs->dwIdleTimeout);

    //
    // save the redial settings
    //

    m_pArgs->nMaxRedials = GetDlgItemInt(m_hWnd, IDC_OPTIONS_REDIALCOUNT_EDIT, NULL, FALSE);
    m_pArgs->piniBothNonFav->WPPI(c_pszCmSection, c_pszCmEntryRedialCount, m_pArgs->nMaxRedials);

    //
    //  NOTE: Logging is enabled/disabled immediately when the logging checkbox
    //        is clicked.  Thus there is no code here to handle the Apply.
    //

    SetPropSheetResult(PSNRET_NOERROR);
}


//+----------------------------------------------------------------------------
//
// Function:  COptionPage::ToggleLogging
//
// Synopsis:  Helper function, responds to logging being enabled/disabled.
//
// Arguments: none
//
// Returns:   BOOL - Is logging now enabled or disabled?
//
// History:   SumitC  Created  11/07/00
//
//+----------------------------------------------------------------------------
BOOL COptionPage::ToggleLogging()
{
    //
    // save the Logging settings
    //

    BOOL fEnableLog = IsDlgButtonChecked(m_hWnd, IDC_OPTIONS_LOGGING);

    m_pArgs->piniBothNonFav->WPPB(c_pszCmSection, c_pszCmEntryEnableLogging, fEnableLog);
    
    if ((!!fEnableLog != !!m_fEnableLog))
    {
        // if the value has changed
        if (fEnableLog)
        {
            DWORD dwMaxSize  = m_pArgs->piniService->GPPI(c_pszCmSectionLogging, c_pszCmEntryMaxLogFileSize, c_dwMaxFileSize);
            LPTSTR pszFileDir = m_pArgs->piniService->GPPS(c_pszCmSectionLogging, c_pszCmEntryLogFileDirectory, c_szLogFileDirectory);

            m_pArgs->Log.SetParams(TRUE, dwMaxSize, pszFileDir); // TRUE == fEnabled

            CmFree(pszFileDir);

            m_pArgs->Log.Start(TRUE);   // TRUE => write a banner as well
            m_pArgs->Log.Log(LOGGING_ENABLED_EVENT);
        }
        else
        {
            m_pArgs->Log.Log(LOGGING_DISABLED_EVENT);
            m_pArgs->Log.Stop();
        }

        m_fEnableLog = fEnableLog;
    }

    return m_fEnableLog;
}


//+----------------------------------------------------------------------------
//
// Function:  CAboutPage::CAboutPage
//
// Synopsis:  Constructor
//
// Arguments: UINT nIDTemplate - Dialog resource ID
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/26/98
//
//+----------------------------------------------------------------------------
CAboutPage::CAboutPage(ArgsStruct* pArgs, UINT nIDTemplate)
    : CPropertiesPage(nIDTemplate)
{
    MYDBGASSERT(pArgs);
    m_pArgs = pArgs;    
}

//+---------------------------------------------------------------------------
//
//  Function:   CAboutPage::OnInitDialog()
//
//  Synopsis:   Init the About property sheet.
//
//  Arguments:  m_hWnd [dlg window handle]
//
//  Returns:    NONE
//
//  History:    henryt  Created     4/30/97
//              byao    Modified    5/12/97   - disable all controls in 
//                                              'Dialing with connectoid' mode
//----------------------------------------------------------------------------
BOOL CAboutPage::OnInitDialog()
{
    UpdateFont(m_hWnd);
                
    LPTSTR  pszTmp;
    LPTSTR  pszExt;
  
    //
    // Set the warning text.  We can't put it the dialog template because it's 
    // longer than 256 chars.
    //

    if (!(pszTmp = CmLoadString(g_hInst, IDMSG_ABOUT_WARNING_PART1)))
    {
        pszTmp = CmStrCpyAlloc(NULL);
    }

    if (!(pszExt = CmLoadString(g_hInst, IDMSG_ABOUT_WARNING_PART2)))
    {
        pszExt = CmStrCpyAlloc(NULL);
    }

    pszTmp = CmStrCatAlloc(&pszTmp, pszExt);

    SetDlgItemTextU(m_hWnd, IDC_ABOUT_WARNING, pszTmp);
    CmFree(pszTmp);
    CmFree(pszExt);

    //#150147
    
    LPTSTR pszVersion = (LPTSTR)CmMalloc(sizeof(TCHAR)*(lstrlenA(VER_PRODUCTVERSION_STR) + 1));

    if (pszVersion)
    {
        wsprintfU(pszVersion, TEXT("%S"), VER_PRODUCTVERSION_STR);

        if (!(pszTmp = CmFmtMsg(g_hInst, IDMSG_ABOUT_BUILDVERSION, pszVersion)))
        {
            pszTmp = CmStrCpyAlloc(pszVersion);
        }

        CmFree(pszVersion);

        if (pszTmp)
        {
            SetDlgItemTextU(m_hWnd, IDC_ABOUT_VERSION, pszTmp);
            CmFree(pszTmp);
        }
    }

    return (TRUE);
}

//+----------------------------------------------------------------------------
//
// Function:  CAboutPage::OnOtherMessage
//
// Synopsis:  Callup opun message other than WM_INITDIALOG and WM_COMMAND
//
// Arguments: UINT - Message Id
//            WPARAM - wParam of the message
//            LPARAM - lParam of the message
//
// Returns:   DWORD - return value of the message
//
// History:   fengsun Created Header    2/26/98
//
//+----------------------------------------------------------------------------
DWORD CAboutPage::OnOtherMessage(UINT uMsg, WPARAM wParam, LPARAM )
{
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   CAboutPage::OnSetActive()
//
//  Synopsis:   Creates DI bitmap, etc. for about tab bitmap
//
//  Arguments:  None
//              
//
//  Returns:    NONE
//
//  History:    nickball    Created     7/14/97
//
//----------------------------------------------------------------------------

BOOL CAboutPage::OnSetActive()
{
    return 0;
}

//+----------------------------------------------------------------------------
//
// Function:  CAboutPage::OnKillActive
//
// Synopsis:  Virtual function. Called upon WM_NOTIFY with PSN_KILLACTIVE
//            Notifies a page that it is about to lose activation either because 
//            another page is being activated or the user has clicked the OK button.
// Arguments: None
//
// Returns:   BOOL - return value of the message
//
// History:   fengsun Created Header    2/26/98
//
//+----------------------------------------------------------------------------
BOOL CAboutPage::OnKillActive()
{
    return 0;
}


//+----------------------------------------------------------------------------
//
// Function:  CAboutPage::OnApply
//
// Synopsis:  Virtual function. Called upon WM_NOTIFY with PSN_APPLY
//            Indicates that the user clicked the OK or Apply Now button 
//            and wants all changes to take effect. 
//
// Arguments: None
//
// Returns:   NONE
//
// History:   fengsun Created Header    2/26/98
//
//+----------------------------------------------------------------------------
void CAboutPage::OnApply()
{
    SetPropSheetResult(PSNRET_NOERROR);
}

//+----------------------------------------------------------------------------
//
// Function:  CAboutPage::OnReset
//
// Synopsis:  Virtual function. Called upon WM_NOTIFY with PSN_RESET
//            Notifies a page that the user has clicked the Cancel button and 
//            the property sheet is about to be destroyed. 
//
// Arguments: None
//
// Returns:   NONE
//
// History:   fengsun Created Header    2/26/98
//
//+----------------------------------------------------------------------------
void CAboutPage::OnReset()
{
    //nothing
}

//+----------------------------------------------------------------------------
//
// Function:  CChangePasswordDlg::OnInitDialog
//
// Synopsis:  Virtual function. Call upon WM_INITDIALOG message
//
// Arguments: None
//
// Returns:   BOOL - Return value of WM_INITDIALOG
//
// History:   v-vijayb Created Header    7/3/99
//
//+----------------------------------------------------------------------------
BOOL CChangePasswordDlg::OnInitDialog()
{
    DWORD cMaxPassword;

    SetForegroundWindow(m_hWnd);

    m_pArgs->hWndChangePassword = m_hWnd;   
    UpdateFont(m_hWnd);

    int iMaxPasswordFromCMS = m_pArgs->piniService->GPPI(c_pszCmSection, c_pszCmEntryMaxPassword, PWLEN);

    if (InBetween(0, iMaxPasswordFromCMS, PWLEN))
    {
        cMaxPassword = iMaxPasswordFromCMS;    
    }
    else
    {
        cMaxPassword = PWLEN;
    }

    SendDlgItemMessageU(m_hWnd, IDC_NEW_PASSWORD, EM_SETLIMITTEXT, cMaxPassword, 0);
    SendDlgItemMessageU(m_hWnd, IDC_CONFIRMNEWPASSWORD, EM_SETLIMITTEXT, cMaxPassword, 0);
    SetFocus(GetDlgItem(m_hWnd, IDC_NEW_PASSWORD));

    //
    // Must return FALSE when setting focus
    //

    return FALSE; 
}



//+----------------------------------------------------------------------------
//
// Function:  CChangePasswordDlg::OnOK
//
// Synopsis:  Virtual function. Called upon WM_COMMAND with IDOK
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   v-vijayb Created Header    7/3/99
//
//+----------------------------------------------------------------------------
void CChangePasswordDlg::OnOK()
{
    TCHAR           szNewConfirmPassword[PWLEN+1];
    TCHAR           szNewPassword[PWLEN+1];

    GetDlgItemText(m_hWnd, IDC_NEW_PASSWORD, szNewPassword, PWLEN+1);
    GetDlgItemText(m_hWnd, IDC_CONFIRMNEWPASSWORD, szNewConfirmPassword, PWLEN+1);
    
    //
    // Both must match exactly
    //

    if (lstrcmpU(szNewPassword, szNewConfirmPassword) == 0)
    {
        //
        // Process password according to our handling rules
        //

        ApplyPasswordHandlingToBuffer(m_pArgs, szNewPassword);         
        
        // 
        // Encode password when comitting to internal storage.
        // 

        lstrcpyU(m_pArgs->szPassword, szNewPassword);
        CmEncodePassword(m_pArgs->szPassword);        

        lstrcpyU(m_pArgs->pRasDialParams->szPassword, szNewPassword);
        CmEncodePassword(m_pArgs->pRasDialParams->szPassword);        

        m_pArgs->fChangedPassword = TRUE;
        m_pArgs->hWndChangePassword = NULL;

        m_pArgs->Log.Log(PASSWORD_EXPIRED_EVENT, TEXT("ok"));
        
        EndDialog(m_hWnd, TRUE);
    }
    else
    {
        HWND    hWnd = GetDlgItem(m_hWnd, IDC_NEW_PASSWORD);
        TCHAR   *pszTmp;
                
        MYDBGASSERT(hWnd);
        
        pszTmp = CmFmtMsg(g_hInst, IDMSG_NOMATCHPASSWORD);                                              
        MYDBGASSERT(pszTmp);
        if (pszTmp)
        {
            MessageBoxEx(m_hWnd, pszTmp, m_pArgs->szServiceName, MB_OK | MB_ICONERROR, LANG_USER_DEFAULT);
            CmFree(pszTmp);
        }
        
        SetFocus(hWnd);
        SendMessageU(hWnd, EM_SETSEL, 0, MAKELONG(0, -1));
    }

    CmWipePassword(szNewConfirmPassword);
    CmWipePassword(szNewPassword);
}

//+----------------------------------------------------------------------------
//
// Function:  CChangePasswordDlg::OnCancel
//
// Synopsis:  Virtual function. Called upon WM_COMMAND with IDCANCEL
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   v-vijayb Created Header    7/16/99
//
//+----------------------------------------------------------------------------
void CChangePasswordDlg::OnCancel()
{
    m_pArgs->fChangedPassword = FALSE;
    m_pArgs->hWndChangePassword = NULL;
    m_pArgs->Log.Log(PASSWORD_EXPIRED_EVENT, TEXT("cancel"));
    EndDialog(m_hWnd, FALSE);
}

//+----------------------------------------------------------------------------
//
// Function:  CChangePasswordDlg::OnOtherCommand
//
// Synopsis:  Virtual function. Call upon WM_COMMAND with command other than IDOK
//            and IDCANCEL
//
// Arguments: WPARAM wParam - wParam of WM_COMMAND
//            LPARAM - 
//
// Returns:   DWORD - 
//
// History:   v-vijayb Created Header    7/3/99
//
//+----------------------------------------------------------------------------
DWORD CChangePasswordDlg::OnOtherCommand(WPARAM wParam, LPARAM)
{
    return FALSE;
}


//+----------------------------------------------------------------------------
//
// Function:  CCallbackNumberDlg::OnInitDialog
//
// Synopsis:  Virtual function. Call upon WM_INITDIALOG message
//
// Arguments: None
//
// Returns:   BOOL - Return value of WM_INITDIALOG
//
// History:   nickball      created         03/01/00
//
//+----------------------------------------------------------------------------
BOOL CCallbackNumberDlg::OnInitDialog()
{
    SetForegroundWindow(m_hWnd);

    //
    // Store window handle globally and setup edit control
    //

    m_pArgs->hWndCallbackNumber = m_hWnd;   
    UpdateFont(m_hWnd);

    SendDlgItemMessageU(m_hWnd, IDC_CALLBACK_NUM_EDIT, EM_SETLIMITTEXT, RAS_MaxCallbackNumber , 0);

    //
    // See if we have anything from previous use. If so, add it to the control.
    //

    SetWindowTextU(GetDlgItem(m_hWnd, IDC_CALLBACK_NUM_EDIT), m_pArgs->pRasDialParams->szCallbackNumber);   

    //
    // Set focus, must return FALSE when doing so.
    //

    SetFocus(GetDlgItem(m_hWnd, IDC_CALLBACK_NUM_EDIT));

    return FALSE; 
}

//+----------------------------------------------------------------------------
//
// Function:  CCallbackNumberDlg::OnOK
//
// Synopsis:  Virtual function. Called upon WM_COMMAND with IDOK
//            Retrieves the number for callback and stores in dial params.
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   nickball      created         03/01/00
//
//+----------------------------------------------------------------------------
void CCallbackNumberDlg::OnOK()
{
    TCHAR szNumber[RAS_MaxCallbackNumber+1];

    GetDlgItemText(m_hWnd, IDC_CALLBACK_NUM_EDIT, szNumber, RAS_MaxCallbackNumber);

    // 
    // Although one would expect that the length of the number would be 
    // verified, this is not the case with RAS. In the interests of
    // behavioral parity we will allow an empty number field. 
    //
  
    //
    // We're good to go, fill in Dial Params and ski-dadle.
    //

    lstrcpyU(m_pArgs->pRasDialParams->szCallbackNumber, szNumber);

    //
    // Succesful callback, store the number in the .CMP
    // 

    m_pArgs->piniProfile->WPPS(c_pszCmSection, c_pszCmEntryCallbackNumber, m_pArgs->pRasDialParams->szCallbackNumber);
                
    m_pArgs->hWndCallbackNumber = NULL;

    m_pArgs->Log.Log(CALLBACK_NUMBER_EVENT, TEXT("ok"), m_pArgs->pRasDialParams->szCallbackNumber);

    EndDialog(m_hWnd, TRUE);
}

//+----------------------------------------------------------------------------
//
// Function:  CCallbackNumberDlg::OnCancel
//
// Synopsis:  Virtual function. Called upon WM_COMMAND with IDCANCEL
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   nickball      created         03/01/00
//
//+----------------------------------------------------------------------------
void CCallbackNumberDlg::OnCancel()
{
    m_pArgs->fWaitingForCallback = FALSE;
    m_pArgs->hWndCallbackNumber = NULL;
    m_pArgs->Log.Log(CALLBACK_NUMBER_EVENT, TEXT("cancel"), TEXT("none"));
    EndDialog(m_hWnd, FALSE);
}

//+----------------------------------------------------------------------------
//
// Function:  CCallbackNumberDlg::OnOtherCommand
//
// Synopsis:  Virtual function. Call upon WM_COMMAND with command other than IDOK
//            and IDCANCEL
//
// Arguments: WPARAM wParam - wParam of WM_COMMAND
//            LPARAM - 
//
// Returns:   DWORD - 
//
// History:   nickball      created         03/01/00
//
//+----------------------------------------------------------------------------
DWORD CCallbackNumberDlg::OnOtherCommand(WPARAM wParam, LPARAM)
{
    return FALSE;
}

//
// No help on OK or Cancel button
//
const DWORD CRetryAuthenticationDlg::m_dwHelp[] = {
        IDC_RETRY_REMEMBER,         IDH_RETRY_REMEMBER,
        IDC_RETRY_USERNAME_STATIC,  IDH_RETRY_USERNAME_STATIC,
        IDC_RETRY_USERNAME,         IDH_RETRY_USERNAME,
        IDC_RETRY_PASSWORD_STATIC,  IDH_RETRY_PASSWORD_STATIC,
        IDC_RETRY_PASSWORD,         IDH_RETRY_PASSWORD,
        IDC_RETRY_DOMAIN_STATIC,    IDH_RETRY_DOMAIN_STATIC,
        IDC_RETRY_DOMAIN,           IDH_RETRY_DOMAIN,
        IDOK,                       IDH_RETRY_OK,
        IDCANCEL,                   IDH_RETRY_CANCEL,
        0,0};

//+----------------------------------------------------------------------------
//
// Function:  CRetryAuthenticationDlg::OnInitDialog
//
// Synopsis:  Virtual function. Call upon WM_INITDIALOG message to intialize
//            the dialog.
//
// Arguments: None
//
// Returns:   BOOL - Return value of WM_INITDIALOG
//
// History:   nickball      created         03/01/00
//
//+----------------------------------------------------------------------------
BOOL CRetryAuthenticationDlg::OnInitDialog()
{   
    DWORD dwMax = MAX_PATH;

    m_pArgs->Log.Log(RETRY_AUTH_EVENT);

    SetForegroundWindow(m_hWnd);
    
    //
    // Brand the dialog
    //

    if (m_pArgs->hSmallIcon)
    {
        SendMessageU(m_hWnd, WM_SETICON, ICON_SMALL, (LPARAM) m_pArgs->hSmallIcon); 
    }

    if (m_pArgs->hBigIcon)
    {        
        SendMessageU(m_hWnd, WM_SETICON, ICON_BIG, (LPARAM) m_pArgs->hBigIcon); 
        SendMessageU(GetDlgItem(m_hWnd, IDC_INET_ICON), STM_SETIMAGE, IMAGE_ICON, (LPARAM) m_pArgs->hBigIcon); 
    }

    //
    // Store window handle globally and setup edit control
    //

    m_pArgs->hWndRetryAuthentication = m_hWnd;  
    UpdateFont(m_hWnd);
    
    //
    // If not Inet dial, then use the service as the title
    //

    if (!m_fInetCredentials)
    {
        LPTSTR pszTitle = CmStrCpyAlloc(m_pArgs->szServiceName);
        SetWindowTextU(m_hWnd, pszTitle);
        CmFree(pszTitle);
    }
    
    //
    // Fill password as appropriate to the template and dial type.
    //

    HWND hwndPassword = GetDlgItem(m_hWnd, IDC_RETRY_PASSWORD);

    if (hwndPassword)
    {
        //
        // Limit user entry according to current config.
        // 
        int iMaxPasswordFromCMS = m_pArgs->piniService->GPPI(c_pszCmSection, c_pszCmEntryMaxPassword, PWLEN);

        if (InBetween(0, iMaxPasswordFromCMS, PWLEN))
        {
            dwMax = iMaxPasswordFromCMS;    
        }
        else
        {
            dwMax = PWLEN;
        }

        SendDlgItemMessageU(m_hWnd, IDC_RETRY_PASSWORD, EM_SETLIMITTEXT, dwMax, 0);
        MYDBGASSERT(dwMax <= PWLEN && dwMax > 0);
                      
        //
        // Do we have any data to display?
        //
        
        BOOL fHasPassword = FALSE;

        if (m_fInetCredentials)           
        {            
            if (lstrlenU(m_pArgs->szInetPassword))
            {
                CmDecodePassword(m_pArgs->szInetPassword);
                SetDlgItemTextU(m_hWnd, IDC_RETRY_PASSWORD, m_pArgs->szInetPassword);
                CmEncodePassword(m_pArgs->szInetPassword);
                fHasPassword = TRUE;
            }
        }        
        else
        {
            if (lstrlenU(m_pArgs->szPassword))
            {
                CmDecodePassword(m_pArgs->szPassword);
                SetDlgItemTextU(m_hWnd, IDC_RETRY_PASSWORD, m_pArgs->szPassword);
                CmEncodePassword(m_pArgs->szPassword);
                fHasPassword = TRUE;
            }
        }

        //
        // Decide what to do with "Save Password" check-box
        //
        
        HWND hwndSavePassword = GetDlgItem(m_hWnd, IDC_RETRY_REMEMBER);

        if (hwndSavePassword)
        {
            // 
            // We have a save password control, see if we should hide it. 
            //

            if ((m_fInetCredentials && m_pArgs->fHideRememberInetPassword) ||
                (!m_fInetCredentials && m_pArgs->fHideRememberPassword))
            {
                ShowWindow(hwndSavePassword, SW_HIDE);
            }
            else
            {
                //
                // We're not hiding, so adjust its state as needed. If no data
                // then disable the control. Otherwise check according to current
                // user setting.
                //

                if (!fHasPassword)
                {
                    EnableWindow(GetDlgItem(m_hWnd, IDC_RETRY_REMEMBER), FALSE);
                }
                else
                {
                    if ((m_fInetCredentials && m_pArgs->fRememberInetPassword) ||
                        (!m_fInetCredentials && m_pArgs->fRememberMainPassword))
                    {
                        SendMessageU(hwndSavePassword, BM_SETCHECK, BST_CHECKED, 0);
                    }
                }
            }
        }
    }

    //
    // Fill username as appropriate to the template and dial type.
    //
    
    HWND hwndUsername = GetDlgItem(m_hWnd, IDC_RETRY_USERNAME);

    if (hwndUsername)
    {
        int iMaxUserNameFromCMS = m_pArgs->piniService->GPPI(c_pszCmSection, c_pszCmEntryMaxUserName, UNLEN);

        if (InBetween(0, iMaxUserNameFromCMS, UNLEN))
        {
            dwMax = iMaxUserNameFromCMS;    
        }
        else
        {
            dwMax = UNLEN;
        }

        SendDlgItemMessageU(m_hWnd, IDC_RETRY_USERNAME, EM_SETLIMITTEXT, dwMax, 0);
        MYDBGASSERT(dwMax <= UNLEN);
               
        if (m_fInetCredentials)           
        {            
            if (lstrlenU(m_pArgs->szInetUserName))
            {
                SetDlgItemTextU(m_hWnd, IDC_RETRY_USERNAME, m_pArgs->szInetUserName);
            }
        }        
        else
        {
            if (lstrlenU(m_pArgs->szUserName))
            {
                SetDlgItemTextU(m_hWnd, IDC_RETRY_USERNAME, m_pArgs->szUserName);
            }
        }
    }

    //
    // Fill domain as appropriate to the template.
    //

    HWND hwndDomain = GetDlgItem(m_hWnd, IDC_RETRY_DOMAIN);
    
    if (hwndDomain)
    {
        int iMaxDomainFromCMS = m_pArgs->piniService->GPPI(c_pszCmSection, c_pszCmEntryMaxDomain, DNLEN);

        if (InBetween(0, iMaxDomainFromCMS, DNLEN))
        {
            dwMax = iMaxDomainFromCMS;    
        }
        else
        {
            dwMax = DNLEN;
        }

        SendDlgItemMessageU(m_hWnd, IDC_RETRY_DOMAIN, EM_SETLIMITTEXT, dwMax, 0);
        MYDBGASSERT(dwMax <= DNLEN);       
       
        if (lstrlenU(m_pArgs->szDomain))
        {
            SetDlgItemTextU(m_hWnd, IDC_RETRY_DOMAIN, m_pArgs->szDomain);
        }
    }

    //
    // Drop focus in the first available control
    //

    HWND hwndFocus = hwndUsername;
    
    if (!hwndFocus)
    {
        hwndFocus = hwndPassword ? hwndPassword : hwndDomain;   
    }
    
    SetFocus(hwndFocus);

    //
    // Must return FALSE when setting focus
    //

    return FALSE; 
}

//+----------------------------------------------------------------------------
//
// Function:  CRetryAuthenticationDlg::OnOK
//
// Synopsis:  Virtual function. Called upon WM_COMMAND with IDOK
//            Retrieves the cerdentials and stores them in dial params.
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   nickball      created         03/01/00
//
//+----------------------------------------------------------------------------
void CRetryAuthenticationDlg::OnOK()
{
    LPTSTR pszBuf = NULL;
    BOOL fSave = FALSE;

    //
    // Check Save Password (if any) to see how we should proceed
    //
    
    BOOL fSwitchToUserCredentials = FALSE;
    BOOL fNeedToResaveUserName = FALSE;
    BOOL fNeedToResaveDomain = FALSE;
    BOOL fChecked = FALSE;
    
    HWND hwndMainDlgSavePW = GetDlgItem(m_pArgs->hwndMainDlg, IDC_MAIN_NOPASSWORD_CHECKBOX);
    HWND hwndMainDlgDialAutomatically = GetDlgItem(m_pArgs->hwndMainDlg, IDC_MAIN_NOPROMPT_CHECKBOX);
    BOOL fMainDlgSavePWEnabled = FALSE;
    BOOL fMainDlgDialAutoEnabled = FALSE;

    //
    // In order not to trigger change notification when updating Main dialog controls.
    // This is set back to FALSE at the bottom of the funtion.
    //
    m_pArgs->fIgnoreChangeNotification = TRUE;


    //
    // Gets the inital state of the checkboxes
    //
    if (hwndMainDlgSavePW)
    {
        fMainDlgSavePWEnabled = IsWindowEnabled(hwndMainDlgSavePW);
    }

    if (hwndMainDlgDialAutomatically)
    {
        fMainDlgDialAutoEnabled = IsWindowEnabled(hwndMainDlgDialAutomatically);
    }

    if (GetDlgItem(m_hWnd, IDC_RETRY_REMEMBER))
    {
        fChecked = IsDlgButtonChecked(m_hWnd, IDC_RETRY_REMEMBER);


        if (m_fInetCredentials)
        {
            if (m_pArgs->fRememberInetPassword != fChecked)
            {          

                if (fChecked && (FALSE == m_pArgs->fRememberInetPassword))
                {
                    //
                    // This time around the user wants to save credentials,
                    // but before (in main dialog) he didn't want to save anything.
                    // Thus we should resave username and domain
                    //
                    fNeedToResaveUserName = TRUE;
                }

                m_pArgs->fRememberInetPassword = fChecked;             

                if (CM_LOGON_TYPE_USER == m_pArgs->dwWinLogonType)
                {
                    SaveUserInfo(m_pArgs, 
                                 UD_ID_REMEMBER_INET_PASSWORD, 
                                 (PVOID)&m_pArgs->fRememberInetPassword);

                }
            }
        }
        else
        {
            if (m_pArgs->fRememberMainPassword != fChecked)
            {          
                if (fChecked && (FALSE == m_pArgs->fRememberMainPassword))
                {
                    //
                    // This time around the user wants to save credentials,
                    // but before (in main dialog) he didn't want to save anything.
                    // Thus we should resave username and domain
                    //
                    fNeedToResaveUserName = TRUE;
                    fNeedToResaveDomain = TRUE;
                }

                m_pArgs->fRememberMainPassword = fChecked;        

                if (CM_LOGON_TYPE_USER == m_pArgs->dwWinLogonType)
                {
                    SaveUserInfo(m_pArgs, 
                                 UD_ID_REMEMBER_PWD, 
                                 (PVOID)&m_pArgs->fRememberMainPassword);               
                }

                //
                // There has been a change to main creds, update main display
                //
                CheckDlgButton(m_pArgs->hwndMainDlg, 
                           IDC_MAIN_NOPASSWORD_CHECKBOX, 
                           m_pArgs->fRememberMainPassword);
            }
        }
    }
    
    

    //
    // If the password field is enabled & the save pw checkbox is unchecked then delete creds.
    // Only if the user is logged on.
    //
    HWND hwndPassword = GetDlgItem(m_hWnd, IDC_RETRY_PASSWORD);

    if (hwndPassword && OS_NT51 && (FALSE == fChecked) && (CM_LOGON_TYPE_USER == m_pArgs->dwWinLogonType))
    {
        if (CM_CREDS_GLOBAL == m_pArgs->dwCurrentCredentialType)
        {
            //
            // Since the user has unchecked the 'Save Password' flag and the current credential type is global,
            // we are deleting globals, but we need to save the userinfo into the USER (local) credential store 
            // in order for CM to correctly pick up the username and password on next launch.
            //
            fSwitchToUserCredentials = TRUE;
        }

        if (m_fInetCredentials)
        {
            //
            // Unsaving Internet credentials
            // Even if we are using the same username, we shouldn't delete main credentials
            // on this dialog, since we are re-authing for Internet credentials
            //
            if (CM_CREDS_GLOBAL == m_pArgs->dwCurrentCredentialType)
            {
                //
                // Unsaving Internet Global
                //

                //
                // Local Inet shouldn't exist in this case, so we shouldn't delete the Identity,
                // but for globals, we don't support just deleting password. This is from the RAS
                // code base and the delete function actually enforces this.
                //
                if (CM_EXIST_CREDS_INET_GLOBAL & m_pArgs->dwExistingCredentials)
                {
                    DeleteSavedCredentials(m_pArgs, CM_CREDS_TYPE_INET, CM_DELETE_SAVED_CREDS_DELETE_GLOBALS, CM_DELETE_SAVED_CREDS_DELETE_IDENTITY);
                    m_pArgs->dwExistingCredentials &= ~CM_EXIST_CREDS_INET_GLOBAL;
                }
            }
            else
            {
                //
                // Unsaving Internet local (user)
                // Even if we are using the same username, we shouldn't delete main credentials
                // on this dialog, since we are just re-authing for Internet password
                //
                if (CM_EXIST_CREDS_INET_USER & m_pArgs->dwExistingCredentials)
                {
                    //
                    // Internet user credentials exist, so now delete the identity based on if the 
                    // global inet creds exist
                    //
                    if (CM_EXIST_CREDS_INET_GLOBAL & m_pArgs->dwExistingCredentials)
                    {
                        DeleteSavedCredentials(m_pArgs, CM_CREDS_TYPE_INET, CM_DELETE_SAVED_CREDS_KEEP_GLOBALS, CM_DELETE_SAVED_CREDS_DELETE_IDENTITY);
                    }
                    else
                    {
                        DeleteSavedCredentials(m_pArgs, CM_CREDS_TYPE_INET, CM_DELETE_SAVED_CREDS_KEEP_GLOBALS, CM_DELETE_SAVED_CREDS_KEEP_IDENTITY);
                    }
                    
                    m_pArgs->dwExistingCredentials &= ~CM_EXIST_CREDS_INET_USER;
                }
            }
        }
        else
        {
            //
            // ReAuth for Main credentials & Delete main set of credentials
            // Most of this code is taken from a section in TryToDeleteAndSaveCredentials
            // since most of the logic remains the same if the user unchecks the 'Save Password' 
            // option on the main dialog, except that here we don't prompt the user.
            // If the user got promted it happened on the main dialog and the creds were either
            // kept or deleted according to his selection. Thus we don't need to ask here.
            //
       
            //
            // Check which option button is currently selected
            //
            if (CM_CREDS_GLOBAL == m_pArgs->dwCurrentCredentialType)
            {
                //
                // Since global is selected then we actually want to delete both sets of credentials
                //

                if (CM_EXIST_CREDS_MAIN_GLOBAL & m_pArgs->dwExistingCredentials)
                {
                    //
                    // Delete the global credentials.  
                    // Note from RAS codebase: Note that we have to delete the global identity 
                    // as well because we do not support deleting 
                    // just the global password.  This is so that 
                    // RasSetCredentials can emulate RasSetDialParams.
                    //

                    DeleteSavedCredentials(m_pArgs, CM_CREDS_TYPE_MAIN, CM_DELETE_SAVED_CREDS_DELETE_GLOBALS, CM_DELETE_SAVED_CREDS_DELETE_IDENTITY);
                    m_pArgs->dwExistingCredentials &= ~CM_EXIST_CREDS_MAIN_GLOBAL;
                }

                if (CM_EXIST_CREDS_INET_GLOBAL & m_pArgs->dwExistingCredentials)
                {
                    if (m_pArgs->fUseSameUserName || (FALSE == m_pArgs->fRememberInetPassword))
                    {
                        DeleteSavedCredentials(m_pArgs, CM_CREDS_TYPE_INET, CM_DELETE_SAVED_CREDS_DELETE_GLOBALS, CM_DELETE_SAVED_CREDS_DELETE_IDENTITY);
                        m_pArgs->dwExistingCredentials &= ~CM_EXIST_CREDS_INET_GLOBAL;
                    }
                }
            }
            else
            {
                //
                // Delete the password saved per-user.  Keep the user name
                // and domain saved, however unless global credentials exist.
                // Whenever global credential exist, and we are deleting user credentials
                // we must always delete all of the information (identity + password) associated
                // with the user credentials. 
                //

                if (CM_EXIST_CREDS_MAIN_USER & m_pArgs->dwExistingCredentials)
                {
                    if (CM_EXIST_CREDS_MAIN_GLOBAL & m_pArgs->dwExistingCredentials)
                    {
                        DeleteSavedCredentials(m_pArgs, CM_CREDS_TYPE_MAIN, CM_DELETE_SAVED_CREDS_KEEP_GLOBALS, CM_DELETE_SAVED_CREDS_DELETE_IDENTITY);
                    }
                    else
                    {
                        DeleteSavedCredentials(m_pArgs, CM_CREDS_TYPE_MAIN, CM_DELETE_SAVED_CREDS_KEEP_GLOBALS, CM_DELETE_SAVED_CREDS_KEEP_IDENTITY);
                    }
                    m_pArgs->dwExistingCredentials &= ~CM_EXIST_CREDS_MAIN_USER;
                }

                if (CM_EXIST_CREDS_INET_USER & m_pArgs->dwExistingCredentials)
                {
                    if (m_pArgs->fUseSameUserName || (FALSE == m_pArgs->fRememberInetPassword))
                    {
                        if (CM_EXIST_CREDS_INET_GLOBAL & m_pArgs->dwExistingCredentials)
                        {
                            DeleteSavedCredentials(m_pArgs, CM_CREDS_TYPE_INET, CM_DELETE_SAVED_CREDS_KEEP_GLOBALS, CM_DELETE_SAVED_CREDS_DELETE_IDENTITY);
                        }
                        else
                        {
                            DeleteSavedCredentials(m_pArgs, CM_CREDS_TYPE_INET, CM_DELETE_SAVED_CREDS_KEEP_GLOBALS, CM_DELETE_SAVED_CREDS_KEEP_IDENTITY);
                        }
                        m_pArgs->dwExistingCredentials &= ~CM_EXIST_CREDS_INET_USER;
                    }
                }
            }
        }
    }

    if (fSwitchToUserCredentials)
    {
        //
        // Since this flag was set when we deleted global credentials, we need 
        // to save the userinfo into the USER (local) credential store 
        // in order for CM to correctly pick up the username and password on next launch.
        // We cannnot store userinfo w/o a password in the global store, because the RAS API 
        // doesn't support that. (From rasdlg code).
        //

        m_pArgs->dwCurrentCredentialType = CM_CREDS_USER;
    }


    if (hwndPassword)
    {       
        pszBuf = CmGetWindowTextAlloc(m_hWnd, IDC_RETRY_PASSWORD);

        if (pszBuf)
        {
            //
            // Process password according to our handling and encoding rules. 
            //

            ApplyPasswordHandlingToBuffer(m_pArgs, pszBuf);         

            //
            // Password is prepped, update our memory based storage.
            //

            if (m_fInetCredentials)
            {
                lstrcpyU(m_pArgs->szInetPassword, pszBuf);
                CmEncodePassword(m_pArgs->szInetPassword);
            }
            else
            {
                lstrcpyU(m_pArgs->szPassword, pszBuf);
                CmEncodePassword(m_pArgs->szPassword);
            }

            lstrcpyU(m_pArgs->pRasDialParams->szPassword, pszBuf);
            CmEncodePassword(m_pArgs->pRasDialParams->szPassword);

            //
            // Make sure we set the persistent user info store correctly. 
            // Blank if save password is not checked or if we aren't using ras
            // cred store. On Win2K+ the creds we marked and deleted so passwords
            // doesn't need to be set to blank.
            //

            if (m_fInetCredentials)
            {
                if (OS_NT5 && m_pArgs->bUseRasCredStore)
                {
                    // 
                    // For Win2K+ we have the ras store. If the checkbox is checked 
                    // and a user is logged in then we want to save it.
                    //
                    if (fChecked && CM_LOGON_TYPE_USER == m_pArgs->dwWinLogonType)
                    {
                        SaveUserInfo(m_pArgs, 
                                     UD_ID_INET_PASSWORD, 
                                     (PVOID)pszBuf);
                    }
                }
                else
                {
                    //
                    // We don't have to ras cred store so we either save the password
                    // or set it to an empty string since deleting marked credentials 
                    // doesn't do anything on no Win2K+ platforms
                    //
                    SaveUserInfo(m_pArgs, 
                                 UD_ID_INET_PASSWORD, 
                                 (PVOID) (fChecked ? pszBuf : TEXT("")));
                }
            }
            else
            {
                if (OS_NT5 && m_pArgs->bUseRasCredStore)
                {
                    // 
                    // For Win2K+ we have the ras store. If the checkbox is checked 
                    // and a user is logged in then we want to save it.
                    //
                    if (fChecked && CM_LOGON_TYPE_USER == m_pArgs->dwWinLogonType)
                    {
                        SaveUserInfo(m_pArgs, 
                                     UD_ID_PASSWORD, 
                                     (PVOID)pszBuf);
                    }
                }
                else
                {
                    //
                    // We don't have to ras cred store so we either save the password
                    // or set it to an empty string since deleting marked credentials 
                    // doesn't do anything on no Win2K+ platforms
                    //
                    SaveUserInfo(m_pArgs, 
                                 UD_ID_PASSWORD, 
                                 (PVOID) (fChecked ? pszBuf : TEXT("")));
                }
                //
                // If there's been a change to main creds, update main display.
                //

                if (SendMessageU(hwndPassword, EM_GETMODIFY, 0L, 0L))
                {
                    SetDlgItemTextU(m_pArgs->hwndMainDlg, IDC_MAIN_PASSWORD_EDIT, pszBuf);
                }
            }

            CmEncodePassword(pszBuf); // Encode before release
            CmFree(pszBuf);
        }
    }   
 

    //
    // Retrieve Domain and copy to CM data store and RasDialParams. We process
    // the domain first because the construction of the username that we hand
    // to RAS depends on it.
    //
    // Note: RAS updates its store whenever the users selects OK. We will too.
    //

    HWND hwndDomain = GetDlgItem(m_hWnd, IDC_RETRY_DOMAIN);

    //
    // If the checkbox is false, the creds were
    // deleted above so we now need to re-save the domain.
    //
    if ((hwndDomain && SendMessageU(hwndDomain, EM_GETMODIFY, 0L, 0L)) || 
        (hwndDomain && FALSE == fChecked) ||
        (hwndDomain && fNeedToResaveDomain))
    {
        pszBuf = CmGetWindowTextAlloc(m_hWnd, IDC_RETRY_DOMAIN);
    
        if (pszBuf)
        {
            lstrcpyU(m_pArgs->szDomain, pszBuf);
            lstrcpyU(m_pArgs->pRasDialParams->szDomain, pszBuf);

            if (CM_LOGON_TYPE_USER == m_pArgs->dwWinLogonType)
            {
                SaveUserInfo(m_pArgs, UD_ID_DOMAIN, (PVOID)pszBuf);          
            }

            //
            // There has been a change to main creds, update main display
            //

            SetDlgItemTextU(m_pArgs->hwndMainDlg, IDC_MAIN_DOMAIN_EDIT, pszBuf);        

            CmFree(pszBuf);
        }
    }

    if (NULL == hwndDomain && FALSE == m_fInetCredentials)
    {
        //
        // The domain field is hidden, but we still need to save the domain info from the
        // pArgs structure in order for us to pre-populate later if it's not internet creds.
        // 
        if (CM_LOGON_TYPE_USER == m_pArgs->dwWinLogonType)
        {
            SaveUserInfo(m_pArgs, UD_ID_DOMAIN, (PVOID)m_pArgs->szDomain);          
        }
    }
    //
    // Retrieve UserName and copy to CM data store and the RasDialParams struct
    //
    HWND hwndUsername = GetDlgItem(m_hWnd, IDC_RETRY_USERNAME);
    
    //
    // If the checkbox is false, the creds were
    // deleted above so we now need to re-save the username.
    //
    if ((hwndUsername && SendMessageU(hwndUsername, EM_GETMODIFY, 0L, 0L)) ||
        (hwndUsername && FALSE == fChecked) ||
        (hwndUsername && fNeedToResaveUserName))
    {
        pszBuf = CmGetWindowTextAlloc(m_hWnd, IDC_RETRY_USERNAME);

        if (pszBuf)
        {
            if (m_fInetCredentials)
            {
                lstrcpyU(m_pArgs->szInetUserName, pszBuf);
                SaveUserInfo(m_pArgs, UD_ID_INET_USERNAME, (PVOID)pszBuf);
            }
            else
            {
                lstrcpyU(m_pArgs->szUserName, pszBuf);
                if (CM_LOGON_TYPE_USER == m_pArgs->dwWinLogonType)
                {
                    SaveUserInfo(m_pArgs, UD_ID_USERNAME, (PVOID)pszBuf);
                }

                //
                // There has been a change to main creds, update main display
                //

                SetDlgItemTextU(m_pArgs->hwndMainDlg, IDC_MAIN_USERNAME_EDIT, pszBuf);        
            }

            //
            // We'll need the service file for the current number. If we're actively
            // tunneling, make sure that we get the top-level service files, so we
            // don't pick up any settings from a referenced dial-up service.
            //
            
            CIni *piniService = NULL;
            BOOL bNeedToFree = FALSE;
            
            if (IsDialingTunnel(m_pArgs))
            {
                piniService = m_pArgs->piniService;
            }
            else
            {
                piniService = GetAppropriateIniService(m_pArgs, m_pArgs->nDialIdx);
                bNeedToFree = TRUE;
            }

            MYDBGASSERT(piniService);
       
            if (piniService)
            {
                //
                // Apply suffix, prefix, to username as necessary
                //

                LPTSTR pszTmp = ApplyPrefixSuffixToBufferAlloc(m_pArgs, piniService, pszBuf);
  
                if (pszTmp)
                {
                    //
                    // Apply domain to username as necessary. Note that we only want to do this on modem calls,
                    // not tunnels.
                    //
                    LPTSTR pszUsername = NULL;

                    if (IsDialingTunnel(m_pArgs))
                    {
                        lstrcpynU(m_pArgs->pRasDialParams->szUserName, pszTmp, sizeof(m_pArgs->pRasDialParams->szUserName)/sizeof(TCHAR));
                    }
                    else
                    {
                        pszUsername = ApplyDomainPrependToBufferAlloc(m_pArgs, piniService, pszTmp, (m_pArgs->aDialInfo[m_pArgs->nDialIdx].szDUN));
   
                        if (pszUsername)
                        {
                            lstrcpynU(m_pArgs->pRasDialParams->szUserName, pszUsername, sizeof(m_pArgs->pRasDialParams->szUserName)/sizeof(TCHAR));
                        }                        
                    }
        
                    CmFree(pszUsername);
                    CmFree(pszTmp);
                }

                if (bNeedToFree)
                {
                    delete piniService;
                }
            }       
        }
 
        CmFree(pszBuf);
    }
  
    if (NULL == hwndUsername)
    {
        //
        // The username field is hidden, but we still need to save it
        // in order for us to pre-populate later.
        //
        if (CM_LOGON_TYPE_USER == m_pArgs->dwWinLogonType)
        {
            SaveUserInfo(m_pArgs, UD_ID_USERNAME, (PVOID)m_pArgs->szUserName);
        }
    }


    m_pArgs->fIgnoreChangeNotification = FALSE;
    
    if (fSwitchToUserCredentials)
    {
        //
        // Now that we saved the user name to the local/user cred store
        // we need to switch the credential type back to global in order
        // to maintain the correct state.
        //
        m_pArgs->dwCurrentCredentialType = CM_CREDS_GLOBAL;
    }

    //
    // Resets the state of the checkboxes
    //
    if (hwndMainDlgSavePW)
    {
        EnableWindow(hwndMainDlgSavePW, fMainDlgSavePWEnabled);
    }

    if (hwndMainDlgDialAutomatically)
    {
        EnableWindow(hwndMainDlgDialAutomatically, fMainDlgDialAutoEnabled);
    }

    //
    // Need to refresh to see which creds exist
    //
    BOOL fReturn = RefreshCredentialTypes(m_pArgs, FALSE);

    //
    // Cleanup state and go.
    //

    m_pArgs->hWndRetryAuthentication = NULL;

    EndDialog(m_hWnd, TRUE);
}

//+----------------------------------------------------------------------------
//
// Function:  CRetryAuthenticationDlg::OnCancel
//
// Synopsis:  Virtual function. Called upon WM_COMMAND with IDCANCEL
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   nickball      created         03/01/00
//
//+----------------------------------------------------------------------------
void CRetryAuthenticationDlg::OnCancel()
{
    m_pArgs->hWndRetryAuthentication = NULL;
    EndDialog(m_hWnd, FALSE);
}

//+----------------------------------------------------------------------------
//
// Function:  CRetryAuthenticationDlg::OnOtherCommand
//
// Synopsis:  Virtual function. Call upon WM_COMMAND with command other than IDOK
//            and IDCANCEL
//
// Arguments: WPARAM wParam - wParam of WM_COMMAND
//            LPARAM - 
//
// Returns:   DWORD - 
//
// History:   nickball      created         03/01/00
//
//+----------------------------------------------------------------------------
DWORD CRetryAuthenticationDlg::OnOtherCommand(WPARAM wParam, LPARAM)
{   
    switch (LOWORD(wParam)) 
    {
        case IDC_RETRY_PASSWORD:
        {  
            if (HIWORD(wParam) == EN_CHANGE) 
            {
                HWND hwndSavePassword = GetDlgItem(m_hWnd, IDC_RETRY_REMEMBER);

                MYDBGASSERT(hwndSavePassword);

                //
                // There has been a change to the password edit control, see
                // if there is any text and set the check-box accordingly.
                // 
                
                if (0 == SendDlgItemMessageU(m_hWnd, 
                                        IDC_RETRY_PASSWORD, 
                                        WM_GETTEXTLENGTH,
                                        0,
                                        0))
                {
                    //
                    // No text. If the control is checked, then uncheck it. 
                    // Also, disable it.
                    //
                    
                    if (IsDlgButtonChecked(m_hWnd, IDC_RETRY_REMEMBER))
                    {
                        SendMessageU(hwndSavePassword, BM_SETCHECK, BST_UNCHECKED, 0);
                    }

                    EnableWindow(hwndSavePassword, FALSE);
                }
                else
                {
                    // 
                    // There is data, if disabled, then enable appropriately
                    //

                    if (FALSE == IsWindowEnabled(GetDlgItem(m_hWnd, IDC_RETRY_REMEMBER)))
                    {                       
                        EnableWindow(GetDlgItem(m_hWnd, IDC_RETRY_REMEMBER), TRUE);
                    }
                }
            
                break;
            }
        }          
    }

    return FALSE;
}

//+----------------------------------------------------------------------------
//
// Function:  CRetryAuthenticationDlg::GetDlgTemplate
//
// Synopsis:  Encapsulates determining which template is to be used
//            for the Retry dialog. Same model a MainDlg, but the 
//            determinants are slightly different as the dialog proc
//            and templates serve double-duty for Inet and VPN.
//
// Arguments: ArgsStruct *pArgs - Ptr to global Args struct
//
// Returns:   UINT - Dlg template ID.
//
// History:   nickball    Created     03/04/00
//
//+----------------------------------------------------------------------------
UINT CRetryAuthenticationDlg::GetDlgTemplate()
{
    MYDBGASSERT(m_pArgs);
    
    //
    // First set the mask according to the .CMS flags for each value.
    //

    UINT uiMainDlgID = 0;
    DWORD dwTemplateMask = 0;

    //
    // If Inet and not UseSameUserName, then honor Inet flags for Username
    //

    if (m_fInetCredentials)
    {
        if (!m_pArgs->fHideInetUsername) 
        {
            dwTemplateMask |= CMTM_UID;
        }
    }
    else
    {
        //
        // Otherwise, the main Username display rules apply.
        //

        if (!m_pArgs->fHideUserName) 
        {
            dwTemplateMask |= CMTM_UID;
        }   
    }

    //
    // If Inet and not UseSameUserName, then honor Inet flags for password
    //

    if (m_fInetCredentials)
    {
        if (!m_pArgs->fHideInetPassword)
        {
            dwTemplateMask |= CMTM_PWD;
        }
    }
    else
    {
        //
        // Otherwise, the main password display rules apply.
        //

        if (!m_pArgs->fHidePassword)
        {
            dwTemplateMask |= CMTM_PWD;
        }   
    }

    //
    // Previously, the OS was the determinant for domain display. 
    // Nowadays, we want to display a domain when:
    //
    //  a) Its not a straight Inet dial 
    //
    //      AND
    //
    //  b) The domain field is not explicitly hidden
    //



    if (!m_fInetCredentials && !m_pArgs->fHideDomain)  
    {
        dwTemplateMask |= CMTM_DMN;
    }

    switch (dwTemplateMask)
    {
        case CMTM_U_P_D:
            uiMainDlgID = IDD_RETRY_UID_PWD_DMN;
            break;

        case CMTM_UID:
            uiMainDlgID = IDD_RETRY_UID_ONLY;
            break;

        case CMTM_PWD:
            uiMainDlgID = IDD_RETRY_PWD_ONLY;
            break;

        case CMTM_DMN:
            uiMainDlgID = IDD_RETRY_DMN_ONLY;
            break;

        case CMTM_UID_AND_PWD:
            uiMainDlgID = IDD_RETRY_UID_AND_PWD;
            break;

        case CMTM_UID_AND_DMN:
            uiMainDlgID = IDD_RETRY_UID_AND_DMN;
            break;

        case CMTM_PWD_AND_DMN:
            uiMainDlgID = IDD_RETRY_PWD_AND_DMN;
            break;
                                
        default:
             MYDBGASSERT(FALSE);
             uiMainDlgID = 0;
             break; 
    }       
    
    return uiMainDlgID;
}


//+----------------------------------------------------------------------------
//
// Func:    AccessPointInfoChanged
//
// Desc:    Checks all the controls to determine if any changes have been made
//
// Args:    NONE 
//
// Return:  BOOL - True if any information has changed
//
// Notes:   
//
// History: t-urama     07/31/2000  Created
//-----------------------------------------------------------------------------

BOOL CGeneralPage::AccessPointInfoChanged()
{
    if (m_bAPInfoChanged)
    {
        return TRUE;
    }

    if (0 != SendDlgItemMessageU(m_hWnd, IDC_GENERAL_PRIMARY_EDIT, EM_GETMODIFY, 0, 0))
    {
        return TRUE;
    }

    if (0 != SendDlgItemMessageU(m_hWnd, IDC_GENERAL_BACKUP_EDIT, EM_GETMODIFY, 0, 0))
    {
        return TRUE;
    }

    
    return FALSE;
}

//+----------------------------------------------------------------------------
//
// Func:    CGeneralPage::DeleteAccessPoint
//
// Desc:    Handler for the delete Access Point button
//
// Args:    NONE 
//
// Return:  NONE
//
// Notes:   
//
// History: t-urama     07/31/2000  Created
//-----------------------------------------------------------------------------

void CGeneralPage::DeleteAccessPoint()
{
   
    // Now try to delete the key for the access point from the registry

    LPTSTR pszRegPath = BuildUserInfoSubKey(m_pArgs->szServiceName, m_pArgs->fAllUser);
        
    MYDBGASSERT(pszRegPath);

    if (NULL == pszRegPath)
    {
        return;
    }

    CmStrCatAlloc(&pszRegPath, TEXT("\\"));
    CmStrCatAlloc(&pszRegPath, c_pszRegKeyAccessPoints);
    CmStrCatAlloc(&pszRegPath, TEXT("\\"));

    MYDBGASSERT(pszRegPath);

    if (NULL == pszRegPath)
    {
        return;
    }

    CmStrCatAlloc(&pszRegPath, m_pArgs->pszCurrentAccessPoint);
    MYDBGASSERT(pszRegPath);

    if (NULL == pszRegPath)
    {
        return;
    }

    if (pszRegPath)
    {
        DWORD dwRes;
        HKEY hKeyCm;

        dwRes = RegOpenKeyExU(HKEY_CURRENT_USER,
                          pszRegPath,
                          0,
                          KEY_ALL_ACCESS,
                          &hKeyCm);

        if (ERROR_SUCCESS == dwRes)
        {
            RegCloseKey(hKeyCm);
            dwRes = RegDeleteKeyU(HKEY_CURRENT_USER, pszRegPath);

            if (ERROR_SUCCESS != dwRes)
            {
                CMTRACE1(TEXT("Delete AP failed, GLE=%d"), GetLastError());
            }
            else
            {
                CMTRACE1(TEXT("Deleted Access Point - %s"), m_pArgs->pszCurrentAccessPoint);
            }

             // First delete the Accesspoint from the combo box and load the new settings

            DWORD dwIdx = (DWORD)SendDlgItemMessageU(m_hWnd, IDC_GENERAL_ACCESSPOINT_COMBO, CB_GETCURSEL, 0, 0);
            
            if (CB_ERR != dwIdx)
            {
                if (0 == dwIdx)
                {
                    SendDlgItemMessageU(m_hWnd, IDC_GENERAL_ACCESSPOINT_COMBO, CB_SETCURSEL, dwIdx+1, 0);
                }
                else
                {
                    SendDlgItemMessageU(m_hWnd, IDC_GENERAL_ACCESSPOINT_COMBO, CB_SETCURSEL, dwIdx-1, 0);
                }
    
                if (ChangedAccessPoint(m_pArgs, m_hWnd, IDC_GENERAL_ACCESSPOINT_COMBO))
                {
                    UpdateForNewAccessPoint(TRUE);
                }

                SendDlgItemMessageU(m_hWnd, IDC_GENERAL_ACCESSPOINT_COMBO, CB_DELETESTRING, dwIdx, 0);
            }
            
            //
            // If the number of APs becomes 1, then make the AccessPointsEnabled Flag FAlSE
            //

            DWORD dwCnt = (DWORD)SendDlgItemMessageU(m_hWnd, IDC_GENERAL_ACCESSPOINT_COMBO, CB_GETCOUNT, 0, 0);
            if (dwCnt == 1) 
            {
               m_pArgs->fAccessPointsEnabled = FALSE;
               WriteUserInfoToReg(m_pArgs, UD_ID_ACCESSPOINTENABLED, (PVOID) &m_pArgs->fAccessPointsEnabled);
               WriteUserInfoToReg(m_pArgs, UD_ID_CURRENTACCESSPOINT, (PVOID) m_pArgs->pszCurrentAccessPoint);
            } 

        }

        CmFree(pszRegPath);
    }
}


//+----------------------------------------------------------------------------
//
// Function:  CNewAccessPointDlg::OnInitDialog
//
// Synopsis:  Virtual function. Call upon WM_INITDIALOG message to intialize
//            the dialog.
//
// Arguments: None
//
// Returns:   BOOL - Return value of WM_INITDIALOG
//
// History:   t-urama      created         08/02/00
//
//+----------------------------------------------------------------------------
BOOL CNewAccessPointDlg::OnInitDialog()
{   
   
    SetForegroundWindow(m_hWnd);

    //
    // Brand the dialog
    //

    LPTSTR pszTitle = CmStrCpyAlloc(m_pArgs->szServiceName);
    MYDBGASSERT(pszTitle);
    if (pszTitle)
    {
        SetWindowTextU(m_hWnd, pszTitle);
    }

    CmFree(pszTitle);
    if (m_pArgs->hSmallIcon)
    {
        SendMessageU(m_hWnd, WM_SETICON, ICON_SMALL, (LPARAM) m_pArgs->hSmallIcon); 
    }

    if (m_pArgs->hBigIcon)
    {        
        SendMessageU(m_hWnd, WM_SETICON, ICON_BIG, (LPARAM) m_pArgs->hBigIcon); 
        SendMessageU(GetDlgItem(m_hWnd, IDC_INET_ICON), STM_SETIMAGE, IMAGE_ICON, (LPARAM) m_pArgs->hBigIcon); 
    }

    UpdateFont(m_hWnd);
    
    EnableWindow(GetDlgItem(m_hWnd, IDOK), FALSE);
    
    HWND hwndEdit = GetDlgItem(m_hWnd, IDC_NEWAP_NAME_EDIT);
    
    if (hwndEdit)
    {
        //
        // Subclass the edit control
        //
        m_pfnOrgEditWndProc = (WNDPROC)SetWindowLongU(hwndEdit, GWLP_WNDPROC, (LONG_PTR)SubClassEditProc);

        //
        //  Set focus to the edit control
        //
        SetFocus(hwndEdit);

        //
        //  Limit the text length of the control
        //
        SendMessageU(hwndEdit, EM_SETLIMITTEXT, MAX_ACCESSPOINT_LENGTH, 0);
    }

    //
    // Must return FALSE when setting focus
    //

    return FALSE; 
 
}

//+----------------------------------------------------------------------------
//
// Function:  CNewAccessPointDlg::SubClassEditProc
//
// Synopsis:  Subclassed edit proc so that back slash chars can be prevented from
//            being entered into the new access point name edit control.
//
// Arguments: standard win32 window proc params
//
// Returns:   standard win32 window proc return value
//
// History:   quintinb      created         08/22/00
//
//+----------------------------------------------------------------------------
LRESULT CALLBACK CNewAccessPointDlg::SubClassEditProc(HWND hwnd, UINT uMsg, 
                                                      WPARAM wParam, LPARAM lParam)
{
    //
    // If user types a back slash character, Beep and do not accept that character
    //

    if ((uMsg == WM_CHAR)  && (VK_BACK != wParam))
    {
        if (TEXT('\\') == (TCHAR)wParam)
        {
            Beep(2000, 100);
            return 0;
        }
    }

    // 
    // Call the original window procedure for default processing. 
    //
    return CallWindowProcU(m_pfnOrgEditWndProc, hwnd, uMsg, wParam, lParam); 
}

//+----------------------------------------------------------------------------
//
// Function:  CNewAccessPointDlg::OnOK
//
// Synopsis:  Virtual function. Call when user hits the OK button
//
// Arguments: None
//
// Returns:   None
//
// History:   t-urama      created         08/02/00
//
//+----------------------------------------------------------------------------
void CNewAccessPointDlg::OnOK()
{
    LPTSTR pszNewAPName = CmGetWindowTextAlloc(m_hWnd, IDC_NEWAP_NAME_EDIT);
    MYDBGASSERT(pszNewAPName);

    if (pszNewAPName && TEXT('\0') != pszNewAPName[0])
    {
        if (m_ppszAPName)
        {
            CmFree(*m_ppszAPName);
            *m_ppszAPName = pszNewAPName;
        } 
        EndDialog(m_hWnd, TRUE);
    }
    else
    {
        CmFree(pszNewAPName);
    }
}

//+----------------------------------------------------------------------------
//
// Function:  CNewAccessPointDlg::OnOtherCommand
//
// Synopsis:  Virtual function. Enables the OK button once the user enters 
//            a name for the Access Point
//
// Arguments: None
//
// Returns:   None
//
// History:   t-urama      created         08/02/00
//
//+----------------------------------------------------------------------------
DWORD CNewAccessPointDlg::OnOtherCommand(WPARAM wParam, LPARAM)
{
    switch (LOWORD(wParam)) 
    {
        case IDC_NEWAP_NAME_EDIT:
        {
            HWND hwndEdit = GetDlgItem(m_hWnd, IDC_NEWAP_NAME_EDIT);
            if (hwndEdit)
            {
                size_t nLen = GetWindowTextLengthU(hwndEdit);
                HWND hwndOK = GetDlgItem(m_hWnd, IDOK);
                if (nLen > 0)
                {
                    EnableWindow(hwndOK, TRUE);
                }
                else
                {
                    EnableWindow(hwndOK, FALSE);
                }
            }
        }
        break;
   }
    return FALSE;
}

//+----------------------------------------------------------------------------
//
// Func:    CGeneralPage::AddNewAPToReg
//
// Desc:    Adds an AP under the Access Points key in the registry and also to the 
//          combo box
//
// Args:    LPTSTR pszNewAPName - New access point name to add
//          BOOL fRefreshUiWwithCurrentValues - overwrite the values currently in UI dlg boxes
//
// Return:  Nothing
//
// Notes:   
//
// History: t-urama     07/31/2000  Created
//-----------------------------------------------------------------------------
void CGeneralPage::AddNewAPToReg(LPTSTR pszNewAPName, BOOL fRefreshUiWwithCurrentValues)
{
    MYDBGASSERT(pszNewAPName);

    if (!pszNewAPName)
    {
        return;
    }

    LPTSTR pszNewAPNameTmp = CmStrCpyAlloc(pszNewAPName);
    

    DWORD dwIdx = (DWORD)SendDlgItemMessageU(m_hWnd,
                                   IDC_GENERAL_ACCESSPOINT_COMBO,
                                   CB_FINDSTRINGEXACT,
                                   0,
                                   (LPARAM)pszNewAPName);
    if (CB_ERR != dwIdx)
    {
        UINT iSuffix = 1;
        TCHAR szAPNameTemp[MAX_PATH + 10];  
        do
        {
            wsprintfU(szAPNameTemp, TEXT("%s%u"), pszNewAPNameTmp, iSuffix);
             
            dwIdx = (DWORD)SendDlgItemMessageU(m_hWnd,
                                       IDC_GENERAL_ACCESSPOINT_COMBO,
                                       CB_FINDSTRINGEXACT,
                                       0,
                                       (LPARAM)szAPNameTemp);
            iSuffix++;
        } while(dwIdx != CB_ERR);

        CmFree(pszNewAPNameTmp);
        pszNewAPNameTmp = CmStrCpyAlloc(szAPNameTemp);
    }

    MYDBGASSERT(pszNewAPNameTmp);
    if (pszNewAPNameTmp)
    {
    
        LPTSTR pszRegPath = BuildUserInfoSubKey(m_pArgs->szServiceName, m_pArgs->fAllUser);
        
        MYDBGASSERT(pszRegPath);

        if (NULL == pszRegPath)
        {
            return;
        }

        CmStrCatAlloc(&pszRegPath, TEXT("\\"));
        CmStrCatAlloc(&pszRegPath, c_pszRegKeyAccessPoints);
        CmStrCatAlloc(&pszRegPath, TEXT("\\"));

        MYDBGASSERT(pszRegPath);

        if (NULL == pszRegPath)
        {
            return;
        }

        CmStrCatAlloc(&pszRegPath,pszNewAPNameTmp);
    
        MYDBGASSERT(pszRegPath);

        if (NULL == pszRegPath)
        {
            return;
        }

        if (pszRegPath)
        {
            DWORD dwRes;
            HKEY hKeyCm;
            DWORD dwDisposition;
        
        
            dwRes = RegCreateKeyExU(HKEY_CURRENT_USER,
                                    pszRegPath,
                                    0,
                                    TEXT(""),
                                    REG_OPTION_NON_VOLATILE,
                                    KEY_ALL_ACCESS,
                                    NULL,
                                    &hKeyCm,
                                    &dwDisposition);
            if (ERROR_SUCCESS == dwRes)
            {
            
               dwRes = (DWORD)SendDlgItemMessageU(m_hWnd, IDC_GENERAL_ACCESSPOINT_COMBO, CB_ADDSTRING,
                                                0, (LPARAM)pszNewAPNameTmp);
               if (CB_ERR != dwRes)
               {
                   CMTRACE1(TEXT("Added new Access point - %s"), pszNewAPNameTmp);
                   SendDlgItemMessageU(m_hWnd, IDC_GENERAL_ACCESSPOINT_COMBO, CB_SETCURSEL, (WPARAM)dwRes, 0L);
                   if (ChangedAccessPoint(m_pArgs, m_hWnd, IDC_GENERAL_ACCESSPOINT_COMBO))
                   {
                       this->UpdateForNewAccessPoint(fRefreshUiWwithCurrentValues);
                   }

                   //
                   // if access points are enabled for the first time, make the AccessPointsEnabled flag TRUE
                   //

                   if (!m_pArgs->fAccessPointsEnabled)
                   {
                       m_pArgs->fAccessPointsEnabled = TRUE;
                       WriteUserInfoToReg(m_pArgs, UD_ID_ACCESSPOINTENABLED, (PVOID) &m_pArgs->fAccessPointsEnabled);
                   }
               }
               RegCloseKey(hKeyCm);
            }
        }
        CmFree(pszRegPath);
    }
   
    CmFree(pszNewAPNameTmp);
    
}

//
// Help id pairs
//
const DWORD CVpnPage::m_dwHelp[] = {
        IDC_VPN_SEL_COMBO,            IDH_VPN_SELECTOR,
        0,0};


//+----------------------------------------------------------------------------
//
// Func:    CVpnPage::CVpnPage
//
// Desc:    Constructor for the CVpnPage class.
//
// Args:    ArgsStruct* pArgs - pointer to the Args structure
//          UINT nIDTemplate - template ID of the VPN page, passed to its parent
//
// Return:  Nothing
//
// Notes:   
//
// History: quintinb     11/01/2000  Created
//-----------------------------------------------------------------------------
CVpnPage::CVpnPage(ArgsStruct* pArgs, UINT nIDTemplate)
    : CPropertiesPage(nIDTemplate, m_dwHelp, pArgs->pszHelpFile)
{
    MYDBGASSERT(pArgs);
    m_pArgs = pArgs;
}

//+----------------------------------------------------------------------------
//
// Func:    CVpnPage::OnInitDialog
//
// Desc:    Handles the WM_INITDLG processing for the VPN page of the CM
//          property sheet.  Basically fills the VPN message text, fills the
//          VPN selector combo and selects an item in the list as necessary.
//
// Args:    None
//
// Return:  BOOL - TRUE if it initialized successfully.
//
// Notes:   
//
// History: quintinb     11/01/2000  Created
//-----------------------------------------------------------------------------
BOOL CVpnPage::OnInitDialog()
{
    if (m_pArgs->pszVpnFile)
    {
        //
        //  Add the VPN friendly names to the combo  
        //
        AddAllKeysInCurrentSectionToCombo(m_hWnd, IDC_VPN_SEL_COMBO, c_pszCmSectionVpnServers, m_pArgs->pszVpnFile);
        
        //
        //  Now we need to select a friendly name in the combo box if the user has already selected something or
        //  if the user has yet to select something but their Admin specified a default.
        //
        LPTSTR pszDefault = m_pArgs->piniBothNonFav->GPPS(c_pszCmSection, c_pszCmEntryTunnelDesc);

        if ((NULL == pszDefault) || (TEXT('\0') == pszDefault[0]))
        {
            CmFree(pszDefault);
            pszDefault = GetPrivateProfileStringWithAlloc(c_pszCmSectionSettings, c_pszCmEntryVpnDefault, TEXT(""), m_pArgs->pszVpnFile);
        }

        if (pszDefault && pszDefault[0])
        {
            LONG_PTR lPtr = SendDlgItemMessageU(m_hWnd, IDC_VPN_SEL_COMBO, CB_FINDSTRINGEXACT, (WPARAM)-1, (LPARAM)pszDefault);
        
            if (CB_ERR != lPtr)
            {
                SendDlgItemMessageU(m_hWnd, IDC_VPN_SEL_COMBO, CB_SETCURSEL, (WPARAM)lPtr, (LPARAM)0);
            }
        }        

        CmFree(pszDefault);

        //
        //  If the Admin specified a message, let's read that and set the static text control
        //
        LPTSTR pszMessage = GetPrivateProfileStringWithAlloc(c_pszCmSectionSettings, c_pszCmEntryVpnMessage, TEXT(""), m_pArgs->pszVpnFile);

        if (pszMessage && pszMessage[0])
        {
            SendDlgItemMessageU(m_hWnd, IDC_VPN_MSG, WM_SETTEXT, (WPARAM)0, (LPARAM)pszMessage);
        }

        CmFree(pszMessage);
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Func:    CVpnPage::OnApply
//
// Desc:    Called when the user hits the OK button for the CM property sheet.
//          Handles saving the VPN server address and DUN setting name.
//
// Args:    None
//
// Return:  Nothing
//
// Notes:   
//
// History: quintinb     11/01/2000  Created
//-----------------------------------------------------------------------------
void CVpnPage::OnApply()
{
    //
    //  Okay, let's figure out what the user selected in the combo
    //
    LONG_PTR lPtr = SendDlgItemMessageU(m_hWnd, IDC_VPN_SEL_COMBO, CB_GETCURSEL, (WPARAM)0, (LPARAM)0);

    if (CB_ERR != lPtr)
    {
        LONG_PTR lTextLen = SendDlgItemMessageU(m_hWnd, IDC_VPN_SEL_COMBO, CB_GETLBTEXTLEN, (WPARAM)lPtr, (LPARAM)0);

        if (CB_ERR != lTextLen)
        {
            LPTSTR pszFriendlyName = (LPTSTR)CmMalloc(sizeof(TCHAR)*(lTextLen+1));

            if (pszFriendlyName)
            {                
                lPtr = SendDlgItemMessageU(m_hWnd, IDC_VPN_SEL_COMBO, CB_GETLBTEXT, (WPARAM)lPtr, (LPARAM)pszFriendlyName);

                if (CB_ERR != lPtr)
                {
                    //
                    //  Write the friendly name as the TunnelDesc
                    //
                    m_pArgs->piniBothNonFav->WPPS(c_pszCmSection, c_pszCmEntryTunnelDesc, pszFriendlyName);

                    //
                    //  Now get the actual data and write it
                    //
                    LPTSTR pszVpnAddress = GetPrivateProfileStringWithAlloc(c_pszCmSectionVpnServers, pszFriendlyName, TEXT(""), m_pArgs->pszVpnFile);

                    //
                    //  Now parse the line into the server name/IP and the DUN name if it exists.
                    //
                    if (pszVpnAddress)
                    {
                        LPTSTR pszVpnSetting = CmStrchr(pszVpnAddress, TEXT(','));

                        if (pszVpnSetting)
                        {
                            *pszVpnSetting = TEXT('\0');
                            pszVpnSetting++;
                            CmStrTrim(pszVpnSetting);
                        } // else it is NULL and we want to clear the existing key if it exists.

                        m_pArgs->piniBothNonFav->WPPS(c_pszCmSection, c_pszCmEntryTunnelDun, pszVpnSetting);

                        CmStrTrim(pszVpnAddress);
                        m_pArgs->piniBothNonFav->WPPS(c_pszCmSection, c_pszCmEntryTunnelAddress, pszVpnAddress);
                    }
                    else
                    {
                        CMASSERTMSG(FALSE, TEXT("CVpnPage::OnApply -- GetPrivateProfileStringWithAlloc failed for pszVpnAddress"));
                    }

                    CmFree(pszVpnAddress);
                }
            }
            else
            {
                CMASSERTMSG(FALSE, TEXT("CVpnPage::OnApply -- CmMalloc failed for pszFriendlyName"));
            }

            CmFree(pszFriendlyName);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmdial\dialogs.h ===
//+----------------------------------------------------------------------------
//
// File:     dialogs.h     
//
// Module:   CMDIAL32.DLL
//
// Synopsis: This header contains definitions for the dialog UI code.
//
// Copyright (c) 1996-1999 Microsoft Corporation
//
// Author:   quintinb   Created Header      08/17/99
//
//+----------------------------------------------------------------------------
#include "cm_misc.h"
#include "ModalDlg.h"

//+---------------------------------------------------------------------------
//
//  class CInetSignInDlg
//
//  Description: The standalone "Internet Sign-In" dlg
//
//  History:    fengsun Created     10/30/97
//
//----------------------------------------------------------------------------


class CInetSignInDlg : public CModalDlg
{
public:
    CInetSignInDlg(ArgsStruct * pArgs);

    virtual void OnOK();
    virtual BOOL OnInitDialog();
    virtual DWORD OnOtherCommand(WPARAM wParam, LPARAM lParam );

protected:
    ArgsStruct  *m_pArgs;   // pointer to the huge structure
    static const DWORD m_dwHelp[]; // help id pairs
};

inline CInetSignInDlg::CInetSignInDlg(ArgsStruct * pArgs) : CModalDlg(m_dwHelp, pArgs->pszHelpFile)
{
    MYDBGASSERT(pArgs);
    m_pArgs = pArgs;
}

//+---------------------------------------------------------------------------
//
//  class CPropertiesPage
//
//  Description: A general properties property page class
//
//  History:    fengsun Created     10/30/97
//
//----------------------------------------------------------------------------

class CPropertiesPage : public CWindowWithHelp
{
    friend class CPropertiesSheet;

public:
    CPropertiesPage(UINT nIDTemplate, const DWORD* pHelpPairs = NULL, 
            const TCHAR* lpszHelpFile = NULL); 
    CPropertiesPage(LPCTSTR lpszTemplateName, const DWORD* pHelpPairs = NULL, 
            const TCHAR* lpszHelpFile = NULL); 

    virtual BOOL OnInitDialog();    // WM_INITDIALOG
    virtual DWORD OnCommand(WPARAM wParam, LPARAM lParam ); // WM_COMMAND

    virtual BOOL OnSetActive();     // PSN_SETACTIVE
    virtual BOOL OnKillActive();    // PSN_KILLACTIVE
    virtual void OnApply();         // PSN_APPLY
    virtual void OnReset();         // PSN_RESET

    // If the derived class need to overwrite thses help function, make this virtual
    void OnPsnHelp(HWND hwndFrom, UINT_PTR idFrom); // PSN_HELP

    virtual DWORD OnOtherMessage(UINT uMsg, WPARAM wParam, LPARAM lParam );

protected:
    LPCTSTR m_pszTemplate;  // the resource ID

protected:
    void SetPropSheetResult(DWORD dwResult);
    static INT_PTR CALLBACK PropPageProc(HWND hwndDlg,UINT uMsg,WPARAM wParam, LPARAM lParam);
};

//+---------------------------------------------------------------------------
//
//  class CPropertiesSheet
//
//  Description: The properties property page class
//
//  History:    fengsun Created     10/30/97
//
//----------------------------------------------------------------------------
class CPropertiesSheet
{
public:
    CPropertiesSheet(ArgsStruct  *pArgs);
    void AddPage(const CPropertiesPage* pPage);
    void AddExternalPage(PROPSHEETPAGE *pPsp);
    BOOL HasPage(const CPropertiesPage* pPage) const;
    int DoPropertySheet(HWND hWndParent, LPTSTR pszCaption,  HINSTANCE hInst);

protected:
    enum {MAX_PAGES = 6};
    enum {CPROP_SHEET_TYPE_INTERNAL = 0, 
        CPROP_SHEET_TYPE_EXTERNAL = 1};
    PROPSHEETHEADER m_psh;  // propertysheet header
    PROPSHEETPAGE m_pages[MAX_PAGES]; // property pages array
    DWORD m_adwPageType[MAX_PAGES]; // property page type
    UINT m_numPages;        // number of property pages
    ArgsStruct  *m_pArgs;

public:
    TCHAR* m_lpszServiceName;  // the profile name, used as the mutex name for OK

protected:
    static LRESULT CALLBACK SubClassPropSheetProc(HWND hwnd, UINT uMsg, WPARAM wParam,LPARAM lParam);
    static int CALLBACK PropSheetProc(HWND hwndDlg, UINT uMsg, LPARAM lParam);
    static WNDPROC m_pfnOrgPropSheetProc; // Original propertysheet wnd proc before subclass

    // pointer to the property sheet which can be accessed by static function.
    // Not works quite safe, if there are multiple instance of CPropertySheet.
    // Should be protected by CriticalSection.
    static CPropertiesSheet* m_pThis;  
};

//
// Inline functions
//

inline CPropertiesSheet::CPropertiesSheet(ArgsStruct  *pArgs)
{
    m_pArgs = pArgs;
    MYDBGASSERT(m_pArgs);
    m_numPages = 0;
    ZeroMemory((LPVOID)m_adwPageType, sizeof(m_adwPageType));
}

inline void CPropertiesPage::SetPropSheetResult(DWORD dwResult)
{
    SetWindowLongU(m_hWnd, DWLP_MSGRESULT, (LONG_PTR)dwResult);
}

class CInetPage;
//+---------------------------------------------------------------------------
//
//  class CGeneralPage
//
//  Description: A dialing property page class
//
//  History:    fengsun Created     10/30/97
//
//----------------------------------------------------------------------------
class CGeneralPage :public CPropertiesPage
{
public:
    CGeneralPage(ArgsStruct* pArgs, UINT nIDTemplate);
    void SetEventListener(CInetPage* pEventListener) {m_pEventListener = pEventListener;}

protected:
    virtual BOOL OnInitDialog();
    virtual DWORD OnCommand(WPARAM wParam, LPARAM lParam );
    virtual void OnApply();
    virtual BOOL OnKillActive();    // PSN_KILLACTIVE

    void OnDialingProperties();
    void OnPhoneBookButton(UINT nPhoneIdx);
    BOOL DisplayMungedPhone(UINT uiPhoneIdx);
    BOOL CheckTapi(TapiLinkageStruct *ptlsTapiLink, HINSTANCE hInst);
    DWORD InitDialInfo();
    void EnableDialupControls(BOOL fEnable);
    void ClearUseDialingRules(int iPhoneNdx);
    void UpdateDialingRulesButton(void);
    void UpdateNumberDescription(int nPhoneIdx, LPCTSTR pszDesc);
    
    //
    //  Access Points
    //
    void UpdateForNewAccessPoint(BOOL fSetPhoneNumberDescriptions);
    BOOL AccessPointInfoChanged();
    void DeleteAccessPoint();
    void AddNewAPToReg(LPTSTR pszNewAPName, BOOL fRefreshUiWwithCurrentValues);
    
    virtual DWORD OnOtherMessage(UINT uMsg, WPARAM wParam, LPARAM lParam );
    enum {WM_INITDIALINFO = WM_USER+1}; // message posted to itself to load dial info

protected:
    ArgsStruct* m_pArgs;    // pointer to the huge structure
    PHONEINFO   m_DialInfo[MAX_PHONE_NUMBERS]; // local copy of dial info, 

    UINT        m_NumPhones;    // Number of phone # to display (1 for connectoid dialing)
    TCHAR       m_szDeviceName[RAS_MaxDeviceName+1];  // modem device name
    TCHAR       m_szDeviceType[RAS_MaxDeviceName+1];  // device type
    CInetPage*  m_pEventListener;           // the object to receive event on this page
    BOOL        m_bDialInfoInit; // whether we have loaded dialing information

    static const DWORD m_dwHelp[]; // help id pairs

    BOOL        m_bAPInfoChanged; // whether Access point information has changed
    
protected:
    static LRESULT CALLBACK SubClassEditProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static WNDPROC m_pfnOrgEditWndProc;  // the original phone # edit window proc for subclassing
};

//+---------------------------------------------------------------------------
//
//  class CInetPage
//
//  Description: The internet sign-on property page class
//
//  History:    fengsun Created     10/30/97
//
//----------------------------------------------------------------------------
class CInetPage :public CPropertiesPage
{
public:
    CInetPage(ArgsStruct* pArgs, UINT nIDTemplate);
    void OnGeneralPageKillActive(BOOL fDirect);

    //
    // The following functions are shared with CInetSignInDlg,
    // For simplicity, we makes them static member function of class CInetPage
    // instead of having another class
    //
    static void OnInetInit(HWND hwndDlg, ArgsStruct *pArgs);
    static void OnInetOk(HWND hwndDlg, ArgsStruct  *pArgs);
    static void AdjustSavePasswordCheckBox(HWND hwndCheckBox, BOOL fEmptyPassword, 
                           BOOL fDialAutomatically, BOOL fPasswordOptional);

protected:
    virtual BOOL OnInitDialog();
    virtual DWORD OnCommand(WPARAM wParam, LPARAM lParam );
    virtual void OnApply();
    virtual BOOL OnSetActive();     // PSN_SETACTIVE

protected:
    ArgsStruct* m_pArgs;// pointer to the huge structure
    BOOL m_fDirect;     // the current connection type selection in General page
    BOOL m_fPasswordOptional; // whether the PasswordOptional flag is set in 
                              // the profile

    static const DWORD m_dwHelp[]; // help id pairs
};

//+---------------------------------------------------------------------------
//
//  class COptionPage
//
//  Description: The options property page class
//
//  History:    fengsun Created     10/30/97
//
//----------------------------------------------------------------------------
class COptionPage :public CPropertiesPage
{
public:
    COptionPage(ArgsStruct* pArgs, UINT nIDTemplate);

protected:
    virtual BOOL OnInitDialog();
    virtual DWORD OnCommand(WPARAM wParam, LPARAM lParam ); // WM_COMMAND
    virtual void OnApply();

    void  InitIdleTimeList(HWND hwndList, DWORD dwMinutes);
    DWORD GetIdleTimeList(HWND hwndList);
    BOOL ToggleLogging();

protected:
    ArgsStruct* m_pArgs; // pointer to the huge structure
    BOOL        m_fEnableLog;  // is logging enabled

    static const DWORD m_dwHelp[]; // help id pairs
    static const DWORD m_adwTimeConst[]; // = {0,1, 5, 10, 30, 1*60, 2*60, 4*60, 24*60};
    static const int m_nTimeConstElements;// = sizeof(adwTimeConst)/sizeof(adwTimeConst[0]);

};

//+---------------------------------------------------------------------------
//
//  class CVpnPage
//
//  Description: The VPN property page class
//
//  History:    quintinb Created     10/26/00
//
//----------------------------------------------------------------------------
class CVpnPage :public CPropertiesPage
{
public:
    CVpnPage(ArgsStruct* pArgs, UINT nIDTemplate);

protected:
    virtual BOOL OnInitDialog();
    virtual void OnApply();

protected:
    ArgsStruct* m_pArgs; // pointer to the huge structure

    static const DWORD m_dwHelp[]; // help id pairs
};

//+---------------------------------------------------------------------------
//
//  class CAboutPage
//
//  Description: The about property page class
//
//  History:    fengsun Created     10/30/97
//
//----------------------------------------------------------------------------
class CAboutPage :public CPropertiesPage
{
public:
    CAboutPage(ArgsStruct* pArgs, UINT nIDTemplate);

protected:
    virtual BOOL OnInitDialog();
    virtual BOOL OnSetActive(); 
    virtual BOOL OnKillActive(); 
    virtual void OnApply();
    virtual void OnReset(); 
    virtual DWORD OnOtherMessage(UINT uMsg, WPARAM wParam, LPARAM lParam );

protected:
    ArgsStruct  *m_pArgs;   // pointer to the huge structure
};


//+---------------------------------------------------------------------------
//
//  class CChangePasswordDlg
//
//  Description: The network change password dlg
//
//  History:    v-vijayb    Created   7/3/99
//
//----------------------------------------------------------------------------


class CChangePasswordDlg : public CModalDlg
{
public:
    CChangePasswordDlg(ArgsStruct *pArgs);

    virtual void OnOK();
    virtual void OnCancel();
    virtual BOOL OnInitDialog();
    virtual DWORD OnOtherCommand(WPARAM wParam, LPARAM lParam );

protected:
    ArgsStruct *m_pArgs;
};

inline CChangePasswordDlg::CChangePasswordDlg(ArgsStruct *pArgs) : CModalDlg()
{
    MYDBGASSERT(pArgs);
    m_pArgs = pArgs;
}

//+---------------------------------------------------------------------------
//
//  class CCallbackNumberDlg
//
//  Description: Emulation of the RAS Callback Number dialog
//
//  History:    nickball    Created   3/1/00
//
//----------------------------------------------------------------------------

class CCallbackNumberDlg : public CModalDlg
{
public:
    CCallbackNumberDlg(ArgsStruct *pArgs);

    virtual void OnOK();
    virtual void OnCancel();
    virtual BOOL OnInitDialog();
    virtual DWORD OnOtherCommand(WPARAM wParam, LPARAM lParam );

protected:
    ArgsStruct *m_pArgs;
};

inline CCallbackNumberDlg::CCallbackNumberDlg(ArgsStruct *pArgs) : CModalDlg()
{
    MYDBGASSERT(pArgs);
    m_pArgs = pArgs;
}

//+---------------------------------------------------------------------------
//
//  class CRetryAuthenticationDlg
//
//  Description: Emulation of the RAS Retry authentication dialog
//
//  History:    nickball    Created   3/1/00
//
//----------------------------------------------------------------------------

class CRetryAuthenticationDlg : public CModalDlg
{
public:
    CRetryAuthenticationDlg(ArgsStruct *pArgs); 

    virtual void OnOK();
    virtual void OnCancel();
    virtual BOOL OnInitDialog();
    virtual DWORD OnOtherCommand(WPARAM wParam, LPARAM lParam );
    virtual UINT GetDlgTemplate();

protected:
    ArgsStruct *m_pArgs;
    BOOL        m_fInetCredentials;
    static const DWORD m_dwHelp[]; // help id pairs
};


inline CRetryAuthenticationDlg::CRetryAuthenticationDlg(ArgsStruct *pArgs) 
       : CModalDlg(m_dwHelp, pArgs->pszHelpFile)
{
    MYDBGASSERT(pArgs);
    
    m_pArgs = pArgs;   

    if (m_pArgs)
    {
        //
        // If the phone number calls for a tunnel, and we're not using 
        // UseSameUserName and we're not actively dialing the tunnel,
        // then we must be dialing the Inet portion of the connection.
        //        
        
        m_fInetCredentials = (!m_pArgs->fUseSameUserName &&
                              !IsDialingTunnel(m_pArgs) && 
                              UseTunneling(m_pArgs, m_pArgs->nDialIdx));
    }
}

//+---------------------------------------------------------------------------
//
//	class CNewAccessPointDlg
//
//	Description: Dialog to get the name of a new Access Point from the user
//
//	History:	t-urama    Created   8/2/00
//
//----------------------------------------------------------------------------

class CNewAccessPointDlg : public CModalDlg
{
public:
    CNewAccessPointDlg(ArgsStruct *pArgs, LPTSTR *ppAPName);

    virtual void OnOK();
    virtual BOOL OnInitDialog();
    virtual DWORD OnOtherCommand(WPARAM wParam, LPARAM lParam );

protected:
	LPTSTR *m_ppszAPName;
	ArgsStruct *m_pArgs;
    static LRESULT CALLBACK SubClassEditProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static WNDPROC m_pfnOrgEditWndProc;  // the original edit control window proc for subclassing
    
};

inline CNewAccessPointDlg::CNewAccessPointDlg(ArgsStruct *pArgs, LPTSTR *ppszAPName) : CModalDlg()
{
    MYDBGASSERT(pArgs);
    
    m_pArgs = pArgs;   

    m_ppszAPName = ppszAPName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmdial\dial_str.h ===
//+----------------------------------------------------------------------------
//
// File:     dial_str.h     
//
// Module:   CMDIAL32.DLL
//
// Synopsis: Header file for CMS and .CMP flags used among various cmdial modules
//
// Copyright (c) 1998 Microsoft Corporation
//
// Author:   nickball Created    10/15/98
//
//+----------------------------------------------------------------------------

#ifndef _CM_DIAL_STR
#define _CM_DIAL_STR

const TCHAR* const c_pszCmEntryMaxUserName    = TEXT("MaxUserName");
const TCHAR* const c_pszCmEntryMaxPassword    = TEXT("MaxPassword");
const TCHAR* const c_pszCmEntryMaxDomain      = TEXT("MaxDomain");
const TCHAR* const c_pszCmEntryMaxPhoneNumber = TEXT("MaxPhoneNumber");

const TCHAR* const c_pszCmEntryRedialCount    = TEXT("RedialCount");
const TCHAR* const c_pszCmEntryPwdOptional    = TEXT("PasswordOptional");
const TCHAR* const c_pszCmEntryDialDevice     = TEXT("Modem");
const TCHAR* const c_pszCmEntryTunnelDevice   = TEXT("TunnelDevice");

const TCHAR* const c_pszCmEntryCallbackNumber = TEXT("CallbackNumber");
 
#endif // _CM_DIAL_STR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmdial\icm.h ===
//+----------------------------------------------------------------------------
//
// File:     icm.h
//
// Module:   CMDIAL32.DLL
//
// Synopsis: Main header file for cmdial32.dll
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   nickball Created    02/10/98
//
//+----------------------------------------------------------------------------
#ifndef _ICM_INC
#define _ICM_INC

#include <stddef.h>
#include <stdlib.h>
#include <limits.h>
#include <windows.h>
#include <windowsx.h>
#include <shlobj.h>
#include <stdio.h>
#include <errno.h>
#include <olectl.h>
#include <ctype.h>
#include <wininet.h>
#include <wchar.h>

// #undef WINVER
// #define WINVER        0x0401

#include <commctrl.h>
#include <ras.h>
#include <raserror.h>
#include <tapi.h>
#include <mbstring.h>
#include <wininet.h>
#include <rasdlg.h>
#include <olectl.h>
#include <ntsecapi.h>  // for LSA stuff

#include "cmglobal.h"
#include "cm_def.h"
#include "reg_str.h"
#include "cmmgr32.h" // help IDs
#include "cm_phbk.h"
#include "cmdial.h"
#include "cmutil.h"
#include "cm_misc.h"
#include "cmlog.h"
#include "state.h"
#include "cmsecure.h"
#include "cmdebug.h"
#include "contable.h"
#include "ary.hxx"
#include "ctr.h"
#include "resource.h"
#include "cmfmtstr.h"
#include "base_str.h"
#include "mgr_str.h" 
#include "ShellDll.h"
#include "mutex.h"
#include "cmras.h"
#include "userinfo.h"
#include "lanawait.h"
#include "linkdll.h" // LinkToDll and BindLinkage
#include "uapi.h"
#include "bmpimage.h" // Common bitmap processing code
#include "pwutil.h"
#include "stp_str.h"
#include "dial_str.h"
#include "mon_str.h"
#include "tooltip.h"
#include "gppswithalloc.h"
#include "hnetcfg.h"
#include "netconp.h"

#if DEBUG && defined(CMASSERTMSG)
#define CELEMS(x)   (                           \
                        CMASSERTMSG(sizeof(x) != sizeof(void*), TEXT("possible incorrect usage of CELEMS")), \
                        (sizeof(x))/(sizeof(x[0])) \
                    )
#else
#define CELEMS(x) ((sizeof(x))/(sizeof(x[0])))
#endif // DEBUG

// we haven't done the strsafe pass for the entire XPSP codebase - make sure we can still build
#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>


//************************************************************************
// define's
//************************************************************************

#define TIMER_RATE              1000        // 1 second
#define PAUSE_DELAY             3
#define PWHANDLE_NONE           0
#define PWHANDLE_LOWER          1
#define PWHANDLE_UPPER          2

#define CE_PASSWORD_NOT_PRESENT 1223

#define CUSTOM_BUTTON_WIDTH 88
//#define DEFAULT_MAX_DOMAIN_LENGTH   256

//
// User defined msg for telling CM itself to start loading startup info
//
#define WM_LOADSTARTUPINFO      (WM_USER + 6)

//
// Delayed hangup of CM for W9x
// wParam indicates if entry should be removed from table.
// lParam is the RAS error code for hangup or ERROR_CANCELLED (currently unused)

#define WM_HANGUP_CM            (WM_USER + 7)

//
// Connected CM - CM is connected, do connect processing
//

#define WM_CONNECTED_CM         (WM_USER + 8)

//
// Pause RasDial - Resume dialing after pause state.
//

#define WM_PAUSE_RASDIAL         (WM_USER + 9)

// Duration message flags

#define DMF_NUL 0x0000
#define DMF_H   0x0001  // Hours
#define DMF_M   0x0002  // Minutes
#define DMF_S   0x0004  // Seconds
#define DMF_HM  0x0003  // Hours, Minutes
#define DMF_HS  0x0005  // Hours, Seconds
#define DMF_MS  0x0006  // Minutes, Seconds
#define DMF_HMS 0x0007  // Hours, Minutes, Seconds

// for NT RasSetEntryProperties() 
#define SCRIPT_PATCH_BUFFER_SIZE    2048
#define SIZEOF_NULL 1

#define MIN_TAPI_VERSION        0x10003
#define MAX_TAPI_VERSION        0x10004

#define NElems(a)  (sizeof a / sizeof a[0])

#define INETCFG_INSTALLMODEM        0x00000002
#define INETCFG_INSTALLRNA          0x00000004
#define INETCFG_INSTALLTCP          0x00000008
#define INETCFG_SUPPRESSINSTALLUI   0x00000080
//
// Check to see if TCP is installed regardless of binding
//
#define INETCFG_INSTALLTCPONLY        0x00004000

//
// Components Checked flags
//
#define CC_RNA                      0x00000001  // RNA installed
#define CC_TCPIP                    0x00000002  // TCPIP installed
#define CC_MODEM                    0x00000004  // Modem installed
#define CC_PPTP                     0x00000008  // PPTP installed
#define CC_SCRIPTING                0x00000010  // Scripting installed
#define CC_RASRUNNING               0X00000020  // RAS services is running
                                                //  on NT
#define CC_CHECK_BINDINGS           0x00000040  // Check if PPP is bound to TCP

#define DT_CMMON                    0x00000001
#define DT_EXPLORER                 0x00000002
#define DT_CMMGR                    0x00000004
#define DT_CMSTP                    0x00000008
#define DT_RUNDLL32                 0x00000010
#define DT_RASAUTOU                 0x00000020
#define DT_USER                     (DT_CMMGR | DT_CMMON | DT_EXPLORER | DT_CMSTP | DT_RUNDLL32 | DT_RASAUTOU)

#define MAX_PHONE_NUMBERS       2

#define MAX_PHONE_LEN95         36 //Win 95 has 36 char phone limit
#define MAX_PHONE_LENNT         80 //NT has 80 char phone limit

//
// Country list limits and defines
//

#define DEF_COUNTRY_INFO_SIZE   1024
#define MAX_COUNTRY_NAME        36

#define DEFAULT_COUNTRY_CODE    1
#define DEFAULT_COUNTRY_ID      1 // US
//
// Default settings values
//

#define DEFAULT_IDLETIMEOUT    10    // # of minutes to wait before idle disconnect

#define DEFAULT_DIALEXTRAPERCENT        80   // see ArgsStruct dwDialExtraPercent
#define DEFAULT_DIALEXTRASAMPLESECONDS  30   // see ArgsStruct dwDialExtraSampleSeconds
#define DEFAULT_HANGUPEXTRAPERCENT        40   // see ArgsStruct dwHangupExtraPercent
#define DEFAULT_HANGUPEXTRASAMPLESECONDS  300   // see ArgsStruct dwHangupExtraSampleSeconds


#define DEFAULT_REDIAL_DELAY    5
#define DEFAULT_MAX_REDIALS     3

#define NT4_BUILD_NUMBER        1381

//
// isdn dial mode
//
#define CM_ISDN_MODE_SINGLECHANNEL          0
#define CM_ISDN_MODE_DUALCHANNEL_ONLY       1
#define CM_ISDN_MODE_DUALCHANNEL_FALLBACK   2

//
// len for the var lasterror string
//
#define MAX_LASTERR_LEN             128

//
// Flags for manipulating dialog template mask
//
#define CMTM_UID            0x00000001  // Username to be displayed
#define CMTM_PWD            0x00000002  // Password to be displayed
#define CMTM_DMN            0x00000004  // Domain to be displayed
#define CMTM_FAVS           0x00000008  // Favorite enbabled dialogs
#define CMTM_GCOPT          0x00000010  // Global Credential Options


#define CMTM_UID_AND_PWD    CMTM_UID | CMTM_PWD             // 0x00000003 // No domain displayed   
#define CMTM_UID_AND_DMN    CMTM_UID | CMTM_DMN             // 0x00000005 // No Password displayed 
#define CMTM_PWD_AND_DMN    CMTM_PWD | CMTM_DMN             // 0x00000006 // No Username displayed 
#define CMTM_U_P_D          CMTM_UID | CMTM_PWD | CMTM_DMN  // 0x00000007 // All userinfo displayed  

//
// Access point names should be no longer than 32 chars (not counting the NULL terminator)
//
#define MAX_ACCESSPOINT_LENGTH 32
#define ID_OK_RELAUNCH_MAIN_DLG 123174

//
// Balloon Tip Flags
//
#define BT_ACCESS_POINTS    0x00000001 // Access Point balloon tip has already been displayed

//
//  Connection Types
//
#define DIAL_UP_CONNECTION 0
#define DIRECT_CONNECTION 1
#define DOUBLE_DIAL_CONNECTION 2

class CConnStatistics;

//
//  Special-case some smart-card PIN errors
//
#define BAD_SCARD_PIN(x) ((SCARD_W_WRONG_CHV == (x)) || (SCARD_E_INVALID_CHV == (x)))


//************************************************************************
// structures, typdef's
//************************************************************************

//
// Function prototypes for entrypoints into RAS.  We will link to RAS using LoadLibary()/GetProcAddress(),
// so that we can be flexible concerning how we load (for example, if RAS is not installed on the machine,
// we can print a polite message, instead of just having Windows put up an ugly dialog about RASAPI32.DLL
// not being found.
//

#include "raslink.h"

//
// Function prototypes for entrypoints into TAPI.  We will link to TAPI using LoadLibary()/GetProcAddress(),
// so that we can be flexible concerning how we load (for example, if TAPI is not installed on the machine,
// we can print a polite message, instead of just having Windows put up an ugly dialog about TAPI32.DLL
// not being found.
//

typedef LONG (WINAPI *pfnTapilineInitialize)(LPHLINEAPP, HINSTANCE, LINECALLBACK, LPCTSTR, LPDWORD);
typedef LONG (WINAPI *pfnTapilineNegotiateAPIVersion)(HLINEAPP, DWORD, DWORD, DWORD, LPDWORD, LPLINEEXTENSIONID);
typedef LONG (WINAPI *pfnTapilineGetDevCaps)(HLINEAPP, DWORD, DWORD, DWORD, LPLINEDEVCAPS);
typedef LONG (WINAPI *pfnTapilineShutdown)(HLINEAPP);
typedef LONG (WINAPI *pfnTapilineTranslateAddress)(HLINEAPP, DWORD, DWORD, LPCTSTR, DWORD, DWORD, LPLINETRANSLATEOUTPUT);
typedef LONG (WINAPI *pfnTapilineTranslateDialog)(HLINEAPP, DWORD, DWORD, HWND, LPCTSTR);
typedef LONG (WINAPI *pfnTapilineGetDevConfig)(DWORD, LPVARSTRING, LPCSTR);

//typedef LONG (WINAPI *pfnTapilineGetID)(HLINE, DWORD, HCALL, DWORD, LPVARSTRING, LPCTSTR);
//typedef LONG (WINAPI *pfnTapitapiGetLocationInfo)(LPCTSTR, LPCTSTR);

typedef LONG (WINAPI *pfnTapilineGetTranslateCaps)(HLINEAPP, DWORD, LPLINETRANSLATECAPS);
typedef LONG (WINAPI *pfnTapilineSetCurrentLocation)(HLINEAPP, DWORD);

//
// function prototypes for LSA stuff.
//
typedef NTSTATUS (NTAPI *pfnLsaOpenPolicy)(PLSA_UNICODE_STRING, PLSA_OBJECT_ATTRIBUTES, ACCESS_MASK, PLSA_HANDLE);
typedef NTSTATUS (NTAPI *pfnLsaRetrievePrivateData)(LSA_HANDLE, PLSA_UNICODE_STRING, PLSA_UNICODE_STRING *);
typedef NTSTATUS (NTAPI *pfnLsaStorePrivateData)(LSA_HANDLE, PLSA_UNICODE_STRING, PLSA_UNICODE_STRING);
typedef ULONG    (NTAPI *pfnLsaNtStatusToWinError)(NTSTATUS);
typedef NTSTATUS (NTAPI *pfnLsaClose)(LSA_HANDLE);
typedef NTSTATUS (NTAPI *pfnLsaFreeMemory)(PVOID);

//
//  Connect Action Function Prototype
//
typedef DWORD (WINAPI *pfnCmConnectActionFunc)(HWND, HINSTANCE, LPCSTR, int);

//
// Structure used to describe the linkage to TAPI.  NOTE:  Changes to this structure
// will probably require changes to LinkToTapi() and UnlinkFromTapi().
//
typedef struct _TapiLinkageStruct {
    HINSTANCE hInstTapi;
    union {
        struct {
            pfnTapilineInitialize pfnlineInitialize;
            pfnTapilineNegotiateAPIVersion pfnlineNegotiateAPIVersion;
            pfnTapilineGetDevCaps pfnlineGetDevCaps;
            pfnTapilineGetDevConfig pfnlineGetDevConfig;
            pfnTapilineShutdown pfnlineShutdown;
            pfnTapilineTranslateAddress pfnlineTranslateAddress;
//          pfnTapitapiGetLocationInfo pfntapiGetLocationInfo;
            pfnTapilineTranslateDialog pfnlineTranslateDialog;
//          pfnTapilineGetID pfnlineGetID;
            pfnTapilineGetTranslateCaps pfnlineGetTranslateCaps;
            pfnTapilineSetCurrentLocation pfnlineSetCurrentLocation;
        };
        void *apvPfnTapi[10];   // see comment for RasLinkageStruct for 10.
    };
    HLINEAPP hlaLine;
    DWORD dwDevCnt;
    BOOL bOpen;
    BOOL bDevicePicked;
    TCHAR szDeviceName[RAS_MaxDeviceName + 1];
    DWORD dwDeviceId;
    DWORD dwApiVersion;
    BOOL bModemSpeakerOff;
    DWORD dwTapiLocationForAccessPoint;   // Tapi location for current access point
    DWORD dwOldTapiLocation;        // Tapi location when CM is started, restored when CM exits
} TapiLinkageStruct;


typedef struct _LsaLinkageStruct {
    HINSTANCE hInstLsa;
    union {
        struct {
            pfnLsaOpenPolicy            pfnOpenPolicy;
            pfnLsaRetrievePrivateData   pfnRetrievePrivateData;
            pfnLsaStorePrivateData      pfnStorePrivateData;
            pfnLsaNtStatusToWinError    pfnNtStatusToWinError;
            pfnLsaClose                 pfnClose;
            pfnLsaFreeMemory            pfnFreeMemory;
        };
        void *apvPfnLsa[7];  
    };
} LsaLinkageStruct;

#define PHONE_DESC_LEN  80
#define PB_MAX_SERVICE  256
#define PB_MAX_REGION   256

//
// Phone Info Flags
//

#define PIF_USE_DIALING_RULES       0x00000001

typedef struct _PHONEINFO
{
    DWORD dwCountryID;
    TCHAR szPhoneNumber[RAS_MaxPhoneNumber+1];
    TCHAR szCanonical[RAS_MaxPhoneNumber+1];
    TCHAR szDUN[MAX_PATH+1];
    TCHAR szPhoneBookFile[MAX_PATH+1];      // the service file associate with the phone #
    TCHAR szDialablePhoneNumber[RAS_MaxPhoneNumber+1];
    TCHAR szDisplayablePhoneNumber[RAS_MaxPhoneNumber+1];
    TCHAR szDesc[PHONE_DESC_LEN];
    DWORD dwPhoneInfoFlags;

    //
    // The following 2 vars are set by the phone book dlg(OnGeneralPhoneChange).
    // We need to save them and then write them out when the user clicks OK.
    //
    TCHAR       szServiceType[PB_MAX_SERVICE];
    TCHAR       szRegionName[PB_MAX_REGION];

} PHONEINFO, *PPHONEINFO;

//
// Structure for all of the program's data.  Basically, the program doesn't have any
// global variables - everything is stored in this structure.
//
typedef struct _ArgsStruct 
{
public:
    LPICMOCCtr   pCtr;                          // OC ctr for FS OC
    UINT uMsgId;                                // message ID used for driving the dialing state machine
    DWORD dwFlags;                              // any flags from the command line  -- see IniArgs
    RasLinkageStruct rlsRasLink;                // linkade to RAS
    HRASCONN hrcRasConn;                        // the handle of the RAS connection
    TapiLinkageStruct tlsTapiLink;              // linkage to TAPI
    LsaLinkageStruct llsLsaLink;                // linkage to LSA
    BOOL fIgnoreChangeNotification;             // TRUE if EN_CHANGE messages should be ignored
    TCHAR szLastErrorSrc[MAX_LASTERR_LEN];      // the source of last err(either RAS or a connect action name)
    TCHAR szDeviceName[RAS_MaxDeviceName+1];    // device being used
    TCHAR szDeviceType[RAS_MaxDeviceName+1];    // device type of the device being used
    TCHAR szUserName[UNLEN+1];                  // username for corp account
    TCHAR szPassword[PWLEN+1];                  // password for corp account
    TCHAR szDomain[DNLEN+1];                    // domain for corp account
    TCHAR szConnectoid[RAS_MaxEntryName];       // connectoid name
    TCHAR szServiceName[RAS_MaxEntryName];      // top-level long service name
    // added for tunneling
    HRASCONN hrcTunnelConn;                 // the handle of the tunnel connection
    TCHAR szTunnelDeviceType[RAS_MaxDeviceType+1]; // device type
    TCHAR szTunnelDeviceName[RAS_MaxDeviceName+1]; // device being used for tunneling
    TCHAR szInetUserName[UNLEN+1];              // username for internet(isp)
    TCHAR szInetPassword[PWLEN+1];              // password for internet(isp)
    BOOL  fUseSameUserName;                     // TRUE if will use the same password for dialup
    BOOL  fHideDialAutomatically;               // don't show 'dial automatically..." checkbox
    BOOL  fHideRememberPassword;                // don't show 'remember password" checkbox
    BOOL  fHideRememberInetPassword;            // don't show 'remember Internet password" checkbox
    BOOL  fDialAutomatically;                   // dial automatically upon start?
    BOOL  fRememberInetPassword;                // remember the internet password
    BOOL  fRememberMainPassword;                // remember the password in the main dialog box
    BOOL  fHideUserName;                        // Hide the username on the main logon tab
    BOOL  fHidePassword;                        // Hide the password on the main logon tab
    BOOL  fHideDomain;                          // Hide the domain on the main logon tab
    BOOL  fHideInetUsername;                    // Hide the username on the Inet logon tab
    BOOL  fHideInetPassword;                    // Hide the password on the Inet logon tab
    BOOL  fTunnelPrimary;                       // if TRUE, we'll tunnel only if the user selects a phone #
                                                //     from the pbk associated with the primary service profile
    BOOL  fTunnelReferences;                    // if TRUE, we'll tunnel only if the user selects a phone #     
                                                //     from the pbk associated with the referenced service profile 
    BOOL  fUseTunneling;                        // TRUE if use tunneling for dial-up networking(it is NOT the same 
                                                //     as (fTunnel|fTunnelReferences)!!!  It's determined by 
                                                //     looking at the above 3 flags plus more.
    BOOL bUseRasCredStore;                      // TRUE if this profile uses RasSetCredentials and RasGetCredentials
                                                // to store creds on win2k+.  Will be FALSE on legacy platforms
    BOOL bShowHNetCfgAdvancedTab;               // displays the ICF & ICS (Advanced) tab
                                                //      Internet Connection Sharing & Internet Connection Firewall tab
                                                //      TRUE by default
    DWORD dwSCardErr;                           // special case handling for SmartCard errors

    LPTSTR GetProperty(const TCHAR* pszName, BOOL *pbValidPropertyName);   // get the cm property by name
    DWORD GetTypeOfConnection();                // is the connection dialup, direct, or double dial?
protected:
    //
    // Encapsulate the tunnel address
    //

    // IP(or DNS name) in the profile for tunnel server
    TCHAR szPrimaryTunnelIP[RAS_MaxPhoneNumber+1];

public:

    const TCHAR* GetTunnelAddress()
        {return szPrimaryTunnelIP;}

    void SetPrimaryTunnel(LPCTSTR pszTunnelIP)
        {lstrcpynU(szPrimaryTunnelIP, pszTunnelIP, sizeof(szPrimaryTunnelIP)/sizeof(TCHAR));}       

public:
    UINT_PTR nTimerId;                          // ID of the timer
    ProgState psState;                                                      // the program's state
    DWORD dwStateStartTime;                     // the time that the state started
    UINT nRedialDelay;                          // the number of seconds to wait between redial attempts
    UINT nMaxRedials;                           // the maximum number of times to redial
    UINT nRedialCnt;                            // number of re-dial attempts remaining
    UINT nLastSecondsDisplay;                   // the last seconds count which was displayed
    UINT nDialIdx;                              // zero-based index of current phone number
    PHONEINFO aDialInfo[MAX_PHONE_NUMBERS]; // actual phone number that's to be dialed
    CIni *piniProfile;
    CIni *piniService;
    CIni *piniBoth;
    CIni *piniBothNonFav;
    LPTSTR pszHelpFile;                         // file name of help file
    BMPDATA BmpData;                            // bitmap handles for main sign-in dialog
    HPALETTE hMasterPalette;                    // the current palette for the app
    HICON hBigIcon;                             // icon for Alt-Tab task bar
    HICON hSmallIcon;                           // icon for main title bar and task bar
    DWORD dwExitCode;
    DWORD dwIdleTimeout;                        // Idle time out in minutes, 0 means never time out
    HWND hwndResetPasswdButton;
    HWND hwndTT;                // tooltip
    HANDLE  *phWatchProcesses;
    LPTSTR  pszResetPasswdExe;
    LPTSTR pszCurrentAccessPoint;               // String to store the current access point
    BOOL fAccessPointsEnabled;                  // Are Access Points enabled?
    DWORD dwOldTapiLocation;                    // tapi location when CM is started
    BOOL fHideBalloonTips;                   // Are Balloon Tips enabled?
    CBalloonTip *pBalloonTip;                   // pointer to the Balloon tip class

    // for references
    BOOL    fHasRefs;
    BOOL    fHasValidTopLevelPBK;
    BOOL    fHasValidReferencedPBKs;

    //
    // for IdleThreshold  -- byao 5/30/97
    //

    CConnStatistics  *pConnStatistics;
    CConnectionTable *pConnTable;

    // idle threshold value
        
    BOOL    fCheckOSComponents;         // should we check OS components?
    BOOL    bDoNotCheckBindings;        // Check if TCP is bound to PPP?
    Ole32LinkageStruct olsOle32Link;    // links to Ole32 DLL for future splashing
    BOOL    fFastEncryption;            // Whether we want a faster encryption or a more secure one
    DWORD   bDialInfoLoaded;            // Whether the dial info is loaded
    BOOL    fStartupInfoLoaded;         // have we loaded Startup info? (OnMainLoadStartupInfo())
    BOOL    fNeedConfigureTapi;         // need to configure TAPI location info
    BOOL    fIgnoreTimerRasMsg;         // Whether to ignore WM_TIMER and RAS messages
    BOOL    fInFastUserSwitch;          // Are we in the process of doing a fast user switch (FUS)
    CShellDll m_ShellDll;                // The link to Shell dll

public:
    BOOL   IsDirectConnect() const;
    void   SetDirectConnect(BOOL fDirect) ; // set the connection type direct or dial-up
    BOOL   IsBothConnTypeSupported() const;
    void   SetBothConnTypeSupported(BOOL fBoth);

protected:
    BOOL    m_fBothConnTypeSupported;     // Whether the profile support both direct connect an dial-up
    BOOL    m_fDirectConnect;             // Whether the current configuration is using direct connection
public:
    LPTSTR  pszRasPbk;                  // Ras phonebook path
    LPTSTR  pszRasHiddenPbk;            // Hidden Ras phonebook path for dial-up portion of wholesale dial
    LPTSTR  pszVpnFile;
    //
    // ISDN dual channel support(dial all initially, dial on demand)
    //
    // Dial-on-demand:
    // CM dials an additional channel when the total bandwidth used exceeds 
    // dwDialExtraPercent percent of the available bandwidth for at least 
    // dwDialExtraSampleSeconds seconds. 
    //
    BOOL    dwIsdnDialMode;             // see CM_ISDN_MODE*
    DWORD   dwDialExtraPercent;         // used when dialmode = dialasneeded
    DWORD   dwDialExtraSampleSeconds;   // used when dialmode = dialasneeded
    DWORD   dwHangUpExtraPercent;       // used when dialmode = dialasneeded
    DWORD   dwHangUpExtraSampleSeconds; // used when dialmode = dialasneeded
    BOOL    fInitSecureCalled;          // whether InitSecure() is called for password Encryption

    //
    // pucDnsTunnelIpAddr_list:
    //      the h_addr_list of a HOSTENT - a list of ip addrs obtained by resolving the
    //      tunnel server DNS name.
    // uiCurrentTunnelAddr
    //      the index for h_TunnelIpAddr_list.  Points to the currently used ip addr address.
    // rgwRandomDnsIndex
    //      an array of random index to index into the tunnel addr list
    //
    unsigned char   *pucDnsTunnelIpAddr_list;
    UINT    uiCurrentDnsTunnelAddr;
    DWORD   dwDnsTunnelAddrCount;
    PWORD   rgwRandomDnsIndex;
    BOOL    fAllUser;
    UINT    uLanaMsgId; // Window handle of Lana window if any    
    LPRASDIALPARAMS pRasDialParams;
    LPRASDIALEXTENSIONS pRasDialExtensions;
    DWORD dwRasSubEntry;
    HWND hwndMainDlg;
    BOOL fNoDialingRules;
    LPRASNOUSER lpRasNoUser;        
    PEAPLOGONINFO lpEapLogonInfo;  
    //
    // Note: RAS will pass either a LPRASNOUSER or LPEAPLOGONINFO ptr through the 
    // RasCustomDialDlg interface when calling CM from WinLogon. RAS will 
    // differentiate them by the RCD_Eap flag, which will be set if the 
    // LPEAPLOGONINFO is passed. When not running in WinLogon, neither 
    // will be sent. 
    //
    BOOL  fChangedPassword;                     // User changed password during logon
    HWND  hWndChangePassword;                   // Hwnd of change passwor dialog
    BOOL  fWaitingForCallback;                  // We're waiting for RAS to call us back
    HWND  hWndCallbackNumber;                   // Hwnd of callback number dialog
    HWND  hWndRetryAuthentication;              // Hwnd of Retry Authentication dialog
    //
    // Support for global credentials
    //
    BOOL fGlobalCredentialsSupported;           // enables/disables support for global creds
    DWORD dwCurrentCredentialType;              // Which credentials are currently selected
    DWORD dwExistingCredentials;                // uses bit flags to mark if credentials exist
    DWORD dwDeleteCredentials;                  // uses bit flag to mark creds for deletion
    DWORD dwWinLogonType;                       //  0 - User logged on
                                                //  1 - Winlogon: dial-up
                                                //  2 - Winlogon: ICS (no one is logged on)
    DWORD dwGlobalUserInfo;                     // uses bit flags to load/save global user info

    LONG lInConnectOrCancel;                    // to protect against Cancel during Connect processing, and vice-versa

    CmLogFile Log;
} ArgsStruct;

//
// Global Credential Support
//

// Used to identify the current RAS credential store being used. 
// Used with ArgsStruct.dwCurrentCredentialType
#define CM_CREDS_USER   1
#define CM_CREDS_GLOBAL 2

// Identifies which type of credentials want to be use used
#define CM_CREDS_TYPE_MAIN      0
#define CM_CREDS_TYPE_INET      1
#define CM_CREDS_TYPE_BOTH      2

// Used to identify who is logged on. 
// Used with ArgsStruct.dwWinLogonType
#define CM_LOGON_TYPE_USER      0     // User is logged on
#define CM_LOGON_TYPE_WINLOGON  1     // Dial-up, winlogon, reconnect user initiated logon
#define CM_LOGON_TYPE_ICS       2     // No user is logged on, but need to dial unattended (ICS)

// Used with ArgsStruct.dwGlobalUserInfo
#define CM_GLOBAL_USER_INFO_READ_ICS_DATA       0x0001  // used to load user settings for ICS
#define CM_GLOBAL_USER_INFO_WRITE_ICS_DATA      0x0002  // used to save user settings for ICS


// Used with ArgsStruct.dwExistingCredentials
#define CM_EXIST_CREDS_MAIN_GLOBAL                  0x0001  // set if RAS credential store has main global creds
#define CM_EXIST_CREDS_MAIN_USER                    0x0002  // set if RAS credential store has main user creds
#define CM_EXIST_CREDS_INET_GLOBAL                  0x0004  // set if RAS credential store has Internet global creds
#define CM_EXIST_CREDS_INET_USER                    0x0008  // set if RAS credential store has Internet user creds

// Used with ArgsStruct.dwDeleteCredentials
#define CM_DELETE_CREDS_MAIN_GLOBAL                 0x0001  // set to delete main global creds
#define CM_DELETE_CREDS_MAIN_USER                   0x0002  // set to delete main user creds
#define CM_DELETE_CREDS_INET_GLOBAL                 0x0004  // set to delete Internet global creds
#define CM_DELETE_CREDS_INET_USER                   0x0008  // set to delete Internet user creds


//
// RasNumEntry - phone number subset of RASENTRY
//

typedef struct tagRasNumEntry
{
  DWORD      dwSize;
  DWORD      dwfOptions;
  DWORD      dwCountryID;
  DWORD      dwCountryCode;
  TCHAR      szAreaCode[ RAS_MaxAreaCode + 1 ];
  TCHAR      szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
} RASNUMENTRY, *LPRASNUMENTRY;

//
// EditNumData struct used to pass data to/from EditNum dialog.
//

typedef struct tagEditNumData
{
    ArgsStruct *pArgs;
    RASNUMENTRY RasNumEntry;

} EDITNUMDATA, *LPEDITNUMDATA;


//************************************************************************
// string constants
//************************************************************************

//
// CMMON exe name, expected to be local
//
const TCHAR* const c_pszCmMonExeName = TEXT("CMMON32.EXE");

//************************************************************************
// function prototypes
//************************************************************************

// init.cpp

void InitProfileFromName(ArgsStruct *pArgs, 
                         LPCTSTR pszArg);

HRESULT InitProfile(ArgsStruct *pArgs, 
                    LPCTSTR pszEntry);

HRESULT InitArgsForDisconnect(ArgsStruct *pArgs, BOOL fAllUser);

HRESULT InitArgsForConnect(ArgsStruct *pArgs, 
                           LPCTSTR pszRasPhoneBook,
                           LPCMDIALINFO lpCmInfo,
                           BOOL fAllUser);

HRESULT InitCredentials(ArgsStruct *pArgs,
                        LPCMDIALINFO lpCmInfo, 
                        DWORD dwFlags,
                        PVOID pvLogonBlob);

HRESULT InitLogging(ArgsStruct *pArgs, 
                    LPCTSTR pszEntry,
                    BOOL fBanner);

LRESULT CreateIniObjects(ArgsStruct *pArgs);

void ReleaseIniObjects(ArgsStruct *pArgs);

DWORD RegisterBitmapClass(HINSTANCE hInst);

HRESULT WriteCmpInfoToReg(LPCTSTR pszSubKey, 
                          LPCTSTR pszEntryName, 
                          PVOID pEntryValue, 
                          DWORD dwType, 
                          DWORD dwSize);

LPTSTR GetEntryFromCmp(const TCHAR *pszSectionName, 
                      LPTSTR pszEntryName, 
                      LPCTSTR pszCmpPath);

void ReplaceCmpFile(LPCTSTR pszCmpPath);

LPTSTR FormRegPathFromAccessPoint(ArgsStruct *pArgs);

        
// disconn.cpp

DWORD Disconnect(CConnectionTable *pConnTable, 
    LPCM_CONNECTION pConnection,
    BOOL fIgnoreRefCount,
    BOOL fPersist);

DWORD HangupNotifyCmMon(CConnectionTable *pConnTable,
    LPCTSTR pszEntry);

// connect.cpp

HRESULT Connect(HWND hwndParent,
                LPCTSTR lpszEntry,
                LPTSTR lpszPhonebook,
                LPRASDIALDLG lpRasDialDlg,
                LPRASENTRYDLG lpRasEntryDlg,
                LPCMDIALINFO lpCmInfo,
                DWORD dwFlags,
                LPVOID lpvLogonBlob);

#define NOT_IN_CONNECT_OR_CANCEL    0
#define IN_CONNECT_OR_CANCEL        1

void GetConnectType(ArgsStruct *pArgs);

void AddWatchProcessId(ArgsStruct *pArgs, DWORD dwProcessId);
void AddWatchProcess(ArgsStruct *pArgs, HANDLE hProcess);

DWORD DoRasHangup(RasLinkageStruct *prlsRasLink, 
    HRASCONN hRasConnection, 
    HWND hwndDlg = NULL, 
    BOOL fWaitForComplete = FALSE,
    LPBOOL pfWaiting = NULL);

DWORD MyRasHangup(ArgsStruct *pArgs, 
    HRASCONN hRasConnection, 
    HWND hwndDlg = NULL, 
    BOOL fWaitForComplete = FALSE);

DWORD HangupCM(
    ArgsStruct *pArgs, 
    HWND hwndDlg, 
    BOOL fWaitForComplete = FALSE,
    BOOL fUpdateTable = TRUE);

BOOL UseTunneling(
    ArgsStruct  *pArgs, 
    DWORD       dwEntry
);

void SetMainDlgUserInfo(
    ArgsStruct  *pArgs,
    HWND        hwndDlg
);

BOOL OnResetPassword(
    HWND        hwndDlg,
    ArgsStruct  *pArgs
);

void AppendStatusPane(HWND hwndDlg, 
                  DWORD dwMsgId);

void AppendStatusPane(HWND hwndDlg, 
                  LPCTSTR pszMsg);

LPTSTR GetPhoneByIdx(ArgsStruct *pArgs, 
                     UINT nIdx, 
                     LPTSTR *ppszDesc, 
                     LPTSTR *ppszDUN, 
                     LPDWORD pdwCountryID,
                     LPTSTR *ppszRegionName,
                     LPTSTR *ppszServiceType,
                     LPTSTR *ppszPhoneBookFile,
                     LPTSTR *ppszCanonical,
                     DWORD  *pdwPhoneInfoFlags); 

void PutPhoneByIdx(ArgsStruct *pArgs, 
                   UINT nIdx, 
                   LPCTSTR pszPhone, 
                   LPCTSTR pszDesc, 
                   LPCTSTR pszDUN, 
                   DWORD dwCountryID, 
                   LPCTSTR pszRegionName,
                   LPCTSTR pszServiceType,
                   LPCTSTR pszPhoneBookFile, 
                   LPCTSTR ppszCanonical,
                   DWORD   dwPhoneInfoFlags);

DWORD LoadDialInfo(ArgsStruct *pArgs, HWND hwndDlg, BOOL fInstallModem = TRUE, BOOL fAlwaysMunge = FALSE); 
VOID MungeDialInfo(ArgsStruct *pArgs);
 
void LoadHelpFileInfo(ArgsStruct *pArgs);

void CopyPhone(ArgsStruct *pArgs, 
               LPRASENTRY preEntry, 
               DWORD dwEntry); 
 
VOID LoadLogoBitmap(ArgsStruct * pArgs, 
                    HWND hwndDlg);

HRESULT LoadFutureSplash(ArgsStruct * pArgs, 
                         HWND hwndDlg);

void LoadProperties(
    ArgsStruct  *pArgs
);

void LoadIconsAndBitmaps(
    ArgsStruct  *pArgs, 
    HWND        hwndDlg
);

DWORD DoRasDial(HWND hwndDlg, 
              ArgsStruct *pArgs, 
              DWORD dwEntry); 

DWORD DoTunnelDial(HWND hwndDlg, 
                 ArgsStruct *pArgs);

BOOL CheckConnect(HWND hwndDlg, 
                  ArgsStruct *pArgs, 
                  UINT *pnCtrlFocus,
                  BOOL fShowMsg = FALSE); 

void MainSetDefaultButton(HWND hwndDlg, 
                          UINT nCtrlId); 

VOID MapStateToFrame(ArgsStruct * pArgs);

void SetInteractive(HWND hwndDlg, 
                    ArgsStruct *pArgs);

void OnMainLoadStartupInfo(
    HWND hwndDlg, 
    ArgsStruct *pArgs
);

BOOL SetupInternalInfo(
    ArgsStruct  *pArgs,
    HWND        hwndDlg
);

void OnMainInit(HWND hwndDlg, 
                ArgsStruct *pArgs);

void OnMainConnect(HWND hwndDlg, 
                   ArgsStruct *pArgs);

int OnMainProperties(HWND hwndDlg, 
                     ArgsStruct *pArgs); 

void OnMainCancel(HWND hwndDlg, 
                  ArgsStruct *pArgs); 

void OnMainEnChange(HWND hwndDlg, 
                    ArgsStruct *pArgs); 

DWORD OnRasNotificationMessage(HWND hwndDlg, 
                               ArgsStruct *pArgs, 
                               WPARAM wParam, 
                               LPARAM lParam);

void OnRasErrorMessage(HWND hwndDlg, 
                       ArgsStruct *pArgs,
                       DWORD dwError);

void OnMainTimer(HWND hwndDlg, 
                 ArgsStruct *pArgs); 

void OnConnectedCM(HWND hwndDlg, 
                ArgsStruct *pArgs);

INT_PTR CALLBACK MainDlgProc(HWND hwndDlg, 
                          UINT uMsg, 
                          WPARAM wParam, 
                          LPARAM lParam); 

BOOL ShowAccessPointInfoFromReg(ArgsStruct *pArgs, 
                                HWND hwndParent, 
                                UINT uiComboID);

BOOL ChangedAccessPoint(ArgsStruct *pArgs, 
                           HWND hwndDlg,
                           UINT uiComboID);

// dialogs.cpp

int DoPropertiesPropSheets(
    HWND        hwndDlg,
    ArgsStruct  *pArgs
);

void CheckConnectionAndInformUser(
    HWND        hwndDlg,
    ArgsStruct  *pArgs
);

BOOL HaveContextHelp(
     HWND    hwndDlg,
     HWND    hwndCtrl
);

// refs.cpp

BOOL ValidTopLevelPBK(
    ArgsStruct  *pArgs
);

BOOL ValidReferencedPBKs(
    ArgsStruct  *pArgs
);

CIni* GetAppropriateIniService(
    ArgsStruct  *pArgs,
    DWORD       dwEntry
);



// ctr.cpp

VOID CleanupCtr(LPICMOCCtr pCtr);

BOOL LinkToOle32(
    Ole32LinkageStruct *polsOle32Link,
    LPCSTR pszOle32); 

void UnlinkFromOle32(
    Ole32LinkageStruct *polsOle32Link); 

// util.cpp

BOOL InBetween(int iLowerBound, int iNumber, int iUpperBound);

void GetPrefixSuffix
(
    ArgsStruct *pArgs, 
    CIni* piniService, 
    LPTSTR *ppszUsernamePrefix, 
    LPTSTR *ppszUsernameSuffix
);

LPTSTR ApplyPrefixSuffixToBufferAlloc
(
    ArgsStruct *pArgs, 
    CIni *piniService, 
    LPTSTR pszBuffer
);

LPTSTR ApplyDomainPrependToBufferAlloc
(
    ArgsStruct *pArgs, 
    CIni *piniService, 
    LPTSTR pszBuffer,
    LPCTSTR pszDunName
);

void ApplyPasswordHandlingToBuffer
(
    ArgsStruct *pArgs,
    LPTSTR pszBuffer
);

BOOL IsActionEnabled(CONST WCHAR *pszProgram, 
                     CONST WCHAR *pszServiceName, 
                     CONST WCHAR *pszServiceFileName, 
                     LPDWORD lpdwLoadType);

BOOL IsLogonAsSystem();

BOOL UnRegisterWindowClass(HINSTANCE hInst);

DWORD RegisterWindowClass(HINSTANCE hInst);

LPCM_CONNECTION GetConnection(ArgsStruct *pArgs);

void NotifyUserOfExistingConnection(
    HWND hwndParent, 
    LPCM_CONNECTION pConnection,
    BOOL fStatus);

BOOL FileExists(LPCTSTR pszFullNameAndPath);

LPTSTR  CmGetWindowTextAlloc(
    HWND hwndDlg, 
    UINT nCtrl);

LPTSTR GetServiceName(CIni *piniService); 

LPTSTR GetTunnelSuffix();

LPTSTR GetDefaultDunSettingName(CIni* piniService, BOOL fTunnelEntry);

LPTSTR GetDunSettingName(ArgsStruct * pArgs, DWORD dwEntry, BOOL fTunnelEntry);

LPTSTR GetCMSforPhoneBook(ArgsStruct * pArgs, DWORD dwEntry);

BOOL ReadMappingByRoot(
    HKEY    hkRoot,
    LPCTSTR pszDUN, 
    LPTSTR pszMapping, 
    DWORD dwMapping,
    BOOL bExpandEnvStrings
);

BOOL ReadMapping(
    LPCTSTR pszDUN, 
    LPTSTR pszMapping, 
    DWORD dwMapping,
    BOOL fAllUser,
    BOOL bExpandEnvStrings
);

LPTSTR ReducePathToRelative(
    ArgsStruct *pArgs, 
    LPCTSTR pszFullPath);

BOOL IsBlankString(LPCTSTR pszString);

BOOL IsValidPhoneNumChar(TCHAR tChar);

LPTSTR StripPath(LPCTSTR pszFullNameAndPath);

void SingleSpace(LPTSTR pszStr, UINT uNumCharsInStr);

void Ip_GPPS(CIni *pIni, 
    LPCTSTR pszSection, 
    LPCTSTR pszEntry, 
    RASIPADDR *pIP);

void CopyGPPS(CIni *pIni, 
    LPCTSTR pszSection, 
    LPCTSTR pszEntry,
    LPTSTR pszBuffer, 
    size_t nLen); 

BYTE HexValue(IN CHAR ch);
CHAR HexChar(IN BYTE byte);

void StripCanonical(LPTSTR pszSrc);
void StripFirstElement(LPTSTR pszSrc);

BOOL FrontExistingUI
(
    CConnectionTable *pConnTable,
    LPCTSTR pszServiceName, 
    BOOL fConnect
);


LPTSTR GetPropertiesDlgTitle(
    LPCTSTR pszServiceName
);

int GetPPTPMsgId(void);

BOOL IsServicePackInstalled(void);

// pb.cpp

#define CPBMAP_ERROR    -1

class CPBMap {
        public:
                CPBMap();
                ~CPBMap();
                DWORD Open(LPCSTR pszISP, DWORD dwParam=0);
                DWORD ToCookie(DWORD_PTR dwPB, DWORD dwIdx, DWORD *pdwParam=NULL);
                DWORD_PTR PBFromCookie(DWORD dwCookie, DWORD *pdwParam=NULL);
                DWORD IdxFromCookie(DWORD dwCookie, DWORD *pdwParam=NULL);
                DWORD_PTR GetPBByIdx(DWORD_PTR dwIdx, DWORD *pdwParam=NULL);
                DWORD GetCnt();
        private:
                UINT m_nCnt;
                void *m_pvData;
};

#define PB_MAX_PHONE    (RAS_MaxPhoneNumber+1)
#define PB_MAX_DESC             256

typedef struct tagPBArgs {
        LPCTSTR pszCMSFile;
        TCHAR szServiceType[PB_MAX_SERVICE];
        DWORD dwCountryId;
        TCHAR szRegionName[PB_MAX_REGION];
        TCHAR szNonCanonical[PB_MAX_PHONE];
        TCHAR szCanonical[PB_MAX_PHONE];
        TCHAR szDesc[PB_MAX_DESC];
        LPTSTR pszMessage;
        TCHAR szPhoneBookFile[MAX_PATH+1];
        LPTSTR pszBitmap;
        LPCTSTR pszHelpFile;
        TCHAR szDUNFile[MAX_PATH+1];
        HPALETTE *phMasterPalette;
} PBArgs;


BOOL DisplayPhoneBook(HWND hwndDlg, PBArgs *pArgs, BOOL fHasValidTopLevelPBK, BOOL fHasValidReferencedPBKs);

// rnawnd.cpp

HANDLE ZapRNAConnectedTo(LPCTSTR pszDUN, HANDLE hEvent);

// userinfo.cpp

BOOL GetUserInfo(
    ArgsStruct  *pArgs, 
    UINT        uiEntry,
    PVOID       *ppvData
);

BOOL SaveUserInfo(
    ArgsStruct  *pArgs, 
    UINT        uiEntry,
    PVOID       pvData
);

BOOL DeleteUserInfo(
    ArgsStruct  *pArgs, 
    UINT        uiEntry
);

int NeedToUpgradeUserInfo(
    ArgsStruct  *pArgs
);

BOOL UpgradeUserInfoFromCmp(
    ArgsStruct  *pArgs
);

BOOL UpgradeUserInfoFromRegToRasAndReg(
    ArgsStruct  *pArgs
);

BOOL ReadUserInfoFromReg(
    ArgsStruct  *pArgs,
    UINT        uiDataID,
    PVOID       *ppvData);

LPTSTR BuildUserInfoSubKey(
    LPCTSTR pszServiceKey, 
    BOOL fAllUser);

LPTSTR BuildICSDataInfoSubKey(
    LPCTSTR pszServiceKey);

BOOL WriteUserInfoToReg(
    ArgsStruct  *pArgs,
    UINT        uiDataID,
    PVOID       pvData);

// ntlsa.cpp

DWORD LSA_ReadString(
    ArgsStruct  *pArgs,
    LPTSTR     pszKey,
    LPTSTR      pszStr,
    DWORD       dwStrLen
);

DWORD LSA_WriteString(
    ArgsStruct  *pArgs,
    LPTSTR     pszKey,
    LPCTSTR     pszStr
);

BOOL InitLsa(
    ArgsStruct  *pArgs
);

BOOL DeInitLsa(
    ArgsStruct  *pArgs
);



// ras.cpp
BOOL IsRasLoaded(const RasLinkageStruct * const prlsRasLink);
BOOL LinkToRas(RasLinkageStruct *prlsRasLink);
void UnlinkFromRas(RasLinkageStruct *prlsRasLink);
BOOL GetRasModems(const RasLinkageStruct *prlsRasLink, 
                  LPRASDEVINFO *pprdiRasDevInfo, 
                  LPDWORD pdwCnt);

BOOL PickModem(IN const ArgsStruct *pArgs, 
               OUT LPTSTR pszDeviceType, 
               OUT LPTSTR pszDeviceName, 
               OUT BOOL* pfSameModem = NULL); 

BOOL GetDeviceType(ArgsStruct *pArgs, 
                   LPTSTR pszDeviceType,
                   UINT uNumCharsInDeviceType,
                   LPTSTR pszDeviceName);

BOOL PickTunnelDevice(LPTSTR pszDeviceType, 
                      LPTSTR pszDeviceName, 
                      LPRASDEVINFO prdiModems, 
                      DWORD dwCnt); 

BOOL PickTunnelDevice(ArgsStruct *pArgs, 
                      LPTSTR pszDeviceType, 
                      LPTSTR pszDeviceName);

void CopyAutoDial(LPRASENTRY preEntry); 
                           
LPRASENTRY MyRGEP(LPCTSTR pszRasPbk,
                  LPCTSTR pszEntryName, 
                  RasLinkageStruct *prlsRasLink);
                  
BOOL CheckConnectionError(HWND hwndDlg, 
                   DWORD dwErr, 
                   ArgsStruct *pArgs,
                   BOOL    fTunneling,
                   LPTSTR   *ppszRasErrMsg = NULL);

LPTSTR GetRasConnectoidName(
    ArgsStruct  *pArgs, 
    CIni*       piniService, 
    BOOL        fTunnelEntry
);

LPRASENTRY CreateRASEntryStruct(
    ArgsStruct  *pArgs, 
    LPCTSTR     pszDUN, 
    CIni*       piniService, 
    BOOL        fTunnelEntry,
    LPTSTR      pszRasPbk,
    LPBYTE      *ppbEapData,
    LPDWORD     pdwEapSize  
);

LRESULT ReadDUNSettings(
    ArgsStruct *pArgs,
    LPCTSTR pszFile, 
    LPCTSTR pszDunName, 
    LPVOID pvBuffer,
    LPBYTE      *ppbEapData,
    LPDWORD     pdwEapSiz,
    BOOL        fTunnel
);

BOOL ValidateDialupDunSettings(LPCTSTR pszCmsFile, 
    LPCTSTR pszDunName,
    LPCTSTR pszTopLevelCms);

LPTSTR CreateRasPrivatePbk(
    ArgsStruct  *pArgs);

DWORD AllocateSecurityDescriptorAllowAccessToWorld(PSECURITY_DESCRIPTOR *ppSd);

LPTSTR GetPathToPbk(
    LPCTSTR pszCmp, ArgsStruct *pArgs);

void DisableWin95RasWizard(
    void
);

BOOL SetIsdnDualChannelEntries(
    ArgsStruct      *pArgs,
    LPRASENTRY      pre,
    LPRASSUBENTRY   *pprse,
    PDWORD          pdwSubEntryCount
);

BOOL SetNtIdleDisconnectInRasEntry(
    ArgsStruct      *pArgs,
    LPRASENTRY      pre
);

BOOL DisableSystemIdleDisconnect(LPRASENTRY pre);

DWORD WINAPI RasDialFunc2(
    ULONG_PTR dwCallbackId,    // user-defined value specified in RasDial 
                           // call
    DWORD dwSubEntry,      // subentry index in multilink connection
    HRASCONN hrasconn,     // handle to RAS connection
    UINT unMsg,            // type of event that has occurred
    RASCONNSTATE rascs,    // connection state about to be entered
    DWORD dwError,         // error that may have occurred
    DWORD dwExtendedError  // extended error information for some 
                           // errors
);

LPRASENTRY AllocateRasEntry();

LPRASDIALEXTENSIONS AllocateAndInitRasDialExtensions();
DWORD InitRasDialExtensions(LPRASDIALEXTENSIONS lpRasDialExtensions);
DWORD SetRasDialExtensions(ArgsStruct* pArgs, BOOL fEnablePausedStates, BOOL fEnableCustomScripting);

LPVOID GetRasCallBack(ArgsStruct* pArgs);
DWORD GetRasCallBackType();

#if 0
/*
void InitDefaultRasPhoneBook();
LPTSTR GetRasSystemPhoneBookPath();
*/
#endif

LPRASDIALPARAMS AllocateAndInitRasDialParams();
DWORD InitRasDialParams(LPRASDIALPARAMS lpRasDialParams);


LPTSTR GetRasPbkFromNT5ProfilePath(LPCTSTR pszProfile);

DWORD OnPauseRasDial(HWND hwndDlg, ArgsStruct *pArgs, WPARAM wParam, LPARAM lParam);   

// tapi.cpp

BOOL OpenTapi(HINSTANCE hInst, TapiLinkageStruct *ptlsTapiLink);
void CloseTapi(TapiLinkageStruct *ptlsTapiLink);
BOOL LinkToTapi(TapiLinkageStruct *ptlsTapiLink, LPCSTR pszTapi);
void UnlinkFromTapi(TapiLinkageStruct *ptlsTapiLink);
BOOL SetTapiDevice(HINSTANCE hInst, 
                   TapiLinkageStruct *ptlsTapiLink, 
                   LPCTSTR pszModem);

LRESULT MungePhone(LPCTSTR pszModem, 
                   LPTSTR *ppszPhone, 
                   TapiLinkageStruct *ptlsTapiLink, 
                   HINSTANCE hInst,
                   BOOL fDialingRulesEnabled,
                   LPTSTR *ppszDial,
                   BOOL fAccessPointsEnabled);

DWORD GetCurrentTapiLocation(TapiLinkageStruct *ptlsTapiLink);

DWORD SetCurrentTapiLocation(TapiLinkageStruct *ptlsTapiLink, DWORD dwLocation);

void RestoreOldTapiLocation(TapiLinkageStruct *ptlsTapiLink);

HANDLE HookLights(ArgsStruct *pArgs);

inline BOOL IsTunnelEnabled(const ArgsStruct* pArgs)
{
    return (pArgs->fTunnelPrimary || pArgs->fTunnelReferences);
}

inline BOOL IsDialingTunnel(const ArgsStruct* pArgs)
{
    return pArgs->psState == PS_TunnelDialing 
        || pArgs->psState == PS_TunnelAuthenticating;
}

inline BOOL _ArgsStruct::IsDirectConnect() const
{
    return m_fDirectConnect;
}

inline void _ArgsStruct::SetDirectConnect(BOOL fDirect)
{
    m_fDirectConnect = fDirect;
}

inline BOOL _ArgsStruct::IsBothConnTypeSupported() const
{
    return m_fBothConnTypeSupported;
}

inline void _ArgsStruct::SetBothConnTypeSupported(BOOL fBoth)
{
    m_fBothConnTypeSupported = fBoth;    
}

// wsock.cpp

BOOL TryAnotherTunnelDnsAddress(
    ArgsStruct  *pArgs
);

// main.cpp

BOOL WhoIsCaller(
    DWORD   dwCaller = DT_USER
);


// lanawait.cpp

BOOL LanaWait(
    ArgsStruct *pArgs,
    HWND       hwndMainDlg
);

//
// Credential helper functions
//

#define CM_DELETE_SAVED_CREDS_KEEP_GLOBALS              FALSE
#define CM_DELETE_SAVED_CREDS_DELETE_GLOBALS            TRUE
#define CM_DELETE_SAVED_CREDS_KEEP_IDENTITY             FALSE
#define CM_DELETE_SAVED_CREDS_DELETE_IDENTITY           TRUE

BOOL InitializeCredentialSupport(ArgsStruct *pArgs);
BOOL RefreshCredentialTypes(ArgsStruct *pArgs, BOOL fSetCredsDefault);
VOID RefreshCredentialInfo(ArgsStruct *pArgs, DWORD dwCredsType);
DWORD FindEntryCredentialsForCM(ArgsStruct *pArgs, LPTSTR pszPhoneBook, BOOL *pfUser, BOOL *pfGlobal);
DWORD GetCurrentCredentialType(ArgsStruct *pArgs);
BOOL DeleteSavedCredentials(ArgsStruct *pArgs, DWORD dwCredsType, BOOL fDeleteGlobal, BOOL fDeleteIdentity);
VOID SetCredentialUIOptionBasedOnDefaultCreds(ArgsStruct *pArgs, HWND hwndDlg);
VOID GetAndStoreUserInfo(ArgsStruct *pArgs, HWND hwndDlg, BOOL fSaveUPD, BOOL fSaveOtherUserInfo);
VOID TryToDeleteAndSaveCredentials(ArgsStruct *pArgs, HWND hwndDlg);
VOID GetUserInfoFromDialog(ArgsStruct *pArgs, HWND hwndDlg, RASCREDENTIALS *prc);
VOID SwitchToLocalCreds(ArgsStruct *pArgs, HWND hwndDlg, BOOL fSwitchToLocal);
VOID SwitchToGlobalCreds(ArgsStruct *pArgs, HWND hwndDlg, BOOL fSwitchToGlobal);
VOID ReloadCredentials(ArgsStruct *pArgs, HWND hwndDlg, DWORD dwWhichCredType);

//
// Global User Info help functions
//
VOID SetIniObjectReadWriteFlags(ArgsStruct *pArgs);

VOID VerifyAdvancedTabSettings(ArgsStruct *pArgs);
HRESULT InternalGetSharingEnabled(IHNetConnection *pHNetConnection, BOOLEAN *pbEnabled, SHARINGCONNECTIONTYPE* pType);
HRESULT InternalGetFirewallEnabled(IHNetConnection *pHNetConnection, BOOLEAN *pbEnabled);
STDMETHODIMP DisableSharing(IHNetConnection *pHNetConn);
VOID EnableInternetFirewall(IHNetConnection *pHNetConn);
HRESULT FindINetConnectionByGuid(GUID *pGuid, INetConnection **ppNetCon);
VOID SetProxyBlanket(IUnknown *pUnk);
BOOL IsAdmin(VOID);
BOOL IsMemberOfGroup(DWORD dwGroupRID, BOOL bUseBuiltinDomainRid);

HRESULT APIENTRY HrCreateNetConnectionUtilities(INetConnectionUiUtilities ** ppncuu);

#endif // _ICM_INC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmdial\image.cpp ===
//+----------------------------------------------------------------------------
//
// File:	 image.cpp
//
// Module:	 CMDIAL32.DLL
//
// Synopsis:  Imaging support routines
//
// Copyright (c) 1998 Microsoft Corporation
//
// Author:	 nickball   Created Header   3/30/98
//		     quintinb   modified to use common\source\bmpimage.cpp 8-6-98
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"

//
//  Include the shared bitmap handling code. (see common\source\bmpimage.cpp)
//
#include "bmpimage.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmdial\disconn.cpp ===
//+----------------------------------------------------------------------------
//
// File:     disconn.cpp
//
// Module:   CMDIAL32.DLL
//
// Synopsis: The main code path for terminating a connection. 
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   nickball   Created    2/10/98
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"
#include "actlist.h"
#include "tunl_str.h"
#include "conact_str.h"

// The following block is copied from wtsapi32.h (we compile with
// _WIN32_WINNT set to less than 5.01, so we can't get these values via a #include)
//
#include "WtsApi32.h"
#define WTS_CONSOLE_CONNECT                0x1
#define WTS_CONSOLE_DISCONNECT             0x2
#define WTS_REMOTE_CONNECT                 0x3
#define WTS_REMOTE_DISCONNECT              0x4
#define WTS_SESSION_LOGON                  0x5
#define WTS_SESSION_LOGOFF                 0x6
#define WTS_SESSION_LOCK                   0x7
#define WTS_SESSION_UNLOCK                 0x8

//+----------------------------------------------------------------------------
//
// Function:    InFastUserSwitch
//
// Synopsis:    Are we in a Fast User switch
//
// Argsuments:  None
//
// Return:      BOOL (TRUE if yes, FALSE if not)
//
// History: 18-Jul-2001   SumitC      Created
//
//-----------------------------------------------------------------------------
BOOL
InFastUserSwitch()
{
    BOOL fReturn = FALSE;

    if (OS_NT51)
    {
        HINSTANCE hInstLib = LoadLibraryExU(TEXT("WTSAPI32.DLL"), NULL, 0);
        if (hInstLib)
        {
            typedef BOOL (WINAPI *pfnWTSQuerySessionInformationW_TYPE) (HANDLE, DWORD, WTS_INFO_CLASS, LPWSTR*, DWORD*);
            typedef VOID (WINAPI *pfnWTSFreeMemory_TYPE) (PVOID);

            pfnWTSQuerySessionInformationW_TYPE pfnWTSQuerySessionInformationW;
            pfnWTSFreeMemory_TYPE               pfnWTSFreeMemory;

            pfnWTSQuerySessionInformationW = (pfnWTSQuerySessionInformationW_TYPE) GetProcAddress(hInstLib, "WTSQuerySessionInformationW");
            pfnWTSFreeMemory =               (pfnWTSFreeMemory_TYPE)               GetProcAddress(hInstLib, "WTSFreeMemory");

            if (pfnWTSQuerySessionInformationW && pfnWTSFreeMemory)
            {
                DWORD cb;
                WTS_CONNECTSTATE_CLASS * pConnectState = NULL;

                CMTRACE(TEXT("Querying to see if we're in a FUS"));
                if (pfnWTSQuerySessionInformationW(WTS_CURRENT_SERVER_HANDLE,
                                                   WTS_CURRENT_SESSION,
                                                   WTSConnectState,
                                                   (LPTSTR *)&pConnectState,
                                                   &cb))
                {
                    CMTRACE1(TEXT("Querying to see if we're in a FUS - succeeded, connstate is %d"), *pConnectState);
                    if (WTSDisconnected == *pConnectState)
                    {
                        fReturn = TRUE;
                        CMTRACE(TEXT("Querying to see if we're in a FUS - yes we are."));
                    }
                    
                    pfnWTSFreeMemory(pConnectState);
                }
            }
            FreeLibrary(hInstLib);
        }
    }

    return fReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  CleanupDisconnect
//
// Synopsis:  Helper function encapsulating release of resource allocated duri
//            ng disconnect.
//
// Arguments: ArgsStruct *pArgs - Ptr to global Args struct
//
// Returns:   Nothing
//
// History:   nickball    Created    8/14/98
//
//+----------------------------------------------------------------------------
void CleanupDisconnect(ArgsStruct *pArgs)
{
    MYDBGASSERT(pArgs);
    
    if (NULL == pArgs)
    {
        return;
    }

    UnlinkFromRas(&pArgs->rlsRasLink);

    ReleaseIniObjects(pArgs);

    if (pArgs->pszRasPbk)
    {
        CmFree(pArgs->pszRasPbk);
        pArgs->pszRasPbk = NULL;
    }

    if (pArgs->pszCurrentAccessPoint)
    {
        CmFree(pArgs->pszCurrentAccessPoint);
        pArgs->pszCurrentAccessPoint = NULL;
    }

    if (pArgs->pszRasHiddenPbk)
    {
        CmFree(pArgs->pszRasHiddenPbk);
        pArgs->pszRasHiddenPbk = NULL;
    }

    if (pArgs->pszVpnFile)
    {
        CmFree(pArgs->pszVpnFile);
        pArgs->pszVpnFile = NULL;
    }

    CmFree(pArgs);
}

//+----------------------------------------------------------------------------
//
// Function:  HangupNotifyCmMon
//
// Synopsis:  Sends a hangup message to CmMon via WM_COPYDATA
//
// Arguments: CConnectionTable *pConnTable - Ptr to the Connection table.
//            LPCTSTR pszEntry - The name of the entry.
//
// Returns:   DWORD - Failure code
//
// History:   nickball    Created    2/11/98
//
//+----------------------------------------------------------------------------
DWORD HangupNotifyCmMon(CConnectionTable *pConnTable,
    LPCTSTR pszEntry)
{
    MYDBGASSERT(pConnTable);
    MYDBGASSERT(pszEntry);
    
    if (NULL == pConnTable || NULL == pszEntry || 0 == pszEntry[0])
    {
        return ERROR_INVALID_PARAMETER;
    }
       
    //
    // Update CMMON if present
    //

    HWND hwndMon;
   
    if (SUCCEEDED(pConnTable->GetMonitorWnd(&hwndMon)) && IsWindow(hwndMon))
    {
        CMTRACE1(TEXT("HangupNotifyCmMon() - Notifying CMMON that we are disconnecting %s"), pszEntry);

        //
        // Stash the entry name in HangupInfo 
        //

        CM_HANGUP_INFO HangupInfo;

        lstrcpyU(HangupInfo.szEntryName, pszEntry);

        //
        // Send Hangup info to CMMON via COPYDATA
        //

        COPYDATASTRUCT CopyData;

        CopyData.dwData = CMMON_HANGUP_INFO;
        CopyData.cbData = sizeof(CM_HANGUP_INFO);                
        CopyData.lpData = (PVOID) &HangupInfo;

        SendMessageU(hwndMon, WM_COPYDATA, NULL, (LPARAM) &CopyData);
    }

#ifdef DEBUG
    if (!hwndMon)
    {
        CMTRACE(TEXT("HangupNotifyCmMon() - CMMON hwnd is NULL"));
    }
#endif
    return ERROR_SUCCESS;
}

//+----------------------------------------------------------------------------
//
// Function:  DoDisconnect
//
// Synopsis:  Encapulates initialization of pArgs with profile, service, etc. 
//            Runs disconnect actions and terminates the connection.
//
// Arguments: LPCM_CONNECTION pConnection - Ptr to a CM_CONNECTION struct containing 
//            connection info such as entry name and RAS handles.
//            BOOL fActions - Flag indicating that disconnect actions should be run
//
// Returns:   DWORD - Failure code
//
// History:   nickball    Created Header    2/12/98
//
//+----------------------------------------------------------------------------
DWORD DoDisconnect(LPCM_CONNECTION pConnection, BOOL fActions)
{
    MYDBGASSERT(pConnection);
    
    if (NULL == pConnection)
    {
        return ERROR_INVALID_PARAMETER;
    }   

    //
    // Allocate and initialize pArgs
    //

    ArgsStruct* pArgs = (ArgsStruct*) CmMalloc(sizeof(ArgsStruct));

    if (NULL == pArgs)
    {
        return ERROR_ALLOCATING_MEMORY;
    }

    //
    // Clear and init global args struct
    //
    
    HRESULT hrRet = InitArgsForDisconnect(pArgs, pConnection->fAllUser);
    
    if (FAILED(hrRet))
    {
        return HRESULT_CODE(hrRet);
    }

    //
    // Initialize the profile
    //

    hrRet = InitProfile(pArgs, pConnection->szEntry);

    if (FAILED(hrRet))
    {
        return HRESULT_CODE(hrRet);
    }

    //
    // Do we want tunneling?  If this was a tunnel connection, then the connection table
    // will have a non-NULL value for the hTunnel field of that connection entry.
    //

    pArgs->fTunnelPrimary = (int) pArgs->piniService->GPPI(c_pszCmSection, c_pszCmEntryTunnelPrimary);
    pArgs->fTunnelReferences = (int) pArgs->piniService->GPPI(c_pszCmSection, c_pszCmEntryTunnelReferences);
    pArgs->fUseTunneling = pConnection->hTunnel ? TRUE : FALSE;

    //
    // Determine our connect type
    //
    
    GetConnectType(pArgs);

    //
    //  Initialize the path to the phonebook if this is NT5 so that disconnect
    //  actions can use it if they want to.  Note that the temporary phonebook
    //  has already been deleted at this point so we will return NULL so that
    //  it doesn't confuse the disconnect actions.
    //
    if (OS_NT5)
    {
        pArgs->pszRasPbk = GetRasPbkFromNT5ProfilePath(pArgs->piniProfile->GetFile());
    }    

    //
    // Initialize logging and log the disconnect event.
    //

    (VOID) InitLogging(pArgs, pConnection->szEntry, FALSE); // FALSE => no banner
    // ignore return value

    TCHAR szTmp[MAX_PATH];            
    MYVERIFY(GetModuleFileNameU(NULL, szTmp, MAX_PATH));          
    pArgs->Log.Log(DISCONNECT_EVENT, szTmp);

    //
    //  If we are in a Fast User Switch, set the flag so that we can skip customactions
    //  that might block the disconnect (by bringing up UI etc)
    //
    pArgs->fInFastUserSwitch = InFastUserSwitch();

    //
    // If we are connected, run Disconnect Actions before we actually terminate
    //

    if (fActions)
    {
        CActionList DisconnectActList;
        DisconnectActList.Append(pArgs->piniService, c_pszCmSectionOnDisconnect);

        DisconnectActList.RunAccordType(NULL, pArgs, FALSE); 
    }

    //
    // Initialize Data and links for Hangup
    //
   
    if (FALSE == LinkToRas(&pArgs->rlsRasLink))
    {
        MYDBGASSERT(FALSE);
        return ERROR_NOT_READY; 
    }

    //
    // Linkage is good, hangup 
    // 

    if (pArgs->rlsRasLink.pfnHangUp)
    {
        //
        // Test the connection status of each connection handle. If not 
        // connected, then there is no reason for us to call Hangup
        //
        
        RASCONNSTATUS rcs;             
        
        if (pConnection->hTunnel) 
        {
            ZeroMemory(&rcs,sizeof(rcs));
            rcs.dwSize = sizeof(rcs);

            if (ERROR_SUCCESS == pArgs->rlsRasLink.pfnGetConnectStatus(pConnection->hTunnel,&rcs) &&
                rcs.rasconnstate == RASCS_Connected)
            {
                if (IsLogonAsSystem())
                {
                    //
                    // Don't want to bring up any UI
                    //
                    DoRasHangup(&pArgs->rlsRasLink, pConnection->hTunnel);
                }
                else
                {
                    MYVERIFY(ERROR_SUCCESS == DoRasHangup(&pArgs->rlsRasLink, pConnection->hTunnel));
                }
            }
        }

        if (pConnection->hDial)
        {
            ZeroMemory(&rcs,sizeof(rcs));
            rcs.dwSize = sizeof(rcs);

            if (ERROR_SUCCESS == pArgs->rlsRasLink.pfnGetConnectStatus(pConnection->hDial,&rcs) &&
                rcs.rasconnstate == RASCS_Connected)
            {
                if (IsLogonAsSystem())
                {
                    //
                    // Don't want to bring up any UI
                    //
                    DoRasHangup(&pArgs->rlsRasLink, pConnection->hDial);
                }
                else
                {
                    DWORD dwRet = DoRasHangup(&pArgs->rlsRasLink, pConnection->hDial);
                    if (ERROR_SUCCESS != dwRet)
                    {
                        CMTRACE1(TEXT("DoDisconnect: DoRasHangup failed with error code with %d"), dwRet);
                    }
                }
            }
        }
    }

    //
    // Un-initialize logging
    //

    (VOID) pArgs->Log.DeInit();
    // ignore return value

    //
    // Cleanup linkage and memory
    //

    CleanupDisconnect(pArgs);

    return ERROR_SUCCESS;
}

//+----------------------------------------------------------------------------
//
// Function:  Disconnect
//
// Synopsis:  Disconnects the connection with the name pszEntry.
//
// Arguments: CConnectionTable *pConnTable - Ptr to connection table
//            LPCM_CONNECTION pConnection - The current table data for the entry.
//            BOOL fIgnoreRefCount - Flag to override ref count
//            BOOL fPersist - Flag indicating that entry should be persistent
//
// Returns:   DWORD - Failure code
//
// History:   nickball    Created    2/11/98
//
//+----------------------------------------------------------------------------
DWORD Disconnect(CConnectionTable *pConnTable, LPCM_CONNECTION pConnection, BOOL fIgnoreRefCount, BOOL fPersist)
{
    MYDBGASSERT(pConnection);
    MYDBGASSERT(pConnTable);
    
    CMTRACE(TEXT("Disconnect()"));

#ifdef DEBUG
    IsLogonAsSystem(); // Traces user name
#endif

    if (NULL == pConnection || NULL == pConnTable)
    {
        return ERROR_INVALID_PARAMETER;
    }

//    MYDBGASSERT(!(fIgnoreRefCount && fPersist)); // mutually exclusive flags
    MYDBGASSERT(CM_CONNECTING != pConnection->CmState); 

    if (!fIgnoreRefCount)
    {
        //
        // The hangup is not forced, check usage
        //

        if (pConnection->dwUsage > 1)
        {
            //
            // As long as fPersist is false, adjust the usage count
            //

            if (!fPersist)
            {
                pConnTable->RemoveEntry(pConnection->szEntry);
            }
            
            return ERROR_SUCCESS;                                
        }
        else
        {
            //
            // If we are already disconnecting, just succeed
            //

            if (CM_DISCONNECTING == pConnection->CmState)
            {
                return ERROR_SUCCESS;
            }
        }
    }

    //
    // Looks like we are comitted to getting to a usage of zero, tell CMMON
    // to stop monitoring this connection unless we are in persist state.
    // 
    
    if (!fPersist)
    {
        HangupNotifyCmMon(pConnTable, pConnection->szEntry);
    }

    LRESULT lRes = ERROR_SUCCESS;

    //
    // Usage is down <= 1, or being ignored. If we are in reconnect prompt 
    // state, then there is nothing to disconnect so don't call hangup.
    //

    if (CM_RECONNECTPROMPT != pConnection->CmState)
    {
        //
        // We are committed to a real disconnect, so set the entry
        // to the disconnecting state while we hangup.
        //

        BOOL fActions = (CM_CONNECTED == pConnection->CmState); 
    
        pConnTable->SetDisconnecting(pConnection->szEntry);

        lRes = DoDisconnect(pConnection, fActions);

        //
        // If persisting, just set the state to reconnect prompt
        //

        if (fPersist)
        {
            //
            // Set entry to limbo state of reconnect prompt
            //

            pConnTable->SetPrompting(pConnection->szEntry);
            return (DWORD)lRes;
        }
    }

    //
    // If forced connect, removed entry completely
    //

    if (fIgnoreRefCount)
    {
        pConnTable->ClearEntry(pConnection->szEntry);           
    }
    else
    {
        pConnTable->RemoveEntry(pConnection->szEntry);     
    }
 
    return (DWORD)lRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmdial\himetric.cpp ===
//+----------------------------------------------------------------------------
//
// File:     himetric.cpp     
//
// Module:   Connection Manager
//
// Synopsis: Routines to convert Pixels to Himetric and vice versa
//
// Copyright (c) 1998 Microsoft Corporation
//
// Author:   nickball Created   02/10/98
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"

#pragma hdrstop


#define HIMETRIC_PER_INCH 2540L

SIZE g_sizePixelsPerInch;

//+------------------------------------------------------------------------
//
//  Function:   InitPixelsPerInch
//
//  Synopsis:   Initializing coordinate mapping for screen pixels
//
//  Returns:    HRESULT; S_OK on success, E_OUTOFMEMORY otherwise
//
//-------------------------------------------------------------------------

void
InitPixelsPerInch(VOID)
{
    HDC     hdc;

    hdc = GetDC(NULL);
    if (!hdc)
        goto Error;

    g_sizePixelsPerInch.cx = GetDeviceCaps(hdc, LOGPIXELSX);
    g_sizePixelsPerInch.cy = GetDeviceCaps(hdc, LOGPIXELSY);

    ReleaseDC(NULL, hdc);

Cleanup:
    return;

Error:
    g_sizePixelsPerInch.cx = 96;
    g_sizePixelsPerInch.cy = 96;
    goto Cleanup;
}


//+---------------------------------------------------------------
//
//  Function:   HimetricFromHPix
//
//  Synopsis:   Converts horizontal pixel units to himetric units.
//
//----------------------------------------------------------------

long
HimetricFromHPix(int iPix)
{
    if (!g_sizePixelsPerInch.cx)
        InitPixelsPerInch();

    return MulDiv(iPix, HIMETRIC_PER_INCH, g_sizePixelsPerInch.cx);
}

//+---------------------------------------------------------------
//
//  Function:   HimetricFromVPix
//
//  Synopsis:   Converts vertical pixel units to himetric units.
//
//----------------------------------------------------------------

long
HimetricFromVPix(int iPix)
{
    if (!g_sizePixelsPerInch.cy)
        InitPixelsPerInch();

    return MulDiv(iPix, HIMETRIC_PER_INCH, g_sizePixelsPerInch.cy);
}

//+---------------------------------------------------------------
//
//  Function:   HPixFromHimetric
//
//  Synopsis:   Converts himetric units to horizontal pixel units.
//
//----------------------------------------------------------------

int
HPixFromHimetric(long lHi)
{
    if (!g_sizePixelsPerInch.cx)
        InitPixelsPerInch();

    return MulDiv(g_sizePixelsPerInch.cx, lHi, HIMETRIC_PER_INCH);
}

//+---------------------------------------------------------------
//
//  Function:   VPixFromHimetric
//
//  Synopsis:   Converts himetric units to vertical pixel units.
//
//----------------------------------------------------------------

int
VPixFromHimetric(long lHi)
{
    if (!g_sizePixelsPerInch.cy)
        InitPixelsPerInch();

    return MulDiv(g_sizePixelsPerInch.cy, lHi, HIMETRIC_PER_INCH);
}

//+---------------------------------------------------------------------------
//
//  Function:   PixelFromHMRect
//
//  Synopsis:   Converts a Himetric RECTL to a Pixel RECT
//
//----------------------------------------------------------------------------

void
PixelFromHMRect(RECT *prcDest, RECTL *prcSrc)
{
    prcDest->left = HPixFromHimetric(prcSrc->left);
    prcDest->top = VPixFromHimetric(prcSrc->top);
    prcDest->right = HPixFromHimetric(prcSrc->right);
    prcDest->bottom = VPixFromHimetric(prcSrc->bottom);
}

//+---------------------------------------------------------------------------
//
//  Function:   HMFromPixelRect
//
//  Synopsis:   Converts a Pixel RECT to a Himetric RECTL
//
//----------------------------------------------------------------------------

void
HMFromPixelRect(RECTL *prcDest, RECT *prcSrc)
{
    prcDest->left = HimetricFromHPix(prcSrc->left);
    prcDest->top = HimetricFromVPix(prcSrc->top);
    prcDest->right = HimetricFromHPix(prcSrc->right);
    prcDest->bottom = HimetricFromVPix(prcSrc->bottom);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmdial\lanawait.cpp ===
//+----------------------------------------------------------------------------
//
// File:	 lanawait.cpp
//
// Module:	 CMDIAL32.DLL
//
// Synopsis: Implementation for the workaround to make CM wait for DUN to 
//           register its LANA for an internet connection before beginning 
//           the tunnel portion of a double dial connection.
//
// Copyright (c) 1996-1999 Microsoft Corporation
//
// Author:	 quintinb   Created Header    08/17/99
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"

const TCHAR* const c_pszCmEntryLanaTimeout = TEXT("LanaTimeout"); 

//+---------------------------------------------------------------------------
//
//	Function:	LanaWait
//
//	Synopsis:	Peform the LANA wait/timeout.
//
//	Arguments:	pArgs [the ptr to ArgsStruct]
//              hwndMainDlg - hwnd of the main dlg
//
//	Returns:	BOOL    TRUE=succes, FALSE=wait not performed.
//
//----------------------------------------------------------------------------
BOOL LanaWait(
    ArgsStruct *pArgs,
    HWND       hwndMainDlg
)
{
    BOOL    fLanaDone = FALSE;
    BOOL    fLanaAbort = FALSE;

    if (IsLanaWaitEnabled())
    {
        CMTRACE(TEXT("Performing Lana Wait!!"));

        WNDCLASSEX WndClass;
        HWND     hWnd;
    
        ZeroMemory(&WndClass, sizeof(WNDCLASSEX));

        WndClass.cbSize        = sizeof(WNDCLASSEX);
        WndClass.lpfnWndProc   = (WNDPROC)LanaWaitWndProc;
        WndClass.hInstance     = g_hInst;
        WndClass.hIcon         = LoadIconU(NULL, IDI_APPLICATION);
        WndClass.hCursor       = LoadCursorU(NULL, IDC_ARROW);
        WndClass.hbrBackground = (HBRUSH)GetStockObject (WHITE_BRUSH);
        WndClass.lpszClassName = LANAWAIT_CLASSNAME;

        MYVERIFY(RegisterClassExU(&WndClass));

        if (!(hWnd = CreateWindowExU(0,
                                     LANAWAIT_CLASSNAME,
                                     LANAWAIT_WNDNAME,
                                     WS_OVERLAPPEDWINDOW,
                                     CW_USEDEFAULT,
                                     CW_USEDEFAULT,
                                     CW_USEDEFAULT,
                                     CW_USEDEFAULT,
                                     (HWND)NULL,
                                     NULL,
                                     g_hInst,
                                     (LPVOID)pArgs)))
        {
            CMTRACE1(TEXT("CreateWindow LANA failed, LE=0x%x"), GetLastError());
        }
        else
        {
            MSG msg;
            ZeroMemory(&msg, sizeof(MSG));

            while (GetMessageU(&msg, NULL, 0, 0))
            {
                //
                // Since we have no accelerators, no need to call
                // TranslateAccelerator here.
                //

                TranslateMessage(&msg);
                DispatchMessageU(&msg);

                //
                // If we received a msg from the top-level
                // window, then the dial is being canceled
                //

                if (pArgs->uLanaMsgId == msg.message)
                {
                    fLanaAbort = TRUE;
                    DestroyWindow(hWnd); //break;
                }
            }
        
            UnregisterClassU(LANAWAIT_CLASSNAME, g_hInst);
            SetActiveWindow(hwndMainDlg);

            //
            // once we've run it once, we don't need to run it again 
            // until after reboot or switch to a different domain.
            // it's safe to just run it every time.
            //

            if (!fLanaAbort)
            {   
                fLanaDone = TRUE;
            }
       }
    }
    else
    {
        CMTRACE(TEXT("Lana Wait is disabled"));
        fLanaDone = TRUE;
    }

    return fLanaDone;
}



//+----------------------------------------------------------------------------
//  Function    LanaWaitWndProc
//
//  Synopsis    Window function for the main app.  Waits for device change
//              message. This funcion will time out if device change is
//              not recieived in LANA_TIMEOUT_DEFAULT secs.
//
//-----------------------------------------------------------------------------

LRESULT APIENTRY LanaWaitWndProc(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
)
{
    switch (message)
    {
        case WM_CREATE:
            {
            UINT    uiTimeout = ((ArgsStruct *)((CREATESTRUCT *)lParam)->lpCreateParams)
                                    ->piniService->GPPI(c_pszCmSection, c_pszCmEntryLanaTimeout, LANA_TIMEOUT_DEFAULT);

            CMTRACE1(TEXT("Lana timeout time = %u ms"), uiTimeout*1000);
            //
            // set up the timer
            //
	        SetTimer(hWnd, LANA_TIME_ID, uiTimeout*1000, (TIMERPROC)NULL);
            }
			break;

        //
		// This is the message we are waiting for the LANA is registered
        //
        case WM_DEVICECHANGE:
            {
            PDEV_BROADCAST_HDR   pDev;
            PDEV_BROADCAST_NET   pNetDev;
               
            CMTRACE(TEXT("Lana - WM_DEVICECHANGE"));

			if (wParam == DBT_DEVICEARRIVAL)
            {
		        pDev = (PDEV_BROADCAST_HDR) lParam;
				if (pDev->dbch_devicetype != DBT_DEVTYP_NET)
                {
					break;
				}

				pNetDev = (PDEV_BROADCAST_NET) pDev;
				if (!(pNetDev->dbcn_flags & DBTF_SLOWNET))
                {
					break;
				}

                CMTRACE(TEXT("Got Lana registration!!!"));
                //
				// Must wait for Broadcast to propigate to all windows. 
                //
                KillTimer(hWnd, LANA_TIME_ID);

                CMTRACE1(TEXT("Lana propagate time = %u ms"), LANA_PROPAGATE_TIME_DEFAULT*1000);

                SetTimer(hWnd, LANA_TIME_ID, LANA_PROPAGATE_TIME_DEFAULT*1000, (TIMERPROC)NULL);
			}
            }
			break;	 


			//  If we get this message we timed out on the device change

        case WM_TIMER:  
            if (wParam == LANA_TIME_ID)
            {
                CMTRACE(TEXT("Killing LANA window..."));
                DestroyWindow(hWnd); 		            
	        }
		    break;
	  
        case WM_DESTROY:
			KillTimer(hWnd, LANA_TIME_ID);
            PostQuitMessage(0);
            break;
       
        default:
            return DefWindowProcU(hWnd, message, wParam, lParam);
    }

    return 0;
}



//+----------------------------------------------------------------------------
//  Function    IsLanaWaitEnabled
//
//  Synopsis    Check to see if the lana wait is enabled.  It's enabled if 
//              reg key value has a non-zero value.
//
//  Arguments   NONE
//
//  Return      TRUE - enabled
//              FALSE  - disabled
//
//-----------------------------------------------------------------------------

BOOL IsLanaWaitEnabled()
{
    BOOL fLanaWaitEnabled = FALSE;
    HKEY hKeyCm;
    DWORD dwType;
    DWORD dwSize = sizeof(DWORD);

    if (RegOpenKeyExU(HKEY_LOCAL_MACHINE,
                      c_pszRegCmRoot,
                      0,
                      KEY_QUERY_VALUE ,
                      &hKeyCm) == ERROR_SUCCESS)
    {
        LONG lResult = RegQueryValueExU(hKeyCm, ICM_REG_LANAWAIT, NULL, &dwType, (BYTE*)&fLanaWaitEnabled, &dwSize);

        if ((lResult == ERROR_SUCCESS) && (dwType == REG_DWORD) && (dwSize == sizeof(DWORD)) && fLanaWaitEnabled)
        {
            fLanaWaitEnabled = TRUE;
        }

        RegCloseKey(hKeyCm);
    }

    return fLanaWaitEnabled;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmdial\lanawait.h ===
//+----------------------------------------------------------------------------
//
// File:     lanawait.h     
//
// Module:   CMDIAL32.DLL
//
// Synopsis: Definitions for the workaround to make CM wait for DUN to 
//           register its LANA for an internet connection before beginning 
//           the tunnel portion of a double dial connection.
//
// Copyright (c) 1996-1998 Microsoft Corporation
//
// Author:   quintinb   Created Header      08/17/99
//
//+----------------------------------------------------------------------------
#ifdef  LANA_WAIT
#ifndef _LANAWAIT_H_ 
#define _LANAWAIT_H_ 

#include <dbt.h>

//----------------------------------------------------------------------

#define ICM_REG_LANAWAIT            TEXT("Lana")
#define LANAWAIT_CLASSNAME          TEXT("CmLana")
#define LANAWAIT_WNDNAME            TEXT("CmLanaWnd")

#define LANA_TIMEOUT_DEFAULT        20          // 20 secs
#define LANA_PROPAGATE_TIME_DEFAULT 3           // 3 secs
#define LANA_TIME_ID                2233

//----------------------------------------------------------------------

LRESULT APIENTRY LanaWaitWndProc(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
);

BOOL IsLanaWaitEnabled();

#endif // _LANAWAIT_H_
#endif // LANA_WAIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmdial\modaldlgclass.cpp ===
//+----------------------------------------------------------------------------
//
// File:     modaldlgclass.cpp     
//
// Module:   CMDIAL32.DLL
//
// Synopsis: Modal Dialog Class implementation.
//
// Copyright (c) 1998 Microsoft Corporation
//
// Author:   nickball Created    10/05/98
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"

//
//	Please see pnpu\common\source for the actual source here.
//

#include "modaldlg.h"
#include "modaldlg.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmdial\makefile.inc ===
$(O)\cmdial32.def: cmdial32.src
    $(C_PREPROCESSOR) $** > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmdial\init.cpp ===
//+----------------------------------------------------------------------------
//
// File:     init.cpp
//
// Module:   CMDIAL32.DLL
//
// Synopsis: The various initialization routines live here.
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   nickball   Created    2/11/98
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"
#include "ConnStat.h"
#include "profile_str.h"
#include "log_str.h"
#include "dial_str.h"
#include "userinfo_str.h"
#include "pwd_str.h"

const TCHAR* const c_pszCmEntryHideUserName             = TEXT("HideUserName"); 
const TCHAR* const c_pszCmEntryHidePassword             = TEXT("HidePassword"); 
const TCHAR* const c_pszCmEntryDisableBalloonTips       = TEXT("HideBalloonTips");

//+----------------------------------------------------------------------------
//
// Function:  RegisterBitmapClass
//
// Synopsis:  Helper function to encapsulate registration of our bitmap class
//
// Arguments: HINSTANCE hInst - HINSTANCE to associate registration with
//
// Returns:   DWORD - error code 
//
// History:   nickball    Created Header    2/9/98
//
//+----------------------------------------------------------------------------
DWORD RegisterBitmapClass(HINSTANCE hInst) 
{
    //
    // Register Bitmap class
    //

    WNDCLASSEX wcClass;

    ZeroMemory(&wcClass,sizeof(WNDCLASSEX));
    wcClass.cbSize = sizeof(WNDCLASSEX);
    wcClass.lpfnWndProc = BmpWndProc;
    wcClass.cbWndExtra = sizeof(HBITMAP) + sizeof(LPBITMAPINFO);
    wcClass.hInstance = hInst;
    wcClass.lpszClassName = ICONNMGR_BMP_CLASS;
    
    if (!RegisterClassExU(&wcClass)) 
    {
        DWORD dwError = GetLastError();

        CMTRACE1(TEXT("RegisterBitmapClass() RegisterClassEx() failed, GLE=%u."), dwError);

        //
        // Only fail if the class does not already exist
        //

        if (ERROR_CLASS_ALREADY_EXISTS != dwError)
        {
            return dwError;
        }
    }      

    return ERROR_SUCCESS;
}

//+----------------------------------------------------------------------------
//
// Function:  ReleaseIniObjects
//
// Synopsis:  Encapsulates freeing of ini objects
//
// Arguments: ArgsStruct *pArgs - Ptr to global args struct
//
// Returns:   Nothing
//
// History:   nickball    Created    2/12/98
//
//+----------------------------------------------------------------------------
void ReleaseIniObjects(ArgsStruct *pArgs)
{
    if (pArgs->piniProfile)
    {
        delete pArgs->piniProfile;
        pArgs->piniProfile = NULL;
    }

    if (pArgs->piniService)
    {
        delete pArgs->piniService;
        pArgs->piniService = NULL;
    }

    if (pArgs->piniBoth)
    {
        delete pArgs->piniBoth;
        pArgs->piniBoth = NULL;
    }

    if (pArgs->piniBothNonFav)
    {
        delete pArgs->piniBothNonFav;
        pArgs->piniBothNonFav = NULL;
    }
}    

//+----------------------------------------------------------------------------
//
// Function:  CreateIniObjects
//
// Synopsis:  Encapsulates creation of ini objects
//
// Arguments: ArgsStruct *pArgs - Ptr to global args struct
//
// Returns:   LRESULT - Failure code
//
// History:   nickball    Created    2/12/98
//
//+----------------------------------------------------------------------------
LRESULT CreateIniObjects(ArgsStruct *pArgs)
{ 
    MYDBGASSERT(pArgs);

    if (NULL == pArgs)
    {
        return ERROR_INVALID_PARAMETER;
    }

    LRESULT lRes = ERROR_SUCCESS;

    //
    // Try to create each ini object
    //
    
    pArgs->piniProfile = new CIni; // &iniProfile;

    if (NULL == pArgs->piniProfile)
    {
        lRes = ERROR_NOT_ENOUGH_MEMORY;    
    }

    pArgs->piniService = new CIni; // &iniService;

    if (NULL == pArgs->piniProfile)
    {
        lRes = ERROR_NOT_ENOUGH_MEMORY;    
    }

    pArgs->piniBoth = new CIni; // &iniBoth;

    if (NULL == pArgs->piniProfile)
    {
        lRes = ERROR_NOT_ENOUGH_MEMORY;    
    }

    pArgs->piniBothNonFav = new CIni; //&iniBothNonFav

    if (NULL == pArgs->piniBothNonFav)
    {
        lRes = ERROR_NOT_ENOUGH_MEMORY;    
    }

    //
    // If something failed, release CIni classes
    //

    if (ERROR_SUCCESS != lRes)
    {
        if (pArgs->piniProfile)
        {
            delete pArgs->piniProfile;
        }

        if (pArgs->piniService)
        {
            delete pArgs->piniService;
        }

        if (pArgs->piniBoth)
        {
            delete pArgs->piniBoth;
        }

        if (pArgs->piniBothNonFav)
        {
            delete pArgs->piniBothNonFav;
        }
    }

    return lRes;
}

//+----------------------------------------------------------------------------
//
// Function:  InitProfile
//
// Synopsis:  Initialize the profile based upon the entry name.  
//
// Arguments: ArgsStruct *pArgs - Ptr to global Args struct           
//            LPCTSTR  pszEntry - Ptr to name of Ras entry
//
// Returns:   HRESULT - Failure code.
//
// History:   nickball    Created    2/9/98
//
//+----------------------------------------------------------------------------
HRESULT InitProfile(ArgsStruct *pArgs, LPCTSTR pszEntry)
{
    MYDBGASSERT(pArgs);
    MYDBGASSERT(pszEntry);
    
    if (NULL == pArgs || NULL == pszEntry)
    {
        return E_POINTER;
    }
    
    if (0 == pszEntry[0])
    {
        return E_INVALIDARG;
    }

    HRESULT hrRes = S_OK;

    LPTSTR pszProfileName = (LPTSTR) CmMalloc(sizeof(TCHAR) * (MAX_PATH + 1));

    if (pszProfileName)
    {
        if (FALSE == ReadMapping(pszEntry, pszProfileName, MAX_PATH, pArgs->fAllUser, TRUE)) // TRUE == bExpandEnvStrings
        {
            //
            // No mappings key, report failure
            //

            LPTSTR pszTmp = CmFmtMsg(g_hInst,IDMSG_DAMAGED_PROFILE);
            MessageBoxEx(NULL, pszTmp, pszEntry, MB_OK|MB_ICONSTOP, LANG_USER_DEFAULT);
            CmFree(pszTmp);
     
            hrRes = E_FAIL;
        }
        else
        {
            MYDBGASSERT(!(*pArgs->piniProfile->GetFile())); // can't have a profile yet
            //
            // Migration code is called here because this is the first place where 
            // we get the path to the cmp. The migration code moves the cmp entries 
            // to the registry and then replaces the cmp file
            //
            
            /*
            //
            // This was commented out because it created some issues when trying to import old
            // profiles. It migrated some values into the wrong sections of the registry.
            //
            // MoveCmpEntriesToReg(pszEntry, pszProfileName, pArgs->fAllUser);
            //
            */

            InitProfileFromName(pArgs, pszProfileName);
        }
    }
    else
    {
        hrRes = E_OUTOFMEMORY;
        CMASSERTMSG(FALSE, TEXT("InitProfile -- Unable to allocate memory for the profile name."));
    }

    CmFree(pszProfileName);
    
    return hrRes;
}

//+---------------------------------------------------------------------------
//
//  Function:   InitProfileFromName
//
//  Synopsis:   Helper function to intialize the service 
//              profile based upon a service name
//
//  Arguments:  ArgsStruct *pArgs - Pointer to global args struct
//              LPCTSTR pszArg     - Full path to .CMP file
//
//  Returns:    Nothing - Use *pArgs->piniProfile->GetFile() to test success 
//
//  History:    a-nichb - Created - 4/22/97
//----------------------------------------------------------------------------

void InitProfileFromName(ArgsStruct *pArgs, 
                            LPCTSTR pszArg)
{
    MYDBGASSERT(pArgs);
    MYDBGASSERT(pszArg);

    if (NULL == pArgs || NULL == pszArg)
    {
        return;
    }

    //
    // Clear INI objects to make sure there are no misunderstandings about
    // there viability should we be forced to make an early return.
    //

    pArgs->piniProfile->Clear();
    pArgs->piniService->Clear();
    pArgs->piniBoth->Clear();
    pArgs->piniBothNonFav->Clear();

    //
    // Verify the existence of the file 
    //

    if (FALSE == FileExists(pszArg)) 
    {
        return;
    }

    //
    // Initialize the profile INI object with the filename
    //
    
    pArgs->piniProfile->SetHInst(g_hInst);
    pArgs->piniProfile->SetFile(pszArg);

    //
    // Check the service name
    //

    LPTSTR pszService = pArgs->piniProfile->GPPS(c_pszCmSection, c_pszCmEntryCmsFile);

    if (*pszService)        
    {
        //
        // We have a service file, build the full path to the file
        //

        LPTSTR pszFullServiceName = CmBuildFullPathFromRelative(pArgs->piniProfile->GetFile(), pszService);

        if (pszFullServiceName)
        {
            MYDBGASSERT(*pszFullServiceName); // should be something there

            pArgs->piniService->SetHInst(pArgs->piniProfile->GetHInst());
            pArgs->piniService->SetFile(pszFullServiceName);

            //
            // Get the service name, we use this throughout
            //

            LPTSTR pszTmp = GetServiceName(pArgs->piniService);
                
            MYDBGASSERT(pszTmp && *pszTmp);

            if (pszTmp)
            {
                lstrcpyU(pArgs->szServiceName, pszTmp);
            }

            CmFree(pszTmp);

            //
            // Both: The .CMP file takes precedence over the .CMS 
            // file, so specify the .CMP file as the primary file
            //

            pArgs->piniBoth->SetHInst(pArgs->piniProfile->GetHInst());
            pArgs->piniBoth->SetFile(pArgs->piniService->GetFile());
            pArgs->piniBoth->SetPrimaryFile(pArgs->piniProfile->GetFile());

            pArgs->piniBothNonFav->SetHInst(pArgs->piniProfile->GetHInst());
            pArgs->piniBothNonFav->SetFile(pArgs->piniService->GetFile());
            pArgs->piniBothNonFav->SetPrimaryFile(pArgs->piniProfile->GetFile());

            //
            // Get whether balloon tips are enabled
            //
            pArgs->fHideBalloonTips = pArgs->piniBothNonFav->GPPB(c_pszCmSection, c_pszCmEntryDisableBalloonTips);

            //
            // Get the values of the current access point and a flag to say if
            // access points are enabled
            //
            PVOID pv = &pArgs->fAccessPointsEnabled;
            if ((ReadUserInfoFromReg(pArgs, UD_ID_ACCESSPOINTENABLED, (PVOID*)&pv)) && (pArgs->fAccessPointsEnabled))
            {
                LPTSTR pszCurrentAccessPoint = NULL;
                ReadUserInfoFromReg(pArgs, UD_ID_CURRENTACCESSPOINT, (PVOID*)&pszCurrentAccessPoint);
                if (pszCurrentAccessPoint)
                {
                    pArgs->pszCurrentAccessPoint = CmStrCpyAlloc(pszCurrentAccessPoint);
                    CmFree(pszCurrentAccessPoint);
                }
                else
                {
                    pArgs->fAccessPointsEnabled = FALSE;
                    pArgs->pszCurrentAccessPoint = CmLoadString(g_hInst, IDS_DEFAULT_ACCESSPOINT);
                }
            }
            else
            {
                pArgs->pszCurrentAccessPoint = CmLoadString(g_hInst, IDS_DEFAULT_ACCESSPOINT);
            }

            //
            // piniProfile, piniBoth, and piniBothNonFav all access the cmp and reg, set the reg path by default
            // to the one with the current access point except the piniBothNonFav which uses the base favorites
            // registry path.
            //

            //
            // Okay, here is how this all works ...
            // CIni classes have a reg path, a primary reg path, a file path, and a primary file path.
            // The reg path and the file path are checked first (the registry is accessed and if empty, then the file is checked), and
            // then the primary reg path and the primary file path are checked (again the registry is checked first and if the
            // setting doesn't exist then it checks the file).  This allows settings in the primary file/reg to override settings in the
            // file/reg.  This allows us to have cmp settings override settings in the cms by accessing the cms settings first and
            // then overwriting the setting with the value from the cmp if it exists or keeping the cms setting if the cmp is empty.
            //
            // The four CIni objects break out like this:
            // piniProfile -    reg = current favorite reg path
            //                  file = cmp file
            //                  primary reg = (nothing)
            //                  primary file = (nothing)
            //                  For direct access to the cmp settings.
            //
            // piniService -    reg = none (cms settings not in the registry).
            //                  file = cms file
            //                  primary reg = (nothing)
            //                  primary file = (nothing)
            //                  For direct access to the cms settings.
            //
            // piniBoth -       reg = none (cms settings not in the registry)
            //                  file = cms file
            //                  primary reg = current favorite reg path
            //                  primary file = cmp file
            //                  For access to any settings that can be overridden from the "cmp" and are favorites enabled (phone number
            //                  settings, which device to use, etc).
            //
            // piniBothNonFav - reg = non-favorite registry path (Software\Microsoft\Connection Manager\UserInfo\<LongService>)
            //                  file = cms file
            //                  primary reg = non-favorite registry path (Software\Microsoft\Connection Manager\UserInfo\<LongService>)
            //                  primary file = cmp file
            //                  For access to any settings that can be overridden from the "cmp" and are NOT favorites enabled
            //                  (tunnel settings, idle disconnect, logging enabled, etc.)
            //                  NOTE that the reg path and the primary reg path are the same.  That is because on writing on the
            //                  regpath value is used and I only wanted one ini object to handle non favorites settings instead of two.
            //

            LPTSTR pszRegPath = FormRegPathFromAccessPoint(pArgs);
            pArgs->piniProfile->SetRegPath(pszRegPath);
            pArgs->piniBoth->SetPrimaryRegPath(pszRegPath);
            CmFree(pszRegPath);

            pszRegPath = BuildUserInfoSubKey(pArgs->szServiceName, pArgs->fAllUser);
            MYDBGASSERT(pszRegPath);
            pArgs->piniBothNonFav->SetPrimaryRegPath(pszRegPath); // For reads
            pArgs->piniBothNonFav->SetRegPath(pszRegPath); // For writes
            CmFree(pszRegPath);
        }
        
        CmFree(pszFullServiceName);
    }
    
    CmFree(pszService);
}           


//+----------------------------------------------------------------------------
//
// Function:  GetEntryFromCmp
//
// Synopsis:  Helper function to read a value from the cmp
//
// Arguments: LPTSTR pszSectionName - The section to be accessed
//            LPTSTR pszCmpPath - The complete path to the cmp
//            LPTSTR pszEntryName - The entry to be accessed in the cmp
//
// Returns:   PVOID - Pointer to the result of cmp access
//
// History:   t-urama   Created Header  07/11/00
//
//+----------------------------------------------------------------------------
LPTSTR GetEntryFromCmp(const TCHAR *pszSectionName, LPTSTR pszEntryName, LPCTSTR pszCmpPath)
{
    BOOL bExitLoop = TRUE;
    DWORD dwSize = (MAX_PATH + 1);
    LPTSTR pszEntryBuffer = NULL;
    DWORD dwRet;
    LPCTSTR c_pszDefault = TEXT("");
    do
    {
        pszEntryBuffer = (LPTSTR)CmMalloc(dwSize*sizeof(TCHAR));
        if (pszEntryBuffer)
        {
            dwRet = GetPrivateProfileStringU(pszSectionName, pszEntryName, c_pszDefault, pszEntryBuffer, dwSize, pszCmpPath);
            if (dwRet)
            {   
                if (dwRet > dwSize)
                {
                    dwSize = dwRet + 1;
                    bExitLoop = FALSE;  //  we didn't get all of the string, try again
                    free(pszEntryBuffer);
                }
            }
            else
            {
                CmFree(pszEntryBuffer);
                return NULL;
            }

        }
        else
        {
            CmFree(pszEntryBuffer);
            return NULL;
        }
    } while (!bExitLoop);

    return pszEntryBuffer;
}

//+----------------------------------------------------------------------------
//
// Function:  ReplaceCmpFile
//
// Synopsis:  Helper function to delete the existing cmp and replace it with 
//            one which has entries for Version and CMSFile
//
// Arguments: LPTSTR pszCmpPath - The complete path to the cmp
//
// Returns:   None
//
// History:   t-urama   Created Header  07/11/00
//
//+----------------------------------------------------------------------------
void ReplaceCmpFile(LPCTSTR pszCmpPath)
{
    LPTSTR pszCMSFileEntry = (LPTSTR) GetEntryFromCmp(c_pszCmSection, (LPTSTR) c_pszCmEntryCmsFile, pszCmpPath);

    if (NULL != pszCMSFileEntry && *pszCMSFileEntry)
    {
        //
        //  Clear the CM section
        //
        WritePrivateProfileStringU(c_pszCmSection, NULL, NULL, pszCmpPath);

        //
        //  Now write back the cms file entry
        //
        WritePrivateProfileStringU(c_pszCmSection, c_pszCmEntryCmsFile, pszCMSFileEntry, pszCmpPath);
    }

    CmFree(pszCMSFileEntry);
}   

//+----------------------------------------------------------------------------
//
// Function:  FormRegPathFromAccessPoint
//
// Synopsis:  Function to create a path to the current access point in the registry
//
// Arguments: ArgsStruct *pArgs - ptr to global args structure
//
// Returns:   LPTSTR - The path to the access point. It is the caller's responsibility to free this
//
// History:   t-urama   Created Header  07/11/00
//
//+----------------------------------------------------------------------------
LPTSTR FormRegPathFromAccessPoint(ArgsStruct *pArgs)
{
    LPTSTR pszRegPath = NULL;
    
    pszRegPath = BuildUserInfoSubKey(pArgs->szServiceName, pArgs->fAllUser);
    MYDBGASSERT(pszRegPath);
    if (NULL == pszRegPath)
    {
        return NULL;
    }

    CmStrCatAlloc(&pszRegPath, TEXT("\\"));
    CmStrCatAlloc(&pszRegPath, c_pszRegKeyAccessPoints);
    CmStrCatAlloc(&pszRegPath, TEXT("\\"));

    CmStrCatAlloc(&pszRegPath, pArgs->pszCurrentAccessPoint);

    return pszRegPath;
}



//+----------------------------------------------------------------------------
//
// Function:  InitArgsForConnect
//
// Synopsis:  Encapsulates initialization of pArgs members necessary to begin dial
//
// Arguments: ArgsStruct *pArgs - Ptr to global args struct
//            LPCTSTR pszRasPhoneBook - RAS phonebook containing entry
//            LPCMDIALINFO lpCmInfo - Ptr to dial info for this dial attempt
//            BOOL fAllUser - The All User attribute of the profile
//
// Returns:   HRESULT - Failure code.
//
// History:   nickball    Created Header    02/09/98
//            nickball    pszRasPhoneBook   08/14/98
//
//+----------------------------------------------------------------------------
HRESULT InitArgsForConnect(ArgsStruct *pArgs, 
                           LPCTSTR pszRasPhoneBook,
                           LPCMDIALINFO lpCmInfo,
                           BOOL fAllUser)
{
    MYDBGASSERT(pArgs);

    if (NULL == pArgs)
    {
        return E_POINTER;
    }

    //
    // Get the flags first
    //

    pArgs->dwFlags = lpCmInfo->dwCmFlags;

    // 
    // Get the RAS phonebook for the entry, and set user mode accordngly
    //

    if (pszRasPhoneBook && *pszRasPhoneBook)
    {
        pArgs->pszRasPbk = CmStrCpyAlloc(pszRasPhoneBook);
    }

    pArgs->fAllUser = fAllUser;
  
    // 
    // Initialize pArgs->tlsTapiLink.dwOldTapiLocation to -1
    //
    pArgs->tlsTapiLink.dwOldTapiLocation = -1;

    //
    // Create stats class 
    //

    if (!OS_NT4)
    {
        pArgs->pConnStatistics = new CConnStatistics();

        if (NULL == pArgs->pConnStatistics)
        {
            return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        }
    }
    
    if (OS_W9X)
    {
        pArgs->uLanaMsgId = RegisterWindowMessageU(TEXT("ConnectionManagerLanaMsg"));
        CMTRACE1(TEXT("InitArgsForConnect() RegisterWindowMessage(\"ConnectionManagerLanaMsg\") uLanaMsgId is %d"), pArgs->uLanaMsgId);
    }
    
    if (!OS_NT5) 
    {
        //
        // Register Window Messages
        //

        pArgs->uMsgId = RegisterWindowMessageU(TEXT(RASDIALEVENT));
        if (!pArgs->uMsgId) 
        {
            CMTRACE1(TEXT("InitArgsForConnect() RegisterWindowMessage(\"InternetConnectionManager\") failed, GLE=%u."), GetLastError());
            pArgs->uMsgId = WM_RASDIALEVENT;
        }
    }

    pArgs->fChangedPassword = FALSE;
    pArgs->fWaitingForCallback = FALSE;
    
    //
    // Create new CIni classes, and set initial exit code
    //

    pArgs->dwExitCode = (DWORD)CreateIniObjects(pArgs);

    return HRESULT_FROM_WIN32(pArgs->dwExitCode);
}

//+----------------------------------------------------------------------------
//
// Function:  InitCredentials
//
// Synopsis:  Transfers credentials from either WinLogon or Reconnect
//
// Arguments: ArgsStruct *pArgs - Ptr to global args struct.
//            LPCMDIALINFO lpCmInfo - Ptr to CmInfo struct.
//            DWORD dwFlags - Flags from RasDialDlg, if any.
//            PVOID pvLogonBlob - Ptr to WinLogon blob, if any.
//            
//
// Returns:   Nothing
//
// History:   nickball    Created    09/21/99
//
//+----------------------------------------------------------------------------
HRESULT InitCredentials(ArgsStruct *pArgs, 
                        LPCMDIALINFO lpCmInfo, 
                        DWORD dwFlags,
                        PVOID pvLogonBlob)
{
    MYDBGASSERT(pArgs);
    MYDBGASSERT(pArgs->piniService);

    if (NULL == pArgs || NULL == pArgs->piniService)
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    //
    // Get credential display flags as they can dictate how we manage creds
    //

    pArgs->fHideUserName = pArgs->piniService->GPPB(c_pszCmSection, c_pszCmEntryHideUserName);            
    pArgs->fHidePassword = pArgs->piniService->GPPB(c_pszCmSection, c_pszCmEntryHidePassword);            

    //
    // If its a non-tunneling profile, the domain display default is false.
    //

    pArgs->fHideDomain = pArgs->piniService->GPPB(c_pszCmSection, 
                                                  c_pszCmEntryHideDomain, 
                                                  !IsTunnelEnabled(pArgs));   
    //
    // Handle special credential scenarios such as reconnect or WinLogon
    // (note that pvLogonBlob can be NULL if the user did a ctrl-alt-del
    // and typed a password but then used an EAP profile to connect.)
    //

    if ((OS_NT5 && !OS_NT51 && pvLogonBlob) || (OS_NT51 && (dwFlags & RCD_Logon)))
    {                     
        CMTRACE(TEXT("InitCredentials - we have been called from Winlogon"));
    
        //
        // Set the type of logon. Assert if we aren't logged on as system
        //
        pArgs->dwWinLogonType = CM_LOGON_TYPE_WINLOGON;
        MYDBGASSERT(IsLogonAsSystem());

        //
        // First make sure that integration is not explicitly disabled
        //
        if (pArgs->piniService->GPPB(c_pszCmSection, c_pszCmEntryUseWinLogonCredentials, TRUE))
        {        
            if (pvLogonBlob)
            {
                if (dwFlags & RCD_Eap) 
                {            
                    pArgs->lpEapLogonInfo = (PEAPLOGONINFO) pvLogonBlob;                
                }
                else 
                {
                    //
                    // We have a RASNOUSER struct to play with. 
                    // FYI: If the dwFlags member is set with RASNOUSER_SmartCard
                    // then the user initiated a logon with a SmartCard, but then 
                    // chose a connection that was not configured for EAP. RAS 
                    // handles that situation by setting the flag and passing an
                    // empty RASNOUSER struct. The flag is currently unused by CM.
                    //

                    pArgs->lpRasNoUser = (LPRASNOUSER) pvLogonBlob;   

                    MYDBGASSERT(sizeof(RASNOUSER) == pArgs->lpRasNoUser->dwSize);
                    CMTRACE1(TEXT("InitCredentials - pArgs->lpRasNoUser->dwFlags is 0x%x"), pArgs->lpRasNoUser->dwFlags);
                }
            }
            // else here is the ctrl-alt-del case with an EAP profile
        }
        else
        {
            CMTRACE1(TEXT("InitCredentials - pvLogonBlob ignored because %s=0"), c_pszCmEntryUseWinLogonCredentials);
        }
    }
    else
    {
        if (IsLogonAsSystem() && OS_NT51)
        {
            //
            // ICS case where a user isn't logged it
            //
            pArgs->dwWinLogonType = CM_LOGON_TYPE_ICS;
        }
        else
        {
            //
            // User is logged in
            //
            pArgs->dwWinLogonType = CM_LOGON_TYPE_USER;
        }
    }

    if (pArgs->dwFlags & FL_RECONNECT)
    {         
        //
        // Update any password data that was passed to us. In the reconnect
        // case we handed the data to CMMON at connect time so it is 
        // already encoded.
        //
 
        if (lpCmInfo->szPassword)
        {
            lstrcpyU(pArgs->szPassword, lpCmInfo->szPassword);
        }
        
        if (lpCmInfo->szInetPassword)
        {
            lstrcpyU(pArgs->szInetPassword, lpCmInfo->szInetPassword);
        }
    }
    else
    {
        if (pArgs->lpRasNoUser)
        {
            //
            // Filter credential integration.

            if (!pArgs->fHideUserName)            
            {
                lstrcpyU(pArgs->szUserName, pArgs->lpRasNoUser->szUserName);
            }

            if (!pArgs->fHidePassword)           
            {
                CmDecodePassword(pArgs->lpRasNoUser->szPassword); // password is already encoded from RasCustomDialDlg
                lstrcpyU(pArgs->szPassword, pArgs->lpRasNoUser->szPassword);
                CmEncodePassword(pArgs->lpRasNoUser->szPassword);
                CmEncodePassword(pArgs->szPassword);
            }
       
            if (!pArgs->fHideDomain)            
            {
                lstrcpyU(pArgs->szDomain, pArgs->lpRasNoUser->szDomain);
            }

            CMTRACE1(TEXT("InitCredentials: pArgs->szUserName is %s"), pArgs->szUserName);
            CMTRACE1(TEXT("InitCredentials: pArgs->szDomain is %s"), pArgs->szDomain);
        }    
    }

    CMTRACE1(TEXT("InitCredentials: pArgs->dwWinLogonType is %d"), pArgs->dwWinLogonType);
    // 
    // This is to setup (global or user) credential support. Since 
    // RAS dll isn't loaded, we don't get the credentials yet so 
    // in LoadProperties we actually get to see which creds exist.
    //
    if (FALSE == InitializeCredentialSupport(pArgs))
    {
        return S_FALSE;
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
// Function:  InitArgsForDisconnect
//
// Synopsis:  Encapsulates initialization of pArgs members necessary to hangup
//
// Arguments: ArgsStruct *pArgs - Ptr to global args struct
//            BOOL fAllUser - All User flag
//
// Returns:   HRESULT - Failure code.
//
// History:   nickball    Created Header    02/11/98
//            nickball    pszRasPhoneBook   08/14/98
//            nickball    fAllUser          10/28/98
//
//+----------------------------------------------------------------------------
HRESULT InitArgsForDisconnect(ArgsStruct *pArgs,
                              BOOL fAllUser)
{
    MYDBGASSERT(pArgs);

    if (NULL == pArgs)
    {
        return E_POINTER;
    }
    
    //
    // Set the All User attribute of the profile
    //

    pArgs->fAllUser = fAllUser;
    
    //
    // Create new CIni classes, and set initial exit code
    //

    pArgs->dwExitCode = (DWORD)CreateIniObjects(pArgs);

    return HRESULT_FROM_WIN32(pArgs->dwExitCode);
}


//+----------------------------------------------------------------------------
//
// Function:  InitLogging
//
// Synopsis:  Initialize the logging functionality for this profile.  
//
// Arguments: ArgsStruct *pArgs - Ptr to global Args struct           
//            LPCTSTR  pszEntry - Ptr to name of Ras entry
//            BOOL     fBanner  - do we want a banner for this?
//
// Returns:   HRESULT - Failure code.
//
// History:   20-Jul-2000   SumitC      Created
//
//+----------------------------------------------------------------------------
HRESULT InitLogging(ArgsStruct *pArgs, LPCTSTR pszEntry, BOOL fBanner)
{
    MYDBGASSERT(pArgs);
    MYDBGASSERT(pszEntry);

    BOOL fEnabled           = FALSE;
    DWORD dwMaxSize         = 0;
    LPTSTR pszFileDir       = NULL;
    LPTSTR pszRegPath       = NULL;
    LPTSTR pszTempRegPath   = NULL;

    //
    //  Check the params
    //

    if (NULL == pArgs || NULL == pszEntry)
    {
        return E_POINTER;
    }

    if (0 == pszEntry[0])
    {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    //
    //  Initialize the logging object (the order is important)
    //
    hr = pArgs->Log.Init(g_hInst, pArgs->fAllUser, pArgs->szServiceName);
    if (S_OK != hr)
    {
        goto Cleanup;
    }

    //
    // Accessing EnableLogging, make sure to use piniBothNonFav as this setting is
    // not favorites enabled.
    //
    fEnabled = pArgs->piniBothNonFav->GPPB(c_pszCmSection, c_pszCmEntryEnableLogging, c_fEnableLogging);

    //
    //  Now get the Max log file size and the log file directory.
    //
    dwMaxSize   = pArgs->piniService->GPPI(c_pszCmSectionLogging, c_pszCmEntryMaxLogFileSize, c_dwMaxFileSize);
    pszFileDir  = pArgs->piniService->GPPS(c_pszCmSectionLogging, c_pszCmEntryLogFileDirectory, c_szLogFileDirectory);

    hr = pArgs->Log.SetParams(fEnabled, dwMaxSize, pszFileDir);
    if (S_OK != hr)
    {
        goto Cleanup;
    }

    if (pArgs->Log.IsEnabled())
    {
        hr = pArgs->Log.Start(fBanner);
        if (S_OK != hr)
        {
            CMTRACE(TEXT("cmdial32 InitLogging - failed to start log, no logging for this connectoid"));
            goto Cleanup;
        }
    }

    CMASSERTMSG(S_OK == hr, TEXT("cmdial32 InitLogging - at end"));

Cleanup:

    CmFree(pszFileDir);

    CMTRACEHR("InitLogging", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmdial\mutexclass.cpp ===
//+----------------------------------------------------------------------------
//
// File:     mutexclass.cpp     
//
// Module:   CMDIAL32.DLL
//
// Synopsis: Mutex class implementation.
//
// Copyright (c) 1998 Microsoft Corporation
//
// Author:   quintinb	created Header	08/16/99
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"

//
//	Please see pnpu\common\source for the actual source here.
//
#include "mutex.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmdial\main.cpp ===
//+----------------------------------------------------------------------------
//
// File:     main.cpp
//
// Module:   CMDIAL32.DLL
//
// Synopsis: The main module implementing interfaces to external (RAS, 
//           InetDialHandler and internal modules (CmCustomDialDlg).
//
// Copyright (c) 1996-1999 Microsoft Corporation
//
// Author:   Dondu      Created    96'
//
// History: 
//              5/05/97     Modified    byao
//                                      added 'InetDialHandler()' for IE4
//              1/26/98     Modified    quintinb
//                                      Added RasCustomDialDlg, RasCustomEntryDlg,
//                                      RasCustomHangUp, and RasCustomDial stubs.
//              02/10/98    Modified    Heavily refvised for 1.2 architectural shift
//
//+----------------------------------------------------------------------------

#include <windows.h>

//#ifdef  WIN32_LEAN_AND_MEAN
//#include <shellapi.h>
//#endif

#include <ras.h>
#include <raserror.h>
#include <rasdlg.h>

#include "cmmaster.h"
#include <wininet.h>
#include "cmtiming.h"
#include "DynamicLib.h"

#include "shelldll.cpp"

//
// Globals
//

HINSTANCE g_hInst;

const TCHAR* const c_pszCmmgrExe = TEXT("CMMGR32.EXE");
const TCHAR* const c_pszExplorerExe = TEXT("EXPLORER.EXE");
const TCHAR* const c_pszCmstpExe = TEXT("CMSTP.EXE");
const TCHAR* const c_pszRunDll32Exe = TEXT("RUNDLL32.EXE");
const TCHAR* const c_pszRasAutoUExe = TEXT("RASAUTOU.EXE");

const TCHAR* const c_pszConnectMutex = TEXT("Connection Manager Connect - "); // Root only

#define RASDDFLAG_Reserved1 0x10000000

//+---------------------------------------------------------------------------
//
//  struct CmRasDialDlg
//
//  Description: Append CM reconnect infor mation to the end of RASDIALDLG
//
//  History:    fengsun Created     11/14/97
//
//----------------------------------------------------------------------------
struct CmRasDialDlg
{
    RASDIALDLG RasDialDlgInfo;  
    struct CmRasDialDlg* pSelf; // point to itself, used to verify CmReConnect
    DWORD  dwSignature;         // verify CmReConnect
    CMDIALINFO CmInfo;          // Reconnect information

    enum {CM_RECONNECT_SIGNATURE = 0xC6687DB5};  // To verify dwSignature
};

//+----------------------------------------------------------------------------
//
// Function:  StripTunnelSuffixW
//
// Synopsis:  Determines if a connection name string contains a suffix of 
//            " (for advanced use only)" and removes it if found.
//
// Arguments: LPWSTR pszwConnectionName - The string (connectoid name).
//
// Returns:   Nothing
//
// History:   nickball      created     1/11/00
//
//+----------------------------------------------------------------------------
void StripTunnelSuffixW(LPWSTR pszwConnectionName)
{
    MYDBGASSERT(pszwConnectionName);

    if (NULL == pszwConnectionName)
    {
        return;
    }

    //
    // On 9X we have to resolve the tunnel connectoid name to the 
    // service name by removing " (for advanced use only)" if it.
    // exists. 
    //

    if (OS_W9X)
    {
        LPWSTR pszwSuffix = GetTunnelSuffix();

        //
        // Search for suffix and truncate as necessary.
        // Note: Assumes that the service name does not match our suffix.
        //

        if (pszwSuffix)
        {           
            LPWSTR pszwTmp = CmStrStrW(pszwConnectionName, pszwSuffix); 
           
            if (pszwTmp)
            {
                CMTRACE1(TEXT("StripTunnelSuffixW - found suffix of %s"), pszwTmp);
                *pszwTmp = L'\0';
                CMTRACE1(TEXT("StripTunnelSuffixW - long service name is %s"), pszwConnectionName);
            }
        }       

        CmFree(pszwSuffix);
    }
}

//+----------------------------------------------------------------------------
//
// Function:  IsStringWithInBuffer
//
// Synopsis:  Verify whether a string go beyond the buffer.
//            
//
// Arguments: const TCHAR* pszStr - the string to be tested
//            DWORD dwSize - the size of the buffer
//
// Returns:   BOOL - TRUE if is
//
// History:   fengsun Created Header    5/22/98
//
//+----------------------------------------------------------------------------
BOOL IsStringWithInBuffer(const TCHAR* pszStr, DWORD dwSize)
{
    MYDBGASSERT(pszStr);

    //
    // Can not do strlen here.  If the data in pszStr is garbage
    // strlen can cause access voilation
    //
    for (DWORD i =0; i<dwSize; i++)
    {
        if (pszStr[i] == TEXT('\0'))
        {
            return TRUE;
        }
    }

    return FALSE;
}



//+----------------------------------------------------------------------------
//
// Function:  IsCmReconnectRequest
//
// Synopsis:  Check whether CM reconnect information is appended to RASDIALDLG
//
// Arguments: const RASDIALDLG* lpInfo - the structure to check
//
// Returns:   BOOL - TRUE if is
//
// History:   fengsun Created Header    5/22/98
//
//+----------------------------------------------------------------------------
BOOL IsCmReconnectRequest(const RASDIALDLG* lpInfo)
{
    MYDBGASSERT(lpInfo);

    if (NULL == lpInfo)
    {
        return FALSE;
    }

    CMTRACE1(TEXT("IsCmReconnectRequest - RASDIALDLG.dwFlags is 0x%x"), ((LPRASDIALDLG)lpInfo)->dwFlags);
    
    //
    // See its our reconnect case by examining the dwFlags of lpInfo
    //

    if (((LPRASDIALDLG)lpInfo)->dwFlags & RASDDFLAG_Reserved1)
    {
        //
        // Test whether we can read beyond RASDIALDLG to avoid access violation
        //

        if (!IsBadReadPtr(lpInfo, sizeof(CmRasDialDlg)) )
        {
            CmRasDialDlg* const pCmDlgInfo = (CmRasDialDlg* const)lpInfo;

            //
            // Test whether it has the flag we added
            //

            if (pCmDlgInfo->pSelf == pCmDlgInfo && 
                pCmDlgInfo->dwSignature == CmRasDialDlg::CM_RECONNECT_SIGNATURE)
            {
                //
                // Whether the reconnect information is valid
                //

                //
                // Does password seem ok?  Whether the password go beyond CmIndo.szPassword
                // We can not do strlen here.  If we have some garbage here, strlen can 
                // cauce access violation.
                //

                if (IsStringWithInBuffer(pCmDlgInfo->CmInfo.szPassword, 
                        sizeof(pCmDlgInfo->CmInfo.szPassword)) )
                {
                    //
                    // Inet Password OK?
                    //
                    if (IsStringWithInBuffer(pCmDlgInfo->CmInfo.szInetPassword, 
                        sizeof(pCmDlgInfo->CmInfo.szInetPassword)) )
                    {
                        //
                        // skip the dwFlags
                        // This is a valid reconnect request from CMMON
                        //
                        return TRUE;
                    }
                }
            }
        }
    }

    return FALSE;
}

//+----------------------------------------------------------------------------
//
// Function:  CmReConnect
//
// Synopsis:  Used specificly for CMMON to call upon reconnect
//      This function is added to fix bug 169128: RasCustomHangup not called 
//          when hangup reconnected connection.
//      In order for RAS to call RasCustomHangup, we have to call RasDialDlg.
//      CMMON calls CmReConnect with reconnect information.  CmReconnect append 
//      CM specific information to the RASDIALDLG structure then calls RasDialDlg.
//      RasCustomHangup then figures out it is a reconnect request.
//
// Arguments: LPTSTR        lpszPhonebook - Ptr to the full path and filename of the phonebook.
//            LPTSTR        lpszEntry - Ptr to the name of the phone-book entry to dial.
//            LPCMDIALINFO lpCmInfo - The reconnect information
//
// Returns:   DWORD WINAPI - Return code
//
//+----------------------------------------------------------------------------
extern "C" 
BOOL CmReConnect(LPTSTR lpszPhonebook, 
    LPTSTR lpszEntry, 
    LPCMDIALINFO lpCmInfo)
{
    CMTRACE(TEXT("CmReconnect"));

    if (OS_NT5)
    {
        //
        // Call RasDialDlg for NT5
        //
        CmRasDialDlg CmDlgInfo;
        ZeroMemory(&CmDlgInfo, sizeof(CmDlgInfo));

        CmDlgInfo.RasDialDlgInfo.dwSize = sizeof(CmDlgInfo.RasDialDlgInfo);
        CmDlgInfo.RasDialDlgInfo.dwFlags = RASDDFLAG_Reserved1;
        CmDlgInfo.CmInfo = *lpCmInfo;
        CmDlgInfo.pSelf = &CmDlgInfo;
        CmDlgInfo.dwSignature = (DWORD)CmRasDialDlg::CM_RECONNECT_SIGNATURE;

        //
        // Load rasdlg.dll
        //

        CDynamicLibrary libRasDlg(TEXT("rasdlg.dll"));

        MYDBGASSERT(libRasDlg.IsLoaded());
        typedef BOOL (WINAPI* fnRasDialDlgTYPE)(
            LPTSTR lpszPhonebook, LPTSTR lpszEntry, LPTSTR lpszPhoneNumber,
            LPRASDIALDLG lpInfo );

#ifndef UNICODE
        LPSTR pszRasDialDlgText = {"RasDialDlgA"};
#else
        LPSTR pszRasDialDlgText = {"RasDialDlgW"};
#endif

        fnRasDialDlgTYPE fnRasDialDlg = (fnRasDialDlgTYPE)libRasDlg.GetProcAddress(pszRasDialDlgText);
        if (fnRasDialDlg)
        {
            //
            // We base on the assumption that RasDialDlg passes the same pointer to RasCustomDialDlg.
            //
            if (lpszPhonebook != NULL && lpszPhonebook[0] == TEXT('\0'))
            {
                return fnRasDialDlg(NULL, lpszEntry, NULL, (RASDIALDLG*)&CmDlgInfo);
            }

            return fnRasDialDlg(lpszPhonebook, lpszEntry, NULL, (RASDIALDLG*)&CmDlgInfo);
        }

        return FALSE;
    }
    else
    {
        //
        // For non-NT5 platform, call CmCustomDialDlg directly
        //
        
        return CmCustomDialDlg(NULL,        // hwndParent
                               RCD_AllUsers, // dwFlags
                               lpszPhonebook, 
                               lpszEntry, 
                               NULL,       // lpszPhoneNumber
                               NULL,       // lpRasDialDlg,
                               NULL,       // lpRasEntryDlg,
                               lpCmInfo);

    }
}

//+----------------------------------------------------------------------------
//
// Function:  WhoIsCaller
//
// Synopsis:  Helper function to determine if we were called manually from the
//            desktop or programmatically.
//
// Arguments: dwCaller - which desktop caller.
//
// Returns:   BOOL - TRUE if the caller matches one of those specified in dwCaller.
//
// History:   nickball    Created Header    3/17/98
//
//+----------------------------------------------------------------------------
BOOL WhoIsCaller(DWORD dwCaller)
{
    BOOL bRet = FALSE;

    TCHAR szTmp[MAX_PATH + 1];
    ZeroMemory(szTmp, sizeof(szTmp));

    //
    // Get the path of the calling process
    //

    MYVERIFY(GetModuleFileNameU(GetModuleHandleA(NULL), szTmp, MAX_PATH));      

    CMTRACE1(TEXT("WhoIsCaller() - Calling process is %s"), szTmp);

    //
    // Locate the filename part
    //

    LPTSTR pszName = StripPath(szTmp);
       
    MYDBGASSERT(pszName);

    if (pszName)
    {
        //
        // Compare against CM and Shell
        //

        if (dwCaller & DT_CMMGR)
        {
            bRet = (lstrcmpiU(pszName, c_pszCmmgrExe) == 0);
        }

        if (!bRet && dwCaller & DT_CMMON)
        {
            bRet |= (lstrcmpiU(pszName, c_pszCmMonExeName) == 0);
        }

        if (!bRet && dwCaller & DT_EXPLORER)
        {
            bRet |= (lstrcmpiU(pszName, c_pszExplorerExe) == 0);
        }
        
        if (!bRet && dwCaller & DT_CMSTP)
        {
            bRet |= (lstrcmpiU(pszName, c_pszCmstpExe) == 0);
        }

        if (!bRet && dwCaller & DT_RUNDLL32)
        {
            bRet |= (lstrcmpiU(pszName, c_pszRunDll32Exe) == 0);
        }

        if (!bRet && dwCaller & DT_RASAUTOU)
        {
            bRet |= (lstrcmpiU(pszName, c_pszRasAutoUExe) == 0);
        }

        CmFree(pszName);
    }

    return bRet;
}

//+----------------------------------------------------------------------------
//
// Function:  HandleCustomConnectRequest
//
// Synopsis:  Attempts to resolve a connect request for the specified entry by
//            examining the current state if any of that connection.
//
// Arguments: HWND hwndParent               - HWND of parent for user notification messages
//            CConnectionTable *pConnTable  - Ptr to the connection table - assumed open
//            LPCTSTR pszEntry              - The name of the service entry
//            DWORD dwFlags                 - The application flags FL_...
//            LPBOOL pfSuccess              - Ptr to flag indicating that the request was
//                                            both 1) resolved and 2) already connected
//
// Returns:   BOOL - TRUE if the request was resolved against the existing table data
//
// History:   nickball    Created     3/18/98
//
//+----------------------------------------------------------------------------
BOOL HandleCustomConnectRequest(
    HWND hwndParent,
    CConnectionTable *pConnTable,
    LPCTSTR pszEntry,
    DWORD dwFlags,
    LPBOOL pfSuccess)
{
    BOOL fResolvedInTable = FALSE;
        
    CM_CONNECTION Connection;
    ZeroMemory(&Connection, sizeof(CM_CONNECTION));

    //
    // Only if there is an existing entry do we have any work here
    //

    if (SUCCEEDED(pConnTable->GetEntry(pszEntry, &Connection)))
    {
        *pfSuccess = TRUE; // assume the best

        //
        // There is a connection entry for this service, examine state.
        //
        
        if (CM_RECONNECTPROMPT != Connection.CmState)
        {
            fResolvedInTable = TRUE; // we can handle it here
            
            //
            // The entry is connecting, connected, or disconnecting. If its a manual
            // connection just notify the user, otherwise check the exact state.
            //
            
            if (dwFlags & FL_DESKTOP) // Set in CMMGR
            {                                       
                NotifyUserOfExistingConnection(hwndParent, &Connection, FALSE);
            }
            else
            {                       
                //
                // Only if we are actually connected can we safely succeed.
                //
                
                if (CM_CONNECTED != Connection.CmState)
                {
                    *pfSuccess = FALSE;
                }
                else
                {
                    MYVERIFY(SUCCEEDED(pConnTable->AddEntry(Connection.szEntry, Connection.fAllUser))); // just bump ref
                }
            }
        }
        else
        {
            //
            // We must be in RECONNECT mode, if this connect request is 
            // from another source, tell CMMON to stop its monitoring. 
            // 

            if (!(dwFlags & FL_RECONNECT))
            {
                //
                // Its not a reconnect, so notify CMMON
                //

                HangupNotifyCmMon(pConnTable, Connection.szEntry);
            }
        }
    }

    return fResolvedInTable;
}

//+---------------------------------------------------------------------------
//
//  Function:   InetDialHandler
//
//  Synopsis:   Ansi and only form of the AutoDial handler . 
//
//  Arguments:  hwndParent[IN]      Handle to parent window. No longer ignored.
//              pszConnectoid[IN]   Connectoid name
//              dwFlags[IN]         Custom dial handler execution flags
//                                  Current the following flags are supported
//                                          INTERNET_CUSTOMDIAL_CONNECT 
//                                          INTERNET_CUSTOMDIAL_UNATTENDED
//                                          INTERNET_CUSTOMDIAL_DISCONNECT
//                                  These flags will be passed from WININET
//              lpdwRasError[OUT]   RasError code returned from ICM
//
//              Returns: The return type is different than one defined in wininet.h
//              TRUE:    This handler handled the dial request (connected or not)
//              FALSE:   This handler didn't handle the dial request
//
//              When returning TRUE, lpdwRasError is set to:
//                  ERROR_SUCCESS:              Call completed
//                  ERROR_USER_DISCONNECTION:   User cancelled dial request
//                  <other ras error>           Dial attempt failed.
//
//              This is a synchronous call. It should not return until the operation is complete.
//
//  Note:       We do not provide a wide form of this API as it is stored in 
//              the szAutoDialfunc member of the RASENTRY downlevel. If the 
//              wide form were avialable, RASAUTOU.EXE would call the function
//              (it appends A or W to the name that it finds in AutoDialFunc),
//              which would be inappropriate because the semantics of the 
//              parameters differ even though the function prototypes match.
//
//  History:    byao        Created                                                 - 05/05/97
//              quintinb    Rewrote to use InetDialHandlerW                         - 03/09/99
//              nickball    Removed InetDialHandlerW as it confuses RasAuto on NT4  - 07/28/99
//              quintinb    Always return true if connect request handled #390890   - 08/19/99
//
//----------------------------------------------------------------------------
extern "C" DWORD WINAPI InetDialHandler(HWND hwndParent, 
    LPCSTR pszConnectoid,
    DWORD dwFlags, 
    LPDWORD lpdwRasError) 
{
    MYDBGASSERT(pszConnectoid);
    MYDBGASSERT(lpdwRasError);
    CMTRACE(TEXT("InetDialHandler"));

    TCHAR           szProfilePath[MAX_PATH+1];
    LPWSTR          pszwConnectionName              = NULL;
    LPTSTR          pszRasPhoneBook                 = NULL;
    LPCMDIALINFO    lpCmInfo                        = NULL;
    BOOL            bRet                            = TRUE; // Read all comments before modifying this init value.
    BOOL            bAllUser;

    //
    // Check whether the parameters are valid
    //
    if (lpdwRasError)
    {
        if (! ((INTERNET_CUSTOMDIAL_CONNECT == dwFlags) ||
               (INTERNET_CUSTOMDIAL_UNATTENDED == dwFlags) ||
               (INTERNET_CUSTOMDIAL_DISCONNECT == dwFlags) ||
               (INTERNET_CUSTOMDIAL_SHOWOFFLINE== dwFlags) ))
        {
            CMASSERTMSG(FALSE, TEXT("InetDialHandler called with invalid flag"));
            *lpdwRasError = ERROR_INVALID_PARAMETER;
            return FALSE;
        }

        if (!pszConnectoid || TEXT('\0') == pszConnectoid[0])
        {
            *lpdwRasError = ERROR_INVALID_PARAMETER;
            return FALSE;
        }
    }
    else
    {
        return FALSE;   
    }
    
    //
    // Make a wide copy of the connectoid name. We also want a copy so 
    // that we can modify if necessary. On 9x we will resolve tunnel
    // entry names down to the base connectoid/service name.
    //

    pszwConnectionName = SzToWzWithAlloc(pszConnectoid);

    MYDBGASSERT(pszwConnectionName);

    if (!pszwConnectionName)
    {
        *lpdwRasError = GetLastError();
        bRet = FALSE;
        goto InetDialHandlerExit;
    }
   
    StripTunnelSuffixW(pszwConnectionName);

    //
    // Handle the Hangup case 
    //

    if (INTERNET_CUSTOMDIAL_DISCONNECT == dwFlags)
    {   
        *lpdwRasError = CmCustomHangUp(NULL, pszwConnectionName, TRUE, FALSE);
        bRet = (ERROR_SUCCESS == *lpdwRasError);
        goto InetDialHandlerExit;       
    }
    
    //
    // Its a connect request, setup CmInfo flags and call
    // 
    
    lpCmInfo = (LPCMDIALINFO) CmMalloc(sizeof(CMDIALINFO));
    
    if (NULL == lpCmInfo)
    {
        *lpdwRasError = ERROR_NOT_ENOUGH_MEMORY;
        bRet = FALSE;
        goto InetDialHandlerExit;       
    }

    if (INTERNET_CUSTOMDIAL_UNATTENDED == dwFlags ) 
    {
        //
        // Unattended dialing mode has been requested
        //

        lpCmInfo->dwCmFlags |= FL_UNATTENDED;
    }

    //
    // Note: Treat INTERNET_CUSTOMDIAL_SHOWOFFLINE the same as INTERNET_CUSTOMDIAL_CONNECT
    //

    bAllUser = ReadMapping(pszwConnectionName, szProfilePath, (sizeof(szProfilePath)/sizeof(TCHAR)), TRUE, TRUE); // TRUE == fAllUser, TRUE == bExpandEnvStrings

    if (FALSE == bAllUser)
    {
        if (FALSE == ReadMapping(pszwConnectionName, szProfilePath, (sizeof(szProfilePath)/sizeof(TCHAR)), FALSE, TRUE)) // FALSE == fAllUser, TRUE == bExpandEnvStrings
        {
            //
            // No mapping, no connection
            //
        
            *lpdwRasError = ERROR_INVALID_PARAMETER;
            bRet = FALSE;
            goto InetDialHandlerExit;
        }
        
        //
        // We have a single user profile path. If this is NT5, build a phonebook path
        //
        
        MYDBGASSERT(OS_NT5);

        if (OS_NT5)
        {
            pszRasPhoneBook = GetRasPbkFromNT5ProfilePath(szProfilePath);
            MYDBGASSERT(pszRasPhoneBook);
        }
    }
    
    //
    // InetDialHandler is usually an auto-dial case. 
    // Exceptions are:
    //      1) When called from WinLogon.exe on NT4.          NT #370311
    //      2) When called from Rundll32.exe.on any platform. 9x #127217
    //

    if ((FALSE == IsLogonAsSystem()) && (FALSE == WhoIsCaller(DT_RUNDLL32)))
    {
        lpCmInfo->dwCmFlags |= FL_AUTODIAL;
    }

    //
    // We set the error code based on whether or not we connected. However, 
    // we should always return TRUE to indicate to WININET, etc. that we 
    // handled the connection request (if we did actually handle it). 
    // Otherwise the caller (eg.IE) will try to dial its own dialer. #390890
    //

    if (CmCustomDialDlg(hwndParent, 
                        bAllUser ? RCD_AllUsers : RCD_SingleUser, 
                        pszRasPhoneBook, 
                        pszwConnectionName, 
                        NULL, 
                        NULL, 
                        NULL,
                        lpCmInfo))
    {
        *lpdwRasError = ERROR_SUCCESS;
    }
    else
    {
        *lpdwRasError = ERROR_USER_DISCONNECTION;
    }

InetDialHandlerExit:

    CmFree(pszRasPhoneBook);
    CmFree(lpCmInfo);
    CmFree(pszwConnectionName);

    CMTRACE2(TEXT("InetDialHandler returns %u with *lpdwRasError %u"), bRet, *lpdwRasError);

    return bRet; 
}

//+----------------------------------------------------------------------------
//
// Function:  AutoDialFunc
//
// Synopsis:  The original AutoDial callback function, provided for backward 
//            compatibility.
//
// Arguments: HWND hwndParent - The hwnd of the caller.
//            LPCTSTR pszEntry - The name of the connection to be dialed
//            DWORD dwFlags - Specific behaviour for the dial session.
//            LPDWORD pdwRetCode - Buffer for return code.
//
// Returns:   BOOL WINAPI - TRUE on success
//
// History:   nickball    Created Header    2/5/98
//
// Note:      This is used by RAS on NT4 SP6
//
//+----------------------------------------------------------------------------
extern "C" BOOL WINAPI AutoDialFunc(HWND hwndParent, 
    LPCSTR pszEntry, 
    DWORD dwFlags,
    LPDWORD pdwRetCode) 
{
    CMTRACE(TEXT("AutoDialFunc()"));

    MYDBGASSERT(OS_NT4);

    //
    //  InetDialHandler always returns TRUE, thus we must determine success or
    //  failure from the pdwRetCode.  If this is ERROR_SUCCESS then we should
    //  return TRUE, otherwise FALSE.
    //
    InetDialHandler(hwndParent, pszEntry, dwFlags, pdwRetCode);

    BOOL bRet = (ERROR_SUCCESS == *pdwRetCode);
        
    //
    // Always override pdwRetCode to ERROR_SUCCESS or RAS will throw an 
    // unpleasant error. RAS is only interested in success or failure.
    //

    *pdwRetCode = ERROR_SUCCESS;

    CMTRACE2(TEXT("AutoDialFunc returns %u with *pdwRetCode %u"), bRet, *pdwRetCode);

    return bRet;
}

//+----------------------------------------------------------------------------
//
// Function:  CopyRasInput
//
// Synopsis:  Simple wrapper function to make copies of the parameters we
//            receive from RAS.
//
// Arguments: LPTSTR* ppszOurCopy - pointer to the string pointer to hold the return string
//            LPWSTR pszwStringFromRas - String from RAS
//
// Returns:   BOOL - returns TRUE on Success, FALSE otherwise
//
// History:   quintinb Created     4/13/99
//
//+----------------------------------------------------------------------------
BOOL CopyRasInput(LPTSTR* ppszOurCopy, LPWSTR pszwStringFromRas)
{
    if (pszwStringFromRas)
    {
#ifndef _UNICODE
        *ppszOurCopy = WzToSzWithAlloc(pszwStringFromRas);
#else
        *ppszOurCopy = CmStrCpyAllocW (pszwStringFromRas);
#endif
        return (NULL != *ppszOurCopy);
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function: RasCustomDialDlg
//
// Synopsis:  Our implementation of RasCustomDialDlg extension, analogous to 
//            RasDialDlg, but providing custom functionality.
//
// Arguments: HINSTANCE hInstDll - The HINSTANCE of the caller.
//            DWORD dwFlags - Dial flags
//            LPTSTR lpszPhonebook - Ptr to the full path and filename of the phonebook.
//            LPTSTR lpszEntry - Ptr to the name of the phone-book entry to dial.
//            LPTSTR lpszPhoneNumber - Ptr toi replacement phone number
//            LPRASDIALDLG lpInfo - Ptr to structure for additional parameters
//
// Returns:   BOOL WINAPI - TRUE on success
//
// History:   nickball    Created Header    2/5/98
//
//+----------------------------------------------------------------------------

extern "C" BOOL WINAPI RasCustomDialDlg(HINSTANCE hInstDll, 
    DWORD dwFlags, 
    LPWSTR lpszwPhonebook, 
    LPWSTR lpszwEntry, 
    LPWSTR lpszwPhoneNumber, 
    LPRASDIALDLG lpInfo,
    PVOID pVoid)
{
    MYDBGASSERT(lpszwEntry);
    MYDBGASSERT(lpszwEntry[0]);
    MYDBGASSERT(lpInfo);

    CMTRACE1(TEXT("RasCustomDialDlg() - dwFlags = 0x%x"), dwFlags);
    CMTRACE1(TEXT("RasCustomDialDlg() - (RASDIALDLG)lpInfo->dwFlags = 0x%x"), lpInfo->dwFlags);
    if (NULL == lpszwEntry || 0 == lpszwEntry[0])
    {
        return FALSE;
    }

    //
    // We have the minimum requirement of an entry name, get to work
    //

    BOOL fSuccess = TRUE;
    LPTSTR pszEntry = NULL;
    LPTSTR pszPhonebook = NULL;

    //
    // If we have a Phonebook name make a copy
    //
    fSuccess = CopyRasInput(&pszPhonebook, lpszwPhonebook);

    if (fSuccess)
    {
        //
        // If we have an entry name (always do), make a copy to work with
        //
        fSuccess = CopyRasInput(&pszEntry, lpszwEntry);

        if (fSuccess)
        {
            //
            // Its always a simple connect request, no flags, no caller ids
            // 

            CMDIALINFO CmInfo;
            ZeroMemory(&CmInfo, sizeof(CMDIALINFO));

            //
            // If this is a reconnect request from CMMON, copy the information
            //
            if (lpInfo && IsCmReconnectRequest(lpInfo))
            {
                CmInfo = ((CmRasDialDlg* )lpInfo)->CmInfo;
            }
            else
            {
                //
                // If running under the system account its never an autodial
                //

                if (FALSE == IsLogonAsSystem())
                {
                    //
                    // See where the call originated. If not a desktop scenario
                    // then set the AUTODIAL flag so that we do the right thing
                    // down the line. This is ugly, but we have no other way of
                    // making the determination. Note: That this entry point 
                    // only exists on NT5 and is only called by RAS so the perf 
                    // hit is contained and CMMGR is not a valid desktop scenario
                    // so we don't have to check for it.
                    //
                    // DT_RASAUTOU - When ICS is enabled, rasauto starts the 
                    // rasautou.exe process to dial a connection. CM used to add
                    // rasautou in the process watch list. The issue was that 
                    // it goes away after connecting, so cmmon32 thought it needed
                    // to disconnected. Now, RASAUTOU is not a watched process 
                    // and cmmon32 does not disconnect.
                    //
                    if (FALSE == WhoIsCaller(DT_EXPLORER | DT_CMSTP | DT_RASAUTOU))
                    {
                        CmInfo.dwCmFlags |= FL_AUTODIAL;
                    }
                }  

                //
                //  Note that we want to set the Unattended flag if RASDDFLAG_NoPrompt is set, unless
                //  the RASDDFLAG_LinkFailure is also set.  We only use the RAS redial on link failure
                //  when we are logging on through WinLogon where we no longer user cmmon32.exe.  Elsewhere,
                //  redial is handled by Cmmon32.exe.  However, in this one case we don't want to be in 
                //  unattended mode because the user won't have a saved password (they logged on from WinLogon)
                //  and unattended mode will just exit silently if it doesn't have all the needed info to dial.
                //
                if ((lpInfo->dwFlags & RASDDFLAG_NoPrompt) && !(lpInfo->dwFlags & RASDDFLAG_LinkFailure))
                {
                    CmInfo.dwCmFlags |= FL_UNATTENDED;
                    CMTRACE(TEXT("RasCustomDialDlg - Setting CmInfo.dwCmFlags |= FL_UNATTENDED"));
                }
            }

            //
            //  If we have a RASNOUSER struct, make sure to encode the password
            //
            LPRASNOUSER lpRasNoUser = NULL;

            if (NULL != pVoid)
            {
                if (0 == (dwFlags & RCD_Eap))
                {
                    lpRasNoUser = (LPRASNOUSER) pVoid;
                    CmEncodePassword(lpRasNoUser->szPassword);
                }
            }

            fSuccess = CmCustomDialDlg(lpInfo ? lpInfo->hwndOwner : NULL,
                                       dwFlags, 
                                       pszPhonebook, 
                                       pszEntry, 
                                       NULL, 
                                       lpInfo,
                                       NULL,
                                       &CmInfo,
                                       pVoid);

            //
            //  If we have a RASNOUSER struct, decode the password to make it plain text again
            //
            if (NULL != lpRasNoUser)
            {
                CmDecodePassword(lpRasNoUser->szPassword);
            }
        }
    }

    //
    // Cleanup and go home
    //

    CmFree(pszPhonebook);       
    CmFree(pszEntry);      

    CMTRACE1(TEXT("RasCustomDialDlg returning %d"), fSuccess);

    return fSuccess;
}

//+----------------------------------------------------------------------------
//
// Function:  RasCustomEntryDlg
//
// Synopsis:  Our implementation of RasCustomEntryDlg extension, analogous to 
//            RasEntryDlg, but providing custom functionality.
//
// Arguments: HINSTANCE hInstDll - The HINSTANCE of the caller.
//            LPTSTR lpszPhonebook - Ptr to the full path and name of the phonebook to be edited.
//            LPTSTR lpszEntry - Ptr to the name of the entry to be edited.
//            LPRASENTRYDLG lpInfo - Ptr to structure containing additional parameters.
//
// Returns:   BOOL WINAPI - TRUE on success
//
// History:   nickball    2/5/98    Created Header    
//            nickball    1/11/00   Now used on 9x, added use of function
//                                  StripTunnelSuffixW() to resolve 9x tunnel
//                                  connectoid names.
//
//+----------------------------------------------------------------------------
extern "C" BOOL WINAPI RasCustomEntryDlg(HINSTANCE hInstDll, 
    LPWSTR lpszwPhonebook, 
    LPWSTR lpszwEntry, 
    LPRASENTRYDLG lpInfo,
    DWORD dwFlags)
{
    MYDBGASSERT(lpszwEntry);
    MYDBGASSERT(lpszwEntry[0]);

    CMTRACE1(TEXT("RasCustomEntryDlg() - dwFlags = 0x%x"), dwFlags);

    if (NULL == lpszwEntry || 0 == lpszwEntry[0])
    {
        return FALSE;
    }

    //
    // We have the minimum requirement of an entry name, get to work
    //

    BOOL fSuccess = TRUE;
    LPTSTR pszEntry = NULL;
    LPTSTR pszPhonebook = NULL;

    //
    // If we have a Phonebook name, make a copy to work with
    //
    fSuccess = CopyRasInput(&pszPhonebook, lpszwPhonebook);

    if (fSuccess)
    {
        //
        // If we have an entry name (always do), make a copy to work with
        //

        fSuccess = CopyRasInput(&pszEntry, lpszwEntry);

        if (fSuccess)
        {
            StripTunnelSuffixW(pszEntry); // Assumes we'll always compile Unicode

            //
            // Its always a properties request, set the flag and dial
            // 

            LPCMDIALINFO lpCmInfo = (LPCMDIALINFO) CmMalloc(sizeof(CMDIALINFO));

            if (lpCmInfo)
            {
                lpCmInfo->dwCmFlags |= FL_PROPERTIES;
                    
                fSuccess = CmCustomDialDlg(lpInfo ? lpInfo->hwndOwner : NULL, 
                                          dwFlags, 
                                          pszPhonebook, 
                                          pszEntry, 
                                          NULL, 
                                          NULL, 
                                          lpInfo,
                                          lpCmInfo);
            }
            else
            {
                fSuccess = FALSE;
            }

            CmFree(lpCmInfo);
        }
    }

    //
    // Cleanup and go home
    //

    CmFree(pszPhonebook);
    CmFree(pszEntry);
   
    return fSuccess;
}

//+----------------------------------------------------------------------------
//
// Function:  RasCustomHangUp
//
// Synopsis:  Our implementation of the RasCustomHangUp extension, analogous to 
//            RasHangup, but providing custom functionality. This function is
//            only called on NT5
//
// Arguments: HRASCONN hRasConn - The handle of the connection to be terminated.
//
// Returns:   DWORD WINAPI - Return code
//
// History:   nickball    Created Header    2/5/98
//
//+----------------------------------------------------------------------------
extern "C" DWORD WINAPI RasCustomHangUp(HRASCONN hRasConn)
{    
    //
    // If someone is calling this function on a system other then NT5, assert.
    //

    MYDBGASSERT(OS_NT5);
    MYDBGASSERT(hRasConn);

    CMTRACE(TEXT("RasCustomHangup()"));

    DWORD dwRes = ERROR_SUCCESS;  
 
    // 
    // First try to open the table, if none found then succeed.
    //
    
    CConnectionTable ConnTable;

    if (FAILED(ConnTable.Open()))
    {
        return dwRes;
    }
      
    //
    // If we have an entry, do the Disconnect
    //

    CM_CONNECTION Connection;
    ZeroMemory(&Connection, sizeof(CM_CONNECTION));
   
    if (SUCCEEDED(ConnTable.GetEntry(hRasConn, &Connection)))
    {
        MYDBGASSERT(hRasConn == Connection.hDial || hRasConn == Connection.hTunnel);
        // 
        // Check connect state of entry. 
        // If we are already in the DISCONNECTING state, perform a simple hangup.
        //
              
        if (CM_DISCONNECTING == Connection.CmState)
        {
            //
            // Set up RAS linkage
            //
        
            RasLinkageStruct rlsRasLink;
            ZeroMemory(&rlsRasLink, sizeof(RasLinkageStruct));

            if (TRUE == LinkToRas(&rlsRasLink) && rlsRasLink.pfnHangUp)
            {
                //
                // Linkage is good, make the hangup call
                //

                dwRes = DoRasHangup(&rlsRasLink, hRasConn);
            }
            else
            {
                MYDBGASSERT(FALSE);
                dwRes = ERROR_NOT_READY;             
            }

            //
            // Cleanup
            // 

            UnlinkFromRas(&rlsRasLink);
        }        
        else
        {
            //
            // If we're still here then we are not in the middle of an existing
            // disconnect, handle disconnect as we otherwise would.
            //

            dwRes = Disconnect(&ConnTable, &Connection, FALSE, FALSE);         
        }
    }
    else
    {
        dwRes = ERROR_NOT_FOUND;
    }
    
    //
    // We are done with the table, close it now. 
    //

    MYVERIFY(SUCCEEDED(ConnTable.Close()));    
    return dwRes;     
}

//+----------------------------------------------------------------------------
//
// Function:  RasCustomDial
//
// Synopsis:  Our implementation of RasCustomDial which we don't support.
//            Provided so that we can return E_NOTIMPL to indicate our lack of 
//            support for this extension.
//
// Arguments: N/A
//
// Returns:   DWORD WINAPI - E_NOTIMPL
//
// History:   nickball    Created Header    2/5/98
//
//+----------------------------------------------------------------------------

extern "C" DWORD WINAPI RasCustomDial(
    HINSTANCE hInstDll, 
    LPRASDIALEXTENSIONS lpRasDialExtensions, 
    LPWSTR lpszPhonebook, 
    LPRASDIALPARAMSW lpRasDialParams, 
    DWORD dwNotifierType, 
    LPVOID lpvNotifier, 
    LPHRASCONN lphRasConn, 
    DWORD dwFlags)
{
    return E_NOTIMPL;
}

//+----------------------------------------------------------------------------
//
// Function:  RasCustomDeleteEntryNotify
//
// Synopsis:  Our implementation of RasCustomDeleteEntry.
//
// Arguments: 
//
// Returns:   DWORD WINAPI - 
//
// History:   quintinb    Created Header    2/5/98
//
//+----------------------------------------------------------------------------
extern "C" DWORD WINAPI RasCustomDeleteEntryNotify(LPWSTR pszPhonebook, LPWSTR pszEntry, DWORD dwFlags)
{
    CDynamicLibrary UserEnv(L"userenv.dll");
    CDynamicLibrary Advapi32(L"advapi32.dll");
    DWORD dwReturn = ERROR_INVALID_PARAMETER;
    HANDLE hImpersonationToken = NULL;   // The token of the thread
    HANDLE hPrimaryToken = NULL;         // The primary token for the new process
    LPWSTR pszShortServiceName = NULL;
    LPWSTR pszCmDirpath = NULL;
    PROCESS_INFORMATION ProcessInfo = {0};
    STARTUPINFO StartupInfo = {0};
    WCHAR szCmpPath[MAX_PATH+1] = {0};
    WCHAR szInfPath[MAX_PATH+1];
    WCHAR szParams[2*MAX_PATH+1];

    typedef BOOL (WINAPI* pfnCreateEnvironmentBlockSpec)(LPVOID*, HANDLE, BOOL);
    typedef BOOL (WINAPI* pfnDestroyEnvironmentBlockSpec)(LPVOID);
    typedef BOOL (WINAPI* pfnDuplicateTokenExSpec)(HANDLE, DWORD, LPSECURITY_ATTRIBUTES, SECURITY_IMPERSONATION_LEVEL, TOKEN_TYPE, PHANDLE);
 
    pfnCreateEnvironmentBlockSpec pfnCreateEnvironmentBlock = NULL;
    pfnDestroyEnvironmentBlockSpec pfnDestroyEnvironmentBlock = NULL;
    pfnDuplicateTokenExSpec pfnDuplicateTokenEx = NULL;

    //
    //  Are we deleting an All User or a Single User Connection
    //
    BOOL bAllUser = (RCD_AllUsers & dwFlags);

    //
    //  Assume we are impersonating until we know otherwise.  Profiles deleted from the
    //  IE Connections Tab will not be impersonating, whereas delete requests from the
    //  folder go through Netman.dll in svchost.exe and are thus impersonating.
    //
    BOOL bImpersonatingProfile = TRUE;

    //
    //  Check the params, note that pszPhoneBook could be NULL
    //
    if ((NULL == pszEntry) || (L'\0' == pszEntry[0]) || 
        ((NULL != pszPhonebook) && (L'\0' == pszPhonebook[0])))
    {
        goto exit;
    }

    //
    //  Next lets setup the impersonation Token
    //
    if (OpenThreadToken(GetCurrentThread(), 
                        TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_ASSIGN_PRIMARY,
                        TRUE, &hImpersonationToken))
    {
        //
        // Okay, we have an impersonation token.  Lets get it, duplicate it and then
        // we can use it to call CreateProcessAsUser
        //

        pfnDuplicateTokenEx = (pfnDuplicateTokenExSpec)Advapi32.GetProcAddress("DuplicateTokenEx");

        if (NULL == pfnDuplicateTokenEx)
        {
            dwReturn = GetLastError();
            CMTRACE1(TEXT("RasCustomDeleteEntry -- Unable get proc address for DuplicateTokenEx, GLE %d"), GetLastError());
            goto exit;        
        }

        if (!pfnDuplicateTokenEx(hImpersonationToken,
                                TOKEN_IMPERSONATE | TOKEN_READ | TOKEN_ASSIGN_PRIMARY | TOKEN_DUPLICATE,
                                NULL, SecurityImpersonation, TokenPrimary, &hPrimaryToken))
        {
            dwReturn = GetLastError();
            CMTRACE1(TEXT("RasCustomDeleteEntry -- DuplicateTokenEx Failed, GLE %d"), GetLastError());
            goto exit;
        }
    }
    else
    {
        bImpersonatingProfile = FALSE;
    }

    //
    //  First let's read the Mappings Key, note that we don't expand the environment strings
    //  if it is an impersonating profile.  ExpandEnvironmentStrings doesn't have the correct
    //  environment loaded sometimes when we are impersonating.  We are launching cmstp.exe
    //  with a full environment block via CreateProcessAsUser, this will take care of the
    //  expansion so there is no need.
    //
    if (FALSE == ReadMapping(pszEntry, szCmpPath, MAX_PATH, bAllUser, !bImpersonatingProfile)) // !bImpersonatingProfile == bExpandEnvStrings
    {
        //
        // No mappings key, return failure
        //
        CMASSERTMSG(FALSE, TEXT("RasCustomDeleteEntry -- ReadMapping returned FALSE, unable to find the profile."));
        dwReturn = ERROR_FILE_NOT_FOUND;
        goto exit;
    }   

    //
    //  At this point we should have a mappings value.  We need to convert that into the INF
    //  path.  CM 1.0/1.1 profiles stored their INF files in the system(32) dir.
    //  CM 1.2  Profiles store this file in the Profile directory.  Since
    //  a user could install an old profile we must try the Legacy location
    //  if the current location fails.
    //

    pszShortServiceName = CmStripPathAndExt(szCmpPath);
    pszCmDirpath = CmStripFileName(szCmpPath, TRUE); // bKeepSlash == TRUE

    if (pszShortServiceName && pszCmDirpath)
    {
        //
        //  Build the new inf location
        //
        wsprintfW(szInfPath, L"%s%s\\%s.inf", pszCmDirpath, pszShortServiceName, pszShortServiceName);

        if (!FileExists(szInfPath) && bAllUser) // if the doesn't file exists and we are all user then try the sys dir
        {
            //
            //  Looks like this is an old style profile with the inf in the system directory.
            //  Now build the old style path and see if it exists.  Note that 1.0 profiles were All User only
            //
            if (0 != GetSystemDirectoryU(szInfPath, MAX_PATH))
            {
                lstrcatU(szInfPath, L"\\");
                lstrcatU(szInfPath, pszShortServiceName);
                lstrcatU(szInfPath, L".inf");
                
                if (!FileExists(szInfPath))
                {
                    CMASSERTMSG(FALSE, TEXT("RasCustomDeleteEntry -- Unable to locate profile inf."));
                    dwReturn = ERROR_FILE_NOT_FOUND;
                    goto exit;                
                }
            }
            else
            {
                dwReturn = GetLastError();
                goto exit;
            }
        }
    } 
    else
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    lstrcpyU(szParams, L"cmstp.exe /u /s \"");
    lstrcatU(szParams, szInfPath);
    lstrcatU(szParams, L"\"");

    if (bImpersonatingProfile)
    {
        //
        //  Fill in the environment block
        //
        WCHAR* pszEnvBlock;

        pfnCreateEnvironmentBlock = (pfnCreateEnvironmentBlockSpec)UserEnv.GetProcAddress("CreateEnvironmentBlock");
        pfnDestroyEnvironmentBlock = (pfnDestroyEnvironmentBlockSpec)UserEnv.GetProcAddress("DestroyEnvironmentBlock");

        if ((NULL == pfnCreateEnvironmentBlock) || (NULL == pfnDestroyEnvironmentBlock))
        {
            dwReturn = ERROR_PROC_NOT_FOUND;
            CMTRACE(TEXT("RasCustomDeleteEntry -- Unable to load pfnCreateEnvironmentBlock Or pfnDestroyEnvironmentBlock."));
            goto exit;
        }    

        if (pfnCreateEnvironmentBlock((void**)&pszEnvBlock, hPrimaryToken, TRUE))
        {
            if (CreateProcessAsUser(hPrimaryToken,
                                    NULL,                         // lpApplicationName
                                    szParams,                     // lpCommandLine
                                    NULL,                         // pProcessAttributes
                                    NULL,                         // lpThreadAttributes
                                    FALSE,                        // bInheritHandles
                                    CREATE_UNICODE_ENVIRONMENT,   // dwCreationFlags
                                    pszEnvBlock,                  // lpEnvironment
                                    NULL,                         // lpCurrentDirectory
                                    &StartupInfo,
                                    &ProcessInfo))
            {
                CloseHandle(ProcessInfo.hProcess);
                CloseHandle(ProcessInfo.hThread);
                dwReturn = ERROR_SUCCESS;
            }
            else
            {
                dwReturn = GetLastError();
                CMTRACE1(TEXT("RasCustomDeleteEntry -- CreateProcessAsUser Failed, GLE %d"), GetLastError());
            }

            pfnDestroyEnvironmentBlock(pszEnvBlock);
        }
        else
        {
            CMTRACE1(L"Unable to Create the Environment block, GLE %d", GetLastError());
        }
    }
    else
    {
        //
        //  We aren't impersonating just use regular CreateProcess
        //
        if (CreateProcess(NULL,                        // lpApplicationName
                          szParams,                    // lpCommandLine
                          NULL,                        // pProcessAttributes
                          NULL,                        // lpThreadAttributes
                          FALSE,                       // bInheritHandles
                          CREATE_UNICODE_ENVIRONMENT,  // dwCreationFlags
                          NULL,                        // lpEnvironment
                          NULL,                        // lpCurrentDirectory
                          &StartupInfo,
                          &ProcessInfo))
        {
            CloseHandle(ProcessInfo.hProcess);
            CloseHandle(ProcessInfo.hThread);
            dwReturn = ERROR_SUCCESS;
        }
        else
        {
            dwReturn = GetLastError();
            CMTRACE1(TEXT("RasCustomDeleteEntry -- CreateProcessAsUser Failed, GLE %d"), GetLastError());
        }
    }
exit:

    if (hImpersonationToken)
    {
        CloseHandle(hImpersonationToken);
    }

    if (hPrimaryToken)
    {
        CloseHandle(hPrimaryToken);
    }

    CmFree(pszCmDirpath);
    CmFree(pszShortServiceName);

    return dwReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  DllMain
//
// Synopsis:  Main entry point into the DLL.
//
// Arguments: HINSTANCE  hinstDLL - Our HINSTANCE
//            DWORD  fdwReason - The reason we are being called.
//            LPVOID  lpvReserved - Reserved
//
// Returns:   BOOL WINAPI - TRUE - always
//
// History:   nickball    Created Header    2/5/98
//
//+----------------------------------------------------------------------------
extern "C" BOOL WINAPI DllMain(HINSTANCE  hInstDLL, 
    DWORD  fdwReason, 
    LPVOID  lpvReserved) 
{
    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:

            if (!InitUnicodeAPI())
            {
               //
               //  Without our U api's we are going no where.  Bail.
               //
               MessageBox(NULL, TEXT("Cmdial32.dll Initialization Error:  Unable to initialize Unicode to ANSI conversion layer, exiting."),
                          TEXT("Connection Manager"), MB_OK | MB_ICONERROR);
                return FALSE;
            }

            /*
            if (S_OK != CmLogInitialize(hInstDLL))
            {
                MessageBox(NULL, TEXT("Cmdial32.dll initialization error: Unable to initialize logging, exiting."),
                           TEXT("Connection Manager"), MB_OK | MB_ICONERROR);
                // not fatal
            }
            */

            CMTRACE(TEXT("====================================================="));
            CMTRACE1(TEXT(" CMDIAL32.DLL - LOADING - Process ID is 0x%x "), GetCurrentProcessId());
            CMTRACE(TEXT("====================================================="));
        
#ifdef DEBUG        
            TCHAR szTmp[MAX_PATH];            
            MYVERIFY(GetModuleFileNameU (GetModuleHandleA(NULL), szTmp, MAX_PATH));      
            CMTRACE1(TEXT("Calling process is %s"), szTmp);
#endif

            // 
            // Setup global instance data
            //

            g_hInst = hInstDLL;

            //
            // Disable thread attach notification
            //

            MYVERIFY(DisableThreadLibraryCalls(hInstDLL));

            break;

        case DLL_PROCESS_DETACH:
        
            CMTRACE(TEXT("====================================================="));
            CMTRACE1(TEXT(" CMDIAL32.DLL - UNLOADING - Process ID is 0x%x "), GetCurrentProcessId());
            CMTRACE(TEXT("====================================================="));

            if (!UnInitUnicodeAPI())
            {
                CMASSERTMSG(FALSE, TEXT("cmdial32 dllmain UnInitUnicodeAPI failed - we are probably leaking a handle"));
            }
            
            //
            // Unlike Windows 95, on Windows NT, Windows classes 
            // that a DLL registers are NOT unregistered when the DLL is unloaded. 
            // Bug 168251:First launch of profile from connections UI causes access violation,
            // after copy new CM bits
            //

            if (OS_NT)
            {
                //
                // Unregister the bitmap class. The new CM bits will re-register the class with
                // correct wnd proc address.
                //
                UnregisterClassU(ICONNMGR_BMP_CLASS, g_hInst);
                UnRegisterWindowClass(g_hInst);
            }

            break;
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function: CmCustomDialDlg
//
// Synopsis:  Our CM specific variation on RasCustomDialDlg.  
//
// Arguments: HWND          hwndParent - The HWND of the parent if deemed necessary by the caller
//            DWORD         dwFlags - Dial flags
//            LPTSTR        lpszPhonebook - Ptr to the full path and filename of the phonebook.
//                          NULL = RAS system phone book
//                          "something" = user-defined RAS phonebook
//                          "" = has not been determined yet
//            LPTSTR        lpszEntry - Ptr to the name of the phone-book entry to dial.
//            LPTSTR        lpszPhoneNumber - Ptr to replacement phone number [IGNORED]
//            LPRASDIALDLG  lpRasDialDlg - Ptr to RASDIALDLG struct
//            LPRASENTRYDLG lpRasEntryDlg - Ptr to RASENTRYDLG struct
//            LPCMDIALINFO  lpCmInfo - Ptr to CMDIALINFO struct containing CM dial info such as flags.
//
// Returns:   BOOL WINAPI - TRUE on success
//
// History:   nickball    Created Header    2/5/98
//
//+----------------------------------------------------------------------------

extern "C" BOOL WINAPI CmCustomDialDlg(HWND hwndParent,
    DWORD dwFlags,
    LPTSTR lpszPhonebook, 
    LPCTSTR lpszEntry, 
    LPTSTR,                         // lpszPhoneNumber
    LPRASDIALDLG lpRasDialDlg,
    LPRASENTRYDLG lpRasEntryDlg,
    LPCMDIALINFO lpCmInfo,
    PVOID pvLogonBlob)
{
    MYDBGASSERT(lpCmInfo);
    MYDBGASSERT(lpszEntry);
    MYDBGASSERT(lpszEntry[0]);

    //DebugBreak();

    CMTRACE1(TEXT("CmCustomDialDlg() - dwFlags = 0x%x"), dwFlags);
    CMTRACE1(TEXT("CmCustomDialDlg() - lpszPhonebook = %s"), MYDBGSTR(lpszPhonebook));
    CMTRACE1(TEXT("CmCustomDialDlg() - lpszEntry = %s"), MYDBGSTR(lpszEntry));

    //
    // lpszPhonebook can be NULL, because we are called by our own modules, CMMGR, CMMON, etc.
    //

    if (NULL == lpszEntry || NULL == lpszEntry[0] || NULL == lpCmInfo)
    {
        return FALSE;
    }

    CM_SET_TIMING_INTERVAL("CmCustomDialDlg - Begin");

    CNamedMutex ConnectMutex;  
    CConnectionTable ConnTable;
    BOOL fConnTableExists = FALSE;
    BOOL fMultiInst = FALSE;
    
    if (!(lpCmInfo->dwCmFlags & FL_PROPERTIES))
    {
        //
        // Try to acquire connect mutex
        //
   
        LPTSTR pszTmp = CmStrCpyAlloc(c_pszConnectMutex);
        pszTmp = CmStrCatAlloc(&pszTmp, lpszEntry);

        if (FALSE == ConnectMutex.Lock(pszTmp, FALSE))
        {            
            if (FALSE == IsLogonAsSystem())
            {
                //
                // Another connect instance exists, try to front it
                //

                FrontExistingUI(NULL, lpszEntry, TRUE);

                // 
                // Now wait for Mutex to be released.
                //


                ConnectMutex.Lock(pszTmp, TRUE, INFINITE, TRUE);

                //
                // Mutex was released by the other instance, we'll handle the connect
                // request in the main path. If there is no table, we know that the 
                // instance which previously owned the mutex terminated without 
                // connecting and we follow suit by returning failure. Otherwise, we 
                // have to take a closer look. 
                //                                             

                fMultiInst = TRUE;
            }
            else
            {
                // 
                // No one is logged on and we don't need to be waiting for the mutex.
                //
                CmFree(pszTmp);
                return FALSE;
            }
       }
       

       CmFree(pszTmp);      
    }

    CMTRACE(TEXT("CmCustomDialDlg - Connect mutex acquired. Examining connection table."));
  
    fConnTableExists = SUCCEEDED(ConnTable.Open());

    if ((!fConnTableExists) && fMultiInst) 
    {
        //
        // If we're a secondary thread that was released from the mutex and
        // there is no connection table, then the user canceled, so bail.
        //

        CMTRACE(TEXT("CmCustomDialDlg - returning connect failure post mutex wait"));
        return FALSE;
    }
  
    //
    // If this is a connect request, see if connection exists. 
    //
    
    if (!(lpCmInfo->dwCmFlags & FL_PROPERTIES))
    {
        if (fConnTableExists)
        {
            //
            // Examine the connection table and try to resolve the connect request
            //

            BOOL fSuccess = FALSE;
            BOOL fDone = HandleCustomConnectRequest(NULL, 
                                                    &ConnTable, 
                                                    lpszEntry, 
                                                    lpCmInfo->dwCmFlags, 
                                                    &fSuccess);
            //
            // If we resolved the request, or we're in fMultiInst mode
            // then we can we can bail with the given success code. If  
            // fMultInst, we know we can bail because there is no entry
            // in the table, from which we infer that the previous owner
            // of the mutex failed and we return this out to our caller.
            //
            // NOTE: There is a theoretical corner case here in the multi-inst 
            // request case. If a succesful connection was established by the 
            // first thread, there is a window between the moment that the mutex 
            // lock is cleared above (releasing the waiting thread), and when 
            // the newly release thread reaches here. The logic is fouled if, 
            // and only if, the connection were dropped and entered the 
            // reconnect prompt state during this window. This is because the
            // second thread would dismiss the CMMON reconnect prompt UI during 
            // the call to HandleCustomConnectRequest, but would then return
            // despite fDone being FALSE. The correct behavior would be to 
            // continue, and honor the connect request. This state could be 
            // identified by an fDone of FALSE coupled with an fSuccess of TRUE.
            //
            
            if (fDone || fMultiInst)
            {
                MYVERIFY(SUCCEEDED(ConnTable.Close()));
                return fSuccess;            
            }           
        }
    }
    else
    {
        //
        // Its a properties request, front any UI that might exist
        //

        if (TRUE == FrontExistingUI(fConnTableExists? &ConnTable : NULL, lpszEntry, FALSE))
        {
            if (fConnTableExists)
            {
                MYVERIFY(SUCCEEDED(ConnTable.Close()));
            }
            return TRUE;       
        }
    }

    if (fConnTableExists)
    {
        MYVERIFY(SUCCEEDED(ConnTable.Close()));
    }
    
    //
    // Make a connection attempt
    //

    HRESULT hrRes = Connect(hwndParent,
                          lpszEntry, 
                          lpszPhonebook, 
                          lpRasDialDlg, 
                          lpRasEntryDlg, 
                          lpCmInfo,                           
                          OS_NT5 ? dwFlags : RCD_AllUsers, // Always AllUser downlevel
                          pvLogonBlob);

    //
    // Make sure we push error codes back out
    //
    BOOL bReturn = SUCCEEDED(hrRes);
    DWORD dwError = 0;

    if (lpRasDialDlg)
    {
        if (ERROR_CANCELLED == HRESULT_CODE(hrRes))
        {
            //
            //  If the user canceled then RasDialDlg returns a false to indicate failure
            //  but sets the dwError value to 0.  In order to match the way RAS does
            //  things we need to do this too.
            //
            lpRasDialDlg->dwError = 0;
        }
        else
        {
            //
            //  If the user entered the wrong PIN, we pass the error up to RAS unchanged
            //  so that RAS knows to take down its 'choose connectoid' dialog and drop
            //  the user back to winlogon
            //
            lpRasDialDlg->dwError = (BAD_SCARD_PIN(hrRes) ? hrRes : HRESULT_CODE(hrRes));
        }

        dwError = lpRasDialDlg->dwError;
    }

    if (lpRasEntryDlg)
    {
        if (ERROR_CANCELLED == HRESULT_CODE(hrRes))
        {
            //
            //  If the user canceled then RasEntryDlg returns a false to indicate failure
            //  but sets the dwError value to 0.  In order to match the way RAS does
            //  things we need to do this too.
            //
            lpRasEntryDlg->dwError = 0;
        }
        else
        {
            lpRasEntryDlg->dwError = HRESULT_CODE(hrRes);
        }

        dwError = lpRasEntryDlg->dwError;
    }
   
    //
    // Let go of the connect mutex and go home to papa.
    //

    CMTRACE(TEXT("CmCustomDialDlg - Releasing mutex")); 
    ConnectMutex.Unlock();

    CMTRACE2(TEXT("CmCustomDialDlg() returning with bReturn = %d, dwError = 0x%x"), bReturn, dwError);
    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  CmCustomHangUp
//
// Synopsis:  Our CM specific variation on RasCustomHangUp. Optionally, the entry
//            name may be given instead of the RAS handle.
//
// Arguments: HRASCONN hRasConn - The handle of the connection to be terminated.
//            LPCTSTR pszEntry - Ptr to the name of the entry to be terminated.
//            BOLL fPersist - Preserve the entry and its usage count.
//
// Returns:   DWORD WINAPI - Return code
//
//+----------------------------------------------------------------------------
extern "C" DWORD WINAPI CmCustomHangUp(HRASCONN hRasConn,
    LPCTSTR pszEntry,
    BOOL fIgnoreRefCount,
    BOOL fPersist)
{
    CMTRACE(TEXT("CmCustomHangUp"));
    MYDBGASSERT(hRasConn || (pszEntry && pszEntry[0]));

    DWORD dwRes = ERROR_SUCCESS;

    //
    // Must have a handle or an entry name
    //

    if (NULL == hRasConn && (NULL == pszEntry || 0 == pszEntry[0]))
    {
        return ERROR_INVALID_PARAMETER;
    }

    // 
    // First try to open the table, if none found then succeed.
    //
    
    CConnectionTable ConnTable;

    if (FAILED(ConnTable.Open()))
    {
        return ERROR_NOT_FOUND;
    }

    //
    // Look up the specified entry
    //

    HRESULT hrRes;

    CM_CONNECTION Connection;
    ZeroMemory(&Connection, sizeof(CM_CONNECTION));
        
    if (hRasConn)
    {
        hrRes = ConnTable.GetEntry(hRasConn, &Connection);
    }
    else
    {
        hrRes = ConnTable.GetEntry(pszEntry, &Connection);
    }
    
    //
    // We have an entry, do the Disconnect
    //

    if (SUCCEEDED(hrRes))
    {               
        if (CM_CONNECTING == Connection.CmState)
        {
            dwRes = ERROR_NOT_FOUND;
        }
        else
        {
            //
            // If the persist flag is not set and the caller is from the desktop
            // then ignore the ref count and do a complete hangup.
            //

//            BOOL fIgnoreRefCount = ((!fPersist) && WhoIsCaller(DT_CMMON | DT_EXPLORER));

            dwRes = Disconnect(&ConnTable, &Connection, fIgnoreRefCount, fPersist);            
        }
    }

    MYVERIFY(SUCCEEDED(ConnTable.Close()));
    
    return dwRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmdial\pwfuncs.cpp ===
//+----------------------------------------------------------------------------
//
// File:     pwfuncs.cpp     
//
// Module:   CMDIAL32.DLL
//
// Synopsis: This source file pound includes the password utility functions, 
//           see common\source\pwutil.cpp for specifics.
//
// Copyright (c) 1999 Microsoft Corporation
//
// Author:   nickball   created         08/04/99
//
//+----------------------------------------------------------------------------
#include "cmmaster.h"

//
//	Please see pnpu\cm\common\source for the actual source here.
//

#include "pwutil.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmdial\ntlsa.cpp ===
//+----------------------------------------------------------------------------
//
// File:     ntlsa.cpp     
//
// Module:   CMDIAL32.DLL
//
// Synopsis: This module contains the functions to allow Connection Manager to
//           interact with the NT LSA security system.
//
// Copyright (c) 1996-1999 Microsoft Corporation
//
// Author:   henryt     created	        02/23/98
//           quintinb	created Header	08/16/99
//
//+----------------------------------------------------------------------------
#include	"cmmaster.h"

///////////////////////////////////////////////////////////////////////////////////
// defines
///////////////////////////////////////////////////////////////////////////////////

#ifndef STATUS_SUCCESS
#define STATUS_SUCCESS  ((NTSTATUS)0x00000000L)
#endif

#define InitializeLsaObjectAttributes( p, n, a, r, s ) { \
    (p)->Length = sizeof( LSA_OBJECT_ATTRIBUTES );       \
    (p)->RootDirectory = r;                              \
    (p)->Attributes = a;                                 \
    (p)->ObjectName = n;                                 \
    (p)->SecurityDescriptor = s;                         \
    (p)->SecurityQualityOfService = NULL;                \
    }


///////////////////////////////////////////////////////////////////////////////////
// typedef's
///////////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////////
// func prototypes
///////////////////////////////////////////////////////////////////////////////////

void InitLsaString(
    PLSA_UNICODE_STRING pLsaString,
    LPWSTR              pszString
);


///////////////////////////////////////////////////////////////////////////////////
// globals
///////////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////////
// Implementation
///////////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
//	Function:	LSA_ReadString
//
//	Synopsis:	Read a string from the NT Local Security Authority (LSA) 
//				store.
//
//	Arguments:	pszKey          The key to identify the string.
//              pszStr          The buffer in which the string is to be
//                              written to.
//              dwStrLen        The length of the string buffer in bytes.
//
//	Returns:	DWORD   0 for SUCCES
//                      GetLastError() for FAILURE
//
//	History:	henryt	Created		5/15/97
//
//----------------------------------------------------------------------------

DWORD LSA_ReadString(
    ArgsStruct  *pArgs,
    LPTSTR     pszKey,
    LPTSTR      pszStr,
    DWORD       dwStrLen
)
{
    DWORD                   dwErr;
    LSA_OBJECT_ATTRIBUTES   oaObjAttr;
    LSA_HANDLE              hPolicy = NULL;
    NTSTATUS                ntStatus = STATUS_SUCCESS;
    LSA_UNICODE_STRING      unicodeKey;
    PLSA_UNICODE_STRING     punicodeValue = NULL;

#if !defined(_UNICODE) && !defined(UNICODE)
    LPWSTR                  pszUnicodeKey = NULL;
#endif
    
    if (!pszKey || !pszStr)
    {
        CMASSERTMSG(FALSE, TEXT("LSA_ReadString -- Invalid Parameter passed."));
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Open the LSA secret space for writing.
    //
    InitializeLsaObjectAttributes(&oaObjAttr, NULL, 0L, NULL, NULL);
    ntStatus = pArgs->llsLsaLink.pfnOpenPolicy(NULL, &oaObjAttr, POLICY_READ, &hPolicy);

    if (ntStatus == STATUS_SUCCESS)
    {

#if !defined(_UNICODE) && !defined(UNICODE)

        //
        // need to convert the ANSI key to unicode
        //

        if (!(pszUnicodeKey = (LPWSTR)CmMalloc((lstrlenA(pszKey)+1)*sizeof(WCHAR))))
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }

        if (!MultiByteToWideChar(CP_ACP, 0, pszKey, -1, pszUnicodeKey, (lstrlenA(pszKey)+1)*sizeof(WCHAR)))
        {
            CmFree(pszUnicodeKey);
            dwErr = ERROR_INVALID_DATA;
            goto exit;
        }
        
        //
        // create a unicode key
        //
        InitLsaString(&unicodeKey, pszUnicodeKey);
        CmFree(pszUnicodeKey);
#else
        //
        // create a unicode key
        //
        InitLsaString(&unicodeKey, pszKey);
#endif
        //
        // get it
        //
        ntStatus = pArgs->llsLsaLink.pfnRetrievePrivateData(hPolicy, &unicodeKey, &punicodeValue);        
    }

    if (ntStatus != STATUS_SUCCESS) 
    {
        dwErr = pArgs->llsLsaLink.pfnNtStatusToWinError(ntStatus);

#ifdef DEBUG        
        if (ERROR_SUCCESS != dwErr)
        {
            if (ERROR_FILE_NOT_FOUND == dwErr)
            {
                CMTRACE(TEXT("LSA_ReadPassword() NT password not found."));
            }
            else
            {
                CMTRACE1(TEXT("LSA_ReadPassword() NT failed, err=%u"), dwErr);
            }
        }
#endif

    }
    else
    {   
        if (dwStrLen < punicodeValue->Length)
        {
            dwErr = ERROR_BUFFER_OVERFLOW;
            goto exit;
        }

#if !defined(_UNICODE) && !defined(UNICODE)

        if (!WideCharToMultiByte(CP_ACP, 0, punicodeValue->Buffer, -1, 
                                 pszStr, dwStrLen, NULL, NULL))
        {
            dwErr = ERROR_INVALID_DATA;
            goto exit;
        }

#else
        
        CopyMemory((PVOID)pszStr, (CONST PVOID)punicodeValue->Buffer, punicodeValue->Length);

#endif
        
        dwErr = 0;
    }

exit:

    if (punicodeValue)
    {
        pArgs->llsLsaLink.pfnFreeMemory(punicodeValue);
    }

    if (hPolicy)
    {
        pArgs->llsLsaLink.pfnClose(hPolicy);
    }

    return dwErr;
}



//+---------------------------------------------------------------------------
//
//	Function:	LSA_WriteString
//
//	Synopsis:	Write a string to the NT Local Security Authority (LSA) 
//				store.
//
//	Arguments:	pszKey          The key to identify the string.
//              pszStr          The string.  This function deletes the
//                              string if this param is NULL.
//
//	Returns:	DWORD   0 for SUCCES
//                      GetLastError() for FAILURE
//
//	History:	henryt	Created		5/15/97
//
//----------------------------------------------------------------------------

DWORD LSA_WriteString(
    ArgsStruct  *pArgs,
    LPTSTR     pszKey,
    LPCTSTR     pszStr
)
{
    DWORD                   dwErr = 0;
    LSA_OBJECT_ATTRIBUTES   oaObjAttr;
    LSA_HANDLE              hPolicy = NULL;
    NTSTATUS                ntStatus = STATUS_SUCCESS;
    LSA_UNICODE_STRING      unicodeKey;
    LSA_UNICODE_STRING     unicodeValue;
#if !defined(_UNICODE) && !defined(UNICODE)
    LPWSTR  pszUnicodeKey = NULL;
    LPWSTR  pszUnicodePassword = NULL;
#endif
    
    if (!pszKey)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Open the LSA secret space for writing.
    //
    InitializeLsaObjectAttributes(&oaObjAttr, NULL, 0L, NULL, NULL);
    ntStatus = pArgs->llsLsaLink.pfnOpenPolicy(NULL, &oaObjAttr, POLICY_WRITE, &hPolicy);
    if (ntStatus == STATUS_SUCCESS)
    {

#if !defined(_UNICODE) && !defined(UNICODE)

        //
        // need to convert the ANSI key to unicode
        //

        if (!(pszUnicodeKey = (LPWSTR)CmMalloc((lstrlenA(pszKey)+1)*sizeof(WCHAR))))
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }
        if (!MultiByteToWideChar(CP_ACP, 0, pszKey, -1, pszUnicodeKey, (lstrlenA(pszKey)+1)*sizeof(WCHAR)))
        {
            dwErr = ERROR_INVALID_DATA;
            goto exit;
        }

        if (pszStr)
        {
            if (!(pszUnicodePassword = (LPWSTR)CmMalloc((lstrlenA(pszStr)+1)*sizeof(WCHAR))))
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                goto exit;
            }
            if (!MultiByteToWideChar(CP_ACP, 0, pszStr, -1, pszUnicodePassword, (lstrlenA(pszStr)+1)*sizeof(WCHAR)))
            {
                dwErr = ERROR_INVALID_DATA;
                goto exit;
            }
        }
        
        //
        // create a unicode key
        //
        InitLsaString(&unicodeKey, pszUnicodeKey);

        if (pszStr)
        {
            //
            // set the data
            //
            unicodeValue.Length = (lstrlenU(pszUnicodePassword)+1)*sizeof(WCHAR);
            unicodeValue.Buffer = (PWSTR)pszUnicodePassword;
        }

#else
        
        //
        // create a unicode key
        //
        InitLsaString(&unicodeKey, pszKey);

        if (pszStr)
        {
            //
            // set the data
            //
            unicodeValue.Length = (lstrlenU(pszStr)+1)*sizeof(TCHAR);
            unicodeValue.Buffer = (PWSTR)pszStr;
        }

#endif

        //
        // save it
        //
        ntStatus = pArgs->llsLsaLink.pfnStorePrivateData(hPolicy, &unicodeKey, pszStr? &unicodeValue : NULL);
    }

    if (ntStatus != STATUS_SUCCESS) 
    {
        dwErr = pArgs->llsLsaLink.pfnNtStatusToWinError(ntStatus);

#ifdef DEBUG        
        if (ERROR_SUCCESS != dwErr)
        {
            if (ERROR_FILE_NOT_FOUND == dwErr)
            {
                CMTRACE(TEXT("LSA_WritePassword() NT password not found."));
            }
            else
            {
                CMTRACE1(TEXT("LSA_WritePassword() NT failed, err=%u"), dwErr);
            }
        }
#endif

    }

    if (hPolicy)
    {
        pArgs->llsLsaLink.pfnClose(hPolicy);
    }

#if !defined(_UNICODE) && !defined(UNICODE)

    if (pszUnicodeKey)
    {
        CmFree(pszUnicodeKey);
    }

    if (pszUnicodePassword)
    {
        CmFree(pszUnicodePassword);
    }

#endif

    return dwErr;
}



//+---------------------------------------------------------------------------
//
//	Function:	InitLsaString
//
//	Synopsis:	Init a LSA string.
//
//	Arguments:	pLsaString      A LSA unicode string.
//              pszString       An unicode string.
//
//	Returns:	None
//
//	History:	henryt	Created		5/15/97
//
//----------------------------------------------------------------------------

void InitLsaString(
    PLSA_UNICODE_STRING pLsaString,
    LPWSTR              pszString
)
{
    DWORD dwStringLength;

    if (pszString == NULL) 
    {
        pLsaString->Buffer = NULL;
        pLsaString->Length = 0;
        pLsaString->MaximumLength = 0;
        return;
    }

    dwStringLength = lstrlenU(pszString);
    pLsaString->Buffer = pszString;
    pLsaString->Length = (USHORT) dwStringLength * sizeof(WCHAR);
    pLsaString->MaximumLength=(USHORT)(dwStringLength+1) * sizeof(WCHAR);
}




//+---------------------------------------------------------------------------
//
//	Function:	InitLsa
//
//	Synopsis:	Basically does GetProcAddress()'s for all the LSA API's that
//              we need since these API's don't exist in the Windows95 version
//              of advapi32.dll.
//
//	Arguments:	NONE
//
//	Returns:	TRUE    if SUCCESS
//              FALSE   otherwise.
//
//	History:	henryt	Created		5/15/97
//
//----------------------------------------------------------------------------

BOOL InitLsa(
    ArgsStruct  *pArgs
) 
{
    LPCSTR apszLsa[] = {
        "LsaOpenPolicy",
        "LsaRetrievePrivateData",
        "LsaStorePrivateData",
        "LsaNtStatusToWinError",
        "LsaClose",
        "LsaFreeMemory",
        NULL
    };

	MYDBGASSERT(sizeof(pArgs->llsLsaLink.apvPfnLsa)/sizeof(pArgs->llsLsaLink.apvPfnLsa[0]) == 
                sizeof(apszLsa)/sizeof(apszLsa[0]));

    ZeroMemory(&pArgs->llsLsaLink, sizeof(pArgs->llsLsaLink));

	return (LinkToDll(&pArgs->llsLsaLink.hInstLsa, 
                      "advapi32.dll",
                      apszLsa,
                      pArgs->llsLsaLink.apvPfnLsa));
}


//+---------------------------------------------------------------------------
//
//	Function:	DeInitLsa
//
//	Synopsis:	The reverse of InitLsa().
//
//	Arguments:	NONE
//
//	Returns:	TRUE    if SUCCESS
//              FALSE   otherwise.
//
//	History:	henryt	Created		5/15/97
//
//----------------------------------------------------------------------------

BOOL DeInitLsa(
    ArgsStruct  *pArgs
) 
{
	if (pArgs->llsLsaLink.hInstLsa) 
	{
		FreeLibrary(pArgs->llsLsaLink.hInstLsa);
	}

    ZeroMemory(&pArgs->llsLsaLink, sizeof(pArgs->llsLsaLink));

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmdial\pbmap.cpp ===
//+----------------------------------------------------------------------------
//
// File:	 pbmap.cpp
//
// Module:	 CMDIAL32.DLL
//
// Synopsis: Implementation of CPBMap. Phonebook mapping object
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:	 nickball   Created    03/12/98
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"

//
// Definitions
//

#define CPBMAP_BITS_FOR_PB			10
#define CPBMAP_BITS_FOR_IDX			((sizeof(DWORD)*8)-CPBMAP_BITS_FOR_PB)
#define CPBMAP_PB_CNT				(1L<<CPBMAP_BITS_FOR_PB)
#define CPBMAP_IDX_CNT				(1L<<CPBMAP_BITS_FOR_IDX)
#define CPBMAP_ENCODE_PB(pb)		((pb)<<CPBMAP_BITS_FOR_IDX)
#define CPBMAP_ENCODE_IDX(idx)		(idx)
#define CPBMAP_DECODE_PB(cookie)	((cookie)>>CPBMAP_BITS_FOR_IDX)
#define CPBMAP_DECODE_IDX(cookie)	((cookie)&(CPBMAP_IDX_CNT-1))

extern "C" HRESULT WINAPI PhoneBookLoad(LPCSTR pszISP, DWORD_PTR *pdwPB);
extern "C" HRESULT WINAPI PhoneBookUnload(DWORD_PTR dwPB);

//
// Types
//

typedef struct tagCPBData 
{
	DWORD_PTR dwPB;
	DWORD dwParam;
} CPBD, *PCPBD;


//
// Implementation
// 

CPBMap::CPBMap() 
{

	m_nCnt = 0;
	m_pvData = NULL;
}


CPBMap::~CPBMap() 
{
	UINT nIdx;

	for (nIdx=0;nIdx<m_nCnt;nIdx++) 
	{
		PhoneBookUnload(((PCPBD) m_pvData)[nIdx].dwPB);
	}
	m_nCnt = 0;
	CmFree(m_pvData);
	m_pvData = NULL;
}


DWORD CPBMap::Open(LPCSTR pszISP, DWORD dwParam) 
{
	PCPBD pData;
	HRESULT hr;

	if (m_nCnt == CPBMAP_PB_CNT) 
	{
		SetLastError(ERROR_INVALID_PARAMETER);
		return (CPBMAP_ERROR);
	}
	
    pData = (PCPBD) CmMalloc((m_nCnt+1)*sizeof(*pData));

    if (pData)
    {
        hr = PhoneBookLoad(pszISP, &pData[m_nCnt].dwPB);

        if (hr == ERROR_SUCCESS) 
        {
            pData[m_nCnt].dwParam = dwParam;
            CopyMemory(pData, m_pvData, m_nCnt*sizeof(*pData));
            CmFree(m_pvData);
            m_pvData = pData;
            m_nCnt++;
        } 
        else 
        {
            CmFree(pData);
            SetLastError(hr);
        }
    }
    else
    {
        CMASSERTMSG(FALSE, TEXT("CPBMap::Open -- unable to allocate pData"));
        hr = ERROR_NOT_ENOUGH_MEMORY;
        SetLastError(hr);
    }

	return ((hr == ERROR_SUCCESS) ? (m_nCnt-1) : CPBMAP_ERROR);
}


DWORD CPBMap::ToCookie(DWORD_PTR dwPB, DWORD dwIdx, DWORD *pdwParam) 
{
	DWORD dwPBIdx;

#ifdef DEBUG
	DWORD dwTmp = CPBMAP_IDX_CNT;
#endif
	
	if (dwIdx >= CPBMAP_IDX_CNT) 
	{
		SetLastError(ERROR_INVALID_PARAMETER);
		return (CPBMAP_ERROR);
	}

	for (dwPBIdx=0; dwPBIdx < m_nCnt; dwPBIdx++) 
	{
		if (dwPB == ((PCPBD) m_pvData)[dwPBIdx].dwPB) 
		{
			break;
		}
	}
	
    if (dwPBIdx == m_nCnt) 
	{
		SetLastError(ERROR_INVALID_PARAMETER);
		return (CPBMAP_ERROR);
	}
	
    if (pdwParam) 
	{
		*pdwParam = ((PCPBD) m_pvData)[dwPBIdx].dwParam;
	}
	
    return (CPBMAP_ENCODE_PB(dwPBIdx)|CPBMAP_ENCODE_IDX(dwIdx));
}


DWORD_PTR CPBMap::PBFromCookie(DWORD dwCookie, DWORD *pdwParam) 
{
	DWORD dwPBIdx;

	dwPBIdx = CPBMAP_DECODE_PB(dwCookie);
	if (dwPBIdx >= m_nCnt) 
	{
		SetLastError(ERROR_INVALID_PARAMETER);
		return (CPBMAP_ERROR);
	}
	if (pdwParam) 
	{
		*pdwParam = ((PCPBD) m_pvData)[dwPBIdx].dwParam;
	}
	return (((PCPBD) m_pvData)[dwPBIdx].dwPB);
}


DWORD CPBMap::IdxFromCookie(DWORD dwCookie, DWORD *pdwParam) 
{
	DWORD dwPBIdx;

	dwPBIdx = CPBMAP_DECODE_PB(dwCookie);
	if (dwPBIdx >= m_nCnt) 
	{
		SetLastError(ERROR_INVALID_PARAMETER);
		return (CPBMAP_ERROR);
	}
	if (pdwParam) 
	{
		*pdwParam = ((PCPBD) m_pvData)[dwPBIdx].dwParam;
	}
	return (CPBMAP_DECODE_IDX(dwCookie));
}


DWORD_PTR CPBMap::GetPBByIdx(DWORD_PTR dwIdx, DWORD *pdwParam) 
{
	if (dwIdx >= m_nCnt) 
	{
		SetLastError(ERROR_INVALID_PARAMETER);
		return (CPBMAP_ERROR);
	}

	if (pdwParam) 
	{
		*pdwParam = ((PCPBD) m_pvData)[dwIdx].dwParam;
	}

	return (((PCPBD) m_pvData)[dwIdx].dwPB);
}


DWORD CPBMap::GetCnt() 
{

	return (m_nCnt);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmdial\pb.cpp ===
//+----------------------------------------------------------------------------
//
// File:     pb.cpp 
//
// Module:   CMDIAL32.DLL
//
// Synopsis: Handle the phone book dialog and call cmpbk32.dll.
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   fengsun Created Header   1/14/98
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"

#define MAX_PB_WAIT 30000       // max miliiseconds to wait for PB mutex     

//+----------------------------------------------------------------------------
//
// Function:  ExtendArray
//
// Synopsis:  Increase the array for one element as the size nSize
//            Reallocate and copy *ppvArray and increase *pnCount
//
// Arguments: void **ppvArray - the point to the array pointer
//            size_t nSize - the size of one element
//            UINT *pnCount - the number of element currently in the array
//
// Returns:   
//
// History:   feng sun Created Header    1/14/98
//
//+----------------------------------------------------------------------------
static void ExtendArray(IN OUT void **ppvArray, size_t nSize, IN OUT UINT *pnCount) 
{
    void *pvTmp;

    if (NULL != ppvArray && NULL != pnCount)
    {
        pvTmp = CmMalloc(nSize*(*pnCount+1));
        if (NULL != pvTmp)
        {
            CopyMemory(pvTmp,*ppvArray,nSize*(*pnCount));
            CmFree(*ppvArray);
            *ppvArray = pvTmp;
            (*pnCount)++;
        }
    }
}


//+---------------------------------------------------------------------------
//
//  struct ServiceInfo
//
//  Synopsis:   Save the information of a service under .cms [Service Types]
//
//  History:    fengsun created     1/14/97
//
//----------------------------------------------------------------------------

typedef struct tagServiceInfo 
{
    DWORD_PTR dwPB;
    UINT nServiceString;  
    PPBFS pFilter;
    PPBFS pFilterA;
    PPBFS pFilterB;
    LPTSTR pszFile;
} ServiceInfo;


class CPhoneBookInfo 
{
    public:
        CPhoneBookInfo();
        ~CPhoneBookInfo();
        BOOL Load(LPCTSTR pszFile, BOOL fHasValidTopLevelPBK, BOOL fHasValidReferencedPBKs);
        void LoadServiceTypes(HWND hwndDlg, UINT nIdServiceType, LPCTSTR pszServiceType);
        void LoadCountries(HWND hwndDlg, UINT nIdCountry, DWORD dwCountryId);
        void LoadRegions(HWND hwndDlg, UINT nIdRegion, LPCTSTR pszRegionName);
        void LoadNumbers(HWND hwndDlg,
                         UINT nIdNumberA,
                         UINT nIdNumberB,
                         UINT nIdMore,
                         LPCTSTR pszPhoneNumber,
                         LPCTSTR pszPhoneBookFile);
        //BOOL GetDisp(DWORD dwCookie, LPTSTR pszDisp, DWORD *pdwDisp);
        BOOL GetDesc(DWORD dwCookie, LPTSTR pszDesc, DWORD *pdwDesc);
        BOOL HasMoreNumbers();
        BOOL GetCanonical(DWORD dwCookie, LPTSTR pszCanonical, DWORD *pdwCanonical);
        BOOL GetNonCanonical(DWORD dwCookie, LPTSTR pszNonCanonical, DWORD *pdwNonCanonical);
        LPCTSTR GetFile(DWORD dwCookie);
        BOOL GetDUN(DWORD dwCookie, LPTSTR pszDUN, DWORD *pdwDUN);
    private:
        BOOL LoadFile(LPCTSTR pszFile, PPBFS pFilterA, PPBFS pFilterB);
        BOOL ServiceCB(LPCTSTR pszSvc,
                       PPBFS pFilter,
                       PPBFS pFilterA,
                       PPBFS pFilterB,
                       DWORD dwPB,
                       LPCTSTR pszFile);
        void LoadRegionsCB(unsigned int nIdx, DWORD_PTR dwParam);
        void LoadNumbersCB(unsigned int nIdx, DWORD_PTR dwParam);
        void LoadCountriesA(HWND hwndDlg, UINT nIdCountry, DWORD dwCountryId);
        void LoadCountriesW(HWND hwndDlg, UINT nIdCountry, DWORD dwCountryId);

        CPBMap m_Map;
        UINT m_nServiceString;
        LPTSTR *m_ppszServiceString;
        UINT m_nServiceInfo;            // the number of elements in m_psiServiceInfo
        ServiceInfo *m_psiServiceInfo;  // a array to save the information of all the services
                                        // under [Service Types]
        UINT m_nIdServiceType;
        UINT m_nIdCountry;
        UINT m_nIdRegion;
        UINT *m_pnRegionIdx;
        UINT m_nRegionIdx;
        typedef struct {
            CPhoneBookInfo *pInfo;
            PPBFS pFilterA;
            PPBFS pFilterB;
            DWORD dwPB;
            LPCSTR pszFile;
        } SCBS;
        friend BOOL WINAPI _ServiceCB(LPCSTR pszSvc, PPBFS pFilter, DWORD_PTR dwParam);

        friend BOOL WINAPI _ReferenceCB(LPCSTR pszFile,
                                        LPCSTR pszURL,
                                        PPBFS pFilterA,
                                        PPBFS pFilterB,
                                        DWORD_PTR dwParam);
        friend void WINAPI _LoadRegionsCB(unsigned int nIdx, DWORD_PTR dwParam);
        friend void WINAPI _LoadNumbersCB(unsigned int nIdx, DWORD_PTR dwParam);
};


LPCTSTR CPhoneBookInfo::GetFile(DWORD dwCookie) 
{
    DWORD dwParam;

    CMTRACE(TEXT("CPhoneBookInfo::GetFile"));

    DWORD_PTR dwPB = m_Map.PBFromCookie(dwCookie, &dwParam);

    if (dwPB == CPBMAP_ERROR) 
    {
        return (TEXT(""));
    }

    MYDBGASSERT(dwParam < m_nServiceInfo);
    
    return (m_psiServiceInfo[dwParam].pszFile);
}

/*
BOOL CPhoneBookInfo::GetDisp(DWORD dwCookie, LPTSTR pszDisp, DWORD *pdwDisp) 
{

    MYDBG(("CPhoneBookInfo::GetDisp"));

    return (PhoneBookGetPhoneDisp(m_Map.PBFromCookie(dwCookie),m_Map.IdxFromCookie(dwCookie),pszDisp,pdwDisp));
}
*/

BOOL CPhoneBookInfo::GetDesc(DWORD dwCookie, LPTSTR pszDesc, DWORD *pdwDesc) 
{
#ifdef UNICODE
    BOOL bReturn = FALSE;
    DWORD dwSize = *pdwDesc;
    LPSTR pszAnsiDesc = (LPSTR)CmMalloc(dwSize);

    if (pszAnsiDesc)
    {
        bReturn = PhoneBookGetPhoneDesc(m_Map.PBFromCookie(dwCookie), m_Map.IdxFromCookie(dwCookie), pszAnsiDesc, pdwDesc);

        MYVERIFY(0 != MultiByteToWideChar(CP_ACP, 0, pszAnsiDesc, -1, pszDesc, dwSize));

        CmFree(pszAnsiDesc);
    }

    return bReturn;

#else
    return (PhoneBookGetPhoneDesc(m_Map.PBFromCookie(dwCookie),m_Map.IdxFromCookie(dwCookie),pszDesc,pdwDesc));
#endif
    
}


BOOL CPhoneBookInfo::GetCanonical(DWORD dwCookie, LPTSTR pszCanonical, DWORD *pdwCanonical) 
{

#ifdef UNICODE
    BOOL bReturn = FALSE;
    DWORD dwSize = *pdwCanonical;
    LPSTR pszAnsiCanonical = (LPSTR)CmMalloc(dwSize);

    if (pszAnsiCanonical)
    {
        bReturn = PhoneBookGetPhoneCanonical(m_Map.PBFromCookie(dwCookie), m_Map.IdxFromCookie(dwCookie), 
            pszAnsiCanonical, pdwCanonical);

        MYVERIFY(0 != MultiByteToWideChar(CP_ACP, 0, pszAnsiCanonical, -1, pszCanonical, dwSize));

        CmFree(pszAnsiCanonical);
    }

    return bReturn;

#else
    return (PhoneBookGetPhoneCanonical(m_Map.PBFromCookie(dwCookie), m_Map.IdxFromCookie(dwCookie), 
        pszCanonical, pdwCanonical));
#endif

}

BOOL CPhoneBookInfo::GetNonCanonical(DWORD dwCookie, LPTSTR pszNonCanonical, DWORD *pdwNonCanonical) 
{

#ifdef UNICODE
    BOOL bReturn = FALSE;
    DWORD dwSize = *pdwNonCanonical;
    LPSTR pszAnsiNonCanonical = (LPSTR)CmMalloc(dwSize);

    if (pszAnsiNonCanonical)
    {
        bReturn = PhoneBookGetPhoneNonCanonical(m_Map.PBFromCookie(dwCookie), m_Map.IdxFromCookie(dwCookie), 
            pszAnsiNonCanonical, pdwNonCanonical);

        MYVERIFY(0 != MultiByteToWideChar(CP_ACP, 0, pszAnsiNonCanonical, -1, pszNonCanonical, dwSize));

        CmFree(pszAnsiNonCanonical);
    }

    return bReturn;

#else
    return (PhoneBookGetPhoneNonCanonical(m_Map.PBFromCookie(dwCookie),m_Map.IdxFromCookie(dwCookie),pszNonCanonical,pdwNonCanonical));
#endif

}

BOOL CPhoneBookInfo::GetDUN(DWORD dwCookie, LPTSTR pszDUN, DWORD *pdwDUN) 
{

#ifdef UNICODE
    BOOL bReturn = FALSE;
    DWORD dwSize = *pdwDUN;
    LPSTR pszAnsiDUN = (LPSTR)CmMalloc(dwSize);

    if (pszAnsiDUN)
    {
        bReturn = PhoneBookGetPhoneDUN(m_Map.PBFromCookie(dwCookie), m_Map.IdxFromCookie(dwCookie), 
            pszAnsiDUN, pdwDUN);

        MYVERIFY(0 != MultiByteToWideChar(CP_ACP, 0, pszAnsiDUN, -1, pszDUN, dwSize));

        CmFree(pszAnsiDUN);
    }

    return bReturn;

#else
    return (PhoneBookGetPhoneDUN(m_Map.PBFromCookie(dwCookie), m_Map.IdxFromCookie(dwCookie), 
        pszDUN, pdwDUN));
#endif

}


CPhoneBookInfo::CPhoneBookInfo() 
{

    m_nServiceString = 0;
    m_ppszServiceString = NULL;
    m_nServiceInfo = 0;
    m_psiServiceInfo = NULL;
    m_pnRegionIdx = NULL;
    m_nRegionIdx = 0;
}


CPhoneBookInfo::~CPhoneBookInfo() 
{

    while (m_nServiceString) 
    {
        CmFree(m_ppszServiceString[--m_nServiceString]);
    }
    
    CmFree(m_ppszServiceString);
    m_ppszServiceString = NULL;
    
    while (m_nServiceInfo) 
    {
        PhoneBookFreeFilter(m_psiServiceInfo[m_nServiceInfo-1].pFilter);
        PhoneBookFreeFilter(m_psiServiceInfo[m_nServiceInfo-1].pFilterA);
        PhoneBookFreeFilter(m_psiServiceInfo[m_nServiceInfo-1].pFilterB);
        CmFree(m_psiServiceInfo[m_nServiceInfo-1].pszFile);
        m_nServiceInfo--;
    }
    
    CmFree(m_psiServiceInfo);
    m_psiServiceInfo = NULL;
    CmFree(m_pnRegionIdx);
    m_pnRegionIdx = NULL;
    m_nRegionIdx = 0;
}

BOOL PhoneBookParseInfoWrapper(LPCTSTR pszFile, PhoneBookParseInfoStruct* piInfo)
{
#ifdef UNICODE
    BOOL bReturn;

    LPSTR pszAnsiFile = WzToSzWithAlloc(pszFile);

    if (NULL == pszAnsiFile)
    {
        return FALSE;
    }
    else
    {
        bReturn = PhoneBookParseInfo(pszAnsiFile, piInfo);
        CmFree(pszAnsiFile);
    }

    return bReturn;
#else
    return PhoneBookParseInfo(pszFile, piInfo);
#endif

}

BOOL CPhoneBookInfo::Load(LPCTSTR pszFile, BOOL fHasValidTopLevelPBK, BOOL fHasValidReferencedPBKs) 
{
    PhoneBookParseInfoStruct iInfo;
    BOOL bRes = FALSE;

    CMTRACE(TEXT("CPhoneBookInfo::Load"));

    CmFree(m_pnRegionIdx);
    m_pnRegionIdx = NULL;
    m_nRegionIdx = 0;
    if (!pszFile) 
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }
    ZeroMemory(&iInfo,sizeof(iInfo));
    iInfo.dwSize = sizeof(iInfo);

    if (fHasValidTopLevelPBK) 
    {
        if (!PhoneBookParseInfoWrapper(pszFile,&iInfo)) 
        {
            return (FALSE);
        }
        bRes = LoadFile(pszFile,iInfo.pFilterA,iInfo.pFilterB);
        PhoneBookFreeFilter(iInfo.pFilterA);
        PhoneBookFreeFilter(iInfo.pFilterB);
        if (!bRes) 
        {
            return (FALSE);
        }
    }

    if (fHasValidReferencedPBKs) 
    {
        iInfo.pfnRef = _ReferenceCB;
        iInfo.dwRefParam = (DWORD_PTR) this;
        if (!PhoneBookParseInfoWrapper(pszFile,&iInfo)) 
        {
            return (FALSE);
        }
        PhoneBookFreeFilter(iInfo.pFilterA);
        PhoneBookFreeFilter(iInfo.pFilterB);
    }
    
    return (TRUE);
}


void CPhoneBookInfo::LoadServiceTypes(HWND hwndDlg, UINT nIdServiceType, LPCTSTR pszServiceType) 
{
    UINT nIdx;
    UINT nTmpIdx;

    CMTRACE(TEXT("CPhoneBookInfo::LoadServiceTypes"));

    CmFree(m_pnRegionIdx);
    m_pnRegionIdx = NULL;
    m_nRegionIdx = 0;
    m_nIdServiceType = nIdServiceType;
    SendDlgItemMessageU(hwndDlg, nIdServiceType, CB_RESETCONTENT,0,0);

    for (nIdx=0; nIdx < m_nServiceString; nIdx++) 
    { 
        nTmpIdx = (UINT) SendDlgItemMessageU(hwndDlg, nIdServiceType, CB_ADDSTRING, 0, (LPARAM) m_ppszServiceString[nIdx]);
        SendDlgItemMessageU(hwndDlg, nIdServiceType, CB_SETITEMDATA, nTmpIdx, nIdx);
    }
    
    if (SendDlgItemMessageU(hwndDlg, nIdServiceType, CB_GETCOUNT, 0, 0) > 1) 
    {
        LPTSTR pszDesc = NULL;

        EnableWindow(GetDlgItem(hwndDlg, nIdServiceType), TRUE);

        //
        // If the service type is empty, select the first type as a default
        //

        if ((!pszServiceType) || pszServiceType[0] == '\0')
        {
            pszDesc = CmStrCpyAlloc(m_ppszServiceString[0]); 
        }
        else
        {
            pszDesc = CmStrCpyAlloc(pszServiceType);
        }
            
        //
        // Search for the specified default and if found, make it the current
        // selection. Previously, we did this in the loop above, but 16-bit 
        // combos, don't remember the CURSEL when strings are added.
        //

        nTmpIdx = (UINT) SendDlgItemMessageU(hwndDlg, 
                                             nIdServiceType, 
                                             CB_FINDSTRINGEXACT,
                                             (WPARAM) -1,
                                             (LPARAM) pszDesc);
        if (nTmpIdx == CB_ERR) 
        {
            nTmpIdx = 0;
        }

        SendDlgItemMessageU(hwndDlg, nIdServiceType, CB_SETCURSEL, nTmpIdx, 0);

        CmFree(pszDesc);
    } 
    else 
    {
        EnableWindow(GetDlgItem(hwndDlg, nIdServiceType), FALSE);
    }
}


typedef struct tagLoadCountriesCBStruct 
{
    DWORD_PTR dwPB;
    HWND hwndDlg;
    UINT nId;
    DWORD dwCountryId;
} LoadCountriesCBStruct;


//
//  Note: this function and its mirror function _LoadCountriesCBW must stay in sync
//
static void WINAPI _LoadCountriesCBA(unsigned int nIdx, DWORD_PTR dwParam) 
{
    LoadCountriesCBStruct *pParam = (LoadCountriesCBStruct *) dwParam;
    CHAR szCountry[256];
    UINT nTmpIdx;
    DWORD dwCountryId = PhoneBookGetCountryId(pParam->dwPB, nIdx);
    DWORD dwLen;

    szCountry[0] = '\0';

    dwLen = sizeof(szCountry) / sizeof(CHAR);
    PhoneBookGetCountryNameA(pParam->dwPB, nIdx, szCountry, &dwLen);
    wsprintfA(szCountry + lstrlenA(szCountry), " (%u)", dwCountryId);

    nTmpIdx = (UINT) SendDlgItemMessageA(pParam->hwndDlg, pParam->nId, CB_FINDSTRINGEXACT, (WPARAM) -1, (LPARAM)szCountry);
    
    if (nTmpIdx != CB_ERR) 
    {
        return;
    }
    
    nTmpIdx = (UINT) SendDlgItemMessageA(pParam->hwndDlg, pParam->nId, CB_ADDSTRING, 0, (LPARAM) szCountry);
    
    SendDlgItemMessageA(pParam->hwndDlg, pParam->nId, CB_SETITEMDATA, nTmpIdx, dwCountryId);
    
    if (pParam->dwCountryId && (dwCountryId == pParam->dwCountryId)) 
    {
        SendDlgItemMessageA(pParam->hwndDlg, pParam->nId, CB_SETCURSEL, nTmpIdx, 0);
    }
}

//
//  Note: this function and its mirror function _LoadCountriesCBA must stay in sync
//
static void WINAPI _LoadCountriesCBW(unsigned int nIdx, DWORD_PTR dwParam) 
{
    LoadCountriesCBStruct *pParam = (LoadCountriesCBStruct *) dwParam;
    WCHAR szCountry[256];
    UINT nTmpIdx;
    DWORD dwCountryId = PhoneBookGetCountryId(pParam->dwPB, nIdx);
    DWORD dwLen;

    szCountry[0] = L'\0';

    dwLen = sizeof(szCountry) / sizeof(WCHAR);
    PhoneBookGetCountryNameW(pParam->dwPB, nIdx, szCountry, &dwLen);
    wsprintfW(szCountry + lstrlenW(szCountry), L" (%u)", dwCountryId);

    nTmpIdx = (UINT) SendDlgItemMessageW(pParam->hwndDlg, pParam->nId, CB_FINDSTRINGEXACT, (WPARAM) -1, (LPARAM)szCountry);
    
    if (nTmpIdx != CB_ERR) 
    {
        return;
    }
    
    nTmpIdx = (UINT) SendDlgItemMessageW(pParam->hwndDlg, pParam->nId, CB_ADDSTRING, 0, (LPARAM) szCountry);

    SendDlgItemMessageW(pParam->hwndDlg, pParam->nId, CB_SETITEMDATA, nTmpIdx, dwCountryId);
    
    if (pParam->dwCountryId && (dwCountryId == pParam->dwCountryId)) 
    {
        SendDlgItemMessageW(pParam->hwndDlg, pParam->nId, CB_SETCURSEL, nTmpIdx, 0);
    }
}


void CPhoneBookInfo::LoadCountries(HWND hwndDlg, UINT nIdCountry, DWORD dwCountryId) 
{
    CMTRACE(TEXT("CPhoneBookInfo::LoadCountries"));

    if (OS_NT51)
    {
        return LoadCountriesW(hwndDlg, nIdCountry, dwCountryId);
    }
    else
    {
        return LoadCountriesA(hwndDlg, nIdCountry, dwCountryId);
    }
}

//
//  Note: this function and its mirror function LoadCountriesW must stay in sync
//
void CPhoneBookInfo::LoadCountriesA(HWND hwndDlg, UINT nIdCountry, DWORD dwCountryId) 
{
    UINT nIdx;
    DWORD_PTR nServiceType;

    CMTRACE(TEXT("CPhoneBookInfo::LoadCountriesA"));

    CmFree(m_pnRegionIdx);
    m_pnRegionIdx = NULL;
    m_nRegionIdx = 0;
    m_nIdCountry = nIdCountry;
    SendDlgItemMessageA(hwndDlg, nIdCountry, CB_RESETCONTENT, 0, 0);
    
    nIdx = (UINT) SendDlgItemMessageA(hwndDlg, m_nIdServiceType, CB_GETCURSEL, 0, 0);

    if (nIdx == CB_ERR) 
    {
        return;
    }
    
    nServiceType = SendDlgItemMessageA(hwndDlg, m_nIdServiceType, CB_GETITEMDATA, nIdx, 0);
    MYDBGASSERT(nServiceType<m_nServiceInfo);
    
    for (nIdx=0; nIdx < m_nServiceInfo; nIdx++) 
    {
        if (m_psiServiceInfo[nIdx].nServiceString == nServiceType) 
        {
            LoadCountriesCBStruct sParam = {m_Map.GetPBByIdx(m_psiServiceInfo[nIdx].dwPB),
                                            hwndDlg,
                                            nIdCountry,
                                            dwCountryId?dwCountryId:PhoneBookGetCurrentCountryId()};

            PhoneBookEnumCountries(m_Map.GetPBByIdx(m_psiServiceInfo[nIdx].dwPB),
                                   _LoadCountriesCBA,
                                   m_psiServiceInfo[nIdx].pFilter,
                                   (DWORD_PTR) &sParam);
        }
    }
    
    if ((SendDlgItemMessageA(hwndDlg,nIdCountry,CB_GETCURSEL,0,0) == CB_ERR) &&
        (SendDlgItemMessageA(hwndDlg,nIdCountry,CB_GETCOUNT,0,0) != 0)) 
    {
        SendDlgItemMessageA(hwndDlg,nIdCountry,CB_SETCURSEL,0,0);
    }
}


//
//  Note: this function and its mirror function LoadCountriesA must stay in sync
//
void CPhoneBookInfo::LoadCountriesW(HWND hwndDlg, UINT nIdCountry, DWORD dwCountryId) 
{
    UINT nIdx;
    DWORD_PTR nServiceType;

    CMTRACE(TEXT("CPhoneBookInfo::LoadCountriesW"));

    CmFree(m_pnRegionIdx);
    m_pnRegionIdx = NULL;
    m_nRegionIdx = 0;
    m_nIdCountry = nIdCountry;
    SendDlgItemMessageW(hwndDlg, nIdCountry, CB_RESETCONTENT, 0, 0);
    
    nIdx = (UINT) SendDlgItemMessageW(hwndDlg, m_nIdServiceType, CB_GETCURSEL, 0, 0);

    if (nIdx == CB_ERR) 
    {
        return;
    }
    
    nServiceType = SendDlgItemMessageW(hwndDlg, m_nIdServiceType, CB_GETITEMDATA, nIdx, 0);
    MYDBGASSERT(nServiceType<m_nServiceInfo);
    
    for (nIdx=0; nIdx < m_nServiceInfo; nIdx++) 
    {
        if (m_psiServiceInfo[nIdx].nServiceString == nServiceType) 
        {
            LoadCountriesCBStruct sParam = {m_Map.GetPBByIdx(m_psiServiceInfo[nIdx].dwPB),
                                            hwndDlg,
                                            nIdCountry,
                                            dwCountryId?dwCountryId:PhoneBookGetCurrentCountryId()};

            PhoneBookEnumCountries(m_Map.GetPBByIdx(m_psiServiceInfo[nIdx].dwPB),
                                   _LoadCountriesCBW,
                                   m_psiServiceInfo[nIdx].pFilter,
                                   (DWORD_PTR) &sParam);
        }
    }
    
    if ((SendDlgItemMessageW(hwndDlg,nIdCountry,CB_GETCURSEL,0,0) == CB_ERR) &&
        (SendDlgItemMessageW(hwndDlg,nIdCountry,CB_GETCOUNT,0,0) != 0)) 
    {
        SendDlgItemMessageW(hwndDlg,nIdCountry,CB_SETCURSEL,0,0);
    }
}


typedef struct tagLoadRegionsCBStruct 
{
    CPhoneBookInfo *pPhoneBook;
    DWORD_PTR dwPB;
    HWND hwndDlg;
    UINT nId;
    LPCSTR pszRegionName;
    UINT nServiceInfo;
} LoadRegionsCBStruct;


void CPhoneBookInfo::LoadRegionsCB(unsigned int nIdx, DWORD_PTR dwParam) 
{
    UINT nTmpIdx;

    LoadRegionsCBStruct *pParam = (LoadRegionsCBStruct *) dwParam;
    CHAR szRegionName[256];
    DWORD dwLen;

    dwLen = sizeof(szRegionName) / sizeof(CHAR);
    PhoneBookGetRegionNameA(pParam->dwPB, nIdx, szRegionName, &dwLen);
    ExtendArray((void **) &m_pnRegionIdx, sizeof(*m_pnRegionIdx)*m_nServiceInfo, &m_nRegionIdx);
    
    for (nTmpIdx = 0; nTmpIdx < m_nServiceInfo; nTmpIdx++) 
    {
        m_pnRegionIdx[m_nServiceInfo*(m_nRegionIdx-1) + nTmpIdx] = UINT_MAX;
    }
    
    nTmpIdx = (UINT) SendDlgItemMessageA(pParam->hwndDlg, pParam->nId, CB_FINDSTRINGEXACT, 0, (LPARAM) szRegionName);
    
    if (nTmpIdx == CB_ERR) 
    {
        nTmpIdx = (UINT) SendDlgItemMessageA(pParam->hwndDlg, pParam->nId, CB_ADDSTRING, 0, (LPARAM) szRegionName);
        
        SendDlgItemMessageA(pParam->hwndDlg, pParam->nId, CB_SETITEMDATA, nTmpIdx, m_nRegionIdx - 1);

        if (pParam->pszRegionName && (lstrcmpA(szRegionName, pParam->pszRegionName) == 0)) 
        {
            SendDlgItemMessageA(pParam->hwndDlg, pParam->nId, CB_SETCURSEL, nTmpIdx, 0);
        }

        m_pnRegionIdx[m_nServiceInfo*(m_nRegionIdx-1) + pParam->nServiceInfo] = nIdx;

    } 
    else 
    {
        DWORD_PTR dwTmp = SendDlgItemMessageA(pParam->hwndDlg, pParam->nId, CB_GETITEMDATA, nTmpIdx, 0);
        m_pnRegionIdx[m_nServiceInfo*dwTmp + pParam->nServiceInfo] = nIdx;
    }
}

static void WINAPI _LoadRegionsCB(unsigned int nIdx, DWORD_PTR dwParam) 
{

    ((LoadRegionsCBStruct *) dwParam)->pPhoneBook->LoadRegionsCB(nIdx,dwParam);
}


void CPhoneBookInfo::LoadRegions(HWND hwndDlg, UINT nIdRegion, LPCTSTR pszRegionName) 
{
    UINT nIdx;
    DWORD dwServiceType;
    DWORD dwCountryID;

    CMTRACE(TEXT("CPhoneBookInfo::LoadRegions"));

    CmFree(m_pnRegionIdx);
    m_pnRegionIdx = NULL;
    m_nRegionIdx = 0;
    m_nIdRegion = nIdRegion;
    SendDlgItemMessageU(hwndDlg,nIdRegion,CB_RESETCONTENT,0,0);
    
    nIdx = (UINT) SendDlgItemMessageU(hwndDlg,m_nIdServiceType,CB_GETCURSEL,0,0);
    if (nIdx == CB_ERR) 
    {
        return;
    }
    
    dwServiceType = (DWORD)SendDlgItemMessageU(hwndDlg,m_nIdServiceType,CB_GETITEMDATA,nIdx,0);
    MYDBGASSERT(dwServiceType<m_nServiceInfo);
    
    nIdx = (UINT) SendDlgItemMessageU(hwndDlg,m_nIdCountry,CB_GETCURSEL,0,0);
    if (nIdx == CB_ERR) 
    {
        return;
    }
    
    dwCountryID = (DWORD)SendDlgItemMessageU(hwndDlg,m_nIdCountry,CB_GETITEMDATA,nIdx,0);
    for (nIdx=0;nIdx<m_nServiceInfo;nIdx++) 
    {
        if (m_psiServiceInfo[nIdx].nServiceString == dwServiceType) 
        {

#ifdef UNICODE
            LPSTR pszAnsiRegionName = WzToSzWithAlloc(pszRegionName);

            if (NULL == pszAnsiRegionName)
            {
                return;
            }
#endif
            LoadRegionsCBStruct sParam = {this,
                                          m_Map.GetPBByIdx(m_psiServiceInfo[nIdx].dwPB),
                                          hwndDlg,
                                          nIdRegion,
#ifdef UNICODE
                                          pszAnsiRegionName,
#else
                                          pszRegionName,
#endif
                                          nIdx};

            PhoneBookEnumRegions(sParam.dwPB,
                                 _LoadRegionsCB,
                                 dwCountryID,
                                 m_psiServiceInfo[nIdx].pFilter,
                                 (DWORD_PTR) &sParam);
#ifdef UNICODE
            CmFree(pszAnsiRegionName);
#endif
        }
    }
    
    if (SendDlgItemMessageU(hwndDlg,nIdRegion,CB_GETCOUNT,0,0) != 0)
    {
        EnableWindow(GetDlgItem(hwndDlg,nIdRegion),TRUE); /* 10763 */
        EnableWindow(GetDlgItem(hwndDlg, IDC_PHONEBOOK_REGION_STATIC), TRUE);
    }
    else
    {
        EnableWindow(GetDlgItem(hwndDlg,nIdRegion),FALSE);
        EnableWindow(GetDlgItem(hwndDlg, IDC_PHONEBOOK_REGION_STATIC), FALSE);
    }

    if ((SendDlgItemMessageU(hwndDlg,nIdRegion,CB_GETCURSEL,0,0) == CB_ERR) &&
        (SendDlgItemMessageU(hwndDlg,nIdRegion,CB_GETCOUNT,0,0) != 0)) 
    {
        SendDlgItemMessageU(hwndDlg,nIdRegion,CB_SETCURSEL,0,0);
    }
}


typedef struct tagLoadNumbersCBStruct 
{
    CPhoneBookInfo *pPhoneBook;
    DWORD_PTR dwPB;
    HWND hwndDlg;
    UINT nIdA;
    UINT nIdB;
    UINT nIdMore;
    PPBFS pFilterA;
    PPBFS pFilterB;
    LPCSTR pszPhoneNumber;
    LPCSTR pszPhoneBookFile;
} LoadNumbersCBStruct;


void CPhoneBookInfo::LoadNumbersCB(unsigned int nIdx, DWORD_PTR dwParam) 
{
    UINT nTmpIdx;

    LoadNumbersCBStruct *pParam = (LoadNumbersCBStruct *) dwParam;
    CHAR szPhoneNumber[256];
    DWORD dwType = PhoneBookGetPhoneType(pParam->dwPB, nIdx);
    UINT nId;
    UINT nOtherId;
    DWORD dwLen;
    BOOL bMatch = FALSE;
    DWORD dwCookie = m_Map.ToCookie(pParam->dwPB, nIdx);
    LPSTR pszAnsiPhoneBookFile;

#ifdef UNICODE
    pszAnsiPhoneBookFile = WzToSzWithAlloc(GetFile(dwCookie));

    if (NULL == pszAnsiPhoneBookFile)
    {
        CMASSERTMSG(FALSE, TEXT("CPhoneBookInfo::LoadNumbersCB -- Insufficient memory for Wide to Ansi conversion."));
        goto exit;
    }
#else
    pszAnsiPhoneBookFile = GetFile(dwCookie);
#endif


    if (PhoneBookMatchFilter(pParam->pFilterA,dwType)) 
    {
        nId = pParam->nIdA;
        nOtherId = pParam->nIdB;
    } 
    else if (PhoneBookMatchFilter(pParam->pFilterB,dwType)) 
    {
        nId = pParam->nIdB;
        nOtherId = pParam->nIdA;
    } 
    else 
    {
        goto exit;
    }
    
    if (pParam->pszPhoneNumber && pParam->pszPhoneBookFile) 
    {
        dwLen = sizeof(szPhoneNumber) / sizeof(TCHAR);

        PhoneBookGetPhoneCanonical(pParam->dwPB, nIdx, szPhoneNumber, &dwLen);

        if ((lstrcmpA(szPhoneNumber, pParam->pszPhoneNumber) == 0) &&
            (lstrcmpA(pszAnsiPhoneBookFile, pParam->pszPhoneBookFile) == 0)) 
        {
            bMatch = TRUE;
        }
    }
    
    if (GetDlgItem(pParam->hwndDlg,nId)) 
    {

        dwLen = sizeof(szPhoneNumber) / sizeof(TCHAR);

        PhoneBookGetPhoneDisp(pParam->dwPB, nIdx, szPhoneNumber, &dwLen);
        nTmpIdx = (UINT) SendDlgItemMessageA(pParam->hwndDlg, nId, LB_FINDSTRINGEXACT, (WPARAM) -1, 
            (LPARAM) szPhoneNumber);

        if (nTmpIdx != LB_ERR) 
        {
            goto exit;
        }

        nTmpIdx = (UINT) SendDlgItemMessageA(pParam->hwndDlg, nId, LB_ADDSTRING, 0, (LPARAM) szPhoneNumber);

        DWORD_PTR dwSet = SendDlgItemMessageA(pParam->hwndDlg, nId, LB_SETITEMDATA, nTmpIdx, (LPARAM) dwCookie);

#ifdef DEBUG
        if (LB_ERR == dwSet)
        {
            CMTRACE(TEXT("PBDlgProc() LB_SETITEMDATA failed"));
        }
#endif

    } 
    else 
    {
        EnableWindow(GetDlgItem(pParam->hwndDlg,pParam->nIdMore),TRUE);
    
        if (bMatch) 
        {
            SendMessageA(pParam->hwndDlg, WM_COMMAND, pParam->nIdMore, 0);
        }
    }

exit:

#ifdef UNICODE
    CmFree(pszAnsiPhoneBookFile);
#endif

    return;
}

static void WINAPI _LoadNumbersCB(unsigned int nIdx, DWORD_PTR dwParam) 
{
    ((LoadNumbersCBStruct *) dwParam)->pPhoneBook->LoadNumbersCB(nIdx,dwParam);
}


void CPhoneBookInfo::LoadNumbers(HWND hwndDlg,
                                 UINT nIdNumberA,
                                 UINT nIdNumberB,
                                 UINT nIdMore,
                                 LPCTSTR pszPhoneNumber,
                                 LPCTSTR pszPhoneBookFile) 
{
    UINT nIdx;
    DWORD dwServiceType;
    DWORD dwCountryID;
    DWORD dwRegionIdx = UINT_MAX;

    CMTRACE(TEXT("CPhoneBookInfo::LoadNumbers"));

    LPSTR pszAnsiPhoneNumber = NULL;
    LPSTR pszAnsiPhoneBookFile = NULL;

#ifdef UNICODE
    pszAnsiPhoneNumber = WzToSzWithAlloc(pszPhoneNumber);

    if (NULL == pszAnsiPhoneNumber)
    {
        CMTRACE(TEXT("CPhoneBookInfo::LoadNumbers -- Insufficient Memory to convert from Wide to MBCS for pszPhoneNumber"));
        goto exit;
    }

    pszAnsiPhoneBookFile = WzToSzWithAlloc(pszPhoneBookFile);

    if (NULL == pszAnsiPhoneBookFile)
    {
        CMTRACE(TEXT("CPhoneBookInfo::LoadNumbers -- Insufficient Memory to convert from Wide to MBCS for pszPhoneBookFile"));
        goto exit;
    }

#else
    pszAnsiPhoneNumber = (LPSTR)pszPhoneNumber;
    pszAnsiPhoneBookFile = (LPSTR)pszPhoneBookFile;
#endif


    SendDlgItemMessageA(hwndDlg, nIdNumberA, LB_RESETCONTENT, 0, 0);
    SendDlgItemMessageA(hwndDlg, nIdNumberB, LB_RESETCONTENT, 0, 0);

#if 0
//  EnableWindow(GetDlgItem(hwndDlg,nIdMore),FALSE); Note: More button is now obsolete
#endif
    
    //
    // Get the current service type
    //

    nIdx = (UINT) SendDlgItemMessageA(hwndDlg, m_nIdServiceType, CB_GETCURSEL, 0, 0);

    if (nIdx == CB_ERR) 
    {
        goto exit;
    }

    dwServiceType = (DWORD)SendDlgItemMessageA(hwndDlg, m_nIdServiceType, CB_GETITEMDATA, nIdx, 0);
    MYDBGASSERT(dwServiceType < m_nServiceInfo);
    
    //
    // Get the current country code
    //

    nIdx = (UINT) SendDlgItemMessageA(hwndDlg, m_nIdCountry, CB_GETCURSEL, 0, 0);
    
    if (nIdx == CB_ERR) 
    {
        goto exit;
    }

    dwCountryID = (DWORD)SendDlgItemMessageA(hwndDlg, m_nIdCountry, CB_GETITEMDATA, nIdx, 0);
    
    //
    // Get the current region ID
    //
    
    nIdx = (UINT) SendDlgItemMessageA(hwndDlg, m_nIdRegion, CB_GETCURSEL, 0, 0);

    if (nIdx != CB_ERR) 
    {
        dwRegionIdx = (DWORD)SendDlgItemMessageA(hwndDlg, m_nIdRegion, CB_GETITEMDATA, nIdx, 0);
    } 
    
    for (nIdx=0; nIdx < m_nServiceInfo; nIdx++) 
    {
        if (m_psiServiceInfo[nIdx].nServiceString == dwServiceType) 
        {
            if ((dwRegionIdx == UINT_MAX) || 
                (m_pnRegionIdx[m_nServiceInfo*dwRegionIdx+nIdx] != UINT_MAX)) 
            {
                LoadNumbersCBStruct sParam = {this,
                                              m_Map.GetPBByIdx(m_psiServiceInfo[nIdx].dwPB),
                                              hwndDlg,
                                              nIdNumberA,
                                              nIdNumberB,
                                              nIdMore,
                                              m_psiServiceInfo[nIdx].pFilterA,
                                              m_psiServiceInfo[nIdx].pFilterB,
                                              pszAnsiPhoneNumber,
                                              pszAnsiPhoneBookFile};

                PhoneBookEnumNumbers(sParam.dwPB,
                                     _LoadNumbersCB,
                                     dwCountryID,
                                     (dwRegionIdx == UINT_MAX) ? UINT_MAX : m_pnRegionIdx[m_nServiceInfo*dwRegionIdx+nIdx],
                                     m_psiServiceInfo[nIdx].pFilter,
                                     (DWORD_PTR) &sParam);
            }
            else 
            {
                //
                // Multiple PBKs (especially if one has no regions) can create a 
                // situation in which we have a valid region selection in the combo
                // but the m_pnRegionIdx[m_nServiceInfo*dwRegionIdx+nIdx] is 
                // UINT_MAX. What we do in this situation is enumerate the 
                // numbers such that only those without regions are added to the 
                // list by enumerating phone numbers with region 0.
                //

                if ((dwRegionIdx != UINT_MAX) && 
                    (m_pnRegionIdx[m_nServiceInfo*dwRegionIdx+nIdx] == UINT_MAX))
                {
                    LoadNumbersCBStruct sParam = {this,
                                                  m_Map.GetPBByIdx(m_psiServiceInfo[nIdx].dwPB),
                                                  hwndDlg,
                                                  nIdNumberA,
                                                  nIdNumberB,
                                                  nIdMore,
                                                  m_psiServiceInfo[nIdx].pFilterA,
                                                  m_psiServiceInfo[nIdx].pFilterB,
                                                  pszAnsiPhoneNumber,
                                                  pszAnsiPhoneBookFile};

                    PhoneBookEnumNumbersWithRegionsZero(sParam.dwPB,
                                                         _LoadNumbersCB,
                                                         dwCountryID,
                                                         m_psiServiceInfo[nIdx].pFilter,
                                                         (DWORD_PTR) &sParam);
                }
            }
        }
    }

exit:

#ifdef UNICODE
    CmFree(pszAnsiPhoneNumber);
    CmFree(pszAnsiPhoneBookFile);
#endif

    return;
}

BOOL CPhoneBookInfo::HasMoreNumbers()
{
    //
    // Filters are stored by service type, so examine each one.
    //

    for (UINT nIdx = 0; nIdx < m_nServiceInfo; nIdx++) 
    {       
        if (PhoneBookHasPhoneType(m_Map.GetPBByIdx(m_psiServiceInfo[nIdx].dwPB), m_psiServiceInfo[nIdx].pFilterB))
        {
            return TRUE;
        }
    }

    return FALSE;
}

BOOL CPhoneBookInfo::LoadFile(LPCTSTR pszFile, PPBFS pFilterA, PPBFS pFilterB) 
{
    CMTRACE(TEXT("CPhoneBookInfo::LoadFile"));

    LPSTR pszAnsiFile = NULL;
    BOOL bRes = TRUE;

#ifdef UNICODE
    pszAnsiFile = WzToSzWithAlloc(pszFile);
    if (!pszAnsiFile)
    {
        return FALSE;
    }
#else
    pszAnsiFile = (LPSTR)pszFile;
#endif

    SCBS sSvc = {this,pFilterA,pFilterB,0,pszAnsiFile};
    PhoneBookParseInfoStruct iInfo;

    sSvc.dwPB = m_Map.Open(pszAnsiFile, m_nServiceInfo);
    
    if (sSvc.dwPB == CPBMAP_ERROR) 
    {
        bRes = FALSE;
        goto exit;
    }

    ZeroMemory(&iInfo, sizeof(iInfo));
    iInfo.dwSize = sizeof(iInfo);
    iInfo.pfnSvc = _ServiceCB; 
    iInfo.dwSvcParam = (DWORD_PTR) &sSvc;

    CMTRACE(TEXT("CPhoneBookInfo::LoadFile - ParseInfo"));

    bRes = PhoneBookParseInfo(pszAnsiFile, &iInfo);

    PhoneBookFreeFilter(iInfo.pFilterA);
    PhoneBookFreeFilter(iInfo.pFilterB);

exit:

#ifdef UNICODE
        CmFree(pszAnsiFile);
#endif

    return (bRes);
}


BOOL CPhoneBookInfo::ServiceCB(LPCTSTR pszSvc,
                               PPBFS pFilter,
                               PPBFS pFilterA,
                               PPBFS pFilterB,
                               DWORD dwPB,
                               LPCTSTR pszFile) 
{
    ServiceInfo *psiInfo;
    UINT nIdx;

    CMTRACE(TEXT("CPhoneBookInfo::ServiceCB"));

    //
    // Extended m_psiServiceInfo and set up the new element
    //

    ExtendArray((void **) &m_psiServiceInfo,sizeof(*m_psiServiceInfo),&m_nServiceInfo);
    psiInfo = &m_psiServiceInfo[m_nServiceInfo-1];
    psiInfo->dwPB = dwPB;
    psiInfo->pFilter = pFilter;
    psiInfo->pFilterA = PhoneBookCopyFilter(pFilterA);
    psiInfo->pFilterB = PhoneBookCopyFilter(pFilterB);
    psiInfo->pszFile = CmStrCpyAlloc(pszFile);
    
    for (nIdx=0;nIdx<m_nServiceString;nIdx++) 
    {
        if (lstrcmpU(pszSvc,m_ppszServiceString[nIdx]) == 0) 
        {
            psiInfo->nServiceString = nIdx;
            break;
        }
    }
    
    if (nIdx == m_nServiceString) 
    {
        ExtendArray((void **) &m_ppszServiceString,sizeof(*m_ppszServiceString),&m_nServiceString);
        m_ppszServiceString[m_nServiceString-1] = CmStrCpyAlloc(pszSvc);
        psiInfo->nServiceString = m_nServiceString - 1;
    }
    return (TRUE);
}

static BOOL WINAPI _ReferenceCB(LPCSTR pszFile,
                                LPCSTR pszURL,
                                PPBFS pFilterA,
                                PPBFS pFilterB,
                                DWORD_PTR dwParam) 
{
    CPhoneBookInfo *pParam = (CPhoneBookInfo *) dwParam;

#ifdef UNICODE
    LPWSTR pszwFile = NULL;
    pszwFile = SzToWzWithAlloc(pszFile);
    BOOL bReturn = FALSE;

    if (NULL != pszwFile)
    {
        bReturn = pParam->LoadFile(pszwFile, pFilterA, pFilterB);
        CmFree(pszwFile);       
    }
    else
    {
        CMTRACE(TEXT("_ReferenceCB -- CmMalloc returned a NULL pointer."));
    }

    return bReturn;

#else
    return (pParam->LoadFile(pszFile, pFilterA, pFilterB));
#endif
}


static BOOL CALLBACK _ServiceCB(LPCSTR pszSvc, PPBFS pFilter, DWORD_PTR dwParam) 
{
    CPhoneBookInfo::SCBS *pParam = (CPhoneBookInfo::SCBS *) dwParam;

#ifdef UNICODE
    BOOL bReturn = FALSE;
    LPWSTR pszwSvc = SzToWzWithAlloc(pszSvc);
    LPWSTR pszwFile = SzToWzWithAlloc(pParam->pszFile);

    if ((NULL != pszwFile) && (NULL != pszwSvc))
    {
        bReturn = (pParam->pInfo->ServiceCB)(pszwSvc,
                                             pFilter,
                                             pParam->pFilterA,
                                             pParam->pFilterB,
                                             pParam->dwPB,
                                             pszwFile);
    }

    CmFree(pszwSvc);    
    CmFree(pszwFile);    

    return bReturn;

#else
    return (pParam->pInfo->ServiceCB(pszSvc,
                                     pFilter,
                                     pParam->pFilterA,
                                     pParam->pFilterB,
                                     pParam->dwPB,
                                     pParam->pszFile));
#endif

}


typedef struct tagPBDlgArgs 
{
    PBArgs *pPBArgs;
    CPhoneBookInfo cPB;
    BMPDATA BmpData;
} PBDlgArgs;


static BOOL PBDlgFillData(HWND hwndDlg, PBArgs *pPBArgs, CPhoneBookInfo *pPB, BOOL fValidateDun) 
{
    UINT nTmpIdx;
    UINT nId;
    DWORD dwLen;

    GetDlgItemTextU(hwndDlg,IDC_PHONEBOOK_SERVICETYPE_COMBO,pPBArgs->szServiceType,sizeof(pPBArgs->szServiceType)/sizeof(TCHAR)-1);
    
    nTmpIdx = (UINT) SendDlgItemMessageU(hwndDlg,IDC_PHONEBOOK_COUNTRY_COMBO,CB_GETCURSEL,0,0);
    if (nTmpIdx != CB_ERR) 
    {
        pPBArgs->dwCountryId = (DWORD)SendDlgItemMessageU(hwndDlg,IDC_PHONEBOOK_COUNTRY_COMBO,CB_GETITEMDATA,nTmpIdx,0);
    } 
    else 
    {
        pPBArgs->dwCountryId = PhoneBookGetCurrentCountryId();
    }
    
    GetDlgItemTextU(hwndDlg,IDC_PHONEBOOK_REGION_COMBO,pPBArgs->szRegionName,sizeof(pPBArgs->szRegionName)/sizeof(TCHAR)-1);
    nId = IDC_PHONEBOOK_PHONE_LIST;
    
    nTmpIdx = (UINT) SendDlgItemMessageU(hwndDlg,nId,LB_GETCURSEL,0,0);
    if (nTmpIdx == LB_ERR) 
    {
        if (GetDlgItem(hwndDlg,IDC_PHONEBOOKEX_PHONE_LIST)) 
        {
            nId = IDC_PHONEBOOKEX_PHONE_LIST;
            nTmpIdx = (UINT) SendDlgItemMessageU(hwndDlg,nId,LB_GETCURSEL,0,0);

            UINT nTmpCount = (UINT) SendDlgItemMessageU(hwndDlg,nId,LB_GETCOUNT,0,0);

        }
    }
    
    if (nTmpIdx != LB_ERR) 
    {
        DWORD dwIdx = (DWORD)SendDlgItemMessageU(hwndDlg,nId,LB_GETITEMDATA,nTmpIdx,0);
        
        if (dwIdx != LB_ERR)
        {
            dwLen = sizeof(pPBArgs->szNonCanonical) / sizeof(TCHAR);
            pPB->GetNonCanonical(dwIdx,pPBArgs->szNonCanonical,&dwLen);

            dwLen = sizeof(pPBArgs->szCanonical) / sizeof(TCHAR);
            pPB->GetCanonical(dwIdx,pPBArgs->szCanonical,&dwLen);

            dwLen = sizeof(pPBArgs->szDesc) / sizeof(TCHAR);
            pPB->GetDesc(dwIdx,pPBArgs->szDesc,&dwLen);
            lstrcpynU(pPBArgs->szPhoneBookFile,pPB->GetFile(dwIdx),sizeof(pPBArgs->szPhoneBookFile)/sizeof(TCHAR));
            dwLen = sizeof(pPBArgs->szDUNFile) / sizeof(TCHAR);
            pPB->GetDUN(dwIdx,pPBArgs->szDUNFile,&dwLen);
            
            if (fValidateDun)
            {
                //
                // Make sure we can support any DUN settings associated with the number
                //
                
                if (FALSE == ValidateDialupDunSettings(pPBArgs->szPhoneBookFile, pPBArgs->szDUNFile, pPBArgs->pszCMSFile))
                {           
                    return FALSE;
                }       
            }
        }
#ifdef DEBUG
        if (LB_ERR == dwIdx)
        {
            CMTRACE(TEXT("PBDlgProc() LB_GETITEMDATA failed"));
        }
#endif
    }

    return TRUE;
}


INT_PTR CALLBACK PBDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam) 
{
    PBDlgArgs *pArgs = (PBDlgArgs *) GetWindowLongU(hwndDlg,DWLP_USER);
    static DWORD adwHelp[] = {IDC_PHONEBOOK_SERVICETYPE_COMBO,IDH_PHONEBOOK_SERVICETYP,
                              IDC_PHONEBOOK_COUNTRY_COMBO,IDH_PHONEBOOK_COUNTRY,
                              IDC_PHONEBOOK_REGION_COMBO,IDH_PHONEBOOK_STATEREG,
                              IDC_PHONEBOOK_REGION_STATIC,IDH_PHONEBOOK_STATEREG,
                              IDC_PHONEBOOK_PHONE_LIST,IDH_PHONEBOOK_ACCESSNUMS,
                              IDC_PHONEBOOK_HELP_BUTTON, IDH_CMHELP,
                              //IDC_PHONEBOOK_MORE_BUTTON,IDH_PHONEBOOK_MORE,
                              IDC_PHONEBOOKEX_MESSAGE_DISPLAY,IDH_PHONEBOOK_SVCMSG,
                              IDC_PHONEBOOKEX_MORE_STATIC,IDH_PHONEBOOK_MORENUMS,
                              IDC_PHONEBOOKEX_PHONE_LIST,IDH_PHONEBOOK_MORENUMS,
                              0,0};
    switch (uMsg) 
    {
        case WM_INITDIALOG:

            CMTRACE(TEXT("PBDlgProc - WM_INITDIALOG"));
            
            UpdateFont(hwndDlg);

            pArgs = (PBDlgArgs *) lParam;
            SetWindowLongU(hwndDlg,DWLP_USER,(LONG_PTR) pArgs);
            SetDlgItemTextU(hwndDlg,IDC_PHONEBOOKEX_MESSAGE_DISPLAY,pArgs->pPBArgs->pszMessage);
            pArgs->cPB.LoadServiceTypes(hwndDlg,IDC_PHONEBOOK_SERVICETYPE_COMBO,pArgs->pPBArgs->szServiceType);
            pArgs->cPB.LoadCountries(hwndDlg,IDC_PHONEBOOK_COUNTRY_COMBO,pArgs->pPBArgs->dwCountryId);
            pArgs->cPB.LoadRegions(hwndDlg,IDC_PHONEBOOK_REGION_COMBO,pArgs->pPBArgs->szRegionName);
            pArgs->cPB.LoadNumbers(hwndDlg,
                                   IDC_PHONEBOOK_PHONE_LIST,
                                   IDC_PHONEBOOKEX_PHONE_LIST,
                                   IDC_PHONEBOOK_MORE_BUTTON,
                                   pArgs->pPBArgs->szCanonical,
                                   pArgs->pPBArgs->szPhoneBookFile);

            if ((SendDlgItemMessageU(hwndDlg,IDC_PHONEBOOK_PHONE_LIST,LB_GETCURSEL,0,0) == LB_ERR) &&
                (!GetDlgItem(hwndDlg,IDC_PHONEBOOKEX_PHONE_LIST) ||
                 (SendDlgItemMessageU(hwndDlg,IDC_PHONEBOOKEX_PHONE_LIST,LB_GETCURSEL,0,0) == LB_ERR))) 
            {
                EnableWindow(GetDlgItem(hwndDlg,IDOK),FALSE);
            }
            
            SendDlgItemMessageU(hwndDlg,IDC_PHONEBOOK_BITMAP,STM_SETIMAGE,IMAGE_BITMAP,(LPARAM) &pArgs->BmpData);

            if (IsLogonAsSystem())
            {
                EnableWindow(GetDlgItem(hwndDlg, IDC_PHONEBOOK_HELP_BUTTON), FALSE);
            }

            return (FALSE);

        case WM_COMMAND:
            switch (LOWORD(wParam)) 
            {
                case IDOK:
                    if (PBDlgFillData(hwndDlg, pArgs->pPBArgs, &pArgs->cPB, TRUE))
                    {
                        EndDialog(hwndDlg,1);
                    }
                    return (TRUE);

                case IDC_PHONEBOOK_HELP_BUTTON:
                    CmWinHelp(hwndDlg, hwndDlg, pArgs->pPBArgs->pszHelpFile,HELP_FORCEFILE,ICM_TRB);
                    return (TRUE);

                case IDCANCEL:
                    EndDialog(hwndDlg,0);
                    return (TRUE);

                case IDC_PHONEBOOK_MORE_BUTTON:
                    MYDBGASSERT(FALSE); // Now obsolete
                    PBDlgFillData(hwndDlg, pArgs->pPBArgs, &pArgs->cPB, FALSE);
                    EndDialog(hwndDlg,2);
                    return (TRUE);

                default:
                    if ((HIWORD(wParam) == CBN_SELCHANGE) || (HIWORD(wParam) == LBN_SELCHANGE)) 
                    {
                        switch (LOWORD(wParam)) 
                        {                              
                            case IDC_PHONEBOOK_SERVICETYPE_COMBO:

                                PBDlgFillData(hwndDlg, pArgs->pPBArgs, &pArgs->cPB, FALSE);
                                pArgs->cPB.LoadCountries(hwndDlg,IDC_PHONEBOOK_COUNTRY_COMBO,pArgs->pPBArgs->dwCountryId);

                                // fall through
                            case IDC_PHONEBOOK_COUNTRY_COMBO:

                                pArgs->cPB.LoadRegions(hwndDlg,IDC_PHONEBOOK_REGION_COMBO,pArgs->pPBArgs->szRegionName);
                                // fall through
                            case IDC_PHONEBOOK_REGION_COMBO:

                                pArgs->cPB.LoadNumbers(hwndDlg,
                                                       IDC_PHONEBOOK_PHONE_LIST,
                                                       IDC_PHONEBOOKEX_PHONE_LIST,
                                                       IDC_PHONEBOOK_MORE_BUTTON,
                                                       pArgs->pPBArgs->szCanonical,
                                                       pArgs->pPBArgs->szPhoneBookFile);

                                if ((SendDlgItemMessageU(hwndDlg,IDC_PHONEBOOK_PHONE_LIST,LB_GETCURSEL,0,0) == LB_ERR) &&
                                    (!GetDlgItem(hwndDlg,IDC_PHONEBOOKEX_PHONE_LIST) ||
                                     (SendDlgItemMessageU(hwndDlg,IDC_PHONEBOOKEX_PHONE_LIST,LB_GETCURSEL,0,0) == LB_ERR))) 
                                {
                                    EnableWindow(GetDlgItem(hwndDlg,IDOK),FALSE);
                                } 
                                else 
                                {
                                    EnableWindow(GetDlgItem(hwndDlg,IDOK),TRUE);
                                }

                                return (TRUE);

                            case IDC_PHONEBOOK_PHONE_LIST:
                                if (SendDlgItemMessageU(hwndDlg,IDC_PHONEBOOK_PHONE_LIST,LB_GETCURSEL,0,0) != LB_ERR) 
                                {
                                    EnableWindow(GetDlgItem(hwndDlg,IDOK),TRUE);
                                    SendDlgItemMessageU(hwndDlg,IDC_PHONEBOOKEX_PHONE_LIST,LB_SETCURSEL,(WPARAM) -1,0);
                                }
                                return (TRUE);

                            case IDC_PHONEBOOKEX_PHONE_LIST:
                                if (SendDlgItemMessageU(hwndDlg,IDC_PHONEBOOKEX_PHONE_LIST,LB_GETCURSEL,0,0) != LB_ERR) 
                                {
                                    EnableWindow(GetDlgItem(hwndDlg,IDOK),TRUE);
                                    SendDlgItemMessageU(hwndDlg,IDC_PHONEBOOK_PHONE_LIST,LB_SETCURSEL,(WPARAM) -1,0);
                                }
                                return (TRUE);

                            default:
                                break;
                        }
                    }
                    if (HIWORD(wParam) == LBN_DBLCLK) 
                    {
                        switch (LOWORD(wParam)) 
                        {
                            case IDC_PHONEBOOK_PHONE_LIST:
                            case IDC_PHONEBOOKEX_PHONE_LIST:
                                if (SendDlgItemMessageU(hwndDlg,LOWORD(wParam),LB_GETCURSEL,0,0) != LB_ERR) 
                                {
                                    SendMessageU(hwndDlg, WM_COMMAND, IDOK, 0);
                                }
                                break;

                            default:
                                break;
                        }
                    }
                    break;
            }
            break;

        case WM_HELP:
        {
            LPHELPINFO lpHelpInfo = (LPHELPINFO) lParam;

            CmWinHelp((HWND) (lpHelpInfo->hItemHandle), 
                    (HWND) (lpHelpInfo->hItemHandle),
                    pArgs->pPBArgs->pszHelpFile,
                    HELP_WM_HELP, 
                    (ULONG_PTR) ((LPTSTR) adwHelp));

            return (TRUE);
        }

        case WM_CONTEXTMENU:
            {

                POINT   pt = {LOWORD(lParam), HIWORD(lParam)};
                HWND    hWndItem;
                
                ScreenToClient(hwndDlg, &pt);
                hWndItem = ChildWindowFromPoint(hwndDlg, pt);
                if (hWndItem != NULL && 
                    HaveContextHelp(hwndDlg, hWndItem))
                {
                    CmWinHelp((HWND) wParam, hWndItem,pArgs->pPBArgs->pszHelpFile,HELP_CONTEXTMENU,(ULONG_PTR) (LPSTR) adwHelp);
                    return (TRUE);
                }
                //
                // 170599: Assertion when right click phone book dialog title bar
                // Return FALSE, DefaultWindowProc will handle this message then.
                //
                return (FALSE);
            }

        case WM_PALETTEISCHANGING:
            CMTRACE2(TEXT("PBDlgProc() got WM_PALETTEISCHANGING message, wParam=0x%x, hwndDlg=0x%x."), wParam, hwndDlg);
            break;

        case WM_PALETTECHANGED: 
        {                       
            if ((wParam != (WPARAM) hwndDlg) && pArgs->BmpData.hDIBitmap) 
            {
                PaletteChanged(&pArgs->BmpData, hwndDlg, IDC_PHONEBOOK_BITMAP);
            }
            else
            {
                CMTRACE2(TEXT("PBDlgProc().WM_PALETTECHANGED not changing palette, wParam=0x%x, hwndDlg=0x%x."), 
                    wParam, hwndDlg);
            }
            break;
        }

        case WM_QUERYNEWPALETTE:

            QueryNewPalette(&pArgs->BmpData, hwndDlg, IDC_PHONEBOOK_BITMAP);        
            break;

        default:
            break;
    }
    return (FALSE);
}


BOOL DisplayPhoneBook(HWND hwndDlg, PBArgs *pPBArgs, BOOL fHasValidTopLevelPBK, BOOL fHasValidReferencedPBKs) 
{
    PBDlgArgs sDlgArgs;
    BOOL bRes = FALSE;
    HWND hwndParent = NULL;
    CNamedMutex PbMutex;

    memset(&sDlgArgs,0,sizeof(sDlgArgs));
    sDlgArgs.pPBArgs = pPBArgs;

    //
    // Show wait cursor and attempt to grab PB access mutex
    //

    HCURSOR hPrev = SetCursor(LoadCursorU(NULL,IDC_WAIT));
    
    if (PbMutex.Lock(c_pszCMPhoneBookMutex, TRUE, MAX_PB_WAIT))
    {       
        sDlgArgs.cPB.Load(pPBArgs->pszCMSFile, fHasValidTopLevelPBK, fHasValidReferencedPBKs);
        PbMutex.Unlock();
    }
    else
    {
        SetCursor(hPrev);
        CMTRACE(TEXT("DisplayPhoneBook() - Unable to grab PB access mutex."));
        return bRes;   
    }

    //
    //  We have a phonebook to display, setup graphics
    //
    
    if (pPBArgs->pszBitmap && *pPBArgs->pszBitmap) 
    {
        sDlgArgs.BmpData.hDIBitmap = CmLoadBitmap(g_hInst, pPBArgs->pszBitmap);
    }
    
    if (!sDlgArgs.BmpData.hDIBitmap) 
    {
        sDlgArgs.BmpData.hDIBitmap = CmLoadBitmap(g_hInst, MAKEINTRESOURCE(IDB_PB));
    }
    
    if (sDlgArgs.BmpData.hDIBitmap) 
    {
        //
        // Create a new Device Dependent bitmap 
        //
       
        sDlgArgs.BmpData.phMasterPalette = pPBArgs->phMasterPalette;
        sDlgArgs.BmpData.bForceBackground = TRUE; // paint as a background app

        CreateBitmapData(sDlgArgs.BmpData.hDIBitmap, &sDlgArgs.BmpData, hwndDlg, TRUE);
    }

    //
    // Determine the template to be used, if the aggregate PB contains any 
    // surcharge numbers then use the EX template for displaying more numbers.
    //

    LPCTSTR pszDlgBox = NULL;
    
    if (sDlgArgs.cPB.HasMoreNumbers())
    {
        pszDlgBox = MAKEINTRESOURCE(IDD_PHONEBOOKEX);
    }
    else
    {
        pszDlgBox = MAKEINTRESOURCE(IDD_PHONEBOOK); 
    }

    MYDBGASSERT(pszDlgBox);

    //
    // Restore cursor and display the PB dialog
    //

    SetCursor(hPrev);

    hwndParent = hwndDlg;

#if 0
/*
    //
    // Previously, the user drove the template decision by electing to see 
    // More numbers via the More button. The return code from the proc would
    // dictate if we should simply call it a again with a different template.
    // Hence this loop and switch.
    //
      
        
    while (1) 
    {
        switch (DialogBoxParam(g_hInst, pszDlgBox, hwndParent, (DLGPROC) PBDlgProc,  (LPARAM) &sDlgArgs)) 
        {
            case 1:
                bRes = TRUE;
                break;

            case 2:
                pszDlgBox = MAKEINTRESOURCE(IDD_PHONEBOOKEX);
                continue;

            case 0:
            default:
                break;
        }
        //
        // Release bitmap resources for dlg
        //

        ReleaseBitmapData(&sDlgArgs.BmpData);
            
        return (bRes);
    }
*/
#else
        bRes = (BOOL) DialogBoxParamU(g_hInst, pszDlgBox, hwndParent, (DLGPROC) PBDlgProc,  (LPARAM) &sDlgArgs);

        ReleaseBitmapData(&sDlgArgs.BmpData);
            
        return (bRes);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmdial\refs.cpp ===
//+----------------------------------------------------------------------------
//
// File:     refs.cpp     
//
// Module:   CMDIAL32.DLL
//
// Synopsis: The module contains the code for profile referencing.
//
// Copyright (c) 1996-1999 Microsoft Corporation
//
// Author:   quintinb	created Header	08/16/99
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"

#include "pbk_str.h"

//+---------------------------------------------------------------------------
//
//	Function:	ValidTopLevelPBK()
//
//	Synopsis:	Checks to see if the toplevel phone book is valid.
//
//	Arguments:	pArgs [the ptr to ArgsStruct]
//
//	Returns:	BOOL    [True if there are valid phone books]
//
//	History:	henryt	Created		4/7/97
//										
//----------------------------------------------------------------------------
BOOL ValidTopLevelPBK(
    ArgsStruct  *pArgs
)
{
    LPTSTR pszTmp;
    LPTSTR pszFullPath;
    BOOL fValid = TRUE;

    //
    //  First check the top level service profile pbk
    //
	
    pszTmp = pArgs->piniService->GPPS(c_pszCmSectionIsp, c_pszCmEntryIspPbFile);

    if (!*pszTmp)
    {
        fValid = FALSE;
    }
    else
    {
        pszFullPath = CmBuildFullPathFromRelative(pArgs->piniProfile->GetFile(), pszTmp);

        if (!pszFullPath || (FALSE == FileExists(pszFullPath))) 
        {
            fValid = FALSE;
        }
        CmFree(pszFullPath);  
    }

    CmFree(pszTmp);

    //
    // If PBK failed, we're done
    //

    if (FALSE == fValid)
    {
        return fValid;
    }

    //
    // Now check the region file
    //

    pszTmp = pArgs->piniService->GPPS(c_pszCmSectionIsp, c_pszCmEntryIspRegionFile);

    if (!*pszTmp)
    {
        fValid = FALSE;
    }
    else
    {
        pszFullPath = CmBuildFullPathFromRelative(pArgs->piniProfile->GetFile(), pszTmp);

        if (!pszFullPath || (FALSE == FileExists(pszFullPath))) 
        {
            fValid = FALSE;
        }
        CmFree(pszFullPath);  
    }

    CmFree(pszTmp);

    return fValid;
}
	

//+---------------------------------------------------------------------------
//
//	Function:	ValidReferencedPBKs()
//
//	Synopsis:	Checks to see if the phone books used by the referenced 
//              service profile(s) exist.
//
//	Arguments:	pArgs [the ptr to ArgsStruct]
//
//	Returns:	BOOL    [True if there are valid phone books]
//
//	History:	henryt	Created		4/7/97
//										
//----------------------------------------------------------------------------
BOOL ValidReferencedPBKs(
    ArgsStruct  *pArgs
)
{
    LPTSTR  pszTmp, pszTmp2;
    LPTSTR  pszRef, pszNext;
    CIni    iniRef(g_hInst);
    CIni    iniFile(g_hInst, pArgs->piniService->GetFile());
    LPTSTR  pszRefFile;
    BOOL    fValid = TRUE;
	BOOL	fValidPairFound = FALSE;
    LPTSTR pszFullPath;
    
    //
    //  Now check the references.
    //

    pszTmp2 = iniFile.GPPS(c_pszCmSectionIsp, c_pszCmEntryIspReferences);
    pszRef = NULL;
    pszNext = pszTmp2;
    
	while (1) 
	{
        if (!(pszRef = CmStrtok(pszNext, TEXT(" \t,"))))
		{
            break;
		}

		fValid = TRUE;
        
		pszNext = pszRef + lstrlenU(pszRef) + 1;

        iniFile.SetEntry(pszRef);

        //
        //  Make sure that each referenced service has a valid pbk and pbr
        //

        pszRefFile = iniFile.GPPS(c_pszCmSectionIsp, c_pszCmEntryIspCmsFile);
        if (*pszRefFile) 
		{
            //
            // Ensure a full path to the RefFile
            //

            pszFullPath = CmBuildFullPathFromRelative(pArgs->piniProfile->GetFile(), pszRefFile);
            
            if (!pszFullPath)
            {
                fValid = FALSE;
            }
            else
            {
                iniRef.SetFile(pszFullPath);
            }
            
            CmFree(pszFullPath);

            if (fValid)
            {
                //
                // Test existence of phonebook
                //

                pszTmp = iniRef.GPPS(c_pszCmSectionIsp, c_pszCmEntryIspPbFile);

                if (!*pszTmp)
                {
                    fValid = FALSE;
                }
                else
                {
                    pszFullPath = CmBuildFullPathFromRelative(pArgs->piniProfile->GetFile(), pszTmp);
                    if (!pszFullPath || (FALSE == FileExists(pszFullPath))) 
                    {
                        fValid = FALSE;               
                    }
                    CmFree(pszFullPath);
                }
            
			    CmFree(pszTmp);

                //
                // Now check the region file
                //

                pszTmp = iniRef.GPPS(c_pszCmSectionIsp, c_pszCmEntryIspRegionFile);

                if (!*pszTmp)
                {
                    fValid = FALSE;
                }
                else
                {
                    pszFullPath = CmBuildFullPathFromRelative(pArgs->piniProfile->GetFile(), pszTmp);
                    if (!pszFullPath || (FALSE == FileExists(pszFullPath))) 
                    {
                        fValid = FALSE;               
                    }
                    CmFree(pszFullPath);
                }

   			    CmFree(pszTmp);
            }
        } 
		else 
		{
            fValid = FALSE;
        }
        
		CmFree(pszRefFile);

        if (fValid)
		{
            fValidPairFound = TRUE;
			break;
		}
    }
    
	CmFree(pszTmp2);

    return fValidPairFound;
}

//+---------------------------------------------------------------------------
//
//	Function:	GetAppropriateIniService
//
//	Synopsis:	Depending on:
//              1. whether we're referencing or not, 
//              2. the pbk from which the user selected the phone #
//
//              this func creates a CIni obj with the correct cms file
//
//	Arguments:	pArgs		Pointer to ArgsStruct
//              dwEntry     phone index
//
//	Returns:	CIni* - the ptr to the new object
//
//	History:	henryt	Created		5/14/97
//----------------------------------------------------------------------------

CIni* GetAppropriateIniService(
    ArgsStruct  *pArgs,
    DWORD       dwEntry
)
{   
    CIni*   piniService = new CIni(g_hInst);

    if (!piniService) 
    {
        CMTRACE(TEXT("GetAppropriateIniService() : alloc mem failed"));
        return NULL;
    }

    //
    //  we need to work with the correct service file(the top-level service
    //  or a referenced service).
    //
    //  according to the spec, we will always use the DUN settings from the cms 
    //  associated w/ the phone book from which the user selected the POP.  i.e.
    //  if the user switches the picked from a different pbk, we need to update
    //  the RAS connectoid.
    //
    
    if (IsBlankString(pArgs->aDialInfo[dwEntry].szPhoneBookFile) || 
        lstrcmpiU(pArgs->aDialInfo[dwEntry].szPhoneBookFile, pArgs->piniService->GetFile()) == 0)
	{
        //
        //  the user either typed in the phone # or selected a phone # from the
        //  top level phone book
        //
        piniService->SetFile(pArgs->piniService->GetFile());
    }
    else 
	{
        //
        //  the user picked the phone # from a referenced phone book.
        //
        piniService->SetFile(pArgs->aDialInfo[dwEntry].szPhoneBookFile);
    }

    return piniService;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmdial\ras.cpp ===
//+----------------------------------------------------------------------------
//
// File:     ras.cpp     
//
// Module:   CMDIAL32.DLL
//
// Synopsis: This module contains the functions to allow Connection Manager to
//           interact with RAS.
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Author:   byao       created         04/29/97
//           quintinb   created Header  08/16/99
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"
#include "compchck.h"
#include "dial_str.h"
#include "dun_str.h"
#include "tunl_str.h"
#include "stp_str.h"
#include "ras_str.h"
#include "dialogs.h"

#include <cmdefs.h> // located in net\inc

//
// CMS flags use to specify DUN settings. These entries are specific
// to this code module, shared entries are stored on dun_str.h
//

const TCHAR* const c_pszCmSectionDunPhone                   = TEXT("Phone");
const TCHAR* const c_pszCmEntryDunPhoneDialAsIs             = TEXT("Dial_As_Is");
const TCHAR* const c_pszCmEntryDunPhonePhoneNumber          = TEXT("Phone_Number");
const TCHAR* const c_pszCmEntryDunPhoneAreaCode             = TEXT("Area_Code");
const TCHAR* const c_pszCmEntryDunPhoneCountryCode          = TEXT("Country_Code");
const TCHAR* const c_pszCmEntryDunPhoneCountryId            = TEXT("Country_ID");
const TCHAR* const c_pszCmSectionDunDevice                  = TEXT("Device");
const TCHAR* const c_pszCmEntryDunDeviceType                = TEXT("Type");
const TCHAR* const c_pszCmEntryDunDeviceName                = TEXT("Name");
const TCHAR* const c_pszCmEntryHideTrayIcon                 = TEXT("HideTrayIcon");
const TCHAR* const c_pszCmEntryInternetConnection           = TEXT("InternetConnection");

//
// the following reg key and value control whether Dial-Up Networking on Win95
// will start the Wizard.  Note that these are explicitly chars instead of TCHARs
//
const CHAR* const c_pszRegRemoteAccess = "RemoteAccess";
const CHAR* const c_pszRegWizard       = "wizard";

#define ICM_RAS_REG_WIZARD_VALUE        0x00000080

//
// .CMS flags used only by ras.cpp
//

const TCHAR* const c_pszCmEntryDialExtraPercent         = TEXT("DialExtraPercent"); 
const TCHAR* const c_pszCmEntryDialExtraSampleSeconds   = TEXT("DialExtraSampleSeconds"); 
const TCHAR* const c_pszCmEntryHangUpExtraPercent         = TEXT("HangUpExtraPercent"); 
const TCHAR* const c_pszCmEntryHangUpExtraSampleSeconds   = TEXT("HangUpExtraSampleSeconds"); 

//
//  This file includes the definitions of c_ArrayOfRasFuncsW and c_ArrayOfRasFuncsUA below
//
#include "raslink.cpp"

//+----------------------------------------------------------------------------
//
// Function:  LinkToRas
//
// Synopsis: Establishes the RAS linkage by populating the inputted RAS Linkage structure
//           with function pointers from Rasapi32.dll (on NT) or from cmutoa.dll (Unicode
//           to ANSI wrapper functions used on win9x).  Most of the actual work is done
//           in LinkToDll, this function just does setup work to make sure the correct
//           entry points are searched for and that Cmutoa.dll is initialized properly (since it
//           needs to link to rasapi32.dll itself to get the actual ANSI RAS API's to work with).
//
// Arguments: RasLinkageStruct *prlsRasLink - pointer to a RAS Linkage structure.  This
//                                            structure contains storage for pointers to
//                                            the RAS dll and all of the needed RAS
//                                            function pointers.
//
// Returns:   BOOL - FALSE if *any* entry point is still not resolved.
//
// History:   quintinb Created Header    01/04/2000
//
//+----------------------------------------------------------------------------
BOOL LinkToRas(RasLinkageStruct *prlsRasLink) 
{
    BOOL bReturn = TRUE;

    //
    //  Check inputs
    //
    if (NULL == prlsRasLink)
    {
        return FALSE;
    }

    if (OS_NT)
    {
        //
        //  On NT we get our RAS APIs from rasapi32.dll and we ask for the W version
        //  of the API.
        //
        if (OS_NT4) 
        {
            c_ArrayOfRasFuncsW[11] = NULL; //RasDeleteSubEntry
            c_ArrayOfRasFuncsW[12] = NULL; //RasSetCustomAuthData
            c_ArrayOfRasFuncsW[13] = NULL; //RasGetEapUserIdentity
            c_ArrayOfRasFuncsW[14] = NULL; //RasFreeEapUserIdentity
            c_ArrayOfRasFuncsW[15] = NULL; //RasInvokeEapUI
            c_ArrayOfRasFuncsW[16] = NULL; //pfnGetCredentials
            c_ArrayOfRasFuncsW[17] = NULL; //pfnSetCredentials
        }
        else if (OS_W2K)
        {
            //
            //  Special-casing for APIs that changed after Windows2000 shipped
            //
            c_ArrayOfRasFuncsW[11] = "DwDeleteSubEntry";   //RasDeleteSubEntry is DwDeleteSubEntry on Win2k
        }

        bReturn = LinkToDll(&prlsRasLink->hInstRas, "RASAPI32.DLL", c_ArrayOfRasFuncsW,
                            prlsRasLink->apvPfnRas);
    }
    else
    {
        //
        //  On Win9x we still want the W version of the API but since it isn't available we
        //  call the wrappers in cmutoa.dll instead.  Thus we use cmutoa.dll as our RAS API dll
        //  and call the UA APIs.  We also have an extra step because we want to make sure 
        //  that cmutoa.dll can actually initialize the RAS dll's that it uses for the UA 
        //  conversion functions.  Thus we call cmutoa's InitCmRasUtoA function to set up 
        //  its internal RAS linkage.  If this function fails, we must fail the RAS link.

        typedef BOOL (WINAPI *pfnInitCmRasUtoASpec)(void);

        pfnInitCmRasUtoASpec InitCmRasUtoA;
        HMODULE hCmUtoADll = LoadLibraryExA("cmutoa.DLL", NULL, 0); // REVIEW: this should use getmodulehandle so as not to change the refcount on the dll.
        
        if (!hCmUtoADll)
        {            
            return FALSE;
        }

        // Get Initialization routine from the DLL
        InitCmRasUtoA = (pfnInitCmRasUtoASpec) GetProcAddress(hCmUtoADll, "InitCmRasUtoA") ;

        if (InitCmRasUtoA)
        {
            bReturn = InitCmRasUtoA();
            if (bReturn)
            {
                if (!OS_MIL)
                {
                    c_ArrayOfRasFuncsUA[10] = NULL; //RasSetSubEntryProperties
                    c_ArrayOfRasFuncsUA[11] = NULL; //RasDeleteSubEntry
                }

                bReturn = LinkToDll(&prlsRasLink->hInstRas, "CMUTOA.DLL", c_ArrayOfRasFuncsUA, 
                                    prlsRasLink->apvPfnRas);
            }
        }

        FreeLibrary(hCmUtoADll); // we want this to stay in memory but the refcount should also be correct
    }

    return bReturn;
}

BOOL IsRasLoaded(const RasLinkageStruct * const prlsRasLink)
{
    UINT uIndex = 0;

    //
    //  Did we get a valid pointer passed in and does that
    //  struct contain a pointer to a RAS dll?
    //
    BOOL bReturn = (NULL != prlsRasLink) && (NULL != prlsRasLink->hInstRas);

    //
    //  The list of functions we are checking for is different on NT
    //  and Win9x.  Note that we also assume that LinkToRas has already
    //  been called so that the list of functions we are expecting will
    //  have been modified for the exact platform that we are one.  If
    //  LinkToRas hasn't been called then the hInstRas param should be
    //  NULL.
    //
    if (OS_NT)
    {
        while (bReturn && (NULL != c_ArrayOfRasFuncsW[uIndex]))
        {
            //
            //  Check for a NULL function pointer when we have
            //  a valid function name.
            //
            if (NULL == prlsRasLink->apvPfnRas[uIndex])
            {
                bReturn = FALSE;
            }

           uIndex++;
        }
    }
    else
    {
        while (bReturn && (NULL != c_ArrayOfRasFuncsUA[uIndex]))
        {
            //
            //  Check for a NULL function pointer when we have
            //  a valid function name.
            //
            if (NULL == prlsRasLink->apvPfnRas[uIndex])
            {
                bReturn = FALSE;
            }

           uIndex++;
        }    
    }

    return bReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  UnlinkFromRas
//
// Synopsis:  This function tears down the linkage with RAS by freeing RAS dll's, calling
//           the cmutoa unklinkage function (if necessary), and zeroing the RAS Linkage
//           structure passed in.
//
// Arguments: RasLinkageStruct *prlsRasLink - pointer to a RAS Linkage structure.  This
//                                        structure contains storage for pointers to
//                                        the RAS dll and all of the needed RAS
//                                        function pointers.
//
// Returns:   Nothing
//
// History:   quintinb Created Header    01/04/2000
//
//+----------------------------------------------------------------------------
void UnlinkFromRas(RasLinkageStruct *prlsRasLink) 
{
    if (!OS_NT)
    {
        HMODULE hCmUtoADll = LoadLibraryExA("cmutoa.dll", NULL, 0);
        
        if (!hCmUtoADll)
        {         
            CMASSERTMSG(FALSE, TEXT("UnlinkFromRas -- Unable to load cmutoa."));
            return;
        }

        FARPROC FreeCmRasUtoA = GetProcAddress(hCmUtoADll, "FreeCmRasUtoA");

        if (FreeCmRasUtoA)
        {
            FreeCmRasUtoA();
        }

        FreeLibrary(hCmUtoADll);
    }

    if (prlsRasLink->hInstRas) 
    {
        FreeLibrary(prlsRasLink->hInstRas);
    }

    memset(prlsRasLink,0,sizeof(RasLinkageStruct));
}

//
// GetRasModems: get a list of modem devices from RAS
//
//+----------------------------------------------------------------------------
//
// Function:  GetRasModems
//
// Synopsis:  Enumerates the available RAS devices.  The device list is allocated and passed
//           back to the caller through the pprdiRasDevInfo pointer.  This allocated memory
//           must be freed by the caller.  The count of available devices is stored in the
//           pdwCnt input parameter.
//
// Arguments: RasLinkageStruct *prlsRasLink - pointer to the RAS Linkage structure
//            LPRASDEVINFO *pprdiRasDevInfo - pointer to hold the RAS device list
//            LPDWORD pdwCnt - pointer to hold the count of devices
//
// Returns:   BOOL - FALSE if unable to return the enumerated device list.
//
// History:   quintinb Created Header    01/04/2000
//
//+----------------------------------------------------------------------------

BOOL GetRasModems(const RasLinkageStruct *prlsRasLink, 
                                  LPRASDEVINFO *pprdiRasDevInfo, 
                                  LPDWORD pdwCnt) 
{
    DWORD dwLen;
    DWORD dwRes;
    DWORD dwCnt;

    if (pprdiRasDevInfo) 
    {
        *pprdiRasDevInfo = NULL;
    }
        
    if (pdwCnt) 
    {
        *pdwCnt = 0;
    }
        
    if (!prlsRasLink->pfnEnumDevices) 
    {
        return (FALSE);
    }
        
    dwLen = 0;
    dwRes = prlsRasLink->pfnEnumDevices(NULL,&dwLen,&dwCnt);

    CMTRACE3(TEXT("GetRasModems() RasEnumDevices(NULL,pdwLen,&dwCnt) returns %u, dwLen=%u, dwCnt=%u."), 
        dwRes, dwLen, dwCnt);
        
    if (((dwRes != ERROR_SUCCESS) && (dwRes != ERROR_BUFFER_TOO_SMALL)) || (dwLen < sizeof(**pprdiRasDevInfo))) 
    {
        return (FALSE);
    }

    if (!pprdiRasDevInfo) 
    {
        if (pdwCnt)
        {
            *pdwCnt = dwCnt;
        }
        return (TRUE);
    }
        
    *pprdiRasDevInfo = (LPRASDEVINFO) CmMalloc(__max(dwLen,sizeof(**pprdiRasDevInfo)));

    if (*pprdiRasDevInfo)
    {
        (*pprdiRasDevInfo)->dwSize = sizeof(**pprdiRasDevInfo);
        dwRes = prlsRasLink->pfnEnumDevices(*pprdiRasDevInfo,&dwLen,&dwCnt);

        CMTRACE3(TEXT("GetRasModems() RasEnumDevices(*pprdiRasDevInfo,&dwLen,&dwCnt) returns %u, dwLen=%u, dwCnt=%u."), 
                 dwRes, dwLen, dwCnt);

        if (dwRes != ERROR_SUCCESS) 
        {
            CmFree(*pprdiRasDevInfo);
            *pprdiRasDevInfo = NULL;
            return (FALSE);
        }
    }
    else
    {
        CMASSERTMSG(FALSE, TEXT("GetRasModems -- CmMalloc failed to allocate memory for *pprdiRasDevInfo."));
        return (FALSE);
    }
    
    if (pdwCnt)
    {
        *pdwCnt = dwCnt;
    }

    return (TRUE);
}


//+----------------------------------------------------------------------------
//
// Function:  PickModem
//
// Synopsis:  
//
// Arguments: const pArgs, the pArgs->pIniProfile contains the modem name
//            OUT pszDeviceType, the device type if not NULL
//            OUT pszDeviceName, the device name if not NULL
//            OUT pfSameModem,   Whether the modem found is the same as 
//                               the one in profile
//
// Returns:   TRUE, is modem is found
//
// History:   fengsun Created Header    10/24/97
//
//+----------------------------------------------------------------------------
BOOL PickModem(IN const ArgsStruct *pArgs, OUT LPTSTR pszDeviceType, 
               OUT LPTSTR pszDeviceName, OUT BOOL* pfSameModem) 
{
    LPRASDEVINFO prdiModems;
    DWORD dwCnt;
    LPTSTR pszModem;
    DWORD dwIdx;
    BOOL bFound = FALSE;

    //
    // First, get a list of modems from RAS
    //
    
    if (!GetRasModems(&pArgs->rlsRasLink,&prdiModems,&dwCnt) || dwCnt == 0) 
    {
        return (FALSE);
    }

    if (pfSameModem)
    {
        *pfSameModem = FALSE;
    }

    //
    // Get the name of the current modem from the service profile and 
    // try to find a match against non-tunnel RAS devices in the list 
    //
    pszModem = pArgs->piniProfile->GPPS(c_pszCmSection, c_pszCmEntryDialDevice);

    if (*pszModem) 
    {
        CMTRACE1(TEXT("PickModem() - looking for match with %s"), pszModem);

        for (dwIdx=0; dwIdx < dwCnt; dwIdx++) 
        {               
            CMTRACE2(TEXT("PickModem() - examining device (%s) of type (%s)"), prdiModems[dwIdx].szDeviceName, prdiModems[dwIdx].szDeviceType);

            // 
            // we'll take only ISDN and modem devices
            //
            if (lstrcmpiU(prdiModems[dwIdx].szDeviceType, RASDT_Isdn) &&
                lstrcmpiU(prdiModems[dwIdx].szDeviceType, RASDT_Modem) &&
                lstrcmpiU(prdiModems[dwIdx].szDeviceType, RASDT_Atm))
            {
                continue;
            }

            // 
            // If we have a match, we're done here
            //

            if (lstrcmpiU(pszModem,prdiModems[dwIdx].szDeviceName) == 0) 
            {
                CMTRACE(TEXT("PickModem() - match found."));
                bFound = TRUE;
                if (pfSameModem)
                {
                    *pfSameModem = TRUE;
                }
                break;
            }
        }
    }

    if (FALSE == bFound)
    {
        //
        // No match, find the first non-tunnel device and use it by default.
        //

        CMTRACE(TEXT("PickModem() - enumerating devices for default match against type RASDT_Isdn, RASDT_Modem or RASDT_Atm")); 
        
        for (dwIdx=0; dwIdx < dwCnt; dwIdx++) 
        {
            CMTRACE2(TEXT("PickModem() - examining device (%s) of type (%s)"), prdiModems[dwIdx].szDeviceName, prdiModems[dwIdx].szDeviceType); 
            
            //
            // we'll take only ISDN and modem devices
            //

            if (!lstrcmpiU(prdiModems[dwIdx].szDeviceType, RASDT_Isdn) ||
                 !lstrcmpiU(prdiModems[dwIdx].szDeviceType, RASDT_Modem) ||
                 !lstrcmpiU(prdiModems[dwIdx].szDeviceType, RASDT_Atm)) 
            {
                CMTRACE2(TEXT("PickModem() - default device (%s) of type (%s) selected."), prdiModems[dwIdx].szDeviceName, prdiModems[dwIdx].szDeviceType);
                bFound = TRUE;
                break;
            }
        }
    }

    // 
    // If we have a match, fill device name and device type
    //

    if (bFound)
    {
        if (pszDeviceType) 
        {
            lstrcpyU(pszDeviceType,prdiModems[dwIdx].szDeviceType);
        }
        
        if (pszDeviceName) 
        {
            lstrcpyU(pszDeviceName,prdiModems[dwIdx].szDeviceName);
        }
    }

    CmFree(pszModem);
    CmFree(prdiModems);
    return (bFound);
}

//+----------------------------------------------------------------------------
//
// Function:  GetDeviceType
//
// Synopsis:  Get the deviceType for a chosen device name
//
// Arguments: pArgs - Pointer to ArgsStruct
//            pszDeviceType[OUT] - pointer to buffer where device 
//                                 type will be returned
//            uNumCharsInDeviceType [IN] - number of chars of memory available in pszDeviceType
//            pszDeviceName[IN] - device name
//
// Returns:   TRUE on success, FALSE otherwise
//
// History:   byao  Created  03/21/97
//-----------------------------------------------------------------------------
BOOL GetDeviceType(ArgsStruct *pArgs, LPTSTR pszDeviceType, UINT uNumCharsInDeviceType, LPTSTR pszDeviceName)
{
    LPRASDEVINFO prdiModems;
    DWORD dwCnt, dwIdx;

    if (!pszDeviceType)
    {
        return FALSE;
    }

    // first, get a list of modems from RAS
    if (!GetRasModems(&pArgs->rlsRasLink,&prdiModems,&dwCnt)) 
    {
        return (FALSE);
    }

    // choose the device that has the same name as pszDeviceName
    for (dwIdx=0;dwIdx<dwCnt;dwIdx++) 
    {
        if (lstrcmpiU(pszDeviceName,prdiModems[dwIdx].szDeviceName) == 0) 
        {
            lstrcpynU(pszDeviceType, prdiModems[dwIdx].szDeviceType, uNumCharsInDeviceType);
            break;
        }
    }

    CmFree(prdiModems);

    if (dwIdx == dwCnt)  // not found in the modem list -- strange things happened
    {
        return FALSE; 
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
//      Function        PickTunnelDevice
//
//      Synopsis        pick a tunnel device used to dial out
//
//      Arguments       
//                              pszDeviceType   Tunnel device type. -- RASDT_Vpn
//                              pszDeviceName   Tunnel device name
//                              prdiModems              Pointer to a list of modems
//                              dwCnt                   Total number of modems available in the system
//
//      Returns         TRUE                    succeed
//                              FALSE                   otherwise
//
//      History         3/1/97          byao            Created
//
//-----------------------------------------------------------------------------
BOOL PickTunnelDevice(LPTSTR pszDeviceType, 
                                          LPTSTR pszDeviceName, 
                                          LPRASDEVINFO prdiModems, 
                                          DWORD dwCnt) 
{
    DWORD dwIdx;

    if (dwCnt == 0) 
    {
        return (FALSE);
    }
    
    for (dwIdx=0;dwIdx<dwCnt;dwIdx++) 
    {
        if (lstrcmpiU(pszDeviceType,prdiModems[dwIdx].szDeviceType) == 0) 
        {
            break;
        }
    }

    if (dwIdx == dwCnt) 
    {
        return (FALSE);
    }

    if (pszDeviceType) 
    {
        lstrcpyU(pszDeviceType,prdiModems[dwIdx].szDeviceType);
    }

    if (pszDeviceName) 
    {
        lstrcpyU(pszDeviceName,prdiModems[dwIdx].szDeviceName);
    }

        return (TRUE);
}

//+----------------------------------------------------------------------------
//
//      Function        PickTunnelDevice
//
//      Synopsis        pick a tunnel device used to dial out
//
//      Arguments       pArgs                   Pointer to ArgsStruct
//                              pszDeviceType   Tunnel device type. --  RASDT_Vpn
//                              pszDeviceName   Tunnel device name
//
//      Returns         TRUE - scripting has been installed
//
//      History         3/1/97          byao            Created
//
//-----------------------------------------------------------------------------
BOOL PickTunnelDevice(ArgsStruct *pArgs, 
                                          LPTSTR pszDeviceType, 
                                          LPTSTR pszDeviceName) 
{
        LPRASDEVINFO prdiModems;
        DWORD dwCnt;
        BOOL bRes;

        // first, get a list of modems from RAS
        if (!GetRasModems(&pArgs->rlsRasLink,&prdiModems,&dwCnt)) 
    {
                return (FALSE);
        }

        // then, pick up the one used for tunneling
        bRes = PickTunnelDevice(pszDeviceType,pszDeviceName,prdiModems,dwCnt);
        CmFree(prdiModems);
        return (bRes);
}

//+----------------------------------------------------------------------------
//
// Function:  CopyAutoDial
//
// Synopsis:  Sets the szAutodialDll and szAutodialFunc members of the 
//            specified RAS entry structure with our module name and
//            InetDialHandler repectively. Not on NT5.
//
// Arguments: LPRASENTRY preEntry - Ptr to the Ras entry structure.
//
// Returns:   Nothing
//
// History:   nickball    Created Header    03/16/98
//            nickball    Removed from NT5  11/17/98
//
//+----------------------------------------------------------------------------
void CopyAutoDial(LPRASENTRY preEntry) 
{
    MYDBGASSERT(preEntry);

    //
    // Don't set these on NT5, they are no longer used by IE and the 
    // InetDialHandler prototype differs from that used by RAS
    //

    if (OS_NT5 || NULL == preEntry)
    {
        return;
    }

    memset(preEntry->szAutodialDll,0,sizeof(preEntry->szAutodialDll));

    //
    // Set szAutodialDll with our Module name
    //

    GetModuleFileNameU(g_hInst, preEntry->szAutodialDll, sizeof(preEntry->szAutodialDll)/sizeof(TCHAR));    

    //
    // Set szAutodialFunc with the mangled form of InetDialHandler
    //

    memset(preEntry->szAutodialFunc,0,sizeof(preEntry->szAutodialFunc));
    lstrcpyU(preEntry->szAutodialFunc, c_pszInetDialHandler);
}

//+----------------------------------------------------------------------------
//
//      Function        MyRGEP
//
//      Synopsis        Call RasGetEntryProperties()
//                              
//      Arguments       
//
//      Returns         
//
//      Histroy         Revised to improve performance  08/7/97 fengsun
//-----------------------------------------------------------------------------
LPRASENTRY MyRGEP(LPCTSTR pszRasPbk, LPCTSTR pszEntryName, RasLinkageStruct *prlsRasLink) 
{
    LPRASENTRY preRasEntry;
    DWORD dwRes;

    if (!(preRasEntry = AllocateRasEntry()))
    {
        MYDBGASSERT(0);
        return NULL;
    }

    DWORD dwRasEntry = preRasEntry->dwSize;

    dwRes = prlsRasLink->pfnGetEntryProperties(pszRasPbk,
                                               pszEntryName,
                                               preRasEntry,
                                               &dwRasEntry,
                                               NULL,  // lpbDeviceInfo
                                               NULL); // lpdwDeviceInfoSize

    CMTRACE2(TEXT("MyRGEP() - dwRasEntry = %u : sizeof(*preRasEntry) = %u"), dwRasEntry, sizeof(*preRasEntry));
    
    if ((dwRes == ERROR_BUFFER_TOO_SMALL) && (dwRasEntry >= sizeof(*preRasEntry))) 
    {
        //
        // If the memory if not large enough, realloc one
        //
        CmFree(preRasEntry);

        preRasEntry = (LPRASENTRY) CmMalloc(dwRasEntry);

        if (NULL != preRasEntry)
        {
            //
            // dwSize has to be set to sizeof(RASENTRY)
            // because dwRasEntry contains the additional
            // bytes required for this connectoid (alternative
            // phone numbers, etc.
            //
            preRasEntry->dwSize = sizeof(RASENTRY); // Specifies version

            dwRes = prlsRasLink->pfnGetEntryProperties (pszRasPbk,
                                                        pszEntryName,
                                                        preRasEntry,
                                                        &dwRasEntry,
                                                        NULL,
                                                        NULL);
        }
        else
        {
            MYDBGASSERT(0);
            return NULL;
        }
    }

    if (dwRes != ERROR_SUCCESS) 
    {
        CMTRACE3(TEXT("MyRGEP(*pszRasPbk=%s, *pszEntryName=%s) RasGetEntryProperties returned %u"), pszRasPbk, pszEntryName, dwRes);
        CmFree(preRasEntry);
        preRasEntry = NULL;
    }

    SetLastError(dwRes);
    return (preRasEntry);
}

//+----------------------------------------------------------------------------
//
//  Function    IsConnectErrorFatal
//
//  Synopsis    Determine if an error is recoverable, (ie. we should re-dial). 
//
//  Arguments   DWORD dwErr             - The RAS error code
//              ArgsStruct* pArgs       - Ptr to global args struct
//
//  Returns     TRUE if error is fatal
//
//  Histroy     nickball    Created header  05/21/99     
//    
//-----------------------------------------------------------------------------
BOOL IsConnectErrorFatal(DWORD dwErr, ArgsStruct *pArgs)
{
    switch (dwErr)
    {
        //
        // The following cases are W9x ISDN error returns that actually mean
        // different things on WinNT.  Since we use the NT header files, we don't
        // have an include file that contains these errors.  We have to special
        // case these so that we recognize them as ISDN errors, and reconnect as
        // appropriate.
        //
        // The 9x errors are listed below along with the NT equivalents.
        //

    case 751:       // 9x.ERROR_BAD_DEST_ADDRESS    == NT.ERROR_INVALID_CALLBACK_NUMBER 
    case 752:       // 9x.ERROR_UNREACHABLE_DEST    == NT.ERROR_SCRIPT_SYNTAX
    case 753:       // 9x.ERROR_INCOMPATIBLE_DEST   == NT.ERROR_HANGUP_FAILED
    case 754:       // 9x.ERROR_NETWORK_CONGESTION  == NT.ERROR_BUNDLE_NOT_FOUND
    case 755:       // 9x.ERROR_CALL_BLOCKED        == NT.ERROR_CANNOT_DO_CUSTOMDIAL
    case 756:       // 9x.ERROR_NETWORK_TEMPFAILURE == NT.ERROR_DIAL_ALREADY_IN_PROGRESS
        if (OS_W9X)
        {
            //
            // On W9x, if you have an invalid ISDN number, the error codes
            // returned by Millennium RAS are different from the NT ones.
            // We have to special-case these by number so that we reconnect
            //
            CMTRACE1(TEXT("IsConnectErrorFatal : handled Win9x ISDN error %d"), dwErr);
            return FALSE;
        }
        break;

    case ERROR_PPP_TIMEOUT:             // Timed out waiting for a valid response from the remote PPP peer.%0
    case ERROR_PPP_REMOTE_TERMINATED:   // PPP terminated by remote machine.%0
    case ERROR_PPP_INVALID_PACKET:      // The PPP packet is invalid.%0
    case ERROR_PPP_NO_RESPONSE:         // Remote PPP peer is not responding
    case ERROR_SERVER_NOT_RESPONDING:
    case ERROR_LINE_BUSY:
    case ERROR_NO_CARRIER:
    case ERROR_REMOTE_DISCONNECTION:
    case ERROR_BAD_ADDRESS_SPECIFIED:
    case ERROR_AUTOMATIC_VPN_FAILED:    // New ras error for VPN
        return FALSE;
        break;
    case ERROR_NO_ANSWER: 
        {
            // 
            // For ISDN (Whistler bug#384223) we want to make sure CM displays the correct ras error (same as TAPI)
            // thus we have to treat this error as a fatal error.
            // This should return TRUE for the first time we are dialing and only dual-channel mode
            //
            if (0 == lstrcmpiU(pArgs->szDeviceType, RASDT_Isdn) && (pArgs->nMaxRedials == pArgs->nRedialCnt))
            {
                if (CM_ISDN_MODE_DUALCHANNEL_ONLY == pArgs->dwIsdnDialMode)
                {
                    return TRUE;
                }
            }

            return FALSE;
            break;
        }

        
    default:
        break;
    }

    return TRUE;
}


//+----------------------------------------------------------------------------
//
//  Function    IsRasError
//
//  Synopsis    Simple function to determine if an error falls in the RAS range
//
//  Arguments   DWORD dwErr - The error code
//
//  Returns     TRUE if error is within RAS range
//
//  Histroy     nickball    Created header  05/21/99     
//    
//-----------------------------------------------------------------------------
inline BOOL IsRasError(DWORD dwErr)
{
   return ((dwErr >= RASBASE) && (dwErr <= RASBASEEND));
}

//+----------------------------------------------------------------------------
//
//  Function    CheckConnectionError
//
//  Synopsis    Determine if a RAS error is recoverable. If not recoverable, 
//              retrieves the appropriate error message for display.
//
//  Arguments   DWORD dwErr             - The RAS error code
//              ArgsStruct* pArgs       - Ptr to global args struct
//              BOOL   fTunneling       - Flag indicating whether we're tunneling
//              LPTSTR *ppszRasErrMsg   - Pointer to pointer for message string
//
//  Returns     TRUE if error is fatal
//
//  Histroy     nickball    Created header  05/21/99     
//    
//-----------------------------------------------------------------------------
BOOL CheckConnectionError(HWND hwndDlg, 
    DWORD dwErr, 
    ArgsStruct *pArgs,
    BOOL    fTunneling,
    LPTSTR   *ppszRasErrMsg)
{
    DWORD dwIdMsg = 0;
    LPTSTR pszMsg = NULL;
    LPTSTR pszTmp = NULL;

    //
    // Examine the error more closely. Note: For W2K, we skip RAS 
    // errors and query RAS for a displayable error string below.
    //

    if ((!OS_NT5) || (!IsRasError(dwErr)))
    {  
        switch (dwErr) 
        {
            case ERROR_PPP_TIMEOUT:             // Timed out waiting for a valid response from the remote PPP peer.%0
            case ERROR_PPP_REMOTE_TERMINATED:   // PPP terminated by remote machine.%0
            case ERROR_PPP_INVALID_PACKET:      // The PPP packet is invalid.%0
            case ERROR_PPP_NO_RESPONSE:         // Remote PPP peer is not responding
            case ERROR_SERVER_NOT_RESPONDING:
                dwIdMsg = IDMSG_PPPPROBLEM;
                break;

            case ERROR_LINE_BUSY:
                if ((pArgs->nDialIdx+1 == MAX_PHONE_NUMBERS || 
                    !pArgs->aDialInfo[pArgs->nDialIdx+1].szDialablePhoneNumber[0]) &&
                    !pArgs->nRedialCnt)
                    dwIdMsg = IDMSG_LINEBUSY;
                else
                    dwIdMsg = IDMSG_LINEBUSYREDIAL;

                break;

            case ERROR_NO_ANSWER:
            case ERROR_NO_CARRIER:
                if ((pArgs->nDialIdx+1 == MAX_PHONE_NUMBERS || 
                    !pArgs->aDialInfo[pArgs->nDialIdx+1].szDialablePhoneNumber[0]) &&
                    !pArgs->nRedialCnt)
                    dwIdMsg = fTunneling ? IDMSG_TUNNEL_NOANSWER : IDMSG_NOANSWER ;
                else
                    dwIdMsg = fTunneling ? IDMSG_TUNNEL_NOANSWERREDIAL : IDMSG_NOANSWERREDIAL;
                break;

            case ERROR_REMOTE_DISCONNECTION:
                dwIdMsg = IDMSG_REMOTEDISCONNECTED;
                break;

            case ERROR_BAD_ADDRESS_SPECIFIED:
                dwIdMsg = IDMSG_TUNNEL_NOANSWERREDIAL;
                break;

            case ERROR_PPP_NO_PROTOCOLS_CONFIGURED: // No PPP control protocols configured.%0
                dwIdMsg = IDMSG_TCPIPPROBLEM;
                break;

            case ERROR_PORT_ALREADY_OPEN:
                dwIdMsg = fTunneling ? IDMSG_TUNNELINUSE : IDMSG_PORTINUSE ;
                break;

            case ERROR_FROM_DEVICE:
                dwIdMsg = IDMSG_DEVICEERROR;
                break;

            case ERROR_HARDWARE_FAILURE:
            case ERROR_PORT_OR_DEVICE: //11694
            case ERROR_DEVICE_NOT_READY:
                dwIdMsg = IDMSG_NOTRESPONDING;
                break;

            case ERROR_NO_DIALTONE:
                dwIdMsg = IDMSG_NODIALTONE;
                break;

            case ERROR_CANCELLED:
            case ERROR_USER_DISCONNECTION:
                dwIdMsg = IDMSG_CANCELED;                
                break;

            case ERROR_AUTHENTICATION_FAILURE:
            case ERROR_ACCESS_DENIED: // 13795 // WINDOWS ERROR
                dwIdMsg = IDMSG_BADPASSWORD;
                break;

            case ERROR_VOICE_ANSWER:
                dwIdMsg = IDMSG_VOICEANSWER;
                break;
           
            case ERROR_PORT_NOT_AVAILABLE:
                if (IsDialingTunnel(pArgs))
                {
                    dwIdMsg = IDMSG_TUNNELNOTAVAILABLE;
                }
                else
                {
                    dwIdMsg = IDMSG_PORTNOTAVAILABLE;
                }
                break;

            case ERROR_PORT_NOT_CONFIGURED:
                dwIdMsg = IDMSG_PORTNOTCONFIGURED;
                break;

            case ERROR_RESTRICTED_LOGON_HOURS:
                dwIdMsg = IDMSG_RESTRICTEDLOGONHOURS;
                break;
    
            case ERROR_ACCT_DISABLED:
            case ERROR_ACCT_EXPIRED:
                dwIdMsg = IDMSG_ACCTDISABLED;
                break;

            case ERROR_PASSWD_EXPIRED:
                dwIdMsg = IDMSG_PASSWDEXPIRED;
                break;
    
            case ERROR_NO_DIALIN_PERMISSION:
                dwIdMsg = IDMSG_NODIALINPERMISSION;
                break;

            case ERROR_PROTOCOL_NOT_CONFIGURED:
                dwIdMsg = IDMSG_PROTOCOL_NOT_CONFIGURED;
                break;

            case ERROR_INVALID_DATA: // WINDOWS ERROR

                //
                // The specific case in which we encountered DUN settings
                // that aren't supported on the current platform
                //

                CMTRACE(TEXT("CheckConnectionError - Unsupported DUN setting detected"));
                dwIdMsg = IDMSG_UNSUPPORTED_SETTING;
                break;
        
            case ERROR_BAD_PHONE_NUMBER: // TBD - drop through to default
            default: 
                break;
        }
    }

    if (0 == dwIdMsg)
    {
        //
        // If no message ID was picked up, then try to get one from RAS
        //

        if (pArgs->rlsRasLink.pfnGetErrorString) 
        {
            DWORD dwRes;
            DWORD dwFmtMsgId;

            pszTmp = (LPTSTR) CmMalloc(256 * sizeof(TCHAR)); // Docs say 256 chars is always enough.
            
            if (pszTmp)
            {
                dwRes = pArgs->rlsRasLink.pfnGetErrorString((UINT) dwErr, pszTmp, (DWORD) 256);
 
                if (ERROR_SUCCESS == dwRes)
                {
                    pszMsg = CmFmtMsg(g_hInst, IDMSG_RAS_ERROR, pszTmp, dwErr);
                }
            }

            CmFree(pszTmp);
        }
        
        if (NULL == pszMsg)
        {
            //
            // Still no message, try to get description from system (on NT)
            // Note: HRESULTS are displayed in Hex, Win errors are decimal.
            
            if (OS_NT)
            {                
                if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER + FORMAT_MESSAGE_IGNORE_INSERTS + FORMAT_MESSAGE_FROM_SYSTEM,
                                  NULL, dwErr, 0, (LPTSTR) &pszTmp, 1, NULL))
                {
                    if (pszTmp)
                    {
                        pszMsg = CmFmtMsg(g_hInst, (dwErr > 0x7FFFFFFF) ? IDMSG_SYS_ERROR_HEX : IDMSG_SYS_ERROR_DEC, pszTmp, dwErr);
                        LocalFree(pszTmp);
                    }
                    else
                    {
                        CMASSERTMSG(FALSE, TEXT("CheckConnectionError -- FormatMessage failed to allocate pszTmp."));
                    }
                }
            }
            
            if (NULL == pszMsg)
            {
                //
                // Still no message, go with default
                //
                
                pszMsg = CmFmtMsg(g_hInst, (dwErr > 0x7FFFFFFF) ? IDMSG_CM_ERROR_HEX : IDMSG_CM_ERROR_DEC, dwErr);       
            }
        }
    }

    //
    // Special check for tunneling to verify that we have a device name 
    //
    
    if (IsDialingTunnel(pArgs))
    {
        //
        // Check whether the tunnel device name is valid
        //
        if (!PickTunnelDevice(pArgs,pArgs->szTunnelDeviceType,pArgs->szTunnelDeviceName)) 
        {
            pArgs->szTunnelDeviceName[0]= TEXT('\0');
            pArgs->piniProfile->WPPS(c_pszCmSection, c_pszCmEntryTunnelDevice, TEXT(""));
                       
            pszMsg = CmLoadString(g_hInst, GetPPTPMsgId());

            dwIdMsg = 0;
        }

        pArgs->piniProfile->WPPS(c_pszCmSection, c_pszCmEntryTunnelDevice, pArgs->szTunnelDeviceName);
    }

    //
    // If we have a message ID format it for display
    //

    if (dwIdMsg) 
    {
        MYDBGASSERT(!pszMsg);
        pszMsg = CmFmtMsg(g_hInst,dwIdMsg);
    }

    if (pszMsg) 
    {
        if (!ppszRasErrMsg)
        {
            AppendStatusPane(hwndDlg,pszMsg);
            CmFree(pszMsg);
        }
        else
        {
            //
            // pass the msg to the caller.  the caller needs to free it.
            //
            *ppszRasErrMsg = pszMsg;
        }
    }

    BOOL bCancel = IsConnectErrorFatal(dwErr, pArgs);

    if (bCancel && dwErr != ERROR_CANCELLED && 
        dwErr != ERROR_AUTHENTICATION_FAILURE &&
        dwErr != ERROR_ACCESS_DENIED)
    {
        //
        // if we're canceling redial, then there might be something
        // seriously wrong.  We want to recheck our configs the next
        // time CM is run.
        //
        ClearComponentsChecked();
    }
    
    return (bCancel);
}

//+----------------------------------------------------------------------------
//
//  Function    GetRasConnectoidName
//
//  Synopsis    Construct a RAS connectoid name.
//
//              The connectoid name is "<long service name>-[Primary|Backup]".
//              or "<long service name>&Tunnel" for the case of tunnel entry.
//
//  Arguments   pArgs               Pointer to ArgsStruct
//              piniService[IN]     the service obj
//              fTunnelEntry[IN]    TRUE:  This connectoid is for tunneling
//                                  FALSE: otherwise
//
//  Returns     LPTSTR              The connectoid name.
//
//-----------------------------------------------------------------------------
LPTSTR GetRasConnectoidName(
    ArgsStruct  *pArgs, 
    CIni*       piniService, 
    BOOL        fTunnelEntry
)
{
    LPTSTR  pszConnectoid = GetServiceName(piniService);
    
    if (pszConnectoid)
    {       
        //
        // If tunneling 9X connectoid, append the Tunnel 
        // Suffix - e.g. "Tunnel (for advanced use only)"
        //

        if (OS_W9X && fTunnelEntry) 
        {
            LPTSTR pszSuffix = GetTunnelSuffix();       
   
            if (pszSuffix)
            {
                pszConnectoid = CmStrCatAlloc(&pszConnectoid, pszSuffix); 
            }
   
            CmFree(pszSuffix);
        }
    }   

    return pszConnectoid;
}

//+----------------------------------------------------------------------------
//
//      Function        CreateRASEntryStruct
//
//      Synopsis        Create a connectoid with the settings specified in the cms.
//              If a parameter does NOT exist in the cms file, the corresponding 
//              value is used.
//
//              The connectoid name is "<long service name>-[Primary|Backup]".
//              or "<long service name>&Tunnel" for the case of tunnel entry.
//
//      Arguments       pArgs                           Pointer to ArgsStruct
//                              pszDUN                  DUN name
//              piniService[IN]     the service file obj
//                              fTunnelEntry[IN]        TRUE:  This connectoid is for tunneling
//                                                                      FALSE: otherwise
//              pszRasPbk           the RAS phonebook in which the connectoid is located
//              ppbEapData[OUT]         Address of pointer to store EapData, allocated here.
//                              pdwEapSize[OUT]         Ptr to a DWORD to record the size of the data blob.
//
//      Returns         LPRASENTRY          The new RAS connectoid
//
//      History         5/12/97                         henryt          created
//                              5/23/97                         byao            Modified: added fSkipProfile flag
//                              6/9/97                          byao            Modified: use DUN= field when the 
//                                                                                              phone number has no DUN name associated
//                              7/28/97                         byao            Added change for #10459
//              4/13/97             nickball    Renamed, return LPRASENTRY
//-----------------------------------------------------------------------------
LPRASENTRY CreateRASEntryStruct(
    ArgsStruct  *pArgs,
    LPCTSTR     pszDUN, 
    CIni*       piniService, 
    BOOL        fTunnelEntry,
    LPTSTR      pszRasPbk,
    LPBYTE              *ppbEapData,
    LPDWORD         pdwEapSize
)
{
    LPTSTR      pszDunEntry = NULL;
    DWORD       dwErr;
    BOOL        bTmp;

    //
    // first we need to create a RAS entry in memory with default values
    //

    LPRASENTRY  preBuffer = AllocateRasEntry();

    if (!preBuffer)
    {
        return NULL;
    }

    MYDBGASSERT(preBuffer->dwSize >= sizeof(*preBuffer));

    //
    // Set up the preBuffer to defaults value
    //

    preBuffer->dwFramingProtocol = RASFP_Ppp;

    //
    // Allow only TCP/IP by default
    //
    preBuffer->dwfNetProtocols |= RASNP_Ip;

    //
    // Set default RASEO settings.  
    //

    if (!fTunnelEntry)
    {
        preBuffer->dwfOptions |= RASEO_UseCountryAndAreaCodes   |
                                 RASEO_IpHeaderCompression      |
                                 RASEO_RemoteDefaultGateway     |
                                 RASEO_SwCompression;
                                 //RASEO_SecureLocalFiles;      // NT 427042
                                 //RASEO_DisableLcpExtensions;  //13059 Olympus + 289461 NT 
        //
        //  We want to honor the HideTrayIcon flag.  If it is not NT5, then
        //  we always set this flag.  If it is NT5, then we should only set
        //  this flag if HideTrayIcon is false.
        //

        if (!OS_NT5 || !(pArgs->piniService->GPPI(c_pszCmSection, c_pszCmEntryHideTrayIcon)))
        {
            preBuffer->dwfOptions |= RASEO_ModemLights;
        }

        //
        //  In order for users to be able to specify device settings on Whistler,
        //  they have to do it from the control panel and we have to set the
        //  RASEO2_UseGlobalDeviceSettings flag in dwfOptions2.
        //
        if (OS_NT51)
        {
            ((LPRASENTRY_V501)preBuffer)->dwfOptions2 |= RASEO2_UseGlobalDeviceSettings;
        }

        //
        // We should have the devicename/devicetype by now.
        // (PickModem should be called)
        //
        
        MYDBGASSERT(pArgs->szDeviceType[0]);
        MYDBGASSERT(pArgs->szDeviceName[0]);

        lstrcpynU(preBuffer->szDeviceType, pArgs->szDeviceType, 
                    sizeof(preBuffer->szDeviceType)/sizeof(TCHAR));
        
        lstrcpynU(preBuffer->szDeviceName, pArgs->szDeviceName, 
                    sizeof(preBuffer->szDeviceName)/sizeof(TCHAR));
    }
    else
    {              
        preBuffer->dwfOptions = RASEO_IpHeaderCompression       |
                                RASEO_RemoteDefaultGateway      |
                                RASEO_NetworkLogon              |
                                RASEO_SwCompression;            
                                //RASEO_SecureLocalFiles        // NT 427042
                                //RASEO_DisableLcpExtensions    
        //
        //  Always set Modem lights on direct connection, unless HideTrayIcon
        //  flag is explicitly set in the .CMS. #262825, #262988
        //

        if (!(pArgs->piniService->GPPI(c_pszCmSection, c_pszCmEntryHideTrayIcon)))
        {           
            preBuffer->dwfOptions |= RASEO_ModemLights;
        }
   
        MYDBGASSERT(pArgs->szTunnelDeviceType[0]);
        MYDBGASSERT(pArgs->szTunnelDeviceName[0]);

        lstrcpynU(preBuffer->szDeviceType, pArgs->szTunnelDeviceType, 
                    sizeof(preBuffer->szDeviceType)/sizeof(TCHAR));
                
        lstrcpynU(preBuffer->szDeviceName, pArgs->szTunnelDeviceName, 
                    sizeof(preBuffer->szDeviceName)/sizeof(TCHAR));

        lstrcpyU(preBuffer->szLocalPhoneNumber, pArgs->GetTunnelAddress());
    }

    //
    //  Check to see if we need to tell RAS that this connection has Internet Connectivity or not
    //
    if (OS_NT51)
    {
        //
        //  Note that we use the top level service profile on purpose here (pArgs->pIniService directly)
        //  as this is a profile global setting.
        //
        if (pArgs->piniService->GPPB(c_pszCmSection, c_pszCmEntryInternetConnection,
                                     (BOOL) ((LPRASENTRY_V501)preBuffer)->dwfOptions2 & RASEO2_Internet)) 
        {
            ((LPRASENTRY_V501)preBuffer)->dwfOptions2 |= RASEO2_Internet;
        } 
        else 
        {
            ((LPRASENTRY_V501)preBuffer)->dwfOptions2 &= ~RASEO2_Internet;
        }
    }

    //
    // If we have a specific DUN name to use, then 
    // use it instead of the default DUN setting in the .CMS.
    //

    if (pszDUN && *pszDUN)
    {
        pszDunEntry = CmStrCpyAlloc(pszDUN);
    }
    else
    {
        pszDunEntry = GetDefaultDunSettingName(piniService, fTunnelEntry);
    }

    //
    // If we have a DUN setting name, read the settings from cms
    //

    if (pszDunEntry && *pszDunEntry)
    {
        dwErr = (DWORD)ReadDUNSettings(pArgs, piniService->GetFile(), pszDunEntry, preBuffer, ppbEapData ,pdwEapSize, fTunnelEntry);

        if (ERROR_SUCCESS != dwErr)
        {
            CMTRACE(TEXT("UpdateRASConnectoid: ReadDUNSettings failed"));
            CmFree(preBuffer);
            preBuffer = NULL;
            goto exit;
        }
    }

    //
    // Get autodial information, store in preBuffer
    //

    CopyAutoDial(preBuffer); 
        
    //
    // disable the RAS wizard on Win95
    //
    if (OS_W9X)
    {
        DisableWin95RasWizard();
    }

exit:
    if (pszDunEntry)
    {
        CmFree(pszDunEntry);
    }
      
    SetLastError(dwErr);

    return preBuffer;
}

//+----------------------------------------------------------------------------
//
//  Function    CreateRasPrivatePbk
//
//  Synopsis    Create the private RAS phone book and returns the full path.
//
//  Arguments   pArgs       Pointer to global Args struct
//
//  Returns     LPTSTR      The full path name of the newly created private pbk
//
//  History     ??/??/97    henryt      created
//
//              01/15/99    Jeffspr     Changed the GetTempFileName pattern,
//                                      as it was using more than the allowed/
//                                      used 3 chars, plus made the failure 
//                                      case use the same pattern (we will 
//                                      filter on this in the connection 
//                                      enumerator to ignore these entries).
//
//              05/21/99    nickball    Added allocation, removed input buf
//              04/10/00    quintinb    Removed GetTempFileName as we no longer
//                                      want this file to be temporary.  Changed
//                                      the function to create a file named _cmphone.pbk
//                                      in the profile directory.
//                                      Please see Whistler bug 15812 for details.
//              07/05/00    t-urama     Changed the path to the hidden pbk to point
//                                      to the RAS pbk.
//
//-----------------------------------------------------------------------------

LPTSTR CreateRasPrivatePbk(ArgsStruct  *pArgs)
{   
    //
    //  No private PBK on win9x, everything is in the registry.
    //
    if (OS_W9X)
    {
        return NULL;
    }

    if (NULL == pArgs)
    {
        MYDBGASSERT(pArgs);
        return NULL;
    }

    LPTSTR pszHiddenPbkPath = NULL;
    LPCTSTR pszCmp = pArgs->piniProfile->GetFile();

    //
    // This version of the function uses the function GetPathToPbk in connect.cpp to find the path
    // to the phone book. The hidden phone book also has to be created in the same directory.
    //
    if (pszCmp)
    {
        LPTSTR pszRasPbkDir = GetPathToPbk(pszCmp, pArgs);
        MYDBGASSERT(pszRasPbkDir);

        if (pszRasPbkDir)
        {
            pszHiddenPbkPath = (LPTSTR) CmMalloc((lstrlen(pszRasPbkDir) + lstrlen(CM_PBK_FILTER_PREFIX) + 7) * sizeof(TCHAR));

            if (pszHiddenPbkPath)
            {
                wsprintfU(pszHiddenPbkPath, TEXT("%s\\%sphone"), pszRasPbkDir, CM_PBK_FILTER_PREFIX);
                MYDBGASSERT(pszHiddenPbkPath);
                
                HANDLE hFile = INVALID_HANDLE_VALUE;
                SECURITY_ATTRIBUTES sa = {0};
                PSECURITY_ATTRIBUTES pSA = NULL;
                PSECURITY_DESCRIPTOR pSd = NULL;

                if (OS_NT5 && pArgs->fAllUser)
                {
                    //
                    // Be sure to create it with a security descriptor that 
                    // allows it to be read by any authenticated user.  If we don't it may 
                    // prevent other users from being able to read it. We didn't want to 
                    // change the old behavior downlevel so this fix is just for Whistler+.
                    //
                    DWORD dwErr = AllocateSecurityDescriptorAllowAccessToWorld(&pSd);
                    if ((ERROR_SUCCESS == dwErr) && pSd)
                    {
                        sa.nLength = sizeof(SECURITY_ATTRIBUTES);
                        sa.lpSecurityDescriptor = pSd;
                        sa.bInheritHandle = TRUE;

                        pSA = &sa;
                    }
                }                
               
                hFile = CreateFileU(pszHiddenPbkPath, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE,
                                           pSA, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);


                CmFree(pSd);

                if (hFile == INVALID_HANDLE_VALUE)
                {
                    DWORD dwLastError = GetLastError();
                    MYDBGASSERT(hFile != INVALID_HANDLE_VALUE);
                    CMTRACE1(TEXT("CreateRasPrivatePbk - CreateFileU failed. GetLastError = %d"), dwLastError);
                }
                CloseHandle(hFile);
            }
            else
            {
                CMASSERTMSG(FALSE, TEXT("CreateRasPrivatePbk -- CmMalloc returned NULL for pszHiddenPbkPath"));
            }

            CmFree(pszRasPbkDir);
        }
    }
    
    return pszHiddenPbkPath;
}



//+----------------------------------------------------------------------------
//
//      Function        GetPathToPbk
//
//      Synopsis        This function is a helper function called by 
//                      CheckAccessToCmpAndPbk in connect.cpp and by 
//                      CreateRasPrivatePbk. It returns the path to the RAS
//                      phonebook.
//
//      Arguments       LPTSTR pszCmp       - The path to the cmp file
//                      LPTSTR pszRasPbk    - The string to store the result
//                      ArgsStruct *pArgs   - pArgs
//
//      Returns         NONE
//
//      History         07/05/00                        t-urama         created
//----------------------------------------------------------------------------- 
LPTSTR GetPathToPbk(LPCTSTR pszCmp, ArgsStruct *pArgs)
{
    MYDBGASSERT(pArgs); 
    if (NULL == pArgs)
    {
        return NULL;
    }

    MYDBGASSERT(pszCmp); 
    if (NULL == pszCmp)
    {
        return NULL;
    }

    LPTSTR pszRasPbk = NULL;

    //
    //  pszRasPbk could be NULL if we are on NT4 or we are using the
    //  all user default phonebook.
    //
    if (NULL == pArgs->pszRasPbk)
    {
        if (OS_NT4)
        {
            DWORD dwSize = (MAX_PATH + 1);
            DWORD dwRet;
            BOOL bExitLoop = TRUE;

            do
            {
                pszRasPbk = (LPTSTR)CmMalloc(dwSize*sizeof(TCHAR));

                if (pszRasPbk)
                {
                    dwRet = GetSystemDirectoryU(pszRasPbk, dwSize);
                    if (dwRet)
                    {
                        if (dwRet > dwSize)
                        {
                            dwSize = dwRet + 1;
                            bExitLoop = FALSE;  //  we didn't get all of the string, try again
                            CmFree(pszRasPbk);
                        }
                        else
                        {
                            bExitLoop = TRUE;
                            CmStrCatAlloc(&pszRasPbk, c_pszRasDirRas);
                        }
                    }
                    else
                    {
                        CmFree(pszRasPbk);
                        pszRasPbk = NULL;
                    }
                }
                else
                {
                    CMASSERTMSG(FALSE, TEXT("GetPathToPbk -- CmMalloc failed!"));
                    return NULL;
                }
            } while (!bExitLoop);
        }
        else
        {
            pszRasPbk = CmStrCpyAlloc(pszCmp);

            if (pszRasPbk)
            {
                LPTSTR pszSlash = CmStrrchr(pszRasPbk, TEXT('\\'));
                if (pszSlash)
                {
                    *pszSlash = TEXT('\0'); // remove <shortservicename>.cmp

                    pszSlash = CmStrrchr(pszRasPbk, TEXT('\\'));

                    if (pszSlash)
                    {
                        *pszSlash = TEXT('\0');

                        CmStrCatAlloc(&pszRasPbk, TEXT("\\"));
                        CmStrCatAlloc(&pszRasPbk, c_pszPbk);
                    }
                    else
                    {
                        CMASSERTMSG(FALSE, TEXT("GetPathToPbk -- unable to convert cmp path to pbk path."));
                        CmFree(pszRasPbk);
                        pszRasPbk = NULL;
                    }

                
                }
                 
                else
                {
                    CMASSERTMSG(FALSE, TEXT("GetPathToPbk -- unable to convert cmp path to pbk path!"));
                    CmFree(pszRasPbk);
                    pszRasPbk = NULL;
                }
            }
        }
    }
    else
    {
        pszRasPbk = CmStrCpyAlloc(pArgs->pszRasPbk);
        LPTSTR pszSlash = CmStrrchr(pszRasPbk, TEXT('\\'));
        if (pszSlash)
        {
            *pszSlash = TEXT('\0'); // remove the RAS phonebook name
        }   
        else
        {
            CMASSERTMSG(FALSE, TEXT("GetPathToPbk -- unable to convert RAS pbk name to pbk path!"));
            CmFree(pszRasPbk);
            pszRasPbk = NULL;
        }
    }

    return pszRasPbk;
}

//+----------------------------------------------------------------------------
//
//      Function        DisableWin95RasWizard
//
//      Synopsis        This function disable the Win95 Dial-up Networking wizard
//              by writing a dword reg value 0x00000080 in the registry.
//
//      Arguments       NONE
//
//      Returns         NONE
//
//      History         7/1/97                          henryt          created
//-----------------------------------------------------------------------------
void DisableWin95RasWizard(
    void)
{
    HKEY    hkReg = NULL;
    LONG    lRes;
    DWORD   dwSize;
    DWORD   dwType;
    DWORD   dwValue;

    lRes = RegOpenKeyExA(HKEY_CURRENT_USER, c_pszRegRemoteAccess, 0,
                         KEY_QUERY_VALUE|KEY_SET_VALUE, &hkReg);

    if (ERROR_SUCCESS != lRes)
    {
        CMTRACE1(TEXT("DisableWin95RasWizard() RegOpenKeyEx() failed, GLE=%u."), lRes);
        goto exit;
    }
        
    //
    // see if we already have a value there.
    //
    dwSize = sizeof(DWORD);
    lRes = RegQueryValueExA(hkReg, 
                            c_pszRegWizard, 
                            NULL, 
                            &dwType,
                            (LPBYTE)&dwValue,
                            &dwSize);

    if (lRes == ERROR_SUCCESS   &&
        dwSize == sizeof(DWORD) &&
        dwType == REG_BINARY    &&
        dwValue == ICM_RAS_REG_WIZARD_VALUE) 
    {
        CMTRACE(TEXT("DisableWin95RasWizard() RegQueryValueEx() - found correct value."));
        goto exit;
    }
        
    //
    // well, the value is not in reg yet.  we need to create the value.
    //
    dwValue = ICM_RAS_REG_WIZARD_VALUE;
    lRes = RegSetValueExA(hkReg, 
                          c_pszRegWizard,
                          0, 
                          REG_BINARY, 
                          (LPBYTE)&dwValue, 
                          sizeof(dwValue));
#ifdef DEBUG
    if (ERROR_SUCCESS != lRes)
    {
        CMTRACE1(TEXT("DisableWin95RasWizard() RegSetValueEx() failed, GLE=%u."), lRes);
    }
#endif    
exit:

    if (hkReg)
    {
        lRes = RegCloseKey(hkReg);

#ifdef DEBUG
        if (ERROR_SUCCESS != lRes)
        {
            CMTRACE1(TEXT("DisableWin95RasWizard() RegCloseKey() failed, GLE=%u."), lRes);
        }
#endif
    }
    return;
}



//+----------------------------------------------------------------------------
//
//  Function    SetIsdnDualChannelEntries
//
//  Synopsis    As what the func name says.  We prepare the RASENTRY and
//              RASSUBENTRY properly.  We don't actually make RAS calls to
//              save the entries. We'll leave it to the caller(so that the
//              can make other changes to the structs for other reasons and 
//              commit the changes in 1 or 2 RAS calls).
//
//  Arguments   pArgs [IN]          Pointer to ArgsStruct
//              pRasEntry [IN/OUT]  rasentry to be filled
//              ppRasSubEntry [OUT] pointer to be filled with the subentry array
//                                  The buffer is allocated in this function.
//              pdwSubEntryCount    Number of subentries allocated.
//
//  Returns     BOOL                TRUE = success, FALSE = failure.
//
//-----------------------------------------------------------------------------
BOOL SetIsdnDualChannelEntries(ArgsStruct *pArgs, LPRASENTRY pRasEntry,
                                      LPRASSUBENTRY *ppRasSubEntry, PDWORD pdwSubEntryCount)
{
    //
    //  Lets check the input parameters
    //
    MYDBGASSERT(pArgs);
    MYDBGASSERT(pRasEntry);
    MYDBGASSERT(ppRasSubEntry);
    MYDBGASSERT(pdwSubEntryCount);
    if ((NULL == pArgs) || (NULL == pRasEntry) || (NULL == ppRasSubEntry) ||
        (NULL == pdwSubEntryCount))
    {
        return FALSE;
    }
    
    //
    //  Since we don't support BAP if they called this function they must have wanted
    //  to do DualChannel ISDN.  If the dial mode isn't set for dual channel, we will
    //  assert an continue.  Better to connect the user in dual channel mode then not
    //  at all if they have a misconfigured profile.
    //
    MYDBGASSERT(pArgs->dwIsdnDialMode != CM_ISDN_MODE_SINGLECHANNEL);

    //
    //  Check the size of the passed in RasEntry struct.  If it isn't at least
    //  a 4.01 size struct, then return.
    //
    MYDBGASSERT(pRasEntry->dwSize >= sizeof(LPRASENTRY_V401));
    if (sizeof(LPRASENTRY_V401) > pRasEntry->dwSize)
    {
        return FALSE;
    }

    LPRASENTRY_V401 pRasEntry401 = (LPRASENTRY_V401)pRasEntry;

    //
    // set isdn dial mode to dial both channels
    //
    pRasEntry401->dwDialMode = RASEDM_DialAll;
    CMTRACE(TEXT("ISDN Dual Channel Mode On"));

    if (OS_NT)
    {
       *pdwSubEntryCount = 2;
    }
    else if (OS_MIL)
    {
        // 112351: 9x only requires one sub entry.  We'll keep the device name the same.
        // In this case, Win9x will work as follows:
        //  for the 1st channel, the device name provided works fine.
        //  for the 2nd channel, 9x sees the device is in use and looks for the
        //  the closest match (which is the 2nd channel).
        //
    
       *pdwSubEntryCount = 1;
    }
    else
    {
        CMASSERTMSG(FALSE, TEXT("SetIsdnDualChannelEntries -- Function called on a platform other than NT or Millennium."));
        return FALSE;
    }

    //
    //  Allocate the sub entries
    //
    *ppRasSubEntry = (LPRASSUBENTRY)CmMalloc((*pdwSubEntryCount)*(sizeof(RASSUBENTRY)));

    if (NULL == *ppRasSubEntry)
    {
        CMASSERTMSG(FALSE, TEXT("SetIsdnDualChannelEntries -- CmMalloc failed to alloc ppRasSubEntry."));
        return FALSE;
    }

    //
    //  Fill in the sub entries with the device and phonenumber information
    //
    for (DWORD dwIndex=0; dwIndex < (*pdwSubEntryCount); dwIndex++)
    {
        (*ppRasSubEntry)[dwIndex].dwSize = sizeof(RASSUBENTRY);
        lstrcpyU((*ppRasSubEntry)[dwIndex].szDeviceType, pArgs->szDeviceType);
        lstrcpyU((*ppRasSubEntry)[dwIndex].szDeviceName, pArgs->szDeviceName);
        lstrcpyU((*ppRasSubEntry)[dwIndex].szLocalPhoneNumber, pRasEntry401->szLocalPhoneNumber);
    }
    
    return TRUE;
}

//
// Keep in case we ever want to support BAP
//
/*
BOOL SetIsdnDualChannelEntries(
    ArgsStruct              *pArgs,
    LPRASENTRY              pre,
    LPRASSUBENTRY           *prgrse,
    PDWORD                  pdwSubEntryCount
)
{
    LPRASENTRY_V401 pre401;

    MYDBGASSERT(pArgs->dwIsdnDialMode != CM_ISDN_MODE_SINGLECHANNEL);

    MYDBGASSERT(pre->dwSize >= sizeof(LPRASENTRY_V401));
    pre401 = (LPRASENTRY_V401)pre;

    //
    // set isdn dial mode
    //

    if (pArgs->dwIsdnDialMode == CM_ISDN_MODE_DIALALL)
    {
        //
        // dial both channels
        //
        pre401->dwDialMode = RASEDM_DialAll;
        CMTRACE(TEXT("ISDN Dual Channel Mode On"));
    }
    else
    {
        //
        // dial 2nd channel on demand
        //

        //
        // First get the 4 thresholds
        //
        if (!pArgs->dwDialExtraPercent)
        {
            pArgs->dwDialExtraPercent = pArgs->piniService->GPPI(c_pszCmSection, 
                                                                 c_pszCmEntryDialExtraPercent, 
                                                                 DEFAULT_DIALEXTRAPERCENT);
            if (pArgs->dwDialExtraPercent < 0 ||
                pArgs->dwDialExtraPercent > 100)
            {
                pArgs->dwDialExtraPercent = DEFAULT_DIALEXTRAPERCENT;
            }
        }
        
        if (!pArgs->dwDialExtraSampleSeconds)
        {
            pArgs->dwDialExtraSampleSeconds = pArgs->piniService->GPPI(c_pszCmSection, 
                                                                       c_pszCmEntryDialExtraSampleSeconds, 
                                                                       DEFAULT_DIALEXTRASAMPLESECONDS);
            if (pArgs->dwDialExtraSampleSeconds < 0)
            {
                pArgs->dwDialExtraSampleSeconds = DEFAULT_DIALEXTRASAMPLESECONDS;
            }
        }
    
        if (!pArgs->dwHangUpExtraPercent)
        {
            pArgs->dwHangUpExtraPercent = pArgs->piniService->GPPI(c_pszCmSection, 
                                                                   c_pszCmEntryHangUpExtraPercent, 
                                                                   DEFAULT_HANGUPEXTRAPERCENT);
            if (pArgs->dwHangUpExtraPercent < 0 ||
                pArgs->dwHangUpExtraPercent > 100)
            {
                pArgs->dwHangUpExtraPercent = DEFAULT_HANGUPEXTRAPERCENT;
            }
        }
        
        if (!pArgs->dwHangUpExtraSampleSeconds)
        {
            pArgs->dwHangUpExtraSampleSeconds = pArgs->piniService->GPPI(c_pszCmSection, 
                                                                         c_pszCmEntryHangUpExtraSampleSeconds, 
                                                                         DEFAULT_HANGUPEXTRASAMPLESECONDS);
            if (pArgs->dwHangUpExtraSampleSeconds < 0)
            {
                pArgs->dwHangUpExtraSampleSeconds = DEFAULT_HANGUPEXTRASAMPLESECONDS;
            }
        }

        //
        // set multilink info
        //
        pre401->dwDialMode = RASEDM_DialAsNeeded;

        pre401->dwDialExtraPercent          = pArgs->dwDialExtraPercent;
        pre401->dwDialExtraSampleSeconds    = pArgs->dwDialExtraSampleSeconds;
        pre401->dwHangUpExtraPercent        = pArgs->dwHangUpExtraPercent;
        pre401->dwHangUpExtraSampleSeconds  = pArgs->dwHangUpExtraSampleSeconds;

        CMTRACE2(TEXT("ISDN 2nd Channel Dial On Demand: dial extra %u%%, dial extra %u sample secs"),
                 pre401->dwDialExtraPercent, pre401->dwDialExtraSampleSeconds);

        CMTRACE2(TEXT("\t\thangup extra %u%%, hangup extra %u sample secs"),
                 pre401->dwHangUpExtraPercent, pre401->dwHangUpExtraSampleSeconds);
    }


    if (OS_NT)
    {
        if (!(*prgrse = (LPRASSUBENTRY)CmMalloc(2*sizeof(RASSUBENTRY))))
        {
            CMTRACE(TEXT("SetIsdnDualChannelEntries failed to alloc a ras sub entry"));
            return FALSE;
        }
        
        ZeroMemory((PVOID)*prgrse, 2*sizeof(RASSUBENTRY));

        //
        // first channel
        //
        (*prgrse)[0].dwSize = sizeof(RASSUBENTRY);
        lstrcpyU((*prgrse)[0].szDeviceType, pArgs->szDeviceType);
        lstrcpyU((*prgrse)[0].szDeviceName, pArgs->szDeviceName);
        lstrcpyU((*prgrse)[0].szLocalPhoneNumber, pre401->szLocalPhoneNumber);

        //
        // the 2nd channel is identical
        //
        CopyMemory((PVOID)(*prgrse + 1), (PVOID)*prgrse, sizeof(RASSUBENTRY));

        *pdwSubEntryCount = 2;
    }
    else
    {
        MYDBGASSERT(OS_MIL);

        CMTRACE(TEXT("doing the Millennium subentry stuff"));

        // 112351: 9x only requires one sub entry.  We'll keep the device name the same.
        // In this case, Win9x will work as follows:
        //  for the 1st channel, the device name provided works fine.
        //  for the 2nd channel, 9x sees the device is in use and looks for the
        //  the closest match (which is the 2nd channel).
        //

        if (!(*prgrse = (LPRASSUBENTRY)CmMalloc(1*sizeof(RASSUBENTRY))))
        {
            CMTRACE(TEXT("SetIsdnDualChannelEntries failed to alloc a ras sub entry"));
            return FALSE;
        }

        ZeroMemory((PVOID)*prgrse, 1*sizeof(RASSUBENTRY));

        //
        // 2nd channel
        //
        (*prgrse)[0].dwSize = sizeof(RASSUBENTRY);
        lstrcpyU((*prgrse)[0].szDeviceType, pArgs->szDeviceType);
        lstrcpyU((*prgrse)[0].szDeviceName, pArgs->szDeviceName);
        lstrcpyU((*prgrse)[0].szLocalPhoneNumber, pre401->szLocalPhoneNumber);

        *pdwSubEntryCount = 1;
    }
    return TRUE;
}
*/


//+----------------------------------------------------------------------------
//
//      Function        SetNtIdleDisconnectInRasEntry
//
//      Synopsis        As what the func name says.  We prepare the RASENTRY and
//              RASSUBENTRY properly.  We don't actually make RAS calls to
//              save the entries. We'll leave it to the caller(so that the
//              can make other changes to the structs for other reasons and 
//              commit the changes in 1 or 2 RAS calls).
//
//      Arguments       pArgs [IN]              Pointer to ArgsStruct
//              pre   [OUT]         Pointer to RASENTRY with the correct size
//
//      Returns         BOOL                TRUE = success, FALSE = failure.
//
//-----------------------------------------------------------------------------
BOOL SetNtIdleDisconnectInRasEntry(
    ArgsStruct      *pArgs,
    LPRASENTRY      pre
)
{
    if (!OS_NT4)
    {
        return FALSE;
    }
    
    if ((NULL == pArgs) || (NULL == pre) || (pre->dwSize < sizeof(LPRASENTRY_V401)))
    {
        CMASSERTMSG(FALSE, TEXT("SetNtIdleDisconnectInRasEntry -- Invalid parameter"));
        return FALSE;
    }

    //
    // If idle-disconnect is enabled, use the options value otherwise 
    // pArgs->dwIdleTimeout is in minutes.  Note that 0xFFFFFFFF means
    // no idle disconnect to RAS but 0 is the value we use to mean never
    // idle disconnect in the CMS.
    //

    DWORD dwIdle = (pArgs->dwIdleTimeout * 60);

    if (0 == dwIdle)
    {
        dwIdle = (DWORD)-1;
    }

    ((LPRASENTRY_V401 )pre)->dwIdleDisconnectSeconds = dwIdle;

    CMTRACE1(TEXT("SetNtIdleDisconnect: current idle Timeout is %u seconds."), dwIdle);

    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:   DisableSystemIdleDisconnect
//
// Synopsis:   This function sets the idle timeout value of a RAS connection to
//             be disabled.
//
// Arguments:  LPRASENTRY pre - pointer to a RASENTRY to disable idle disconnect for
//
// Returns:    BOOL TRUE = success, FALSE = failure.
//
//-----------------------------------------------------------------------------
BOOL DisableSystemIdleDisconnect(LPRASENTRY pre)
{
    if ((NULL == pre) || (pre->dwSize < sizeof(LPRASENTRY_V401)))
    {
        CMASSERTMSG(FALSE, TEXT("DisableSystemIdleDisconnect -- Invalid parameter"));
        return FALSE;
    }

    //
    // Set the idle time to 0xFFFFFFFF which means no idle disconnect to RAS
    //

    ((LPRASENTRY_V401 )pre)->dwIdleDisconnectSeconds = (DWORD)-1;

    CMTRACE(TEXT("DisableSystemIdleDisconnect -- System Idle disconnect disabled"));

    return TRUE;
}


//+----------------------------------------------------------------------------
//
//      Function        RasDialFunc2
//
//      Synopsis        A RAS callback type 2 for RasDial.
//
//      Arguments       
//      ULONG_PTR dwCallbackId,// user-defined value specified in RasDial 
//      DWORD dwSubEntry,      // subentry index in multilink connection
//      HRASCONN hrasconn,     // handle to RAS connection
//      UINT unMsg,            // type of event that has occurred
//      RASCONNSTATE rascs,    // connection state about to be entered
//      DWORD dwError,         // error that may have occurred
//      DWORD dwExtendedError  // extended error information for some errors
//
//      Returns         LPRASENTRY - pointer to the RASENTRY structure allocated
//
//-----------------------------------------------------------------------------
DWORD WINAPI RasDialFunc2(
    ULONG_PTR dwCallbackId,     // user-defined value specified in RasDial 
    DWORD dwSubEntry,           // subentry index in multilink connection
    HRASCONN hrasconn,          // handle to RAS connection
    UINT unMsg,                 // type of event that has occurred
    RASCONNSTATE rascs,         // connection state about to be entered
    DWORD dwError,              // error that may have occurred
    DWORD dwExtendedError       // extended error information for some errors
)
{   
    CMTRACE2(TEXT("RasDialFunc2():  dwSubentry=%u. dwErr=0x%x"), dwSubEntry, dwError);
    CMTRACE2(TEXT("RasDialFunc2():  dwExtendedErr=0x%x, rascs=%u"), dwExtendedError, rascs);

    MYDBGASSERT(dwCallbackId);

    if (dwCallbackId)
    {
        ArgsStruct *pArgs = (ArgsStruct *) dwCallbackId;        
        pArgs->dwRasSubEntry = dwSubEntry;

        //CMTRACE1(TEXT("RasDialFunc2():  pArgs->lInConnectOrCancel=%d"),pArgs->lInConnectOrCancel);
        //CMASSERTMSG((NOT_IN_CONNECT_OR_CANCEL == pArgs->lInConnectOrCancel),
        //            TEXT("RasDialFunc2 - RasDial mutex is NOT NULL..."));

        SendMessage(pArgs->hwndMainDlg, pArgs->uMsgId, rascs, dwError);
    }

    return 1;
}

//+----------------------------------------------------------------------------
//
// Function:  SetRasDialExtensions
//
// Synopsis:  Encapsulates initialization and configuration of the 
//            RasDialExtensions that we use on NT.
//
// Arguments: pArgs - Ptr to global args struct
//            fEnablePausedStates - Use Paused states or not
//            fEnableCustomScripting - whether to use custom scripting or not
//
// Returns:   DWORD - Error code
//
// History:   nickball      Created    7/22/99
//
//+----------------------------------------------------------------------------
DWORD SetRasDialExtensions(ArgsStruct* pArgs, BOOL fEnablePausedStates, BOOL fEnableCustomScripting)
{
    DWORD dwRes = ERROR_SUCCESS;

    MYDBGASSERT(pArgs);
    
    if (NULL == pArgs)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // If not already allocated, we need a RasDialExtensions struct
    //

    if (!pArgs->pRasDialExtensions)
    {
        pArgs->pRasDialExtensions = AllocateAndInitRasDialExtensions();

        if (!pArgs->pRasDialExtensions)
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    else
    {                    
        dwRes = InitRasDialExtensions(pArgs->pRasDialExtensions);
    }

    if (ERROR_SUCCESS != dwRes)
    {
        goto SetRasDialExtensionsExit;
    }

    //
    // Turn on PauseStates for NT
    //

    if (fEnablePausedStates)
    {
        pArgs->pRasDialExtensions->dwfOptions |= RDEOPT_PausedStates; 
    }

    //
    //  Turn on custom scripting if we are running on Whistler+ and the caller
    //  asked for it.
    //
    if (fEnableCustomScripting && OS_NT51)
    {
        pArgs->pRasDialExtensions->dwfOptions |= RDEOPT_UseCustomScripting;
    }

    //
    // RDEOPT_NoUser is required for the WinLogon credential case, 
    // which we identify by the presence of either lpEapLogonInfo 
    // or lpRasNoUser.  Note that the if statement below is somewhat redundant
    // since we should have CM_LOGON_TYPE_WINLOGON set if we get either a NoUser
    // struct or an EapLogonInfo struct.  However, wanted to point out that on Win2k
    // one of the first two will always be true and on Whistler the first two may be
    // false but the third true (RAS now sends a flag to tell us when we are at WinLogon on 
    // whistler as there are Ctrl-Alt-Del with SmartCard cases where it sends neither struct).
    //

    if (pArgs->lpEapLogonInfo || pArgs->lpRasNoUser || (CM_LOGON_TYPE_WINLOGON == pArgs->dwWinLogonType))
    {
        pArgs->pRasDialExtensions->dwfOptions |= RDEOPT_NoUser;
    }

    //
    // If the modem speaker is turned off, makes sure that we
    // disable it explicitly in RAS, otherwise it will use 
    // its default and turn the speaker on. These settings 
    // should be ignored by RAS in the tunnel case.
    //

    if (pArgs->tlsTapiLink.bModemSpeakerOff)
    {
        pArgs->pRasDialExtensions->dwfOptions |= RDEOPT_IgnoreModemSpeaker;
        pArgs->pRasDialExtensions->dwfOptions &= ~RDEOPT_SetModemSpeaker;
    }

SetRasDialExtensionsExit:

    return dwRes;
}

//+----------------------------------------------------------------------------
//
// Function:  InitRasDialExtensions
//
// Synopsis:  Flushes a previously allocated RasDialExtensions buffer and sets
//            size, options for re-use.
//
// Arguments: LPRASDIALEXTENSIONS - Ptr to allocated struct with size set.
//
// Returns:   DWORD - Error code
//
// History:   nickball      Created    5/22/99
//
//+----------------------------------------------------------------------------
DWORD InitRasDialExtensions(LPRASDIALEXTENSIONS lpRasDialExtensions)
{   
    MYDBGASSERT(lpRasDialExtensions);

    if (NULL == lpRasDialExtensions)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // First, we determine the size
    //

    DWORD dwSize = OS_NT5 ? sizeof(RASDIALEXTENSIONS_V500) : sizeof(RASDIALEXTENSIONS);

    //
    // Flush buffer and reset size.
    //

    ZeroMemory(lpRasDialExtensions, dwSize);

    lpRasDialExtensions->dwSize = dwSize;

    //
    // Set customdial if needed
    //

    if (dwSize == sizeof(RASDIALEXTENSIONS_V500))
    {  
        // 
        // Set the CustomDial flag for NT5. We don't set this on NT4 
        // and 9X as a precaution because the falg isn't defined.
        //

        lpRasDialExtensions->dwfOptions |= RDEOPT_CustomDial;
    }

    CMTRACE1(TEXT("InitRasDialExtensions() - dwSize is %u"), dwSize);

    return ERROR_SUCCESS;
}

//+----------------------------------------------------------------------------
//
// Function:  AllocateAndInitRasDialExtensions
//
// Synopsis:  Encapsulates the allocation of a RASEXTENSION based upon the OS
//
// Arguments: None
//
// Returns:   LPRASDIALEXTENSIONS - Ptr to allocated struct with size set.
//
// History:   nickball      Created    5/13/99
//
//+----------------------------------------------------------------------------
LPRASDIALEXTENSIONS AllocateAndInitRasDialExtensions()
{
    //
    // Allocate struct and pre-fill as appropriate
    //

    LPRASDIALEXTENSIONS prdeNew = (LPRASDIALEXTENSIONS)CmMalloc(OS_NT5 ? 
        sizeof(RASDIALEXTENSIONS_V500) : sizeof(RASDIALEXTENSIONS));

    if (!prdeNew)
    {
        CMTRACE(TEXT("AllocateAndInitRasDialExtensions: failed to alloc RasDialExtension buffer"));
        return NULL;
    }
    
    InitRasDialExtensions(prdeNew);

    return prdeNew;
}

//+----------------------------------------------------------------------------
//
// Function:  InitRasDialParams
//
// Synopsis:  Flushes a previously allocated RasDialParams buffer and sets
//            size, options for re-use.
//
// Arguments: LPRASDIALPARAMS - Ptr to allocated struct with size set.
//
// Returns:   DWORD - Error code
//
// History:   nickball      Created    5/22/99
//
//+----------------------------------------------------------------------------
DWORD InitRasDialParams(LPRASDIALPARAMS lpRasDialParams)
{   
    MYDBGASSERT(lpRasDialParams);

    if (NULL == lpRasDialParams)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // First, we determine the size
    //

    DWORD dwSize = OS_NT ? sizeof(RASDIALPARAMS_V401) : sizeof(RASDIALPARAMS);

    //
    // Flush buffer and reset size.
    //

    ZeroMemory(lpRasDialParams, dwSize);

    lpRasDialParams->dwSize = dwSize;

    CMTRACE1(TEXT("InitRasDialParams() - dwSize is %u"), dwSize);

    return ERROR_SUCCESS;
}

//+----------------------------------------------------------------------------
//
// Function:  AllocateAndInitRasDialParams
//
// Synopsis:  Encapsulates the allocation of a RASDIALPARAMS based upon the OS
//
// Arguments: None
//
// Returns:   LPRASDIALPARAMS - Ptr to allocated struct with size set.
//
// History:   nickball      Created    5/22/99
//
//+----------------------------------------------------------------------------
LPRASDIALPARAMS AllocateAndInitRasDialParams()
{
    //
    // Allocate struct and pre-fill as appropriate
    //

    LPRASDIALPARAMS prdpNew = (LPRASDIALPARAMS)CmMalloc(OS_NT ? 
        sizeof(RASDIALPARAMS_V401) : sizeof(RASDIALPARAMS));

    if (!prdpNew)
    {
        CMTRACE(TEXT("AllocateRasDialParams: failed to alloc RasDialParams buffer"));
        return NULL;
    }
    
    InitRasDialParams(prdpNew);

    return prdpNew;
}

//+----------------------------------------------------------------------------
//
// Function:  AllocateRasEntry
//
// Synopsis:  Encapsulates the allocation of a RASENTRY struct based upon the OS
//
// Arguments: None
//
// Returns:   LPRASENTRY - Ptr to allocated struct with size set.
//
// History:   nickball  Created Header    5/13/99
//
//+----------------------------------------------------------------------------
LPRASENTRY AllocateRasEntry()
{
    static DWORD    s_dwRasEntrySize = -1;

    //
    // first, we determine the size
    //
    if (s_dwRasEntrySize == -1)
    {                
        if (OS_NT51)
        {
            //
            // Whistler
            //
            s_dwRasEntrySize = sizeof(RASENTRY_V501);
        }
        else if (OS_W2K)
        {
            //
            // nt5
            //
            s_dwRasEntrySize = sizeof(RASENTRY_V500);        
        }
        else if (OS_MIL || OS_NT4)
        {
            //
            // Millennium uses the NT4 structure
            //
            s_dwRasEntrySize = sizeof(RASENTRY_V401);
        }
        else
        {
            //
            // win9x
            //
            s_dwRasEntrySize = sizeof(RASENTRY);
        }
    }

    //
    // add 512 bytes since a rasentry can contain alternate phone #'s
    // See RASENTRY.dwAlternateOffset 
    //
    LPRASENTRY preNew = (LPRASENTRY)CmMalloc(s_dwRasEntrySize+512);

    if (!preNew)
    {
        CMTRACE(TEXT("AllocateRasEntry: failed to alloc rasentry buffer"));
        return NULL;
    }
    
    preNew->dwSize = s_dwRasEntrySize;
    if (s_dwRasEntrySize >= sizeof(RASENTRY_V500))
    {
        ((LPRASENTRY_V500)preNew)->dwType = RASET_Internet;
   
        //
        // For NT5, set szCustomDialDll with our Module name. This ensures that our
        // custom DialDlg, DialEntry, and Hangup routines will be called by RAS for
        // operations on our connectoid. We don't want to tie our path to anything 
        // machine specific, so we'll use the %windir% environment string. 
        // 

        lstrcpyU(((LPRASENTRY_V500)preNew)->szCustomDialDll, c_pszCmDialPath);
    }

    CMTRACE1(TEXT("AllocateRasEntry() - s_dwRasEntrySize is %u"), s_dwRasEntrySize);

    return preNew;
}

#if 0
/*

//+----------------------------------------------------------------------------
//
// Function:  GetRasSystemPhoneBookPath
//
// Synopsis:  Builds the conventional path to the RAS system phonebook
//
// Arguments: None
//
// Returns:   LPTSTR - The phonebook path 
//
// History:   nickball    Created    8/14/98
//
//+----------------------------------------------------------------------------
LPTSTR GetRasSystemPhoneBookPath()
{
    MYDBGASSERT(OS_NT);
    
    TCHAR szTemp[MAX_PATH+1];

    GetSystemDirectoryU(szTemp,sizeof(szTemp));
    lstrcatU(szTemp, c_pszRasDirRas);
    lstrcatU(szTemp, c_pszRasPhonePbk);
    
    return CmStrCpyAlloc(szTemp);
}

//+---------------------------------------------------------------------------
//
//      Function:       InitDefaultRasPhoneBook
//
//      Synopsis:       Special case Helper function ensures that there is a default 
//                              ras phonebook when running on NT. We simply attempt to create 
//                              the file which fails if the file already exists, or creates 
//                              an empty file if it does not.
//
//      Arguments:      None
//
//      Returns:        Nothing
//
//      History:        a-nichb -       4/30/97         Created
//                      VetriV          5/21/97         Changed code to call GetOSVersion()
//                                                      instead of using pArgs->dwPlatformID
//                                                      for bug #4700    
//                      nickball        ??/??/98        Removed as we no longer call RasValidateEntry
//                                                      which introduced the requirement of having at
//                                                      least an empty phonebook for the API to work.
//
//----------------------------------------------------------------------------
void InitDefaultRasPhoneBook()
{               
    //
    // NT only. Create empty system phonebook if none exists
    //

    if (OS_NT) 
    {       
        LPTSTR pszSystemPbk = GetRasSystemPhoneBookPath();

        if (pszSystemPbk)
        {
            //
            // Try to create the phonebook, fails if file already exists
            //
            
            HANDLE hInf = CreateFileU(pszSystemPbk,
                                      GENERIC_WRITE|GENERIC_READ,
                                      0,
                                      NULL,
                                      CREATE_NEW,
                                      FILE_ATTRIBUTE_NORMAL,
                                      NULL);

            if (hInf != INVALID_HANDLE_VALUE)
            {
                CloseHandle(hInf);
            }
        }
        CmFree(pszSystemPbk);
    }
}
*/
#endif

//+----------------------------------------------------------------------------
//
// Function:  GetRasPbkFromNT5ProfilePath
//
// Synopsis:  Helper function to manufacture a RAS phonebook path from
//            a .CMP file path on NT5
//
// Arguments: LPCTSTR pszProfile - The full path to a profile .CMP file.
//
// Returns:   LPTSTR - The new phonebook path. NULL on failure
//
// History:   nickball    Created    8/13/98
//
//+----------------------------------------------------------------------------
LPTSTR GetRasPbkFromNT5ProfilePath(LPCTSTR pszProfile)
{
    MYDBGASSERT(OS_NT5);
    MYDBGASSERT(pszProfile);

    if (NULL == pszProfile)
    {
        return NULL;
    }

    //
    // We will deduce the phonebook path from our current profile location.
    //

    LPTSTR pszRasPhonePath = (LPTSTR) CmMalloc(MAX_PATH + 1);    
    MYDBGASSERT(pszRasPhonePath);

    if (pszRasPhonePath)
    {
        //
        // Strip .CMP file name and parent directory
        //
        
        LPTSTR pszDir = CmStripFileName(pszProfile, FALSE);
        MYDBGASSERT(pszDir);
        
        if (pszDir)
        {
            LPTSTR pszTmp = CmStrrchr(pszDir, TEXT('\\'));                   
            MYDBGASSERT(pszTmp);

            if (pszTmp)
            {

                *pszTmp = 0;
                
                //
                // Append \\pbk\\rasphone.pbk
                //
                
                lstrcpyU(pszRasPhonePath, pszDir);
                lstrcatU(pszRasPhonePath, TEXT("\\"));
                lstrcatU(pszRasPhonePath, c_pszPbk);
                lstrcatU(pszRasPhonePath, c_pszRasPhonePbk);               
            }
            
            CmFree(pszDir);
        }           
        else
        {
            CmFree(pszRasPhonePath);
        }
    }                            

    return pszRasPhonePath;
}

#define MAX_BLOB_CHARS_PER_LINE 128

//+----------------------------------------------------------------------------
//
// Function:  ReadDunSettingsEapData
//
// Synopsis:  Retrieves DUN setting for EAP config (opaque blob) data. The 
//            entry may span several lines and contain several EAP data blocks.
//
// Arguments: CIni *pIni - Ptr to ini object to be used.
//            LPBYTE* ppbEapData - Address of pointer to store EapData, allocated here.
//            LPDWORD pdwEapSize - Ptr to a DWORD to record the size of the data blob.
//            DWORD dwCustomAuthKey - The EAP type that we are interested in.
//
// Returns:   TRUE on success
//
// Note:      CM expects blob data to be provided in numbered entries such as:
//                    CustomAuthData0=, CustomAuthData1=, CustomAuthData2=, etc.
//
// History:   nickball    Created                                       08/24/98
//            nickball    Handle multiple EAP data blocks in blob.      09/11/99
//
//+----------------------------------------------------------------------------
BOOL ReadDunSettingsEapData(CIni *pIni, 
        LPBYTE* ppbEapData,
        LPDWORD pdwEapSize,
        const DWORD dwCustomAuthKey)
{
    CHAR *pchBuf = NULL;
    CHAR szTmp[MAX_BLOB_CHARS_PER_LINE + 2]; 
    CHAR szEntry[128];
    int nLine = -1;
    int nRead = -1; 
    int nTotal = 0;

    LPBYTE pbEapBytes = NULL;

    MYDBGASSERT(pIni);
    MYDBGASSERT(ppbEapData);
    MYDBGASSERT(pdwEapSize);

    if (NULL == pIni || NULL == ppbEapData || NULL == pdwEapSize) 
    {
        return FALSE;
    }

    //
    // First get the section (it should include &) then the entry.
    //

    BOOL bRet = FALSE;
    LPWSTR pszLoadSection = pIni->LoadSection(c_pszCmSectionDunServer);         
    LPSTR pszSection = WzToSzWithAlloc(pszLoadSection);       
    LPSTR pszFile = WzToSzWithAlloc(pIni->GetFile());

    if (!pszLoadSection || !pszSection || !pszFile)
    {
        bRet = FALSE;
        goto exit;
    }

    // 
    // Read numbered entries until there are no more. 
    // Note: RAS blob doesn't exceed 64 chars, but can wrap over multiple lines
    //

    while (nRead)
    {
        //
        // Read CustomAuthDataX where X is the number of entries
        // 

        nLine++;
        wsprintfA(szEntry, "%s%d", c_pszCmEntryDunServerCustomAuthData, nLine);

        nRead = GetPrivateProfileStringA(pszSection, szEntry, "", szTmp, sizeof(szTmp), pszFile);

        if (nRead)
        {               
            //
            // If line exceeded 64 chars, it is considered corrupt
            // 

            if (MAX_BLOB_CHARS_PER_LINE < nRead)
            {                               
                nTotal = 0;
                break;
            }

            //
            // Update our local master buffer with the latest fragment
            //

            if (nLine)
            {
                pchBuf = CmStrCatAllocA(&pchBuf, szTmp);
            }
            else
            {
                pchBuf = CmStrCpyAllocA(szTmp);
            }

            if (!pchBuf)
            {
                bRet = FALSE;
                goto exit;
            }

            nTotal += nRead;
        }
    }

    //
    // At this point we should have the entire entry in pchBuf in HEX format
    // Convert the buffer to byte format and store in supplied EAP buffer.
    //

    if (nTotal && !(nTotal & 1))
    {
        nTotal /= 2; // Only need half the hex char size

        pbEapBytes = (BYTE *) CmMalloc(nTotal + 1);

        if (!pbEapBytes)
        {
            goto exit;
        }

        CHAR *pch = pchBuf;
        BYTE *pb = pbEapBytes;

        while (*pch != '\0')
        {
                *pb = HexValue( *pch++ ) * 16;
                *pb += HexValue( *pch++ );
                ++pb;
        }

        //
        // Now we have the bytes, locate and extract the data block that we
        // are after. Note: Multiple blocks are arrayed using the following 
        // header:
        //
        //  typedef struct _EAP_CUSTOM_DATA
        //  {
        //      DWORD dwSignature;
        //      DWORD dwCustomAuthKey;
        //      DWORD dwSize;
        //      BYTE  abdata[1];
        //  } EAP_CUSTOM_DATA;
        //

        EAP_CUSTOM_DATA *pCustomData = (EAP_CUSTOM_DATA *) pbEapBytes;

        while (((LPBYTE) pCustomData - pbEapBytes) < nTotal)
        {
            if (pCustomData->dwCustomAuthKey == dwCustomAuthKey)
            {
                //
                // Bingo! We have a match, first make sure that the indicated 
                // size isn't pointing out into space, then make a copy and 
                // run for the hills.
                //

                if (((LPBYTE) pCustomData - pbEapBytes) + sizeof(EAP_CUSTOM_DATA) + pCustomData->dwSize > (DWORD) nTotal)
                {
                    MYDBGASSERT(FALSE);
                    goto exit;
                }

                *ppbEapData = (BYTE *) CmMalloc(pCustomData->dwSize);        

                if (*ppbEapData)
                {   
                    CopyMemory(*ppbEapData, pCustomData->abdata, pCustomData->dwSize);                    

                    *pdwEapSize = pCustomData->dwSize;                                                     
                    bRet = TRUE;
                    goto exit;                                
                }
            }       

            //
            // Locate the next data block
            //

            pCustomData = (EAP_CUSTOM_DATA *) ((LPBYTE) pCustomData + sizeof(EAP_CUSTOM_DATA) + pCustomData->dwSize); 
        }
    }

exit:

    CmFree(pchBuf);
    CmFree(pszLoadSection);
    CmFree(pszSection);
    CmFree(pszFile);
    CmFree(pbEapBytes);

    return bRet;
}

//+----------------------------------------------------------------------------
//
// Function:  ReadDUNSettings
//
// Synopsis:  Reads the DUN settings for the specified DUN name and .CMS file 
//            into a RASENTRY structure. Because some settings are not supported 
//                        on downlevel platforms, this function will potentially display an
//                        error message to the user.
//
// Arguments: ArgsStruct *pArgs  - Ptr to global args struct.
//            LPCSTR pszFile     - Full path to the .CMS file.
//            LPCTSTR pszDunName - The DUN name for the settings.
//            LPVOID pvBuffer    - Ptr to RASENTRY buffer.
//            LPBYTE* ppbEapData - Address of pointer to store EapData
//            LPDWORD pdwEapSize - Ptr to a DWORD to record the size of the data blob.
//            BOOL  fTunnel      - are we reading tunnel settings?
//
// Returns:   ERROR_SUCCESS on success. Use GetLastError for failure details.
//
// Note:      This was formerly the PhoneBookReadDun API in CMPBK.DLL
//
// History:   nickball    8/22/98   Created Header    
//            nickball    02/03/99  Added pArgs :( in order to have access to the 
//                                  the top-level service for path conversion.
//
//+----------------------------------------------------------------------------
LRESULT ReadDUNSettings(ArgsStruct *pArgs,
        LPCTSTR pszFile, 
        LPCTSTR pszDunName, 
        LPVOID pvBuffer, 
        LPBYTE* ppbEapData, 
        LPDWORD pdwEapSize,
        BOOL    fTunnel) 
{       
    MYDBGASSERT(pszFile);
    MYDBGASSERT(pszDunName);
    MYDBGASSERT(pvBuffer);

    if (NULL == pszFile || NULL == pszDunName || NULL == pvBuffer)
    {
        return (ERROR_INVALID_PARAMETER);
    }

    CMTRACE1(TEXT("ReadDUNSettings -- using DUN setting: %s"), pszDunName);
    
    RASENTRYW *preRas = (RASENTRYW *) pvBuffer;

    //
    // Setup INI object. Prepend pszDunName with "&" for section.
    //

    CIni iniFile(g_hInst, pszFile);
    
    LPTSTR pszSection = CmStrCpyAlloc(TEXT("&"));
    pszSection = CmStrCatAlloc(&pszSection, pszDunName);
    iniFile.SetSection(pszSection);
    CmFree(pszSection);

    //
    // Get and apply the Phone section entries
    //

    if (iniFile.GPPB(c_pszCmSectionDunPhone, c_pszCmEntryDunPhoneDialAsIs)) 
    {
        preRas->dwfOptions &= ~RASEO_UseCountryAndAreaCodes;;
    }
    
    CopyGPPS(&iniFile, c_pszCmSectionDunPhone, c_pszCmEntryDunPhonePhoneNumber, preRas->szLocalPhoneNumber, sizeof(preRas->szLocalPhoneNumber)/sizeof(TCHAR));
    CopyGPPS(&iniFile,c_pszCmSectionDunPhone, c_pszCmEntryDunPhoneAreaCode, preRas->szAreaCode, sizeof(preRas->szAreaCode)/sizeof(TCHAR));
    preRas->dwCountryCode = iniFile.GPPI(c_pszCmSectionDunPhone, c_pszCmEntryDunPhoneCountryCode, preRas->dwCountryCode);
    preRas->dwCountryID = iniFile.GPPI(c_pszCmSectionDunPhone, c_pszCmEntryDunPhoneCountryId, preRas->dwCountryID);
    
    //
    // Get and apply the Device section entries
    //

    CopyGPPS(&iniFile,c_pszCmSectionDunDevice, c_pszCmEntryDunDeviceType, preRas->szDeviceType, sizeof(preRas->szDeviceType)/sizeof(TCHAR));
    CopyGPPS(&iniFile,c_pszCmSectionDunDevice, c_pszCmEntryDunDeviceName, preRas->szDeviceName, sizeof(preRas->szDeviceName)/sizeof(TCHAR));
    
    //
    // Get and apply the Server section entries
    //

    LPTSTR pszTmp = iniFile.GPPS(c_pszCmSectionDunServer, c_pszCmEntryDunServerType);
    if (*pszTmp) 
    {
        if (0 == lstrcmpiU(pszTmp, c_pszDunPpp)) 
        {
            preRas->dwFramingProtocol = RASFP_Ppp;
        } 
        else if (0 == lstrcmpiU(pszTmp, c_pszDunCslip)) 
        {
            preRas->dwFramingProtocol = RASFP_Slip;
            preRas->dwfOptions |= RASEO_IpHeaderCompression;
        } 
        else if (0 == lstrcmpiU(pszTmp, c_pszDunSlip)) 
        {
            preRas->dwFramingProtocol = RASFP_Slip;
            if (iniFile.GPPB(c_pszCmSectionDunServer, c_pszCmEntryDunTcpIpIpHeaderCompress,
                             (BOOL) preRas->dwfOptions & RASEO_IpHeaderCompression)) 
            {
                preRas->dwfOptions |= RASEO_IpHeaderCompression;
            } 
            else 
            {
                preRas->dwfOptions &= ~RASEO_IpHeaderCompression;
            }
        }
    }
    CmFree(pszTmp);
    
    if (iniFile.GPPB(c_pszCmSectionDunServer, c_pszCmEntryDunServerSwCompress,
                                    (BOOL) preRas->dwfOptions & RASEO_SwCompression)) 
    {
        preRas->dwfOptions |= RASEO_SwCompression;
    } 
    else 
    {
        preRas->dwfOptions &= ~RASEO_SwCompression;
    }

    if (iniFile.GPPB(c_pszCmSectionDunServer, c_pszCmEntryDunServerDisableLcp,
                                    (BOOL) preRas->dwfOptions & RASEO_DisableLcpExtensions)) 
    {
        preRas->dwfOptions |= RASEO_DisableLcpExtensions;
    } 
    else 
    {
        preRas->dwfOptions &= ~RASEO_DisableLcpExtensions;
    }
    
    if (iniFile.GPPB(c_pszCmSectionDunServer, c_pszCmEntryDunServerNetworkLogon,
                                    (BOOL) preRas->dwfOptions & RASEO_NetworkLogon)) 
    {
        preRas->dwfOptions |= RASEO_NetworkLogon;
    } 
    else 
    {
        preRas->dwfOptions &= ~RASEO_NetworkLogon;
    }
        
    if (iniFile.GPPB(c_pszCmSectionDunServer, c_pszCmEntryDunServerNegotiateTcpIp,
                                    (BOOL) preRas->dwfNetProtocols & RASNP_Ip)) 
    {
        preRas->dwfNetProtocols |= RASNP_Ip;
    } 
    else 
    {
        preRas->dwfNetProtocols &= ~RASNP_Ip;
    }

    if (iniFile.GPPB(c_pszCmSectionDunServer, c_pszCmEntryDunServerNegotiateIpx,
                                    (BOOL) preRas->dwfNetProtocols & RASNP_Ipx)) 
    {
        preRas->dwfNetProtocols |= RASNP_Ipx;
    } 
    else 
    {
        preRas->dwfNetProtocols &= ~RASNP_Ipx;
    }

    if (iniFile.GPPB(c_pszCmSectionDunServer, c_pszCmEntryDunServerNegotiateNetBeui, preRas->dwfNetProtocols&RASNP_NetBEUI)) 
    {
        preRas->dwfNetProtocols |= RASNP_NetBEUI;
    } 
    else 
    {
        preRas->dwfNetProtocols &= ~RASNP_NetBEUI;
    }

    //
    // Get the NT5 specific DUN settings. We will error out if we're running 
    // downlevel when these settings are configured and the EnforceCustomSecurity
    // flag has been set.
    //
    // Note: c_pszCmEntryDunServerEnforceCustomSecurity is a DUN setting and is FALSE by default
    //

    BOOL bEnforceCustomSecurity = iniFile.GPPI(c_pszCmSectionDunServer, c_pszCmEntryDunServerEnforceCustomSecurity, FALSE);

    //
    // Is EAP required
    //

    if (iniFile.GPPB(c_pszCmSectionDunServer, c_pszCmEntryDunServerRequireEap,
                                    (BOOL) preRas->dwfOptions & RASEO_RequireEAP)) 
    {
        if (!(OS_NT5) && bEnforceCustomSecurity)
        {               
            return (ERROR_INVALID_DATA);
        }

        preRas->dwfOptions |= RASEO_RequireEAP;
    } 
    else 
    {
        preRas->dwfOptions &= ~RASEO_RequireEAP;
    }

    //
    // PAP required
    //

    if (iniFile.GPPB(c_pszCmSectionDunServer, c_pszCmEntryDunServerRequirePap,
                                    (BOOL) preRas->dwfOptions & RASEO_RequirePAP)) 
    {
        if (!(OS_NT5) && bEnforceCustomSecurity)
        {               
            return (ERROR_INVALID_DATA);
        }

        preRas->dwfOptions |= RASEO_RequirePAP;
    } 
    else 
    {
        preRas->dwfOptions &= ~RASEO_RequirePAP;
    }

    //
    // SPAP required
    //

    if (iniFile.GPPB(c_pszCmSectionDunServer, c_pszCmEntryDunServerRequireSpap,
                                    (BOOL) preRas->dwfOptions & RASEO_RequireSPAP)) 
    {
        if (!(OS_NT5) && bEnforceCustomSecurity)
        {               
            return (ERROR_INVALID_DATA);
        }

        preRas->dwfOptions |= RASEO_RequireSPAP;
    } 
    else 
    {
        preRas->dwfOptions &= ~RASEO_RequireSPAP;
    }

    //
    // CHAP required
    //

    if (iniFile.GPPB(c_pszCmSectionDunServer, c_pszCmEntryDunServerRequireChap,
                                    (BOOL) preRas->dwfOptions & RASEO_RequireCHAP)) 
    {
        if (!(OS_NT5) && bEnforceCustomSecurity)
        {               
            return (ERROR_INVALID_DATA);
        }

        preRas->dwfOptions |= RASEO_RequireCHAP;
    } 
    else 
    {
        preRas->dwfOptions &= ~RASEO_RequireCHAP;
    }

    //
    // MSCHAP required
    //

    if (iniFile.GPPB(c_pszCmSectionDunServer, c_pszCmEntryDunServerRequireMsChap,
                                    (BOOL) preRas->dwfOptions & RASEO_RequireMsCHAP)) 
    {
        if (!(OS_NT5) && bEnforceCustomSecurity)
        {               
            return (ERROR_INVALID_DATA);
        }

        preRas->dwfOptions |= RASEO_RequireMsCHAP;
    } 
    else 
    {
        preRas->dwfOptions &= ~RASEO_RequireMsCHAP;
    }

    //
    // MSCHAP2 required
    //

    if (iniFile.GPPB(c_pszCmSectionDunServer, c_pszCmEntryDunServerRequireMsChap2,
                                    (BOOL) preRas->dwfOptions & RASEO_RequireMsCHAP2)) 
    {
        if (!(OS_NT5) && bEnforceCustomSecurity)
        {               
            return (ERROR_INVALID_DATA);
        }

        preRas->dwfOptions |= RASEO_RequireMsCHAP2;
    } 
    else 
    {
        preRas->dwfOptions &= ~RASEO_RequireMsCHAP2;
    }

    //
    // W95 MSCHAP required
    //

    if (iniFile.GPPB(c_pszCmSectionDunServer, c_pszCmEntryDunServerRequireW95MsChap,
                                    (BOOL) preRas->dwfOptions & RASEO_RequireW95MSCHAP)) 
    {
        if (!(OS_NT5) && bEnforceCustomSecurity)
        {               
            return (ERROR_INVALID_DATA);
        }

        preRas->dwfOptions |= RASEO_RequireW95MSCHAP;
    } 
    else 
    {
        preRas->dwfOptions &= ~RASEO_RequireW95MSCHAP;
    }

    //
    // Custom Security configuration
    //

    if (iniFile.GPPB(c_pszCmSectionDunServer, c_pszCmEntryDunServerCustomSecurity,
                                    (BOOL) preRas->dwfOptions & RASEO_Custom)) 
    {
        if (!(OS_NT5) && bEnforceCustomSecurity)
        {               
            return (ERROR_INVALID_DATA);
        }

        preRas->dwfOptions |= RASEO_Custom;
    } 
    else 
    {
        preRas->dwfOptions &= ~RASEO_Custom;
    }

    //
    // Now get the legacy security settings if we don't already have
    // settings specificed from above.  By checking for the Win2k specific
    // settings first we allow Admins to specify both so that legacy platforms
    // can have settings but Win2k can use the more granular settings.
    // If we didn't do this the legacy flags could water down the security on Win2k ...
    //
    const DWORD dwWin2kSecuritySettings = RASEO_RequireEAP | RASEO_RequirePAP | RASEO_RequireSPAP | 
                                          RASEO_RequireCHAP | RASEO_RequireMsCHAP | RASEO_RequireMsCHAP2 | RASEO_RequireW95MSCHAP;

    if (0 == (preRas->dwfOptions & dwWin2kSecuritySettings) || !OS_NT5)
    {
        //
        // Security settings
        //
        if (iniFile.GPPB(c_pszCmSectionDunServer, c_pszCmEntryDunServerPwEncrypt,
                                            (BOOL) preRas->dwfOptions & RASEO_RequireEncryptedPw)) 
        {
            preRas->dwfOptions |= RASEO_RequireEncryptedPw;
        } 
        else 
        {
            preRas->dwfOptions &= ~RASEO_RequireEncryptedPw;
        }

        //
        // MS-CHAP
        //

        if (iniFile.GPPB(c_pszCmSectionDunServer, c_pszCmEntryDunServerPwEncryptMs,
                                        (BOOL) preRas->dwfOptions & RASEO_RequireMsEncryptedPw)) 
        {
            preRas->dwfOptions |= RASEO_RequireMsEncryptedPw;
        } 
        else 
        {
            preRas->dwfOptions &= ~RASEO_RequireMsEncryptedPw;
        }
    }
    else
    {
        CMASSERTMSG((preRas->dwfOptions & RASEO_Custom), TEXT("ReadDUNSettings -- Win2k+ security setting configured but RASEO_Custom not specified."));
    }

    //
    // Encrypt Data (legacy setting, same as ET_Require from above)
    //

    if (iniFile.GPPB(c_pszCmSectionDunServer, c_pszCmEntryDunServerDataEncrypt,
                                    (BOOL) preRas->dwfOptions & RASEO_RequireDataEncryption)) 
    {
        preRas->dwfOptions |= RASEO_RequireDataEncryption;
    } 
    else 
    {
        preRas->dwfOptions &= ~RASEO_RequireDataEncryption;
    }    

    //
    // Encryption type, just a straight int read. (win2k+ setting)
    //
    
    int nTmp = iniFile.GPPI(c_pszCmSectionDunServer, c_pszCmEntryDunServerEncryptionType, -1);

    if (OS_NT5)
    {
        //
        // We need to set Tunnel encryption type to ET_Require because that's what the ConnFolder does.
        // We also set it ET_Require if the user specified RASEO_RequireDataEncryption as a legacy setting
        // but didn't specify a specific win2k setting.
        //
        if (-1 == nTmp)
        {
            if (fTunnel || (preRas->dwfOptions & RASEO_RequireDataEncryption))
            {
                nTmp = ET_Require;
            }
            else
            {
                nTmp = ET_Optional;       
            }
        }
        ((LPRASENTRY_V500)preRas)->dwEncryptionType = (DWORD) nTmp;
    }
    else
    {
        if (-1 != nTmp && bEnforceCustomSecurity)
        {
            return (ERROR_INVALID_DATA);
        }
    }  
   
    //
    // Get the EAP type ID (CustomAuthKey) - The data is stored in the RAS 
    // pbk via a specific API, just before dialing - SetCustomAuthData().
    //

    nTmp = iniFile.GPPI(c_pszCmSectionDunServer, c_pszCmEntryDunServerCustomAuthKey, -1);

    //
    // If a type ID for EAP is specified, see if there is any config data
    //

    if (-1 != nTmp) 
    {                       
        if (!(OS_NT5) && bEnforceCustomSecurity)
        {
            return (ERROR_INVALID_DATA);
        }

        //
        // We have an ID and its NT5, read the EAP config data
        //

        ((LPRASENTRY_V500)preRas)->dwCustomAuthKey = nTmp;              

        ReadDunSettingsEapData(&iniFile, ppbEapData, pdwEapSize, nTmp);         
    }

    //
    // Get and apply the Networking section entries. 
    //

    nTmp = iniFile.GPPI(c_pszCmSectionDunNetworking, c_pszCmEntryDunNetworkingVpnStrategy, -1);

    if (-1 != nTmp)
    {
        if (!(OS_NT5) && bEnforceCustomSecurity)
        {
            return (ERROR_INVALID_DATA);
        }

        ((LPRASENTRY_V500)preRas)->dwVpnStrategy = nTmp;
    }

    //
    //  See if the profile calls for using a Pre-Shared Key for L2TP.  Note that we currently don't
    //  provide a mechanism to set the Pre-Shared Key through RasSetCredentials but that could easily
    //  be done through a custom action or a post install action.
    //
    if (OS_NT51)
    {
        if (iniFile.GPPB(c_pszCmSectionDunNetworking, c_pszCmEntryDunNetworkingUsePreSharedKey,
                         (BOOL) ((LPRASENTRY_V501)preRas)->dwfOptions2 & RASEO2_UsePreSharedKey)) 
        {
            ((LPRASENTRY_V501)preRas)->dwfOptions2 |= RASEO2_UsePreSharedKey;
        } 
        else 
        {
            ((LPRASENTRY_V501)preRas)->dwfOptions2 &= ~RASEO2_UsePreSharedKey;
        }
    }

    //
    // File and Print sharing.  Note that on systems up to Win2k we only have the traditional RASEO_SecureLocalFiles.
    // However, Win2k gave this flag two purposes (enable/disable NetBt and enable/disable file and print sharing).
    // In Whistler two separate flags were developed to allow greater granularity.  To give legacy profiles the behavior
    // they expect while disabling file and print sharing as the default the logic gets a little complicated.  Basically
    // the new flag overrides the legacy flag and defaults to 1.  If the new flag isn't specified then we use the value
    // of the legacy flag if it is specified.  If neither is specified we set it to 1.  On platforms previous to Whistler
    // the old flag is the only thing we have and it defaults to 0.
    //

    int nLegacySecureLocalFiles = iniFile.GPPI(c_pszCmSectionDunServer, c_pszCmEntryDunServerSecureLocalFiles, -1);
    int nSecureFileAndPrint = iniFile.GPPI(c_pszCmSectionDunServer, c_pszCmEntryDunNetworkingSecureFileAndPrint, -1);

    if (-1 == nSecureFileAndPrint)
    {
        nSecureFileAndPrint = nLegacySecureLocalFiles ? 1 : 0;
    }

    if (-1 == nLegacySecureLocalFiles)
    {
        nLegacySecureLocalFiles = 0;
    }

    if (OS_NT51)
    {
        //
        // Set the 501/Options2 style File and Print sharing flag
        //

        if (nSecureFileAndPrint) 
        {
            if (!(OS_NT5) && bEnforceCustomSecurity)
            {               
                return (ERROR_INVALID_DATA);
            }

            ((LPRASENTRY_V501)preRas)->dwfOptions2 |= RASEO2_SecureFileAndPrint;
        } 
        else 
        {
            ((LPRASENTRY_V501)preRas)->dwfOptions2 &= ~RASEO2_SecureFileAndPrint;
        }
    }
    else
    {
        if (nLegacySecureLocalFiles) 
        {
            preRas->dwfOptions |= RASEO_SecureLocalFiles;
        }
        else
        {
            preRas->dwfOptions &= ~RASEO_SecureLocalFiles;    
        }    
    }

    //
    // Pick up Whistler specific DUN settings
    //
    
    if (OS_NT51)    
    {
        //
        // Get the 501/Options2 style MSNet binding flag
        //

        if (iniFile.GPPB(c_pszCmSectionDunServer, c_pszCmEntryDunNetworkingSecureClientForMSNet,
                                        (BOOL) ((LPRASENTRY_V501)preRas)->dwfOptions2 & RASEO2_SecureClientForMSNet)) 
        {
            ((LPRASENTRY_V501)preRas)->dwfOptions2 |= RASEO2_SecureClientForMSNet;
        } 
        else 
        {
            ((LPRASENTRY_V501)preRas)->dwfOptions2 &= ~RASEO2_SecureClientForMSNet;
        }

        //
        // Get the 501/Options2 style Multilink Negotiation flag
        //

        if (iniFile.GPPB(c_pszCmSectionDunServer, c_pszCmEntryDunNetworkingDontNegotiateMultilink,
                                        (BOOL) ((LPRASENTRY_V501)preRas)->dwfOptions2 & RASEO2_DontNegotiateMultilink)) 
        {
            ((LPRASENTRY_V501)preRas)->dwfOptions2 |= RASEO2_DontNegotiateMultilink;
        } 
        else 
        {
            ((LPRASENTRY_V501)preRas)->dwfOptions2 &= ~RASEO2_DontNegotiateMultilink;
        }

        //
        // Get the 501/Options2 style DontUseRasCredentials flag
        //

        if (iniFile.GPPB(c_pszCmSectionDunServer, c_pszCmEntryDunNetworkingDontUseRasCredentials,
                                        (BOOL) ((LPRASENTRY_V501)preRas)->dwfOptions2 & RASEO2_DontUseRasCredentials)) 
        {
            ((LPRASENTRY_V501)preRas)->dwfOptions2 |= RASEO2_DontUseRasCredentials;
        } 
        else 
        {
            ((LPRASENTRY_V501)preRas)->dwfOptions2 &= ~RASEO2_DontUseRasCredentials;
        }

        //
        //  Get the RASEO_CustomScript flag value.  Note that this flag existed on Win2k but wasn't
        //  available for RasDial only RasDialDlg.  On Whistler+ it is available to RasDial as well.
        //  Note that we also have to set the RDEOPT_UseCustomScripting flag in the RASDIALEXTENSIONS
        //  for this to work.
        //
        if (iniFile.GPPB(c_pszCmSectionDunScripting, c_pszCmEntryDunScriptingUseRasCustomScriptDll,
                                        (BOOL) (preRas->dwfOptions & RASEO_CustomScript))) 
        {
            preRas->dwfOptions |= RASEO_CustomScript;
        } 
        else 
        {
            preRas->dwfOptions &= ~RASEO_CustomScript;
        }

        if (iniFile.GPPB(c_pszCmSectionDunServer, c_pszCmEntryDunServerDisableNbtOverIP,
                         (BOOL) (((LPRASENTRY_V501)preRas)->dwfOptions2 & RASEO2_DisableNbtOverIP)))
        {
            ((LPRASENTRY_V501)preRas)->dwfOptions2 |= RASEO2_DisableNbtOverIP;
        } 
        else 
        {
            ((LPRASENTRY_V501)preRas)->dwfOptions2 &= ~RASEO2_DisableNbtOverIP;
        }
    }

    //
    // Get and apply the TCP/IP section entries
    //

    if (iniFile.GPPB(c_pszCmSectionDunTcpIp, c_pszCmEntryDunTcpIpSpecifyIpAddress,
                                        (BOOL) preRas->dwfOptions & RASEO_SpecificIpAddr)) 
    {
        preRas->dwfOptions |= RASEO_SpecificIpAddr;
    } 
    else 
    {
        preRas->dwfOptions &= ~RASEO_SpecificIpAddr;
    }
    
    Ip_GPPS(&iniFile, c_pszCmSectionDunTcpIp, c_pszCmEntryDunTcpIpIpAddress, &preRas->ipaddr);
    
    if (iniFile.GPPB(c_pszCmSectionDunTcpIp, c_pszCmEntryDunTcpIpSpecifyServerAddress,
                                    (BOOL) preRas->dwfOptions & RASEO_SpecificNameServers)) 
    {
        preRas->dwfOptions |= RASEO_SpecificNameServers;
    } 
    else 
    {
        preRas->dwfOptions &= ~RASEO_SpecificNameServers;
    }

    if (iniFile.GPPB(c_pszCmSectionDunTcpIp, c_pszCmEntryDunTcpIpIpHeaderCompress,
                                    (BOOL) preRas->dwfOptions & RASEO_IpHeaderCompression)) 
    {
        preRas->dwfOptions |= RASEO_IpHeaderCompression;
    } 
    else 
    {
        preRas->dwfOptions &= ~RASEO_IpHeaderCompression;
    }

    Ip_GPPS(&iniFile, c_pszCmSectionDunTcpIp, c_pszCmEntryDunTcpIpDnsAddress, &preRas->ipaddrDns);
    Ip_GPPS(&iniFile, c_pszCmSectionDunTcpIp, c_pszCmEntryDunTcpIpDnsAltAddress, &preRas->ipaddrDnsAlt);
    Ip_GPPS(&iniFile, c_pszCmSectionDunTcpIp, c_pszCmEntryDunTcpIpWinsAddress, &preRas->ipaddrWins);
    Ip_GPPS(&iniFile, c_pszCmSectionDunTcpIp, c_pszCmEntryDunTcpIpWinsAltAddress, &preRas->ipaddrWinsAlt);
    
    if (iniFile.GPPB(c_pszCmSectionDunTcpIp, c_pszCmEntryDunTcpIpGatewayOnRemote,
                                    (BOOL) preRas->dwfOptions & RASEO_RemoteDefaultGateway)) 
    {
        preRas->dwfOptions |= RASEO_RemoteDefaultGateway;
    } 
    else 
    {
        preRas->dwfOptions &= ~RASEO_RemoteDefaultGateway;
    }

    if (OS_NT51)
    {
        //
        //  If the caller specified a DNS suffix then lets read it and add it to the RAS entry
        //
        CopyGPPS(&iniFile, c_pszCmSectionDunTcpIp, c_pszCmEntryDunTcpIpDnsSuffix, ((LPRASENTRY_V501)preRas)->szDnsSuffix, sizeof(((LPRASENTRY_V501)preRas)->szDnsSuffix)/sizeof(TCHAR));
    }

    //
    //  Set the TCP Window size -- the NTT DoCoMo fix for Whistler.  The Win2k version of this fix
    //  must be written through a private RAS API that must be called after the phonebook entry 
    //  exists ie. after we call RasSetEntryProperties ... otherwise it won't work on the first
    //  dial.
    //
    if (OS_NT51)
    {
        ((LPRASENTRY_V501)preRas)->dwTcpWindowSize = iniFile.GPPI(c_pszCmSectionDunTcpIp, c_pszCmEntryDunTcpIpTcpWindowSize, 0);
    }

    //
    // Get and apply the Scripting section entries
    //

    TCHAR szScript[MAX_PATH + 1] = TEXT("");
    CopyGPPS(&iniFile,c_pszCmSectionDunScripting, c_pszCmEntryDunScriptingName, szScript, sizeof(szScript)/sizeof(TCHAR));

    //
    // The script path from our cms file is a relative path. We need to convert
    // it to a full path, but make sure that we use the top-level service for
    // the conversion because it is used to derive the short-service name for
    // the directory.  Note that tunnel dun settings cannot have a script.
    //        

    if (szScript[0] && !fTunnel) 
    {
        CMTRACE1(TEXT("ReadDunSettings() - Converting script path %s to full path"), szScript);
        pszTmp = CmConvertRelativePath(pArgs->piniService->GetFile(), szScript);

        MYDBGASSERT(pszTmp);

        if (pszTmp && *pszTmp)
        {           
            lstrcpyU(preRas->szScript, pszTmp);
            CMTRACE1(TEXT("ReadDunSettings() - Script file is %s"), preRas->szScript);
        }

        CmFree(pszTmp);
    }   
    else
    {
        //
        // The cms didn't specify a script ==> no script
        //
        preRas->szScript[0] = TEXT('\0');
    }

    //
    //  If this is Whistler+ then we may need to invoke a terminal window
    //
    if (OS_NT51 && !fTunnel && iniFile.GPPB(c_pszCmSectionDunScripting, c_pszCmEntryDunScriptingUseTerminalWindow,
                                            (BOOL) preRas->dwfOptions & RASEO_TerminalAfterDial)) 
    {
        preRas->dwfOptions |= RASEO_TerminalAfterDial;
    } 
    else 
    {
        preRas->dwfOptions &= ~RASEO_TerminalAfterDial;
    }

    return (ERROR_SUCCESS);
}


//+----------------------------------------------------------------------------
//
// Function:  ValidateDialupDunSettings
//
// Synopsis:  Verifies the DUN settings that the specified .CMS and DUN name are
//            supported on the current platform. If we are running on a downlevel
//            OS and we encounter any NT specific security settings we error out.
//
// Arguments: LPCTSTR pszCmsFile     - The phone # specific .CMS file name.
//            LPCTSTR pszDunName     - The DUN name, if any for the settings.
//            LPCTSTR pszTopLevelCms - The top-level CMS file name.
//
// Returns:   BOOL - TRUE on success.
//
// History:   nickball    Created               8/26/98
//
//+----------------------------------------------------------------------------
BOOL ValidateDialupDunSettings(LPCTSTR pszCmsFile, LPCTSTR pszDunName, LPCTSTR pszTopLevelCms)
{
    MYDBGASSERT(pszCmsFile);
    MYDBGASSERT(*pszCmsFile);
    MYDBGASSERT(pszDunName);

    if (NULL == pszCmsFile || (!*pszCmsFile) || NULL == pszDunName)
    {
        return FALSE;
    }

    //
    // On NT5 we currently support all settings, so succeed automatically
    //

    if (OS_NT5)
    {
        return TRUE;
    }

    //
    // Determine the DUN name that we are looking for. In the tunnel case we
    // always read it from the .CMS. For dial-up, we'll use the specified DUN
    // name, and revert to the .CMS if blank. 
    //

    CIni iniFile(g_hInst, pszCmsFile);

    //
    // Now determine the DUN name to be used when looking up settings.
    //

    LPTSTR pszEntryName;

    //
    // If we have a specific DUN name to use, and we're not tunneling 
    // use it instead of the default DUN setting in the .CMS.
    //

    if (pszDunName && *pszDunName)
    {
        pszEntryName = CmStrCpyAlloc(pszDunName);
    }
    else
    {
        pszEntryName = GetDefaultDunSettingName(&iniFile, FALSE); // FALSE == not tunnel
    }

    //
    // If no DUN name is specified, then pass validation automatically
    //

    if (!pszEntryName || (!*pszEntryName))
    {
        CmFree(pszEntryName);
        CMTRACE1(TEXT("ValidateDunSettings() - No DUN name found in %s"), pszCmsFile);
        return TRUE;
    }
    
    //
    // Include the entryname in the section headers
    //

    LPTSTR pszSection = CmStrCpyAlloc(TEXT("&"));
    pszSection = CmStrCatAlloc(&pszSection, pszEntryName);
    iniFile.SetSection(pszSection);

    CmFree(pszSection);
    CmFree(pszEntryName);

    //
    // Check to see if the admin wants us to check the custom security settings
    // against the platform. By default, we do not enforce this check.
    // 
    //

    if (FALSE == iniFile.GPPB(c_pszCmSectionDunServer, c_pszCmEntryDunServerEnforceCustomSecurity))
    {
        return TRUE;
    }

    //
    // Now check the actual settings if we're still here.
    //

    if (iniFile.GPPB(c_pszCmSectionDunServer, c_pszCmEntryDunServerRequireEap))                             
    {
        goto ValidateDunSettingsExit;
    }

    if (iniFile.GPPB(c_pszCmSectionDunServer, c_pszCmEntryDunServerRequirePap))
    {
        goto ValidateDunSettingsExit;
    }
            
    if (iniFile.GPPB(c_pszCmSectionDunServer, c_pszCmEntryDunServerRequireSpap))
    {
        goto ValidateDunSettingsExit;
    }

    if (iniFile.GPPB(c_pszCmSectionDunServer, c_pszCmEntryDunServerRequireChap))
    {
        goto ValidateDunSettingsExit;
    }

    if (iniFile.GPPB(c_pszCmSectionDunServer, c_pszCmEntryDunServerRequireMsChap))
    {
        goto ValidateDunSettingsExit;
    }

    if (iniFile.GPPB(c_pszCmSectionDunServer, c_pszCmEntryDunServerRequireMsChap2))
    {
        goto ValidateDunSettingsExit;
    }

    if (iniFile.GPPB(c_pszCmSectionDunServer, c_pszCmEntryDunServerRequireW95MsChap))
    {
        goto ValidateDunSettingsExit;
    }

    if (iniFile.GPPB(c_pszCmSectionDunServer, c_pszCmEntryDunServerCustomSecurity))
    {
        goto ValidateDunSettingsExit;
    }

    if (iniFile.GPPB(c_pszCmSectionDunServer, c_pszCmEntryDunServerEncryptionType))                             
    {
        goto ValidateDunSettingsExit;
    }

    if (-1 != iniFile.GPPI(c_pszCmSectionDunServer, c_pszCmEntryDunServerCustomAuthKey, -1))  
    {
        goto ValidateDunSettingsExit;
    }
            
    if (-1 != iniFile.GPPI(c_pszCmSectionDunNetworking, c_pszCmEntryDunNetworkingVpnStrategy, -1))
    {
        goto ValidateDunSettingsExit;
    }
    
    return TRUE;

ValidateDunSettingsExit:

    //
    // Get the top-level service name
    //

    CIni iniTopLevelCms(g_hInst, pszTopLevelCms);

    LPTSTR pszTitle = GetServiceName(&iniTopLevelCms);
    LPTSTR pszTmp = CmFmtMsg(g_hInst,IDMSG_UNSUPPORTED_SETTING_NUM);       

    MessageBoxEx(NULL, pszTmp, pszTitle, MB_OK|MB_ICONSTOP, LANG_USER_DEFAULT);//13309
    
    CmFree(pszTmp);                 
    CmFree(pszTitle);

    CMTRACE1(TEXT("ValidateDunSettings() - Unsupported setting detected in %s"), pszCmsFile);
    return FALSE;
}

//+----------------------------------------------------------------------------
//
// Function:  InvokeTerminalWindow
//
// Synopsis:  Allows CM to invoke a terminal window on Whistler or later versions
//            of Win2k but calling a private RAS API in RasDlg.dll.
//
// Arguments: LPCWSTR pszPhoneBook - full path to the phonebook file
//            LPCWSTR pszEntry - entry name to invoke the terminal window for
//            RASDIALPARAMS *pRasDialParams - RasDialParams for the connection
//                                            to invoke the terminal window for
//            HWND hWnd - window handle of the parent dialog
//            HRASCONN hRasconn - handle to the ras connection
//
// Returns:   Windows error message
//
// History:   quintinb    Created               07/11/00
//
//+----------------------------------------------------------------------------
DWORD InvokeTerminalWindow(LPCWSTR pszPhoneBook, LPCWSTR pszEntry, RASDIALPARAMS *pRasDialParams, HWND hWnd, HRASCONN hRasconn)
{
    //
    //  Validate the input parameters.  Note that pszPhoneBook can be NULL but if it is non-NULL then we cannot have
    //  an empty string.
    //
    MYDBGASSERT(OS_NT51);
    if (((NULL != pszPhoneBook) && (L'\0' == pszPhoneBook[0])) || 
        (NULL == pszEntry) || (L'\0' == pszEntry[0]) || (NULL == pRasDialParams) || 
        (NULL == hWnd) || (NULL == hRasconn))
    {
        CMASSERTMSG(FALSE, TEXT("InvokeTerminalWindow - Invalid parameter passed."));
        return ERROR_INVALID_PARAMETER; 
    }

    DWORD dwReturn;
    typedef DWORD (WINAPI *pfnDwTerminalDlgSpec)(LPCWSTR, LPCWSTR, RASDIALPARAMS *, HWND, HRASCONN);

    //
    //  First call loadlibrary on rasdlg.dll
    //

    HMODULE hRasDlg = LoadLibraryExU(TEXT("rasdlg.dll"), NULL, 0);

    if (hRasDlg)
    {
        pfnDwTerminalDlgSpec pfnDwTerminalDlg = (pfnDwTerminalDlgSpec)GetProcAddress(hRasDlg, "DwTerminalDlg");

        if (pfnDwTerminalDlg)
        {
            dwReturn = pfnDwTerminalDlg(pszPhoneBook, pszEntry, pRasDialParams, hWnd, hRasconn);
        }
        else
        {
            dwReturn = ERROR_PROC_NOT_FOUND;
        }
        
        FreeLibrary(hRasDlg);
    }
    else
    {
        dwReturn = ERROR_MOD_NOT_FOUND;
    }

    return dwReturn;
}

//+----------------------------------------------------------------------------
//
// Function:  OnPauseRasDial
//
// Synopsis:  Message handler for RasDial pause states. In the pause state, RAS
//            is suspended, waiting for us to restart it by calling RasDial after
//            performing the appropriate interface with the user.
//
// Arguments: HWND hwndDlg      - Window handle of main dialog
//            ArgsStruct *pArgs - Ptr to global args struct  
//            WPARAM wParam     - wParam being handled  
//            LPARAM lParam     - lParam being handled
//
// Returns:   Windows error message
//
// History:   nickball    Created               05/19/99
//
//+----------------------------------------------------------------------------

DWORD OnPauseRasDial(HWND hwndDlg, ArgsStruct *pArgs, WPARAM wParam, LPARAM lParam)        
{                      
    CMTRACE2(TEXT("OnPauseRasDial - wParam is %u and lParam is %u."), wParam, lParam);    

    MYDBGASSERT(pArgs);
    if (NULL == pArgs)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Get connection handle and re-dial
    //
    
    HRASCONN hRasConn;
    DWORD dwRes = ERROR_SUCCESS;    
    LPTSTR pszRasPbk = pArgs->pszRasPbk;
    
    //
    // Determine the appropriate connection handle and phonebook
    // Note: Make an explicit copy or we'll wind up re-dialing
    // if the connection drops while the pause UI is invoked.
    //

    if (IsDialingTunnel(pArgs))
    {
        hRasConn = pArgs->hrcTunnelConn;
    }
    else
    {
        hRasConn = pArgs->hrcRasConn;

        if (pArgs->pszRasHiddenPbk)
        {
            pszRasPbk = pArgs->pszRasHiddenPbk;
        }
    }

    //
    // Handle the pause
    //

    switch (wParam)
    {
        case (RASCS_PAUSED + 4):  // 4100 - RASCS_InvokeEapUI )

            //
            // If UNATTENDED, just bail out immediately.
            //
    
            if (pArgs->dwFlags & FL_UNATTENDED)
            {
                dwRes = ERROR_INTERACTIVE_MODE;
                goto OnPauseRasDialExit;
            }

            //
            // If EAP triggered the pause, invoke the EAP UI
            //
    
            dwRes = pArgs->rlsRasLink.pfnInvokeEapUI(hRasConn, pArgs->dwRasSubEntry, pArgs->pRasDialExtensions, hwndDlg);
      
            CMTRACE1(TEXT("OnPauseRasDial() - InvokeEapUI() returns %u."), dwRes);           
            break;

        case RASCS_PasswordExpired: // Domain password has expired
        {
            //
            // If UNATTENDED, just bail out immediately.
            //
    
            if (pArgs->dwFlags & FL_UNATTENDED)
            {
                dwRes = ERROR_INTERACTIVE_MODE;
                goto OnPauseRasDialExit;
            }

            CChangePasswordDlg  NewPasswordDlg(pArgs);
            
            if (IDOK != NewPasswordDlg.DoDialogBox(g_hInst, IDD_CHANGEPASSWORD, pArgs->hwndMainDlg))
            {
                if (pArgs->dwExitCode)
                {
                    dwRes = pArgs->dwExitCode;
                }
                else
                {
                    dwRes = ERROR_CANCELLED;
                }
            }
            
            CMTRACE1(TEXT("OnPauseRasDial() - Password Expired"), dwRes);
            
            break;
        }

        case RASCS_CallbackSetByCaller: // Server wants to call us back
        {           
            //
            // Preset dial params and call dialog to retrieve number from user
            // 
            
            LPTSTR pszTmp = pArgs->piniProfile->GPPS(c_pszCmSection, c_pszCmEntryCallbackNumber);   
            lstrcpyU(pArgs->pRasDialParams->szCallbackNumber, pszTmp);
            CmFree(pszTmp);
       
            //
            // If we're running unattended, skip the dialog phase. The 
            // presumption is that there is no user there to receive it.
            //

            BOOL bPromptUser = !(pArgs->dwFlags & FL_UNATTENDED);
                               
            if (bPromptUser)    
            {
                //
                // The above also applies in the case of DialAutomatically
                // if we have a phone number, then there is no need to prompt.
                //
                
                if (pArgs->fDialAutomatically && TEXT('\0') != pArgs->pRasDialParams->szCallbackNumber[0])
                {
                    bPromptUser = FALSE;
                }
            }

            if (bPromptUser)
            {
                CCallbackNumberDlg CallbackNumberDialog(pArgs);                       
                
                if (IDOK != CallbackNumberDialog.DoDialogBox(g_hInst, IDD_CALLBACK_NUMBER, pArgs->hwndMainDlg))
                {
                    //
                    // If the user canceled, clear the number so that RAS wont attempt callback
                    //

                    lstrcpyU(pArgs->pRasDialParams->szCallbackNumber, TEXT(""));
                }
            }
           
            dwRes = ERROR_SUCCESS;          
            CMTRACE1(TEXT("OnPauseRasDial() - CallbackSetByCaller returns %u"), dwRes);
            
            break;
        }

        case RASCS_RetryAuthentication: // Credentials aren't correct
        {
            //
            // If UNATTENDED, just bail out immediately.
            //
    
            if (pArgs->dwFlags & FL_UNATTENDED)
            {
                dwRes = ERROR_INTERACTIVE_MODE;
                goto OnPauseRasDialExit;
            }

            //
            // Creds didn't work, prompt user for new ones.
            //

            CRetryAuthenticationDlg RetryAuthenticationDialog(pArgs); 

            if (IDOK != RetryAuthenticationDialog.DoDialogBox(g_hInst, 
                                                               RetryAuthenticationDialog.GetDlgTemplate(),
                                                               pArgs->hwndMainDlg))         
            {
                //
                // User canceled, or the call was dropped elsewhere. Use 
                // existing error code or designate authentication failure.
                //

                if (pArgs->dwExitCode)
                {
                    dwRes = pArgs->dwExitCode;
                }
                else
                {
                    dwRes = ERROR_AUTHENTICATION_FAILURE;
                }
            }
            
            CMTRACE1(TEXT("OnPauseRasDial() - RetryAuthentication"), dwRes);            
            break;      
        }
        
        case RASCS_Interactive:         // Terminal/script pause state
            if (OS_NT51)
            {
                if (pArgs->dwFlags & FL_UNATTENDED)
                {
                    dwRes = ERROR_INTERACTIVE_MODE;
                    goto OnPauseRasDialExit;
                }

                dwRes = InvokeTerminalWindow(pszRasPbk, pArgs->szServiceName, pArgs->pRasDialParams, pArgs->hwndMainDlg, hRasConn);
                break;
            } // else fail through to default and error out.

        //
        // We got a pause state that we don't handle, error out.
        //
        default:
            dwRes = ERROR_INTERACTIVE_MODE;
            CMASSERTMSG(FALSE, TEXT("OnPauseRasDial() - Error, unsupported RAS pause state encountered."));                                
            break;
    }

    //
    // On success, call RasDial to resume connection
    //

    if (ERROR_SUCCESS == dwRes)
    {
        //
        // Decode active password, re-call RasDial, then re-encode
        //
        
        CmDecodePassword(pArgs->pRasDialParams->szPassword); 

        CMASSERTMSG((NOT_IN_CONNECT_OR_CANCEL == pArgs->lInConnectOrCancel),
                    TEXT("OnPauseRasDial - RasDial mutex is NOT NULL..."));

        dwRes = pArgs->rlsRasLink.pfnDial(pArgs->pRasDialExtensions, 
                                          pszRasPbk, 
                                          pArgs->pRasDialParams, 
                                          GetRasCallBackType(), 
                                          GetRasCallBack(pArgs), 
                                          &hRasConn);

        CmEncodePassword(pArgs->pRasDialParams->szPassword); 
 
        CMTRACE1(TEXT("OnPauseRasDial() - RasDial() returns %u."), dwRes);           

        //
        // Reset timers, the current action starts now.
        //

        pArgs->dwStateStartTime = GetTickCount();
        pArgs->nLastSecondsDisplay = (UINT) -1;
    }

OnPauseRasDialExit:

    if (ERROR_SUCCESS != dwRes)
    {
        OnRasErrorMessage(hwndDlg, pArgs, dwRes);
    }

    return dwRes;
}

//+----------------------------------------------------------------------------
//
// Function:  GetRasCallBackType
//
// Synopsis:  Simple function to return the Callback type that we use for RasDial
//            depending upon the OS.
//
// Arguments: None
//
// Returns:   DWORD - The callback type
//
// History:   nickball    Created       05/22/99
//
//+----------------------------------------------------------------------------

DWORD GetRasCallBackType()
{
    if (OS_NT5) 
    {
        return 2;
    }
    else
    {
        return -1;
    }
}

//+----------------------------------------------------------------------------
//
// Function:  GetRasCallBack
//
// Synopsis:  Simple function to return the Callback that we use for RasDial
//            depending upon the OS.
//
// Arguments: ArgsStruct *pArgs - Ptr to global args struct  
//
// Returns:   LPVOID - The callback
//
// History:   nickball    Created       05/22/99
//
//+----------------------------------------------------------------------------

LPVOID GetRasCallBack(ArgsStruct* pArgs)
{
    MYDBGASSERT(pArgs);

    if (NULL == pArgs)
    {
        return NULL;
    }

    //
    // Now set return the callback func or hwnd according to OS.
    //

    if (OS_NT5)
    {       
        //
        // Set Callback data in RasDialParams
        //

        if (pArgs->pRasDialParams->dwSize == sizeof(RASDIALPARAMS_V401))
        {          
            ((LPRASDIALPARAMS_V401)pArgs->pRasDialParams)->dwCallbackId = (ULONG_PTR) pArgs;
        }      

       return (LPVOID) RasDialFunc2;
    }
    else
    {
        MYDBGASSERT(pArgs->hwndMainDlg);
        return (LPVOID) pArgs->hwndMainDlg;
    }
}


//+----------------------------------------------------------------------------
//
// Function:  AllocateSecurityDescriptorAllowAccessToWorld
//
// Synopsis:  This function allocates a security descriptor for all users.
//            This function was taken directly from RAS when they create their
//            phonebook. This has to be before GetPhoneBookPath otherwise it 
//            causes compile errors in other components since we don't have a
//            function prototype anywhere and cmcfg just includes this (getpbk.cpp)
//            file. This function is also in common\source\getpbk.cpp
//
// Arguments: PSECURITY_DESCRIPTOR *ppSd - Pointer to a pointer to the SD struct
//
// Returns:   DWORD - returns ERROR_SUCCESS if successfull
//
// History:   06/27/2001    tomkel  Taken from RAS ui\common\pbk\file.c
//
//+----------------------------------------------------------------------------
#define SIZE_ALIGNED_FOR_TYPE(_size, _type) \
    (((_size) + sizeof(_type)-1) & ~(sizeof(_type)-1))

DWORD AllocateSecurityDescriptorAllowAccessToWorld(PSECURITY_DESCRIPTOR *ppSd)
{
    PSECURITY_DESCRIPTOR    pSd;
    PSID                    pSid;
    PACL                    pDacl;
    DWORD                   dwErr = ERROR_SUCCESS;
    DWORD                   dwAlignSdSize;
    DWORD                   dwAlignDaclSize;
    DWORD                   dwSidSize;
    PVOID                   pvBuffer;
    DWORD                   dwAcls = 0;

    // Here is the buffer we are building.
    //
    //   |<- a ->|<- b ->|<- c ->|
    //   +-------+--------+------+
    //   |      p|      p|       |
    //   | SD   a| DACL a| SID   |
    //   |      d|      d|       |
    //   +-------+-------+-------+
    //   ^       ^       ^
    //   |       |       |
    //   |       |       +--pSid
    //   |       |
    //   |       +--pDacl
    //   |
    //   +--pSd (this is returned via *ppSd)
    //
    //   pad is so that pDacl and pSid are aligned properly.
    //
    //   a = dwAlignSdSize
    //   b = dwAlignDaclSize
    //   c = dwSidSize
    //

    if (NULL == ppSd)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Initialize output parameter.
    //
    *ppSd = NULL;

    // Compute the size of the SID.  The SID is the well-known SID for World
    // (S-1-1-0).
    //
    dwSidSize = GetSidLengthRequired(1);

    // Compute the size of the DACL.  It has an inherent copy of SID within
    // it so add enough room for it.  It also must sized properly so that
    // a pointer to a SID structure can come after it.  Hence, we use
    // SIZE_ALIGNED_FOR_TYPE.
    //
    dwAlignDaclSize = SIZE_ALIGNED_FOR_TYPE(
                        sizeof(ACCESS_ALLOWED_ACE) + sizeof(ACL) + dwSidSize,
                        PSID);

    // Compute the size of the SD.  It must be sized propertly so that a
    // pointer to a DACL structure can come after it.  Hence, we use
    // SIZE_ALIGNED_FOR_TYPE.
    //
    dwAlignSdSize   = SIZE_ALIGNED_FOR_TYPE(
                        sizeof(SECURITY_DESCRIPTOR),
                        PACL);

    // Allocate the buffer big enough for all.
    //
    dwErr = ERROR_OUTOFMEMORY;
    pvBuffer = CmMalloc(dwSidSize + dwAlignDaclSize + dwAlignSdSize);
    if (pvBuffer)
    {
        SID_IDENTIFIER_AUTHORITY SidIdentifierWorldAuth
                                    = SECURITY_WORLD_SID_AUTHORITY;
        PULONG  pSubAuthority;

        dwErr = NOERROR;

        // Setup the pointers into the buffer.
        //
        pSd   = pvBuffer;
        pDacl = (PACL)((PBYTE)pvBuffer + dwAlignSdSize);
        pSid  = (PSID)((PBYTE)pDacl + dwAlignDaclSize);

        // Initialize pSid as S-1-1-0.
        //
        if (!InitializeSid(
                pSid,
                &SidIdentifierWorldAuth,
                1))  // 1 sub-authority
        {
            dwErr = GetLastError();
            goto finish;
        }

        pSubAuthority = GetSidSubAuthority(pSid, 0);
        *pSubAuthority = SECURITY_WORLD_RID;

        // Initialize pDacl.
        //
        if (!InitializeAcl(
                pDacl,
                dwAlignDaclSize,
                ACL_REVISION))
        {
            dwErr = GetLastError();
            goto finish;
        }

        dwAcls = SPECIFIC_RIGHTS_ALL | STANDARD_RIGHTS_ALL;

        dwAcls &= ~(WRITE_DAC | WRITE_OWNER);
        
        if(!AddAccessAllowedAce(
                pDacl,
                ACL_REVISION,
                dwAcls,
                pSid))
        {
            dwErr = GetLastError();
            goto finish;
        }

        // Initialize pSd.
        //
        if (!InitializeSecurityDescriptor(
                pSd,
                SECURITY_DESCRIPTOR_REVISION))
        {
            dwErr = GetLastError();
            goto finish;
        }

        // Set pSd to use pDacl.
        //
        if (!SetSecurityDescriptorDacl(
                pSd,
                TRUE,
                pDacl,
                FALSE))
        {
            dwErr = GetLastError();
            goto finish;
        }

        // Set the owner for pSd.
        //
        if (!SetSecurityDescriptorOwner(
                pSd,
                NULL,
                TRUE))
        {
            dwErr = GetLastError();
            goto finish;
        }

        // Set the group for pSd.
        //
        if (!SetSecurityDescriptorGroup(
                pSd,
                NULL,
                FALSE))
        {
            dwErr = GetLastError();
            goto finish;
        }

finish:
        if (!dwErr)
        {
            *ppSd = pSd;
        }
        else
        {
            CmFree(pvBuffer);
        }
    }

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmdial\rnawnd.cpp ===
//+----------------------------------------------------------------------------
//
// File:     rnawnd.cpp    
//
// Module:   CMDIAL32.DLL
//
// Synopsis: Win9x Rnaapp.exe workaround code.
//
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Author:   quintinb	created Header	08/16/99
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"
#include <process.h>

#define MAX_RNA_WND_TITLE_LEN   26    // Max chars for window title compare
#define MAX_ZAPRNA_PAUSE 50           // milliseconds to pause between window enumerations  

typedef struct tagFRCTParam {
    HANDLE hEvent;
	LPSTR pszDun;
} ZRCTParam, *PZRCTP;

typedef struct tagFindParam {
	LPCSTR pszTitle;
    HWND hwndRNA;
} FINDPARAM, *PFINDPARAM;

//+---------------------------------------------------------------------------
//
//	Function:	FindRnaWindow
//
//	Synopsis:	Callback for EnumWindows().  It receives the hwnd of all the 
//              top-level windows.  It's job is to look for the RNA status wnd.
//
//	Arguments:	hwndTop hwnd of the top-level window
//              lParam  title of the rna wnd to be found.
//
//	Returns:	NONE
//
//	History:	henryt	Created		8/19/97
//----------------------------------------------------------------------------

BOOL CALLBACK FindRnaWindow(
    HWND    hwndTop,
    LPARAM  lParam)
{
    MYDBGASSERT(lParam);

    PFINDPARAM pFindParam = (PFINDPARAM) lParam;
    CHAR szTitle[MAX_RNA_WND_TITLE_LEN + 1];

    if (NULL == pFindParam)
    {
        return TRUE;
    }

    //
    // We are looking for a top-level window with a title matching lParam
    //
    
    if (MAKEINTATOM(GetClassLongU(hwndTop, GCW_ATOM)) == WC_DIALOG)
    {
        GetWindowTextA(hwndTop, szTitle, MAX_RNA_WND_TITLE_LEN + 1);
        //
        // truncate the window title as we only check the first few chars
        //
        szTitle[MAX_RNA_WND_TITLE_LEN] = '\0';

        if (lstrcmpA(szTitle, pFindParam->pszTitle) == 0)
        {
            //
            // Its a match, update the hwnd and bail
            //

            pFindParam->hwndRNA = hwndTop;
            return FALSE;
        }
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:  fnZRCT
//
// Synopsis:  Thread to terminate RNA "Connected To" dlg
//
// Arguments: void *pvParam - Thread parameters PZRCTP containing connectoid 
//                            name is expected
//
// Returns:   unsigned long - Standard thread return code
//
// History:   nickball    Created    3/5/98
//
//+----------------------------------------------------------------------------
static unsigned long __stdcall fnZRCT(void *pvParam) 
{
	PZRCTP pParam = (PZRCTP) pvParam;
    PFINDPARAM pFindParam = NULL;
	unsigned uRes = 1;
	HMODULE hLibrary = NULL;
	BOOL bRes;
	HLOCAL hRes;
    LPSTR pszFmt = NULL;
	CHAR szTmp[MAX_PATH];
	DWORD dwIdx;
    DWORD dwWait;

    MYDBGASSERT(pParam->hEvent);
    MYDBGASSERT(pParam->pszDun);

    //
    // Load RNAAPP.EXE, so we can access its resources
    //

	hLibrary = LoadLibraryExA("rnaapp.exe", NULL, LOAD_LIBRARY_AS_DATAFILE);
	if (!hLibrary) 
    {
		uRes = GetLastError();
		CMTRACE1(TEXT("fnZRCT() LoadLibraryEx() failed, GLE=%u."), GetLastError());
		goto done;
	}

    //
    // Extract string #204 from RNAAPP.EXE, then release.
    //
	
    if (!LoadStringA(hLibrary, 204, szTmp, sizeof(szTmp)/sizeof(CHAR)-1))
    {
		uRes = GetLastError();
		CMTRACE1(TEXT("fnZRCT() LoadString() failed, GLE=%u."), GetLastError());
		goto done;
	}
	
    bRes = FreeLibrary(hLibrary);
    hLibrary = NULL;

#ifdef DEBUG
    if (!bRes)
    {
        CMTRACE1(TEXT("fnZRCT() FreeLibrary() failed, GLE=%u."), GetLastError());
    }
#endif
	
    //
    // Format the string with our DUN name
    //
    
    pszFmt = (LPSTR)CmMalloc((lstrlenA(szTmp)+1)*sizeof(TCHAR));
	
    if (!pszFmt) 
    {
		uRes = GetLastError();
		CMTRACE1(TEXT("fnZRCT() CmMalloc() failed, GLE=%u."), GetLastError());
		goto done;
	}
	
    lstrcpyA(pszFmt, szTmp);
	wsprintfA(szTmp, pszFmt, pParam->pszDun);
    
    //
    // to work around a bug where a long connectoid/profile name can prevent
    // us to look for the RNA window(because the window title will be truncated)
    // we only read the first 26 chars.
    //

    szTmp[MAX_RNA_WND_TITLE_LEN] = '\0';
   
    //
    // Setup param for FindRnaWindow callback used in EnumWindows
    //

    pFindParam = (PFINDPARAM)CmMalloc(sizeof(FINDPARAM));
	if (!pFindParam) 
    {
		CMTRACE1(TEXT("ZapRNAConnectedTo() CmMalloc() failed, GLE=%u."), GetLastError());
		goto done;
	}
    
    pFindParam->pszTitle = szTmp;
    pFindParam->hwndRNA = NULL;

    //
    // Try to find the window every 50 milliseconds up to 200 times
    //

    CMTRACE1(TEXT("fnZRCT() is watching for a window named %s."), szTmp);

    for (dwIdx=0; dwIdx < 200; dwIdx++) 
    {
        EnumWindows(FindRnaWindow, (LPARAM) pFindParam);

		//hwndRNA = FindWindow(TEXT("#32770"),szTmp);
		
        //
        // If hwnd has a value, its the RNA wind, hide it and bail
        //

        if (pFindParam->hwndRNA) 
        {
			CMTRACE(TEXT("fnZRCT() is hiding the dialog."));
			ShowWindowAsync(pFindParam->hwndRNA,SW_HIDE);
			uRes = 0;
			break;
		}
		
        //
        // Wait for MAX_ZAPRNA_PAUSE milliseconds, or until event is signaled
        //

        dwWait = WaitForSingleObject(pParam->hEvent, MAX_ZAPRNA_PAUSE);

        //
        // If not a timeout, we're done
        //

        if (WAIT_TIMEOUT != dwWait)
        {
            //
            // If not an event signal, report 
            //

            if (WAIT_OBJECT_0 != dwWait)
            {       
    		    CMTRACE1(TEXT("fnZRCT() WAIT_OBJECT_0 != dwWait, GLE=%u."), GetLastError());
            }

            break;
        }
	}

done:
	
    //
    // Cleanup
    //
#ifdef DEBUG
    if (uRes)
    {
        CMTRACE(TEXT("fnZRCT() has exited without hiding the dialog."));
    }
#endif

    CmFree(pParam->pszDun);
	CmFree(pParam);
	CmFree(pFindParam);
	CmFree(pszFmt);

#ifdef DEBUG
    if (uRes)
    {
        CMTRACE(TEXT("fnZRCT() could not free all of its alloc-ed memory"));
    }
#endif

    if (hLibrary) 
    {
		bRes = FreeLibrary(hLibrary);
	}
	
    CMTRACE1(TEXT("fnZRCT() is exiting with uRes=%u."), uRes);

	return (uRes);
}

//+----------------------------------------------------------------------------
//
// Function:  ZapRNAConnectedTo
//
// Synopsis:  Fires off thread to hide the RNA "Connected To" dlg
//
// Arguments: LPCTSTR pszDUN - The name of the DUN entry that we are connecting
//            HANDLE hEvent - Handle to CM termination event
//
// Returns:   HANDLE - Handle of created thread or NULL on failure
//
// History:   nickball    Created Header    3/5/98
//
//+----------------------------------------------------------------------------
HANDLE ZapRNAConnectedTo(LPCTSTR pszDUN, HANDLE hEvent) 
{
	MYDBGASSERT(pszDUN);
    MYDBGASSERT(hEvent);
    
    PZRCTP pParam;
	unsigned long tidThread;
	HANDLE hThread = NULL;

	if (NULL == pszDUN || NULL == *pszDUN || NULL == hEvent) 
    {
		return hThread;
	}
	
    pParam = (PZRCTP) CmMalloc(sizeof(ZRCTParam));

	if (!pParam) 
    {
		CMTRACE1(TEXT("ZapRNAConnectedTo() CmMalloc() failed, GLE=%u."), GetLastError());
		return hThread;
	}

    pParam->pszDun = WzToSzWithAlloc(pszDUN);

	if (!pParam->pszDun) 
    {
		CMTRACE1(TEXT("ZapRNAConnectedTo() CmMalloc() failed, GLE=%u."), GetLastError());
		return hThread;
	}
    
    //
    // Setup params to be passed to thread
    //

    pParam->hEvent = hEvent;

    //
    // Create the Zap thread 
    //

    hThread = (HANDLE) CreateThread(NULL, 0, fnZRCT, pParam, 0, &tidThread);
	if (!hThread) 
    {
        //
        // Couldn't create thread, free params
        //

        CMTRACE1(TEXT("ZapRNAConnectedTo() CreateThread() failed, GLE=%u."), GetLastError());
		CmFree(pParam);
	} 

    // 
    // Note: pParam is release inside thread
    //
 
    CMTRACE1(TEXT("fnZRCT() is exiting with hThread=%u."), hThread);
    
    return hThread;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmdial\state.h ===
//+----------------------------------------------------------------------------
//
// File:     state.h
//
// Module:   CMDIAL32.DLL
//
// Synopsis: Dialing states definition
//
// Copyright (c) 1998 Microsoft Corporation
//
// Author:   quintinb	Created Header	08/16/99
//
//+----------------------------------------------------------------------------

#ifndef __STATE_H_DEFINED__
#define __STATE_H_DEFINED__

#ifndef _PROGSTATE_ENUMERATION
#define _PROGSTATE_ENUMERATION
typedef enum _ProgState {
        PS_Interactive=0,		  // interactive with user
        PS_Dialing,				  // dialing primary number
        PS_RedialFrame,			  // Redialing, for future flash frame# only, not a state
        PS_Pausing,				  // waiting to re-dial
        PS_Authenticating,		  // authenticating user-password
        PS_Online,				  // connected/on-line
		PS_TunnelDialing,		  // start to dial up tunnel server
		PS_TunnelAuthenticating,  // start authentication for tunnel connection
		PS_TunnelOnline,		  // we're now online for tunneling
		PS_Error,					// Error while attempting to connect
        PS_Last
} ProgState;

const int NUMSTATES = PS_Last;

#endif // _PROGSTATE_ENUMERATION
#endif // __STATE_H_DEFINED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmdial\resource.h ===
//+----------------------------------------------------------------------------
//
// File:     resource.h     
//
// Module:   CMDIAL32.DLL
//
// Synopsis: Resource ID definitions
//
// Copyright (c) 1996-1998 Microsoft Corporation
//
// Author:   quintinb   Created Header      08/17/99
//
//+----------------------------------------------------------------------------

// Used by icmdlg.rc
//
#define IDD_MAIN_ALL_USERDATA           101
#define IDD_MAIN_NO_USERDATA            102
#define IDD_MAIN_UID_ONLY               103
#define IDD_MAIN_UID_AND_PWD            104
#define IDD_MAIN_UID_AND_DMN            105
#define IDD_MAIN_PWD_ONLY               106
#define IDD_MAIN_PWD_AND_DMN            107
#define IDD_MAIN_DMN_ONLY               108
#define IDD_CHANGEPASSWORD              109
#define IDD_CALLBACK_NUMBER             110
//                                      111
#define IDI_APP                         112
#define IDB_APP                         113
#define IDD_PHONEBOOK                   114
#define IDD_PHONEBOOKEX                 115
#define IDB_PB                          116
//                                      117
//                                      118
//                                      119
#define IDM_TRAY                        120
#define IDMC_TRAY_OPEN                  121
#define IDD_RECONNECT                   123
#define IDD_DIAL                        124
#define IDD_MODEM                       125
#define IDD_TUNNEL                      126
#define IDD_TUNNEL_SIGNIN               127
#define IDD_EDIT_NUMBER                 128
#define IDD_RETRY_UID_PWD_DMN           129
#define IDD_RETRY_UID_AND_DMN           130
#define IDD_RETRY_PWD_AND_DMN           131
#define IDD_RETRY_DMN_ONLY              132
#define IDD_RETRY_UID_AND_PWD           133
#define IDD_RETRY_UID_ONLY              134
#define IDD_RETRY_PWD_ONLY              135
//                                      136
//                                      137
//                                      138
//                                      139
//                                      140
//                                      141
//                                      142
//                                      143
#define IDD_INTERNET_SIGNIN             144
#define IDD_INTERNET_SIGNIN_NO_UID      145
#define IDD_INTERNET_SIGNIN_NO_PWD      146
#define IDD_INET_SIGNIN                 147
#define IDD_INET_SIGNIN_NO_UID          148
#define IDD_INET_SIGNIN_NO_PWD          149
#define IDD_OPTIONS                     150
//                                      151
#define IDD_ABOUT                       152
#define IDD_GENERAL                     153
#define IDD_GENERAL_DIRECT              154
#define IDD_VPN                         155

#define IDC_MAIN_BITMAP                 1001
#define IDC_PHONEBOOK_BITMAP            1002
#define IDC_MAIN_USERNAME_EDIT          1004
#define IDC_MAIN_PASSWORD_EDIT          1005
#define IDC_MAIN_REMEMBER_CHECKBOX      1006
#define IDC_MAIN_MESSAGE_DISPLAY        1007
#define IDC_MAIN_STATUS_DISPLAY         1008
#define IDC_MAIN_DOMAIN_EDIT            1009
#define IDC_MAIN_PROPERTIES_BUTTON      1010
#define IDC_MAIN_HELP_BUTTON            1011
#define IDB_ABOUT                       1012
#define IDC_EDIT_PHONE                  1013
#define IDC_EDIT_AREA_CODE              1014
#define IDC_EDIT_EXACT                  1015
#define IDC_EDIT_COUNTRY_COMBO          1016
#define IDC_MAIN_USERNAME_STATIC        1017
#define IDC_MAIN_PASSWORD_STATIC        1018
#define IDC_MAIN_DOMAIN_STATIC          1019
#define IDC_EDIT_HELP                   1020
#define IDC_RADIO_DIRECT                1021
#define IDC_RADIO_DIALUP                1022
//                                      1023
//                                      1024
#define IDC_PHONEBOOK_SERVICETYPE_COMBO 1025
#define IDC_PHONEBOOK_COUNTRY_COMBO     1026
#define IDC_PHONEBOOK_PHONE_LIST        1027
#define IDC_PHONEBOOK_REGION_COMBO      1028
#define IDC_PHONEBOOK_REGION_STATIC     1029
#define IDC_PHONEBOOK_HELP_BUTTON       1030
#define IDC_PHONEBOOK_MORE_BUTTON       1031
#define IDC_PHONEBOOKEX_PHONE_LIST      1032
#define IDC_PHONEBOOKEX_MESSAGE_DISPLAY 1033
#define IDC_MAIN_SERVICE_LABEL          1034
#define IDC_MAIN_STATUS_LABEL           1035
#define IDC_PHONEBOOKEX_MORE_STATIC     1036
//                                      1037
#define IDC_CONNSTAT_ICON               1038
#define IDC_CONNSTAT_DURATION_DISPLAY   1039
#define IDC_CONNSTAT_SPEED_DISPLAY      1040
#define IDC_CONNSTAT_RECEIVED_DISPLAY   1041
#define IDC_CONNSTAT_SENT_DISPLAY       1042
#define IDC_CONNSTAT_DISCONNECT_BUTTON  1043
#define IDC_CONNSTAT_DISCONNECT_DISPLAY 1044
#define IDC_NEW_PASSWORD                1045
#define IDC_CONFIRMNEWPASSWORD          1046
//                                      1047
//                                      1048
#define IDC_DETAILS                     1049
#define IDC_DETAILINFO                  1050
#define IDC_DIALGROUP                   1051
#define IDC_MODEMGROUP                  1052
#define IDC_INET_ICON                   1053
#define IDC_CALLBACK_NUM_EDIT           1054
#define IDC_CALLBACK_NUM_LABEL1         1055
#define IDC_CALLBACK_NUM_LABEL2         1056
#define IDC_CONNECT                     1057
#define IDC_RECONNECT_MSG               1058
#define IDC_MAIN_RESET_PASSWORD         1059
#define IDC_MAIN_CUSTOM                 1060
#define IDC_ABOUT_FRAME                 1061
#define IDC_ABOUT_BITMAP                1062
#define IDC_ABOUT_VERSION               1063
#define IDC_ABOUT_WARNING               1064
#define IDC_ABOUT_CM_STATIC             1065
#define IDC_ABOUT_VERSION_STATIC        1066
#define IDC_ABOUT_COPYRIGHT_STATIC      1067
#define IDC_ABOUT_SHOCKWAVE_STATIC      1068
#define IDC_CONNSTAT_STATIC_CALL_DURATION   1069
#define IDC_CONNSTAT_STATIC_CONNECT_SPEED   1070
#define IDC_CONNSTAT_STATIC_BYTES_RECEIVED  1071
#define IDC_CONNSTAT_STATIC_BYTES_SENT      1072
//                                      1073
//                                      1074
//                                      1075
//                                      1076
//                                      1077
//                                      1078
//                                      1079
//                                      1080
//                                      1081
#define IDC_RETRY_DOMAIN                1082
#define IDC_RETRY_PASSWORD              1083
#define IDC_RETRY_USERNAME              1084
#define IDC_RETRY_REMEMBER              1085
#define IDC_RETRY_PASSWORD_STATIC       1086
#define IDC_RETRY_USERNAME_STATIC       1087
#define IDC_RETRY_DOMAIN_STATIC         1088
#define IDC_RETRY_EXPLAIN               1089
//                                      1090
//                                      1091
#define IDS_BAD_CON_FILE                1092
#define IDS_WRONG_WINDOWS_VER16         1093
#define IDS_WRONG_WINDOWS_VER32         1094
#define IDS_DNSERR_CAPTION              1095
#define IDS_DNSERR_MESSAGE              1096
//                                      1097
#define IDS_CAPTION                     1098
#define IDS_IPNOMEM                     1099
#define IDS_IPBAD_FIELD_VALUE           1100
#define IDS_ADVANCED_BAD_IRQ            1101
#define IDS_ADVANCED_BAD_HEXCHR         1102
#define IDS_COMM_NOT_AVAILABLE          1103
#define IDS_MODEMS_PROPERTIES           1104

#define IDS_NO_MODEM_INSTALLED          1105
#define IDS_INSTALL_MODEM               1106
#define IDS_CHANGE_MODEM                1107

#define IDS_CANCEL_PLAYBACK             1108
#define IDS_TERMINAL_CAPTION            1109
#define IDS_DOMAIN_BAD_IP               1110
#define IDS_SHIVAENV_NOT_SET            1111
//                                      1112
#define IDS_IP_UNKNOWN                  1113
#define IDS_IP_ADDRESS                  1114
#define IDS_SHIVAENV_NOT_SET_2          1115
#define IDC_PHONE_NUMBER                1116
#define IDC_GENERAL_START_IE            1117
#define IDC_MODEM_TYPE                  1118
#define IDC_MODEM_CHANGE_MODEM          1119
#define IDC_MODEM_PORT                  1120
#define IDC_MODEM_SPEAKER_BOX           1121
#define IDC_MODEM_MAXSPEED              1122
#define IDC_MODEM_ADVANCED              1123
#define IDC_ADVANCED_IRQ                1124
#define IDC_ADVANCED_IOADR              1125
#define IDC_DOMAIN_NAME                 1126
#define IDC_DOMAIN_DNS                  1127
#define IDC_DOMAIN_BACKUP               1128
#define IDC_MODEM_OFF                   1130
#define IDC_DOMAIN_STATIC_IP            1131
#define IDC_MODEM_HIGH                  1132
//                                      1133
//                                      1134
//                                      1135
//                                      1136
//                                      1137
//                                      1138
//                                      1139
#define IDC_DOMAIN_IP_DYNAMIC           1140
#define IDC_DOMAIN_IP_STATIC            1141
#define IDC_DOMAIN_DNS_DYNAMIC          1142
#define IDC_DOMAIN_DNS_STATIC           1143
#define IDC_DOMAIN_STATIC_IP_LBL        1144
#define IDC_DOMAIN_DNS_PRI_LBL          1145
#define IDC_DOMAIN_DNS_SEC_LBL          1146
#define IDC_COUNTRY_COMBO               1147
#define IDC_CONNECT_LINE_IP             1148
// End IEDIAL defines

#define IDC_GENERAL_EDITNUMBER          1244
#define IDC_GENERAL_PHONENUMBERS_GROUPBOX 1245
#define IDC_STATIC_MINUTES              1246
#define IDC_STATIC_TIMES                1247
#define IDC_GENERAL_PRIMARYDESC_DISPLAY 1248
#define IDC_GENERAL_BACKUPDESC_DISPLAY  1249
#define IDC_GENERAL_P1_STATIC           1250
#define IDC_GENERAL_P2_STATIC           1251
#define IDC_GENERAL_PRIMARY_EDIT        1252
#define IDC_GENERAL_BACKUP_EDIT         1253
#define IDC_GENERAL_PRIMARYPB_BUTTON    1254
#define IDC_GENERAL_BACKUPPB_BUTTON     1255
#define IDC_GENERAL_TAPI_BUTTON         1256
#define IDC_GENERAL_MODEM_COMBO         1257
#define IDC_GENERAL_UDR1_CHECKBOX       1258
#define IDC_GENERAL_UDR2_CHECKBOX       1259
#define IDC_INET_USERNAME_STATIC        1261
#define IDC_INET_PASSWORD_STATIC        1262
#define IDC_CONNECT_USING               1263
#define IDC_INET_USERNAME               1264
#define IDC_INET_PASSWORD               1265
//                                      1266
#define IDC_INET_REMEMBER               1267
#define IDC_OPTIONS_IDLETIME_LIST       1269
#define IDC_OPTIONS_REDIALCOUNT_SPIN    1270
#define IDC_OPTIONS_REDIALCOUNT_EDIT    1271
#define IDC_MAIN_NOPROMPT_CHECKBOX      1272
#define IDC_OPTIONS_SECURITY            1275
#define IDC_OPTIONS_START_IE            1276
#define IDC_OPTIONS_MINIMIZE            1277    
#define IDC_MAIN_NOPASSWORD_CHECKBOX    1278
#define IDC_OPTIONS_LOGGING             1279
#define IDC_OPTIONS_CLEAR_LOG           1280    
#define IDC_OPTIONS_VIEW_LOG            1281    
#define IDC_LOGGING_GROUPBOX            1282
//
#define IDC_VPN_MSG                     1285
#define IDC_VPN_SEL_COMBO               1286

#ifndef IDC_STATIC
#define IDC_STATIC                      -1
#endif

#define ICONNMGR_BMP_CLASS      TEXT("IConnMgr Bitmap Class")
#define ICONNMGR_STATUS_CLASS   TEXT("IConnMgr Status Class")

// Access Point specific values
#define IDD_MAIN_ALL_USERDATA_FAV       1290
#define IDC_MAIN_ACCESSPOINT_STATIC     1291
#define IDC_MAIN_ACCESSPOINT_COMBO      1292

#define IDD_MAIN_NO_USERDATA_FAV        1293
#define IDD_MAIN_UID_ONLY_FAV           1294
#define IDD_MAIN_UID_AND_PWD_FAV        1295
#define IDD_MAIN_UID_AND_DMN_FAV        1296
#define IDD_MAIN_PWD_ONLY_FAV           1297
#define IDD_MAIN_PWD_AND_DMN_FAV        1298
#define IDD_MAIN_DMN_ONLY_FAV           1299


#define IDC_GENERAL_ACCESSPOINT_STATIC  1302
#define IDC_GENERAL_NEWAP_BUTTON        1303
#define IDC_GENERAL_DELETEAP_BUTTON     1304
#define IDC_SETTINGS                    1305
#define IDC_GENERAL_ACCESSPOINT_COMBO   1306

#define IDD_NEW_ACCESSPOINT             1307
#define IDC_NEWAP_NAME_EDIT             1308

// Dialogs with global credentials options _GCOPT
#define IDD_MAIN_ALL_USERDATA_FAV_GCOPT 1309
#define IDD_MAIN_UID_AND_PWD_FAV_GCOPT  1310
#define IDD_MAIN_PWD_ONLY_FAV_GCOPT     1311
#define IDD_MAIN_PWD_AND_DMN_FAV_GCOPT  1312
#define IDD_MAIN_ALL_USERDATA_GCOPT     1313
#define IDD_MAIN_UID_AND_PWD_GCOPT      1314
#define IDD_MAIN_PWD_ONLY_GCOPT         1315
#define IDD_MAIN_PWD_AND_DMN_GCOPT      1316

#define IDC_OPT_CREDS_SINGLE_USER       1317
#define IDC_OPT_CREDS_ALL_USER          1318

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        156
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1319
#define _APS_NEXT_SYMED_VALUE           105
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmdial\userinfo.cpp ===
//+----------------------------------------------------------------------------
//
// File:     userinfo.cpp     
//
// Module:   CMDIAL32.DLL
//
// Synopsis: This module contains the code that handles getting/saving user info.
//
// Copyright (c) 1996-1999 Microsoft Corporation
//
// Author:   henryt     created         02/??/98
//           quintinb   created Header  08/16/99
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"
#include "cmuufns.h"

#include "pwd_str.h"
#include "userinfo_str.h"
#include "conact_str.h"

///////////////////////////////////////////////////////////////////////////////////
// define's
///////////////////////////////////////////////////////////////////////////////////

//
// CM_MAX_PWD - Maximum possible size of password dataencrypted or otherwise.
//              Includes inbound buffer size + room for encryption expansion.
//

const DWORD CM_MAX_PWD = PWLEN * 3; // 2.73 would be enough

//
// Define this if you want to test userinfo upgrade! You should also delete the key
// HKEY_CURRENT_USER\Software\Microsoft\Connection Manager\UserInfo\<Service Name>
//
//#define TEST_USERINFO_UPGRADE 1

#define CACHE_KEY_LEN 80 // Don't change unless you've read every comment regarding it

//
// Suffix for CacheEntry name used on Legacy and W9x. Note: the space is not a typo

const TCHAR* const c_pszCacheEntryNameSuffix = TEXT(" (Connection Manager)"); 

///////////////////////////////////////////////////////////////////////////////////
// typedef's
///////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////
// func prototypes
///////////////////////////////////////////////////////////////////////////////////

////////////////



BOOL WriteDataToReg(
    LPCTSTR pszKey, 
    UINT uiDataID, 
    DWORD dwType, 
    CONST BYTE *lpData, 
    DWORD cbData,
    BOOL fAllUser);


BOOL ReadDataFromReg(
    LPCTSTR pszKey, 
    UINT uiDataID, 
    LPDWORD lpdwType, 
    BYTE *lpData, 
    LPDWORD lpcbData,
    BOOL fAllUser);

LPBYTE GetDataFromReg(
    LPCTSTR pszKey, 
    UINT uiDataID, 
    DWORD dwType, 
    DWORD dwSize,
    BOOL fAllUser);

BOOL DeleteDataFromReg(
    LPCTSTR pszKey, 
    UINT uiDataID,
    BOOL fAllUser);

BOOL DeleteUserInfoFromReg(
    ArgsStruct  *pArgs,
    UINT        uiEntry);

BOOL ReadPasswordFromCmp(
    ArgsStruct  *pArgs,
    UINT        uiEntry,
    LPTSTR      *ppszPassword);

LPCTSTR TranslateUserDataID(
    UINT uiDataID);

BOOL ReadUserInfoFromCmp(
    ArgsStruct  *pArgs,
    UINT        uiEntry,
    PVOID       *ppvData);

BOOL DeleteUserInfoFromCmp(
    ArgsStruct  *pArgs,
    UINT        uiEntry);

DWORD RasSetCredsWrapper(
    ArgsStruct *pArgs, 
    LPCTSTR pszPhoneBook, 
    DWORD dwMask, 
    LPCTSTR pszData);

int WriteUserInfoToRas(
    ArgsStruct  *pArgs,
    UINT        uiDataID,
    PVOID       pvData);

int DeleteUserInfoFromRas(
    ArgsStruct  *pArgs,
    UINT        uiEntry);

DWORD RasGetCredsWrapper(
    ArgsStruct *pArgs,
    LPCTSTR pszPhoneBook,
    DWORD dwMask,
    PVOID *ppvData);

BOOL ReadUserInfoFromRas(
    ArgsStruct  *pArgs,
    UINT        uiEntry,
    PVOID       *ppvData);

///////////////

BOOL ReadStringFromCache(
    ArgsStruct  *pArgs,
    LPTSTR      pszEntryName,
    LPTSTR      *ppszStr
);

BOOL DeleteStringFromCache(
    ArgsStruct  *pArgs,
    LPTSTR      pszEntryName
);

LPTSTR GetLegacyKeyName(ArgsStruct *pArgs);

LPTSTR EncryptPassword(
    ArgsStruct *pArgs, 
    LPCTSTR pszPassword, 
    LPDWORD lpdwBufSize, 
    LPDWORD lpdwCryptType,
    BOOL fReg,
    LPSTR pszSubKey);

LPBYTE DecryptPassword(
    ArgsStruct *pArgs, 
    LPBYTE pszEncryptedData, 
    DWORD dwEncryptionType,
    DWORD dwEncryptedBytes,
    BOOL /*fReg*/,
    LPSTR pszSubKey);

LPTSTR BuildUserInfoSubKey(
    LPCTSTR pszServiceKey, 
    BOOL fAllUser);

///////////////////////////////////////////////////////////////////////////////////
// Implementation
///////////////////////////////////////////////////////////////////////////////////

#ifdef TEST_USERINFO_UPGRADE

//+---------------------------------------------------------------------------
//
//  Function:   WriteStringToCache
//
//  Synopsis:   Write a null terminated password string to cache.
//
//  Arguments:  pArgs           ptr to ArgsStruct
//              pszEntryName    name to identify the cache entry
//              pszStr          the string
//
//  Returns:    BOOL    TRUE = success, FALSE = failure
//
//----------------------------------------------------------------------------
BOOL WriteStringToCache(
    ArgsStruct  *pArgs,
    LPTSTR      pszEntryName,
    LPTSTR      pszStr)
{
    MYDBGASSERT(pArgs);
    MYDBGASSERT(pszEntryName && *pszEntryName);
    MYDBGASSERT(pszStr && *pszStr);
    
    DWORD dwRes = ERROR_SUCCESS;

    //
    // In the legacy case, we use mpr.dll for caching user data on W9x.
    // On NT we use the Local Security Authority (LSA)
    //

    if (OS_NT)
    {    
        if (InitLsa(pArgs)) 
        {
            if (!(*ppszStr = (LPTSTR)CmMalloc(dwBufSize)))
            {
                return FALSE;
            }
           
            dwRes = LSA_WriteString(pArgs, pszEntryName, pszStr);
            DeInitLsa(pArgs);
        }
        else
        {
            dwRes = GetLastError();
        }
    }
    else
    {
        //
        // for Windows95
        //
        HINSTANCE hInst = NULL;
        WORD (WINAPI *pfnFunc)(LPSTR,WORD,LPSTR,WORD,BYTE,UINT) = NULL;
    
        //
        // Load MPR for system password cache support 
        //

        MYVERIFY(hInst = LoadLibraryExA("mpr.dll", NULL, 0));
        
        if (hInst) 
        {
            //
            // Get function ptr for WNetCachePassword API and cache the password
            //

            MYVERIFY(pfnFunc = (WORD (WINAPI *)(LPSTR,WORD,LPSTR,WORD,BYTE,UINT)) 
                GetProcAddress(hInst, "WNetCachePassword"));
            
            if (pfnFunc) 
            {
                //
                //  Convert the EntryName and Password Strings to Ansi
                //

                LPSTR pszAnsiEntryName = WzToSzWithAlloc(pszEntryName);
                LPSTR pszAnsiStr = WzToSzWithAlloc(pszStr);

                if (pszAnsiStr && pszAnsiEntryName)
                {
                    //
                    // Store the password
                    //

                    dwRes = pfnFunc(pszAnsiEntryName,
                                    (WORD)lstrlenA(pszAnsiEntryName),
                                    pszAnsiStr,
                                    (WORD)lstrlenA(pszAnsiStr),
                                    CACHE_KEY_LEN,
                                    0);                
                }
                else
                {
                    dwRes = ERROR_NOT_ENOUGH_MEMORY;
                }

                CmFree(pszAnsiStr);
                CmFree(pszAnsiEntryName);
            }
            else
            {
                dwRes = GetLastError();
            }

            FreeLibrary(hInst);
        }
        else
        {
            dwRes = GetLastError();
        }
    }

#ifdef DEBUG
    if (dwRes)
    {
        CMTRACE1(TEXT("WriteStringToCache() failed, err=%u."), dwRes);
    }
#endif

    return (ERROR_SUCCESS == dwRes);
}

#endif //TEST_USERINFO_UPGRADE



//+----------------------------------------------------------------------------
//
// Function:  BuildUserInfoSubKey
//
// Synopsis:  Constructs the appropriate subkey for UserInfo based on the service
//            name key and the user mode of the profile.
//
// Arguments: LPCTSTR pszServiceKey - The service name key
//            BOOL fAllUser         - Flag indicating that profile is All-User
//
// Returns:   LPTSTR - Ptr to allocated buffer containing subkey or NULL on failure.
//
// History:   nickball    Created    8/14/98
//
//+----------------------------------------------------------------------------
LPTSTR BuildUserInfoSubKey(LPCTSTR pszServiceKey, BOOL fAllUser)
{
    MYDBGASSERT(pszServiceKey);

    if (NULL == pszServiceKey)
    {
        return NULL;
    }

    //
    // Use the appropriate base key
    // 
    
    LPTSTR pszSubKey = NULL;

    if (fAllUser)
    {
        pszSubKey = CmStrCpyAlloc(c_pszRegCmUserInfo);       
    }
    else
    {
        pszSubKey = CmStrCpyAlloc(c_pszRegCmSingleUserInfo);          
    }

    MYDBGASSERT(pszSubKey);

    //
    // Append profile service name
    //

    if (pszSubKey && *pszSubKey)
    {
        pszSubKey = CmStrCatAlloc(&pszSubKey, pszServiceKey);  
        MYDBGASSERT(pszSubKey);

        return pszSubKey;
    }

    CmFree(pszSubKey);

    return NULL;
}

//+----------------------------------------------------------------------------
//
// Function:  BuildICSDataInfoSubKey
//
// Synopsis:  Constructs the appropriate subkey for ICS UserInfo based on the service
//            name key.
//
// Arguments: LPCTSTR pszServiceKey - The service name key
//
// Returns:   LPTSTR - Ptr to allocated buffer containing subkey or NULL on failure.
//
// History:   03/30/2001    tomkel      Created
//
//+----------------------------------------------------------------------------
LPTSTR BuildICSDataInfoSubKey(LPCTSTR pszServiceKey)
{
    MYDBGASSERT(pszServiceKey);

    if (NULL == pszServiceKey)
    {
        return NULL;
    }

    //
    // Use the appropriate base key
    // 
    
    LPTSTR pszSubKey = NULL;

    pszSubKey = CmStrCpyAlloc(c_pszRegCmRoot);       

    MYDBGASSERT(pszSubKey);

    //
    // Append profile service name
    //

    if (pszSubKey && *pszSubKey)
    {
        pszSubKey = CmStrCatAlloc(&pszSubKey, pszServiceKey);  
       
        MYDBGASSERT(pszSubKey);

        if (pszSubKey)
        {
            CmStrCatAlloc(&pszSubKey, TEXT("\\"));
            if (pszSubKey)
            {
                CmStrCatAlloc(&pszSubKey, c_pszCmRegKeyICSDataKey);
            }
        }

        return pszSubKey;
    }

    CmFree(pszSubKey);

    return NULL;
}



//+----------------------------------------------------------------------------
//
// Function:  dwGetWNetCachedPassword
//
// Synopsis:  Wrapper to encapsulate linking to MPR.DLL and calling GetWNetCac
//            hedPassword.
//
// Arguments: LPSTR pszEntryName - The names of the key used to identify the password.
//            LPSTR* ppszStr - The buffer to receive the retrieved password.
//            WORD* pwSizeOfStr - The size of the input buffer. Also receives 
//                                of the # of chars retrieved.
//
// Returns:   DWORD - Windows error code.
//
// History:   nickball    Created Header    6/17/99
//
//+----------------------------------------------------------------------------

DWORD dwGetWNetCachedPassword(LPSTR pszEntryName, LPSTR* ppszStr, WORD* pwSizeOfStr)
{
    MYDBGASSERT(OS_W9X);

    DWORD dwRes = ERROR_SUCCESS;
    WORD (WINAPI *pfnFunc)(LPSTR,WORD,LPSTR,LPWORD,BYTE) = NULL;
    HINSTANCE hInst = NULL;

    //
    // Load MPR for system password cache support 
    //

    MYVERIFY(hInst = LoadLibraryExA("mpr.dll", NULL, 0));
    
    if (hInst) 
    {
        //
        // Get function ptr for WNetGetCachedPassword API and retrieve the string
        //

        MYVERIFY(pfnFunc = (WORD (WINAPI *)(LPSTR,WORD,LPSTR,LPWORD,BYTE)) 
            GetProcAddress(hInst, "WNetGetCachedPassword"));

        //
        // Read the cache data
        //

        if (pfnFunc) 
        {
            //
            // NOTE: Final param must be CACHE_KEY_LEN (80), no docs to indicate 
            // exact usage of API but retrieval is tied to the value used when
            // storing the pwd. Thus we hard code to CACHE_KEY_LEN because this 
            // is the value that was used by the original version that stored 
            // the password in the 9X cache. The receiving buffer size is 
            // retained at 256 to minimize delta from latest shipping version. 
            //
            // NT# 355459 - nickball - 6/17/99
            //            
            
            dwRes = pfnFunc(pszEntryName, (WORD)lstrlenA(pszEntryName),
                            *ppszStr, pwSizeOfStr, CACHE_KEY_LEN);
        }
        else
        {
            dwRes = GetLastError();
        }
    }
    else
    {
        dwRes = GetLastError();
    }

    if (NULL != hInst)                      
    {
        FreeLibrary(hInst);    
    }

    return (dwRes);
}

//+---------------------------------------------------------------------------
//
//  Function:   ReadStringFromCache
//
//  Synopsis:   Read a null terminated string from cache.
//
//  Arguments:  pArgs           ptr to ArgsStruct
//              pszEntryName    name to identify the cache entry
//              ppszStr         ptr to the ptr of the buffer.
//
//  Returns:    BOOL    TRUE = success, FALSE = failure
//
//----------------------------------------------------------------------------
BOOL ReadStringFromCache(
    ArgsStruct  *pArgs,
    LPTSTR      pszEntryName,
    LPTSTR      *ppszStr
)
{
    DWORD   dwRes = ERROR_SUCCESS;
    
    //
    // Alloc buffer - the buffer is uuencoded.  See UserInfoToString().
    //
    
    WORD wBufSize = 256; // arbitrary, we used to use 80 on W95 

    //
    // On NT, we use the Local Security Authority (LSA) services for reading
    // the string in the legacy case. On Win9x, we uses mpr.dll. 
    // Note: wBufSize is used as an in\out param, can be modified below.
    //

    if (OS_NT) 
    {
        if (InitLsa(pArgs))
        {
            if (!(*ppszStr = (LPTSTR)CmMalloc(wBufSize)))
            {
                return FALSE;
            }

            dwRes = LSA_ReadString(pArgs, pszEntryName, *ppszStr, wBufSize);
            DeInitLsa(pArgs);
        }
        else
        {
            dwRes = GetLastError();
        }
    }
    else
    {
        //
        // for Windows95
        //

        LPSTR pszAnsiStr = (LPSTR)CmMalloc(wBufSize);
        LPSTR pszAnsiEntryName = WzToSzWithAlloc(pszEntryName);
        
        if (pszAnsiStr && pszAnsiEntryName)
        {
            dwRes = dwGetWNetCachedPassword(pszAnsiEntryName, &pszAnsiStr, &wBufSize);

            if (ERROR_SUCCESS == dwRes)
            {
                *ppszStr = SzToWzWithAlloc(pszAnsiStr);
                if (NULL == *ppszStr)
                {
                    dwRes = ERROR_NOT_ENOUGH_MEMORY;
                }
            }
        }

        CmFree (pszAnsiStr);
        CmFree (pszAnsiEntryName);
    }

    if (dwRes)
    {
        CmFree(*ppszStr);
        *ppszStr = NULL;
        CMTRACE1(TEXT("ReadStringFromCache() failed, err=%u."), dwRes);
    }

    return (ERROR_SUCCESS == dwRes);
}

//+---------------------------------------------------------------------------
//
//  Function:   DeleteStringFromCache
//
//  Synopsis:   Delete the string from cache.
//
//  Arguments:  pArgs           ptr to ArgsStruct
//              pszEntryName    name to identify the cache entry
//
//  Returns:    BOOL    TRUE = success, FALSE = failure
//
//----------------------------------------------------------------------------
BOOL DeleteStringFromCache(
    ArgsStruct  *pArgs,
    LPTSTR      pszEntryName
)
{
    DWORD   dwRes;

    //
    // on NT, we use the Local Security Authority (LSA) services for storing
    // the string.  On Win95, we use mpr.dll.
    //
    if (OS_NT) 
    {
        if (InitLsa(pArgs)) 
        {
            dwRes = LSA_WriteString(pArgs, pszEntryName, NULL);
            DeInitLsa(pArgs);
        }
        else
        {
            dwRes = GetLastError();
        }
    }
    else
    {
        //
        // for Windows95
        //
        HINSTANCE   hInst = NULL;
        WORD (WINAPI *pfnFunc)(LPSTR,WORD,BYTE) = NULL;

        // Load MPR for system password cache support 
        
        MYVERIFY(hInst = LoadLibraryExA("mpr.dll", NULL, 0));
        
        // Get function ptr for WNetRemoveCachedPassword API and remove the string
        
        if (!hInst) 
        {
            return FALSE;
        }

        MYVERIFY(pfnFunc = (WORD (WINAPI *)(LPSTR,WORD,BYTE)) 
            GetProcAddress(hInst, "WNetRemoveCachedPassword"));

        if (!pfnFunc) 
        {
            FreeLibrary(hInst);
            return FALSE;
        }
       
        LPSTR pszAnsiEntryName = WzToSzWithAlloc(pszEntryName);
        
        if (pszAnsiEntryName)
        {
            dwRes = pfnFunc(pszAnsiEntryName, (WORD)lstrlenA(pszAnsiEntryName), CACHE_KEY_LEN);
        }
        else
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
        }

        CmFree (pszAnsiEntryName);

        FreeLibrary(hInst);
    }

#ifdef DEBUG
    if (dwRes)
    {
        CMTRACE1(TEXT("DeleteStringFromCache() LSA_WriteString/WNetRemoveCachedPassword() failed, err=%u."), dwRes);
    }
#endif

    return (ERROR_SUCCESS == dwRes);
}

//+---------------------------------------------------------------------------
//
//  Function:   RasSetCredsWrapper
//
//  Synopsis:   Wrapper to call RasSetCredential.  This function stores the
//              given string in the appropriate field of a RASCREDENTIALS struct
//              (based on the value in dwMask) and calls RasSetCredentials.
//               
//
//  Arguments:  pArgs           ptr to ArgsStruct
//              pszPhoneBook    Full path to the phonebook file, or NULL for 
//                              the default all user pbk
//              dwMask          dwMask value to set in the RASCREDENTIALS
//                              struct.  Currently must be one of RASCM_UserName, 
//                              RASCM_Domain, or RASCM_Password.
//              pszData         string data to set
//
//  Returns:    DWORD   ERROR_SUCCESS if successful, a windows error code otherwise
//
//----------------------------------------------------------------------------
DWORD RasSetCredsWrapper(
    ArgsStruct *pArgs,
    LPCTSTR pszPhoneBook,
    DWORD dwMask,
    LPCTSTR pszData
)
{
    DWORD dwRet = ERROR_INVALID_PARAMETER;
    BOOL fSavePassword = TRUE;

    MYDBGASSERT(pArgs && pArgs->rlsRasLink.pfnSetCredentials);
    MYDBGASSERT(pszData);
    MYDBGASSERT((RASCM_UserName == dwMask) || (RASCM_Domain == dwMask) || (RASCM_Password == dwMask));

    if (pArgs && pszData && pArgs->rlsRasLink.pfnSetCredentials)
    {
        LPTSTR pszConnectoid = GetRasConnectoidName(pArgs, pArgs->piniService, FALSE);

        if (pszConnectoid)
        {
            RASCREDENTIALS RasCredentials = {0};
            RasCredentials.dwSize = sizeof(RasCredentials);
            
            if (CM_CREDS_GLOBAL == pArgs->dwCurrentCredentialType)
            {
                RasCredentials.dwMask = dwMask | RASCM_DefaultCreds; 
            }
            else
            {
                RasCredentials.dwMask = dwMask; 
            }
            
            BOOL bClearPassword = FALSE;

            if (RASCM_UserName == dwMask)
            {
                lstrcpyU(RasCredentials.szUserName, pszData);
            }
            else if (RASCM_Domain == dwMask)
            {
                lstrcpyU(RasCredentials.szDomain, pszData);
            }
            else if (RASCM_Password == dwMask)
            {
                if (0 == lstrcmpU(c_pszSavedPasswordToken, pszData))
                {
                    //
                    // We have 16 *'s. This password is from the RAS cred store, 
                    // so we don't want to save the 16 *'s 
                    //
                    fSavePassword = FALSE;
                }
                else
                {
                    lstrcpyU(RasCredentials.szPassword, pszData);
                    bClearPassword = (TEXT('\0') == pszData[0]);
                }
            }
            else
            {
                CmFree(pszConnectoid);
                return ERROR_INVALID_PARAMETER;
            }

            if (fSavePassword)
            {
                dwRet = pArgs->rlsRasLink.pfnSetCredentials(pszPhoneBook, pszConnectoid, &RasCredentials, bClearPassword);

                if (ERROR_CANNOT_FIND_PHONEBOOK_ENTRY == dwRet)
                {
                    //
                    //  Then the phonebook entry doesn't exist yet, lets create it.
                    //
                    LPRASENTRY pRasEntry = (LPRASENTRY)CmMalloc(sizeof(RASENTRY));

                    if (pRasEntry && pArgs->rlsRasLink.pfnSetEntryProperties)
                    {
                        pRasEntry->dwSize = sizeof(RASENTRY);
                        dwRet = pArgs->rlsRasLink.pfnSetEntryProperties(pszPhoneBook, pszConnectoid, pRasEntry, pRasEntry->dwSize, NULL, 0);

                        //
                        //  Lets try to set the credentials one more time ...
                        //
                        if (ERROR_SUCCESS == dwRet)
                        {
                            dwRet = pArgs->rlsRasLink.pfnSetCredentials(pszPhoneBook, pszConnectoid, &RasCredentials, bClearPassword);
                        }

                        CmFree(pRasEntry);
                    }
                }
            }
            CmWipePassword(RasCredentials.szPassword);
            CmFree(pszConnectoid);
        }
    }

    return dwRet;
}


//+---------------------------------------------------------------------------
//
//  Function:   WriteUserInfoToRas
//
//  Synopsis:   Write a userinfo data to ras credential storage
//
//  Arguments:  pArgs           ptr to ArgsStruct
//              uiDataID        the resource ID associated with the data
//              pvData          userinfo data
//
//  Returns:    int    TRUE = success, FALSE = failure, returns -1 if RAS
//                     doesn't cache this piece of data and it should be put
//                     in the registry instead.
//
//----------------------------------------------------------------------------
int WriteUserInfoToRas(
    ArgsStruct  *pArgs,
    UINT        uiDataID,
    PVOID       pvData)
{
    int iReturn = -1;

    if (OS_NT5 && pArgs && pArgs->bUseRasCredStore)
    {
        DWORD dwMask;
        LPTSTR pszPhoneBook = NULL;

        switch (uiDataID)
        {
            case UD_ID_USERNAME:
                dwMask = RASCM_UserName;
                iReturn = (ERROR_SUCCESS == RasSetCredsWrapper(pArgs, pArgs->pszRasPbk, dwMask, (LPCTSTR)pvData));
                break;

            case UD_ID_PASSWORD:
                dwMask = RASCM_Password;
                iReturn = (ERROR_SUCCESS == RasSetCredsWrapper(pArgs, pArgs->pszRasPbk, dwMask, (LPCTSTR)pvData));
                MYDBGASSERT(iReturn);

                //
                //  Note that if we are using the same username then we want to write the password to both the
                //  password and the InetPassword storage.  This is because we don't actually have a password, just
                //  16 *'s.  This tells RAS to look in its internal store for the password.  The trouble is that if
                //  we don't cache the real password when we hand RAS the 16 *'s, it looks and finds a NULL password.
                //  Thus we keep both passwords the same and this avoids that problem.
                //
                if (pArgs->piniService->GPPB(c_pszCmSection, c_pszCmEntryUseSameUserName))
                {
                    pszPhoneBook = CreateRasPrivatePbk(pArgs);

                    if (pszPhoneBook)
                    {
                        iReturn = (ERROR_SUCCESS == RasSetCredsWrapper(pArgs, pszPhoneBook, dwMask, (LPCTSTR)pvData));
                        CmFree(pszPhoneBook);
                    }                
                }

                break;

            case UD_ID_DOMAIN:
                dwMask = RASCM_Domain;
                iReturn = (ERROR_SUCCESS == RasSetCredsWrapper(pArgs, pArgs->pszRasPbk, dwMask, (LPCTSTR)pvData));
                break;

            case UD_ID_INET_PASSWORD:
                dwMask = RASCM_Password;
                pszPhoneBook = CreateRasPrivatePbk(pArgs);

                if (pszPhoneBook)
                {
                    iReturn = (ERROR_SUCCESS == RasSetCredsWrapper(pArgs, pszPhoneBook, dwMask, (LPCTSTR)pvData));
                    CmFree(pszPhoneBook);
                }
                break;

            case UD_ID_INET_USERNAME:
                dwMask = RASCM_UserName;
                pszPhoneBook = CreateRasPrivatePbk(pArgs);

                if (pszPhoneBook)
                {
                    iReturn = (ERROR_SUCCESS == RasSetCredsWrapper(pArgs, pszPhoneBook, dwMask, (LPCTSTR)pvData));
                    CmFree(pszPhoneBook);
                }
                break;

            default:
                break;
        }
    }

    if ((0 != iReturn) && (-1 != iReturn))
    {
        if (CM_CREDS_GLOBAL == pArgs->dwCurrentCredentialType)
        {
            CMTRACE1(TEXT("WriteUserInfoToRas() - %s saved to the Global RAS Credential store"), TranslateUserDataID(uiDataID));
        }
        else
        {
            CMTRACE1(TEXT("WriteUserInfoToRas() - %s saved to the User RAS Credential store"), TranslateUserDataID(uiDataID));
        }
    }

    return iReturn;
}


//+---------------------------------------------------------------------------
//
//  Function:   WriteUserInfoToReg
//
//  Synopsis:   Write a userinfo data to the registry.
//
//  Arguments:  pArgs           ptr to ArgsStruct
//              uiDataID        the resource ID associated with the data
//              pvData          userinfo data
//
//  Returns:    BOOL    TRUE = success, FALSE = failure
//
//----------------------------------------------------------------------------
BOOL WriteUserInfoToReg(
    ArgsStruct  *pArgs,
    UINT        uiDataID,
    PVOID       pvData)
{
    MYDBGASSERT(pArgs);    
    MYDBGASSERT(pvData);    

    BOOL fRet = FALSE;
    UINT uiID = uiDataID; // can be changed in switch
    BYTE *lpData;

    if (NULL == pArgs || NULL == pvData)
    {
        return FALSE;
    }

    //
    // Determine Reg params based upon uiDataID
    //

    switch (uiID)
    {
        case UD_ID_USERNAME:
        case UD_ID_INET_USERNAME:
        case UD_ID_DOMAIN:
        case UD_ID_CURRENTACCESSPOINT:
        {    
            //
            // Store as strings
            //
                      
            DWORD dwSize = (lstrlenU((LPTSTR)pvData) + 1) * sizeof(TCHAR);            
            
            MYDBGASSERT(dwSize <= (UNLEN + sizeof(TCHAR))); // Make sure size is reasonable

            lpData = (BYTE *) pvData;

            fRet = WriteDataToReg(pArgs->szServiceName, uiID, REG_SZ, lpData, dwSize, pArgs->fAllUser);                
            break;
        }

        case UD_ID_PASSWORD:
        case UD_ID_INET_PASSWORD:
        {
            DWORD dwBufLen = 0;
            DWORD dwCrypt = 0;
            LPTSTR pszSubKey = BuildUserInfoSubKey(pArgs->szServiceName, pArgs->fAllUser);
            
            LPSTR pszAnsiSubKey = WzToSzWithAlloc(pszSubKey);
            
            if (UD_ID_INET_PASSWORD == uiID)
            {
                dwCrypt |= CMSECURE_ET_USE_SECOND_RND_KEY;
            }

            //
            // Encrypt
            //
            
            LPTSTR pszEncryptedData = EncryptPassword(pArgs, (LPTSTR) pvData, &dwBufLen, &dwCrypt, TRUE, pszAnsiSubKey);
            
            //
            // Free in case we return if the function failed
            //
            CmFree(pszSubKey);
            CmFree(pszAnsiSubKey);

            if (!pszEncryptedData)
            {
                return FALSE;
            }

            MYDBGASSERT(dwBufLen <= CM_MAX_PWD); // Can't read it out otherwise
            
            //
            // Write the password and the encryption type on success
            //
        
            if (WriteDataToReg(pArgs->szServiceName, uiID, REG_BINARY, (BYTE *) pszEncryptedData, dwBufLen, pArgs->fAllUser))                
            {
                //
                // A second write for the encryption type. Written as a DWORD.
                //

                uiID = UD_ID_PCS;           
                
                //
                // Now that we're UNICODE enabled, we will always be encrypting 
                // a UNICODE string, so update the crypt type, so that it can be
                // properly decrypted.
                //
                
                dwCrypt = AnsiToUnicodePcs(dwCrypt);
                
                lpData = (BYTE *) &dwCrypt;
            
                fRet = WriteDataToReg(pArgs->szServiceName, uiID, REG_DWORD, lpData, sizeof(DWORD), pArgs->fAllUser);                
            }

            // 
            // Release the buffer before we go
            // 
            
            CmFree(pszEncryptedData);

            
            break;
        }
        
        case UD_ID_NOPROMPT:
        case UD_ID_REMEMBER_PWD:
        case UD_ID_REMEMBER_INET_PASSWORD:
        case UD_ID_ACCESSPOINTENABLED:
        {            
            //
            // Store BOOL as DWORD
            //

            DWORD dwTmp = *(LPBOOL)pvData;            
            lpData = (BYTE *) &dwTmp;

            fRet = WriteDataToReg(pArgs->szServiceName, uiID, REG_DWORD, lpData, sizeof(DWORD), pArgs->fAllUser);                
            break;
        }

        default:
            break;
    }

    MYDBGASSERT(fRet);
    return fRet;
}

//+----------------------------------------------------------------------------
//
// Function:  WriteDataToReg
//
// Synopsis:  Stores the specified data as the specifed value under the 
//            specified key under the userinfo root.
//
// Arguments: LPCTSTR pszKey - The key name (service name)
//            UINT uiDataID - The resource ID, used to name the value 
//            DWORD dwType - The registry data type
//            CONST BYTE *lpData - Ptr to the data to be stored
//            DWORD cbData - The size of the data buffer
//            BOOL fAllUser - Flag indicating that profile is All-User
//
// Returns:   BOOL - TRUE on success, otherwise FALSE
//
// History:   nickball    Created   5/21/98
//
//+----------------------------------------------------------------------------
BOOL WriteDataToReg(
    LPCTSTR pszKey, 
    UINT uiDataID, 
    DWORD dwType, 
    CONST BYTE *lpData, 
    DWORD cbData,
    BOOL fAllUser)
{
    MYDBGASSERT(pszKey && *pszKey);
    MYDBGASSERT(lpData);

    HKEY    hKeyCm;
    DWORD   dwDisposition;
    DWORD   dwRes = 1;
    LPTSTR  pszSubKey; 

    if (NULL == pszKey || !*pszKey || NULL == lpData)
    {
        return FALSE;
    }
                  
    //
    // Per-user data is always stored under HKEY_CURRENT_USER
    // Build the sub key to be opened.
    //

    pszSubKey = BuildUserInfoSubKey(pszKey, fAllUser);

    if (NULL == pszSubKey)
    {
        return FALSE;
    }
    
    //
    // Open the sub key under HKCU
    //
    
    dwRes = RegCreateKeyExU(HKEY_CURRENT_USER,
                            pszSubKey,
                            0,
                            TEXT(""),
                            REG_OPTION_NON_VOLATILE,
                            KEY_SET_VALUE,
                            NULL,
                            &hKeyCm,
                            &dwDisposition);

    //
    // If we opened the key successfully, write the value
    //
    
    if (ERROR_SUCCESS == dwRes)
    {                        
        dwRes = RegSetValueExU(hKeyCm, 
                               TranslateUserDataID(uiDataID), 
                               NULL, 
                               dwType,
                               lpData, 
                               cbData);             
#ifdef DEBUG
        if (ERROR_SUCCESS == dwRes)
        {
            CMTRACE1(TEXT("WriteDataToReg() - %s written to registry"), TranslateUserDataID(uiDataID));
        }
#endif
        
        RegCloseKey(hKeyCm);
    }

    CmFree(pszSubKey);

    return (ERROR_SUCCESS == dwRes);
}

//+----------------------------------------------------------------------------
//
// Function:  DeleteDataFromReg
//
// Synopsis:  Deletes the specified value under the specified by uiDataID
//
// Arguments: LPCTSTR pszKey - The key name (service name)
//            UINT uiDataID - The resource ID, used to name the value 
//            BOOL fAllUser - Flag indicating that profile is All-User
//
// Returns:   BOOL - TRUE on success, otherwise FALSE
//
// History:   nickball    Created   5/21/98
//
//+----------------------------------------------------------------------------
BOOL DeleteDataFromReg(
    LPCTSTR pszKey, 
    UINT uiDataID,
    BOOL fAllUser)
{
    MYDBGASSERT(pszKey && *pszKey);

    HKEY    hKeyCm;
    DWORD   dwRes = 1;
    LPTSTR  pszSubKey; 

    if (NULL == pszKey || !*pszKey)
    {
        return FALSE;
    }
                  
    //
    // Per-user data is always stored under HKEY_CURRENT_USER
    // Build the sub key to be opened.
    //

    pszSubKey = BuildUserInfoSubKey(pszKey, fAllUser);

    if (NULL == pszSubKey)
    {
        return FALSE;
    }
    
    //
    // Open the sub key under HKCU
    //

    dwRes = RegOpenKeyExU(HKEY_CURRENT_USER,
                          pszSubKey,
                          0,
                          KEY_SET_VALUE,
                          &hKeyCm);
       
    //
    // If we opened the key successfully, delete the value
    //
    
    if (ERROR_SUCCESS == dwRes)
    {                        
        dwRes = RegDeleteValueU(hKeyCm, TranslateUserDataID(uiDataID));

        //
        // Delete the key used for encrypting the passwords
        //
        if (UD_ID_PASSWORD == uiDataID)
        {
            dwRes = RegDeleteValueU(hKeyCm, c_pszCmRegKeyEncryptedPasswordKey);
        }

        if (UD_ID_INET_PASSWORD == uiDataID)
        {
            dwRes = RegDeleteValueU(hKeyCm, c_pszCmRegKeyEncryptedInternetPasswordKey);
        }

#ifdef DEBUG
        if (ERROR_SUCCESS == dwRes)
        {
            CMTRACE1(TEXT("DeleteDataFromReg() - %s removed from registry"), TranslateUserDataID(uiDataID));
        }
#endif
                
        RegCloseKey(hKeyCm);
    }

    CmFree(pszSubKey);

    return (ERROR_SUCCESS == dwRes);
}

//+----------------------------------------------------------------------------
//
// Function:  GetDataFromReg
//
// Synopsis:  Allocates a buffer for and retrieves the specifed data from the
//            registry.
//
// Arguments: LPCTSTR pszKey - The key name (service name)
//            UINT uiDataID - The resource ID, used to name the value 
//            DWORD dwType - The registry data type 
//            DWORD dwSize - Numbrt of bytes in the data buffer
//            BOOL fAllUser - Flag indicating that profile is All-User
//
// Returns:   LPBYTE - Ptr to retrieved data, NULL on error
//
// History:   nickball    Created   5/21/98
//
//+----------------------------------------------------------------------------
LPBYTE GetDataFromReg(
    LPCTSTR pszKey, 
    UINT uiDataID, 
    DWORD dwType, 
    DWORD dwSize,
    BOOL fAllUser)
{    
    MYDBGASSERT(pszKey);

    DWORD dwSizeTmp = dwSize;
    DWORD dwTypeTmp = dwType;

    if (NULL == pszKey || !*pszKey)
    {
        return NULL;
    }

    //
    // Allocate a buffer of the desired size
    //

    LPBYTE lpData = (BYTE *) CmMalloc(dwSize);

    if (NULL == lpData)
    {
        return FALSE;
    }

    //
    // Read the data from the registry
    //

    if (!ReadDataFromReg(pszKey, uiDataID, &dwTypeTmp, lpData, &dwSizeTmp, fAllUser))
    {
        CmFree(lpData);
        lpData = NULL;
    }

    return lpData;
}
//+---------------------------------------------------------------------------
//
//  Function:   ReadUserInfoFromReg
//
//  Synopsis:   Read the specified userinfo data from the registry.
//
//  Arguments:  pArgs           ptr to ArgsStruct
//              uiDataID        the resource ID associated with the data
//              ppvData         ptr to ptr to be allocated and filled
//
//  Returns:    BOOL    TRUE = success, FALSE = failure
//
//----------------------------------------------------------------------------
BOOL ReadUserInfoFromReg(
    ArgsStruct  *pArgs,
    UINT        uiDataID,
    PVOID       *ppvData)
{
    MYDBGASSERT(pArgs);    
    MYDBGASSERT(ppvData);    

    BYTE *lpData = NULL;

    if (NULL == pArgs || NULL == ppvData)
    {
        return FALSE;
    }

    //
    // Set size and type as appropriate
    //

    switch (uiDataID)
    {
        case UD_ID_USERNAME:
        case UD_ID_INET_USERNAME:
        case UD_ID_DOMAIN: 
        case UD_ID_CURRENTACCESSPOINT:
        {    
            lpData =  GetDataFromReg(pArgs->szServiceName, uiDataID, REG_SZ, (UNLEN + 1) * sizeof(TCHAR), pArgs->fAllUser);           
            
            if (lpData)
            {
                *ppvData = lpData;            
            }
            
            break;
        }

        case UD_ID_PASSWORD:
        case UD_ID_INET_PASSWORD:            
        {    
            BYTE *lpTmp = NULL;

            //
            // Get the encryption type 
            //

            lpData = GetDataFromReg(pArgs->szServiceName, UD_ID_PCS, REG_DWORD, sizeof(DWORD), pArgs->fAllUser);

            if (!lpData)
            {
                return FALSE;
            }
            
            //
            // Since we know the return value in this case is a DWORD, then cast it to DWORD pointer 
            // and get the value
            //
            DWORD dwCrypt = *((DWORD*)lpData);
            CmFree(lpData);    

            //
            // Now retrieve the encrypted password
            //
            
            lpData = GetDataFromReg(pArgs->szServiceName, uiDataID, REG_BINARY, CM_MAX_PWD, pArgs->fAllUser);

            if (!lpData)
            {
                return FALSE;
            }

            //
            // Decrypt it
            //

            DWORD dwSize = lstrlenU((LPTSTR)lpData)*sizeof(TCHAR);

            //
            // Crypt routines only know about Ansi PCS values, so convert as necessary
            //
            LPTSTR pszSubKey = BuildUserInfoSubKey(pArgs->szServiceName, pArgs->fAllUser);           
            LPSTR pszAnsiSubKey = WzToSzWithAlloc(pszSubKey);

            if (UD_ID_INET_PASSWORD == uiDataID)
            {
                dwCrypt |= CMSECURE_ET_USE_SECOND_RND_KEY;
            }

            lpTmp = DecryptPassword(pArgs, (LPBYTE)lpData, UnicodeToAnsiPcs(dwCrypt), dwSize, TRUE, pszAnsiSubKey);

            //
            // Free the buffer for the reg query
            //

            CmFree(lpData);         
            
            //
            // We're Unicode now, so if the password was encrypted 
            // as an Ansi string convert the data to a UNICODE string.
            // Otherwise, just update the supplied buffer.
            //

            if (IsAnsiPcs(dwCrypt) && lpTmp)
            {
                *ppvData = SzToWzWithAlloc((LPSTR)lpTmp);
                CmFree(lpTmp);
            }
            else
            {
                *ppvData = lpTmp;            
            }

            //
            // Assign lpData for return purposes
            //

            lpData = (BYTE*) *ppvData;  // NULL on failure
            
            CmFree(pszSubKey);
            CmFree(pszAnsiSubKey);
            break;
        }

        case UD_ID_NOPROMPT:
        case UD_ID_REMEMBER_PWD:
        case UD_ID_REMEMBER_INET_PASSWORD:
        case UD_ID_ACCESSPOINTENABLED:
        {            
            lpData =  GetDataFromReg(pArgs->szServiceName, uiDataID, REG_DWORD, sizeof(DWORD), pArgs->fAllUser);

            if (lpData)
            {
                //
                // Translate to DWORD pointer and check the value
                //

                if (*((DWORD*)lpData))
                {
                    *(BOOL *)*ppvData = TRUE;
                }
                else
                {
                    *(BOOL *)*ppvData = FALSE;
                }
            
                CmFree(lpData);            
            }
            
            break;
        }

        default:
            MYDBGASSERT(FALSE);
            return FALSE;
    }           

    return (NULL != lpData); 
}

//+----------------------------------------------------------------------------
//
// Function:  ReadDataFromReg
//
// Synopsis:  Retrieves the data from the specifed value under the 
//            specified key under the userinfo root.
//
// Arguments: LPCTSTR pszKey - The key name (service name)
//            UINT uiDataID - The resource ID, used to name the value 
//            LPDWORD lpdwType - The registry data type expected, and returned
//            CONST BYTE *lpData - Ptr to buffer for data
//            LPDWORD lpcbData - The size of the data buffer
//            BOOL fAllUser - Flag indicating that profile is All-User
//
// Returns:   BOOL - TRUE on success, otherwise FALSE
//
// History:   nickball    Created   5/21/98
//
//+----------------------------------------------------------------------------
BOOL ReadDataFromReg(
    LPCTSTR pszKey, 
    UINT uiDataID, 
    LPDWORD lpdwType, 
    BYTE *lpData, 
    LPDWORD lpcbData,
    BOOL fAllUser)
{   
    MYDBGASSERT(pszKey && *pszKey);
    MYDBGASSERT(lpData);
    MYDBGASSERT(lpcbData);
    MYDBGASSERT(lpdwType);

    HKEY    hKeyCm;
    DWORD   dwRes = 1;
    DWORD   dwTypeTmp; // the value returned by query

    LPTSTR  pszSubKey; 

    if (NULL == pszKey || !*pszKey || NULL == lpData)
    {
        return FALSE;
    }
                  
    //
    // Per-user data is always stored under HKEY_CURRENT_USER
    // Build the sub key to be opened.
    //

    pszSubKey = BuildUserInfoSubKey(pszKey, fAllUser);

    if (NULL == pszSubKey)
    {
        return FALSE;
    }
    
    //
    // Open the sub key under HKCU
    //
    
    dwRes = RegOpenKeyExU(HKEY_CURRENT_USER,
                          pszSubKey,
                          0,
                          KEY_QUERY_VALUE,
                          &hKeyCm);
    //
    // If we opened the key successfully, retrieve the value
    //
    
    if (ERROR_SUCCESS == dwRes)
    {                        
        dwRes = RegQueryValueExU(hKeyCm, 
                                 TranslateUserDataID(uiDataID),
                                 NULL,
                                 &dwTypeTmp,
                                 lpData, 
                                 lpcbData);        
        
        if (ERROR_SUCCESS == dwRes)
        {
            CMTRACE1(TEXT("ReadDataFromReg() - %s read from registry"), TranslateUserDataID(uiDataID));
            MYDBGASSERT(*lpdwType == dwTypeTmp);

            if (*lpdwType == dwTypeTmp)
            {
                *lpdwType = dwTypeTmp;
            }
        }
        
        RegCloseKey(hKeyCm);
    }

    CmFree(pszSubKey);
    
    return (ERROR_SUCCESS == dwRes && (*lpdwType == dwTypeTmp)); // sanity check that type was expected
}

//+---------------------------------------------------------------------------
//
//  Function:   DeleteUserInfoFromReg
//
//  Synopsis:   Delete userinfo data from registry
//
//  Arguments:  pArgs           ptr to ArgsStruct
//              uiEntry         cmp field entry id
//
//  Returns:    BOOL    TRUE = success, FALSE = failure
//
//----------------------------------------------------------------------------
BOOL DeleteUserInfoFromReg(
    ArgsStruct  *pArgs,
    UINT        uiEntry
)
{
    return DeleteDataFromReg(pArgs->szServiceName, uiEntry, pArgs->fAllUser);
}

//+---------------------------------------------------------------------------
//
//  Function:   DeleteUserInfoFromRas
//
//  Synopsis:   Delete userinfo data from the RAS credential cache
//
//  Arguments:  pArgs           ptr to ArgsStruct
//              uiEntry         cmp field entry id
//
//  Returns:    int    TRUE = success, FALSE = failure, -1 if RAS doesn't
//                                                         store this info
//
//----------------------------------------------------------------------------
int DeleteUserInfoFromRas(
    ArgsStruct  *pArgs,
    UINT        uiEntry
)
{
    LPTSTR pszEmpty = TEXT("");

    return WriteUserInfoToRas(pArgs, uiEntry, pszEmpty);
}

//+---------------------------------------------------------------------------
//
//  Function:   ReadPasswordFromCmp
//
//  Synopsis:   Read a null terminated password string from Cmp.
//
//  Arguments:  pArgs           ptr to ArgsStruct
//              uiEntry         cmp entry name
//              ppszPassword    ptr to ptr of the password buffer.
//
//  Returns:    BOOL    TRUE = success, FALSE = failure
//
//----------------------------------------------------------------------------
BOOL ReadPasswordFromCmp(
    ArgsStruct  *pArgs,
    UINT        uiEntry,
    LPTSTR      *ppszPassword
)
{
    MYDBGASSERT(pArgs);
    MYDBGASSERT(ppszPassword);

    if (NULL == pArgs || NULL == ppszPassword)
    {
        return FALSE;
    }

    //
    // Read in password from profile
    //
    
    BOOL fOk = FALSE;

    LPTSTR pszEncryptedData = pArgs->piniProfile->GPPS(c_pszCmSection, TranslateUserDataID(uiEntry));

    if (*pszEncryptedData)
    {
        //
        // Trim away all the spaces at both ends
        //

        CmStrTrim(pszEncryptedData);

        //
        // Get the type and decrypt
        //
        
        DWORD dwEncryptionType = (DWORD)pArgs->piniProfile->GPPI(c_pszCmSection, 
                                                       c_pszCmEntryPcs,
                                                       CMSECURE_ET_RC2);   // default   
        //
        //  Since this was saved in the CMP in Ansi form, we need to convert the characters back to
        //  Ansi form so that we can decrypt them.  We still may not be able to (if we cannot
        //  round trip the Unicode conversion for instance) but then we will fail and display a
        //  blank password.  Not the end of the world but hopefully avoidable.
        //
        
        LPSTR pszAnsiEncryptedData;
        LPSTR pszAnsiUnEncryptedData;

        pszAnsiEncryptedData = WzToSzWithAlloc(pszEncryptedData);
        
        if (NULL != pszAnsiEncryptedData)
        {
            DWORD dwSize = lstrlenA(pszAnsiEncryptedData)*sizeof(TCHAR);
            
            //
            // Here we don't need to differentiate between main password and internet password
            // because we are reading this from a file and the mask is used when reading to/from 
            // registry.
            //

            pszAnsiUnEncryptedData = (LPSTR)DecryptPassword(pArgs, 
                                                            (LPBYTE)pszAnsiEncryptedData, 
                                                            dwEncryptionType, 
                                                            dwSize, 
                                                            FALSE,
                                                            NULL);

            if (pszAnsiUnEncryptedData)
            {
                *ppszPassword = SzToWzWithAlloc(pszAnsiUnEncryptedData);

                if (NULL != *ppszPassword)
                {
                    fOk = ((BOOL)**ppszPassword);
                }
                CmWipePasswordA(pszAnsiUnEncryptedData);
                CmFree(pszAnsiUnEncryptedData);
            }    
        }

        CmFree(pszAnsiEncryptedData);
    }

    CmFree(pszEncryptedData);

    return fOk;
}

//+---------------------------------------------------------------------------
//
//  Function:   ReadUserInfoFromCmp
//
//  Synopsis:   Read a userinfo data from cmp.
// 
//  Arguments:  pArgs           ptr to ArgsStruct
//              uiEntry         the cmp file entry
//              ppvData         ptr to ptr to the data buffer.  If the userinfo
//                              is multiple byte(e.g. password), the func allocs
//                              the buffer.
//
//  Returns:    BOOL    TRUE = success, FALSE = failure
//
//----------------------------------------------------------------------------
BOOL ReadUserInfoFromCmp(
    ArgsStruct  *pArgs,
    UINT        uiEntry,
    PVOID       *ppvData
)
{   
    switch (uiEntry)
    {
        case UD_ID_USERNAME:
        case UD_ID_INET_USERNAME:
        case UD_ID_DOMAIN:
            *ppvData = (PVOID)pArgs->piniProfile->GPPS(c_pszCmSection, TranslateUserDataID(uiEntry));
            break;

        case UD_ID_PASSWORD:
        case UD_ID_INET_PASSWORD:
            return ReadPasswordFromCmp(pArgs, uiEntry, (LPTSTR *)ppvData);
            break;

        case UD_ID_NOPROMPT:
        case UD_ID_REMEMBER_PWD:
        case UD_ID_REMEMBER_INET_PASSWORD:
            *(BOOL *)(*ppvData) = pArgs->piniProfile->GPPB(c_pszCmSection, TranslateUserDataID(uiEntry));
            break;

            //
            //  None of these should be in the CMP by this point.  Return a failure value.
            //
        case UD_ID_PCS:
        case UD_ID_ACCESSPOINTENABLED:
        case UD_ID_CURRENTACCESSPOINT: // if we are trying to read the access point
            CMASSERTMSG(FALSE, TEXT("ReadUserInfoFromCmp -- trying to read a value that should never be in the cmp, why?"));
            *ppvData = NULL;
            return FALSE;
            break;

        default:
            MYDBGASSERT(0);
            break;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   DeleteUserInfoFromCmp
//
//  Synopsis:   Deletes userinfo data from cmp.
// 
//  Arguments:  pArgs           ptr to ArgsStruct
//              uiEntry         the cmp file entry
//
//  Returns:    BOOL    TRUE = success, FALSE = failure
//
//----------------------------------------------------------------------------
BOOL DeleteUserInfoFromCmp(
    ArgsStruct  *pArgs,
    UINT        uiEntry
)
{
    BOOL bReturn = FALSE;
    UINT  uiKeepDefCreds = 0;
    const TCHAR* const c_pszKeepDefaultCredentials = TEXT("KeepDefaultCredentials"); 

    if (NULL == pArgs)
    {
        return bReturn;
    }

    switch (uiEntry)
    {
        case UD_ID_USERNAME:
        case UD_ID_DOMAIN:
        case UD_ID_INET_USERNAME:
        case UD_ID_NOPROMPT:
        case UD_ID_REMEMBER_PWD:
        case UD_ID_REMEMBER_INET_PASSWORD:
        case UD_ID_PASSWORD:
        case UD_ID_INET_PASSWORD:

            //
            // Get KeepDefaultCredentials value from CMP
            //
            uiKeepDefCreds = GetPrivateProfileIntU(c_pszCmSection, c_pszKeepDefaultCredentials, 0,
                                                   pArgs->piniProfile->GetFile());

            if (0 == uiKeepDefCreds) 
            {
                if (WritePrivateProfileStringU(c_pszCmSection, TranslateUserDataID(uiEntry), 
                                               NULL, pArgs->piniProfile->GetFile()))
                {
                    bReturn = TRUE;
                }
            }
            break;

        default:
            MYDBGASSERT(0);
            break;

    }
    return bReturn;
}

//+---------------------------------------------------------------------------
//
//  Function:   RasGetCredsWrapper
//
//  Synopsis:   Wrapper function to call RasGetCredentials.  The function
//              calls RasGetCredentials and then copies the appropriate data
//              from the RASCREDENTIALS struct into the buffer pointed to by
//              *ppvData (allocated on the caller behalf).  Note that the value
//              set in dwMask determines which data item is retrieved from the
//              credentials cache.  Currently, dwMask must be one of RASCM_UserName,
//              RASCM_Domain, or RASCM_Password.
// 
//  Arguments:  pArgs           ptr to ArgsStruct
//              pszPhoneBook    full path to the phonebook file to get the 
//                              data from, or NULL to use the all user default pbk
//              dwMask          dwMask value for the RASCREDENTIALS struct
//              ppvData         ptr to ptr to the data buffer.  If the userinfo
//                              is multiple byte(e.g. password), the func allocs
//                              the buffer.
//
//  Returns:    DWORD   ERROR_SUCCESS on success, winerror on failure
//
//----------------------------------------------------------------------------
DWORD RasGetCredsWrapper(
    ArgsStruct *pArgs,
    LPCTSTR pszPhoneBook,
    DWORD dwMask,
    PVOID *ppvData
)
{
    DWORD dwRet = ERROR_INVALID_PARAMETER;

    MYDBGASSERT(pArgs && pArgs->rlsRasLink.pfnGetCredentials);
    MYDBGASSERT(ppvData);
    MYDBGASSERT((RASCM_UserName == dwMask) || (RASCM_Domain == dwMask) || (RASCM_Password == dwMask));

    if (pArgs && ppvData && pArgs->rlsRasLink.pfnGetCredentials)
    {
        LPTSTR pszConnectoid = GetRasConnectoidName(pArgs, pArgs->piniService, FALSE);

        if (pszConnectoid)
        {
            RASCREDENTIALS RasCredentials = {0};
            RasCredentials.dwSize = sizeof(RasCredentials);
            
            if (CM_CREDS_GLOBAL == pArgs->dwCurrentCredentialType)
            {
                RasCredentials.dwMask = dwMask | RASCM_DefaultCreds;
            }
            else
            {
                RasCredentials.dwMask = dwMask; 
            }
            
            dwRet = pArgs->rlsRasLink.pfnGetCredentials(pszPhoneBook, pszConnectoid, &RasCredentials);

            if (ERROR_SUCCESS == dwRet)
            {
                LPTSTR pszData = NULL;

                if (RASCM_UserName == dwMask)
                {
                    pszData = RasCredentials.szUserName;
                }
                else if (RASCM_Domain == dwMask)
                {
                    pszData = RasCredentials.szDomain;                
                }
                else if (RASCM_Password == dwMask)
                {
                    pszData = RasCredentials.szPassword;
                }

                LPTSTR pszReturn = CmStrCpyAlloc(pszData);

                if (NULL == pszReturn)
                {
                    dwRet = ERROR_NOT_ENOUGH_MEMORY;
                }
                else
                {
                    *ppvData = pszReturn;
                }
            }

            CmWipePassword(RasCredentials.szPassword);

            CmFree(pszConnectoid);
        }
    }

    return dwRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   ReadUserInfoFromRas
//
//  Synopsis:   Read userinfo data from the RAS credentials cache
// 
//  Arguments:  pArgs           ptr to ArgsStruct
//              uiEntry         the cmp file entry
//              ppvData         ptr to ptr to the data buffer.  If the userinfo
//                              is multiple byte(e.g. password), the func allocs
//                              the buffer.
//
//  Returns:    BOOL    TRUE = success, FALSE = failure
//
//----------------------------------------------------------------------------
BOOL ReadUserInfoFromRas(
    ArgsStruct  *pArgs,
    UINT        uiEntry,
    PVOID       *ppvData
)
{
    BOOL bReturn = FALSE;

    if (OS_NT5 && pArgs && pArgs->bUseRasCredStore)
    {
        DWORD dwMask;
        LPTSTR pszPhoneBook = NULL;

        switch (uiEntry)
        {
            case UD_ID_USERNAME:
                dwMask = RASCM_UserName;
                bReturn = (ERROR_SUCCESS == RasGetCredsWrapper(pArgs, pArgs->pszRasPbk, dwMask, ppvData));

                break;

            case UD_ID_PASSWORD:
                dwMask = RASCM_Password;
                bReturn = (ERROR_SUCCESS == RasGetCredsWrapper(pArgs, pArgs->pszRasPbk, dwMask, ppvData));
                break;

            case UD_ID_DOMAIN:
                dwMask = RASCM_Domain;
                bReturn = (ERROR_SUCCESS == RasGetCredsWrapper(pArgs, pArgs->pszRasPbk, dwMask, ppvData));
                break;

            case UD_ID_INET_PASSWORD:
                dwMask = RASCM_Password;
                pszPhoneBook = CreateRasPrivatePbk(pArgs);

                if (pszPhoneBook)
                {
                    bReturn = (ERROR_SUCCESS == RasGetCredsWrapper(pArgs, pszPhoneBook, dwMask, ppvData));
                    CmFree(pszPhoneBook);
                }
                break;

            case UD_ID_INET_USERNAME:
                dwMask = RASCM_UserName;
                pszPhoneBook = CreateRasPrivatePbk(pArgs);

                if (pszPhoneBook)
                {
                    bReturn = (ERROR_SUCCESS == RasGetCredsWrapper(pArgs, pszPhoneBook, dwMask, ppvData));
                    CmFree(pszPhoneBook);
                }
                break;
        }
    }

    if (bReturn)
    {
        if (CM_CREDS_GLOBAL == pArgs->dwCurrentCredentialType)
        {
            CMTRACE1(TEXT("ReadUserInfoFromRas() - %s retrieved from the Global RAS Credential store"), TranslateUserDataID(uiEntry));
        }
        else
        {
            CMTRACE1(TEXT("ReadUserInfoFromRas() - %s retrieved from the User RAS Credential store"), TranslateUserDataID(uiEntry));
        }
    }

    return bReturn;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetUserInfo
//
//  Synopsis:   Get an userinfo.  The user info can reside in either the
//              cache, cmp, or registry.  This functions hides this from the
//              user.
//
//  We first try the cmp file.  If that fails, we try the cache.
//       We'll get the following user info:
//           username, 
//           password, 
//           domain,
//           remember main passwd,
//           dial automatically,
//           inet username,
//           inet passwd
//           remember inet password
//           inet use same user name
// 
//  Arguments:  pArgs           ptr to ArgsStruct
//              uiEntry         the cmp file entry
//              pvData          ptr to ptr to the data buffer.  If the userinfo
//                              is multiple byte(e.g. password), the func allocs
//                              the buffer.
//
//  Returns:    BOOL    TRUE = success, FALSE = failure
//
//----------------------------------------------------------------------------
BOOL GetUserInfo(
    ArgsStruct  *pArgs, 
    UINT        uiEntry,
    PVOID       *ppvData
)
{
    BOOL bReturn = ReadUserInfoFromRas(pArgs, uiEntry, ppvData);

    if (!bReturn)
    {
        bReturn = ReadUserInfoFromReg(pArgs, uiEntry, ppvData);        
    }

    if (!bReturn)
    {
        bReturn = ReadUserInfoFromCmp(pArgs, uiEntry, ppvData);
    }

    return bReturn;
}

//+---------------------------------------------------------------------------
//
//  Function:   SaveUserInfo
//
//  Synopsis:   Save an userinfo.  The user info can reside in either the
//              RAS cred cache or the registry.  This functions abstracts
//              this from the user.
//
//  We first try the RAS cred cache.  If the RAS cred cache doesn't hold that
//  piece of info we then save it in the registry.
//       We'll save the following user info:
//           username, 
//           password, 
//           domain,
//           remember main passwd,
//           dial automatically,
//           inet username,
//           inet passwd
//           remember inet password
//           inet use same user name
// 
//  Arguments:  pArgs           ptr to ArgsStruct
//              uiEntry         the cmp file entry
//              pvData          ptr to the data buffer.  If the userinfo is
//                              multiple byte(e.g. password), the func allocs
//                              the buffer.
//
//  Returns:    BOOL    TRUE = success, FALSE = failure
//
//----------------------------------------------------------------------------
BOOL SaveUserInfo(
    ArgsStruct  *pArgs, 
    UINT        uiEntry,
    PVOID       pvData
)
{
    //
    //  Try giving the Data to RAS first.  If the function returns
    //  -1, then this is data that RAS doesn't hold for us and we will
    //  have to put it in the registry instead.
    //
    int iReturn = WriteUserInfoToRas(pArgs, uiEntry, pvData);

    if (-1 == iReturn)
    {
        //
        // Just write the data to the registry. Use CMP only as
        // an upgrade reference for UserInfo data post CM 1.1
        //

        iReturn = WriteUserInfoToReg(pArgs, uiEntry, pvData);
    }

    return iReturn;
}

//+---------------------------------------------------------------------------
//
//  Function:   DeleteUserInfo
//
//  Synopsis:   Delete an userinfo.  The user info can reside in either the
//              RAS Cred cache or the registry.  This functions abstracts
//              this from the user.
//
//       We first try the RAS cache first.  If that piece of info isn't stored
//       in the RAS cache then we try the registry.
//
//       We'll delete the following user info:
//           username, 
//           password, 
//           domain,
//           remember main passwd,
//           dial automatically,
//           inet username,
//           inet passwd
//           remember inet password
//           inet use same user name
// 
//  Arguments:  pArgs           ptr to ArgsStruct
//              uiEntry         the cmp file entry
//
//  Returns:    BOOL    TRUE = success, FALSE = failure
//
//----------------------------------------------------------------------------
BOOL DeleteUserInfo(
    ArgsStruct  *pArgs, 
    UINT        uiEntry
)
{
    int iReturn = DeleteUserInfoFromRas(pArgs, uiEntry);

    if (-1 == iReturn)
    {
        iReturn = DeleteUserInfoFromReg(pArgs, uiEntry);
    }

    return iReturn;
}

//+---------------------------------------------------------------------------
//
//  Function:   NeedToUpgradeUserInfo
//
//  Synopsis:   Do we need to upgrade the cm 1.0/1.1 userinfo to the cm 1.2 format?
// 
//  Arguments:  pArgs - Ptr to global args struct
//
//  Returns:    BOOL    TRUE = success, FALSE = failure
//
//----------------------------------------------------------------------------
int NeedToUpgradeUserInfo(
    ArgsStruct  *pArgs)
{
    MYDBGASSERT(pArgs);

    DWORD dwRes;
    HKEY hKeyCm;
    LPTSTR pszSubKey;
    int iReturn = c_iNoUpgradeRequired;

    if (pArgs)
    {
        //
        //  If this is NT5 or greater, we want to be storing our credentials with RAS
        //  instead of the registry.  
        //
        //  If this isn't NT5 we still want to upgrade the user to using the registry as 
        //  storage instead of the cmp if they haven't already
        //  been upgraded.  Thus the simple test is to open the service name key in HKCU. 
        //  This key will exist, if the user has already run 1.2 bits.
        //

        pszSubKey = BuildUserInfoSubKey(pArgs->szServiceName, pArgs->fAllUser);

        dwRes = RegOpenKeyExU(HKEY_CURRENT_USER,
                              pszSubKey,
                              0,
                              KEY_QUERY_VALUE,
                              &hKeyCm);

        if (ERROR_SUCCESS == dwRes)
        {
            //
            //  Then we have the registry method, unless we are supposed to be using the RAS
            //  cred store we are done.  If we are supposed to be using the RAS cred store
            //  we need to check to make sure that we are using it.  Note we could have a problem
            //  here if the user has registry cred data and then their registry gets write protected.
            //  This would allow us to read from it but not delete the old data.  Thus the user
            //  would never be able to save any changes because we would always think they needed
            //  to upgrade.  An unlikely scenario but possible ...
            //

            if (pArgs->bUseRasCredStore)
            {
                LPTSTR pszUserName = NULL;

                BOOL bRet = ReadUserInfoFromReg(pArgs, UD_ID_USERNAME, (PVOID*)&pszUserName);

                if (bRet && (NULL != pszUserName) && (TEXT('\0') != pszUserName[0]))
                {
                    //
                    //  Then we have the username in the registry.  Lets upgrade to the RAS
                    //  credential store.
                    //
                    iReturn = c_iUpgradeFromRegToRas;
                }

                CmFree(pszUserName);
            }

            RegCloseKey(hKeyCm);
        }
        else
        {
            iReturn = c_iUpgradeFromCmp;
        }

        CmFree(pszSubKey);
    }
    else
    {
        CMASSERTMSG(FALSE, TEXT("NeedToUpgradeUserInfo -- NULL pArgs passed"));    
    }

    //
    // We don't want to upgrade if it's ICS. This prevents from adding info to the registry.
    //
    if (CM_LOGON_TYPE_ICS == pArgs->dwWinLogonType)
    {
        iReturn = c_iNoUpgradeRequired;
    }


    return iReturn;
}

//+---------------------------------------------------------------------------
//
//  Function:   UpgradeUserInfoFromRegToRasAndReg
//
//  Synopsis:   Upgrade the userinfo from CM 1.2 registry only format to the
//              CM 1.3 format which uses both RAS credential storage and
//              the registry.
// 
//  Arguments:  pArgs           ptr to ArgsStruct
//
//  Returns:    BOOL    TRUE = success, FALSE = failure
//
//----------------------------------------------------------------------------
BOOL UpgradeUserInfoFromRegToRasAndReg(
    ArgsStruct  *pArgs
)
{
    BOOL bReturn = FALSE;

    if (OS_NT5)
    {
        LPTSTR pszTmp;

        pszTmp = NULL;

        //
        // If we get an empty string "" from ReadUserInfoFromReg we don't want to 
        // save the empty string to the RAS Credstore because it might overwrite 
        // global credentials information. This can happen if User1 saves global
        // credentials and User2 tries using the same profile. Since User2 is running 
        // this profile for the 1st time, he'll run through an upgrade path and if global
        // creds exist we don't want to null them out.
        //
        
        if (ReadUserInfoFromReg(pArgs, UD_ID_INET_USERNAME, (PVOID*)&pszTmp))
        {
            DeleteUserInfoFromReg(pArgs, UD_ID_INET_USERNAME);
            if (pszTmp && lstrlenU(pszTmp))
            {
                WriteUserInfoToRas(pArgs, UD_ID_INET_USERNAME, pszTmp);
            }
            CmFree(pszTmp);
        }

        pszTmp = NULL;
        if (ReadUserInfoFromReg(pArgs, UD_ID_INET_PASSWORD, (PVOID*)&pszTmp))
        {
            DeleteUserInfoFromReg(pArgs, UD_ID_INET_PASSWORD);
            if (pszTmp && lstrlenU(pszTmp))
            {
                WriteUserInfoToRas(pArgs, UD_ID_INET_PASSWORD, pszTmp);
            }
            CmFree(pszTmp);
        }

        pszTmp = NULL;
        if (ReadUserInfoFromReg(pArgs, UD_ID_USERNAME, (PVOID*)&pszTmp))
        {
            DeleteUserInfoFromReg(pArgs, UD_ID_USERNAME);
            if (pszTmp && lstrlenU(pszTmp))
            {
                WriteUserInfoToRas(pArgs, UD_ID_USERNAME, pszTmp);
            }
            CmFree(pszTmp);
        }

        pszTmp = NULL;
        if (ReadUserInfoFromReg(pArgs, UD_ID_DOMAIN, (PVOID*)&pszTmp))
        {
            DeleteUserInfoFromReg(pArgs, UD_ID_DOMAIN);
            if (pszTmp && lstrlenU(pszTmp))
            {
                WriteUserInfoToRas(pArgs, UD_ID_DOMAIN, pszTmp);
            }
            CmFree(pszTmp);
        }

        pszTmp = NULL;
        if (ReadUserInfoFromReg(pArgs, UD_ID_PASSWORD, (PVOID*)&pszTmp))
        {
            DeleteUserInfoFromReg(pArgs, UD_ID_PASSWORD);
            if (pszTmp && lstrlenU(pszTmp))
            {
                WriteUserInfoToRas(pArgs, UD_ID_PASSWORD, pszTmp);
            }
            CmFree(pszTmp);
        }

        //
        //  Now delete the PCS value as it is no longer meaningful
        //
        DeleteUserInfoFromReg(pArgs, UD_ID_PCS);
    }
    else
    {
        MYDBGASSERT(FALSE);
    }


    return bReturn;
}


//+---------------------------------------------------------------------------
//
//  Function:   UpgradeUserInfoFromCmp
//
//  Synopsis:   Upgrade the userinfo from cm1.0/1,1 format to 1.3 format.
// 
//  Arguments:  pArgs           ptr to ArgsStruct
//
//  Returns:    BOOL    TRUE = success, FALSE = failure
//
//----------------------------------------------------------------------------
BOOL UpgradeUserInfoFromCmp(
    ArgsStruct  *pArgs
)
{
    LPTSTR      pszTmp;
    BOOL        fTmp;
    PVOID       pv;

    //
    // First retrieve each of the non-cached data items
    // Then delete username, internetusername, domain, password, 
    // internetpassword, remember password, remember internet password
    // and noprompt (dial automatically) from the CMP file.
    // If the KeepDefaultCredentials is set to 1 in the .CMP file then the 
    // DeleteUserInfoFromCmp function does not actually delete the values from 
    // the file.
    // If we get an empty string "" from ReadUserInfoFromCmp we don't want to 
    // save the empty string to the RAS Credstore because it might overwrite 
    // global credentials information. This can happen if User1 saves global
    // credentials and User2 tries using the same profile. Since User2 is running 
    // this profile for the 1st time, he'll run through an upgrade path and if global
    // creds exist we don't want to null them out.
    //

    pszTmp = NULL;
    ReadUserInfoFromCmp(pArgs, UD_ID_USERNAME, (PVOID*)&pszTmp);
    if (pszTmp && lstrlenU(pszTmp))
    {
        SaveUserInfo(pArgs, UD_ID_USERNAME, pszTmp);
    }
    DeleteUserInfoFromCmp(pArgs, UD_ID_USERNAME);
    CmFree(pszTmp);

    pszTmp = NULL;
    ReadUserInfoFromCmp(pArgs, UD_ID_DOMAIN, (PVOID*)&pszTmp);
    if (pszTmp && lstrlenU(pszTmp))
    {
        SaveUserInfo(pArgs, UD_ID_DOMAIN, pszTmp);
    }    
    DeleteUserInfoFromCmp(pArgs, UD_ID_DOMAIN);
    CmFree(pszTmp);

    pszTmp = NULL;
    ReadUserInfoFromCmp(pArgs, UD_ID_INET_USERNAME, (PVOID*)&pszTmp);
    if (pszTmp && lstrlenU(pszTmp))
    {
        SaveUserInfo(pArgs, UD_ID_INET_USERNAME, pszTmp);
    }
    DeleteUserInfoFromCmp(pArgs, UD_ID_INET_USERNAME);
    CmFree(pszTmp);

    pv = &fTmp;
    ReadUserInfoFromCmp(pArgs, UD_ID_NOPROMPT, &pv);
    SaveUserInfo(pArgs, UD_ID_NOPROMPT, pv);
    DeleteUserInfoFromCmp(pArgs, UD_ID_NOPROMPT);

    pv = &fTmp;
    ReadUserInfoFromCmp(pArgs, UD_ID_REMEMBER_PWD, &pv);
    SaveUserInfo(pArgs, UD_ID_REMEMBER_PWD, pv);
    DeleteUserInfoFromCmp(pArgs, UD_ID_REMEMBER_PWD);

    pv = &fTmp;
    ReadUserInfoFromCmp(pArgs, UD_ID_REMEMBER_INET_PASSWORD, &pv);
    SaveUserInfo(pArgs, UD_ID_REMEMBER_INET_PASSWORD, pv);
    DeleteUserInfoFromCmp(pArgs, UD_ID_REMEMBER_INET_PASSWORD);

    //
    // Construct old cache entry name
    //

    LPTSTR pszCacheEntryName = GetLegacyKeyName(pArgs);
    
    //
    // main passwd
    //
    pszTmp = NULL;
    
    //
    // To get the passwords, the cm 1.1 logic is that we first try the cmp, then the cache.
    //

    if (ReadUserInfoFromCmp(pArgs, UD_ID_PASSWORD, (PVOID*)&pszTmp))
    {
        if (pszTmp && lstrlenU(pszTmp))
        {
            SaveUserInfo(pArgs, UD_ID_PASSWORD, pszTmp);
        }
    }
    else
    {
        CmFree(pszTmp);
        pszTmp = NULL;

#ifdef  TEST_USERINFO_UPGRADE
    
        MYVERIFY(WriteStringToCache(pArgs, pszCacheEntryName, TEXT("CM 1.1 main password")));
#endif        
        
        //
        // Try to read it from cache
        //

        if (ReadStringFromCache(pArgs, pszCacheEntryName, &pszTmp))
        {
            if (pszTmp && lstrlenU(pszTmp))
            {
                if (SaveUserInfo(pArgs, UD_ID_PASSWORD, pszTmp))
                {

#ifdef  TEST_USERINFO_UPGRADE

                MYVERIFY(DeleteStringFromCache(pArgs, pszCacheEntryName));
#endif
                }
            }
        }
    }
    DeleteUserInfoFromCmp(pArgs, UD_ID_PASSWORD);
    CmFree(pszTmp);

    //
    // inet passwd
    //
    pszTmp = NULL;
    if (ReadUserInfoFromCmp(pArgs, UD_ID_INET_PASSWORD, (PVOID*)&pszTmp))
    {
        if (pszTmp && lstrlenU(pszTmp))
        {
            SaveUserInfo(pArgs, UD_ID_INET_PASSWORD, pszTmp);
        }
    }
    else
    {
        CmFree(pszTmp);
        pszTmp = NULL;

        //
        // Build tunnel entry name and read string from cache
        //
      
        pszCacheEntryName = CmStrCatAlloc(&pszCacheEntryName, TEXT("-tunnel"));

#ifdef  TEST_USERINFO_UPGRADE
        
        MYVERIFY(WriteStringToCache(pArgs, pszCacheEntryName, TEXT("CM 1.1 internet password")));
#endif
       
        if (ReadStringFromCache(pArgs, pszCacheEntryName, &pszTmp))
        {
            if (pszTmp && lstrlenU(pszTmp))
            {
                if (SaveUserInfo(pArgs, UD_ID_INET_PASSWORD, pszTmp))
                {

#ifdef  TEST_USERINFO_UPGRADE

                MYVERIFY(DeleteStringFromCache(pArgs, pszCacheEntryName));
#endif
                }
            }
        }
    }
    DeleteUserInfoFromCmp(pArgs, UD_ID_INET_PASSWORD);
    CmFree(pszTmp);

    CmFree(pszCacheEntryName);

    return TRUE; // MarkUserInfoUpgraded(pArgs);
}

//+----------------------------------------------------------------------------
//
// Function:  GetLegacyKeyName
//
// Synopsis:  Builds the string fragment used to build cache entry name. The "
//            sign-in" prefix is maintained for legacy compatibility
//
// Arguments: ArgsStruct *pArgs - Ptr to global args struct
//
// Returns:   LPTSTR - Ptr to allocated string containing "<service name> - Sign-In"
//
// Note:      Used exclusively for cache entry name construction
//
// History:   nickball    Created Header    4/16/98
//
//+----------------------------------------------------------------------------
LPTSTR GetLegacyKeyName(ArgsStruct *pArgs)
{
    MYDBGASSERT(pArgs);

    //
    // Service name is the basis of the key name. We also include 
    // IDMSG_TITLESERVICE and append a suffix of " (Connection Manager)"
    //

    LPTSTR pszRes = CmFmtMsg(g_hInst, IDMSG_TITLESERVICE, pArgs->szServiceName);
    
    MYDBGASSERT(pszRes && *pszRes);

    if (pszRes)
    {
        pszRes = CmStrCatAlloc(&pszRes, c_pszCacheEntryNameSuffix);
    }

    return (pszRes);
}

//+----------------------------------------------------------------------------
//
// Function:  EncryptPassword
//
// Synopsis:  Wrapper for encrypting password
//
// Arguments: ArgsStruct *pArgs - Ptr to global args struct
//            LPCTSTR pszPassword - The password to be encrypted
//            LPDWORD lpdwBufSize - Buffer for size of the encrypted buffer - optional
//            LPDWORD lpdwCryptType - Buffer for crypto type used
//            BOOL    fReg - Password is disguised for registry storage
//
// Returns:   LPTSTR - Ptr to allocated buffer containing encrypted form of password
//
// History:   nickball    Created Header    5/22/98
//
//+----------------------------------------------------------------------------

LPTSTR EncryptPassword(
    ArgsStruct *pArgs, 
    LPCTSTR pszPassword, 
    LPDWORD lpdwBufSize, 
    LPDWORD lpdwCryptType,
    BOOL /*fReg*/,
    LPSTR pszSubKey)
{
    MYDBGASSERT(pArgs);
    MYDBGASSERT(pszPassword);
    MYDBGASSERT(lpdwCryptType);
    DWORD dwEncryptedBufferLen;
    DWORD dwSize = 0;

    LPTSTR pszEncryptedData = NULL;
    TCHAR szSourceData[PWLEN + 1];

    if (NULL == pArgs || NULL == pszPassword || NULL == lpdwCryptType)
    { 
        return NULL;
    }

    //
    // Standard encryption, copy the password
    //

    lstrcpyU(szSourceData, pszPassword);
   
    //
    // It is not safe to call InitSecure more than once
    //
    if (!pArgs->fInitSecureCalled)
    {
        pArgs->fInitSecureCalled = TRUE;
        InitSecure(FALSE); // don't use fast encryption anymore
    }

    //
    // Encrypt the provided password
    //

    if (EncryptData(
            (LPBYTE)szSourceData, 
            (lstrlenU(szSourceData)+1) * sizeof(TCHAR),
            (LPBYTE*)&pszEncryptedData,
            &dwEncryptedBufferLen,
            lpdwCryptType,
#if defined(DEBUG) && defined(DEBUG_MEM)
            (PFN_CMSECUREALLOC)AllocDebugMem, // Give the DEBUG_MEM version of alloc/free
            (PFN_CMSECUREFREE)FreeDebugMem))  // Not quit right, AllocDebugMem takes 3 param
#else
            (PFN_CMSECUREALLOC)CmMalloc,
            (PFN_CMSECUREFREE)CmFree,
            pszSubKey))
#endif
    {
        if (lpdwBufSize)
        {
            *lpdwBufSize = dwEncryptedBufferLen;
        }   
    }

    MYDBGASSERT(pszEncryptedData);
    
    CmWipePassword(szSourceData);
    return pszEncryptedData;
}

//+----------------------------------------------------------------------------
//
// Function:  DecryptPassword
//
// Synopsis:  Wrapper to decrypt password
//
// Arguments: ArgsStruct *pArgs - Ptr to global args struct
//            LPCTSTR pszEncryptedData - The encrypted data
//            DWORD dwEncryptionType - The encryption type of the data
//            BOOL    fReg - Password is disguised for registry storage
//
// Returns:   LPTSTR - Ptr to a buffer containing the decrypted form of the password.
//
// History:   nickball    Created     5/22/98
//
//+----------------------------------------------------------------------------
LPBYTE DecryptPassword(
    ArgsStruct *pArgs, 
    LPBYTE pszEncryptedData, 
    DWORD dwEncryptionType,
    DWORD dwEncryptedBytes,
    BOOL /*fReg*/,
    LPSTR pszSubKey)
{      
    MYDBGASSERT(pArgs);
    MYDBGASSERT(pszEncryptedData);
    
    DWORD dwDecryptedBufferLen;
    LPBYTE pszDecryptedData = NULL;

    if (NULL == pArgs || NULL == pszEncryptedData)
    { 
        return NULL;
    }

    //
    // It is not safe to call InitSecure more than once
    //

    if (!pArgs->fInitSecureCalled)
    {
        pArgs->fInitSecureCalled = TRUE;
        InitSecure(FALSE); // don't use fast encryption anymore
    }

    if (DecryptData(pszEncryptedData, dwEncryptedBytes, &pszDecryptedData, &dwDecryptedBufferLen,
                    dwEncryptionType, 
#if defined(DEBUG) && defined(DEBUG_MEM)
             (PFN_CMSECUREALLOC)AllocDebugMem, // Give the DEBUG_MEM version of alloc/free
             (PFN_CMSECUREFREE)FreeDebugMem))  // Not quit right, AllocDebugMem takes 3 param
#else
                    (PFN_CMSECUREALLOC)CmMalloc, 
                    (PFN_CMSECUREFREE)CmFree,
                    pszSubKey))
#endif
    {
        return pszDecryptedData;
    }

    return NULL; 
}

//+----------------------------------------------------------------------------
//
// Function:  TranslateUserDataID
//
// Synopsis:  Wrapper to map user data ID to string name of .CMP entry
//
// Arguments: UINT uiDataID - UserInfo data ID to be translated
//
// Returns:   LPCTSTR - Ptr to a constant containing the .CMP entry flag
//
// History:   nickball    Created     10/13/98
//
//+----------------------------------------------------------------------------
LPCTSTR TranslateUserDataID(UINT uiDataID)
{   
    switch(uiDataID)
    {

    case UD_ID_USERNAME:
        return c_pszCmEntryUserName;
        break;

    case UD_ID_INET_USERNAME:
        return c_pszCmEntryInetUserName;
        break;

    case UD_ID_DOMAIN:
        return c_pszCmEntryDomain;
        break;

    case UD_ID_PASSWORD:
        return c_pszCmEntryPassword;
        break;

    case UD_ID_INET_PASSWORD:
        return c_pszCmEntryInetPassword;
        break;

    case UD_ID_NOPROMPT:
        return c_pszCmEntryNoPrompt;
        break;

    case UD_ID_REMEMBER_PWD:
        return c_pszCmEntryRememberPwd;
        break;
    
    case UD_ID_REMEMBER_INET_PASSWORD:
        return c_pszCmEntryRememberInetPwd;
        break;
 
    case UD_ID_PCS:
        return c_pszCmEntryPcs;
        break;

    case UD_ID_ACCESSPOINTENABLED:
        return c_pszCmEntryAccessPointsEnabled;
        break;

    case UD_ID_CURRENTACCESSPOINT:
        return c_pszCmEntryCurrentAccessPoint;
        break;

    default:
        break;
    }

    MYDBGASSERT(FALSE);
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmdial\tooltip.cpp ===
//+----------------------------------------------------------------------------
//
// File:     tooltip.cpp
//
// Module:   CMDIAL32.DLL
//
// Synopsis: This module contains the code for the implementing balloon tips.
//
// Copyright (c) 1996-2000 Microsoft Corporation
//
// Author:   markcl    Created Header   11/2/00
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"


WNDPROC CBalloonTip::m_pfnOrgBalloonWndProc = NULL;

//+----------------------------------------------------------------------------
//
// Function:  CBalloonTip::CBalloonTip
//
// Synopsis:  Balloon tip constructor
//
// Arguments:	nothing
//
// Returns:   nothing
//
// History:   markcl	Created Header    10/31/00
//
//+----------------------------------------------------------------------------

CBalloonTip::CBalloonTip()
{
    // Nothing to do
}

//+----------------------------------------------------------------------------
//
// Function:  CBalloonTip::DisplayBallonTip
//
// Synopsis:  Displays a balloon tip
//
// Arguments:	LLPOINT	lppoint         - pointer to a POINT struct with the coordinates for displaying
//              int		iIcon           - type of icon to display in the balloon tip
//              LPCTSTR	lpszTitle       - Title of the balloon tip window
//              LPTSTR	lpszBalloonMsg  - Message to display in the balloon tip
//              HWND	hWndParent      - handle to the parent window
//
// Returns:   nothing
//
// History:   markcl    Created Header    10/31/00
//
//+----------------------------------------------------------------------------
BOOL CBalloonTip::DisplayBalloonTip(LPPOINT lppoint, UINT iIcon, LPCTSTR lpszTitle, LPTSTR lpszBalloonMsg, HWND hWndParent)
{

    //
    //	If we don't have a message or a position, we don't display the balloon tip.
    //
    if (NULL == lpszBalloonMsg || NULL == lppoint)
    {
        MYDBGASSERT(lpszBalloonMsg && lppoint);

        return FALSE;
    }

    //
    //  Comctl32.dll must be 5.80 or greater to use balloon tips.  We check the dll version 
    //  by calling DllGetVersion in comctl32.dll.
    //
    HINSTANCE hComCtl = LoadLibraryExA("comctl32.dll", NULL, 0);

    CMASSERTMSG(hComCtl, TEXT("LoadLibrary - comctl32 failed for Balloon Tips"));

    if (hComCtl != NULL)
    {
        typedef HRESULT (*DLLGETVERSIONPROC)(DLLVERSIONINFO* lpdvi);

        DLLGETVERSIONPROC fnDllGetVersion = (DLLGETVERSIONPROC) GetProcAddress(hComCtl,"DllGetVersion");

        MYDBGASSERT(fnDllGetVersion);

        if (NULL == fnDllGetVersion)
        {
            //
            //  DllGetVersion does not exist in Comctl32.dll.  This mean the version is too old so we need to fail.
            //
            FreeLibrary(hComCtl);
            return FALSE;
        }
        else
        {
            DLLVERSIONINFO dvi;

            ZeroMemory(&dvi, sizeof(dvi));
            dvi.cbSize = sizeof(dvi);

            HRESULT hResult = (*fnDllGetVersion)(&dvi);

            FreeLibrary(hComCtl);
			
            if (SUCCEEDED(hResult))
            {
                //
                //  Take the version returned and compare it to 5.80.
                //
                if (MAKELONG(dvi.dwMinorVersion,dvi.dwMajorVersion) < MAKELONG(80,5))
                {
                    CMTRACE2(TEXT("COMCTL32.DLL version - %d.%d"),dvi.dwMajorVersion,dvi.dwMinorVersion);
                    CMTRACE1(TEXT("COMCTL32.DLL MAKELONG - %li"),MAKELONG(dvi.dwMinorVersion,dvi.dwMajorVersion));
                    CMTRACE1(TEXT("Required minimum MAKELONG - %li"),MAKELONG(80,5));
					
                    // Wrong DLL version
                    return FALSE;
                }
            }
            else
            {
                CMASSERTMSG(FALSE, TEXT("Call to DllGetVersion in comctl32.dll failed."));
                return FALSE;
            }
        }
    }

    //
    //  Hide any existing balloon tips before trying to display a new one.
    //    
    if (m_hwndTT && m_bTTActive)
    {
        HideBalloonTip();
    }

    //
    // Create the Balloon ToolTip window
    //
    m_hwndTT = CreateWindowExU(NULL,TOOLTIPS_CLASS, TEXT("CM Balloon Tip Window"),
                               WS_POPUP | TTS_BALLOON, CW_USEDEFAULT, CW_USEDEFAULT,
                               CW_USEDEFAULT, CW_USEDEFAULT, hWndParent, NULL, g_hInst, NULL);

    if (m_hwndTT)
    {
        m_ti.cbSize = sizeof(m_ti);
        m_ti.uFlags = TTF_TRACK;
        m_ti.hwnd = hWndParent;
        m_ti.hinst = g_hInst;
	
        SendMessageU(m_hwndTT,TTM_ADDTOOL,0,(LPARAM) (LPTOOLINFO) &m_ti);

        SendMessageU(m_hwndTT,TTM_SETMAXTIPWIDTH,0,200);
    }
    else
    {
        MYDBGASSERT(m_hwndTT);
        return FALSE;
    }

    //
    //  Subclass the edit control
    //
    m_pfnOrgBalloonWndProc = (WNDPROC)SetWindowLongU(m_hwndTT, GWLP_WNDPROC, (LONG_PTR)SubClassBalloonWndProc);

    //
    //  Save the this pointer with the window
    //
    SetWindowLongU(m_hwndTT, GWLP_USERDATA, (LONG_PTR)this);

    //
    //	Set the balloon message
    //
    m_ti.lpszText = lpszBalloonMsg;
    SendMessageU(m_hwndTT,TTM_UPDATETIPTEXT,0,(LPARAM) (LPTOOLINFO) &m_ti);

    //
    //  If we got a title, then add it
    //
    if (lpszTitle)
    {
	
        //
        //  confirm we have a valid icon
        //
        if (iIcon > 3)
        {
            iIcon = TTI_NONE;  // TTI_NONE = No icon
        }
		
        SendMessageU(m_hwndTT,TTM_SETTITLE,(WPARAM) iIcon,(LPARAM) lpszTitle);
    }

    //
    //  Set the position
    //
    SendMessageU(m_hwndTT,TTM_TRACKPOSITION,0,(LPARAM) (DWORD) MAKELONG(lppoint->x,lppoint->y));

    //
    //  Show balloon tip window
    //
    SendMessageU(m_hwndTT,TTM_TRACKACTIVATE,(WPARAM) TRUE,(LPARAM) (LPTOOLINFO) &m_ti);

    //  Set active state
    m_bTTActive = TRUE;
	
    return TRUE;

}

//+----------------------------------------------------------------------------
//
// Function:  CBalloonTip::HideBallonTip
//
// Synopsis:  Hides a balloon tip
//
// Arguments: nothing
//
// Returns:   nothing
//
// History:   markcl	Created Header    10/31/00
//
//+----------------------------------------------------------------------------
BOOL CBalloonTip::HideBalloonTip()
{

    // check active state && handle
    if(m_hwndTT && m_bTTActive)
    {
        // hide window
        SendMessageU(m_hwndTT,TTM_TRACKACTIVATE,(WPARAM) FALSE,(LPARAM) (LPTOOLINFO) &m_ti);

        m_bTTActive = FALSE;

        // force a repaint on parent window
        InvalidateRect(m_ti.hwnd,NULL,NULL);

        // destroy window
        DestroyWindow(m_hwndTT);
        m_hwndTT = NULL;

        return TRUE;

    }
    else
    {

        return FALSE;
    
    }

}

//+----------------------------------------------------------------------------
//
// Function:  CBalloonTip::SubClassBalloonWndProc
//
// Synopsis:  Subclassed wnd proc to trap the mouse button clicks on the balloon tip window
//
// Arguments: standard win32 window proc params
//
// Returns:   standard win32 window proc return value
//
// History:   markcl      created         11/2/00
//
//+----------------------------------------------------------------------------
LRESULT CALLBACK CBalloonTip::SubClassBalloonWndProc(HWND hwnd, UINT uMsg, 
                                                      WPARAM wParam, LPARAM lParam)
{

    if ((uMsg == WM_LBUTTONDOWN) || (uMsg == WM_RBUTTONDOWN))
    {
	
        //
        // Get the object pointer saved by SetWindowLong
        //
        CBalloonTip* pBalloonTip = (CBalloonTip*)GetWindowLongU(hwnd, GWLP_USERDATA);
        MYDBGASSERT(pBalloonTip);

        if (pBalloonTip)
        {
            pBalloonTip->HideBalloonTip();
        }
    }

    // 
    // Call the original window procedure for default processing. 
    //
    return CallWindowProcU(m_pfnOrgBalloonWndProc, hwnd, uMsg, wParam, lParam); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmdial\tooltip.h ===
//+----------------------------------------------------------------------------
//
// File:     tooltip.h
//
// Module:   CMDIAL32.DLL
//
// Synopsis: Main header file for tool tips
//
// Copyright (c) 1998-2000 Microsoft Corporation
//
// Author:   markcl Created    11/2/00
//
//+----------------------------------------------------------------------------

// NOTE: The following 2 sections will need to be removed if we compile with NT verion > 4.0 
// or _WIN32_IE > 4.0.

//
// Copied from commctrl.h
//
#define TTS_BALLOON             0x40
//#define TTI_INFO                1

#define TTM_SETTITLEA           (WM_USER + 32)  // wParam = TTI_*, lParam = char* szTitle
#define TTM_SETTITLEW           (WM_USER + 33)  // wParam = TTI_*, lParam = wchar* szTitle

#ifdef UNICODE
#define TTM_SETTITLE            TTM_SETTITLEW
#else
#define TTM_SETTITLE            TTM_SETTITLEA
#endif
// End of copied commctrl.h

//
// Copied from shlwapi.h
//
typedef struct _DLLVERSIONINFO
{
    DWORD cbSize;
    DWORD dwMajorVersion;                   // Major version
    DWORD dwMinorVersion;                   // Minor version
    DWORD dwBuildNumber;                    // Build number
    DWORD dwPlatformID;                     // DLLVER_PLATFORM_*
} DLLVERSIONINFO;

typedef struct _DLLVERSIONINFO2
{
    DLLVERSIONINFO info1;
    DWORD dwFlags;                          // No flags currently defined
    ULONGLONG ullVersion;                   // Encoded as:
                                            // Major 0xFFFF 0000 0000 0000
                                            // Minor 0x0000 FFFF 0000 0000
                                            // Build 0x0000 0000 FFFF 0000
                                            // QFE   0x0000 0000 0000 FFFF
} DLLVERSIONINFO2;

typedef HRESULT (CALLBACK* DLLGETVERSIONPROC)(DLLVERSIONINFO *);
// End of copied shlwapi.h



//+---------------------------------------------------------------------------
//
//	class CBalloonTip
//
//	Description: Balloon Tip window
//
//	History:	markcl    Created   10/31/00
//
//----------------------------------------------------------------------------

class CBalloonTip
{
public:
	CBalloonTip();
		
	BOOL DisplayBalloonTip(LPPOINT lppoint, UINT iIcon, LPCTSTR lpszTitle, LPTSTR lpszBalloonMsg, HWND hWndParent);
	BOOL HideBalloonTip();


protected:
    static LRESULT CALLBACK SubClassBalloonWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static WNDPROC m_pfnOrgBalloonWndProc;  // the original edit control window proc for subclassing

	HWND		m_hwndTT;		// handle for the balloon tooltip
	BOOL		m_bTTActive;	// whether the balloon tooltip is active or not

	TOOLINFO	m_ti;				// tooltip structure

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmdial\tapi.cpp ===
//+----------------------------------------------------------------------------
//
// File:     tapi.cpp     
//
// Module:   CMDIAL32.DLL
//
// Synopsis: The module contains the code related to TAPI.
//
// Copyright (c) 1996-1999 Microsoft Corporation
//
// Author:   byao       created         04/29/97
//           quintinb   created Header  08/16/99
//
//+----------------------------------------------------------------------------
#include "cmmaster.h"    
#include "unimodem.h" 

//
// Local prototype
//

DWORD GetModemSpeakerMode(TapiLinkageStruct *ptlsTapiLink);

//+----------------------------------------------------------------------------
//
// Function:  TapiCallback
//
// Synopsis:  NULL callback required param when intializing line
//
// Arguments: DWORD hDevice - 
//            DWORD dwMsg - 
//            DWORD dwCallbackInstance - 
//            DWORD dwParam1 - 
//            DWORD dwParam2 - 
//            DWORD dwParam3 - 
//
// Returns:   Nothing
//
// History:   nickball      Created Header    7/7/99
//
//+----------------------------------------------------------------------------

VOID FAR PASCAL TapiCallback(DWORD hDevice, 
                             DWORD dwMsg, 
                             DWORD dwCallbackInstance, 
                             DWORD dwParam1, 
                             DWORD dwParam2, 
                             DWORD dwParam3) 
{
    // nothing
}

//+----------------------------------------------------------------------------
//
// Function:  OpenTapi
//
// Synopsis:  
//
// Arguments: HINSTANCE hInst - 
//            TapiLinkageStruct *ptlsTapiLink - 
//
// Returns:   BOOL - 
//
// History:   quintinb Created Header    5/1/99
//
//+----------------------------------------------------------------------------
BOOL OpenTapi(HINSTANCE hInst, TapiLinkageStruct *ptlsTapiLink) 
{
    LONG lRes;

    if (ptlsTapiLink->bOpen) 
    {
        return (TRUE);
    }
    
    if (!ptlsTapiLink->pfnlineInitialize || !ptlsTapiLink->pfnlineShutdown) 
    {
        SetLastError(ERROR_PROC_NOT_FOUND);
        return (FALSE);
    }
    
    lRes = ptlsTapiLink->pfnlineInitialize(&ptlsTapiLink->hlaLine,
                                            hInst,
                                            TapiCallback,
                                            NULL,
                                            &ptlsTapiLink->dwDevCnt);

    CMTRACE3(TEXT("OpenTapi() lineInitialize() returns %u, hlaLine=0x%x, dwDevCnt=%u."), 
        lRes, ptlsTapiLink->hlaLine, ptlsTapiLink->dwDevCnt);
    
    if (lRes != 0) 
    {
        DWORD dwErr = ERROR_INVALID_PARAMETER;

        switch (lRes) 
        {

            case LINEERR_REINIT:
                dwErr = ERROR_BUSY;
                break;

            case LINEERR_RESOURCEUNAVAIL:
            case LINEERR_NOMEM:
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
        }

        SetLastError(dwErr);
        return (FALSE);
    }
    
    ptlsTapiLink->bOpen = TRUE;
    ptlsTapiLink->bDevicePicked = FALSE;
    ptlsTapiLink->bModemSpeakerOff = FALSE;

    return (TRUE);
}

//+----------------------------------------------------------------------------
//
// Function:  CloseTapi
//
// Synopsis:  Helper function to clean up TAPI line.
//
// Arguments: TapiLinkageStruct *ptlsTapiLink - Our TAPI linkage struct
//
// Returns:   Nothing
//
// History:   nickball    Created Header    7/7/99
//
//+----------------------------------------------------------------------------

void CloseTapi(TapiLinkageStruct *ptlsTapiLink) 
{
    if (ptlsTapiLink->bOpen) 
    {
        ptlsTapiLink->bOpen = FALSE;
        ptlsTapiLink->pfnlineShutdown(ptlsTapiLink->hlaLine);
    }
}

//+----------------------------------------------------------------------------
//
// Function:  LinkToTapi
//
// Synopsis:  Encapsulates the calling of LinkToDll with the correct table of 
//            function names to be used therein with GetProcAddress
//
// Arguments: TapiLinkageStruct *ptlsTapiLink - The Tapi linkage struct to receive the function addresses
//            LPCTSTR pszTapi - The explicit name of the DLL  
//
// Returns:   BOOL - TRUE if fully linked
//
// History:   nickball    Created Header    12/31/97
//
//+----------------------------------------------------------------------------

BOOL LinkToTapi(TapiLinkageStruct *ptlsTapiLink, LPCSTR pszTapi) 
{
    BOOL bRet = FALSE;

    if (OS_NT)
    {
        static LPCSTR apszTapi[] = 
        {
            //
            //  Several of the Tapi Functions don't have W versions.  Use all the Unicode functions
            //  that we can however.
            //
            "lineInitialize", // no W version
            "lineNegotiateAPIVersion", // no W version
            "lineGetDevCapsW",
            "lineGetDevConfig",
            "lineShutdown", // no W version
            "lineTranslateAddressW",
            "lineTranslateDialogW",
            "lineGetTranslateCaps",
            "lineSetCurrentLocation",
            NULL
        };

        MYDBGASSERT(sizeof(ptlsTapiLink->apvPfnTapi)/sizeof(ptlsTapiLink->apvPfnTapi[0])==sizeof(apszTapi)/sizeof(apszTapi[0]));
        bRet = LinkToDll(&ptlsTapiLink->hInstTapi,pszTapi,apszTapi,ptlsTapiLink->apvPfnTapi);    
    }
    else
    {
        static LPCSTR apszTapi[] = 
        {
            "lineInitialize",
            "lineNegotiateAPIVersion",
            "lineGetDevCaps",
            "lineGetDevConfig",
            "lineShutdown",
            "lineTranslateAddress",
            "lineTranslateDialog",
            "lineGetTranslateCaps",
            "lineSetCurrentLocation",
            NULL
        };
        MYDBGASSERT(sizeof(ptlsTapiLink->apvPfnTapi)/sizeof(ptlsTapiLink->apvPfnTapi[0])==sizeof(apszTapi)/sizeof(apszTapi[0]));
        bRet = LinkToDll(&ptlsTapiLink->hInstTapi,pszTapi,apszTapi,ptlsTapiLink->apvPfnTapi);    
    }

    return bRet;
}



//+----------------------------------------------------------------------------
//
// Function:  UnlinkFromTapi
//
// Synopsis:  Helper function to release link to TAPI and clear linkage struct
//
// Arguments: TapiLinkageStruct *ptlsTapiLink - Ptr to our TAPI linkage struct
//
// Returns:   Nothing
//
// History:   nickball    Created Header    7/7/99
//            
//            t-urama     Modified          08/04/00 Access Points: Restore Tapi 
//                                                   location when CM was started
//+----------------------------------------------------------------------------

void UnlinkFromTapi(TapiLinkageStruct *ptlsTapiLink) 
{
    if (ptlsTapiLink->hInstTapi) 
    {
        //
        // If we changed the original Tapi location, restore it
        //
        if (-1 != ptlsTapiLink->dwOldTapiLocation)
        {
            RestoreOldTapiLocation(ptlsTapiLink);
        }

        CloseTapi(ptlsTapiLink);
        
        FreeLibrary(ptlsTapiLink->hInstTapi);
        
        memset(ptlsTapiLink,0,sizeof(*ptlsTapiLink));
    }
}

LPTSTR GetModemFromLineDevCapsWithAlloc(LPLINEDEVCAPS pldcLineDevCaps)
{
    LPTSTR pszTmp = NULL;

    if (OS_NT)
    {
        pszTmp = (LPTSTR) CmMalloc((pldcLineDevCaps->dwLineNameSize + 1)*sizeof(TCHAR));

        if (pszTmp)
        {
            LPTSTR pszPointerIntoTapiBuffer = LPTSTR((DWORD_PTR)pldcLineDevCaps + pldcLineDevCaps->dwLineNameOffset);
            lstrcpynU (pszTmp, pszPointerIntoTapiBuffer, pldcLineDevCaps->dwLineNameSize + 1);
        }    
    }
    else
    {
        //
        //  If this is Win9x, then we have an Ansi buffer that we need to convert to Unicode
        //
        LPSTR pszAnsiTmp = (LPSTR) CmMalloc((pldcLineDevCaps->dwLineNameSize + 1)*sizeof(CHAR));

        if (pszAnsiTmp)
        {
            LPSTR pszPointerIntoTapiBuffer = LPSTR((DWORD_PTR)pldcLineDevCaps + pldcLineDevCaps->dwLineNameOffset);
            lstrcpynA (pszAnsiTmp, pszPointerIntoTapiBuffer, pldcLineDevCaps->dwLineNameSize + 1);

            pszTmp = SzToWzWithAlloc(pszAnsiTmp);

            CmFree(pszAnsiTmp);
        }
    
    }

    return pszTmp;
}

BOOL SetTapiDevice(HINSTANCE hInst, 
                   TapiLinkageStruct *ptlsTapiLink, 
                   LPCTSTR pszModem) 
{
    BOOL bRet = TRUE;
    LONG lRes;
    DWORD dwTmp;
    LPLINEDEVCAPS pldcLineDevCaps;

    if (!OpenTapi(hInst,ptlsTapiLink)) 
    {
        return (FALSE);
    }
    
    if (ptlsTapiLink->bDevicePicked && (lstrcmpU(ptlsTapiLink->szDeviceName, pszModem) == 0)) 
    {
        return (TRUE);
    }
    
    CMTRACE1(TEXT("SetTapiDevice() looking for device name match with (%s)."), pszModem);

    ptlsTapiLink->bDevicePicked = FALSE;

    //
    //  LineGetDevCaps has both an Ansi version (win9x) and a Unicode version.  Thus we must use
    //  the correct char size as needed.
    //
    dwTmp = sizeof(LINEDEVCAPS) + (2048 * (OS_NT ? sizeof(WCHAR) : sizeof(CHAR)));
    
    pldcLineDevCaps = (LPLINEDEVCAPS) CmMalloc(dwTmp);
    if (NULL == pldcLineDevCaps)
    {
        return FALSE;
    }
    pldcLineDevCaps->dwTotalSize = dwTmp;

    for (ptlsTapiLink->dwDeviceId=0; ptlsTapiLink->dwDeviceId < ptlsTapiLink->dwDevCnt; ptlsTapiLink->dwDeviceId++) 
    {
        LINEEXTENSIONID leiLineExtensionId;

        lRes = ptlsTapiLink->pfnlineNegotiateAPIVersion(ptlsTapiLink->hlaLine,
                                                         ptlsTapiLink->dwDeviceId,
                                                         MIN_TAPI_VERSION,
                                                         MAX_TAPI_VERSION,
                                                         &ptlsTapiLink->dwApiVersion,
                                                         &leiLineExtensionId);

        CMTRACE3(TEXT("******* SetTapiDevice() lineNegotiateAPIVersion(dwDeviceId=%u) returns %u, dwApiVersion=0x%x."), 
            ptlsTapiLink->dwDeviceId, lRes, ptlsTapiLink->dwApiVersion);
    
        if (lRes == ERROR_SUCCESS) 
        {
            lRes = ptlsTapiLink->pfnlineGetDevCaps(ptlsTapiLink->hlaLine,
                                                    ptlsTapiLink->dwDeviceId,
                                                    ptlsTapiLink->dwApiVersion,
                                                    0,
                                                    pldcLineDevCaps);

            CMTRACE2(TEXT("SetTapiDevice() lineGetDevCaps(dwDeviceId=%u) returns %u."), 
                ptlsTapiLink->dwDeviceId, lRes);
            
            if (lRes == ERROR_SUCCESS) 
            {
                //
                // Copy out the device name according to reported offset and 
                // length. Don't assume that its a NULL terminated string.
                //
                LPTSTR pszTmp = GetModemFromLineDevCapsWithAlloc(pldcLineDevCaps);

                if (pszTmp)
                {
                    //
                    //  Okay, we have a device name from TAPI, first try to do a straight
                    //  comparision with the one we are looking for
                    //

                    CMTRACE1(TEXT("SetTapiDevice() - examining LineName of (%s)."), pszTmp); 
                    
                    if (0 == lstrcmpU(pszModem, pszTmp))
                    {
                        ptlsTapiLink->bDevicePicked = TRUE;
                    }
                    else
                    {
                        //
                        //  We didn't find a straight match but that doesn't mean that
                        //  this isn't our device.  On NT, RAS keeps its device names in ANSI
                        //  internally.  Thus we can try roundtripping the string to MBCS and
                        //  back and see if they match now.  Another possibility is that this
                        //  is an ISDN device, because on NT4 the RAS name and TAPI name are
                        //  different for ISDN devices.  So, instead of checking the LineName
                        //  we should check the ProviderInfo (it is concatenation of two NULL terminated strings
                        //  and the second string is the used by RAS as device name)
                        //
                        if (OS_NT)
                        {
                            DWORD dwSize = WzToSz(pszTmp, NULL, 0); // cannot use WzToSzWithAlloc or we would get asserts
                                                                    // that the string didn't roundtrip on debug builds.
                                                                    // The point here is not to have it round trip so 
                                                                    // that is what we want but we don't want to assert.

                            if (0 != dwSize)
                            {
                                LPSTR pszAnsiTmp = (LPSTR)CmMalloc(dwSize*sizeof(CHAR));

                                if (pszAnsiTmp)
                                {
                                    if (WzToSz(pszTmp, pszAnsiTmp, dwSize))
                                    {
                                       LPWSTR pszRoundTripped = SzToWzWithAlloc(pszAnsiTmp);

                                        if (pszRoundTripped)
                                        {
                                            if (0 == lstrcmpU(pszModem, pszRoundTripped))
                                            {
                                                ptlsTapiLink->bDevicePicked = TRUE;
                                            }
                                        }
                                        CmFree(pszRoundTripped);
                                    }
                                    CmFree(pszAnsiTmp);
                                }
                            }

                            //
                            //  Okay, check for an ISDN device name if it is one
                            //
                            if (!ptlsTapiLink->bDevicePicked)
                            {
                                //
                                // Copy out the provider info according to reported offset  
                                // and length. Don't assume that its NULL terminated.
                                //
                                CmFree(pszTmp);
                                pszTmp = (LPTSTR) CmMalloc((pldcLineDevCaps->dwProviderInfoSize + 1)*sizeof(TCHAR));
                    
                                if (pszTmp)
                                {                       
                                    lstrcpynU(pszTmp, (LPTSTR)((LPBYTE)pldcLineDevCaps + pldcLineDevCaps->dwProviderInfoOffset), (pldcLineDevCaps->dwProviderInfoSize + 1));

                                    //
                                    // We should do this only if the device type is ISDN
                                    // The device type is the first string in the ProviderInfo
                                    //

                                    CMTRACE1(TEXT("SetTapiDevice() - examining ProviderInfo of (%s) for match with (RASDT_Isdn)."), pszTmp); 
                        
                                    if (0 == lstrcmpiU(pszTmp, RASDT_Isdn))
                                    {
                                        ptlsTapiLink->bDevicePicked = TRUE;
                                    }
                                }                    
                            }
                        }
                    }
                }

                //
                //  If we found a device, then we need to copy the name over
                //
                if (ptlsTapiLink->bDevicePicked)
                {
                    lstrcpynU(ptlsTapiLink->szDeviceName, pszModem, CELEMS(ptlsTapiLink->szDeviceName));

                    if (OS_NT)
                    {
                        dwTmp = GetModemSpeakerMode(ptlsTapiLink);
        
                        if (-1 != dwTmp && MDMSPKR_OFF == dwTmp)
                        {
                            ptlsTapiLink->bModemSpeakerOff = TRUE;
                        }
                    }

                    //
                    //  We found a device, stop looking...
                    //
                    CmFree(pszTmp);
                    break;
                }

                CmFree(pszTmp);
            }
        }
    }
    
    CmFree(pldcLineDevCaps);
    bRet = ptlsTapiLink->bDevicePicked;

    return bRet;
}

//+----------------------------------------------------------------------------
//
// Function:  GetModemSpeakerMode
//
// Synopsis:  Queries Modem settings for Speaker modeof a modem device.
//
// Arguments: TapiLinkageStruct *ptlsTapiLink - Ptr to TAPI linkage 
//
// Returns:   DWORD - The speaker mode for a valid modem device or 0xFFFFFFFF 
//
// History:   nickball    Created     7/7/99
//
//+----------------------------------------------------------------------------
DWORD GetModemSpeakerMode(TapiLinkageStruct *ptlsTapiLink)
{   
    DWORD dwRet = -1;

    LPVARSTRING lpVar = (LPVARSTRING) CmMalloc(sizeof(VARSTRING));

    //
    // Get the required buffer size by querying the config.
    //

    if (lpVar)
    {
        lpVar->dwTotalSize = sizeof(VARSTRING);
        lpVar->dwUsedSize = lpVar->dwTotalSize;

        DWORD dwRet = ptlsTapiLink->pfnlineGetDevConfig(ptlsTapiLink->dwDeviceId, lpVar, "comm/datamodem/dialout"); 

        if (LINEERR_STRUCTURETOOSMALL == dwRet || lpVar->dwNeededSize > lpVar->dwTotalSize)
        {
            //
            // We need a bigger buffer, re-allocate
            // 

            DWORD dwTmp = lpVar->dwNeededSize;

            CmFree(lpVar);
            lpVar = (LPVARSTRING) CmMalloc(dwTmp);                                             
        
            if (lpVar)
            {
                lpVar->dwTotalSize = dwTmp;
                lpVar->dwUsedSize = lpVar->dwTotalSize;

                //
                // Now get the actual config
                //

                dwRet = ptlsTapiLink->pfnlineGetDevConfig(ptlsTapiLink->dwDeviceId, lpVar, "comm/datamodem/dialout"); 

                if (ERROR_SUCCESS != dwRet)
                {
                    CmFree(lpVar);
                    lpVar = NULL;
                }
            }
        }
    }                        
    
    //
    // If we don't have a valid VARSTRING something failed, error out.
    //

    if (NULL == lpVar)
    {
        return -1;                                                
    }
    
    //
    // We have a VARSTRING for the "dialout" config, 
    // get the MODEMSETTINGS info. and see how the
    // modem speaker is configured.
    //

    PUMDEVCFG       lpDevConfig = NULL;
    LPCOMMCONFIG    lpCommConfig    = NULL;
    LPMODEMSETTINGS lpModemSettings = NULL;

    if (lpVar->dwStringFormat == STRINGFORMAT_BINARY && 
        lpVar->dwStringSize >= sizeof(UMDEVCFG))
    {
        lpDevConfig = (PUMDEVCFG) 
            ((LPBYTE) lpVar + lpVar->dwStringOffset);

        lpCommConfig = &lpDevConfig->commconfig;

        //
        // Check modems only
        //

        if (lpCommConfig->dwProviderSubType == PST_MODEM)
        {
            lpModemSettings = (LPMODEMSETTINGS)((LPBYTE) lpCommConfig + 
                                    lpCommConfig->dwProviderOffset);

            dwRet = lpModemSettings->dwSpeakerMode;           
        }                                                
    }

    CmFree(lpVar);

    return dwRet;
}


//+----------------------------------------------------------------------------
//
// Func:    MungePhone
//
// Desc:    call TAPI to do phone dial info translation
//
// Args:    [pszModem]      - IN, modem string
//          [ppszPhone]     - INOUT, phone number for display
//          [ptlsTapiLink]  - IN, argument string for connect action
//          [hInst]         - IN, instance handle (needed to call TAPI)
//          [fDialingRules] - are dialing rules enabled
//          [ppszDial]      - OUT, dialable phone number
//          [fAccessPointsEnabled] - IN, are access points enabled
// Return:  LRESULT
//
// Notes:   
//
// History: 01-Mar-2000   SumitC      Added header block
//          04-Mar-2000   SumitC      fixed case for dialing rules not enabled
//          04-Aug-2000   t-urama     Added changing the TAPI location based on access point
//
//-----------------------------------------------------------------------------

LRESULT MungePhone(LPCTSTR pszModem, 
                   LPTSTR *ppszPhone, 
                   TapiLinkageStruct *ptlsTapiLink, 
                   HINSTANCE hInst, 
                   BOOL fDialingRules,
                   LPTSTR *ppszDial,
                   BOOL fAccessPointsEnabled)
{

    LPLINETRANSLATEOUTPUT pltoOutput = NULL;
    DWORD dwLen;
    LPWSTR pszDisplayable = NULL;
    LPWSTR pszDialable = NULL;
    LPSTR pszAnsiDisplayable = NULL;
    LPSTR pszAnsiDialable = NULL;
    LPTSTR pszOriginalPhoneNumber = NULL;
    LRESULT lRes = ERROR_INVALID_PARAMETER;

    //
    //  Check the input params.  Note that ppszDial could be NULL.
    //
    if ((NULL == pszModem) || (NULL == ppszPhone) || (NULL == *ppszPhone) || (NULL == ptlsTapiLink) || (NULL == hInst))
    {
        lRes =  ERROR_INVALID_PARAMETER;
        CMASSERTMSG(FALSE, TEXT("MungePhone - invalid param."));
        goto done;
    }
    
    if (!SetTapiDevice(hInst, ptlsTapiLink, pszModem)) 
    {
        lRes = ERROR_NOT_FOUND;
        goto done;
    }

    if (FALSE == fDialingRules)
    {
        pszOriginalPhoneNumber = CmStrCpyAlloc(*ppszPhone);
    }
    
    if (TRUE == fDialingRules)
    {
        if (fAccessPointsEnabled)
        {
            //
            // Access Points are enabled. we now have to change the TAPI location 
            // to that of the current access point. First get the current TAPI 
            // location from TAPI
            //

            DWORD dwRet = GetCurrentTapiLocation(ptlsTapiLink);
            if (-1 == dwRet)
            {
                lRes = ERROR_NOT_FOUND;
                goto done;
            }

            if ((0 != ptlsTapiLink->dwTapiLocationForAccessPoint) && (dwRet != ptlsTapiLink->dwTapiLocationForAccessPoint))
            {
                //
                // The current TAPI location is different from the access point TAPI location
                // Change it.  Note that if the current TAPI location is 0, this just means we haven't written
                // one for the favorite yet.  Don't try to change it as SetCurrentTapiLocation will error out.
                //

                lRes = SetCurrentTapiLocation(ptlsTapiLink, ptlsTapiLink->dwTapiLocationForAccessPoint);
            
                if (lRes != ERROR_SUCCESS)
                {
                    CMASSERTMSG(FALSE, TEXT("MungePhone -- unable to set the current TAPI location."));
                    goto done;
                }

                CMTRACE1(TEXT("MungePhone() - Changed TAPI location to %u."), ptlsTapiLink->dwTapiLocationForAccessPoint);

                //
                // Save the TAPI location that was being used when CM started. 
                // This will be restored when CM exits
                //
                if (-1 == ptlsTapiLink->dwOldTapiLocation) 
                {
                    ptlsTapiLink->dwOldTapiLocation = dwRet;
                    CMTRACE1(TEXT("Saved TAPI location used when CM started, location is %d"), ptlsTapiLink->dwOldTapiLocation);
                }
            }
        }
    }
 
    //
    // Setup buffer for output, make sure to size the CHARs properly
    //
    dwLen = sizeof(*pltoOutput) + (1024 * (OS_NT ? sizeof(WCHAR) : sizeof(CHAR)));

    pltoOutput = (LPLINETRANSLATEOUTPUT) CmMalloc(dwLen);
    if (NULL == pltoOutput)
    {
        lRes = ERROR_NOT_ENOUGH_MEMORY;
        goto done;
    }
    pltoOutput->dwTotalSize = dwLen;

    //
    // Do the translation
    //

    if (OS_NT)
    {
        lRes = ptlsTapiLink->pfnlineTranslateAddress(ptlsTapiLink->hlaLine,
                                                     ptlsTapiLink->dwDeviceId,
                                                     ptlsTapiLink->dwApiVersion,
                                                     *ppszPhone,
                                                     0,
                                                     LINETRANSLATEOPTION_CANCELCALLWAITING,
                                                     pltoOutput);
    }
    else
    {
        LPSTR pszAnsiPhone = WzToSzWithAlloc(*ppszPhone);

        if (pszAnsiPhone)
        {
            //
            // Note that the Cast on parameter 4 is to fake out the compiler, 
            // rather than building a full set of "U" infrastructure for
            // the tapi linkage when only a couple of TAPI calls take strings.
            //
            
            lRes = ptlsTapiLink->pfnlineTranslateAddress(ptlsTapiLink->hlaLine,
                                                         ptlsTapiLink->dwDeviceId,
                                                         ptlsTapiLink->dwApiVersion,
                                                         (LPWSTR)pszAnsiPhone, 
                                                         0,
                                                         LINETRANSLATEOPTION_CANCELCALLWAITING,
                                                         pltoOutput);
        }

        CmFree(pszAnsiPhone);
    }

    CMTRACE3(TEXT("MungePhone(Modem=%s,Phone=%s) lineTranslateAddress(DeviceId=%u)"),
             MYDBGSTR(pszModem), MYDBGSTR(*ppszPhone), ptlsTapiLink->dwDeviceId);
    CMTRACE1(TEXT("\treturns %u."), lRes);

    if (lRes == ERROR_SUCCESS)
    {    
        //
        // Get ptrs to displayable and dialable variations
        //
        LPBYTE pBase = (LPBYTE) pltoOutput;

        if (OS_NT)
        {
            pszDisplayable = (LPTSTR) (pBase + pltoOutput->dwDisplayableStringOffset);
            pszDialable = (LPTSTR) (pBase + pltoOutput->dwDialableStringOffset);
        }
        else
        {
            pszAnsiDisplayable = (LPSTR)(pBase + pltoOutput->dwDisplayableStringOffset);
            pszAnsiDialable = (LPSTR)(pBase + pltoOutput->dwDialableStringOffset);
        }
    }

done:
    CmFree(*ppszPhone);
    *ppszPhone = NULL;
    if (ppszDial) 
    {
        CmFree(*ppszDial);
        *ppszDial = NULL;
    }
    
    // Allocate buffers using the ptr ptrs specified by the caller 
    // and fill them with the displayable and dialable versions
    

    if (ERROR_SUCCESS == lRes) 
    {
        if (OS_NT)
        {
            if (fDialingRules)
            {
                *ppszPhone = CmStrCpyAlloc(pszDisplayable);
            }
            else
            {
                *ppszPhone = CmStrCpyAlloc(pszOriginalPhoneNumber);
            }
        }
        else
        {
            if (fDialingRules)
            {
                *ppszPhone = SzToWzWithAlloc(pszAnsiDisplayable);
            }
            else
            {
                *ppszPhone = CmStrCpyAlloc(pszOriginalPhoneNumber);
            }
        }
        
        MYDBGASSERT(*ppszPhone);
        if (*ppszPhone)
        {
            //
            // TAPI prepends a space, so trim the displayable number.
            // 
            CmStrTrim(*ppszPhone);
            SingleSpace(*ppszPhone, (lstrlenU(*ppszPhone) + 1));
        }
        else
        {
            //
            //  If we failed to alloc *ppszPhone, continue because we don't
            //  depend on it below but we want the return code to be a failure.
            //
            lRes = ERROR_NOT_ENOUGH_MEMORY;
        }

        if (ppszDial) 
        {
            if (OS_NT)
            {
                if (fDialingRules)
                {
                    *ppszDial = CmStrCpyAlloc(pszDialable);
                }
                else
                {
                    UINT uLen = 2 + lstrlenU(pszOriginalPhoneNumber);// 2 == one for NULL term and one for first char of pszDialable

                    *ppszDial = (LPTSTR) CmMalloc(sizeof(TCHAR)*uLen); 

                    if (*ppszDial)
                    {
                        (*ppszDial)[0] = pszDialable[0];

                        lstrcpynU((*ppszDial + 1), pszOriginalPhoneNumber, uLen - 1);
                    }
                }
            }
            else
            {
                if (fDialingRules)
                {
                    *ppszDial = SzToWzWithAlloc(pszAnsiDialable);
                }
                else
                {
                    UINT uLen = 2 + lstrlenU(pszOriginalPhoneNumber);// 2 == one for NULL term and one for first char of pszDialable

                    *ppszDial = (LPTSTR) CmMalloc(sizeof(TCHAR)*uLen); 

                    if (*ppszDial)
                    {
                        int lRet = MultiByteToWideChar(CP_ACP, 0, pszAnsiDialable, 1, *ppszDial, 1);

                        lstrcpynU((*ppszDial + lRet), pszOriginalPhoneNumber, uLen - lRet);

                    }
                }
            }
        }
    }

    if (FALSE == fDialingRules)
    {
        CmFree(pszOriginalPhoneNumber);
    }
    CmFree(pltoOutput);
    return (lRes);
}

//+----------------------------------------------------------------------------
//
// Func:    GetCurrentTapiLocation
//
// Desc:    get the current Tapi location
//
// Args:    [ptlsTapiLink]  - IN, Ptr to TAPI linkage
//          
// Return:  DWORD dwCurrentLoc - Current Tapi Location
//
// Notes:   
//
// History: t-urama     07/21/2000  Created 
//-----------------------------------------------------------------------------

DWORD GetCurrentTapiLocation(TapiLinkageStruct *ptlsTapiLink)
{
    MYDBGASSERT(ptlsTapiLink->pfnlineGetTranslateCaps);
    if (!ptlsTapiLink->pfnlineGetTranslateCaps)
    {
        SetLastError(ERROR_PROC_NOT_FOUND);
        return (-1);
    }

    LPLINETRANSLATECAPS lpTranslateCaps = NULL;
    DWORD dwLen;
    LRESULT lRes;
    DWORD dwRes = -1;

    dwLen = sizeof(*lpTranslateCaps) + (1024 * (OS_NT ? sizeof(WCHAR) : sizeof(CHAR)));

    do
    {
        CmFree(lpTranslateCaps);
        lpTranslateCaps = (LPLINETRANSLATECAPS) CmMalloc(dwLen);
        MYDBGASSERT(lpTranslateCaps);
        if (NULL == lpTranslateCaps)
        {
            lRes = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
        lpTranslateCaps->dwTotalSize = dwLen;
        lRes = ptlsTapiLink->pfnlineGetTranslateCaps(ptlsTapiLink->hlaLine,                   
                                                    ptlsTapiLink->dwApiVersion,                  
                                                    lpTranslateCaps);
        if (LINEERR_STRUCTURETOOSMALL == lRes)
        {
            dwLen = lpTranslateCaps->dwNeededSize;
        }

    } while(LINEERR_STRUCTURETOOSMALL == lRes);

    if (ERROR_SUCCESS != lRes)
    {
        CMTRACE1(TEXT("lineGetTranslateCaps returns error code %u."), lRes);
    }
    else
    {
        dwRes = lpTranslateCaps->dwCurrentLocationID;
    }
    CmFree(lpTranslateCaps);
    return dwRes;
}

//+----------------------------------------------------------------------------
//
// Func:    SetCurrentTapiLocation
//
// Desc:    Set the current Tapi location
//
// Args:    TapiLinkageStruct *ptlsTapiLink  - Ptr to TAPI linkage
//          DWORD dwLocation - New location
//
// Return:  DWORD - Error code
//
// Notes:   
//
// History: t-urama     07/21/2000  Created
//-----------------------------------------------------------------------------

DWORD SetCurrentTapiLocation(TapiLinkageStruct *ptlsTapiLink, DWORD dwLocation)
{
    MYDBGASSERT(ptlsTapiLink->pfnlineSetCurrentLocation);
    if (!ptlsTapiLink->pfnlineSetCurrentLocation)
    {
        SetLastError(ERROR_PROC_NOT_FOUND);
        return (-1);
    }

    DWORD dwRes = 0;
    dwRes = ptlsTapiLink->pfnlineSetCurrentLocation(ptlsTapiLink->hlaLine, dwLocation);                  

    return dwRes;
}

//+----------------------------------------------------------------------------
//
// Func:    RestoreOldTapiLocation
//
// Desc:    Restore the Tapi location to the one when CM was started
//
// Args:    TapiLinkageStruct *ptlsTapiLink  - IN, Ptr to TAPI linkage
//
// Return:  Nothing
//
// Notes:   
//
// History: t-urama     07/21/2000  Created
//-----------------------------------------------------------------------------
                                                     
void RestoreOldTapiLocation(TapiLinkageStruct *ptlsTapiLink)
{
    if (ptlsTapiLink->dwOldTapiLocation != ptlsTapiLink->dwTapiLocationForAccessPoint)
    {
        SetCurrentTapiLocation(ptlsTapiLink, ptlsTapiLink->dwOldTapiLocation);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmdial\wsock.cpp ===
//+----------------------------------------------------------------------------
//
// File:     wsock.cpp     
//
// Module:   CMDIAL32.DLL
//
// Synopsis: This module contains the winsock related CM code.
//
// Copyright (c) 1996-1999 Microsoft Corporation
//
// Author:   henryt     created         03/??/98
//           quintinb	created Header	08/16/99
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"
#include "winsock.h"
#include "tunl_str.h"

///////////////////////////////////////////////////////////////////////////////////
// define's
///////////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////////
// typedef's
///////////////////////////////////////////////////////////////////////////////////

typedef int (PASCAL FAR *PFN_WSAStartup)(WORD, LPWSADATA);
typedef int (PASCAL FAR *PFN_WSACleanup)(void);
typedef struct hostent FAR * (PASCAL FAR *PFN_gethostbyname)(const char FAR * name);

///////////////////////////////////////////////////////////////////////////////////
// func prototypes
///////////////////////////////////////////////////////////////////////////////////

BOOL InvokeGetHostByName(
    ArgsStruct  *pArgs
);

BOOL BuildDnsTunnelList(
    ArgsStruct      *pArgs,
    struct hostent  *pHe
);

BOOL BuildRandomTunnelIndex(
    ArgsStruct      *pArgs,
    DWORD           dwCount
);

///////////////////////////////////////////////////////////////////////////////////
// Implementation
///////////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
//	Function:	TryAnotherTunnelDnsAddress
//
//	Synopsis:	see if there's another dns address associated with the current
//              tunnel name.  if so, set that address in primary or extended
//              tunnel ip properly.
//
//	Arguments:	pArgs               ptr to ArgsStruct
//
//	Returns:	TRUE    if SUCCESS
//              FALSE   otherwise.
//
//----------------------------------------------------------------------------

BOOL TryAnotherTunnelDnsAddress(
    ArgsStruct  *pArgs
)
{
    MYDBGASSERT(pArgs);

    //
    // RAS does all this for us on NT5, so bail out now.
    //

    if (NULL == pArgs || OS_NT5)
    {
        return FALSE;
    }

    //
    // if the list of tunnel ip addrs is empty, let's resolve the dns name
    // and see if there are other addrs behind the dns name.
    //
    if (!pArgs->pucDnsTunnelIpAddr_list)
    {
        if (!InvokeGetHostByName(pArgs))
        {
            return FALSE;
        }
    }

    MYDBGASSERT(pArgs->pucDnsTunnelIpAddr_list);

    if (pArgs->uiCurrentDnsTunnelAddr == pArgs->dwDnsTunnelAddrCount - 1)
    {
        //
        // we've run out of addrs in the list.
        //

        //
        // we need to destroy the list
        //
        CmFree(pArgs->pucDnsTunnelIpAddr_list);
        pArgs->pucDnsTunnelIpAddr_list = NULL;

        CmFree(pArgs->rgwRandomDnsIndex);
        pArgs->rgwRandomDnsIndex = NULL;

        pArgs->uiCurrentDnsTunnelAddr = 0;
        pArgs->dwDnsTunnelAddrCount = 0;

        //
        // If we're currently using the primary tunnel server, we need to 
        // restore it since we overwrote it.
        //

        LPTSTR pszTunnelIp = pArgs->piniBothNonFav->GPPS(c_pszCmSection, c_pszCmEntryTunnelAddress);

        if (lstrlenU(pszTunnelIp) > RAS_MaxPhoneNumber) 
        {
            pszTunnelIp[0] = TEXT('\0');
        }

        pArgs->SetPrimaryTunnel(pszTunnelIp);
        CmFree(pszTunnelIp);

        return FALSE;
    }

    //
    // try the next ip addr in the list
    //
    TCHAR   szAddr[16];     // xxx.xxx.xxx.xxx
    unsigned char *puc;

    pArgs->uiCurrentDnsTunnelAddr++;

    puc = pArgs->pucDnsTunnelIpAddr_list + pArgs->rgwRandomDnsIndex[pArgs->uiCurrentDnsTunnelAddr]*4;

    wsprintfU(szAddr, TEXT("%hu.%hu.%hu.%hu"),
             *puc,
             *(puc+1),
             *(puc+2),
             *(puc+3));

    CMTRACE1(TEXT("TryAnotherTunnelDnsAddress: found ip addr %s for the tunnel server"), szAddr);

    pArgs->SetPrimaryTunnel(szAddr);
    return TRUE;
}

//+---------------------------------------------------------------------------
//
//	Function:	InvokeGetHostByName
//
//	Synopsis:	call gethostbyname and sets up internal ipaddr list.
//
//	Arguments:	pArgs               ptr to ArgsStruct
//
//	Returns:	TRUE    if SUCCESS
//              FALSE   otherwise.
//
//----------------------------------------------------------------------------
BOOL InvokeGetHostByName(
    ArgsStruct  *pArgs
)
{
    HINSTANCE           hInst;
    PFN_WSAStartup      pfnWSAStartup;
    PFN_WSACleanup      pfnWSACleanup = NULL;
    PFN_gethostbyname   pfngethostbyname;
    WSADATA             wsaData;
    struct hostent      *pHe;
    BOOL                fOk = FALSE;
#ifdef UNICODE
    LPSTR pszHostName;
    DWORD dwSize;
#endif
    //
    // the list's gotta be empty
    //
    MYDBGASSERT(!pArgs->pucDnsTunnelIpAddr_list);

    MYVERIFY(hInst = LoadLibraryExA("wsock32.dll", NULL, 0));

    if (!hInst) 
    {
        return FALSE;
    }

    if (!(pfnWSAStartup = (PFN_WSAStartup)GetProcAddress(hInst, "WSAStartup")))
    {
        goto exit;
    }

    if (pfnWSAStartup(MAKEWORD(1, 1), &wsaData))
    {
        goto exit;
    }

    pfnWSACleanup = (PFN_WSACleanup)GetProcAddress(hInst, "WSACleanup");

    if (!(pfngethostbyname = (PFN_gethostbyname)GetProcAddress(hInst, "gethostbyname")))
    {
        goto exit;
    }

#ifdef UNICODE

    pszHostName = WzToSzWithAlloc(pArgs->GetTunnelAddress());

    if (pszHostName)
    {
        pHe = pfngethostbyname(pszHostName);
        CmFree(pszHostName);

        if (!pHe)
        {
            goto exit;
        }
    }
    else
    {
        goto exit;
    }

#else
    if (!(pHe = pfngethostbyname(pArgs->GetTunnelAddress())))
    {
        goto exit;
    }
#endif

    if (BuildDnsTunnelList(pArgs, pHe))
    {
        fOk = TRUE;
    }

exit:

    if (pfnWSACleanup)
    {
        pfnWSACleanup();
    }

    if (hInst)
    {
        FreeLibrary(hInst);
    }

    return fOk;
}



//+---------------------------------------------------------------------------
//
//	Function:	BuildDnsTunnelList
//
//	Synopsis:	Build a tunnel address list.
//
//	Arguments:	pArgs   ptr to ArgsStruct
//              pHe     a ptr to hostent(returned by gethostbyname()).
//
//	Returns:	TRUE    if SUCCESS
//              FALSE   otherwise.
//
//----------------------------------------------------------------------------
BOOL BuildDnsTunnelList(
    ArgsStruct      *pArgs,
    struct hostent  *pHe
)
{
    DWORD   dwCnt;

    //
    // see how many addrs we have
    //
    for (dwCnt=0; pHe->h_addr_list[dwCnt]; dwCnt++)
        ;

    if (dwCnt < 2)
    {
        return FALSE;
    }

    //
    // if we have more than one addrs, save the list.
    //
    pArgs->dwDnsTunnelAddrCount = dwCnt;

    if (!(pArgs->pucDnsTunnelIpAddr_list = (unsigned char *)CmMalloc(dwCnt*pHe->h_length)))
    {
        CMTRACE(TEXT("InvokeGetHostByName: failed to alloc tunnel addr list"));
        return FALSE;
    }

    for (dwCnt=0; dwCnt<pArgs->dwDnsTunnelAddrCount; dwCnt++)
    {
        CopyMemory(pArgs->pucDnsTunnelIpAddr_list + dwCnt*pHe->h_length,
                   pHe->h_addr_list[dwCnt],
                   pHe->h_length);
    }

    pArgs->uiCurrentDnsTunnelAddr = 0;

    //
    // we need a random list.  With this, we can get a random addr in constant
    // time(and fast).  see cmtools\getips.
    //
    if (!BuildRandomTunnelIndex(pArgs, dwCnt))
    {
        CmFree(pArgs->pucDnsTunnelIpAddr_list);
        pArgs->pucDnsTunnelIpAddr_list = NULL;
        return FALSE;
    }
    
    return TRUE;
}


//+---------------------------------------------------------------------------
//
//	Function:	BuildRandomTunnelIndex
//
//	Synopsis:	Build a list random indices.  With this, we can get a random 
//              addr in constant time(and fast).  see cmtools\getips.
//
//	Arguments:	pArgs   ptr to ArgsStruct
//              dwCount # of of indices
//
//	Returns:	TRUE    if SUCCESS
//              FALSE   otherwise.
//
//----------------------------------------------------------------------------

BOOL BuildRandomTunnelIndex(
    ArgsStruct      *pArgs,
    DWORD           dwCount
)
{
    DWORD   i, j;
    PWORD   rgwIndex;
    WORD    wTmp;

    //
    // we can only have at most 65536 ip addrs(the max. range of a WORD), which is plenty.
    //
    MYDBGASSERT((dwCount > 1) && (dwCount <= 65536));

    if (!(pArgs->rgwRandomDnsIndex = (PWORD)CmMalloc(sizeof(WORD)*dwCount)))
    {
        return FALSE;
    }

    //
    // now start build the random indices...
    //
    for (i=0, rgwIndex=pArgs->rgwRandomDnsIndex; i<dwCount; i++)
    {
        rgwIndex[i] = (WORD)i;
    }

#ifdef  DEBUG
    {
        unsigned char *puc;
        TCHAR   szAddr[16];     // xxx.xxx.xxx.xxx

        CMTRACE2(TEXT("BuildRandomTunnelIndex: BEFORE randomization(server=%s, count=%u):"), 
                 pArgs->GetTunnelAddress(), dwCount);
    
        for (i=0; i<dwCount; i++)
        {
            puc = pArgs->pucDnsTunnelIpAddr_list + i*4;
            wsprintfU(szAddr, TEXT("%hu.%hu.%hu.%hu"),
                     *puc,
                     *(puc+1),
                     *(puc+2),
                     *(puc+3));
            CMTRACE2(TEXT("%u: %s"), i, szAddr);
        }
    }
#endif

    //
    // If we only have 2 addrs, the first address has already been used by RAS, 
    // there's no need to randomize the list.  We'll just use the 2nd addr.
    //
    if (dwCount == 2)
    {
        return TRUE;
    }

    CRandom r;

    //
    // randomize the indices.  skip the first entry.
    //
    for (i=1; i<dwCount; i++)
    {
        do 
        {
            //
            // j has to be non-zero(to leave the 0-th entry untouhced).
            //
            j = r.Generate() % dwCount;
        } while (!j);

        if (i != j)
        {
            wTmp = rgwIndex[i];
            rgwIndex[i] = rgwIndex[j];
            rgwIndex[j] = wTmp;
        }
    }

#ifdef  DEBUG
    {
        unsigned char *puc;
        TCHAR   szAddr[16];     // xxx.xxx.xxx.xxx

        CMTRACE2(TEXT("BuildRandomTunnelIndex: AFTER randomization(server=%s, count=%u):"), 
                 pArgs->GetTunnelAddress(), dwCount);
    
        for (i=0; i<dwCount; i++)
        {
            puc = pArgs->pucDnsTunnelIpAddr_list + rgwIndex[i]*4;
            wsprintfU(szAddr, TEXT("%hu.%hu.%hu.%hu"),
                      *puc,
                      *(puc+1),
                      *(puc+2),
                      *(puc+3));
            CMTRACE2(TEXT("%u: %s"), i, szAddr);
        }
    }
#endif

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmdial\help\cmmgr32.h ===
/* Copyright (c) 1998 Microsoft Corporation */
/* Help ID mapping for Connection Manager 32-bit Help topics */
/* Help file = cmmgr32.hlp */
/* If you make a change to this file, be sure to notify your help author and/or your lead developer.*/


/* Topic that the Help button goes to */
#define ICM_TRB                     0001

/* Logon dialog */
#define IDH_LOGON_NAME              1002
#define IDH_LOGON_PSWD              1003
#define IDH_LOGON_NEW               4010
#define IDH_LOGON_DOMAIN            3090
#define IDH_LOGON_AUTOCONN          2006
#define IDH_LOGON_SVCMSG            1008
#define IDH_LOGON_CONNECT_STAT      1005
#define IDH_LOGON_CONNECT           1006
#define IDH_LOGON_PROPERTIES        1007
#define IDH_LOGON_CANCEL            1010
#define IDH_LOGON_SAVEPW            1012
#define IDH_LOGON_SAVEFORALL        1014
#define IDH_LOGON_SAVEFORME         1015

// Access Points --logon dialog - Help ID for the Accesspoints combo box
#define IDH_LOGON_ACCESSPOINTS      1013

/* Connections Status dialog box */
#define IDH_STATUS_DISCONNECT       1011

/* Connections Properties dialog--General tab */
#define IDH_GENERAL_ALREADY         8002
#define IDH_GENERAL_DIALTHIS        8003
#define IDH_GENERAL_PHONENUM        2000
#define IDH_GENERAL_PHONEBOOK       2001
#define IDH_GENERAL_PHONEBOOKB      2005
#define IDH_GENERAL_BACKUPNUM       2002
#define IDH_GENERAL_DIALRULE        2003
#define IDH_GENERAL_USE_DIAL_RULE   4020
#define IDH_GENERAL_USE_DIAL_RULEB  4021
#define IDH_GENERAL_CONNECT_MODEM   2004

// Access Points -- General tab
#define IDH_GENERAL_NEWAP           4022    // New button
#define IDH_GENERAL_DELETEAP        4023    // Delete button
#define IDH_GENERAL_ACCESSPOINTS    4024    // Access points combo box

/* Connection Properties dialog--Options tab */
#define IDH_OPTIONS_IDLEDIS         2010
#define IDH_OPTIONS_REDIAL          2020
#define IDH_OPTIONS_LOGGING         2030
#define IDH_OPTIONS_CLEAR_LOG       2040
#define IDH_OPTIONS_VIEW_LOG        2050

/* Connections Properties dialog--Internet Logon tab */
#define IDH_INTERNET_PASSWORD       2060
#define IDH_INTERNET_USER_NAME      2070
#define IDH_INTERNET_SAVEPASS       2080

/* Connection Properties dialog--VPN tab */
#define IDH_VPN_SELECTOR            2100

/* Phone Book dialog */
#define IDH_PHONEBOOK_SERVICETYP    3000
#define IDH_PHONEBOOK_COUNTRY       3001
#define IDH_PHONEBOOK_STATEREG      3002
#define IDH_PHONEBOOK_ACCESSNUMS    3003
#define IDH_PHONEBOOK_MORENUMS      3005
#define IDH_PHONEBOOK_SVCMSG        3006

/*Retry Dialog */
#define IDH_RETRY_REMEMBER          2501
#define IDH_RETRY_USERNAME_STATIC   2502
#define IDH_RETRY_USERNAME          2503
#define IDH_RETRY_PASSWORD_STATIC   2504
#define IDH_RETRY_PASSWORD          2505
#define IDH_RETRY_DOMAIN_STATIC     2506
#define IDH_RETRY_DOMAIN            2507
#define IDH_RETRY_OK                2508
#define IDH_RETRY_CANCEL            2509

/*Button IDs */
#define IDH_CMHELP                  4000
#define IDH_DETAILS                 6020
#define IDH_OK_CONNECTED            6030
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\cm\cmdial\util.cpp ===
//+----------------------------------------------------------------------------
//
// File:     util.cpp
//      
// Module:   CMDIAL32.DLL 
//
// Synopsis: Various utility functions
//
// Copyright (c) 1996-1999 Microsoft Corporation
//
// Author:   dondu      Created   01/01/96
//
//+----------------------------------------------------------------------------

#include "cmmaster.h"
#include "DynamicLib.h"
#include "profile_str.h"
#include "tunl_str.h"
#include "stp_str.h"
#include "dun_str.h"

#include "linkdll.cpp" // LinkToDll and BindLinkage

//
//  Get the common functions AddAllKeysInCurrentSectionToCombo
//  and GetPrivateProfileStringWithAlloc
//
#include "gppswithalloc.cpp"

const TCHAR* const c_pszTunnelName = TEXT(" Tunnel");
const TCHAR* const c_pszRegCurrentVersion       = TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion");
const TCHAR* const c_pszRegCsdVersion           = TEXT("CSDVersion");
const TCHAR* const c_pszIconMgrClass            = TEXT("IConnMgr Class");
const TCHAR* const c_pszCmEntryPasswordHandling     = TEXT("PasswordHandling"); 
//+----------------------------------------------------------------------------
//
// Function:  CmGetWindowTextAlloc
//
// Synopsis:  Retrieves the text of a control in a dialog, returning the text in
//            a block of allocated memory
//
// Arguments: HWND hwndDlg - The window that owns the control
//            UINT nCtrl - The ID of the control
//
// Returns:   LPTSTR - Ptr to buffer containing the window text
//
// History:   nickball    Created Header    4/1/98
//
//+----------------------------------------------------------------------------
LPTSTR CmGetWindowTextAlloc(HWND hwndDlg, UINT nCtrl) 
{
    HWND hwndCtrl = nCtrl ? GetDlgItem(hwndDlg, nCtrl) : hwndDlg;
    size_t nLen = GetWindowTextLengthU(hwndCtrl);
    LPTSTR pszRes = (LPTSTR)CmMalloc((nLen+2)*sizeof(TCHAR));

    if (pszRes)
    {
        GetWindowTextU(hwndCtrl, pszRes, nLen+1);
    }

    return (pszRes);
}

//+----------------------------------------------------------------------------
//
// Function:  ReducePathToRelative
//
// Synopsis:  Helper function, converts a full profile file path into a 
//            relative path.
//
// Arguments: ArgsStruct *pArgs     - Ptr to global Args struct
//            LPCTSTR pszFullPath   - The full path to the file
//            
//
// Returns:   LPTSTR - The relative path form or NULL
//
// Note:      The file to be reduced should exist and be located
//            in the profile directory
//
// History:   nickball    Created    8/12/98
//
//+----------------------------------------------------------------------------
LPTSTR ReducePathToRelative(ArgsStruct *pArgs, LPCTSTR pszFullPath)
{    
    MYDBGASSERT(pszFullPath);
    MYDBGASSERT(pArgs);

    if (NULL == pszFullPath || NULL == pArgs || FALSE == FileExists(pszFullPath))
    {
        return NULL;
    }
 
    //
    // Use CMS as base
    //

    LPTSTR pszReduced = CmStripPathAndExt(pArgs->piniService->GetFile()); 
    MYDBGASSERT(pszReduced);

    if (pszReduced)
    {
        //
        // Append the filename
        //
        
        pszReduced = CmStrCatAlloc(&pszReduced, TEXT("\\"));
        MYDBGASSERT(pszReduced);

        if (pszReduced)
        {
            LPTSTR pszFileName = StripPath(pszFullPath);
            MYDBGASSERT(pszFileName);    

            if (pszFileName)    
            {
                pszReduced = CmStrCatAlloc(&pszReduced, pszFileName);
                MYDBGASSERT(pszReduced);
                CmFree(pszFileName);
   
                if (pszReduced)
                {
                    return pszReduced;
                }
            }
        }
    }
    
    CmFree(pszReduced);
    return NULL;
}


// get service name from the service file
LPTSTR GetServiceName(CIni *piniService) 
{
    LPTSTR pszTmp;

    pszTmp = piniService->GPPS(c_pszCmSection,c_pszCmEntryServiceName);
    if (!*pszTmp) 
    {
        //
        // failed to get service name, then use base filename
        //
        CmFree(pszTmp);
        pszTmp = CmStripPathAndExt(piniService->GetFile());
        
        //
        // Do not write the entry back to .CMS file - #4849
        //
        // piniService->WPPS(c_pszCmSection, c_pszCmEntryServiceName, pszTmp);
    }
    return (pszTmp);
}

//+----------------------------------------------------------------------------
//
//  Function    GetTunnelSuffix
//
//  Synopsis    Returns an allocated string containing the tunnel suffix
//
//  Arguments   None
//
//  Returns     LPTSTR - Ptr to the suffix in its entirety, caller must free
//
//  History     06/14/99    nickball    Created
//
//-----------------------------------------------------------------------------
LPTSTR GetTunnelSuffix()
{    
    MYDBGASSERT(OS_W9X); // secondary connectoids only exist on 9X

    //
    // First copy the phrase " Tunnel", which is not localized
    // 

    LPTSTR pszSuffix = CmStrCpyAlloc(c_pszTunnelName); 
    
    //
    // Now retrieve the localizable phrase " (for advanced use only)"
    //
   
    if (pszSuffix)
    {
        LPTSTR pszTmp = CmLoadString(g_hInst, IDS_TUNNEL_SUFFIX);
        pszSuffix = CmStrCatAlloc(&pszSuffix, pszTmp);
        CmFree(pszTmp);
    }

    MYDBGASSERT(pszSuffix);

    return pszSuffix;
}

//+----------------------------------------------------------------------------
//
//  Function    GetDefaultDunSettingName
//
//  Synopsis    Get the default DUN name from the specified .CMS
//
//  Arguments   piniService - The service file object to be used.
//              fTunnel - Indicates if the profile is for tunneling
//
//  Returns     LPTSTR - Ptr to the DUN name
//
//  History     10/28/98    nickball    Created
//
//-----------------------------------------------------------------------------
LPTSTR GetDefaultDunSettingName(CIni* piniService, BOOL fTunnelEntry)
{
    //
    // Get the DUN name from the top level service file, ex: snowbird online service
    //

    LPTSTR pszTmp = NULL;
       
    if (fTunnelEntry)
    {
        pszTmp = piniService->GPPS(c_pszCmSection, c_pszCmEntryTunnelDun);
        MYDBGASSERT(pszTmp && *pszTmp); // CMAK writes this, it shouldn't be blank
    }
    else
    {
        pszTmp = piniService->GPPS(c_pszCmSection, c_pszCmEntryDun);
    }

    return (pszTmp);
}


//+----------------------------------------------------------------------------
//
//  Function    GetDunSettingName
//
//  Synopsis    Get the current DUN name
//
//  Arguments   pArgs - Ptr to ArgStruct
//              dwEntry - index of rasentry (ignored if fTunnel is true)
//              fTunnel - is this a VPN?
//
//  Returns     Dun setting name
//
//  History     01-Nov-2000   SumitC      Created
//
//-----------------------------------------------------------------------------
LPTSTR GetDunSettingName(ArgsStruct * pArgs, DWORD dwEntry, BOOL fTunnel)
{
    LPTSTR pszTmp = NULL;

    MYDBGASSERT(pArgs);
    MYDBGASSERT(fTunnel || (dwEntry <= 1));

    if (NULL == pArgs)
    {
        return NULL;
    }

    if (fTunnel)
    {
        pszTmp = pArgs->piniBothNonFav->GPPS(c_pszCmSection, c_pszCmEntryTunnelDun);
        MYDBGASSERT(pszTmp && *pszTmp); // CMAK writes this, it shouldn't be blank
        
        if (pszTmp && !*pszTmp)
        {
            // the "empty string" case
            CmFree(pszTmp);
            pszTmp = NULL;
        }
    }
    else
    {
        if (pArgs->aDialInfo[dwEntry].szDUN[0])
        {
            pszTmp = CmStrCpyAlloc(pArgs->aDialInfo[dwEntry].szDUN);
        }
        else
        {
            CIni * pIni = GetAppropriateIniService(pArgs, dwEntry);

            if (pIni)
            {
                pszTmp = pIni->GPPS(c_pszCmSection, c_pszCmEntryDun);
                delete pIni;
            }        
        }
    }

    if (NULL == pszTmp)
    {
        pszTmp = GetDefaultDunSettingName(pArgs->piniService, fTunnel);
    }

    return pszTmp;
}


//+----------------------------------------------------------------------------
//
//  Function    GetCMSforPhoneBook
//
//  Synopsis    Get the name of the .CMS file that contains the current phonebook
//
//  Arguments   pArgs - Ptr to ArgStruct
//              dwEntry - index of rasentry
//
//  Returns     phonebook filename (NULL if error or not found)
//
//  History     10-Nov-2000   SumitC      Created
//
//-----------------------------------------------------------------------------
LPTSTR GetCMSforPhoneBook(ArgsStruct * pArgs, DWORD dwEntry)
{
    LPTSTR pszTmp = NULL;

    MYDBGASSERT(pArgs);
    MYDBGASSERT(dwEntry <= 1);

    if (NULL == pArgs)
    {
        return NULL;
    }

    PHONEINFO * pPhoneInfo = &(pArgs->aDialInfo[dwEntry]);

    if (pPhoneInfo && pPhoneInfo->szPhoneBookFile[0])
    {
        LPTSTR pszFileName = CmStrrchr(pPhoneInfo->szPhoneBookFile, TEXT('\\'));

        if (pszFileName)
        {
            pszTmp = CmStrCpyAlloc(CharNextU(pszFileName));
        }
    }

    return pszTmp;
}


//+----------------------------------------------------------------------------
//
// Function:  FileExists
//
// Synopsis:  Helper function to encapsulate determining if a file exists. 
//
// Arguments: LPCTSTR pszFullNameAndPath - The FULL Name and Path of the file.
//
// Returns:   BOOL - TRUE if the file is located
//
// History:   nickball    Created    3/9/98
//
//+----------------------------------------------------------------------------
BOOL FileExists(LPCTSTR pszFullNameAndPath)
{
    MYDBGASSERT(pszFullNameAndPath);

    if (pszFullNameAndPath && pszFullNameAndPath[0])
    {
        HANDLE hFile = CreateFileU(pszFullNameAndPath, 0, FILE_SHARE_READ | FILE_SHARE_WRITE,
                                   NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

        if (hFile != INVALID_HANDLE_VALUE)
        {
            if (GetFileType(hFile) == FILE_TYPE_DISK)
            {
                CloseHandle(hFile);
                return TRUE;
            }
            else
            {
                CloseHandle(hFile);
                return FALSE;
            }
        }
    }
    
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   IsBlankString
//  
//  Synopsis:   Check whether a given string contains only spaces(' ')
//
//  Arguments:  pszString   string to be verified
//
//  Returns:    TRUE            only space is in the string
//              FALSE           otherwise
//
//  History:    byao            Modified  4/11/97
//              byao            Modified  4/14/97   Change the function to apply to
//                                                  all strings (instead of phone no only).
//----------------------------------------------------------------------------
BOOL IsBlankString(LPCTSTR pszString)
{
    MYDBGASSERT(pszString);

    DWORD dwIdx;
    DWORD dwLen = lstrlenU(pszString);

    if (NULL == pszString)
    {
        return FALSE;
    }

    for (dwIdx = 0; dwIdx < dwLen; dwIdx++)
    {
        if (pszString[dwIdx]!=TEXT(' '))
        {
            return FALSE;
        }
    }

    return TRUE;
}

//
// Acceptable phone number characters
//

#define VALID_CTRL_CHARS TEXT("\03\026\030") // ctrl-c, ctrl-v, ctrl-x.
#define VALID_PHONE_CHARS TEXT("0123456789AaBbCcDdPpTtWw!@$ -()+*#,\0")

//+---------------------------------------------------------------------------
//
//  Function:   IsValidPhoneNumChar
//
//  Synopsis:   Helper function to encapsulate validation of a character to 
//              determine if it is an acceptable input char for a phone number
//
//  Arguments:  TCHAR tChar - the char in question
//
//  Returns:    TRUE    if valid
//              FALSE   otherwise
//
//  History:    nickball - Created - 7/7/97
//
//----------------------------------------------------------------------------
BOOL IsValidPhoneNumChar(TCHAR tChar)
{
    LPTSTR lpValid = NULL;
    
    //
    // Scan thru the list of valid tapi characters
    //

    for (lpValid = VALID_PHONE_CHARS; *lpValid; lpValid++)
    {
        if (tChar == (TCHAR) *lpValid)
        {
            return TRUE;
        }
    }

    //
    // Scan thru the list of valid ctrl characters
    //

    for (lpValid = VALID_CTRL_CHARS; *lpValid; lpValid++)
    {
        if (tChar == (TCHAR) *lpValid)
        {
            return TRUE;
        }
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   ReadMappingByRoot
//
//  Synopsis:   Read in the mapping from the [HKCU or HKLM] branch of the registry
//
//  Arguments:  hkRoot          either HKCU or HKLM
//              pszDUN[IN]      Connectoid name
//              pszMapping[IN]  Full path of the service profile(.CMS) for this connectoid
//              dwNumCharsInMapping[IN]   Number of chars in pszMapping, including the NULL char
//
//  Returns:    TRUE        if registry key read in successfully
//              FALSE       otherwise
//
//----------------------------------------------------------------------------
BOOL ReadMappingByRoot(
    HKEY    hkRoot,
    LPCTSTR pszDUN, 
    LPTSTR pszMapping, 
    DWORD dwNumCharsInMapping,
    BOOL bExpandEnvStrings
) 
{
    MYDBGASSERT(pszDUN);
    MYDBGASSERT(pszMapping);
    MYDBGASSERT(dwNumCharsInMapping);

    if (NULL == pszDUN || NULL == pszMapping)
    {
        return FALSE;
    }

    TCHAR szTmp[MAX_PATH + 1] = TEXT("");
    DWORD dwNumBytesInTmp = sizeof(szTmp);
    DWORD dwRes;

    HKEY hkKey;
    DWORD dwType;

    dwRes = RegOpenKeyExU(hkRoot,
                          c_pszRegCmMappings,  // Mappings sub-key
                          0,
                          KEY_READ,
                          &hkKey);
    if (dwRes != ERROR_SUCCESS) 
    {
        CMTRACE1(TEXT("ReadMappingByRoot() RegOpenKeyEx() failed, GLE=%u."), dwRes);
        return (FALSE);
    }

    dwRes = RegQueryValueExU(hkKey, pszDUN, NULL, &dwType, (LPBYTE) szTmp, &dwNumBytesInTmp);

    RegCloseKey(hkKey);
 
    //
    // If no value found, just bail
    // 

    if ((dwRes != ERROR_SUCCESS) || (!*szTmp))
    {
        CMTRACE1(TEXT("ReadMappingByRoot() RegQueryValueEx() failed, GLE=%u."), dwRes);
        return FALSE;
    }

    // 
    // Check for and expand environment strings
    //
    
    if (bExpandEnvStrings && (TEXT('%') == *szTmp))
    {
        CMTRACE1(TEXT("Expanding Mapping environment string as %s"), szTmp);

        dwRes = ExpandEnvironmentStringsU(szTmp, pszMapping, dwNumCharsInMapping);        

        MYDBGASSERT(dwRes <= dwNumCharsInMapping);
    }
    else
    {
        lstrcpyU(pszMapping, szTmp);
        dwRes = lstrlenU(pszMapping) + 1;
    }

#ifdef DEBUG
    if (dwRes <= dwNumCharsInMapping)
    {
        CMTRACE1(TEXT("ReadMappingByRoot() SUCCESS. Mapping is %s"), pszMapping);
    }
    else
    {
        CMTRACE(TEXT("ReadMappingByRoot() FAILED."));
    }
#endif

    return (dwRes <= dwNumCharsInMapping);
}

//+---------------------------------------------------------------------------
//
//  Function:   ReadMapping
//
//  Synopsis:   Read in the mapping from the registry
//
//  Arguments:  pszDUN[IN]     Connectoid name
//              pszMapping[IN] Full path of the service profile(.CMS) for this connectoid
//              dwMapping[IN]  Number of chars in pszMapping, including the NULL char
//              fAllUser[IN]   Look in the AllUser hive
//
//  Returns:    BOOL           TRUE if found
//
//----------------------------------------------------------------------------
BOOL ReadMapping(
    LPCTSTR pszDUN, 
    LPTSTR pszMapping, 
    DWORD dwMapping,
    BOOL fAllUser,
    BOOL bExpandEnvStrings) 
{
    BOOL fOk = FALSE;

    //
    // Copied from ntdef.h
    //

    #define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)
   
    if (fAllUser)
    {
        CMTRACE1(TEXT("ReadMapping() - Reading AllUser Mapping for %s"), pszDUN);
        
        fOk = ReadMappingByRoot(HKEY_LOCAL_MACHINE, pszDUN, pszMapping, dwMapping, bExpandEnvStrings);            
    }
    else
    {
        CMTRACE1(TEXT("ReadMapping() - Reading Single User Mapping for %s"), pszDUN);

        //
        // Only NT5 has single-user profiles
        //

        MYDBGASSERT(OS_NT5);

        if (OS_NT5)
        {        
            //
            // There are cases where we aren't always running in the user context (certain
            // WinLogon cases and certain delete notification cases).  At these times we
            // have impersonation setup but don't have direct access to the HKCU, thus
            // we use RtlOpenCurrentUser in these instances.
            //

            CDynamicLibrary libNtDll;   // Destructor will call FreeLibrary
            HANDLE hCurrentUserKey = NULL;

            if (libNtDll.Load(TEXT("NTDLL.DLL")))
            {
                typedef NTSTATUS (NTAPI * RtlOpenCurrentUserPROC)(IN ULONG DesiredAccess,
                    OUT PHANDLE CurrentUserKey);
                typedef NTSTATUS (NTAPI * NtClosePROC)(IN HANDLE Handle);

                RtlOpenCurrentUserPROC pfnRtlOpenCurrentUser;

                if ( (pfnRtlOpenCurrentUser = (RtlOpenCurrentUserPROC)libNtDll.GetProcAddress("RtlOpenCurrentUser")) != NULL)
                {
                    if (NT_SUCCESS (pfnRtlOpenCurrentUser(KEY_READ | KEY_WRITE, &hCurrentUserKey)))
                    {                    
                        fOk = ReadMappingByRoot((HKEY)hCurrentUserKey, pszDUN, pszMapping, dwMapping, bExpandEnvStrings);
                                            
                        NtClosePROC pfnNtClose;

                        if ( (pfnNtClose = (NtClosePROC)libNtDll.GetProcAddress("NtClose")) != NULL)
                        {
                            pfnNtClose(hCurrentUserKey);
                        }
                    }
                }

            }

            MYDBGASSERT(hCurrentUserKey);
        }   
    }

    return fOk;
}

//+----------------------------------------------------------------------------
//
// Function:  StripPath
//
// Synopsis:  Helper function to deal with the tedium of extracting the filename 
//            part of a complete filename and path.
//
// Arguments: LPCTSTR pszFullNameAndPath - Ptr to the full filename with path
//
// Returns:   LPTSTR - Ptr to an allocated buffer containing the dir, or NULL on failure.
//
// Note:      It is up to the caller to provide reasonable input, the only requirement
//            is that the input contain '\'. 
//
// History:   nickball    Created    3/31/98
//
//+----------------------------------------------------------------------------
LPTSTR StripPath(LPCTSTR pszFullNameAndPath)
{
    MYDBGASSERT(pszFullNameAndPath);

    if (NULL == pszFullNameAndPath)
    {
        return NULL;
    }

    //
    // Locate the last '\'
    //
    
    LPTSTR pszSlash = CmStrrchr(pszFullNameAndPath, TEXT('\\'));

    if (NULL == pszSlash)
    {
        MYDBGASSERT(FALSE);
        return NULL;
    }

    //
    // Return an allocated copy of the string beyond the last '\'
    //

    pszSlash = CharNextU(pszSlash);

    return (CmStrCpyAlloc(pszSlash)); 
}

//+----------------------------------------------------------------------------
//
// Function:  NotifyUserOfExistingConnection
//
// Synopsis:  Helper function to notify user that connection is either connect
//            ing or connected already.
//
// Arguments: HWND hwndParent - Hwnd of parent if any.
//            LPCM_CONNECTION pConnection - Ptr to CM_CONNECTION structure 
//                                          containing state, entry name, etc.
//            BOOL fStatus - Flag indicating the status pane should be used for display.
//
// Returns:   Nothing
//
// History:   nickball    Created Header    3/17/98
//
//+----------------------------------------------------------------------------
void NotifyUserOfExistingConnection(HWND hwndParent, LPCM_CONNECTION pConnection, BOOL fStatus)
{   
    MYDBGASSERT(pConnection);

    //
    // Test assumptions
    //

    if (NULL == pConnection)
    {
        return;
    }

    MYDBGASSERT(CM_CONNECTED == pConnection->CmState || 
                CM_CONNECTING == pConnection->CmState ||
                CM_DISCONNECTING == pConnection->CmState);

    //
    // First load the correct message based upon state
    //

    int iMsgId;

    switch (pConnection->CmState)
    {
        case CM_CONNECTED:
            iMsgId = IDMSG_ALREADY_CONNECTED;
            break;

        case CM_CONNECTING: 
            iMsgId = IDMSG_ALREADY_CONNECTING;   
            break;

        case CM_DISCONNECTING: 
            iMsgId = IDMSG_ALREADY_DISCONNECTING;   
            break;
        
        default:
            MYDBGASSERT(FALSE);
            return;
            break;
    }

    //
    // Format the message with service name
    //

    LPTSTR pszMsg = CmFmtMsg(g_hInst, iMsgId, pConnection->szEntry);

    if (pszMsg)
    {
        //
        // Display according to requested output 
        //

        if (fStatus)
        {
            AppendStatusPane(hwndParent, pszMsg);
        }
        else
        {
            MessageBoxEx(hwndParent, pszMsg, pConnection->szEntry, MB_OK|MB_ICONINFORMATION, LANG_USER_DEFAULT);
        }

        CmFree(pszMsg);
    }
}

//+----------------------------------------------------------------------------
//
// Function:  GetConnection 
//
// Synopsis:  Helper routine to retrieve the connection data for the current
//            service from the connection table.
//
// Arguments: ArgsStruct *pArgs - Ptr to global Args struct
//
// Returns:   Allocated ptr to a CM_CONNECTION or NULL
//
// History:   nickball    Created    2/23/98
//
//+----------------------------------------------------------------------------
LPCM_CONNECTION GetConnection(ArgsStruct *pArgs)
{
    MYDBGASSERT(pArgs);
    MYDBGASSERT(pArgs->pConnTable);
   
    LPCM_CONNECTION pConnection = (LPCM_CONNECTION) CmMalloc(sizeof(CM_CONNECTION));   

    if (pArgs && pArgs->pConnTable && pConnection)
    {
        //
        // Retrieve the entry
        //

        if (FAILED(pArgs->pConnTable->GetEntry(pArgs->szServiceName, pConnection)))
        {
            CmFree(pConnection);
            pConnection = NULL;
        }
    }

    return pConnection;
}

//+----------------------------------------------------------------------------
//
// Function:  SingleSpace
//
// Synopsis:  Converts multiple space chars in a string to single spaces.
//            For example: "1  206  645 7865" becomes "1 206 645 7865"
//
// Arguments: LPTSTR pszStr - The string to be examined/modified
//
// Returns:   Nothing
//
// Note:      This is a fix for the MungePhone problem on W95 where TAPI adds 
//            two spaces between the 9 and the 1 when dialing long distance 
//            with a prefix. RAID #3198
//
// History:   nickball    4/1/98    Created Header    
//            nickball    4/1/98    Relocated from cm_misc.cpp
//
//+----------------------------------------------------------------------------
void SingleSpace(LPTSTR pszStr, UINT uNumCharsInStr) 
{
    LPTSTR pszTmp = pszStr;

    while (pszTmp && *pszTmp && uNumCharsInStr)
    {
        if (CmIsSpace(pszTmp) && CmIsSpace(pszTmp + 1))
        {
            lstrcpynU(pszTmp, (pszTmp + 1), uNumCharsInStr); 
        }

        pszTmp++;
        uNumCharsInStr--;
    }
}

//+----------------------------------------------------------------------------
//
// Function:  Ip_GPPS
//
// Synopsis:  Retrieves the result of a GPPS on the specified CIni object in R
//            ASIPADDR format. Used for reading IP addresses in INI files. 
//
// Arguments: CIni *pIni - The Cini object to be used
//            LPCTSTR pszSection - String name of the section to be read
//            LPCTSTR pszEntry - String name of the entry to be read
//            RASIPADDR *pIP - Ptr to the RASIPADDR structure to be filled.
//
// Returns:   static void - Nothing
//
// History:   nickball    Created Header    8/22/98
//
//+----------------------------------------------------------------------------

void Ip_GPPS(CIni *pIni, LPCTSTR pszSection, LPCTSTR pszEntry, RASIPADDR *pIP)
{    
    LPTSTR pszTmp;
    LPTSTR pszOctet;
    RASIPADDR ip;

    MYDBGASSERT(pszSection);
    MYDBGASSERT(pszEntry);

    pszTmp = pIni->GPPS(pszSection, pszEntry);
    if (!*pszTmp) 
    {
        CmFree(pszTmp);
        return;
    }
    memset(&ip,0,sizeof(ip));
    pszOctet = pszTmp;
    ip.a = (BYTE)CmAtol(pszOctet);
    while (CmIsDigit(pszOctet)) 
    {
        pszOctet++;
    }
    if (*pszOctet != '.') 
    {
        CmFree(pszTmp);
        return;
    }
    pszOctet++;
    ip.b = (BYTE)CmAtol(pszOctet);
    while (CmIsDigit(pszOctet)) 
    {
        pszOctet++;
    }
    if (*pszOctet != '.') 
    {
        CmFree(pszTmp);
        return;
    }
    pszOctet++;
    ip.c = (BYTE)CmAtol(pszOctet);
    while (CmIsDigit(pszOctet)) 
    {
        pszOctet++;
    }
    if (*pszOctet != '.') 
    {
        CmFree(pszTmp);
        return;
    }
    pszOctet++;
    ip.d = (BYTE)CmAtol(pszOctet);
    while (CmIsDigit(pszOctet)) 
    {
        pszOctet++;
    }
    if (*pszOctet) 
    {
        CmFree(pszTmp);
        return;
    }
    
    memcpy(pIP,&ip,sizeof(ip));
    CmFree(pszTmp);
    return;
}

//+----------------------------------------------------------------------------
//
// Function:  CopyGPPS
//
// Synopsis:  Copies the result of a GPPS call on the specified INI object to 
//            the buffer specified in pszBuffer.
//
// Arguments: CIni *pIni - Ptr to the CIni object to be used.
//            LPCTSTR pszSection - String name the section to be read
//            LPCTSTR pszEntry - String name of the entry to be read
//            LPTSTR pszBuffer - The buffer to be filled with the result
//            size_t nLen - The size of the buffer to be filled
//
// Returns:   static void - Nothing
//
// History:   nickball    Created Header    8/22/98
//
//+----------------------------------------------------------------------------
void CopyGPPS(CIni *pIni, LPCTSTR pszSection, LPCTSTR pszEntry, LPTSTR pszBuffer, size_t nLen) 
{
    // REVIEW:  Doesn't check input params

    LPTSTR pszTmp;

    pszTmp = pIni->GPPS(pszSection, pszEntry);
    if (*pszTmp) 
    {
        lstrcpynU(pszBuffer, pszTmp, nLen);
    }
    CmFree(pszTmp);
}

//
// From ras\ui\common\nouiutil\noui.c
//

CHAR HexChar(IN BYTE byte)

    /* Returns an ASCII hexidecimal character corresponding to 0 to 15 value,
    ** 'byte'.
    */
{
    const CHAR* pszHexDigits = "0123456789ABCDEF";

    if (byte >= 0 && byte < 16)
        return pszHexDigits[ byte ];
    else
        return '0';
}

//
// From ras\ui\common\nouiutil\noui.c
//

BYTE HexValue(IN CHAR ch)

    /* Returns the value 0 to 15 of hexadecimal character 'ch'.
    */
{
    if (ch >= '0' && ch <= '9')
        return (BYTE )(ch - '0');
    else if (ch >= 'A' && ch <= 'F')
        return (BYTE )((ch - 'A') + 10);
    else if (ch >= 'a' && ch <= 'f')
        return (BYTE )((ch - 'a') + 10);
    else
        return 0;
}

//+----------------------------------------------------------------------------
//
// Function:  StripCanonical
//
// Synopsis:  Simple helper to strip canonical formatting codes from a phone number
//            Obviously the number is assumed to be in canonical format.
//
// Arguments: LPTSTR pszSrc - the string to be modifed
//
// Returns:   Nothing
//
// History:   nickball      09/16/98     Created 
//
//+----------------------------------------------------------------------------
void StripCanonical(LPTSTR pszSrc)
{
    MYDBGASSERT(pszSrc);
    MYDBGASSERT(pszSrc);
    
    if (NULL == pszSrc || !*pszSrc)
    {
        return;
    }
    //
    // eg. +1 (425) 555 5555
    //
    
    LPTSTR pszNext = CharNextU(pszSrc);

    if (pszNext)
    {
        lstrcpyU(pszSrc, pszNext);
    
        //
        // eg. 1 (425) 555 5555
        //

        LPTSTR pszLast = CmStrchr(pszSrc, TEXT('('));

        if (pszLast)
        {
            pszNext = CharNextU(pszLast);
            
            if (pszNext)
            {
                lstrcpyU(pszLast, pszNext);         

                //
                // eg. 1 425) 555 5555  
                //

                pszLast = CmStrchr(pszSrc, TEXT(')'));

                if (pszLast)
                {
                    pszNext = CharNextU(pszLast);

                    if (pszNext)
                    {
                        lstrcpyU(pszLast, pszNext);                             
                    }
                }

                // 
                // eg. 1 425 555 5555
                //
            }
        }           
    }                       
}

//+----------------------------------------------------------------------------
//
// Function:  StripFirstElement
//
// Synopsis:  Simple helper to strip the substring prior to the first space in 
//            a string
//
// Arguments: LPTSTR pszSrc - the string to be modifed
//
// Returns:   Nothing
//
// History:   nickball      09/16/98     Created 
//
//+----------------------------------------------------------------------------
void StripFirstElement(LPTSTR pszSrc)
{
    MYDBGASSERT(pszSrc);
    MYDBGASSERT(pszSrc);
       
    if (pszSrc && *pszSrc)
    {
        LPTSTR pszSpace = CmStrchr(pszSrc, TEXT(' '));
        
        if (pszSpace && *pszSpace)
        {
            LPTSTR pszTmp = CharNextU(pszSpace);
            
            if (pszTmp && *pszTmp)
            {
                lstrcpyU(pszSrc, pszTmp);
            }
        }
    }
}   

//+----------------------------------------------------------------------------
//
// Function:  FrontExistingUI
//
// Synopsis:  Fronts existing UI for a given profile connect or settings attempt
// 
// Arguments: CConnectionTable *pConnTable  - ptr to connection table if any.
//            LPTSTR pszServiceName         - the long service name
//            BOOL fConnect                 - flag indicating that the request is for connect
//
// Note:      Caller is required to ensure that there is not an existing 
//            (non-logon) window with the same service names as the title.
//
// Returns:   TRUE if we fronted anything
//
//+----------------------------------------------------------------------------
BOOL FrontExistingUI(CConnectionTable *pConnTable, LPCTSTR pszServiceName, BOOL fConnect)
{
    LPTSTR pszPropTitle = GetPropertiesDlgTitle(pszServiceName);
    HWND hwndProperties = NULL;
    HWND hwndLogon = NULL;
    HWND hwndFront = NULL;
    BOOL bRet = FALSE;
    BOOL fLaunchProperties = FALSE;

    //
    // First look for a properties dialog
    // 

    if (pszPropTitle)
    {
        hwndProperties = FindWindowExU(NULL, NULL, WC_DIALOG, pszPropTitle);
    }
    
    CmFree(pszPropTitle);   

    //
    // Now see if we have a logon dialog up
    //
       
    hwndLogon = FindWindowExU(NULL, NULL, c_pszIconMgrClass, pszServiceName);
    
    //
    // Assume the common case, then consider the alternative scenarios.
    // 

    hwndFront = hwndLogon ? hwndLogon : hwndProperties;

    //
    // Note: There is an ambiguous case in which both UIs are up, but aren't 
    // related, in which case we front according to the requested action.
    //

    if (hwndLogon && hwndProperties)
    {
        //
        // We have both dialogs up, if the logon owns the properties dialog
        // or the request is for a properties display, we'll front properties. 
        //

        if (hwndLogon == GetParent(hwndProperties) || !fConnect)
        {
            hwndFront = hwndProperties;
        }
    }
    
    //
    // If we have a window handle, front it
    //

    if (hwndFront)
    {
        CMTRACE(TEXT("FrontExistingUI - Fronting existing connect instance UI"));

        SetForegroundWindow(hwndFront);

        bRet = TRUE;

        //
        // If the request is for properties, and there is a logon UI, but no
        // properties, we want to launch the properties UI from the logon UI
        // programmatically.
        //

        if (!fConnect && !hwndProperties) // fLaunchProperties)
        {
            if (pConnTable)
            {
                CM_CONNECTION Connection;
                ZeroMemory(&Connection, sizeof(CM_CONNECTION));
             
                //
                // Don't launch in the middle of connecting, etc.
                //

                if (FAILED(pConnTable->GetEntry(pszServiceName, &Connection)))
                {
                    PostMessageU(hwndLogon, WM_COMMAND, MAKEWPARAM(IDC_MAIN_PROPERTIES_BUTTON, 0), (LPARAM)0);
                }
            }
        }
    }   
    
    return bRet;
}

#if 0 // NT 301988
/*

//+----------------------------------------------------------------------------
//
// Function:  IsAnotherInstanceRunning
//
// Synopsis:  Check to see if another instance of the same profile running.
//
// Arguments: CConnectionTable *pConnTable - ptr to the connection table
//            LPTSTR pszServiceName - the long service name
//            DWORD  dwFlags - the application flags FL_*
//
// Returns:   Nothing
//
//+----------------------------------------------------------------------------
BOOL IsAnotherInstanceRunning(
    CConnectionTable    *pConnTable,
    LPCTSTR             pszServiceName,
    DWORD               dwFlags
)
{
    BOOL   fRet;
    HWND   hwnd;
    LPTSTR pszPropTitle;

    //
    // first look for the Properties dialog
    //
    if (!(pszPropTitle = GetPropertiesDlgTitle(pszServiceName)))
    {
        return FALSE;
    }

    fRet = TRUE;
    
    if (!(hwnd = FindWindowEx(NULL, NULL, WC_DIALOG, pszPropTitle)))
    {
        //
        // now look for the main dialog.  We make sure that the window returned
        // is really the main dialog, not the Status dialog.  Since the parent of
        // the main dialog is the desktop, we can tell by making sure the parent 
        // of the window returned is the desktop window.
        //
        if ((hwnd = FindWindowEx(NULL, NULL, WC_DIALOG, pszServiceName)) &&
            (GetWindow(hwnd, GW_OWNER) && GetWindow(hwnd, GW_OWNER) != GetDesktopWindow()))
        {
            hwnd = NULL;
        }
    }

    CmFree(pszPropTitle);


    BOOL          fEntryExists;
    CM_CONNECTION Connection;

    ZeroMemory(&Connection, sizeof(CM_CONNECTION));
    fEntryExists = pConnTable && SUCCEEDED(pConnTable->GetEntry(pszServiceName, &Connection));

    if (hwnd)
    {
        CMTRACE(TEXT("Found a previous instance of the same profile."));

        SetForegroundWindow(hwnd);

        //
        // if we're connecting, the "Properties" button is disabled and so we don't bring
        // up the properties dialog.  We don't want to do this also during disconnection
        // and reconnecting.
        //

        if (dwFlags & FL_PROPERTIES && 
            (!fEntryExists ||
             fEntryExists            &&
             Connection.CmState != CM_CONNECTING &&
             Connection.CmState != CM_RECONNECTPROMPT))
        {
            CMTRACE(TEXT("Bringing up the Properties dialog from the previous instance..."));
            //
            // try to bring up the properties dialog of the first instance
            //
            PostMessage(hwnd, WM_COMMAND, MAKEWPARAM(IDC_MAIN_PROPERTIES_BUTTON, 0), (LPARAM)0);
        }
    }
    else
    {
        //
        // During disconnect and reconnect, we don't want to pop up either the main or the 
        // properties dlg.  However, we want to let cmdial run if the Reconnect prompt is gone
        // and the this is a reconnect request from CMMON
        //

        if (fEntryExists && 
            (Connection.CmState == CM_DISCONNECTING         || 
             Connection.CmState == CM_RECONNECTPROMPT       && 
             dwFlags & FL_PROPERTIES))
        {
            fRet = TRUE;
        }
        else
        {
            fRet = FALSE;
        }
    }

    return fRet;
}   
*/
#endif

LPTSTR GetPropertiesDlgTitle(
    LPCTSTR pszServiceName
)
{
    LPTSTR pszTmp = NULL;
    LPTSTR pszTitle = NULL;

    //
    // first look for the Properties dialog
    //
    if (!(pszTmp = CmLoadString(g_hInst, IDS_PROPERTIES_SUFFIX)))
    {
        return NULL;
    }
    if (!(pszTitle = CmStrCpyAlloc(pszServiceName)))
    {
        CmFree(pszTmp);
        return NULL;
    }
    if (!CmStrCatAlloc(&pszTitle, pszTmp))
    {
        CmFree(pszTmp);
        CmFree(pszTitle);
        return NULL;
    }

    CmFree(pszTmp);
    return pszTitle;
}

//+----------------------------------------------------------------------------
//
// Function:  GetPPTPMsgId
//
// Synopsis:  Simple helper to determine appropriate PPTP msg based on OS cfg.
//
// Arguments: None
//
// Returns:   Integer ID of resource string
//
// History:   nickball      12/07/98     Created 
//
//+----------------------------------------------------------------------------
int GetPPTPMsgId(void)
{
    int nID;

    if (OS_NT) 
    {
        //
        // We need to tell the user to re-apply the service pack after manual
        // install of PPTP if they have one.
        //

        if (IsServicePackInstalled())
        {
            nID =   IDMSG_NEED_PPTP_NT_SP;
        }
        else
        {
            nID = IDMSG_NEED_PPTP_NT; // NT w/o SP
        }
    }
    else 
    {
        nID = IDMSG_NEED_PPTP_WIN95;
            
    }

    return nID;
}

//+----------------------------------------------------------------------------
//  Function    IsServicePackInstalled
//
//  Synopsis    Checks the CSDVersion key in the registry to see if a service
//              pack is installed on this machine
//
//  Arguments   None
//
//  Returns     TRUE if service pack (any SP) is installed
//              FALSE if no service pack is installed
//
//  History     2/4/98  VetriV  Created     
//-----------------------------------------------------------------------------
BOOL IsServicePackInstalled(void)
{
    HKEY hKey = NULL;
    TCHAR szBuffer[MAX_PATH] = {TEXT("\0")};
    HKEY hkey = NULL;
    DWORD dwType = 0;
    DWORD dwSize = sizeof(szBuffer);
    
    if (ERROR_SUCCESS == RegOpenKeyExU(HKEY_LOCAL_MACHINE, 
                                       c_pszRegCurrentVersion, 
                                       0,
                                       KEY_READ,
                                       &hkey))
    {
        if (ERROR_SUCCESS == RegQueryValueExU(hkey,
                                              c_pszRegCsdVersion,
                                              NULL,
                                              &dwType,
                                              (LPBYTE)szBuffer,
                                              &dwSize))
        {
            if (szBuffer[0] != TEXT('\0'))
            {
                RegCloseKey(hkey);
                return TRUE;
            }
        }

        RegCloseKey(hKey);
    }

    
    return FALSE;
}

//+----------------------------------------------------------------------------
//
// Function:  RegisterWindowClass
//
// Synopsis:  Encapsulates registration of window class
//
// Arguments: HINSTANCE hInst - Hinst of DLL
//
// Returns:   DWORD - GetLastError
//
// History:   nickball    Created Header    6/3/99
//
//+----------------------------------------------------------------------------
DWORD RegisterWindowClass(HINSTANCE hInst)
{
    WNDCLASSEXA wc;
    ZeroMemory(&wc, sizeof(wc));
    
    if (GetClassInfoExA(NULL,(LPSTR)WC_DIALOG,&wc))
    {
        //
        // Convert to Ansi before calling Ansi forms of APIs. We use the 
        // Ansi forms because GetClassInfoEx cannot be readily wrapped.
        //
    
        LPSTR pszClass = WzToSzWithAlloc(c_pszIconMgrClass);
    
        if (!pszClass)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        wc.lpszClassName = pszClass;
        wc.cbSize = sizeof(wc);
        wc.hInstance = hInst;

        if (!RegisterClassExA(&wc)) 
        {
            DWORD dwError = GetLastError();

            CMTRACE1(TEXT("RegisterWindowClass() RegisterClassEx() failed, GLE=%u."), dwError);

            //
            // Only fail if the class does not already exist
            //

            if (ERROR_CLASS_ALREADY_EXISTS != dwError)
            {
                CmFree(pszClass);
                return dwError;
            }
        }      
    
        CmFree(pszClass);
    }
    return ERROR_SUCCESS;
}

//+----------------------------------------------------------------------------
//
// Function:  UnRegisterWindowClass
//
// Synopsis:  Encapsulates un-registering window class
//
// Arguments: HINSTANCE hInst - Hinst of DLL
//
// Returns:   BOOL - result of UnregsiterClass
//
// History:   nickball    Created Header    6/3/99
//
//+----------------------------------------------------------------------------
BOOL UnRegisterWindowClass(HINSTANCE hInst)
{
    return UnregisterClassU(c_pszIconMgrClass, g_hInst);   
}

//+----------------------------------------------------------------------------
//
// Function:  IsActionEnabled
//
// Synopsis:  checks Registry to see if a command is allowed to run
//
// Arguments: CONST WCHAR *pszProgram         - Name of program to be executed
//            CONST WCHAR *pszServiceName     - Long service name
//            CONST WCHAR *pszServiceFileName - Full path to Service file
//            LPDWORD lpdwLoadType            - Ptr to be filled with load type
//
// Returns:   TRUE if action is allowed @ this time
//
// Notes:     Checks SOFTWARE\Microsoft\Connection Manager\<ServiceName>
//             Under which you will have the Values for each command
//              0 - system32 directory
//              1 - profile directory
//
// History:   v-vijayb    Created Header    07/20/99
//            nickball    Revised           07/27/99
//
//+----------------------------------------------------------------------------
BOOL IsActionEnabled(CONST WCHAR *pszProgram, 
                     CONST WCHAR *pszServiceName, 
                     CONST WCHAR *pszServiceFileName,
                     LPDWORD lpdwLoadType)
{
    HKEY        hKey;
    DWORD       dwLoadFlags, cb;
    BOOL        fIsAllowed = FALSE;
    WCHAR       szSubKey[MAX_PATH + 1];
    WCHAR       szBaseName[MAX_PATH + 1];
    WCHAR       szPath[MAX_PATH + 1];
    WCHAR       *pszTmp;

    MYDBGASSERT(pszProgram && pszServiceName && pszServiceFileName && lpdwLoadType);

    if (NULL == pszProgram ||
        NULL == pszServiceName ||
        NULL == pszServiceFileName ||
        NULL == lpdwLoadType)
    {
        return FALSE;
    }

    *lpdwLoadType = -1;

    if (!IsLogonAsSystem())
    {
        return (TRUE);
    }

    MYDBGASSERT(OS_NT);

    lstrcpyW(szPath, pszProgram);

    //
    // Check for extension. We don't allow anything that doesn't have an extension.
    //
    
    pszTmp = CmStrrchrW(szPath, TEXT('.'));
    if (pszTmp == NULL)
    {
        return (FALSE);
    }

    //
    // Get Basename 
    //
    
    pszTmp = CmStrrchrW(szPath, TEXT('\\'));
    if (pszTmp)
    {
        lstrcpyW(szBaseName, CharNextW(pszTmp));
        *pszTmp = TEXT('\0');
    }
    else
    {
        lstrcpyW(szBaseName, pszProgram);
    }

    lstrcpyW(szSubKey, L"SOFTWARE\\Microsoft\\Connection Manager\\");
    lstrcatW(szSubKey, pszServiceName);
    lstrcatW(szSubKey, L"\\WinLogon Actions");

    if (ERROR_SUCCESS == RegOpenKeyExW(HKEY_LOCAL_MACHINE, szSubKey, 0, KEY_READ, &hKey) )
    {
        cb = sizeof(dwLoadFlags);
        if (ERROR_SUCCESS == RegQueryValueExW(hKey, szBaseName, NULL, NULL, (PBYTE) &dwLoadFlags, &cb))
        {
            switch (dwLoadFlags)
            {
                case 0: // system32 directory only

                    //
                    // No paths in this case, .CMS entry should match key name
                    //
                    
                    if (0 == lstrcmpiW(szBaseName, szPath))
                    {
                        fIsAllowed = TRUE;
                        *lpdwLoadType = dwLoadFlags;
                    }
                    
                    break;

                case 1: // profile directory only

                    //
                    // Get servicename path
                    //

                    pszTmp = CmStripFileNameW(pszServiceFileName, FALSE);
                    
                    if (pszTmp && 0 == lstrcmpiW(pszTmp, szPath))
                    {
                        fIsAllowed = TRUE;
                        *lpdwLoadType = dwLoadFlags;
                    }

                    CmFree(pszTmp);

                    break;

                default:    // invalid flag
                    CMTRACE1(TEXT("IsActionEnabled() - Invalid LoadFlags %d"), dwLoadFlags);
                    goto OnError;
                    break;
            }

        }

OnError:
        RegCloseKey(hKey);
    }


    if (fIsAllowed == FALSE)
    {
        CMTRACE1W(L"IsActionEnabled(returned FALSE) %s", pszProgram);
    }

    return (fIsAllowed);
}

//+----------------------------------------------------------------------------
//
// Function:  ApplyPasswordHandlingToBuffer
//
// Synopsis:  Convert password: all upper case, all lower case, or no conversion
//
// Arguments: ArgsStruct *pArgs     - Ptr to global Args struct
//            LPTSTR pszBuffer      - Buffer to be modified
//
// Returns:   Nothing 
//
// Note:      Available types are: PWHANDLE_LOWER, PWHANDLE_UPPER, PWHANDLE_NONE:
//
// History:   nickball    Created          03/03/00
//
//+----------------------------------------------------------------------------
void ApplyPasswordHandlingToBuffer(ArgsStruct *pArgs, 
                                   LPTSTR pszBuffer)
{    
    MYDBGASSERT(pArgs);
    MYDBGASSERT(pszBuffer);

    if (NULL == pArgs || NULL == pszBuffer)
    {
        return;
    }
        
    CIni *piniService = GetAppropriateIniService(pArgs, pArgs->nDialIdx);

    if (piniService)
    {
        switch (piniService->GPPI(c_pszCmSection, c_pszCmEntryPasswordHandling)) 
        {
            case PWHANDLE_LOWER:
                CharLowerU(pszBuffer);
                break;

            case PWHANDLE_UPPER:
                CharUpperU(pszBuffer);
                break;

            case PWHANDLE_NONE:
            default:
                break;
        }
    }

    delete piniService;
}

//+----------------------------------------------------------------------------
//
// Function:  ApplyDomainHandlingToDialParams
//
// Synopsis:  Handles the messy details of Domain management relative to username
//            Returns a buffer containing the original buffer and (if appropriate) 
//            the domain prepended. 
//
// Arguments: ArgsStruct *pArgs     - Ptr to global Args struct
//            CIni *piniService     - Ptr to the Cini object to be used
//            LPTSTR pszBuffer      - Ptr to the current buffer to which we'll prepend
//
// Returns:   LPTSTR                -  
//
// History:   nickball    Created          03/04/00
//
//+----------------------------------------------------------------------------
LPTSTR ApplyDomainPrependToBufferAlloc(ArgsStruct *pArgs, 
                                       CIni *piniService, 
                                       LPTSTR pszBuffer, 
                                       LPCTSTR pszDunName)
{
    MYDBGASSERT(pArgs);
    MYDBGASSERT(piniService);
    MYDBGASSERT(pszBuffer);
    MYDBGASSERT(pszDunName);

    if (NULL == pArgs || NULL == piniService || NULL == pszBuffer || NULL == pszDunName)
    {
        return NULL;
    }

    BOOL bPrependDomain = FALSE;

    //
    // Prepare the user name. We may need to pre-pend the domain
    //
       
    if (*pArgs->szDomain)
   