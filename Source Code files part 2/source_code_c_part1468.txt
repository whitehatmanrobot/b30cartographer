           //
            CSiteLinksInfo * pSiteLinkInfo;
            
            if (!m_SiteLinksMap.Lookup(*(pvar->puuid), pSiteLinkInfo))
            {
                pSiteLinkInfo = new CSiteLinksInfo();
                m_SiteLinksMap[*(pvar->puuid)] = pSiteLinkInfo;
            }
            
            pSiteLinkInfo->AddNeighbor(
                                *((pvar + 1)->puuid),
                                (pvar+2)->ulVal,
                                ((pvar+3)->calpwstr.cElems > 0)? TRUE : FALSE);



            //
            //  Set it in neighbor2
            //
            if ( !m_SiteLinksMap.Lookup(*((pvar + 1)->puuid), pSiteLinkInfo))
            {
                pSiteLinkInfo = new CSiteLinksInfo();
                m_SiteLinksMap[*((pvar+1)->puuid)] = pSiteLinkInfo;
            }

            pSiteLinkInfo->AddNeighbor(
                                    *(pvar->puuid),
                                    (pvar+2)->ulVal,
                                    ((pvar+3)->calpwstr.cElems)? TRUE : FALSE);


        }
    }


    // close the query handle
    hr = DSCoreLookupEnd( hQuery);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 20);
    }
    return(hr);

}


/*====================================================

DestructElements of CSiteLinksMap

Arguments:

Return Value:


=====================================================*/

void AFXAPI DestructElements(CSiteLinksInfo ** ppLinksInfo, int n)
{
    int i;
    for (i=0;i<n;i++)
        delete *ppLinksInfo++;
}
/*====================================================

DestructElements of CRoutingTable

Arguments:

Return Value:


=====================================================*/


BOOL AFXAPI  CompareElements(CSiteRoutingNode ** ppRoutingNode1, CSiteRoutingNode ** ppRoutingNode2)
{

    return ((**ppRoutingNode1)==(**ppRoutingNode2));

}
/*====================================================

DestructElements of CRoutingTable

Arguments:

Return Value:


=====================================================*/


void AFXAPI DestructElements(CNextHop ** ppNextHop, int n)
{

    int i;
    for (i=0;i<n;i++)
        delete *ppNextHop++;

}

/*====================================================

DestructElements of CRoutingTable

Arguments:

Return Value:


=====================================================*/


void AFXAPI DestructElements(CSiteRoutingNode ** ppRoutingNode, int n)
{

    int i;
    for (i=0;i<n;i++)
        delete *ppRoutingNode++;

}



/*====================================================

HashKey For CRoutingNode

Arguments:

Return Value:


=====================================================*/
UINT AFXAPI HashKey(CSiteRoutingNode* key)
{
    return (key->GetHashKey());
}
/*====================================================

Duplicate:

Arguments:

Return Value:


=====================================================*/
CNextHop * CNextHop::Duplicate() const
{
    return (new CNextHop(m_pNextNode,m_Cost,m_SiteGate));
};

/*====================================================

Const'

Arguments:

Return Value:


=====================================================*/

void CSiteLinksInfo::AddNeighbor(
                     IN GUID &        uuidNeighbor,
                     IN unsigned long ulCost,
                     IN BOOL          fSiteGates)
{
    DWORD   i;
#define NO_OF_LINKS 10


    if ( m_NoOfNeighbors >= m_NoAllocated)
    {
        if (m_NoAllocated == 0) m_NoAllocated = NO_OF_LINKS;
        AP<CSiteRoutingNode> aNeighbors = new CSiteRoutingNode[m_NoAllocated * 2];
        AP<unsigned long> aCosts = new unsigned long[m_NoAllocated *2];
        AP<BOOL> aSiteGates = new BOOL[m_NoAllocated *2];

        for(i=0; i < m_NoOfNeighbors ; i++)
        {
            aNeighbors[i].SetNode(m_pNeighbors[i].GetNode());
            aCosts[i] =  m_pCosts[i];
            aSiteGates[i] = m_pfSiteGates[i];
        }
        delete [] m_pNeighbors;
        delete [] m_pCosts;
        delete []m_pfSiteGates;

        m_pNeighbors = aNeighbors.detach();
        m_pCosts = aCosts.detach();
        m_pfSiteGates = aSiteGates.detach();

        m_NoAllocated *= 2;

    }
    m_pNeighbors[ m_NoOfNeighbors].SetNode( uuidNeighbor );
    m_pCosts[ m_NoOfNeighbors] =   ulCost;
    m_pfSiteGates[ m_NoOfNeighbors] = fSiteGates;
    m_NoOfNeighbors++;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdscore\routtbl.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    routtbl.h

Abstract:

    Routing Table declarations
        
Author:

    Lior Moshaiov (LiorM)

--*/

#ifndef __ROUTTBL_H__
#define __ROUTTBL_H__

class CSiteRoutingNode 
{
    public:
        CSiteRoutingNode();
        CSiteRoutingNode(const GUID& guid);
        ~CSiteRoutingNode();
        UINT            GetHashKey() const;
        void            Print() const;
        int             operator==(IN const CSiteRoutingNode & other) const;
        CSiteRoutingNode *  Duplicate() const;

        const GUID& GetNode()   const;
        void    SetNode(IN const GUID & guid);

    private:
        CSiteRoutingNode(const CSiteRoutingNode &other);                // no definition - to find out unintentionaly copies
        void    operator=(const CSiteRoutingNode &other);               // no definition - to find out unintentionaly copies

        GUID    m_Guid;
            
};

class CSiteGate
{
    public:
        CSiteGate(BOOL fSiteGate=FALSE);
        ~CSiteGate();
        CSiteGate operator+(const CSiteGate &second) const;
        void operator =(IN BOOL fSiteGate);
        void    Print() const;
        BOOL    IsThereASiteGate() const;

        
    private:
        BOOL  operator<(const CSiteGate &second) const;    // no definition - to find out unintentionaly usage
        int  operator==( IN const CSiteGate &second) const;  // no definition - to find out unintentionaly usage

        BOOL    m_fSiteGate;
            
};

class CCost
{
    public:
        CCost(DWORD cost=0);
        ~CCost();
        CCost operator+(const CCost &second) const;
        BOOL  operator<(const CCost &second) const;
        int  operator==( IN const CCost &second) const;
        void operator =(IN DWORD cost);
        void    Print() const;

        
    private:

        DWORD m_Cost;
            
};

class CNextHop
{
    public:
        
        CNextHop(const CSiteRoutingNode* pNextNode);
        CNextHop(const CSiteRoutingNode* pNextNode, const CCost& Cost, const CSiteGate& SiteGate);
        ~CNextHop();

        
        CNextHop * Duplicate() const;
        const   CSiteRoutingNode* GetNextNode() const;
        const   CCost& GetCost()        const;
        void    Print()                 const;
        const   CSiteGate& GetSiteGate() const;
        
    private:
        CNextHop(const CNextHop &other);            // no definition - to find out unintentionaly copies
        void    operator=(const CNextHop &other);   // no definition - to find out unintentionaly copies

        CSiteRoutingNode*   m_pNextNode;
        CCost               m_Cost;
        CSiteGate           m_SiteGate;
            
};

typedef CMap<CSiteRoutingNode*,CSiteRoutingNode*,CNextHop*,CNextHop*> CRoutingTable;
BOOL AFXAPI CompareElements(CSiteRoutingNode ** ppRoutingNode1, CSiteRoutingNode ** ppRoutingNode2);
UINT AFXAPI HashKey(CSiteRoutingNode* key);
void AFXAPI DestructElements(CSiteRoutingNode ** ppRoutingNode, int n);
void AFXAPI DestructElements(CNextHop ** ppNextHop, int n);

class CSiteLinksInfo
{
    public:
        CSiteLinksInfo( );
                    
        ~CSiteLinksInfo();

        void AddNeighbor( GUID & uuidNeighbor,
                     unsigned long ulCost,
                     BOOL          fSiteGates);

        DWORD       GetNoOfNeighbors()  const ;
        DWORD       GetCost(IN DWORD i) const;
        DWORD       IsThereSiteGate(IN DWORD i) const;
        CSiteRoutingNode*   GetNeighbor(IN DWORD i)const ;

    private:

        DWORD               m_NoAllocated;
        DWORD               m_NoOfNeighbors;
        CSiteRoutingNode*   m_pNeighbors;
        DWORD*              m_pCosts;
        BOOL*               m_pfSiteGates;
};

typedef CMap<GUID, const GUID&, CSiteLinksInfo*,CSiteLinksInfo*> CSiteLinksMap;
extern void AFXAPI DestructElements(CSiteLinksInfo ** ppLinksInfo, int n);

class CSiteDB 
{
    public:
        CSiteDB();
        ~CSiteDB();
        HRESULT    Init(   IN const GUID& MySite);
        const CSiteRoutingNode* GetMyNode() const;
        POSITION            GetStartNeighborPosition(IN const CSiteRoutingNode* pSrc) ;
        void                GetNextNeighborAssoc(   IN OUT POSITION& pos,
                                                    OUT const CSiteRoutingNode*& pKey,
                                                    OUT CCost& val,
                                                    OUT CSiteGate& SiteGate);

    private:
       HRESULT GetAllSiteLinks( );
       CSiteDB(const CSiteDB &other);              // no definition - to find out unintentionaly copies
        void    operator=(const CSiteDB &other);    // no definition - to find out unintentionaly copies

        CSiteRoutingNode    m_MySiteNode;
        CSiteLinksMap       m_SiteLinksMap;
        DWORD               m_pos;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdscore\tranrout.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    tranrout.cpp

Abstract:


    Translation routines for properties not in NT5 DS


Author:

    ronit hartmann ( ronith)

--*/

#include "ds_stdh.h"
#include "mqads.h"
#include "coreglb.h"
#include <winsock.h>
#include "mqadsp.h"
#include "mqattrib.h"
#include "xlatqm.h"

#include "tranrout.tmh"

static WCHAR *s_FN=L"mqdscore/tranrout";

/*====================================================

MQADSpRetrieveEnterpriseName

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADSpRetrieveEnterpriseName(
                 IN  CMsmqObjXlateInfo * /*pcMsmqObjXlateInfo*/,
                 OUT PROPVARIANT *   ppropvariant)
{
    DWORD len = wcslen( g_pwcsDsRoot);
    ppropvariant->pwszVal = new WCHAR[ len+ 1];
    wcscpy( ppropvariant->pwszVal, g_pwcsDsRoot);
    ppropvariant->vt = VT_LPWSTR;
    return(MQ_OK);
}

/*====================================================

MQADSpRetrieveEnterprisePEC

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADSpRetrieveEnterprisePEC(
                 IN  CMsmqObjXlateInfo * /*pcMsmqObjXlateInfo*/,
                 OUT PROPVARIANT *   ppropvariant)
{
    ppropvariant->pwszVal = new WCHAR[ 3];
    wcscpy( ppropvariant->pwszVal, L"");
    ppropvariant->vt = VT_LPWSTR;
    return(MQ_OK);
}


/*====================================================

MQADSpRetrieveSiteSignPK

Arguments:

Return Value:

=====================================================*/

HRESULT WINAPI MQADSpRetrieveSiteSignPK(
                 IN  CMsmqObjXlateInfo * pcMsmqObjXlateInfo,
                 OUT PROPVARIANT *       ppropvariant)
{
   ASSERT( ppropvariant->vt == VT_NULL );

   HRESULT hr = MQADSpGetSiteSignPK(
                         pcMsmqObjXlateInfo->ObjectGuid(),
                        &ppropvariant->blob.pBlobData,
                        &ppropvariant->blob.cbSize ) ;
   ppropvariant->vt = VT_BLOB ;

   return LogHR(hr, s_FN, 10);
}


/*====================================================
MQADSpRetrieveSiteGates

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADSpRetrieveSiteGates(
                 IN  CMsmqObjXlateInfo * pcMsmqObjXlateInfo,
                 OUT PROPVARIANT *   ppropvariant)
{

   ASSERT( ppropvariant->vt == VT_NULL);
   CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);

   HRESULT hr = MQADSpGetSiteGates(
                   pcMsmqObjXlateInfo->ObjectGuid(),
                   &requestDsServerInternal,            // This routine is called from
                                            // DSADS:LookupNext or DSADS::Get..
                                            // impersonation, if required,
                                            // has already been performed.
                   &ppropvariant->cauuid.cElems,
                   &ppropvariant->cauuid.pElems
                   );

    ppropvariant->vt = VT_CLSID|VT_VECTOR;
    return LogHR(hr, s_FN, 20);
}

/*====================================================

MQADSpRetrieveNothing

Arguments:

Return Value:

=====================================================*/

HRESULT WINAPI MQADSpRetrieveNothing(
                 IN  CMsmqObjXlateInfo * /*pcMsmqObjXlateInfo*/,
                 OUT PROPVARIANT *   ppropvariant)
{
    ppropvariant->vt = VT_EMPTY ;
    return MQ_OK ;
}

/*====================================================

MQADSpRetrieveQueueQMid

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADSpRetrieveQueueQMid(
                 IN  CMsmqObjXlateInfo * pcMsmqObjXlateInfo,
                 OUT PROPVARIANT *   ppropvariant)
{
    const WCHAR * pchar = pcMsmqObjXlateInfo->ObjectDN();
    //
    //  Skip the queue name
    //
    while ( *pchar != L',')
    {
        pchar++;
    }
    pchar++;

    PROPID prop = PROPID_QM_MACHINE_ID;
    //
    //  To be on the safe side we'd better leave the vt as is, cause it can also be VT_CLSID
    //  if prop requestor allocated the guid (common practice).
    //  The propvariant in this translation routine is the prop requestor propvariant.
    //
    CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);

    //
    //  Is the computer in the local domain?
    //
    const WCHAR * pwcsQueueName = pcMsmqObjXlateInfo->ObjectDN();
    WCHAR * pszDomainName = wcsstr(pwcsQueueName, x_DcPrefix);
    ASSERT(pszDomainName) ;
    HRESULT hr;

    if ( !wcscmp( pszDomainName, g_pwcsLocalDsRoot)) 
    {
        //
        //   try local DC
        //

        hr = g_pDS->GetObjectProperties(
                eLocalDomainController,	
                &requestDsServerInternal,     // This routine is called from
                                        // DSADS:LookupNext or DSADS::Get..
                                        // impersonation, if required,
                                        // has already been performed.
                pchar,
                NULL,
                1,
                &prop,
                ppropvariant);         // output variant array
    }
    else
    {
        hr = g_pDS->GetObjectProperties(
            eGlobalCatalog,	
            &requestDsServerInternal,     // This routine is called from
                                    // DSADS:LookupNext or DSADS::Get..
                                    // impersonation, if required,
                                    // has already been performed.
            pchar,
            NULL,
            1,
            &prop,
            ppropvariant);         // output variant array
    }
    return LogHR(hr, s_FN, 30);
}

/*====================================================

MQADSpRetrieveQueueName

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADSpRetrieveQueueName(
                 IN  CMsmqObjXlateInfo * pcMsmqObjXlateInfo,
                 OUT PROPVARIANT *   ppropvariant)
{
      const WCHAR * pchar = pcMsmqObjXlateInfo->ObjectDN();
      //
      //    Parse the distinguished name of a queue and
      //    build pathname
      //

      //
      //    Find queue name
      //
      const WCHAR * pwcsStartQueue = pchar + x_CnPrefixLen;
      const WCHAR * pwcsEndQueue =  pwcsStartQueue;
      while ( *pwcsEndQueue != ',')
      {
            pwcsEndQueue++;
      }
      //
      //    Find machine name
      //
      const WCHAR * pwcsStartMachine = pwcsEndQueue + 2*(1 + x_CnPrefixLen)
                        + x_MsmqComputerConfigurationLen;    // skip msmq-configuration
      const WCHAR * pwcsEndMachine = pwcsStartMachine;
      while ( *pwcsEndMachine != ',')
      {
            pwcsEndMachine++;
      }
      //
      //    Is the queue name splitted between two attributes?
      //
      AP<WCHAR> pwcsNameExt;
      DWORD dwNameExtLen = 0;
      if (( pwcsEndQueue - pwcsStartQueue) == x_PrefixQueueNameLength +1)
      {
          //
          //    read the queue name ext attribute
          //
          PROPVARIANT varNameExt;
          varNameExt.vt = VT_NULL;
          HRESULT hr = pcMsmqObjXlateInfo->GetDsProp(
                       MQ_Q_NAME_EXT,
                       ADSTYPE_CASE_EXACT_STRING,
                       VT_LPWSTR,
                       FALSE,
                       &varNameExt);
          if ( hr ==  E_ADS_PROPERTY_NOT_FOUND)
          {
              varNameExt.pwszVal = NULL;
              hr = MQ_OK;
          }

          if (FAILED(hr))
          {
              return LogHR(hr, s_FN, 40);
          }
          pwcsNameExt = varNameExt.pwszVal;
          if (  pwcsNameExt != NULL)
          {
              dwNameExtLen = wcslen( pwcsNameExt);
              //
              //    ignore the guid that we added to the first part of the
              //    the queue name
              //
              pwcsEndQueue -= x_SplitQNameIdLength;
          }
      }

      ppropvariant->pwszVal = new WCHAR[2 + (pwcsEndMachine - pwcsStartMachine)
                                          + (pwcsEndQueue - pwcsStartQueue) + dwNameExtLen];
      //
      //    build queue pathname ( m1\q1)
      //
      WCHAR * ptmp =  ppropvariant->pwszVal;
      memcpy( ptmp, pwcsStartMachine, sizeof(WCHAR)*(pwcsEndMachine - pwcsStartMachine));
      ptmp += (pwcsEndMachine - pwcsStartMachine );
      *ptmp = PN_DELIMITER_C;
      ptmp++;

      //
      //    skip escape chars
      //
      while (pwcsStartQueue < pwcsEndQueue) 
      {
          if (*pwcsStartQueue != L'\\')
          {
            *ptmp = *pwcsStartQueue;
            ptmp++;
          }
          pwcsStartQueue++;

      }

      if ( dwNameExtLen > 0)
      {
        memcpy( ptmp, pwcsNameExt, sizeof(WCHAR)*dwNameExtLen);
      }
      ptmp += dwNameExtLen;
      *ptmp = '\0';
      CharLower( ppropvariant->pwszVal);

      ppropvariant->vt = VT_LPWSTR;
      return(MQ_OK);
}

/*====================================================

MQADSpRetrieveQueueDNSName

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADSpRetrieveQueueDNSName(
                 IN  CMsmqObjXlateInfo * pcMsmqObjXlateInfo,
                 OUT PROPVARIANT *   ppropvariant)
{
      const WCHAR * pchar = pcMsmqObjXlateInfo->ObjectDN();
      //
      //    Parse the distinguished name of a queue and
      //    get the queue name from it, for the DNS name of
      //    the computer, retrieve dNSHostName
      //

      //
      //    Find queue name
      //
      const WCHAR * pwcsStartQueue = pchar + x_CnPrefixLen;
      const WCHAR * pwcsEndQueue =  pwcsStartQueue;
      while ( *pwcsEndQueue != ',')
      {
            pwcsEndQueue++;
      }
      const WCHAR * pwcsComputerName = pwcsEndQueue + 2 + x_CnPrefixLen
                        + x_MsmqComputerConfigurationLen;    // skip msmq-configuration
      //
      //    Is the queue name splitted between two attributes?
      //
      AP<WCHAR> pwcsNameExt;
      DWORD dwNameExtLen = 0;
      if (( pwcsEndQueue - pwcsStartQueue) == x_PrefixQueueNameLength +1)
      {
          //
          //    read the queue name ext attribute
          //
          PROPVARIANT varNameExt;
          varNameExt.vt = VT_NULL;
          HRESULT hr = pcMsmqObjXlateInfo->GetDsProp(
                       MQ_Q_NAME_EXT,
                       ADSTYPE_CASE_EXACT_STRING,
                       VT_LPWSTR,
                       FALSE,
                       &varNameExt);
          if ( hr ==  E_ADS_PROPERTY_NOT_FOUND)
          {
              varNameExt.pwszVal = NULL;
              hr = MQ_OK;
          }

          if (FAILED(hr))
          {
              return LogHR(hr, s_FN, 50);
          }
          pwcsNameExt = varNameExt.pwszVal;
          if (  pwcsNameExt != NULL)
          {
              dwNameExtLen = wcslen( pwcsNameExt);
              //
              //    ignore the guid that we added to the first part of the
              //    the queue name
              //
              pwcsEndQueue -= x_SplitQNameIdLength;
          }
      }
      //
      //    Read the computer DNS name
      //
      AP<WCHAR> pwcsDnsName;

      HRESULT hr =  MQADSpGetComputerDns(
                pwcsComputerName,
                &pwcsDnsName
                );

     if ( hr == HRESULT_FROM_WIN32(E_ADS_PROPERTY_NOT_FOUND))
      {
          //
          //    The dNSHostName attribute doesn't have value
          //
          ppropvariant->vt = VT_EMPTY;
          return MQ_OK;
      }
      if (FAILED(hr))
      {
          return LogHR(hr, s_FN, 60);
      }
      DWORD lenComputer = wcslen(pwcsDnsName);

      ppropvariant->pwszVal = new WCHAR[2 + lenComputer
                                          + (pwcsEndQueue - pwcsStartQueue) + dwNameExtLen];
      //
      //    build queue pathname ( m1\q1)
      //
      WCHAR * ptmp =  ppropvariant->pwszVal;
      wcscpy( ptmp, pwcsDnsName);
      ptmp += lenComputer;
      *ptmp = PN_DELIMITER_C;
      ptmp++;
      memcpy( ptmp, pwcsStartQueue, sizeof(WCHAR)*(pwcsEndQueue - pwcsStartQueue));
      ptmp += (pwcsEndQueue - pwcsStartQueue );
      if ( dwNameExtLen > 0)
      {
        memcpy( ptmp, pwcsNameExt, sizeof(WCHAR)*dwNameExtLen);
      }
      ptmp += dwNameExtLen;
      *ptmp = '\0';
      CharLower( ppropvariant->pwszVal);

      ppropvariant->vt = VT_LPWSTR;
      return(MQ_OK);
}


/*====================================================

RetrieveSiteLink

Arguments:

Return Value:

=====================================================*/
STATIC HRESULT RetrieveSiteLink(
           IN  CMsmqObjXlateInfo * pcMsmqObjXlateInfo,
           IN  LPCWSTR          pwcsAttributeName,
           OUT MQPROPVARIANT *  ppropvariant
           )
{
    HRESULT hr;

    MQPROPVARIANT varSiteDn;
    varSiteDn.vt = VT_NULL;
    //
    //  Retrieve the DN of the site-link
    //
    hr = pcMsmqObjXlateInfo->GetDsProp(
                   pwcsAttributeName,
                   ADSTYPE_DN_STRING,
                   VT_LPWSTR,
                   FALSE,
                   &varSiteDn);
    if (FAILED(hr))
    {
        //
        //  Site-link is a mandatory property, therefore if not found it is
        //  a problem
        //
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("RetrieveSiteLink:GetDsProp(%ls)=%lx"), pwcsAttributeName, hr));
        return LogHR(hr, s_FN, 70);
    }
    AP<WCHAR> pClean = varSiteDn.pwszVal;

    //
    //  Translate the DN of the site link into unique id
    //
    PROPID prop = PROPID_S_SITEID;
    CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);

    hr = g_pDS->GetObjectProperties(
                eLocalDomainController,
                &requestDsServerInternal,           // This routine is called from
                                        // DSADS:LookupNext or DSADS::Get..
                                        // impersonation, if required,
                                        // has already been performed.
                varSiteDn.pwszVal,
                NULL,
                1,
                &prop,
                ppropvariant
                );
    if ( hr == HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT) || 
         hr == HRESULT_FROM_WIN32(ERROR_DS_INVALID_DN_SYNTAX))
    {
        //
        //  To enable admin to identify a state where one
        //  of the link's sites was deleted.
        //
        ppropvariant->vt = VT_EMPTY;
        ppropvariant->pwszVal = NULL;
        hr = MQ_OK;   // go on to next result
    }
    return LogHR(hr, s_FN, 80);
}

/*====================================================

MQADSpRetrieveLinkNeighbor1

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADSpRetrieveLinkNeighbor1(
                 IN  CMsmqObjXlateInfo * pcMsmqObjXlateInfo,
                 OUT PROPVARIANT *   ppropvariant)
{
    HRESULT hr2 = RetrieveSiteLink(
                pcMsmqObjXlateInfo,
                MQ_L_NEIGHBOR1_ATTRIBUTE,
                ppropvariant
                );
    return LogHR(hr2, s_FN, 90);
}

/*====================================================

MQADSpRetrieveLinkNeighbor2

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADSpRetrieveLinkNeighbor2(
                 IN  CMsmqObjXlateInfo * pcMsmqObjXlateInfo,
                 OUT PROPVARIANT *   ppropvariant)
{
    HRESULT hr2 = RetrieveSiteLink(
                pcMsmqObjXlateInfo,
                MQ_L_NEIGHBOR2_ATTRIBUTE,
                ppropvariant
                );
    return LogHR(hr2, s_FN, 100);
}

/*====================================================

MQADSpSetLinkNeighbor

Arguments:

Return Value:

=====================================================*/
STATIC HRESULT MQADSpSetLinkNeighbor(
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPVARIANT      *pNewPropVar)
{
    PROPID prop = PROPID_S_FULL_NAME;
    pNewPropVar->vt = VT_NULL;
    CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);

    HRESULT hr2 = g_pDS->GetObjectProperties(
                    eLocalDomainController,	
                    &requestDsServerInternal,     // This routine is called from
                                            // DSADS:LookupNext or DSADS::Get..
                                            // impersonation, if required,
                                            // has already been performed.
 	                NULL,      // object name
                    pPropVar->puuid,      // unique id of object
                    1,
                    &prop,
                    pNewPropVar);
    return LogHR(hr2, s_FN, 110);
}
/*====================================================

MQADSpCreateLinkNeighbor1

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADSpCreateLinkNeighbor1(
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar)
{
    *pdwNewPropID = PROPID_L_NEIGHBOR1_DN;
    HRESULT hr2 = MQADSpSetLinkNeighbor(
                    pPropVar,
                    pNewPropVar);
    return LogHR(hr2, s_FN, 120);
}

/*====================================================

MQADSpSetLinkNeighbor1

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADSpSetLinkNeighbor1(
                 IN IADs *             pAdsObj,
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar)
{
    UNREFERENCED_PARAMETER( pAdsObj);
    HRESULT hr2 = MQADSpCreateLinkNeighbor1(
                    pPropVar,
					pdwNewPropID,
                    pNewPropVar);
    return LogHR(hr2, s_FN, 130);
}
/*====================================================

MQADSpCreateLinkNeighbor2

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADSpCreateLinkNeighbor2(
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar)
{
    *pdwNewPropID = PROPID_L_NEIGHBOR2_DN;
    HRESULT hr2 = MQADSpSetLinkNeighbor(
                    pPropVar,
                    pNewPropVar);
    return LogHR(hr2, s_FN, 140);
}

/*====================================================

MQADSpSetLinkNeighbor2

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADSpSetLinkNeighbor2(
                 IN IADs *             pAdsObj,
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar)
{
    UNREFERENCED_PARAMETER( pAdsObj);
    HRESULT hr2 = MQADSpCreateLinkNeighbor2(
                    pPropVar,
					pdwNewPropID,
                    pNewPropVar);
    return LogHR(hr2, s_FN, 150);
}

STATIC BOOL IsNeighborForeign(
           IN  CMsmqObjXlateInfo * pcMsmqObjXlateInfo,
           IN  LPCWSTR          pwcsAttributeName
           )
{
    //
    //  Check if a site-link neighbor is a foreign site
    //  BUGBUG : future improvment- to cache foreign site info.
    //
    //  Start with getting the neighbor's site-id
    //  
    PROPVARIANT varNeighbor;
    GUID    guidNeighbor;
    varNeighbor.vt = VT_CLSID;
    varNeighbor.puuid = &guidNeighbor;
    HRESULT hr;
    hr = RetrieveSiteLink(
                pcMsmqObjXlateInfo,
                pwcsAttributeName,
                &varNeighbor
                );

    if (FAILED(hr))
    {
        //
        //  Assume it is not a foreign site
        //
        return FALSE;
    }
    //
    //  Is it a foreign site?
    //
    PROPID prop = PROPID_S_FOREIGN;
    PROPVARIANT var;
    var.vt = VT_NULL;
    CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);

    hr = g_pDS->GetObjectProperties(
                eLocalDomainController,
                &requestDsServerInternal,           // This routine is called from
                                        // DSADS:LookupNext or DSADS::Get..
                                        // impersonation, if required,
                                        // has already been performed.
                NULL,
                &guidNeighbor,
                1,
                &prop,
                &var
                );
    if (FAILED(hr))
    {
        //
        //  assume it is no a foreign site
        //
        return FALSE;
    }
    return (var.bVal > 0);
}


/*====================================================

MQADSpRetrieveLinkCost

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADSpRetrieveLinkCost(
                 IN  CMsmqObjXlateInfo * pcMsmqObjXlateInfo,
                 OUT PROPVARIANT *   ppropvariant)
{
    //
    //  Is it a link to a foreign site, if yes increment the cost
    //  otherwise return the cost as is.
    //

    //
    //  First read the cost
    //
    HRESULT hr;
    hr = pcMsmqObjXlateInfo->GetDsProp(
                   MQ_L_COST_ATTRIBUTE,
                   MQ_L_COST_ADSTYPE,
                   VT_UI4,
                   FALSE,
                   ppropvariant);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 160);
    }

    if ( IsNeighborForeign(
           pcMsmqObjXlateInfo,
           MQ_L_NEIGHBOR1_ATTRIBUTE))
    {
        //
        //  For a link to foreign site, increment the cost to prevent
        //  routing through it
        //
        ppropvariant->ulVal += MQ_MAX_LINK_COST;
        return MQ_OK;
    }
    if ( IsNeighborForeign(
           pcMsmqObjXlateInfo,
           MQ_L_NEIGHBOR2_ATTRIBUTE))
    {
        //
        //  For a link to foreign site, increment the cost to prevent
        //  routing through it
        //
        ppropvariant->ulVal += MQ_MAX_LINK_COST;
        return MQ_OK;
    }
    return MQ_OK;
}

/*====================================================

MQADpRetrieveLinkGates

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADSpRetrieveLinkGates(
                 IN  CMsmqObjXlateInfo * pcMsmqObjXlateInfo,
                 OUT PROPVARIANT *   ppropvariant)
{
    //
    //  Is it a link to a foreign site, if yes increment the cost
    //  otherwise return the cost as is.
    //

    //
    //  First read the cost
    //
    CMQVariant varLinkGatesDN;
    HRESULT hr;
    hr = pcMsmqObjXlateInfo->GetDsProp(
                   MQ_L_SITEGATES_ATTRIBUTE,
                   MQ_L_SITEGATES_ADSTYPE,
                   VT_VECTOR|VT_LPWSTR,
                   TRUE,
                   varLinkGatesDN.CastToStruct());
    if ( hr ==  E_ADS_PROPERTY_NOT_FOUND)
    {
      ppropvariant->cauuid.pElems = NULL;
      ppropvariant->cauuid.cElems = 0;
      ppropvariant->vt = VT_CLSID|VT_VECTOR;
      return MQ_OK;
    }
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 180);
    }
    //
    //  Translate the gates DNs to gates-ids
    //
    hr =  MQADSpTranslateGateDn2Id(
                varLinkGatesDN.CastToStruct(),
                &ppropvariant->cauuid.pElems,
                &ppropvariant->cauuid.cElems
                );
    if (SUCCEEDED(hr))
    {
            ppropvariant->vt = VT_CLSID|VT_VECTOR;
    }
    return LogHR(hr, s_FN, 190);
}

/*====================================================

MQADSpCreateLinkCost

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADSpCreateLinkCost(
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar)
{
    //
    //  Just set the PROPID_L_ACTUAL_COST
    //  This support is required for MSMQ 1.0 explorer
    //
    *pdwNewPropID = PROPID_L_ACTUAL_COST;
    *pNewPropVar = *pPropVar;
    return MQ_OK;
}

/*====================================================

MQADSpSetLinkCost

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADSpSetLinkCost(
                 IN IADs *             pAdsObj,
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar)
{
    //
    //  Just set the PROPID_L_ACTUAL_COST
    //  This support is required for MSMQ 1.0 explorer
    //
    UNREFERENCED_PARAMETER( pAdsObj);
	HRESULT hr2 = MQADSpCreateLinkCost(
				pPropVar,
				pdwNewPropID,
				pNewPropVar);
    return LogHR(hr2, s_FN, 170);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdscore\siterout.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    siterout.h

Abstract:

    Sites' routing information Class definition

Author:

    ronit hartmann (ronith)


--*/
#ifndef __SITEROUT_H__
#define __SITEROUT_H__

#include <Ex.h>
#include "routtbl.h"

class CSiteRoutingInformation
{
    public:
		CSiteRoutingInformation();

        ~CSiteRoutingInformation();

        HRESULT Init(
                IN const GUID *     pguidThisSiteId,
                IN BOOL             freplicationMode );

        HRESULT CheckIfSitegateOnRouteToSite(
                        IN const GUID * pguidSite,
						OUT BOOL * pfSitegateOnRoute);

        HRESULT FindBestSiteFromHere(
                                IN const ULONG   cSites,
	                            IN const GUID *  pguidSites,
            	                OUT GUID *       pguidBestSite,
                        	    OUT BOOL *       pfSitegateOnRoute);


    private:
        //
        //  Refresh the site route table
        //

        static void WINAPI RefrshSiteRouteTable(
                IN CTimer* pTimer
                   );

        HRESULT RefreshSiteRoutingTableInternal();


	    CCriticalSection	m_cs;
        CRoutingTable       m_SiteRoutingTable;
        GUID                m_guidThisSiteId;

        CTimer              m_RefreshTimer;
        BOOL                m_fInitialized;     // indication of successful init


};
inline 		CSiteRoutingInformation::CSiteRoutingInformation():
            m_RefreshTimer( RefrshSiteRouteTable),
            m_fInitialized(FALSE)
{
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdscore\traninfo.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    traninfo.cpp

Abstract:

    Translation information of MSMQ 1.0 properties into MSMQ 2.0 attributes

Author:

    ronit hartmann ( ronith)

--*/
#include "ds_stdh.h"
#include "mqads.h"
#include "mqprops.h"
#include "mqattrib.h"
#include "_mqini.h"
#include "tranrout.h"
#include "xlatqm.h"

#include "traninfo.tmh"

static WCHAR *s_FN=L"mqdscore/traninfo";

GUID guidNull = {0,0,0,{0,0,0,0,0,0,0,0}};
//----------------------------------------------------------
//  defaultVARIANT
//
//  This structure is equivalent in size and order of variables 
//  to MQPROPVARIANT.
//
//  MQPROPVARIANT contains a union, and the size first member of
//  the union is smaller than other members of the union.
//  Therefore MQPROVARIANT cannot be initialized at compile time
//  with union members other than the smallest one.
//
//----------------------------------------------------------
struct defaultVARIANT {
    VARTYPE vt;
    WORD wReserved1;
    WORD wReserved2;
    WORD wReserved3;
    ULONG_PTR l1;
    ULONG_PTR l2;
};

C_ASSERT(sizeof(defaultVARIANT) == sizeof(MQPROPVARIANT));
C_ASSERT(FIELD_OFFSET(defaultVARIANT, l1) == FIELD_OFFSET(MQPROPVARIANT, caub.cElems));
C_ASSERT(FIELD_OFFSET(defaultVARIANT, l2) == FIELD_OFFSET(MQPROPVARIANT, caub.pElems));

//
//      Default values for queue properties
//
const defaultVARIANT varDefaultQType = { VT_CLSID, 0,0,0, (LONG_PTR)&guidNull, 0};
const defaultVARIANT varDefaultQJournal = { VT_UI1, 0,0,0, DEFAULT_Q_JOURNAL, 0};
const defaultVARIANT varDefaultQQuota = { VT_UI4, 0,0,0, DEFAULT_Q_QUOTA, 0};
const defaultVARIANT varDefaultQBasePriority = { VT_I2, 0,0,0, DEFAULT_Q_BASEPRIORITY, 0};
const defaultVARIANT varDefaultQJQuota = { VT_UI4, 0,0,0, DEFAULT_Q_JOURNAL_QUOTA, 0};
const defaultVARIANT varDefaultQJLabel = { VT_LPWSTR, 0,0,0, (LONG_PTR)TEXT(""), 0};
const defaultVARIANT varDefaultQAuthenticate = { VT_UI1, 0,0,0, DEFAULT_Q_AUTHENTICATE, 0};
const defaultVARIANT varDefaultQPrivLevel = { VT_UI4, 0,0,0, DEFAULT_Q_PRIV_LEVEL, 0};
const defaultVARIANT varDefaultQTransaction = { VT_UI1, 0,0,0, DEFAULT_Q_TRANSACTION, 0};

MQTranslateInfo   QueueTranslateInfo[] = {
// PROPID                | attribute-name               | vartype   | adstype                   | Translation routine                  | multivalue| InGC | default value                            | Set routine | Create routine | QM1 action                   | notify-QM1-replace | QM1-Set routine |
//-----------------------|------------------------------|-----------|---------------------------|--------------------------------------|-----------|------|------------------------------------------|-------------|----------------|------------------------------|--------------------|-----------------|
{PROPID_Q_INSTANCE       ,MQ_Q_INSTANCE_ATTRIBUTE       ,VT_CLSID   ,MQ_Q_INSTANCE_ADSTYPE      ,NULL                                  ,FALSE      ,TRUE  ,NULL                                      ,NULL         ,NULL            ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_Q_TYPE           ,MQ_Q_TYPE_ATTRIBUTE           ,VT_CLSID   ,MQ_Q_TYPE_ADSTYPE          ,NULL                                  ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultQType          ,NULL         ,NULL            ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_Q_PATHNAME       ,NULL                          ,VT_LPWSTR  ,ADSTYPE_INVALID            ,MQADSpRetrieveQueueName               ,FALSE      ,FALSE ,NULL                                      ,NULL         ,NULL            ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_Q_JOURNAL        ,MQ_Q_JOURNAL_ATTRIBUTE        ,VT_UI1     ,MQ_Q_JOURNAL_ADSTYPE       ,NULL                                  ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultQJournal       ,NULL         ,NULL            ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_Q_QUOTA          ,MQ_Q_QUOTA_ATTRIBUTE          ,VT_UI4     ,MQ_Q_QUOTA_ADSTYPE         ,NULL                                  ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultQQuota         ,NULL         ,NULL            ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_Q_BASEPRIORITY   ,MQ_Q_BASEPRIORITY_ATTRIBUTE   ,VT_I2      ,MQ_Q_BASEPRIORITY_ADSTYPE  ,NULL                                  ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultQBasePriority  ,NULL         ,NULL            ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_Q_JOURNAL_QUOTA  ,MQ_Q_JOURNAL_QUOTA_ATTRIBUTE  ,VT_UI4     ,MQ_Q_JOURNAL_QUOTA_ADSTYPE ,NULL                                  ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultQJQuota        ,NULL         ,NULL            ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_Q_LABEL          ,MQ_Q_LABEL_ATTRIBUTE          ,VT_LPWSTR  ,MQ_Q_LABEL_ADSTYPE         ,NULL                                  ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultQJLabel        ,NULL         ,NULL            ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_Q_CREATE_TIME    ,MQ_Q_CREATE_TIME_ATTRIBUTE    ,VT_I4      ,MQ_Q_CREATE_TIME_ADSTYPE   ,NULL                                  ,FALSE      ,TRUE  ,NULL                                      ,NULL         ,NULL            ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_Q_MODIFY_TIME    ,MQ_Q_MODIFY_TIME_ATTRIBUTE    ,VT_I4      ,MQ_Q_MODIFY_TIME_ADSTYPE   ,NULL                                  ,FALSE      ,TRUE  ,NULL                                      ,NULL         ,NULL            ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_Q_AUTHENTICATE   ,MQ_Q_AUTHENTICATE_ATTRIBUTE   ,VT_UI1     ,MQ_Q_AUTHENTICATE_ADSTYPE  ,NULL                                  ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultQAuthenticate  ,NULL         ,NULL            ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_Q_PRIV_LEVEL     ,MQ_Q_PRIV_LEVEL_ATTRIBUTE     ,VT_UI4     ,MQ_Q_PRIV_LEVEL_ADSTYPE    ,NULL                                  ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultQPrivLevel     ,NULL         ,NULL            ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_Q_TRANSACTION    ,MQ_Q_TRANSACTION_ATTRIBUTE    ,VT_UI1     ,MQ_Q_TRANSACTION_ADSTYPE   ,NULL                                  ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultQTransaction   ,NULL         ,NULL            ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_Q_SCOPE          ,NULL                          ,VT_UI1     ,ADSTYPE_INVALID            ,NULL                                  ,FALSE      ,FALSE ,NULL                                      ,NULL         ,NULL            ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_Q_QMID           ,NULL                          ,VT_CLSID   ,ADSTYPE_INVALID            ,MQADSpRetrieveQueueQMid               ,FALSE      ,FALSE ,NULL                                      ,NULL         ,NULL            ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_Q_MASTERID       ,MQ_Q_MASTERID_ATTRIBUTE       ,VT_CLSID   ,MQ_Q_MASTERID_ADSTYPE      ,NULL                                  ,FALSE      ,TRUE  ,NULL                                      ,NULL         ,NULL            ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_Q_SEQNUM         ,NULL                          ,VT_BLOB    ,ADSTYPE_INVALID            ,NULL                                  ,FALSE      ,FALSE ,NULL                                      ,NULL         ,NULL            ,e_NO_NOTIFY_ERROR_WRITEREQ_QM1,0                   ,NULL},
{PROPID_Q_HASHKEY        ,NULL                          ,VT_UI4     ,ADSTYPE_INVALID            ,NULL                                  ,FALSE      ,FALSE ,NULL                                      ,NULL         ,NULL            ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_Q_LABEL_HASHKEY  ,NULL                          ,VT_UI4     ,ADSTYPE_INVALID            ,NULL                                  ,FALSE      ,FALSE ,NULL                                      ,NULL         ,NULL            ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_Q_SECURITY       ,MQ_Q_SECURITY_ATTRIBUTE       ,VT_BLOB    ,MQ_Q_SECURITY_ADSTYPE      ,NULL                                  ,FALSE      ,TRUE  ,NULL                                      ,NULL         ,NULL            ,e_NOTIFY_WRITEREQ_QM1_REPLACE ,PROPID_Q_SECURITY   ,MQADSpQM1SetSecurity},
{PROPID_Q_NT4ID          ,MQ_Q_NT4ID_ATTRIBUTE          ,VT_CLSID   ,MQ_Q_NT4ID_ADSTYPE         ,NULL                                  ,FALSE      ,TRUE  ,NULL                                      ,NULL         ,NULL            ,e_NO_NOTIFY_ERROR_WRITEREQ_QM1,0                   ,NULL},
{PROPID_Q_DONOTHING      ,NULL                          ,VT_UI1     ,ADSTYPE_INVALID            ,NULL                                  ,FALSE      ,FALSE ,NULL                                      ,NULL         ,NULL            ,e_NO_NOTIFY_ERROR_WRITEREQ_QM1,0                   ,NULL},
{PROPID_Q_FULL_PATH      ,MQ_Q_FULL_PATH_ATTRIBUTE      ,VT_LPWSTR  ,MQ_Q_FULL_PATH_ADSTYPE     ,NULL                                  ,FALSE      ,TRUE  ,NULL                                      ,NULL         ,NULL            ,e_NO_NOTIFY_ERROR_WRITEREQ_QM1,0                   ,NULL},            
{PROPID_Q_NAME_SUFFIX    ,MQ_Q_NAME_EXT                 ,VT_LPWSTR  ,MQ_Q_NAME_EXT_ADSTYPE      ,NULL                                  ,FALSE      ,TRUE  ,NULL                                      ,NULL         ,NULL            ,e_NO_NOTIFY_ERROR_WRITEREQ_QM1,0                   ,NULL},            
{PROPID_Q_OBJ_SECURITY   ,MQ_Q_SECURITY_ATTRIBUTE       ,VT_BLOB    ,MQ_Q_SECURITY_ADSTYPE      ,NULL                                  ,FALSE      ,TRUE  ,NULL                                      ,NULL         ,NULL            ,e_NO_NOTIFY_NO_WRITEREQ_QM1   ,0                   ,NULL},
{PROPID_Q_SECURITY_INFORMATION  ,NULL                   ,VT_UI1     ,ADSTYPE_INVALID            ,MQADSpRetrieveNothing                 ,FALSE      ,FALSE ,NULL                                      ,NULL         ,NULL            ,e_NO_NOTIFY_ERROR_WRITEREQ_QM1,0                   ,NULL},
{PROPID_Q_PATHNAME_DNS   ,NULL                          ,VT_LPWSTR  ,ADSTYPE_INVALID            ,MQADSpRetrieveQueueDNSName            ,FALSE      ,FALSE ,NULL                                      ,NULL         ,NULL            ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL}
};

//
//      Default values for machine properties
//

const defaultVARIANT varDefaultQMService = { VT_UI4, 0,0,0, DEFAULT_N_SERVICE, 0};
const defaultVARIANT varDefaultQMServiceRout = { VT_UI1, 0,0,0, DEFAULT_N_SERVICE, 0};    //[adsrv]
const defaultVARIANT varDefaultQMServiceDs   = { VT_UI1, 0,0,0, DEFAULT_N_SERVICE, 0};
const defaultVARIANT varDefaultQMServiceDep  = { VT_UI1, 0,0,0, DEFAULT_N_SERVICE, 0};
const defaultVARIANT varDefaultQMInFrs = { VT_CLSID|VT_VECTOR, 0,0,0, 0, 0};
const defaultVARIANT varDefaultQMOutFrs = { VT_CLSID|VT_VECTOR, 0,0,0, 0, 0};
const defaultVARIANT varDefaultQMQuota = { VT_UI4, 0,0,0, DEFAULT_QM_QUOTA, 0};
const defaultVARIANT varDefaultQMJQuota = { VT_UI4, 0,0,0, DEFAULT_QM_JOURNAL_QUOTA, 0};
const defaultVARIANT varDefaultQMForeign = { VT_UI1, 0,0,0, DEFAULT_QM_FOREIGN, 0};
const defaultVARIANT varDefaultQMOs = { VT_UI4, 0,0,0, DEFAULT_QM_OS, 0};
const defaultVARIANT varDefaultQMMType = { VT_LPWSTR, 0,0,0, (LONG_PTR)TEXT(""), 0};
const defaultVARIANT varDefaultQMSignPk = { VT_BLOB, 0,0,0, 0, 0};
const defaultVARIANT varDefaultQMEncryptPk = { VT_BLOB, 0,0,0, 0, 0};
const defaultVARIANT varDefaultQMSiteIDs = { VT_CLSID|VT_VECTOR, 0,0,0, 0, 0};
const defaultVARIANT varDefaultQMDescription = { VT_LPWSTR, 0,0,0, (LONG_PTR)TEXT(""), 0};


MQTranslateInfo   MachineTranslateInfo[] = {
// PROPID                | attribute-name               | vartype           | adstype                   | Translation routine                    | multivalue| InGC | default value                         | Set routine            | Create routine          | QM1 action                   | notify-QM1-replace | QM1-Set routine |
//-----------------------|------------------------------|-------------------|---------------------------|----------------------------------------|-----------|------|---------------------------------------|------------------------|-------------------------|------------------------------|--------------------|-----------------|
{PROPID_QM_SITE_ID       ,NULL                          ,VT_CLSID           ,ADSTYPE_INVALID            ,MQADSpRetrieveMachineSite               ,FALSE      ,FALSE ,NULL                                   ,MQADSpSetMachineSite    ,MQADSpCreateMachineSite  ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_QM_MACHINE_ID    ,MQ_QM_ID_ATTRIBUTE            ,VT_CLSID           ,MQ_QM_ID_ADSTYPE           ,NULL                                    ,FALSE      ,TRUE  ,NULL                                   ,NULL                    ,NULL                     ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_QM_PATHNAME      ,MQ_QM_PATHNAME_ATTRIBUTE      ,VT_LPWSTR          ,ADSTYPE_INVALID            ,MQADSpRetrieveMachineName               ,FALSE      ,FALSE ,NULL                                   ,NULL                    ,NULL                     ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_QM_CONNECTION    ,NULL                          ,VT_LPWSTR|VT_VECTOR,ADSTYPE_INVALID            ,NULL                                    ,FALSE      ,FALSE ,NULL                                   ,NULL                    ,NULL                     ,e_NO_NOTIFY_ERROR_WRITEREQ_QM1,0                   ,NULL},
{PROPID_QM_ENCRYPTION_PK ,NULL                          ,VT_BLOB            ,ADSTYPE_INVALID            ,NULL                                    ,FALSE      ,FALSE ,NULL                                   ,NULL                    ,NULL                     ,e_NO_NOTIFY_ERROR_WRITEREQ_QM1,0                   ,NULL},
{PROPID_QM_ADDRESS       ,NULL                          ,VT_BLOB            ,ADSTYPE_INVALID            ,MQADSpRetrieveMachineAddresses          ,FALSE      ,FALSE ,NULL                                   ,NULL                    ,NULL                     ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_QM_CNS           ,NULL                          ,VT_CLSID|VT_VECTOR ,ADSTYPE_INVALID            ,MQADSpRetrieveMachineCNs                ,FALSE      ,FALSE ,NULL                                   ,NULL                    ,NULL                     ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_QM_OUTFRS        ,NULL                          ,VT_CLSID|VT_VECTOR ,ADSTYPE_INVALID            ,MQADSpRetrieveMachineOutFrs             ,FALSE      ,FALSE ,NULL                                   ,MQADSpSetMachineOutFrss ,MQADSpCreateMachineOutFrss,e_NOTIFY_WRITEREQ_QM1_AS_IS  ,0                   ,NULL},
{PROPID_QM_INFRS         ,NULL                          ,VT_CLSID|VT_VECTOR ,ADSTYPE_INVALID            ,MQADSpRetrieveMachineInFrs              ,FALSE      ,FALSE ,NULL                                   ,MQADSpSetMachineInFrss  ,MQADSpCreateMachineInFrss,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
// [adsrv] Next one is for asking old-style QM Service - to be calculated
// TBD: is it OK to keep 2 attributes with the same names (different IDs)?
{PROPID_QM_SERVICE       ,MQ_QM_SERVICE_ATTRIBUTE       ,VT_UI4             ,ADSTYPE_INVALID,            MQADSpRetrieveQMService                 ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultQMService   ,MQADSpSetMachineService ,NULL                     ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},  // [adsrv] TBD notification
// [adsrv] Next one provides access to the old PROPID_SET_SERVICE from migration and replication, like QueryNt4PSCs
{PROPID_QM_OLDSERVICE    ,MQ_QM_SERVICE_ATTRIBUTE       ,VT_UI4             ,MQ_QM_SERVICE_ADSTYPE      ,NULL                                    ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultQMService   ,MQADSpSetMachineService ,NULL                     ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
// [adsrv] Next are 3 new separate bits for server functionality
{PROPID_QM_SERVICE_DSSERVER   ,MQ_QM_SERVICE_DSSERVER_ATTRIBUTE    ,VT_UI1,MQ_QM_SERVICE_DSSERVER_ADSTYPE   ,NULL                                ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultQMServiceDs ,MQADSpSetMachineServiceDs,NULL                    ,e_NOTIFY_WRITEREQ_QM1_REPLACE  ,PROPID_QM_SERVICE  ,MQADSpQM1SetMachineService},
{PROPID_QM_SERVICE_ROUTING    ,MQ_QM_SERVICE_ROUTING_ATTRIBUTE     ,VT_UI1,MQ_QM_SERVICE_ROUTING_ADSTYPE    ,NULL                                ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultQMServiceRout,MQADSpSetMachineServiceRout,NULL                 ,e_NOTIFY_WRITEREQ_QM1_REPLACE  ,PROPID_QM_SERVICE  ,MQADSpQM1SetMachineService},
{PROPID_QM_SERVICE_DEPCLIENTS ,MQ_QM_SERVICE_DEPCLIENTS_ATTRIBUTE  ,VT_UI1,MQ_QM_SERVICE_DEPCLIENTS_ADSTYPE ,NULL                                ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultQMServiceDep  ,NULL                  ,NULL                     ,e_NOTIFY_WRITEREQ_QM1_REPLACE  ,PROPID_QM_SERVICE  ,MQADSpQM1SetMachineService},
{PROPID_QM_MASTERID      ,MQ_QM_MASTERID_ATTRIBUTE      ,VT_CLSID           ,MQ_QM_MASTERID_ADSTYPE     ,MQADSpRetrieveMachineMasterId           ,FALSE      ,TRUE  ,NULL                                   ,NULL                    ,NULL                     ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_QM_HASHKEY       ,NULL                          ,VT_UI4             ,ADSTYPE_INVALID            ,NULL                                    ,FALSE      ,FALSE ,NULL                                   ,NULL                    ,NULL                     ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_QM_SEQNUM        ,NULL                          ,VT_BLOB            ,ADSTYPE_INVALID            ,NULL                                    ,FALSE      ,FALSE ,NULL                                   ,NULL                    ,NULL                     ,e_NO_NOTIFY_ERROR_WRITEREQ_QM1,0                   ,NULL},
{PROPID_QM_QUOTA         ,MQ_QM_QUOTA_ATTRIBUTE         ,VT_UI4             ,MQ_QM_QUOTA_ADSTYPE        ,NULL                                    ,FALSE      ,FALSE ,(MQPROPVARIANT*)&varDefaultQMQuota     ,NULL                    ,NULL                     ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_QM_JOURNAL_QUOTA ,MQ_QM_JOURNAL_QUOTA_ATTRIBUTE ,VT_UI4             ,MQ_QM_JOURNAL_QUOTA_ADSTYPE,NULL                                    ,FALSE      ,FALSE ,(MQPROPVARIANT*)&varDefaultQMJQuota    ,NULL                    ,NULL                     ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_QM_MACHINE_TYPE  ,MQ_QM_MACHINE_TYPE_ATTRIBUTE  ,VT_LPWSTR          ,MQ_QM_MACHINE_TYPE_ADSTYPE ,NULL                                    ,FALSE      ,FALSE ,(MQPROPVARIANT*)&varDefaultQMMType     ,NULL                    ,NULL                     ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_QM_CREATE_TIME   ,MQ_QM_CREATE_TIME_ATTRIBUTE   ,VT_I4              ,MQ_QM_CREATE_TIME_ADSTYPE  ,NULL                                    ,FALSE      ,FALSE ,NULL                                   ,NULL                    ,NULL                     ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_QM_MODIFY_TIME   ,MQ_QM_MODIFY_TIME_ATTRIBUTE   ,VT_I4              ,MQ_QM_MODIFY_TIME_ADSTYPE  ,NULL                                    ,FALSE      ,FALSE ,NULL                                   ,NULL                    ,NULL                     ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_QM_FOREIGN       ,MQ_QM_FOREIGN_ATTRIBUTE       ,VT_UI1             ,MQ_QM_FOREIGN_ADSTYPE      ,NULL                                    ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultQMForeign   ,NULL                    ,NULL                     ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_QM_OS            ,MQ_QM_OS_ATTRIBUTE            ,VT_UI4             ,MQ_QM_OS_ADSTYPE           ,NULL                                    ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultQMOs        ,NULL                    ,NULL                     ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_QM_SECURITY      ,MQ_QM_SECURITY_ATTRIBUTE      ,VT_BLOB            ,MQ_QM_SECURITY_ADSTYPE     ,NULL                                    ,FALSE      ,TRUE  ,NULL                                   ,NULL                    ,NULL                     ,e_NOTIFY_WRITEREQ_QM1_REPLACE ,PROPID_QM_SECURITY  ,MQADSpQM1SetSecurity},
{PROPID_QM_SIGN_PK       ,MQ_QM_SIGN_PK_ATTRIBUTE       ,VT_BLOB            ,MQ_QM_SIGN_PK_ADSTYPE      ,NULL                                    ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultQMSignPk    ,NULL                    ,NULL                     ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_QM_ENCRYPT_PK    ,MQ_QM_ENCRYPT_PK_ATTRIBUTE    ,VT_BLOB            ,MQ_QM_ENCRYPT_PK_ADSTYPE   ,NULL                                    ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultQMEncryptPk ,NULL                    ,NULL                     ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_QM_FULL_PATH     ,MQ_QM_FULL_PATH_ATTRIBUTE     ,VT_LPWSTR          ,MQ_QM_FULL_PATH_ADSTYPE    ,NULL                                    ,FALSE      ,TRUE  ,NULL                                   ,NULL                    ,NULL                     ,e_NO_NOTIFY_NO_WRITEREQ_QM1   ,0                   ,NULL},
{PROPID_QM_SITE_IDS      ,MQ_QM_SITES_ATTRIBUTE         ,VT_CLSID|VT_VECTOR ,MQ_QM_SITES_ADSTYPE        ,NULL                                    ,TRUE       ,TRUE  ,(MQPROPVARIANT*)&varDefaultQMSiteIDs   ,NULL                    ,NULL                     ,e_NOTIFY_WRITEREQ_QM1_REPLACE ,PROPID_QM_SITE_ID   ,MQADSpQM1SetMachineSite},
{PROPID_QM_OUTFRS_DN     ,MQ_QM_OUTFRS_ATTRIBUTE        ,VT_LPWSTR|VT_VECTOR,MQ_QM_OUTFRS_ADSTYPE       ,NULL                                    ,TRUE       ,TRUE  ,(MQPROPVARIANT*)&varDefaultQMOutFrs    ,NULL                    ,NULL                     ,e_NOTIFY_WRITEREQ_QM1_REPLACE ,PROPID_QM_OUTFRS    ,MQADSpQM1SetMachineOutFrss},
{PROPID_QM_INFRS_DN      ,MQ_QM_INFRS_ATTRIBUTE         ,VT_LPWSTR|VT_VECTOR,MQ_QM_OUTFRS_ADSTYPE       ,NULL                                    ,TRUE       ,TRUE  ,(MQPROPVARIANT*)&varDefaultQMInFrs     ,NULL                    ,NULL                     ,e_NOTIFY_WRITEREQ_QM1_REPLACE ,PROPID_QM_INFRS     ,MQADSpQM1SetMachineInFrss},
{PROPID_QM_NT4ID         ,MQ_QM_NT4ID_ATTRIBUTE         ,VT_CLSID           ,MQ_QM_NT4ID_ADSTYPE        ,NULL                                    ,FALSE      ,TRUE  ,NULL                                   ,NULL                    ,NULL                     ,e_NO_NOTIFY_ERROR_WRITEREQ_QM1,0                   ,NULL},
{PROPID_QM_DONOTHING     ,NULL                          ,VT_UI1             ,ADSTYPE_INVALID            ,NULL                                    ,FALSE      ,FALSE ,NULL                                   ,NULL                    ,NULL                     ,e_NO_NOTIFY_ERROR_WRITEREQ_QM1,0                   ,NULL},
{PROPID_QM_OBJ_SECURITY  ,MQ_QM_SECURITY_ATTRIBUTE      ,VT_BLOB            ,MQ_QM_SECURITY_ADSTYPE     ,NULL                                    ,FALSE      ,TRUE  ,NULL                                   ,NULL                    ,NULL                     ,e_NO_NOTIFY_NO_WRITEREQ_QM1   ,0                   ,NULL},
{PROPID_QM_SECURITY_INFORMATION   ,NULL                 ,VT_UI1             ,ADSTYPE_INVALID            ,MQADSpRetrieveNothing                   ,FALSE      ,FALSE ,NULL                                   ,NULL                    ,NULL                     ,e_NO_NOTIFY_ERROR_WRITEREQ_QM1,0                   ,NULL},
{PROPID_QM_ENCRYPT_PKS   ,MQ_QM_ENCRYPT_PK_ATTRIBUTE    ,VT_BLOB            ,MQ_QM_ENCRYPT_PK_ADSTYPE   ,NULL                                    ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultQMEncryptPk ,NULL                    ,NULL                     ,e_NO_NOTIFY_ERROR_WRITEREQ_QM1,0                   ,NULL},
{PROPID_QM_SIGN_PKS      ,MQ_QM_SIGN_PK_ATTRIBUTE       ,VT_BLOB            ,MQ_QM_SIGN_PK_ADSTYPE      ,NULL                                    ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultQMSignPk    ,NULL                    ,NULL                     ,e_NO_NOTIFY_ERROR_WRITEREQ_QM1,0                   ,NULL},
{PROPID_QM_PATHNAME_DNS  ,NULL                          ,VT_LPWSTR          ,ADSTYPE_INVALID            ,MQADSpRetrieveMachineDNSName            ,FALSE      ,FALSE ,NULL                                   ,NULL                    ,NULL                     ,e_NOTIFY_WRITEREQ_QM1_AS_IS   ,0                   ,NULL},
{PROPID_QM_WORKGROUP_ID  ,MQ_QM_WORKGROUP_ID_ATTRIBUTE  ,VT_CLSID           ,MQ_QM_WORKGROUP_ID_ADSTYPE ,NULL                                    ,FALSE      ,TRUE  ,NULL                                   ,NULL                    ,NULL                     ,e_NO_NOTIFY_ERROR_WRITEREQ_QM1,0                   ,NULL},
{PROPID_QM_DESCRIPTION   ,MQ_QM_DESCRIPTION_ATTRIBUTE   ,VT_LPWSTR          ,MQ_QM_DESCRIPTION_ADSTYPE  ,NULL                                    ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultQMDescription ,NULL                  ,NULL                     ,e_NO_NOTIFY_NO_WRITEREQ_QM1   ,0                   ,NULL}
};   

 

 
//
//      Default values for enterprise properties
//

const defaultVARIANT varDefaultENameStyle = { VT_UI1, 0,0,0, DEFAULT_E_NAMESTYLE, 0};
const defaultVARIANT varDefaultECspName = { VT_LPWSTR, 0,0,0, (LONG_PTR)DEFAULT_E_DEFAULTCSP, 0};
const defaultVARIANT varDefaultELongLive = { VT_UI4, 0,0,0, MSMQ_DEFAULT_LONG_LIVE, 0};
const defaultVARIANT varDefaultEVersion = { VT_UI2, 0,0,0, DEFAULT_E_VERSION, 0};
const defaultVARIANT varDefaultEInterval1 = { VT_UI2, 0,0,0, DEFAULT_S_INTERVAL1, 0};
const defaultVARIANT varDefaultEInterval2 = { VT_UI2, 0,0,0, DEFAULT_S_INTERVAL2, 0};
                                                                                                                                                                                                                         
MQTranslateInfo   EnterpriseTranslateInfo[] = {
// PROPID                | attribute-name               | vartype           | adstype                    | Translation routine                    | multivalue| InGC | default value                         | Set routine | Create routine | QM1 action | notify-QM1-replace | QM1-Set routine |
//-----------------------|------------------------------|-------------------|----------------------------|----------------------------------------|-----------|------|---------------------------------------|-------------|----------------|------------|--------------------|-----------------|
{PROPID_E_NAME           ,NULL                          ,VT_LPWSTR          ,ADSTYPE_INVALID             ,MQADSpRetrieveEnterpriseName            ,FALSE      ,FALSE ,NULL                                   ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_E_NAMESTYLE      ,MQ_E_NAMESTYLE_ATTRIBUTE      ,VT_UI1             ,MQ_E_NAMESTYLE_ADSTYPE      ,NULL                                    ,FALSE      ,FALSE ,(MQPROPVARIANT*)&varDefaultENameStyle  ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_E_CSP_NAME       ,MQ_E_CSP_NAME_ATTRIBUTE       ,VT_LPWSTR          ,MQ_E_CSP_NAME_ADSTYPE       ,NULL                                    ,FALSE      ,FALSE ,(MQPROPVARIANT*)&varDefaultECspName    ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_E_PECNAME        ,NULL                          ,VT_LPWSTR          ,ADSTYPE_INVALID             ,MQADSpRetrieveEnterprisePEC             ,FALSE      ,FALSE ,NULL                                   ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_E_S_INTERVAL1    ,MQ_E_INTERVAL1                ,VT_UI2             ,MQ_E_INTERVAL1_ADSTYPE      ,NULL                                    ,FALSE      ,FALSE ,(MQPROPVARIANT*)&varDefaultEInterval1  ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_E_S_INTERVAL2    ,MQ_E_INTERVAL2                ,VT_UI2             ,MQ_E_INTERVAL2_ADSTYPE      ,NULL                                    ,FALSE      ,FALSE ,(MQPROPVARIANT*)&varDefaultEInterval2  ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_E_MASTERID       ,NULL                          ,VT_CLSID           ,ADSTYPE_INVALID             ,NULL                                    ,FALSE      ,FALSE ,NULL                                   ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_E_SEQNUM         ,NULL                          ,VT_BLOB            ,ADSTYPE_INVALID             ,NULL                                    ,FALSE      ,FALSE ,NULL                                   ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_E_ID             ,MQ_E_ID_ATTRIBUTE             ,VT_CLSID           ,MQ_E_ID_ADSTYPE             ,NULL                                    ,FALSE      ,FALSE ,NULL                                   ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_E_CRL            ,NULL                          ,VT_BLOB            ,ADSTYPE_INVALID             ,NULL                                    ,FALSE      ,FALSE ,NULL                                   ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_E_CSP_TYPE       ,NULL                          ,VT_UI4             ,ADSTYPE_INVALID             ,NULL                                    ,FALSE      ,FALSE ,NULL                                   ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_E_ENCRYPT_ALG    ,NULL                          ,VT_UI4             ,ADSTYPE_INVALID             ,NULL                                    ,FALSE      ,FALSE ,NULL                                   ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_E_SIGN_ALG       ,NULL                          ,VT_UI4             ,ADSTYPE_INVALID             ,NULL                                    ,FALSE      ,FALSE ,NULL                                   ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_E_HASH_ALG       ,NULL                          ,VT_UI4             ,ADSTYPE_INVALID             ,NULL                                    ,FALSE      ,FALSE ,NULL                                   ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_E_CIPHER_MODE    ,NULL                          ,VT_UI4             ,ADSTYPE_INVALID             ,NULL                                    ,FALSE      ,FALSE ,NULL                                   ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_E_LONG_LIVE      ,MQ_E_LONG_LIVE_ATTRIBUTE      ,VT_UI4             ,MQ_E_LONG_LIVE_ADSTYPE      ,NULL                                    ,FALSE      ,FALSE ,(MQPROPVARIANT*)&varDefaultELongLive   ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_E_VERSION        ,MQ_E_VERSION_ATTRIBUTE        ,VT_UI2             ,MQ_E_VERSION_ADSTYPE        ,NULL                                    ,FALSE      ,FALSE ,(MQPROPVARIANT*)&varDefaultEVersion    ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_E_NT4ID          ,MQ_E_NT4ID_ATTRIBUTE          ,VT_CLSID           ,MQ_E_NT4ID_ADSTYPE          ,NULL                                    ,FALSE      ,FALSE ,NULL                                   ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_E_SECURITY       ,MQ_E_SECURITY_ATTRIBUTE       ,VT_BLOB            ,MQ_E_SECURITY_ADSTYPE       ,NULL                                    ,FALSE      ,FALSE ,NULL                                   ,NULL         ,NULL            ,0           ,0                   ,NULL}
};


const defaultVARIANT varDefaultLGatesDN = { VT_LPWSTR|VT_VECTOR, 0,0,0, 0, 0};
const defaultVARIANT varDefaultLGates = { VT_CLSID|VT_VECTOR, 0,0,0, 0, 0};
const defaultVARIANT varDefaultLDescription = { VT_LPWSTR, 0,0,0, (LONG_PTR)TEXT(""), 0};

MQTranslateInfo   SiteLinkTranslateInfo[] = {
// PROPID                | attribute-name               | vartype           | adstype                   | Translation routine                    | multivalue| InGC | default value                  | Set routine           | Creare routine          | QM1 action | notify-QM1-replace | QM1-Set routine |
//-----------------------|------------------------------|-------------------|---------------------------|----------------------------------------|-----------|------|--------------------------------|-----------------------|-------------------------|------------|--------------------|-----------------|
{PROPID_L_NEIGHBOR1      ,NULL                          ,VT_CLSID           ,ADSTYPE_INVALID            ,MQADSpRetrieveLinkNeighbor1             ,FALSE      ,FALSE ,NULL                            ,MQADSpSetLinkNeighbor1 ,MQADSpCreateLinkNeighbor1,0           ,0                   ,NULL},
{PROPID_L_NEIGHBOR2      ,NULL                          ,VT_CLSID           ,ADSTYPE_INVALID            ,MQADSpRetrieveLinkNeighbor2             ,FALSE      ,FALSE ,NULL                            ,MQADSpSetLinkNeighbor2 ,MQADSpCreateLinkNeighbor2,0           ,0                   ,NULL},
{PROPID_L_COST           ,NULL                          ,VT_UI4             ,ADSTYPE_INVALID            ,MQADSpRetrieveLinkCost                  ,FALSE      ,FALSE ,NULL                            ,MQADSpSetLinkCost      ,MQADSpCreateLinkCost     ,0           ,0                   ,NULL},
{PROPID_L_MASTERID       ,NULL                          ,VT_CLSID           ,ADSTYPE_INVALID            ,NULL                                    ,FALSE      ,FALSE ,NULL                            ,NULL                   ,NULL                     ,0           ,0                   ,NULL},
{PROPID_L_SEQNUM         ,NULL                          ,VT_BLOB            ,ADSTYPE_INVALID            ,NULL                                    ,FALSE      ,FALSE ,NULL                            ,NULL                   ,NULL                     ,0           ,0                   ,NULL},
{PROPID_L_ID             ,MQ_L_ID_ATTRIBUTE             ,VT_CLSID           ,MQ_L_ID_ADSTYPE            ,NULL                                    ,FALSE      ,FALSE ,NULL                            ,NULL                   ,NULL                     ,0           ,0                   ,NULL},
{PROPID_L_GATES_DN       ,MQ_L_SITEGATES_ATTRIBUTE      ,VT_LPWSTR|VT_VECTOR,MQ_L_SITEGATES_ADSTYPE     ,NULL                                    ,TRUE       ,FALSE ,(MQPROPVARIANT*)&varDefaultLGatesDN,NULL                ,NULL                     ,0           ,0                   ,NULL},
{PROPID_L_NEIGHBOR1_DN   ,MQ_L_NEIGHBOR1_ATTRIBUTE      ,VT_LPWSTR          ,MQ_L_NEIGHBOR1_ADSTYPE     ,NULL                                    ,FALSE      ,FALSE ,NULL                            ,NULL                   ,NULL                     ,0           ,0                   ,NULL},
{PROPID_L_NEIGHBOR2_DN   ,MQ_L_NEIGHBOR2_ATTRIBUTE      ,VT_LPWSTR          ,MQ_L_NEIGHBOR2_ADSTYPE     ,NULL                                    ,FALSE      ,FALSE ,NULL                            ,NULL                   ,NULL                     ,0           ,0                   ,NULL},
{PROPID_L_DESCRIPTION    ,MQ_L_DESCRIPTION_ATTRIBUTE    ,VT_LPWSTR          ,MQ_L_DESCRIPTION_ADSTYPE   ,NULL                                    ,FALSE      ,FALSE ,(MQPROPVARIANT*)&varDefaultLDescription,NULL            ,NULL                     ,0           ,0                   ,NULL},
{PROPID_L_FULL_PATH      ,MQ_L_FULL_PATH_ATTRIBUTE      ,VT_LPWSTR          ,MQ_L_FULL_PATH_ADSTYPE     ,NULL                                    ,FALSE      ,TRUE  ,NULL                            ,NULL                   ,NULL                     ,0           ,0                   ,NULL},            
{PROPID_L_ACTUAL_COST    ,MQ_L_COST_ATTRIBUTE           ,VT_UI4             ,MQ_L_COST_ADSTYPE          ,NULL                                    ,FALSE      ,FALSE ,NULL                            ,NULL                   ,NULL                     ,0           ,0                   ,NULL},
{PROPID_L_GATES          ,NULL                          ,VT_CLSID|VT_VECTOR ,ADSTYPE_INVALID            ,MQADSpRetrieveLinkGates                 ,TRUE       ,FALSE ,(MQPROPVARIANT*)&varDefaultLGates,NULL                  ,NULL                     ,0           ,0                   ,NULL}
};


const defaultVARIANT varDefaultUserSignCert = { VT_BLOB, 0,0,0, 0, 0};
const defaultVARIANT varDefaultUserDigest = { VT_VECTOR | VT_CLSID, 0,0,0,0,0};

MQTranslateInfo   UserTranslateInfo[] = {
// PROPID                | attribute-name               | vartype           | adstype                   | Translation routine                    | multivalue| InGC | default value                          | Set routine | Create routine | QM1 action | notify-QM1-replace | QM1-Set routine |
//-----------------------|------------------------------|-------------------|---------------------------|----------------------------------------|-----------|------|----------------------------------------|-------------|----------------|------------|--------------------|-----------------|
{PROPID_U_SID            ,MQ_U_SID_ATTRIBUTE            ,VT_BLOB            ,MQ_U_SID_ADSTYPE           ,NULL                                    ,FALSE      ,TRUE  ,NULL                                    ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_U_SIGN_CERT      ,MQ_U_SIGN_CERT_ATTRIBUTE      ,VT_BLOB            ,MQ_U_SIGN_CERT_ADSTYPE     ,NULL                                    ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultUserSignCert ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_U_MASTERID       ,NULL                          ,VT_CLSID           ,ADSTYPE_INVALID            ,NULL                                    ,FALSE      ,FALSE ,NULL                                    ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_U_SEQNUM         ,NULL                          ,VT_BLOB            ,ADSTYPE_INVALID            ,NULL                                    ,FALSE      ,FALSE ,NULL                                    ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_U_DIGEST         ,MQ_U_DIGEST_ATTRIBUTE         ,VT_CLSID|VT_VECTOR ,MQ_U_DIGEST_ADSTYPE        ,NULL                                    ,TRUE       ,TRUE  ,(MQPROPVARIANT*)&varDefaultUserDigest   ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_U_ID             ,MQ_U_ID_ATTRIBUTE             ,VT_CLSID           ,MQ_U_ID_ADSTYPE            ,NULL                                    ,FALSE      ,TRUE  ,NULL                                    ,NULL         ,NULL            ,0           ,0                   ,NULL}
};

MQTranslateInfo   MQUserTranslateInfo[] = {
// PROPID                | attribute-name               | vartype           | adstype                   | Translation routine                    | multivalue| InGC | default value                          | Set routine | Create routine | QM1 action | notify-QM1-replace | QM1-Set routine |
//-----------------------|------------------------------|-------------------|---------------------------|----------------------------------------|-----------|------|----------------------------------------|-------------|----------------|------------|--------------------|-----------------|
{PROPID_MQU_SID          ,MQ_MQU_SID_ATTRIBUTE          ,VT_BLOB            ,MQ_MQU_SID_ADSTYPE         ,NULL                                     ,FALSE     ,TRUE  ,NULL                                    ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_MQU_SIGN_CERT    ,MQ_MQU_SIGN_CERT_ATTRIBUTE    ,VT_BLOB            ,MQ_MQU_SIGN_CERT_ADSTYPE   ,NULL                                     ,FALSE     ,TRUE  ,(MQPROPVARIANT*)&varDefaultUserSignCert ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_MQU_MASTERID     ,NULL                          ,VT_CLSID           ,ADSTYPE_INVALID            ,NULL                                     ,FALSE     ,FALSE ,NULL                                    ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_MQU_SEQNUM       ,NULL                          ,VT_BLOB            ,ADSTYPE_INVALID            ,NULL                                     ,FALSE     ,FALSE ,NULL                                    ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_MQU_DIGEST       ,MQ_MQU_DIGEST_ATTRIBUTE       ,VT_CLSID|VT_VECTOR ,MQ_MQU_DIGEST_ADSTYPE      ,NULL                                     ,TRUE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultUserDigest   ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_MQU_ID           ,MQ_MQU_ID_ATTRIBUTE           ,VT_CLSID           ,MQ_MQU_ID_ADSTYPE          ,NULL                                     ,FALSE     ,TRUE  ,NULL                                    ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_MQU_SECURITY     ,MQ_MQU_SECURITY_ATTRIBUTE     ,VT_BLOB            ,MQ_MQU_SECURITY_ADSTYPE    ,NULL                                     ,FALSE     ,TRUE  ,NULL                                    ,NULL         ,NULL            ,0           ,0                   ,NULL}
};

const defaultVARIANT varDefaultSForeign = { VT_UI1, 0,0,0, 0, 0};
const defaultVARIANT varDefaultSInterval1 = { VT_UI2, 0,0,0, DEFAULT_S_INTERVAL1, 0};
const defaultVARIANT varDefaultSInterval2 = { VT_UI2, 0,0,0, DEFAULT_S_INTERVAL2, 0};


MQTranslateInfo   SiteTranslateInfo[] = {
// PROPID                | attribute-name               | vartype           | adstype                   | Translation routine                    | multivalue| InGC | default value                     | Set routine | Create routine | QM1 action | notify-QM1-replace | QM1-Set routine |
//-----------------------|------------------------------|-------------------|---------------------------|----------------------------------------|-----------|------|-----------------------------------|-------------|----------------|------------|--------------------|-----------------|
{PROPID_S_PATHNAME       ,MQ_S_NAME_ATTRIBUTE           ,VT_LPWSTR          ,MQ_S_NAME_ADSTYPE          ,NULL                                    ,FALSE      ,FALSE ,NULL                               ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_S_SITEID         ,MQ_S_ID_ATTRIBUTE             ,VT_CLSID           ,MQ_S_ID_ADSTYPE            ,NULL                                    ,FALSE      ,FALSE ,NULL                               ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_S_PSC            ,NULL                          ,VT_LPWSTR          ,ADSTYPE_INVALID            ,NULL                                    ,FALSE      ,FALSE ,NULL                               ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_S_INTERVAL1      ,MQ_S_INTERVAL1                ,VT_UI2             ,MQ_S_INTERVAL1_ADSTYPE     ,NULL                                    ,FALSE      ,FALSE ,(MQPROPVARIANT*)&varDefaultSInterval1,NULL       ,NULL            ,0           ,0                   ,NULL},
{PROPID_S_INTERVAL2      ,MQ_S_INTERVAL2                ,VT_UI2             ,MQ_S_INTERVAL2_ADSTYPE     ,NULL                                    ,FALSE      ,FALSE ,(MQPROPVARIANT*)&varDefaultSInterval2,NULL       ,NULL            ,0           ,0                   ,NULL},
{PROPID_S_MASTERID       ,NULL                          ,VT_CLSID           ,ADSTYPE_INVALID            ,NULL                                    ,FALSE      ,FALSE ,NULL                               ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_S_SEQNUM         ,NULL                          ,VT_BLOB            ,ADSTYPE_INVALID            ,NULL                                    ,FALSE      ,FALSE ,NULL                               ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_S_SECURITY       ,MQ_S_SECURITY_ATRRIBUTE       ,VT_BLOB            ,MQ_S_SECURITY_ADSTYPE      ,NULL                                    ,FALSE      ,FALSE ,NULL                               ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_S_PSC_SIGNPK     ,NULL                          ,VT_BLOB            ,ADSTYPE_INVALID            ,MQADSpRetrieveSiteSignPK                ,FALSE      ,FALSE ,NULL                               ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_S_GATES          ,NULL                          ,VT_CLSID|VT_VECTOR ,ADSTYPE_INVALID            ,MQADSpRetrieveSiteGates                 ,FALSE      ,FALSE ,NULL                               ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_S_FULL_NAME      ,MQ_S_FULL_NAME_ATTRIBUTE      ,VT_LPWSTR          ,MQ_S_FULL_NAME_ADSTYPE     ,NULL                                    ,FALSE      ,FALSE ,NULL                               ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_S_NT4_STUB       ,MQ_S_NT4_STUB_ATTRIBUTE       ,VT_UI2             ,MQ_S_NT4_STUB_ADSTYPE      ,NULL                                    ,FALSE      ,FALSE ,NULL                               ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_S_FOREIGN        ,MQ_S_FOREIGN_ATTRIBUTE        ,VT_UI1             ,MQ_S_FOREIGN_ADSTYPE       ,NULL                                    ,FALSE      ,FALSE ,(MQPROPVARIANT*)&varDefaultSForeign,NULL         ,NULL            ,0           ,0                   ,NULL},                                         
{PROPID_S_DONOTHING      ,NULL                          ,VT_UI1             ,ADSTYPE_INVALID            ,NULL                                    ,FALSE      ,FALSE ,NULL                               ,NULL         ,NULL            ,0           ,0                   ,NULL}
};

MQTranslateInfo   CnTranslateInfo[] = {
// PROPID                | attribute-name               | vartype           | adstype                   | Translation routine                    | multivalue| InGC | default value                     | Set routine | Create routine | QM1 action | notify-QM1-replace | QM1-Set routine |
//-----------------------|------------------------------|-------------------|---------------------------|----------------------------------------|-----------|------|-----------------------------------|-------------|----------------|------------|--------------------|-----------------|
{PROPID_CN_SECURITY       ,MQ_S_SECURITY_ATRRIBUTE       ,VT_BLOB            ,MQ_S_SECURITY_ADSTYPE      ,NULL                                    ,FALSE      ,FALSE ,NULL                               ,NULL         ,NULL            ,0           ,0                   ,NULL}
};

MQTranslateInfo   ServerTranslateInfo[] = {
// PROPID                | attribute-name               | vartype           | adstype                   | Translation routine                    | multivalue| default value | Set routine | Create routine | QM1 action | notify-QM1-replace | QM1-Set routine |
//-----------------------|------------------------------|-------------------|---------------------------|----------------------------------------|-----------|---------------|-------------|----------------|------------|--------------------|-----------------|
{PROPID_SRV_NAME         ,MQ_SRV_NAME_ATTRIBUTE         ,VT_LPWSTR          ,MQ_SRV_NAME_ADSTYPE        ,NULL                                    ,FALSE      ,NULL           ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_SRV_ID           ,MQ_SRV_ID_ATTRIBUTE           ,VT_CLSID           ,MQ_SRV_ID_ADSTYPE          ,NULL                                    ,FALSE      ,NULL           ,NULL         ,NULL            ,0           ,0                   ,NULL},                              
{PROPID_SRV_FULL_PATH    ,MQ_SRV_FULL_PATH_ATTRIBUTE    ,VT_LPWSTR          ,MQ_SRV_FULL_PATH_ADSTYPE   ,NULL                                    ,FALSE      ,NULL           ,NULL         ,NULL            ,0           ,0                   ,NULL}                              
};

MQTranslateInfo   SettingTranslateInfo[] = {
// PROPID                | attribute-name               | vartype           | adstype                   | Translation routine                    | multivalue| default value | Set routine | Create routine | QM1 action | notify-QM1-replace | QM1-Set routine |
//-----------------------|------------------------------|-------------------|---------------------------|----------------------------------------|-----------|---------------|-------------|----------------|------------|--------------------|-----------------|
{PROPID_SET_NAME         ,MQ_SET_NAME_ATTRIBUTE         ,VT_LPWSTR          ,MQ_SET_NAME_ADSTYPE        ,NULL                                    ,FALSE      ,NULL           ,NULL         ,NULL            ,0           ,0                   ,NULL},
// [adsrv] Next one provides access to the old PROPID_SET_SERVICE from migration and replication, like QueryNt4PSCs
{PROPID_SET_OLDSERVICE    ,MQ_SET_SERVICE_ATTRIBUTE      ,VT_UI4             ,MQ_SET_SERVICE_ADSTYPE     ,NULL                                   ,FALSE      ,NULL           ,NULL         ,NULL            ,0           ,0                   ,NULL}, // [adsrv] TBD notification
{PROPID_SET_SERVICE_ROUTING   ,MQ_SET_SERVICE_ROUTING_ATTRIBUTE   ,VT_UI1 ,MQ_SET_SERVICE_ROUTING_ADSTYPE     ,NULL                              ,FALSE      ,NULL           ,NULL         ,NULL            ,0           ,0                   ,NULL},// [adsrv] TBD notification
{PROPID_SET_SERVICE_DSSERVER  ,MQ_SET_SERVICE_DSSERVER_ATTRIBUTE  ,VT_UI1 ,MQ_SET_SERVICE_DSSERVER_ADSTYPE    ,NULL                              ,FALSE      ,NULL           ,NULL         ,NULL            ,0           ,0                   ,NULL},// [adsrv] TBD notification
{PROPID_SET_SERVICE_DEPCLIENTS,MQ_SET_SERVICE_DEPCLIENTS_ATTRIBUTE,VT_UI1 ,MQ_SET_SERVICE_DEPCLIENTS_ADSTYPE  ,NULL                              ,FALSE      ,NULL           ,NULL         ,NULL            ,0           ,0                   ,NULL},// [adsrv] TBD notification
{PROPID_SET_QM_ID        ,MQ_SET_QM_ID_ATTRIBUTE        ,VT_CLSID           ,MQ_SET_QM_ID_ADSTYPE       ,NULL                                    ,FALSE      ,NULL           ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_SET_APPLICATION  ,MQ_SET_APPLICATION_ATTRIBUTE  ,VT_LPWSTR          ,MQ_SET_QM_ID_ADSTYPE       ,NULL                                    ,FALSE      ,NULL           ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_SET_FULL_PATH    ,MQ_SET_FULL_PATH_ATTRIBUTE    ,VT_LPWSTR          ,MQ_SET_FULL_PATH_ADSTYPE   ,NULL                                    ,FALSE      ,NULL           ,NULL         ,NULL            ,0           ,0                   ,NULL},          
{PROPID_SET_NT4          ,MQ_SET_NT4_ATTRIBUTE          ,VT_UI4             ,MQ_SET_NT4_ADSTYPE         ,NULL                                    ,FALSE      ,NULL           ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_SET_MASTERID     ,MQ_SET_MASTERID_ATTRIBUTE     ,VT_CLSID           ,MQ_SET_MASTERID_ADSTYPE    ,NULL                                    ,FALSE      ,NULL           ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_SET_SITENAME     ,MQ_SET_SITENAME_ATTRIBUTE     ,VT_LPWSTR          ,MQ_SET_SITENAME_ADSTYPE    ,NULL                                    ,FALSE      ,NULL           ,NULL         ,NULL            ,0           ,0                   ,NULL}
};

MQTranslateInfo ComputerTranslateInfo[] = {
// PROPID                   | attribute-name                   | vartype           | adstype                       | Translation routine                    | multivalue| InGC | default value                          | Set routine | Create routine | QM1 action | notify-QM1-replace | QM1-Set routine |
//--------------------------|----------------------------------|-------------------|-------------------------------|----------------------------------------|-----------|------|----------------------------------------|-------------|----------------|------------|--------------------|-----------------|
{PROPID_COM_FULL_PATH       ,MQ_COM_FULL_PATH_ATTRIBUTE        ,VT_LPWSTR          ,MQ_COM_FULL_PATH_ADSTYPE       ,NULL                                    ,FALSE      ,FALSE ,NULL                                    ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_COM_SAM_ACCOUNT     ,MQ_COM_SAM_ACCOUNT_ATTRIBUTE      ,VT_LPWSTR          ,MQ_COM_SAM_ACCOUNT_ADSTYPE     ,NULL                                    ,FALSE      ,FALSE ,NULL                                    ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_COM_CONTAINER       ,NULL                              ,VT_LPWSTR          ,ADSTYPE_INVALID                ,NULL                                    ,FALSE      ,FALSE ,NULL                                    ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_COM_ACCOUNT_CONTROL ,MQ_COM_ACCOUNT_CONTROL_ATTRIBUTE  ,VT_UI4             ,MQ_COM_ACCOUNT_CONTROL_ADSTYPE ,NULL                                    ,FALSE      ,FALSE ,NULL                                    ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_COM_DNS_HOSTNAME    ,MQ_COM_DNS_HOSTNAME_ATTRIBUTE     ,VT_LPWSTR          ,MQ_COM_DNS_HOSTNAME_ADSTYPE    ,NULL                                    ,FALSE      ,FALSE ,NULL                                    ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_COM_SID             ,MQ_COM_SID_ATTRIBUTE              ,VT_BLOB            ,MQ_COM_SID_ADSTYPE             ,NULL                                    ,FALSE      ,FALSE ,NULL                                    ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_COM_SIGN_CERT       ,MQ_COM_SIGN_CERT_ATTRIBUTE        ,VT_BLOB            ,MQ_COM_SIGN_CERT_ADSTYPE       ,NULL                                    ,FALSE      ,TRUE  ,(MQPROPVARIANT*)&varDefaultUserSignCert ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_COM_DIGEST          ,MQ_COM_DIGEST_ATTRIBUTE           ,VT_CLSID|VT_VECTOR ,MQ_COM_DIGEST_ADSTYPE          ,NULL                                    ,TRUE       ,TRUE  ,(MQPROPVARIANT*)&varDefaultUserDigest   ,NULL         ,NULL            ,0           ,0                   ,NULL},
{PROPID_COM_ID              ,MQ_COM_ID_ATTRIBUTE               ,VT_CLSID           ,MQ_COM_ID_ADSTYPE              ,NULL                                    ,FALSE      ,TRUE  ,NULL                                    ,NULL         ,NULL            ,0           ,0                   ,NULL}
};

//-----------------------------------------------------
// Helper macro to get the number of elements in a static array
//
//-----------------------------------------------------
#define ARRAY_SIZE(array)   (sizeof(array)/sizeof(array[0]))

//
//  An array that keeps the category strings of the classes
//
AP<WCHAR> pwcsCategory[e_MSMQ_NUMBER_OF_CLASSES];

//-----------------------------------------------------
// MSMQ classes
// keep in the same order as the enum in mqads.h
//-----------------------------------------------------
const MQClassInfo g_MSMQClassInfo[e_MSMQ_NUMBER_OF_CLASSES] = {
// class name                          | properties table       | number of properties in table       | get translation object routine | context                  | dwObjType        | ObjectCategory  | category                                | Category Len
//-------------------------------------|------------------------|-------------------------------------|--------------------------------|--------------------------|------------------|-----------------|-----------------------------------------|---------------------
{MSMQ_COMPUTER_CONFIGURATION_CLASS_NAME, MachineTranslateInfo,    ARRAY_SIZE(MachineTranslateInfo),     GetMsmqQmXlateInfo,            e_RootDSE,                   MQDS_MACHINE,     &pwcsCategory[0], x_ComputerConfigurationCategoryName,     x_ComputerConfigurationCategoryLength},
{MSMQ_QUEUE_CLASS_NAME,                  QueueTranslateInfo,      ARRAY_SIZE(QueueTranslateInfo),       GetDefaultMsmqObjXlateInfo,    e_RootDSE,                   MQDS_QUEUE,       &pwcsCategory[1], x_QueueCategoryName,                     x_QueueCategoryLength},
{MSMQ_SERVICE_CLASS_NAME,                EnterpriseTranslateInfo, ARRAY_SIZE(EnterpriseTranslateInfo),  GetDefaultMsmqObjXlateInfo,    e_ServicesContainer,         MQDS_ENTERPRISE,  &pwcsCategory[2], x_ServiceCategoryName,                   x_ServiceCategoryLength},
{MSMQ_SITELINK_CLASS_NAME,               SiteLinkTranslateInfo,   ARRAY_SIZE(SiteLinkTranslateInfo),    GetDefaultMsmqObjXlateInfo,    e_MsmqServiceContainer,      MQDS_SITELINK,    &pwcsCategory[3], x_LinkCategoryName,                      x_LinkCategoryLength},
{MSMQ_USER_CLASS_NAME,                   UserTranslateInfo,       ARRAY_SIZE(UserTranslateInfo),        GetDefaultMsmqObjXlateInfo,    e_RootDSE,                   MQDS_USER,        &pwcsCategory[4], x_UserCategoryName,                      x_UserCategoryLength},
{MSMQ_SETTING_CLASS_NAME,                SettingTranslateInfo,    ARRAY_SIZE(SettingTranslateInfo),     GetDefaultMsmqObjXlateInfo,    e_SitesContainer,            0,                &pwcsCategory[5], x_SettingsCategoryName,                  x_SettingsCategoryLength},
{MSMQ_SITE_CLASS_NAME,                   SiteTranslateInfo,       ARRAY_SIZE(SiteTranslateInfo),        GetDefaultMsmqObjXlateInfo,    e_SitesContainer,            MQDS_SITE,        &pwcsCategory[6], x_SiteCategoryName,                      x_SiteCategoryLength},
{MSMQ_SERVER_CLASS_NAME,                 ServerTranslateInfo,     ARRAY_SIZE(ServerTranslateInfo),      GetDefaultMsmqObjXlateInfo,    e_ConfigurationContainer,    0,                &pwcsCategory[7], x_ServerCategoryName,                    x_ServerCategoryLength},
{MSMQ_COMPUTER_CLASS_NAME,               ComputerTranslateInfo,   ARRAY_SIZE(ComputerTranslateInfo),    GetDefaultMsmqObjXlateInfo,    e_RootDSE,                   0,                &pwcsCategory[8], x_ComputerCategoryName,                  x_ComputerCategoryLength},
{MSMQ_MQUSER_CLASS_NAME,                 MQUserTranslateInfo,     ARRAY_SIZE(MQUserTranslateInfo),      GetDefaultMsmqObjXlateInfo,    e_RootDSE,                   MQDS_MQUSER,      &pwcsCategory[9], x_MQUserCategoryName,                    x_MQUserCategoryLength},
{MSMQ_SITE_CLASS_NAME,                   CnTranslateInfo,         ARRAY_SIZE(CnTranslateInfo),          GetDefaultMsmqObjXlateInfo,    e_SitesContainer,            MQDS_CN,          &pwcsCategory[6], x_SiteCategoryName,                      x_SiteCategoryLength}
};

//-----------------------------------------------------
// Number of MSMQ classes
//
//-----------------------------------------------------
extern const ULONG g_cMSMQClassInfo = ARRAY_SIZE(g_MSMQClassInfo);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdscore\utils.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:
	dsutils.h

Abstract:
	General declarations and utilities for MqAds project

Author:
    AlexDad

--*/


#ifndef __UTILS_H__
#define __UTILS_H__

//-----------------------------
//  Misc routines
//-----------------------------


// Translation from MQPropValue to OLE Variant
extern HRESULT MqVal2Variant(
      OUT VARIANT *pvProp, 
      IN  const MQPROPVARIANT *pPropVar,
      ADSTYPE adsType);

// Translation from MqPropValue to wide string
extern HRESULT MqPropVal2String(
      IN  MQPROPVARIANT *pPropVar,
      IN  ADSTYPE        adsType,
      OUT LPWSTR *       ppwszVal); 

// Translation from OLE variant to MQPropValue
extern HRESULT Variant2MqVal(
      OUT  MQPROPVARIANT *   pMqVar,
      IN   VARIANT *         pOleVar,
      IN   const ADSTYPE     adstype,
      IN   const VARTYPE     vartype
      );

// Translation from MQPropValue to ADSI Variant
extern HRESULT MqVal2AdsiVal(
      IN  ADSTYPE        adsType,
      OUT DWORD         *pdwNumValues,
      OUT PADSVALUE     *ppADsValue, 
      IN  const MQPROPVARIANT *pPropVar,
      IN  PVOID          pvMainAlloc);

// Translation from ADSI Value to MQPropValue
extern HRESULT AdsiVal2MqVal(
      OUT MQPROPVARIANT *pPropVar,
      IN  VARTYPE       vtTarget, 
      IN  ADSTYPE       AdsType,
      IN  DWORD         dwNumValues,
      IN  PADSVALUE     pADsValue);

extern void LogTraceQuery(LPWSTR wszStr, LPWSTR wszFileName, USHORT usPoint);

extern void LogTraceQuery2(LPWSTR wszStr1, LPWSTR wszStr2, LPWSTR wszFileName, USHORT usPoint);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdscore\utils.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    dsutils.cpp

Abstract:

    Implementation of utilities used in MQADS dll.

Author:

    Alexander Dadiomov (AlexDad)

--*/
#include "ds_stdh.h"
#include "iads.h"
#include "dsutils.h"
#include "adstempl.h"
#include "autorel.h"
#include "mqsec.h"
#include "_secutil.h"
#include <math.h>
#include "_propvar.h"
#include "utils.h"

#include "utils.tmh"

static WCHAR *s_FN=L"mqdscore/utils";

#define CHECK_ALLOCATION(p, point)              \
    if (p == NULL)                              \
    {                                           \
        ASSERT(0);                              \
        LogIllegalPoint(s_FN, point);           \
        return MQ_ERROR_INSUFFICIENT_RESOURCES; \
    }

//-------------------------------------------
// TimeFromSystemTime:
//
//  This routine convertes SYSTEMTIME structure into time_t
//-------------------------------------------
STATIC inline time_t TimeFromSystemTime(const SYSTEMTIME * pstTime)
{
	tm tmTime;
        //
        // year in struct tm starts from 1900
        //
	tmTime.tm_year  = pstTime->wYear - 1900;
        //
        // month in struct tm is zero based 0-11 (in SYSTEMTIME it is 1-12)
        //
	tmTime.tm_mon   = pstTime->wMonth - 1;
	tmTime.tm_mday  = pstTime->wDay;
	tmTime.tm_hour  = pstTime->wHour; 
	tmTime.tm_min   = pstTime->wMinute;
	tmTime.tm_sec   = pstTime->wSecond; 
        //
        // time is in UTC, no need to adjust daylight savings time
        //
	tmTime.tm_isdst = 0;
        return mktime(&tmTime);
}

//-------------------------------------------
// TimeFromOleDate:
//
//  This routine convertes DATE into time_t
//-------------------------------------------
STATIC BOOL TimeFromOleDate(DATE dtSrc, time_t *ptime)
{
	SYSTEMTIME stTime;
	if (!VariantTimeToSystemTime(dtSrc, &stTime))
	{
		return LogBOOL(FALSE, s_FN, 200);
	}
        *ptime = TimeFromSystemTime(&stTime);
	return TRUE;
}

//------------------------------------------------------------
// SetWStringIntoAdsiValue: puts wide string into ADSValue according to ADSType
//------------------------------------------------------------
STATIC HRESULT SetWStringIntoAdsiValue(
   ADSTYPE adsType,
   PADSVALUE pADsValue,
   LPWSTR wsz,
   PVOID pvMainAlloc)
{
    ULONG  ul;
    LPWSTR pwszTmp;

    if (adsType == ADSTYPE_DN_STRING ||
        adsType == ADSTYPE_CASE_EXACT_STRING ||
        adsType == ADSTYPE_CASE_IGNORE_STRING ||
        adsType == ADSTYPE_PRINTABLE_STRING ||
        adsType == ADSTYPE_NUMERIC_STRING)
    {
        ul      = (wcslen(wsz) + 1) * sizeof(WCHAR);
        pwszTmp = (LPWSTR)PvAllocMore(ul, pvMainAlloc);
        CHECK_ALLOCATION(pwszTmp, 10);
        CopyMemory(pwszTmp,  wsz,  ul);
    }
    else
    {
          pADsValue->dwType = ADSTYPE_INVALID;
          return LogHR(MQ_ERROR, s_FN, 210);
    }

    switch (adsType)
    {
      case  ADSTYPE_DN_STRING :
          pADsValue->DNString = pwszTmp;
          break;
      case ADSTYPE_CASE_EXACT_STRING:
          pADsValue->CaseExactString = pwszTmp;
          break;
      case ADSTYPE_CASE_IGNORE_STRING:
          pADsValue->CaseIgnoreString = pwszTmp;
          break;
      case ADSTYPE_PRINTABLE_STRING:
          pADsValue->PrintableString = pwszTmp;
          break;
      case ADSTYPE_NUMERIC_STRING:
          pADsValue->NumericString = pwszTmp;
          break;
      default:
          ASSERT(0);
          pADsValue->dwType = ADSTYPE_INVALID;
          return LogHR(MQ_ERROR, s_FN, 220);
    }

    pADsValue->dwType = adsType;
    return MQ_OK;
}

//------------------------------------------------------------
// SetStringIntoAdsiValue: puts string into ADSValue according to ADSType
//------------------------------------------------------------
STATIC HRESULT SetStringIntoAdsiValue(
    ADSTYPE adsType,
    PADSVALUE pADsValue,
    LPSTR sz,
    PVOID pvMainAlloc)
{
    ULONG  ul;
    LPWSTR pwszTmp;

    if (adsType == ADSTYPE_DN_STRING ||
        adsType == ADSTYPE_CASE_EXACT_STRING ||
        adsType == ADSTYPE_CASE_IGNORE_STRING ||
        adsType == ADSTYPE_PRINTABLE_STRING ||
        adsType == ADSTYPE_NUMERIC_STRING)
    {
        ul = (strlen(sz) + 1) * sizeof(WCHAR);
        pwszTmp = (LPWSTR)PvAllocMore(ul, pvMainAlloc);
        CHECK_ALLOCATION(pwszTmp, 20);
        mbstowcs(pwszTmp, sz, ul/sizeof(WCHAR) );
    }
    else
    {
          pADsValue->dwType = ADSTYPE_INVALID;
          return LogHR(MQ_ERROR, s_FN, 230);
    }

    switch (adsType)
    {
      case  ADSTYPE_DN_STRING :
          pADsValue->DNString = pwszTmp;
          break;
      case ADSTYPE_CASE_EXACT_STRING:
          pADsValue->CaseExactString = pwszTmp;
          break;
      case ADSTYPE_CASE_IGNORE_STRING:
          pADsValue->CaseIgnoreString = pwszTmp;
          break;
      case ADSTYPE_PRINTABLE_STRING:
          pADsValue->PrintableString = pwszTmp;
          break;
      case ADSTYPE_NUMERIC_STRING:
          pADsValue->NumericString = pwszTmp;
          break;
      default:
          ASSERT(0);
          pADsValue->dwType = ADSTYPE_INVALID;
          return LogHR(MQ_ERROR, s_FN, 240);
    }

    pADsValue->dwType = adsType;
    return MQ_OK;
}



//------------------------------------------------------------
//    MqVal2Variant()
//    Translates MQPropVal into OLE Variant value
//------------------------------------------------------------
HRESULT MqVal2Variant(
      OUT VARIANT       *pOleVar,
      IN  const MQPROPVARIANT *pMqVar,
      ADSTYPE           adstype)
{
    LPWSTR wsz;
    ULONG  ul;
    HRESULT hr;

    switch (pMqVar->vt)
    {
       case(VT_UI1):
           if (adstype == ADSTYPE_BOOLEAN)
           {
                pOleVar->vt = VT_BOOL;
#pragma warning(disable: 4310)
                pOleVar->boolVal = (pMqVar->bVal ? VARIANT_TRUE : VARIANT_FALSE);
#pragma warning(default: 4310)
           }
           else if (adstype ==  ADSTYPE_INTEGER)
           {
                pOleVar->vt = VT_I4;
                pOleVar->lVal = pMqVar->bVal;
           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR, s_FN, 250);
           }
           break;

       case(VT_I2):
           if (adstype ==  ADSTYPE_INTEGER)
           {
               pOleVar->vt = VT_I4;
               pOleVar->lVal = pMqVar->iVal;
           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR, s_FN, 260);
           }
           break;

       case(VT_UI2):
           if (adstype ==  ADSTYPE_INTEGER)
           {
               pOleVar->vt = VT_I4;
               pOleVar->lVal = pMqVar->uiVal;
           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR, s_FN, 270);
           }
           break;

       case(VT_BOOL):
           if (adstype ==  ADSTYPE_INTEGER)
           {
               pOleVar->vt = VT_BOOL;
               pOleVar->boolVal = pMqVar->boolVal;
           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR, s_FN, 280);
           }
           break;

       case(VT_I4):
           if (adstype ==  ADSTYPE_INTEGER)
           {
               pOleVar->vt = VT_I4;
               pOleVar->lVal = pMqVar->lVal;
           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR, s_FN, 290);
           }
           break;

       case(VT_UI4):
           if (adstype ==  ADSTYPE_INTEGER)
           {
               pOleVar->vt = VT_I4;
               CopyMemory(&pOleVar->lVal, &pMqVar->ulVal, sizeof(ULONG));
           }
           else if (adstype ==  ADSTYPE_UTC_TIME)
           {
               //pOleVar->vt = VT_DATE;
               //CopyMemory(&pOleVar->date, &pMqVar->ulVal, sizeof(ULONG));
               //
               // BUGBUG - The code above was wrong, We can't assign ULONG into OLE Date.
               // Currently we never get to here because all of our time props ar read-only,
               // but this needs to be changed when we add a writable time property
               // to the the DS. (RaananH)
               // 
               ASSERT(0);
               return LogHR(MQ_ERROR, s_FN, 300);
           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR, s_FN, 310);
           }
           break;

       case(VT_DATE):
           if (adstype ==  ADSTYPE_UTC_TIME)
           {
               pOleVar->vt = VT_DATE;
               pOleVar->date = pMqVar->date;
           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR, s_FN, 320);
           }
           break;

       case(VT_BSTR):
           if (adstype ==  ADSTYPE_DN_STRING          ||
               adstype == ADSTYPE_CASE_EXACT_STRING   ||
               adstype ==  ADSTYPE_CASE_IGNORE_STRING ||
               adstype == ADSTYPE_PRINTABLE_STRING    ||
               adstype ==  ADSTYPE_NUMERIC_STRING     ||
               adstype == ADSTYPE_CASE_EXACT_STRING)
           {
               pOleVar->vt = VT_BSTR;
               pOleVar->bstrVal = SysAllocString(pMqVar->bstrVal);
           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR, s_FN, 330);
           }
           break;

       case(VT_LPSTR):
           if (adstype ==  ADSTYPE_DN_STRING          ||
               adstype == ADSTYPE_CASE_EXACT_STRING   ||
               adstype ==  ADSTYPE_CASE_IGNORE_STRING ||
               adstype == ADSTYPE_PRINTABLE_STRING    ||
               adstype ==  ADSTYPE_NUMERIC_STRING     ||
               adstype == ADSTYPE_CASE_EXACT_STRING)
           {
               pOleVar->vt = VT_BSTR;
               ul = strlen(pMqVar->pszVal) + 1;
               wsz = new WCHAR[ul * sizeof(WCHAR)];
               mbstowcs( wsz, pMqVar->pszVal, ul );
               pOleVar->bstrVal = SysAllocString(wsz);
               delete [] wsz;
           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR, s_FN, 340);
           }
           break;

       case(VT_LPWSTR):
           if (adstype ==  ADSTYPE_DN_STRING          ||
               adstype == ADSTYPE_CASE_EXACT_STRING   ||
               adstype ==  ADSTYPE_CASE_IGNORE_STRING ||
               adstype == ADSTYPE_PRINTABLE_STRING    ||
               adstype ==  ADSTYPE_NUMERIC_STRING     ||
               adstype == ADSTYPE_CASE_EXACT_STRING)
           {
               pOleVar->vt = VT_BSTR;
               pOleVar->bstrVal = SysAllocString(pMqVar->pwszVal);
           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR, s_FN, 350);
           }
           break;

       case(VT_LPWSTR|VT_VECTOR):
           if (adstype ==  ADSTYPE_DN_STRING)
           {

                //
                // Create safe array
                //
                SAFEARRAYBOUND  saBounds;

                saBounds.lLbound   = 0;
                saBounds.cElements = pMqVar->calpwstr.cElems;
                pOleVar->parray = SafeArrayCreate(VT_VARIANT, 1, &saBounds);
			    CHECK_ALLOCATION(pOleVar->parray, 30);
                pOleVar->vt = VT_VARIANT | VT_ARRAY;

                //
                // Fill safe array with strings
                //
                LONG            lTmp, lNum;
                lNum = pMqVar->calpwstr.cElems;
                for (lTmp = 0; lTmp < lNum; lTmp++)
                {
                   CAutoVariant   varClean;
                   VARIANT * pvarTmp = &varClean;
                   pvarTmp->bstrVal = BS_SysAllocString(pMqVar->calpwstr.pElems[lTmp]);
                   pvarTmp->vt = VT_BSTR;

                   //
                   // Add to safe array
                   //
                   hr = SafeArrayPutElement(pOleVar->parray, &lTmp, pvarTmp);
                   if (FAILED(hr))
                   {
                        return LogHR(hr, s_FN, 2000);
                   }

                }
           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR, s_FN, 360);
           }
           break;

       case(VT_CLSID):
           if (adstype ==  ADSTYPE_OCTET_STRING)
           {
			   pOleVar->vt = VT_ARRAY | VT_UI1;
			   pOleVar->parray = SafeArrayCreateVector(VT_UI1, 0, 16);
			   CHECK_ALLOCATION(pOleVar->parray, 40);
				
			   for (long i=0; i<16; i++)
			   {
				   hr = SafeArrayPutElement(
					        pOleVar->parray,
						    &i,
						    ((unsigned char *)pMqVar->puuid)+i);
                   if (FAILED(hr))
                   {
                       return LogHR(hr, s_FN, 2010);
                   }
			   }

           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR, s_FN, 370);
           }
           break;

       case(VT_BLOB):
           if (adstype ==  ADSTYPE_OCTET_STRING)
           {
               ASSERT( pMqVar->blob.cbSize > 0);
			   pOleVar->vt = VT_ARRAY | VT_UI1;
               DWORD len = pMqVar->blob.cbSize;

			   pOleVar->parray = SafeArrayCreateVector(VT_UI1, 0, len);
			   CHECK_ALLOCATION(pOleVar->parray, 50);
               ASSERT( ((long)len) > 0);
				
			   for (long i=0; i<(long)len; i++)
			   {
				   hr = SafeArrayPutElement(
					        pOleVar->parray,
						    &i,
						    pMqVar->blob.pBlobData+i);
                   if (FAILED(hr))
                   {
                        return LogHR(hr, s_FN, 2020);
                   }
               }

           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR, s_FN, 380);
           }
           break;

       case(VT_VECTOR|VT_CLSID):
           if (adstype ==  ADSTYPE_OCTET_STRING)
           {
                //
                //  Can't set array size to be zero ( ADSI limitation)
                //
                if ( pMqVar->cauuid.cElems == 0)
                {
                    return LogHR(MQ_ERROR, s_FN, 390);
                }

                //
                // Create safe array
                //
                SAFEARRAYBOUND  saBounds;

                saBounds.lLbound   = 0;
                saBounds.cElements = pMqVar->cauuid.cElems;
                pOleVar->parray = SafeArrayCreate(VT_VARIANT, 1, &saBounds);
			    CHECK_ALLOCATION(pOleVar->parray, 60);
                pOleVar->vt = VT_VARIANT | VT_ARRAY;

                //
                // Fill safe array with GUIDs ( each GUID is a safe array)
                //
                LONG            lTmp, lNum;
                lNum = pMqVar->cauuid.cElems;
                for (lTmp = 0; lTmp < lNum; lTmp++)
                {
                   CAutoVariant   varClean;
                   VARIANT * pvarTmp = &varClean;

			       pvarTmp->parray = SafeArrayCreateVector(VT_UI1, 0, 16);
			       CHECK_ALLOCATION(pvarTmp->parray, 70);
			       pvarTmp->vt = VT_ARRAY | VT_UI1;

			       for (long i=0; i<16; i++)
			       {
				       hr = SafeArrayPutElement(
					            pvarTmp->parray,
						        &i,
						        ((unsigned char *)(pMqVar->cauuid.pElems + lTmp))+i);
                       if (FAILED(hr))
                       {
                            return LogHR(hr, s_FN, 2030);
                       }
			       }
                   //
                   // Add safearray variant to safe array
                   //
                   hr = SafeArrayPutElement(pOleVar->parray, &lTmp, pvarTmp);
                   if (FAILED(hr))
                   {
                        return LogHR(hr, s_FN, 2040);
                   }

                }
           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR, s_FN, 400);
           }
           break;

       default:
           // NIY
           ASSERT(0);
           return LogHR(MQ_ERROR, s_FN, 410);
    }
    return MQ_OK;
}


HRESULT ArrayOfLpwstr2MqVal(
      IN  VARIANT  *        pOleVar,
      IN  const ADSTYPE     adstype,
      IN  const VARTYPE     vartype,
      IN  const VARTYPE     vartypeElement,
      OUT MQPROPVARIANT *   pMqVar
      )
{
       //
       // get number of elements
       //
       LONG lLbound, lUbound;
       if (FAILED(SafeArrayGetLBound(pOleVar->parray, 1, &lLbound)) ||
           FAILED(SafeArrayGetUBound(pOleVar->parray, 1, &lUbound)))
       {
           ASSERT(0);
           return LogHR(MQ_ERROR, s_FN, 420);
       }
       ULONG cElems;
       cElems = lUbound - lLbound + 1;

       //
       // Allocate array of results
       //
       AP<LPWSTR> pElems = new LPWSTR[cElems];

       //
       // Translate each element
       //
       LONG lIdx;
       ULONG ulTmp;
       for (ulTmp = 0, lIdx = lLbound; ulTmp < cElems; ulTmp++, lIdx++)
       {
           //
           // get variant to translate
           //
           CAutoVariant varTmp;
           HRESULT hr = SafeArrayGetElement(pOleVar->parray, &lIdx, &varTmp);
           if (FAILED(hr))
           {
               ASSERT(0);
               return LogHR(hr, s_FN, 430);
           }

           //
           // translate the variant (RECURSION)
           //
           PROPVARIANT var;
           hr = Variant2MqVal(&var, &varTmp, adstype, vartypeElement);
           if (FAILED(hr))
           {
               ASSERT(0);
               return LogHR(hr, s_FN, 440);
           }

           //
           // Fill element in array of results
           //
           pElems[ulTmp] = var.pwszVal;
       }

       //
       // set return variant
       //
       pMqVar->vt = VT_VECTOR|VT_LPWSTR;
       pMqVar->calpwstr.cElems = cElems;
       pMqVar->calpwstr.pElems = pElems.detach();
       return(MQ_OK);
}

HRESULT ArrayOfClsid2MqVal(
      IN  VARIANT  *        pOleVar,
      IN  const ADSTYPE     adstype,
      IN  const VARTYPE     vartype,
      IN  const VARTYPE     vartypeElement,
      OUT MQPROPVARIANT *   pMqVar
      )
{
       //
       // get number of elements
       //
       LONG lLbound, lUbound;
       if (FAILED(SafeArrayGetLBound(pOleVar->parray, 1, &lLbound)) ||
           FAILED(SafeArrayGetUBound(pOleVar->parray, 1, &lUbound)))
       {
           ASSERT(0);
           return LogHR(MQ_ERROR, s_FN, 450);
       }
       ULONG cElems;
       cElems = lUbound - lLbound + 1;

       //
       // Allocate array of results
       //
       AP<GUID> pElems = new GUID[cElems];

       //
       // Translate each element
       //
       LONG lIdx;
       ULONG ulTmp;
       for (ulTmp = 0, lIdx = lLbound; ulTmp < cElems; ulTmp++, lIdx++)
       {
           //
           // get variant to translate
           //
           CAutoVariant varTmp;
           HRESULT hr = SafeArrayGetElement(pOleVar->parray, &lIdx, &varTmp);
           if (FAILED(hr))
           {
               ASSERT(0);
               LogHR(hr, s_FN, 460);
               return MQ_ERROR;
           }

           //
           // translate the variant (RECURSION)
           //
           CMQVariant MQVarTmp;
           hr = Variant2MqVal(MQVarTmp.CastToStruct(), &varTmp, adstype, vartypeElement);
           if (FAILED(hr))
           {
               ASSERT(0);
               LogHR(hr, s_FN, 470);
               return MQ_ERROR;
           }

           //
           // Fill element in array of results
           //
           pElems[ulTmp] = *(MQVarTmp.GetCLSID());
       }

       //
       // set return variant
       //
       pMqVar->vt = VT_VECTOR|VT_CLSID;
       pMqVar->cauuid.cElems = cElems;
       pMqVar->cauuid.pElems = pElems.detach();
       return(MQ_OK);
}


//------------------------------------------------------------
//    Variant2MqVal()
//    Translates OLE Variant into MQPropVal value
//------------------------------------------------------------
HRESULT Variant2MqVal(
      OUT  MQPROPVARIANT * pMqVar,
      IN   VARIANT  *      pOleVar,
      IN const ADSTYPE     adstype,
      IN const VARTYPE     vartype)
{

    switch (pOleVar->vt)
    {
       case(VT_UI1):
           if (adstype == ADSTYPE_BOOLEAN)
           {
                pMqVar->vt = VT_UI1;
                pMqVar->bVal = (pOleVar->boolVal ? (unsigned char)1 : (unsigned char)0);
           }
           else if (adstype ==  ADSTYPE_INTEGER)
           {
                pMqVar->vt = VT_I4;
                pMqVar->lVal = pOleVar->bVal;
           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR, s_FN, 480);
           }
           break;

       case(VT_I2):
           if (adstype ==  ADSTYPE_INTEGER)
           {
               pMqVar->vt = VT_I4;
               pMqVar->lVal = pOleVar->iVal;
           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR, s_FN, 490);
           }
           break;

       case(VT_I4):
           if (adstype ==  ADSTYPE_INTEGER)
           {
               if ( vartype == VT_I2)
               {
                   pMqVar->vt = VT_I2;
                   pMqVar->iVal = pOleVar->iVal;
               }
               else if ( vartype == VT_UI2)
               {
                   pMqVar->vt = VT_UI2;
                   pMqVar->iVal = pOleVar->uiVal;
               }
               else
               {
                   ASSERT(( vartype == VT_I4) || (vartype == VT_UI4));
                   pMqVar->vt = vartype;
                   pMqVar->lVal = pOleVar->lVal;
               }
           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR, s_FN, 500);
           }
           break;

       case(VT_UI2):
           if (adstype ==  ADSTYPE_INTEGER)
           {
               pMqVar->vt = VT_I4;
               pMqVar->lVal = pOleVar->uiVal;
           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR, s_FN, 510);
           }
           break;

       case(VT_BOOL):
           if (adstype == ADSTYPE_BOOLEAN)
           {
                pMqVar->vt = VT_UI1;
                pMqVar->bVal = (pOleVar->boolVal ? (unsigned char)1 : (unsigned char)0);
           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR, s_FN, 520);
           }
           break;

       case(VT_UI4):
           if (adstype ==  ADSTYPE_INTEGER)
           {
               pMqVar->vt = VT_I4;
               CopyMemory(&pMqVar->lVal, &pOleVar->ulVal, sizeof(ULONG));
           }
           else if (adstype ==  ADSTYPE_UTC_TIME)
           {
               //pMqVar->vt = VT_DATE;
               //CopyMemory(&pMqVar->date, &pOleVar->ulVal, sizeof(ULONG));
               //
               // BUGBUG - The code above is wrong, We can't assign ULONG into OLE Date.
               // Currently we never get to here because all of our time props ar read-only,
               // but this needs to be changed when we add a writable time property
               // to the the DS. (RaananH)
               // 
               ASSERT(0);
               return LogHR(MQ_ERROR, s_FN, 530);
           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR, s_FN, 540);
           }
           break;

       case(VT_DATE):
           if (adstype ==  ADSTYPE_UTC_TIME)
           {
               //
               //   convert date->time_t
               //
               time_t tTime;
               if (!TimeFromOleDate(pOleVar->date, &tTime))
               {
                   return LogHR(MQ_ERROR, s_FN, 550);
               }
               pMqVar->lVal = INT_PTR_TO_INT(tTime); //BUGBUG bug year 2038
               pMqVar->vt = VT_I4;
           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR, s_FN, 560);
           }
           break;

       case(VT_BSTR):
           if (adstype ==  ADSTYPE_DN_STRING          ||
               adstype == ADSTYPE_CASE_EXACT_STRING   ||
               adstype ==  ADSTYPE_CASE_IGNORE_STRING ||
               adstype == ADSTYPE_PRINTABLE_STRING    ||
               adstype ==  ADSTYPE_NUMERIC_STRING     ||
               adstype == ADSTYPE_CASE_EXACT_STRING)
           {
               pMqVar->vt = VT_LPWSTR;
               pMqVar->pwszVal = new WCHAR[ 1 + wcslen(pOleVar->bstrVal)];
               wcscpy( pMqVar->pwszVal, pOleVar->bstrVal);
           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR, s_FN, 570);
           }
           break;

       case(VT_ARRAY):
           if (adstype ==  ADSTYPE_OCTET_STRING)
           {
               ASSERT(0);
               //pMqVar->vt = VT_BSTR;
               //pMqVar->bstrVal = SysAllocStringByteLen(NULL, pOleVar->parray->...);
               //CopyMemory(pMqVar->bstrVal, pOleVar->parray...ptr.., pOleVar->parray...size);
           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR, s_FN, 580);
           }
           break;

       case(VT_ARRAY|VT_UI1):
           if (adstype == ADSTYPE_OCTET_STRING)
           {
                ASSERT(SafeArrayGetDim( pOleVar->parray) == 1);
                LONG    lUbound;
                LONG    lLbound;

                SafeArrayGetUBound(pOleVar->parray, 1, &lUbound);
                SafeArrayGetLBound(pOleVar->parray, 1, &lLbound);

                LONG len = lUbound - lLbound + 1;
                unsigned char * puc = NULL;
                if ( vartype == VT_CLSID)
                {
                    ASSERT( len == sizeof(GUID));
                    //
                    //  This is a special case where we do not necessarily allocate the memory for the guid
                    //  in puuid. The caller may already have puuid set to a guid, and this is indicated by the
                    //  vt member on the given propvar. It could be VT_CLSID if guid already allocated, otherwise
                    //  we allocate it (and vt should be VT_NULL (or VT_EMPTY))
                    //
                    if (pMqVar->vt != VT_CLSID)
                    {
                        ASSERT(((pMqVar->vt == VT_NULL) || (pMqVar->vt == VT_EMPTY)));
                        pMqVar->puuid = new GUID;
                        pMqVar->vt = VT_CLSID;
                    }
                    else if ( pMqVar->puuid == NULL)
                    {
                        return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 590);
                    }
                    puc = ( unsigned char *)pMqVar->puuid;
                }
                else if (vartype == VT_BLOB)
                {
                    pMqVar->caub.cElems = len;
                    pMqVar->caub.pElems = new unsigned char[ len];
                    puc = pMqVar->caub.pElems;
                    pMqVar->vt = VT_BLOB;
                }
                ASSERT( puc != NULL);
                for ( long i = 0; i < len; i++)
                {
                    SafeArrayGetElement(pOleVar->parray, &i, puc + i);

                }

           }
           else
           {
               ASSERT(0);
               return LogHR(MQ_ERROR, s_FN, 600);
           }
           break;
       case(VT_ARRAY|VT_VARIANT):
           {
               //
               // this is a multi-valued property, each variant is one of the values.
               // target must be a vector.
               //
               if (!(vartype & VT_VECTOR))
               {
                   ASSERT(0);
                   return LogHR(MQ_ERROR, s_FN, 610);
               }

               //
               // get target type of each element
               //
               VARTYPE vartypeElement;
               vartypeElement = vartype;
               vartypeElement &= (~VT_VECTOR);

               if (( vartypeElement == VT_CLSID) &&
                   (adstype == ADSTYPE_OCTET_STRING))
               {
                    HRESULT hr2 = ArrayOfClsid2MqVal(
                                            pOleVar,
                                            adstype,
                                            vartype,
                                            vartypeElement,
                                            pMqVar);
                   return LogHR(hr2, s_FN, 620);
              }

              if (( vartypeElement == VT_LPWSTR) &&
                   (adstype == ADSTYPE_DN_STRING))
              {
                    HRESULT hr2 = ArrayOfLpwstr2MqVal(
                                            pOleVar,
                                            adstype,
                                            vartype,
                                            vartypeElement,
                                            pMqVar);
                   return LogHR(hr2, s_FN, 630);
              }

              //
              // currently we support only VT_CLSID  and VT_LPWSTR
              // here we may need to check for other types when we support them
              //
              ASSERT(0);
              return LogHR(MQ_ERROR, s_FN, 640);
              break;
           }

       default:
           // NIY
           ASSERT(0);
           return LogHR(MQ_ERROR, s_FN, 650);
    }
    return MQ_OK;
}


//------------------------------------------------------------
//    MqVal2AdsiVal()
//    Translates MQPropVal into ADSI value
//------------------------------------------------------------
HRESULT MqVal2AdsiVal(
      IN  ADSTYPE        adsType,
      OUT DWORD         *pdwNumValues,
      OUT PADSVALUE     *ppADsValue,
      IN  const MQPROPVARIANT *pPropVar,
      IN  PVOID          pvMainAlloc)
{
    HRESULT hr;
    ULONG   i;
    PADSVALUE pADsValue = NULL;

    // Allocate ADS value  for a single case
    if (!(pPropVar->vt & VT_VECTOR))
    {
          pADsValue = (PADSVALUE)PvAllocMore(sizeof(ADSVALUE), pvMainAlloc);
          CHECK_ALLOCATION(pADsValue, 80);
          pADsValue->dwType = adsType;
          *pdwNumValues     = 1;
          *ppADsValue       = pADsValue;
    }

    switch (pPropVar->vt)
    {
      case(VT_UI1):
          if (adsType != ADSTYPE_INTEGER &&
              adsType != ADSTYPE_BOOLEAN )
          {
              ASSERT(0);
              pADsValue->dwType = ADSTYPE_INVALID;
              return LogHR(MQ_ERROR, s_FN, 660);
          }
          pADsValue->Integer = pPropVar->bVal;
          break;

      case(VT_I2):
          if (adsType != ADSTYPE_INTEGER)
          {
              ASSERT(0);
              pADsValue->dwType = ADSTYPE_INVALID;
              return LogHR(MQ_ERROR, s_FN, 670);
          }
          pADsValue->Integer = pPropVar->iVal;
          break;

      case(VT_UI2):
          if (adsType != ADSTYPE_INTEGER)
          {
              ASSERT(0);
              pADsValue->dwType = ADSTYPE_INVALID;
              return LogHR(MQ_ERROR, s_FN, 680);
          }
          pADsValue->Integer = pPropVar->uiVal;
          break;

      case(VT_BOOL):
          if (adsType != ADSTYPE_INTEGER)
          {
              ASSERT(0);
              pADsValue->dwType = ADSTYPE_INVALID;
              return LogHR(MQ_ERROR, s_FN, 700);
          }
          pADsValue->Boolean = (pPropVar->boolVal ? TRUE : FALSE);
          //BUGBUG: is it the same representation?
          break;

      case(VT_I4):
          if (adsType != ADSTYPE_INTEGER)
          {
              ASSERT(0);
              pADsValue->dwType = ADSTYPE_INVALID;
              return LogHR(MQ_ERROR, s_FN, 710);
          }
          // BUGBUG Signed long may loose sign while copied to DWORD
          pADsValue->Integer = pPropVar->lVal; // may loose sign here!
          break;

      case(VT_UI4):
          if (adsType != ADSTYPE_INTEGER)
          {
              ASSERT(0);
              pADsValue->dwType = ADSTYPE_INVALID;
              return LogHR(MQ_ERROR, s_FN, 720);
          }
          pADsValue->Integer = pPropVar->ulVal;
          break;

      case(VT_HRESULT):
          if (adsType != ADSTYPE_INTEGER)
          {
              ASSERT(0);
              pADsValue->dwType = ADSTYPE_INVALID;
              return LogHR(MQ_ERROR, s_FN, 730);
          }
          pADsValue->Integer = pPropVar->scode;
          break;

      case(VT_DATE):
          if (adsType != ADSTYPE_UTC_TIME)
          {
              ASSERT(0);
              pADsValue->dwType = ADSTYPE_INVALID;
              return LogHR(MQ_ERROR, s_FN, 740);
          }
          if (!VariantTimeToSystemTime(pPropVar->date, &pADsValue->UTCTime))
          {
               ASSERT(0);
               pADsValue->dwType = ADSTYPE_INVALID;
               return LogHR(MQ_ERROR, s_FN, 750);
          }
          break;

      case(VT_CLSID):
          if (adsType != ADSTYPE_OCTET_STRING)
          {
              ASSERT(0);
              pADsValue->dwType = ADSTYPE_INVALID;
              return LogHR(MQ_ERROR, s_FN, 760);
          }
          pADsValue->OctetString.dwLength = sizeof(GUID);
          pADsValue->OctetString.lpValue  = (LPBYTE)PvAllocMore(sizeof(GUID), pvMainAlloc);
          CHECK_ALLOCATION(pADsValue->OctetString.lpValue, 90);
          CopyMemory(pADsValue->OctetString.lpValue,  pPropVar->puuid,  sizeof(CLSID));
          break;

      case(VT_BLOB):
          if (adsType == ADSTYPE_NT_SECURITY_DESCRIPTOR)
          {
              pADsValue->SecurityDescriptor.dwLength = pPropVar->blob.cbSize;
              pADsValue->SecurityDescriptor.lpValue  = (LPBYTE)PvAllocMore(pPropVar->blob.cbSize, pvMainAlloc);
              CHECK_ALLOCATION(pADsValue->SecurityDescriptor.lpValue, 100);
              CopyMemory(pADsValue->SecurityDescriptor.lpValue,  pPropVar->blob.pBlobData,  pPropVar->blob.cbSize);
          }
          else if (adsType == ADSTYPE_OCTET_STRING)
          {
              pADsValue->OctetString.dwLength = pPropVar->blob.cbSize;
              pADsValue->OctetString.lpValue  = (LPBYTE)PvAllocMore(pPropVar->blob.cbSize, pvMainAlloc);
              CHECK_ALLOCATION(pADsValue->OctetString.lpValue, 110);
              CopyMemory(pADsValue->OctetString.lpValue,  pPropVar->blob.pBlobData,  pPropVar->blob.cbSize);
          }
          else
          {
              ASSERT(0);
              pADsValue->dwType = ADSTYPE_INVALID;
              return LogHR(MQ_ERROR, s_FN, 770);
          }
          break;

      case(VT_BSTR):
          hr = SetWStringIntoAdsiValue(adsType, pADsValue, pPropVar->bstrVal, pvMainAlloc);
          if (FAILED(hr))
          {
              ASSERT(0);
              return LogHR(hr, s_FN, 780);
          }
          break;

      case(VT_LPSTR):
          hr = SetStringIntoAdsiValue(adsType, pADsValue, pPropVar->pszVal, pvMainAlloc);
          if (FAILED(hr))
          {
              ASSERT(0);
              return LogHR(hr, s_FN, 790);
          }
          break;

      case(VT_LPWSTR):
          hr = SetWStringIntoAdsiValue(adsType, pADsValue, pPropVar->pwszVal, pvMainAlloc);
          if (FAILED(hr))
          {
              ASSERT(0);
              return LogHR(hr, s_FN, 800);
          }
          break;

      case(VT_VECTOR | VT_UI1):
          switch(adsType)
          {
                  case ADSTYPE_OCTET_STRING:
                      pADsValue = (PADSVALUE)PvAllocMore(sizeof(ADSVALUE), pvMainAlloc);
                      CHECK_ALLOCATION(pADsValue, 120);
                      pADsValue->dwType = adsType;

                      pADsValue->OctetString.dwLength = pPropVar->caub.cElems;
                      pADsValue->OctetString.lpValue  = (LPBYTE)PvAllocMore(pPropVar->caub.cElems, pvMainAlloc);
                      CHECK_ALLOCATION(pADsValue->OctetString.lpValue, 130);
                      CopyMemory(pADsValue->OctetString.lpValue,  pPropVar->caub.pElems,  pPropVar->caub.cElems);

                      *ppADsValue   = pADsValue;
                      *pdwNumValues = 1;
                      break;

                  case ADSTYPE_INTEGER:
                      pADsValue = (PADSVALUE)PvAllocMore(sizeof(ADSVALUE) * pPropVar->caub.cElems, pvMainAlloc);
                      CHECK_ALLOCATION(pADsValue, 140);

                      for (i=0; i<pPropVar->caub.cElems; i++)
                      {
                          pADsValue[i].Integer = pPropVar->caub.pElems[i];
                          pADsValue[i].dwType = adsType;
                      }

                      *ppADsValue   = pADsValue;
                      *pdwNumValues = pPropVar->caub.cElems;
                      break;

                  default:
                      ASSERT(0);
                      return LogHR(MQ_ERROR, s_FN, 810);
          }

          break;

      case(VT_VECTOR | VT_I2):
          if (adsType != ADSTYPE_INTEGER)
          {
              ASSERT(0);
              return LogHR(MQ_ERROR, s_FN, 820);
          }

          pADsValue = (PADSVALUE)PvAllocMore(sizeof(ADSVALUE) * pPropVar->cai.cElems, pvMainAlloc);
          CHECK_ALLOCATION(pADsValue, 150)
          pADsValue->dwType = adsType;

          for (i=0; i<pPropVar->cai.cElems; i++)
          {
              pADsValue[i].Integer = pPropVar->cai.pElems[i];
              pADsValue[i].dwType = adsType;
          }

          *ppADsValue   = pADsValue;
          *pdwNumValues = pPropVar->cai.cElems;
          break;

      case(VT_VECTOR | VT_UI2):
          if (adsType != ADSTYPE_INTEGER)
          {
              ASSERT(0);
              return LogHR(MQ_ERROR, s_FN, 830);
          }

          pADsValue = (PADSVALUE)PvAllocMore(sizeof(ADSVALUE) * pPropVar->caui.cElems, pvMainAlloc);
          CHECK_ALLOCATION(pADsValue, 160)

          for (i=0; i<pPropVar->caui.cElems; i++)
          {
              pADsValue[i].Integer = pPropVar->caui.pElems[i];
              pADsValue[i].dwType = adsType;
          }

          *ppADsValue   = pADsValue;
          *pdwNumValues = pPropVar->caui.cElems;
          break;

      case(VT_VECTOR | VT_I4):
          if (adsType != ADSTYPE_INTEGER)
          {
              ASSERT(0);
              return LogHR(MQ_ERROR, s_FN, 840);
          }

          pADsValue = (PADSVALUE)PvAllocMore(sizeof(ADSVALUE) * pPropVar->cal.cElems, pvMainAlloc);
          CHECK_ALLOCATION(pADsValue, 170);

          for (i=0; i<pPropVar->cal.cElems; i++)
          {
              // BUGBUG:  may loose sign
              pADsValue[i].Integer = pPropVar->cal.pElems[i];
              pADsValue[i].dwType = adsType;
          }

          *ppADsValue   = pADsValue;
          *pdwNumValues = pPropVar->cal.cElems;
          break;

      case(VT_VECTOR | VT_UI4):
          if (adsType != ADSTYPE_INTEGER)
          {
              ASSERT(0);
              return LogHR(MQ_ERROR, s_FN, 850);
          }

          pADsValue = (PADSVALUE)PvAllocMore(sizeof(ADSVALUE) * pPropVar->caul.cElems, pvMainAlloc);
          CHECK_ALLOCATION(pADsValue, 180);

          for (i=0; i<pPropVar->caul.cElems; i++)
          {
              pADsValue[i].Integer = pPropVar->caul.pElems[i];
              pADsValue[i].dwType = adsType;
          }

          *ppADsValue   = pADsValue;
          *pdwNumValues = pPropVar->caul.cElems;
          break;

      case(VT_VECTOR | VT_CLSID):
          if (adsType != ADSTYPE_OCTET_STRING)
          {
              ASSERT(0);
              return LogHR(MQ_ERROR, s_FN, 860);
          }

          pADsValue = (PADSVALUE)PvAllocMore(sizeof(ADSVALUE) * pPropVar->cauuid.cElems, pvMainAlloc);
          CHECK_ALLOCATION(pADsValue, 190);
          pADsValue->dwType = adsType;

          for (i=0; i<pPropVar->cauuid.cElems; i++)
          {
              pADsValue[i].OctetString.dwLength = sizeof(GUID);
              pADsValue[i].dwType = adsType;
              pADsValue[i].OctetString.lpValue  = (LPBYTE)PvAllocMore(sizeof(GUID), pvMainAlloc);
              CHECK_ALLOCATION(pADsValue[i].OctetString.lpValue, 200);
              CopyMemory(pADsValue[i].OctetString.lpValue,  &pPropVar->cauuid.pElems[i],  sizeof(GUID));
          }

          *ppADsValue   = pADsValue;
          *pdwNumValues = pPropVar->cauuid.cElems;
          break;

      case(VT_VECTOR | VT_BSTR):
          if (adsType != ADSTYPE_OCTET_STRING)
          {
              ASSERT(0);
              return LogHR(MQ_ERROR, s_FN, 870);
          }

          pADsValue = (PADSVALUE)PvAllocMore(sizeof(ADSVALUE) * pPropVar->cabstr.cElems, pvMainAlloc);
          CHECK_ALLOCATION(pADsValue, 210);


          for (i=0; i<pPropVar->cabstr.cElems; i++)
          {
              hr = SetWStringIntoAdsiValue(adsType, pADsValue+i, pPropVar->cabstr.pElems[i], pvMainAlloc);
              if (FAILED(hr))
              {
                  ASSERT(0);
                  return LogHR(MQ_ERROR, s_FN, 880);
              }
          }

          *ppADsValue   = pADsValue;
          *pdwNumValues = pPropVar->cabstr.cElems;
          break;

      case(VT_VECTOR | VT_LPWSTR):
          if (adsType != ADSTYPE_DN_STRING)
          {
              ASSERT(0);
              return LogHR(MQ_ERROR, s_FN, 890);
          }

          pADsValue = (PADSVALUE)PvAllocMore(sizeof(ADSVALUE) * pPropVar->calpwstr.cElems, pvMainAlloc);
          CHECK_ALLOCATION(pADsValue, 220);

          for (i=0; i<pPropVar->calpwstr.cElems; i++)
          {
              hr = SetWStringIntoAdsiValue(adsType, pADsValue+i, pPropVar->calpwstr.pElems[i], pvMainAlloc);
              if (FAILED(hr))
              {
                  ASSERT(0);
                  return LogHR(hr, s_FN, 900);
              }
          }

          *ppADsValue   = pADsValue;
          *pdwNumValues = pPropVar->calpwstr.cElems;
          break;

      case(VT_VARIANT):
          ASSERT(0);
          pADsValue->dwType = ADSTYPE_INVALID;
          // NIY
          break;

    case(VT_EMPTY):
    case VT_NULL:

      default:
        ASSERT(0);
        pADsValue->dwType = ADSTYPE_INVALID;
        return LogHR(MQ_ERROR, s_FN, 910);
    }

    return MQ_OK;
}
const WCHAR x_True[] = L"TRUE";
const DWORD x_TrueLength = (sizeof( x_True) /sizeof(WCHAR)) -1;
const WCHAR x_False[] = L"FALSE";
const DWORD x_FalseLength = (sizeof( x_False) /sizeof(WCHAR)) -1;
const DWORD x_NumberLength = 256;
const WCHAR x_Null[] = L"\\00";
const DWORD x_NullLength = (sizeof( x_Null)/sizeof(WCHAR)) -1;

STATIC void StringToSearchFilter(
      IN  MQPROPVARIANT *pPropVar,
      OUT LPWSTR *       ppwszVal
)
/*++

Routine Description:
    Translate a string variant restirction to a LDAP search filter
    according to RFC 2254

Arguments:
    pPropVar    : varaint containing the string
    ppwszVal    : output, the search filter

Return Value:
    none

--*/
{
    //
    //  NUL string should be replace with \00
    //
    if ( wcslen( pPropVar->pwszVal) == 0)
    {
      *ppwszVal = new WCHAR[ x_NullLength + 1];
      wcscpy(*ppwszVal, x_Null);
      return;
    }
    DWORD len = wcslen( pPropVar->pwszVal);
    *ppwszVal = new WCHAR[ 3 * len + 1];
    WCHAR * pNextChar = *ppwszVal;
    //
    //  Chars *,(,),\ should be escaped in a special way
    //
    for ( DWORD i = 0; i < len; i++)
    {
        switch( pPropVar->pwszVal[i])
        {
        case L'*':
            *pNextChar++ = L'\\';
            *pNextChar++ = L'2';
            *pNextChar++ = L'a';
            break;
        case L'(':
            *pNextChar++ = L'\\';
            *pNextChar++ = L'2';
            *pNextChar++ = L'8';
            break;
        case L')':
            *pNextChar++ = L'\\';
            *pNextChar++ = L'2';
            *pNextChar++ = L'9';
            break;
        case '\\':
            *pNextChar++ = L'\\';
            *pNextChar++ = L'5';
            *pNextChar++ = L'c';
            break;
        default:
            *pNextChar++ = pPropVar->pwszVal[i];
            break;
        }
    }

    *pNextChar = L'\0';
    return;
}
//------------------------------------------------------------
//    MqVal2String()
//    Translates MQPropVal into string
//------------------------------------------------------------
HRESULT MqPropVal2String(
      IN  MQPROPVARIANT *pPropVar,
      IN  ADSTYPE        adsType,
      OUT LPWSTR *       ppwszVal)
{
    HRESULT hr;

    switch (pPropVar->vt)
    {
      case(VT_UI1):
          {
              if ( adsType == ADSTYPE_BOOLEAN)
              {
                  if ( pPropVar->bVal)
                  {
                      *ppwszVal = new WCHAR[ x_TrueLength + 1];
                      wcscpy(*ppwszVal,x_True);
                  }
                  else
                  {
                      *ppwszVal = new WCHAR[ x_FalseLength + 1];
                      wcscpy(*ppwszVal,x_False);
                  }
              }
              else
              {
                  *ppwszVal = new WCHAR[ x_NumberLength + 1];
                wsprintf(*ppwszVal, L"%d", pPropVar->bVal);
              }
          }
          break;

      case(VT_I2):
          *ppwszVal = new WCHAR[ x_NumberLength + 1];
          wsprintf(*ppwszVal, L"%d", pPropVar->iVal);
          break;

      case(VT_UI2):
          *ppwszVal = new WCHAR[ x_NumberLength + 1];
          wsprintf(*ppwszVal, L"%d", pPropVar->uiVal);
          break;

      case(VT_BOOL):
          *ppwszVal = new WCHAR[ x_NumberLength + 1];
          wsprintf(*ppwszVal, L"%d", pPropVar->boolVal);
          break;

      case(VT_I4):
		  if ( adsType == ADSTYPE_INTEGER)
		  {
			  *ppwszVal = new WCHAR[ x_NumberLength + 1];
			  wsprintf(*ppwszVal, L"%d", pPropVar->lVal);
		  }
		  else if ( adsType == ADSTYPE_UTC_TIME)
		  {
			  struct tm  * ptmTime;
			  time_t tTime = pPropVar->lVal; //BUGBUG bug year 2038
			  ptmTime = gmtime( &tTime);
			  if ( ptmTime == NULL)
			  {
                  return LogHR(MQ_ERROR, s_FN, 920);
			  }
			  *ppwszVal = new WCHAR[ 20];
			  //
			  // the format should be
			  //  990513102200Z i.e 13.5.99 10:22:00
			  //
			  wsprintf(
					*ppwszVal,
					L"%02d%02d%02d%02d%02d%02dZ",
					(ptmTime->tm_year + 1900) % 100,   //year in struct tm starts from 1900
					ptmTime->tm_mon + 1,			   //month in struct tm starts from 0
					ptmTime->tm_mday,
					ptmTime->tm_hour ,			       //hour in struct tm starts from 0
					ptmTime->tm_min ,			       //minute in struct tm starts from 0
					ptmTime->tm_sec                    //second in struct tm starts from 0
					);
		  }
		  else
		  {
			  ASSERT(0);
              return LogHR(MQ_ERROR, s_FN, 930);
		  }
          break;

      case(VT_UI4):
          *ppwszVal = new WCHAR[ x_NumberLength + 1];
          wsprintf(*ppwszVal, L"%d", pPropVar->ulVal);
          break;

      case(VT_HRESULT):
          *ppwszVal = new WCHAR[ x_NumberLength + 1];
          wsprintf(*ppwszVal, L"%d", pPropVar->scode);
          break;

      case(VT_CLSID):
          {
              ADsFree  pwcsGuid;
              hr = ADsEncodeBinaryData(
                    (unsigned char *)pPropVar->puuid,
                    sizeof(GUID),
                    &pwcsGuid
                    );
              if (FAILED(hr))
              {
                  return LogHR(hr, s_FN, 940);
              }
              *ppwszVal = new WCHAR[ wcslen( pwcsGuid) + 1];
              wcscpy( *ppwszVal, pwcsGuid);
          }
          break;

      case(VT_BLOB):
          {

              ADsFree  pwcsBlob;
              hr = ADsEncodeBinaryData(
                    pPropVar->blob.pBlobData,
                    pPropVar->blob.cbSize,
                    &pwcsBlob
                    );
              if (FAILED(hr))
              {
                  return LogHR(hr, s_FN, 950);
              }
              *ppwszVal = new WCHAR[ wcslen( pwcsBlob) + 1];
              wcscpy( *ppwszVal, pwcsBlob);
          }

          break;

      case(VT_LPWSTR):
          StringToSearchFilter(
                    pPropVar,
                    ppwszVal
                    );
          break;


      default:
        ASSERT(0);
        return LogHR(MQ_ERROR, s_FN, 960);
    }

    return MQ_OK;
}

STATIC LPWSTR GetWStringFromAdsiValue(
      IN  ADSTYPE       AdsType,
      IN  PADSVALUE     pADsValue)
{
    switch(AdsType)
    {
    case ADSTYPE_DN_STRING:
        return pADsValue->DNString;

    case ADSTYPE_CASE_EXACT_STRING:
        return pADsValue->CaseExactString;

    case ADSTYPE_CASE_IGNORE_STRING:
        return pADsValue->CaseIgnoreString;

    case ADSTYPE_PRINTABLE_STRING:
        return pADsValue->PrintableString;

    case ADSTYPE_NUMERIC_STRING:
        return pADsValue->NumericString;

    case ADSTYPE_OBJECT_CLASS:
        return pADsValue->ClassName;

    default:
        ASSERT(0);
        return NULL;
    }
}

STATIC HRESULT AdsiStringVal2MqVal(
      OUT MQPROPVARIANT *pPropVar,
      IN  VARTYPE       vtTarget,
      IN  ADSTYPE       AdsType,
      IN  DWORD         dwNumValues,
      IN  PADSVALUE     pADsValue)
{
    LPWSTR pwsz;

    if (vtTarget == VT_LPWSTR)
    {
        if (dwNumValues == 1)
        {
            pwsz = GetWStringFromAdsiValue(AdsType, pADsValue);
            if (pwsz == NULL)
            {
                ASSERT(0);
                return LogHR(MQ_ERROR, s_FN, 970);
            }

            pPropVar->vt      = VT_LPWSTR;
            pPropVar->pwszVal = new WCHAR[wcslen(pwsz) + 1];
            wcscpy(pPropVar->pwszVal, pwsz);
			return(MQ_OK);
        }
		else
		{
			ASSERT(0);
            return LogHR(MQ_ERROR, s_FN, 980);
		}
	}
    else if (vtTarget == (VT_LPWSTR | VT_VECTOR))
    {
        pPropVar->vt    = VT_LPWSTR | VT_VECTOR;
        AP<LPWSTR> pElems = new LPWSTR[dwNumValues];
        CWcsArray pClean( dwNumValues,  pElems);
        for(DWORD i = 0; i < dwNumValues; i++)
        {
            pwsz = GetWStringFromAdsiValue(AdsType, &pADsValue[i]);
            if (pwsz == NULL)
            {
                ASSERT(0);
                return LogHR(MQ_ERROR, s_FN, 990);
            }

            pElems[i] = new WCHAR[wcslen(pwsz) + 1];
            wcscpy(pElems[i], pwsz);
        }

        (pPropVar->calpwstr).cElems = dwNumValues;
        pClean.detach();
        (pPropVar->calpwstr).pElems = pElems.detach();
        return MQ_OK;
    }
    else
    {
        ASSERT(0);
        return LogHR(MQ_ERROR, s_FN, 1000);
    }
}

STATIC HRESULT SetIntegerIntoMqPropVar(
    IN  VARTYPE       vtTarget,
    OUT MQPROPVARIANT *pPropVar,
    IN  ULONG         *pIntegers,
    IN  ULONG          cIntegers)
{

	pPropVar->vt = vtTarget;

    switch(vtTarget)
    {
    case(VT_UI1):
        ASSERT(cIntegers == 1);
        pPropVar->bVal = *(unsigned char *)pIntegers;   // UCHAR
        break;

    case(VT_I2):
        ASSERT(cIntegers == 1);
        pPropVar->iVal = *(short *)pIntegers;   // short
        break;

    case(VT_UI2):
        ASSERT(cIntegers == 1);
        pPropVar->uiVal = *(unsigned short *)pIntegers;   // USHORT
        break;

    case(VT_I4):
        ASSERT(cIntegers == 1);
        pPropVar->lVal = *pIntegers;   // long
        break;

    case(VT_UI4):
        ASSERT(cIntegers == 1);
        pPropVar->ulVal = *pIntegers;   // ULONG
        break;

    case(VT_HRESULT):
        ASSERT(cIntegers == 1);
        pPropVar->scode = *pIntegers;   // SCODE
        break;



    default:
        ASSERT(0);
        pPropVar->vt = VT_EMPTY;
        return LogHR(MQ_ERROR, s_FN, 1010);
    }

    return MQ_OK;
}

STATIC HRESULT AdsiIntegerVal2MqVal(
      OUT MQPROPVARIANT *pPropVar,
      IN  VARTYPE       vtTarget,
      IN  DWORD         dwNumValues,
      IN  PADSVALUE     pADsValue)
{
    if (dwNumValues == 1)
    {
        ULONG intval = pADsValue->Integer;
        if (FAILED(SetIntegerIntoMqPropVar(
                      vtTarget,
                      pPropVar,
                      &intval,
                      1)))
        {
            ASSERT(0);
            return LogHR(MQ_ERROR, s_FN, 1020);
        }
    }
    else
    {
        AP<ULONG> pArr = new ULONG[dwNumValues];
        for (DWORD i=0; i<dwNumValues; i++)
        {
            pArr[i] = pADsValue[i].Integer;
        }

        if (FAILED(SetIntegerIntoMqPropVar(
                      vtTarget,
                      pPropVar,
                      pArr,
                      dwNumValues)))
        {
            ASSERT(0);
            return LogHR(MQ_ERROR, s_FN, 1030);
        }

    }
    return MQ_OK;
}

//------------------------------------------------------------
//    AdsiVal2MqVal()
//    Translates ADSI value into MQ PropVal
//------------------------------------------------------------
HRESULT AdsiVal2MqVal(
      OUT MQPROPVARIANT *pPropVar,
      IN  VARTYPE       vtTarget,
      IN  ADSTYPE       AdsType,
      IN  DWORD         dwNumValues,
      IN  ADSVALUE *    pADsValue)
{
    HRESULT hr2;

    switch (AdsType)
    {
    case ADSTYPE_DN_STRING:
    case ADSTYPE_CASE_EXACT_STRING:
    case ADSTYPE_CASE_IGNORE_STRING:
    case ADSTYPE_PRINTABLE_STRING:
    case ADSTYPE_NUMERIC_STRING:
    case ADSTYPE_OBJECT_CLASS:

        hr2 = AdsiStringVal2MqVal(
                  pPropVar,
                  vtTarget,
                  AdsType,
                  dwNumValues,
                  pADsValue);
        return LogHR(hr2, s_FN, 1040);

    case ADSTYPE_INTEGER:

        hr2 = AdsiIntegerVal2MqVal(
                    pPropVar,
                    vtTarget,
                    dwNumValues,
                    pADsValue);
        return LogHR(hr2, s_FN, 1050);

    case ADSTYPE_BOOLEAN:
        if (dwNumValues == 1)
        {
            if (vtTarget == VT_BOOL)
            {
                pPropVar->vt      = VT_BOOL;
#pragma warning(disable: 4310)
                pPropVar->boolVal = (pADsValue->Boolean ? VARIANT_TRUE : VARIANT_FALSE);  //BUGBUG: are values the same?
#pragma warning(default: 4310)
            }
            else if (vtTarget == VT_UI1)
            {
                pPropVar->vt      = VT_UI1;
                pPropVar->bVal = (pADsValue->Boolean ? (unsigned char)1 : (unsigned char)0);  //BUGBUG: are values the same?
            }
            else
            {
                ASSERT(0);
                return LogHR(MQ_ERROR, s_FN, 1060);
            }
        }
        else
        {
            ASSERT(0);  // There is no VT_BOOL | VT_VECTOR case on MQPROPVARIANT
            return LogHR(MQ_ERROR, s_FN, 1070);
        }
        break;

    case ADSTYPE_OCTET_STRING:

        if (vtTarget == VT_BLOB)
        {
            if (dwNumValues != 1)
            {
                ASSERT(0);  // NIY
                return LogHR(MQ_ERROR, s_FN, 1080);
            }
            pPropVar->vt             = VT_BLOB;
            pPropVar->blob.cbSize    = pADsValue->OctetString.dwLength;
            pPropVar->blob.pBlobData = new BYTE[pADsValue->OctetString.dwLength];

            CopyMemory(pPropVar->blob.pBlobData,
                       pADsValue->OctetString.lpValue,
                       pADsValue->OctetString.dwLength);
        }
        else if (vtTarget == VT_CLSID)
        {
            if (dwNumValues != 1)
            {
                ASSERT(0);  // NIY
                return LogHR(MQ_ERROR, s_FN, 1090);
            }
            ASSERT(pADsValue->OctetString.dwLength == 16);

            //
            //  This is a special case where we do not necessarily allocate the memory for the guid
            //  in puuid. The caller may already have puuid set to a guid, and this is indicated by the
            //  vt member on the given propvar. It could be VT_CLSID if guid already allocated, otherwise
            //  we allocate it (and vt should be VT_NULL (or VT_EMPTY))
            //
            if (pPropVar->vt != VT_CLSID)
            {
                ASSERT(((pPropVar->vt == VT_NULL) || (pPropVar->vt == VT_EMPTY)));
                pPropVar->vt    = VT_CLSID;
                pPropVar->puuid = new GUID;
            }   
            else if ( pPropVar->puuid == NULL)
            {
                return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 1100);
            }

            CopyMemory(pPropVar->puuid,
                       pADsValue->OctetString.lpValue,
                       pADsValue->OctetString.dwLength);
        }
        else if (vtTarget == (VT_CLSID|VT_VECTOR))
        {
            ASSERT( pADsValue->OctetString.dwLength == sizeof(GUID));
            DWORD num = dwNumValues;
            pPropVar->cauuid.pElems = new GUID[ num];
            pPropVar->cauuid.cElems = num;
            pPropVar->vt = VT_CLSID|VT_VECTOR;


            for (DWORD i = 0 ; i < num; i++, pADsValue++)
            {
                CopyMemory(&pPropVar->cauuid.pElems[i],
                           pADsValue->OctetString.lpValue,
                           sizeof(GUID));
            }

        }
        else
        {
            ASSERT(0);
            return LogHR(MQ_ERROR, s_FN, 1110);
        }
        break;

    case ADSTYPE_UTC_TIME:
        if (dwNumValues != 1)
        {
            ASSERT(0);    // NIY
            return LogHR(MQ_ERROR, s_FN, 1120);
        }

        if (vtTarget == VT_DATE)
        {
            pPropVar->vt      = VT_DATE;
            if (!SystemTimeToVariantTime(&pADsValue->UTCTime, &pPropVar->date))
            {
                ASSERT(0);
                return LogHR(MQ_ERROR, s_FN, 1130);
            }
        }
        else if (vtTarget == VT_I4)
        {
            //
            //   convert SYSTEMTIME->time_t
            //
            pPropVar->vt = VT_I4;
            pPropVar->lVal = INT_PTR_TO_INT(TimeFromSystemTime(&pADsValue->UTCTime)); //BUGBUG bug year 2038

        }
        else
        {
            ASSERT(0);
            return LogHR(MQ_ERROR, s_FN, 1140);
        }
        break;

    case ADSTYPE_LARGE_INTEGER:
        // No such thing in MQ!
        ASSERT(0);
        return LogHR(MQ_ERROR, s_FN, 1150);

	case ADSTYPE_NT_SECURITY_DESCRIPTOR:
        if (dwNumValues != 1)
        {
            ASSERT(0);    // NIY
            return LogHR(MQ_ERROR, s_FN, 1160);
        }

        if (vtTarget == VT_BLOB)
        {
#ifdef _DEBUG
            SECURITY_DESCRIPTOR *pSD = (SECURITY_DESCRIPTOR*)
                                    pADsValue->SecurityDescriptor.lpValue ;
            DWORD dwSDLen = GetSecurityDescriptorLength(pSD) ;

            ASSERT(IsValidSecurityDescriptor(pSD)) ;
            ASSERT(dwSDLen == pADsValue->SecurityDescriptor.dwLength) ;
#endif

            pPropVar->vt             = VT_BLOB;
            pPropVar->blob.cbSize    = pADsValue->SecurityDescriptor.dwLength;
            pPropVar->blob.pBlobData = new BYTE[pADsValue->SecurityDescriptor.dwLength];

            CopyMemory(pPropVar->blob.pBlobData,
                       pADsValue->SecurityDescriptor.lpValue,
                       pADsValue->SecurityDescriptor.dwLength);
        }
        break;

    case ADSTYPE_PROV_SPECIFIC:
        // No such thing in MQ!
        ASSERT(0);
        return LogHR(MQ_ERROR, s_FN, 1170);

    default:
        return LogHR(MQ_ERROR, s_FN, 1180);

    }
    return MQ_OK;
}




void LogMsgHR(HRESULT hr, LPWSTR wszFileName, USHORT usPoint)
{
    WRITE_MSMQ_LOG(( MSMQ_LOG_ERROR,
                     e_LogDS,
                     LOG_DS_ERRORS,
                     L"MQADS Error: %s/%d. HR: %x", 
                     wszFileName,
                     usPoint,
                     hr)) ;
}

void LogMsgNTStatus(NTSTATUS status, LPWSTR wszFileName, USHORT usPoint)
{
    WRITE_MSMQ_LOG(( MSMQ_LOG_ERROR,
                     e_LogDS,
                     LOG_DS_ERRORS,
                     L"MQADS Error: %s/%d. NTStatus: %x", 
                     wszFileName,
                     usPoint,
                     status)) ;
}

void LogMsgRPCStatus(RPC_STATUS status, LPWSTR wszFileName, USHORT usPoint)
{
    WRITE_MSMQ_LOG(( MSMQ_LOG_ERROR,
                     e_LogDS,
                     LOG_DS_ERRORS,
                     L"MQADS Error: %s/%d. RPCStatus: %x", 
                     wszFileName,
                     usPoint,
                     status)) ;
}

void LogMsgBOOL(BOOL b, LPWSTR wszFileName, USHORT usPoint)
{
    WRITE_MSMQ_LOG(( MSMQ_LOG_ERROR,
                     e_LogDS,
                     LOG_DS_ERRORS,
                     L"MQADS Error: %s/%d. BOOL: %x", 
                     wszFileName,
                     usPoint,
                     b)) ;
}

void LogIllegalPoint(LPWSTR wszFileName, USHORT usPoint)
{
        WRITE_MSMQ_LOG(( MSMQ_LOG_ERROR,
                         e_LogDS,
                         LOG_DS_ERRORS,
                         L"MQADS Error: %s/%d. Point", 
                         wszFileName,
                         usPoint)) ;
}

#ifdef _WIN64
	void LogIllegalPointValue(DWORD64 dw64, LPCWSTR wszFileName, USHORT usPoint)
	{
		WRITE_MSMQ_LOG(( MSMQ_LOG_ERROR,
						 e_LogDS,
						 LOG_DS_ERRORS,
						 L"MQADS Error: %s/%d, Value: 0x%I64x",
						 wszFileName,
						 usPoint,
						 dw64)) ;
	}
#else
	void LogIllegalPointValue(DWORD dw, LPCWSTR wszFileName, USHORT usPoint)
	{
		WRITE_MSMQ_LOG(( MSMQ_LOG_ERROR,
						 e_LogDS,
						 LOG_DS_ERRORS,
						 L"MQADS Error: %s/%d, Value: 0x%x",
						 wszFileName,
						 usPoint,
						 dw)) ;
	}
#endif //_WIN64

void LogTraceQuery(LPWSTR wszStr, LPWSTR wszFileName, USHORT usPoint)
{
        WRITE_MSMQ_LOG(( MSMQ_LOG_ERROR,
                         e_LogDS,
                         LOG_DS_QUERY,
                         L"MQADS Trace: %s/%d. %s", 
                         wszFileName,
                         usPoint,
                         wszStr)) ;
}

void LogTraceQuery2(LPWSTR wszStr1, LPWSTR wszStr2, LPWSTR wszFileName, USHORT usPoint)
{
        WRITE_MSMQ_LOG(( MSMQ_LOG_ERROR,
                         e_LogDS,
                         LOG_DS_QUERY,
                         L"MQADS Trace: %s/%d. %s  %s", 
                         wszFileName,
                         usPoint,
                         wszStr1,
                         wszStr2)) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdscore\usercert.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    usercert.h

Abstract:
    Classes to manipulate use certificate blob


Author:

    Ronit Hartmann (ronith)

--*/

#ifndef __USERCERT_H__
#define __USERCERT_H__
//-----------------------------------------
// User object : certificate attribute structure
//
// In MSMQ each user has a certificate per machine,
// In NT5 there is one user object per user.
// Therefore msmq-certificate property in NT5 will contain
// multiple values
//-----------------------------------------


#pragma pack(push, 1)
#pragma warning(disable: 4200)  //  zero-sized array in struct/union (enabeld later)

struct CUserCert {
public:

    inline CUserCert( const GUID&    guidDigest,
                      const GUID&    guidId,
                      const DWORD    dwCertLength,
                      const BYTE *   pCert);

	inline CUserCert();
    inline CUserCert( const CUserCert& other);
    static ULONG CalcSize(
            IN DWORD dwCertLen);

    inline HRESULT CopyIntoBlob( OUT MQPROPVARIANT * pvar) const;

    inline BOOL DoesDigestMatch(
                IN  const GUID *       pguidDigest) const;

    inline DWORD GetSize() const;

    inline BYTE * MarshaleIntoBuffer(
                    IN BYTE * pbBuffer);

private:

    GUID           m_guidDigest;
    GUID           m_guidId;
    DWORD          m_dwCertLength;
    BYTE           m_Cert[0];       // variable length
};

#pragma warning(default: 4200)  //  zero-sized array in struct/union
#pragma pack(pop)


inline CUserCert::CUserCert(
                      const GUID&    guidDigest,
                      const GUID&    guidId,
                      const DWORD    dwCertLength,
                      const BYTE *   pCert)
{
	//
	// ISSUE-2000/12/18-ilanh Compiler bug
	//
    memcpy((UNALIGNED GUID*)&m_guidDigest, &guidDigest, sizeof(GUID));
    memcpy((UNALIGNED GUID*)&m_guidId, &guidId, sizeof(GUID));
    memcpy((UNALIGNED DWORD*)&m_dwCertLength, &dwCertLength, sizeof(DWORD));
    memcpy( m_Cert, pCert, dwCertLength);
}

inline CUserCert::CUserCert(
                  const CUserCert& other)
{
	//
	// ISSUE-2000/12/18-ilanh Compiler bug
	//
    memcpy((UNALIGNED GUID*)&m_guidDigest, &other.m_guidDigest, sizeof(GUID));
    memcpy((UNALIGNED GUID*)&m_guidId, &other.m_guidId, sizeof(GUID));
    memcpy((UNALIGNED DWORD*)&m_dwCertLength, &other.m_dwCertLength, sizeof(DWORD));
    memcpy( m_Cert, &other.m_Cert, m_dwCertLength);
}

inline CUserCert::CUserCert()
{
}

inline HRESULT CUserCert::CopyIntoBlob( OUT MQPROPVARIANT * pvar) const
{
    if ( pvar->vt != VT_NULL)
    {
        return(MQ_ERROR);
    }
    if ( m_dwCertLength == 0)
    {
        return(MQ_ERROR);
    }
    //
    //  allocate memory
    //
    pvar->blob.pBlobData = new BYTE[ m_dwCertLength];
    memcpy( pvar->blob.pBlobData, &m_Cert,  m_dwCertLength);
    pvar->blob.cbSize =  m_dwCertLength;
    pvar->vt = VT_BLOB;
    return( MQ_OK);
}

inline BOOL CUserCert::DoesDigestMatch(
                 IN  const GUID *  pguidDigest) const
{
	//
	// ISSUE-2000/12/18-ilanh Compiler bug
	//
    return(memcmp((UNALIGNED GUID*)&m_guidDigest, pguidDigest, sizeof(GUID)) == 0);
}

inline DWORD CUserCert::GetSize() const
{
    return( sizeof( CUserCert) +  m_dwCertLength);
}

inline ULONG CUserCert::CalcSize(
                   IN DWORD dwCertLen)
{
    return( sizeof(CUserCert) + dwCertLen);
}

inline BYTE * CUserCert::MarshaleIntoBuffer(
                         IN BYTE * pbBuffer)
{
    BYTE * pNextToFill = pbBuffer;
    memcpy( pNextToFill, &m_guidDigest, sizeof(GUID));
    pNextToFill += sizeof(GUID);
    memcpy( pNextToFill, &m_guidId, sizeof(GUID));
    pNextToFill += sizeof(GUID);
    memcpy( pNextToFill, &m_dwCertLength, sizeof(DWORD));
    pNextToFill += sizeof(DWORD);
    memcpy( pNextToFill, &m_Cert, m_dwCertLength);
    pNextToFill += m_dwCertLength;
    return( pNextToFill);

}


#pragma pack(push, 1)
#pragma warning(disable: 4200)  //  zero-sized array in struct/union (enabeld later)


struct CUserCertBlob {
public:
    inline CUserCertBlob(
                    IN const CUserCert *     pUserCert);
    inline CUserCertBlob();
    static ULONG CalcSize( void);

    inline HRESULT GetUserCert( IN  const GUID *       pguidDigest,
                         OUT const CUserCert ** ppUserCert) const;

    inline DWORD GetNumberOfCerts();

    inline HRESULT GetCertificate(
                          IN  const DWORD     dwCertificateNumber,
                          OUT MQPROPVARIANT * pvar
                          );

    inline void MarshaleIntoBuffer(
                  IN BYTE * pbBuffer);
    inline void IncrementNumCertificates();

    inline HRESULT RemoveCertificateFromBuffer(
                            IN  const GUID *     pguidDigest,
                            IN  DWORD            dwTotalSize,
                            OUT DWORD *          pdwCertSize);

private:

    DWORD           m_dwNumCert;
    CUserCert       m_userCert;
};

#pragma warning(default: 4200)  //  zero-sized array in struct/union
#pragma pack(pop)

inline CUserCertBlob::CUserCertBlob(
              IN const CUserCert *     pUserCert):
              m_userCert(*pUserCert)
{
    m_dwNumCert = 1;
}

inline CUserCertBlob::CUserCertBlob()
{
}

inline HRESULT CUserCertBlob::GetUserCert(
                         IN  const GUID *       pguidDigest,
                         OUT const CUserCert ** ppUserCert) const
{
    if ( m_dwNumCert == 0)
    {
        return(MQ_ERROR);
    }
    const CUserCert * pUserCert = &m_userCert;
    for (DWORD i = 0; i < m_dwNumCert; i++)
    {
        if (pUserCert->DoesDigestMatch( pguidDigest))
        {
            *ppUserCert = pUserCert;
            return( MQ_OK);
        }
        //
        //  Move to next certificate
        //
        BYTE *pBuf = (BYTE*) pUserCert ;
        pBuf += pUserCert->GetSize();
        pUserCert = (const CUserCert*) pBuf ;
    }
    //
    //  No match digest in the user cert blob
    //
    return(MQ_ERROR);

}
inline DWORD CUserCertBlob::GetNumberOfCerts()
{
    return( m_dwNumCert);
}

inline HRESULT CUserCertBlob::GetCertificate(
                          IN  const DWORD     dwCertificateNumber,
                          OUT MQPROPVARIANT * pvar
                          )
{
    HRESULT hr;

    if ( dwCertificateNumber > m_dwNumCert)
    {
        return(MQ_ERROR);
    }
    const CUserCert * pUserCert = &m_userCert;
    //
    //  Move to certificate number dwCertificateNumber
    //
    for (DWORD i = 0; i < dwCertificateNumber; i++)
    {
        //
        //  Move to next certificate
        //
        pUserCert = (const CUserCert * )((const unsigned char *)pUserCert + pUserCert->GetSize());
    }
    pvar->vt = VT_NULL;
    hr = pUserCert->CopyIntoBlob(
                            pvar
                            );
    return(hr);
}

inline ULONG CUserCertBlob::CalcSize( void)
{
    //
    //  Just the size of CUserCertBlob without
    //  the size of m_userCert
    //
    return( sizeof(CUserCertBlob) - CUserCert::CalcSize(0));
}

inline void CUserCertBlob::MarshaleIntoBuffer(
                  IN BYTE * pbBuffer)
{
    ASSERT( m_dwNumCert == 1);
    memcpy( pbBuffer, &m_dwNumCert, sizeof(DWORD));
    m_userCert.MarshaleIntoBuffer( pbBuffer + sizeof(DWORD));

}
inline void CUserCertBlob::IncrementNumCertificates()
{
    m_dwNumCert++;
}

inline HRESULT CUserCertBlob::RemoveCertificateFromBuffer(
                            IN  const GUID *     pguidDigest,
                            IN  DWORD            dwTotalSize,
                            OUT DWORD *          pdwCertSize)
{
    const CUserCert * pUserCert = &m_userCert;
    //
    //  Find the certificate to be removed according to its digest
    //
    BOOL fFoundCertificate = FALSE;
    for ( DWORD i = 0; i < m_dwNumCert; i++)
    {
        if ( pUserCert->DoesDigestMatch( pguidDigest))
        {
            fFoundCertificate = TRUE;
            break;
        }
        //
        //  Move to next certificate
        //
        pUserCert = (const CUserCert * )((const unsigned char *)pUserCert + pUserCert->GetSize());
    }
    if ( !fFoundCertificate)
    {
        return MQDS_OBJECT_NOT_FOUND;
    }
    //
    //  copy buffer ( i.e. copy the remaining certificates over the removed one)
    //
    DWORD dwCertSize =  pUserCert->GetSize();
    DWORD_PTR dwSizeToCopy =  dwTotalSize -
                         (((const unsigned char *)pUserCert) - ((const unsigned char *)&m_userCert))
                         - dwCertSize - sizeof(m_dwNumCert);
    if ( dwSizeToCopy)
    {
        memcpy( (unsigned char *)pUserCert,
                (unsigned char *)pUserCert + dwCertSize,
                dwSizeToCopy);
    }
    *pdwCertSize = dwCertSize;
    m_dwNumCert--;
    return(MQ_OK);
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdscore\tranrout.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    tranrout.h

Abstract:

    Translation routines for properties not in NT5 DS

Author:

    ronit hartmann ( ronith)

--*/
#ifndef __tranrout_h__
#define __tranrout_h__


HRESULT WINAPI MQADSpRetrieveEnterpriseName(
                 IN  CMsmqObjXlateInfo * pcMsmqObjXlateInfo,
                 OUT PROPVARIANT *   ppropvariant);

HRESULT WINAPI MQADSpRetrieveEnterprisePEC(
                 IN  CMsmqObjXlateInfo * pcMsmqObjXlateInfo,
                 OUT PROPVARIANT *   ppropvariant);

HRESULT WINAPI MQADSpRetrieveSiteSignPK(
                 IN  CMsmqObjXlateInfo * pcMsmqObjXlateInfo,
                 OUT PROPVARIANT *   ppropvariant);

HRESULT WINAPI MQADSpRetrieveSiteGates(
                 IN  CMsmqObjXlateInfo * pcMsmqObjXlateInfo,
                 OUT PROPVARIANT *   ppropvariant);

HRESULT WINAPI MQADSpRetrieveSiteInterval1(
                 IN  CMsmqObjXlateInfo * pcMsmqObjXlateInfo,
                 OUT PROPVARIANT *   ppropvariant);

HRESULT WINAPI MQADSpRetrieveSiteInterval2(
                 IN  CMsmqObjXlateInfo * pcMsmqObjXlateInfo,
                 OUT PROPVARIANT *   ppropvariant);



HRESULT WINAPI MQADSpRetrieveQueueQMid(
                 IN  CMsmqObjXlateInfo * pcMsmqObjXlateInfo,
                 OUT PROPVARIANT *   ppropvariant);


HRESULT WINAPI MQADSpRetrieveQueueName(
                 IN  CMsmqObjXlateInfo * pcMsmqObjXlateInfo,
                 OUT PROPVARIANT *   ppropvariant);

HRESULT WINAPI MQADSpRetrieveQueueDNSName(
                 IN  CMsmqObjXlateInfo * pcMsmqObjXlateInfo,
                 OUT PROPVARIANT *   ppropvariant);

HRESULT WINAPI MQADSpRetrieveNothing(
                 IN  CMsmqObjXlateInfo * pcMsmqObjXlateInfo,
                 OUT PROPVARIANT *   ppropvariant);

HRESULT WINAPI MQADSpRetrieveLinkNeighbor1(
                 IN  CMsmqObjXlateInfo * pcMsmqObjXlateInfo,
                 OUT PROPVARIANT *   ppropvariant);

HRESULT WINAPI MQADSpRetrieveLinkNeighbor2(
                 IN  CMsmqObjXlateInfo * pcMsmqObjXlateInfo,
                 OUT PROPVARIANT *   ppropvariant);

HRESULT WINAPI MQADSpSetLinkNeighbor1(
                 IN IADs *             pAdsObj,
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar);

HRESULT WINAPI MQADSpCreateLinkNeighbor1(
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar);

HRESULT WINAPI MQADSpSetLinkNeighbor2(
                 IN IADs *             pAdsObj,
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar);

HRESULT WINAPI MQADSpCreateLinkNeighbor2(
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar);

HRESULT WINAPI MQADSpRetrieveLinkCost(
                 IN  CMsmqObjXlateInfo * pcMsmqObjXlateInfo,
                 OUT PROPVARIANT *   ppropvariant);

HRESULT WINAPI MQADSpRetrieveLinkGates(
                 IN  CMsmqObjXlateInfo * pcMsmqObjXlateInfo,
                 OUT PROPVARIANT *   ppropvariant);

HRESULT WINAPI MQADSpSetLinkCost(
                 IN IADs *             pAdsObj,
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar);

HRESULT WINAPI MQADSpCreateLinkCost(
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdscore\xlatqm.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    xlatqm.cpp

Abstract:

    Implementation of routines to translate QM info from NT5 Active DS
    to what MSMQ 1.0 (NT4) QM's expect

Author:

    Raanan Harari (raananh)

--*/

#include "ds_stdh.h"
#include "mqads.h"
#include "mqattrib.h"
#include "xlatqm.h"
#include "coreglb.h"
#include "dsutils.h"
#include "ipsite.h"
#include "_propvar.h"
#include "utils.h"
#include "adstempl.h"
#include "mqdsname.h"
#include "winsock.h"
#include "uniansi.h"
#include <mqsec.h>
#include <nspapi.h>
#include <wsnwlink.h>

#include "xlatqm.tmh"

static WCHAR *s_FN=L"mqdscore/xlatqm";

HRESULT WideToAnsiStr(LPCWSTR pwszUnicode, LPSTR * ppszAnsi);


//----------------------------------------------------------------------
//
// Static routines
//
//----------------------------------------------------------------------

STATIC HRESULT GetMachineNameFromQMObject(LPCWSTR pwszDN, LPWSTR * ppwszMachineName)
/*++

Routine Description:
    gets the machine name from the object's DN

Arguments:
    pwszDN              - Object's DN
    ppwszMachineName    - returned name for the object

Return Value:
    HRESULT

--*/
{
    //
    // copy to tmp buf so we can munge it
    //
    AP<WCHAR> pwszTmpBuf = new WCHAR[1+wcslen(pwszDN)];
    wcscpy(pwszTmpBuf, pwszDN);

    //
    // skip "CN=msmq,CN="
    // BUGBUG: need to write a parser for DN's
    //
    LPWSTR pwszTmp = wcschr(pwszTmpBuf, L',');
    if (pwszTmp)
        pwszTmp = wcschr(pwszTmp, L'=');
    if (pwszTmp)
        pwszTmp++;

    //
    // sanity check
    //
    if (pwszTmp == NULL)
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("GetMachineNameFromQMObject:Bad DN for QM object (%ls)"), pwszDN));
        return LogHR(MQ_ERROR, s_FN, 10);
    }

    LPWSTR pwszNameStart = pwszTmp;

    //
    // remove the ',' at the end of the name
    //
    pwszTmp = wcschr(pwszNameStart, L',');
    if (pwszTmp)
        *pwszTmp = L'\0';

    //
    // save name
    //
    AP<WCHAR> pwszMachineName = new WCHAR[1+wcslen(pwszNameStart)];
    wcscpy(pwszMachineName, pwszNameStart);

    //
    // return values
    //
    *ppwszMachineName = pwszMachineName.detach();
    return S_OK;
}

/*++

Routine Description:
    gets the computer DNS name

Arguments:
    pwcsComputerName    - the computer name
    ppwcsDnsName        - returned DNS name of the computer

Return Value:
    HRESULT

--*/
HRESULT MQADSpGetComputerDns(
                IN  LPCWSTR     pwcsComputerName,
                OUT WCHAR **    ppwcsDnsName
                )
{
    *ppwcsDnsName = NULL;
    PROPID prop = PROPID_COM_DNS_HOSTNAME;
    PROPVARIANT varDnsName;
    varDnsName.vt = VT_NULL;
    //
    //  Is the computer in the local domain?
    //
    WCHAR * pszDomainName = wcsstr(pwcsComputerName, x_DcPrefix);
    ASSERT(pszDomainName) ;
    HRESULT hr;

    if ( !wcscmp( pszDomainName, g_pwcsLocalDsRoot)) 
    {
        //
        //   try local DC
        //
        CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);
        hr = g_pDS->GetObjectProperties(
            eLocalDomainController,
            &requestDsServerInternal,
 	        pwcsComputerName,      // the computer object name
            NULL,     
            1,
            &prop,
            &varDnsName);
    }
    else
    {

        CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);
        hr =  g_pDS->GetObjectProperties(
                    eGlobalCatalog,
                    &requestDsServerInternal,
 	                pwcsComputerName,      // the computer object name
                    NULL,    
                    1,
                    &prop,
                    &varDnsName);
    }
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 20);
    }

    //
    // return value
    //
    *ppwcsDnsName = varDnsName.pwszVal;
    return MQ_OK;
}

STATIC HRESULT GetMachineNameAndDnsFromQMObject(LPCWSTR pwszDN,
                                                LPWSTR * ppwszMachineName,
                                                LPWSTR * ppwszMachineDnsName)
/*++

Routine Description:
    gets the machine name and dns name from the object's DN

Arguments:
    pwszDN              - Object's DN
    ppwszMachineName    - returned name for the object
    ppwszMachineDnsName - returned dns name for the object

Return Value:
    HRESULT

--*/
{
    *ppwszMachineName = NULL;
    *ppwszMachineDnsName = NULL;

    DWORD len = wcslen(pwszDN);

    //
    // skip "CN=msmq,CN="
    // BUGBUG: need to write a parser for DN's
    //
    LPWSTR pwszTmp = wcschr(pwszDN, L',');
    if (pwszTmp)
        pwszTmp = wcschr(pwszTmp, L'=');
    if (pwszTmp)
        pwszTmp++;

    //
    // sanity check
    //
    if (pwszTmp == NULL)
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("GetMachineNameAndDnsFromQMObject:Bad DN for QM object (%ls)"), pwszDN));
        return LogHR(MQ_ERROR, s_FN, 30);
    }

    LPWSTR pwszNameStart = pwszTmp;

    //
    // find the ',' at the end of the name
    //
    pwszTmp = wcschr(pwszNameStart, L',');

    //
    // save name
    //
    AP<WCHAR> pwszMachineName = new WCHAR[1 + len];

    DWORD_PTR dwSubStringLen = pwszTmp - pwszNameStart;
    wcsncpy( pwszMachineName, pwszNameStart, dwSubStringLen);
    pwszMachineName[ dwSubStringLen] = L'\0';

    //
    //  For the dns name of the computer read dNSHostName of its computer
    //  object ( father object)
    //
    pwszTmp = wcschr(pwszDN, L',') + 1;    // the computer name

    MQADSpGetComputerDns(
                pwszTmp,
                ppwszMachineDnsName
                );
    //
    //  ignore the result ( in case of failure a null string is returned)

    //
    // return values
    //
    *ppwszMachineName = pwszMachineName.detach();
    return S_OK;

}



//----------------------------------------------------------------------
//
// CMsmqQmXlateInfo class
//
//----------------------------------------------------------------------


struct XLATQM_ADDR_SITE
//
// Describes an address in a site
//
{
    GUID        guidSite;
    USHORT      AddressLength;
    USHORT      usAddressType;
    sockaddr    Address;
};

class CMsmqQmXlateInfo : public CMsmqObjXlateInfo
//
// translate object for the QM DS object. It contains common info needed for
// for translation of several properties in the QM object
//
{
public:
    CMsmqQmXlateInfo(
        LPCWSTR             pwszObjectDN,
        const GUID*         pguidObjectGuid,
        CDSRequestContext * pRequestContext);
    ~CMsmqQmXlateInfo();
    HRESULT ComputeBestSite();
    HRESULT ComputeAddresses();
    HRESULT ComputeCNs();

    const GUID *                 BestSite();
    const XLATQM_ADDR_SITE *     Addrs();
    ULONG                        CountAddrs();
    const GUID *                 CNs();

    HRESULT RetrieveFrss(
           IN  LPCWSTR          pwcsAttributeName,
           OUT MQPROPVARIANT *  ppropvariant
           );


private:
    HRESULT GetDSSites(OUT ULONG *pcSites,
                       OUT GUID ** prgguidSites);

    HRESULT RetrieveFrssFromDs(
           IN  LPCWSTR          pwcsAttributeName,
           OUT MQPROPVARIANT *  pvar
           );

    HRESULT FetchMachineParameters(
                OUT BOOL *      pfForeignMachine,
                OUT BOOL *      pfRoutingServer,
                OUT LPWSTR *    ppwszMachineName,
                OUT LPWSTR *    ppwszMachineDnsName);

   HRESULT ComputeSiteGateAddresses(
                    const IPSITE_SiteArrayEntry *   prgSites,
                    ULONG                           cSites,
                    const ULONG *                   prgIpAddrs,
                    ULONG                           cIpAddrs);

   HRESULT ComputeRoutingServerAddresses(
                    const IPSITE_SiteArrayEntry *   prgSites,
                    ULONG                           cSites,
                    const ULONG *                   prgIpAddrs,
                    ULONG                           cIpAddrs);

   HRESULT ComputeIDCAddresses(
                    BOOL                            fThisLocalServer,
                    const IPSITE_SiteArrayEntry *   prgSites,
                    ULONG                           cSites,
                    const ULONG *                   prgIpAddrs,
                    ULONG                           cIpAddrs);


    //
    // the following are set by ComputeBestSite
    //
    GUID m_guidBestSite;
    BOOL m_fSitegateOnRouteToBestSite;
    BOOL m_fComputedBestSite;

    AP<GUID> m_rgguidSites;
    ULONG    m_cSites;

    //
    //  the following are set by CoputeAddresses
    //
    AP<XLATQM_ADDR_SITE> m_rgAddrs;
    ULONG m_cAddrs;
    BOOL m_fComputedAddresses;
    BOOL m_fMachineIsSitegate;
    BOOL m_fForeignMachine;

    //
    // the following are set by ComputeCNs
    //
    AP<GUID> m_rgCNs;
    BOOL m_fComputedCNs;
};


inline const GUID * CMsmqQmXlateInfo::BestSite()
{
    return &m_guidBestSite;
}


inline const XLATQM_ADDR_SITE * CMsmqQmXlateInfo::Addrs()
{
    return (m_rgAddrs);
}


inline ULONG CMsmqQmXlateInfo::CountAddrs()
{
    return m_cAddrs;
}


inline const GUID * CMsmqQmXlateInfo::CNs()
{
    return (m_rgCNs);
}


CMsmqQmXlateInfo::CMsmqQmXlateInfo(LPCWSTR          pwszObjectDN,
                                   const GUID*      pguidObjectGuid,
                                   CDSRequestContext * pRequestContext)
/*++

Routine Description:
    Class consructor. constructs base object, and initilaizes class

Arguments:
    pwszObjectDN    - DN of object in DS
    pguidObjectGuid - GUID of object in DS

Return Value:
    None

--*/
 : CMsmqObjXlateInfo(pwszObjectDN, pguidObjectGuid, pRequestContext)
{
    m_fComputedBestSite = FALSE;
    m_fComputedAddresses = FALSE;
    m_fComputedCNs = FALSE;
	
	m_cSites = 0;
}


CMsmqQmXlateInfo::~CMsmqQmXlateInfo()
/*++

Routine Description:
    Class destructor

Arguments:
    None

Return Value:
    None

--*/
{
    //
    // members are auto delete classes
    //
}


HRESULT CMsmqQmXlateInfo::GetDSSites(OUT ULONG *pcSites,
                                     OUT GUID  ** prgguidSites)
/*++

Routine Description:
    Returns the sites of the QM as written in the DS

Arguments:
    pcSites       - returned number of sites in returned array
    prgguidSites - returned array of site guids

Return Value:
    HRESULT

--*/
{
    HRESULT hr;

    //
    // get the sites stored in the DS for the computer
    //
    CMQVariant propvarResult;
    PROPVARIANT * ppropvar = propvarResult.CastToStruct();
    hr = GetDsProp(MQ_QM_SITES_ATTRIBUTE,
                   ADSTYPE_OCTET_STRING,
                   VT_VECTOR|VT_CLSID,
                   TRUE /*fMultiValued*/,
                   ppropvar);
    if (FAILED(hr) && (hr != E_ADS_PROPERTY_NOT_FOUND))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("CMsmqQmXlateInfo::GetDSSites:GetDsProp(%ls)=%lx"), MQ_QM_SITES_ATTRIBUTE, hr));
        return LogHR(hr, s_FN, 40);
    }

    //
    // if property is not there, we return 0 sites
    //
    if (hr == E_ADS_PROPERTY_NOT_FOUND)
    {
        *pcSites = 0;
        *prgguidSites = NULL;
        return MQ_OK;
    }

    //
    // we know we got something, it should be array of guids
    //
    ASSERT(ppropvar->vt == (VT_VECTOR|VT_CLSID));

    //
    // return values
    //
    *pcSites = ppropvar->cauuid.cElems;
    *prgguidSites = ppropvar->cauuid.pElems;
    ppropvar->vt = VT_EMPTY; // don't auto free the variant
    return MQ_OK;
}


HRESULT CMsmqQmXlateInfo::ComputeBestSite()
/*++

Routine Description:
    Computes the best site to return for the machine, and saves it in the class.
    If the best site is already computed, it returns immediately.

    Algorithm:
      if there is a site computed return it;

      read sites from DS.
      if sites == 0       ASSERT real error, not likely to happen.
      else if sites == 1  find if there is sitegate in route to him & save it.
      else
      {
          get best site using dikstra algorithm (also if sitegate is on route) and save it

          if none of them is in the map, we may need to refresh, check again, then if none again,
          it means the site that the QM claims to be in was deleted between QM startup & the checking,
          because it doesn not appear in the sites container.

          if so, we need to event, error     debug-info
      }

Arguments:
    none

Return Value:
    HRESULT

--*/
{
    HRESULT hr;

    //
    // return if already computed
    //
    if (m_fComputedBestSite)
    {
        return MQ_OK;
    }

    //
    // Get DS sites from DS
    //
    
    
    hr = GetDSSites(&m_cSites, &m_rgguidSites);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("CMsmqQmXlateInfo::ComputeBestSite:GetDSSites()=%lx"), hr));
        return LogHR(hr, s_FN, 50);
    }

    //
    // check the returned array
    //
    if (m_cSites == 0)
    {
        //
        // there should be site(s) for the QM, it is an error otherwise
        //
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("CMsmqQmXlateInfo::ComputeBestSite:no sites in DS")));
        ASSERT(0);
        // BUGBUG: raise event
        return LogHR(MQ_ERROR, s_FN, 60);
    }

    if (m_cSites == 1)
    {
        //
        // find if there is a sitegate to it
        //
        hr = g_pSiteRoutingTable->CheckIfSitegateOnRouteToSite(&m_rgguidSites[0], &m_fSitegateOnRouteToBestSite);
        if (FAILED(hr) && (hr != MQDS_UNKNOWN_SITE_ID))
        {
            DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("CMsmqQmXlateInfo::ComputeBestSite:g_pSiteRoutingTable->CheckIfSitegateOnRouteToSite()=%lx"), hr));
            return LogHR(hr, s_FN, 70);
        }
        else if (hr == MQDS_UNKNOWN_SITE_ID)
        {
            //
            //  The site written in the msmq-configuration is not linked
            //  to the other sites ( or at least replication about the site-link
            //  was propogated yet to this server).
            //
            //  In this case we will return the site written in the msmq-configuration
            //
            //  Since we want the requested computer's CN to be the same as the site
            //  we set m_fSitegateOnRouteToBestSite
            //
            m_fSitegateOnRouteToBestSite = TRUE;
            DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("CMsmqQmXlateInfo::ComputeBestSite:site not found in the routing table")));
            // BUGBUG: raise event
        }

        //
        // save best site for later use
        //
        m_guidBestSite = m_rgguidSites[0];
    }
    else
    {
        //
        // multiple sites for QM. Find the best site to return. It is the one
        // with the least cost routing from our site.
        //
        hr = g_pSiteRoutingTable->FindBestSiteFromHere(m_cSites, m_rgguidSites, &m_guidBestSite, &m_fSitegateOnRouteToBestSite);
        if (FAILED(hr) && (hr != MQDS_UNKNOWN_SITE_ID))
        {
            DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("CMsmqQmXlateInfo::ComputeBestSite:g_pSiteRoutingTable->FindBestSiteFromHere()=%lx"), hr));
            return LogHR(hr, s_FN, 80);
        }
        else if (hr == MQDS_UNKNOWN_SITE_ID)
        {
            //
            //  The sites written in the msmq-configuration are not linked
            //  to the other sites ( or at least replication about the site-link
            //  was propogated yet to this server).
            //
            //  In this case we will return the first site written in the
            //  msmq-configuration
            //
            m_guidBestSite = m_rgguidSites[0];
            //
            //  Since we want the requested computer's CN to be the same as the site
            //  we set m_fSitegateOnRouteToBestSite
            //
            m_fSitegateOnRouteToBestSite = TRUE;

            DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("CMsmqQmXlateInfo::ComputeBestSite:no site was found in the routing table")));
            // BUGBUG: raise event
        }
    }

    //
    // m_guidBestSite & m_fSitegateOnRouteToBestSite are now set to the correct values
    //
    m_fComputedBestSite = TRUE;
    return MQ_OK;
}


HRESULT CMsmqQmXlateInfo::ComputeSiteGateAddresses(
                    const IPSITE_SiteArrayEntry *   prgSites,
                    ULONG                           cSites,
                    const ULONG *                   prgIpAddrs,
                    ULONG                           cIpAddrs)
/*
Routine Description:
    Computes the addresses to return for site-gate, and saves them in the class.

    Algorithm:

    1. save all IP addresses of the sitegates
    2. If there are no saved addresses, save a dummy IP address as the site-gate's IP Address

Arguments:
    none

Return Value:
    HRESULT
*/
{
    ULONG cNextAddressToFill = 0;

	ASSERT( m_rgguidSites != NULL);
    //
    //  Compute the IP addresses of the site-gate
    //
    if (cSites == 0)   // no ip addresses were associated with sites ( subnets resolution)
    {
        //
        // there are no IP addresses associated with sites for this computer.
        //
        //  For FRS we cannot save "unknown IP address" ( since the QM
        //  doesn't handle it).
        //
        //  Therefore, if we have IP addresses for the computer, we will return all of them
        //  with the machine's site. Otherwise (we couldn't find IP addresses at all for the
        //  computer) the best we can do is still return unknown address.
        //
        if (cIpAddrs > 0)
        {

            m_rgAddrs = new XLATQM_ADDR_SITE[m_cSites];
            for (ULONG ulTmp = 0; ulTmp < m_cSites; ulTmp++)
            {
                //
                //  Did we resolve ip address of this site?
                //
                //  Note the first ip address ( random) is returned
                //
                if (m_guidBestSite == m_rgguidSites[ulTmp])
                {
                    m_rgAddrs[ulTmp].usAddressType = IP_ADDRESS_TYPE;
                    m_rgAddrs[ulTmp].AddressLength = sizeof(ULONG);
                    memcpy(&m_rgAddrs[ulTmp].Address, &prgIpAddrs[0], sizeof(ULONG));
                    m_rgAddrs[ulTmp].guidSite = m_guidBestSite;
                }
                else
                {
                    //
                    //  BUGBUG - to verify that every site that we
                    //  didn't resolve its address, is indeed a foreign site
                    //
                    m_rgAddrs[ulTmp].usAddressType = FOREIGN_ADDRESS_TYPE;
                    m_rgAddrs[ulTmp].AddressLength = sizeof(GUID);
                    memcpy(&m_rgAddrs[ulTmp].Address, &m_rgguidSites[ulTmp], sizeof(GUID));
                    m_rgAddrs[ulTmp].guidSite = m_rgguidSites[ulTmp];
                }
            }
            cNextAddressToFill = m_cSites;
        }
        else // ip addresses were associated with sites ( subnets resolution)
        {
            //
            // no IP addresses for the computer at all
            // save dummy IP address with machine's site.
            //
            m_rgAddrs = new XLATQM_ADDR_SITE[1];
            m_rgAddrs[0].usAddressType = IP_ADDRESS_TYPE;
            m_rgAddrs[0].AddressLength = sizeof(ULONG);
            memset(&m_rgAddrs[0].Address, 0 , sizeof(ULONG)); //IPADDRS_UNKNOWN
            m_rgAddrs[0].guidSite = m_guidBestSite;
            cNextAddressToFill = 1;
        }
    }
    else
    {
        //
        // return all the site-gate  addresses including foreign ones
        //

        ASSERT(m_rgguidSites != NULL);
        DWORD cAddresses = m_cSites + cSites;

        m_rgAddrs = new XLATQM_ADDR_SITE[cAddresses];
        for (ULONG ulTmp = 0; ulTmp < cSites; ulTmp++)
        {
            m_rgAddrs[ulTmp].usAddressType = IP_ADDRESS_TYPE;
            m_rgAddrs[ulTmp].AddressLength = sizeof(ULONG);
            memcpy(&m_rgAddrs[ulTmp].Address, &prgSites[ulTmp].ulIpAddress, sizeof(ULONG));
            m_rgAddrs[ulTmp].guidSite = prgSites[ulTmp].guidSite;
        }
        cNextAddressToFill = cSites;
        //
        //  add the foreign sites
        //
        for ( ulTmp = 0; ulTmp < m_cSites; ulTmp++)
        {
			//
			// make sure not to over fill the array
			//
            if ( cNextAddressToFill ==  cAddresses)
            {
                break;
            }

            if (g_mapForeignSites.IsForeignSite(&m_rgguidSites[ ulTmp]) )
            {
                m_rgAddrs[ cNextAddressToFill].usAddressType = FOREIGN_ADDRESS_TYPE;
                m_rgAddrs[ cNextAddressToFill].AddressLength = sizeof(GUID);
                memcpy( &m_rgAddrs[ cNextAddressToFill].Address, &m_rgguidSites[ ulTmp], sizeof(GUID));
                m_rgAddrs[ cNextAddressToFill].guidSite = m_rgguidSites[ ulTmp];
                cNextAddressToFill++;
            }
        }
    }

    m_cAddrs = cNextAddressToFill;
    return MQ_OK;
}


HRESULT CMsmqQmXlateInfo::ComputeRoutingServerAddresses(
                const IPSITE_SiteArrayEntry *   prgSites,
                ULONG                           cSites,
                const ULONG *                   prgIpAddrs,
                ULONG                           cIpAddrs)
/*
Routine Description:
    Computes the addresses to return for routing server, and saves them in the class.

    Algorithm:

    1. save all IP addresses of the routing server
    2. If there are no saved addresses, save a dummy IP address as the routing-server's IP Address

Arguments:
    none

Return Value:
    HRESULT
*/
{
    ULONG cNextAddressToFill;
    //
    //  Compute the IP addresses and then
    //
    if (cSites == 0) // no ip addresses were associated with sites ( subnets resolution)
    {
        //
        // there sre no IP addresses with sites found for this computer.
        //
        // The best solution would be to
        // save IP address unknown address with machine's site.
        //  But we cannot use it, since the QM doesn't handle
        //  a IP address unknown address for FRSs.
        //
        //  Therefore, if we have IP addresses for the computer, we will return all of them
        //  with the machine's site. Otherwise (we couldn't find IP addresses at all for the
        //  computer) the best we can do is still return unknown address.
        //
        if (cIpAddrs > 0)
        {
                m_rgAddrs = new XLATQM_ADDR_SITE[cIpAddrs];
                for ( DWORD i = 0; i < cIpAddrs; i++)
                {
                    m_rgAddrs[i].usAddressType = IP_ADDRESS_TYPE;
                    m_rgAddrs[i].AddressLength = sizeof(ULONG);
                    memcpy(&m_rgAddrs[i].Address, &prgIpAddrs[i], sizeof(ULONG));
                    m_rgAddrs[i].guidSite = m_guidBestSite;
                }
                cNextAddressToFill = cIpAddrs;
        }
        else
        {
            //
            // no IP addresses for the computer at all
            // save dummy IP address with machine's site.
            //
            m_rgAddrs = new XLATQM_ADDR_SITE[1];
            m_rgAddrs[0].usAddressType = IP_ADDRESS_TYPE;
            m_rgAddrs[0].AddressLength = sizeof(ULONG);
            memset(&m_rgAddrs[0].Address, 0, sizeof(ULONG)); //IPADDRS_UNKNOWN
            m_rgAddrs[0].guidSite = m_guidBestSite;
            cNextAddressToFill = 1;

            //
            //  inform the user, that there are RS with unknown addresses
            //
            if ( ObjectDN() != NULL)
            {
                DBGMSG((DBGMOD_ADS, DBGLVL_WARNING,
                    TEXT("Unable to resolve IP addresses of RS : %ls"), ObjectDN()));
            }
            else
            {
                DBGMSG((DBGMOD_ADS, DBGLVL_WARNING,
                    TEXT("Unable to resolve IP addresses of RS : GUID=%!guid!"), ObjectGuid()));
            }
            static BOOL fInformOnceAboutRsWithoutAddresses = FALSE;

            if ( !fInformOnceAboutRsWithoutAddresses)
            {
                REPORT_CATEGORY(RS_WITHOUT_ADDRESSES, CATEGORY_MQDS);
                fInformOnceAboutRsWithoutAddresses = TRUE;
            }

        }
    }
    else // ip addresses were associated with sites ( subnets resolution)
    {
        //
        // computer has at least one IP address
        // return all IP addresses of routing server
        //
        m_rgAddrs = new XLATQM_ADDR_SITE[cSites];
        for (DWORD ulTmp = 0; ulTmp < cSites; ulTmp++)
        {
            m_rgAddrs[ulTmp].usAddressType = IP_ADDRESS_TYPE;
            m_rgAddrs[ulTmp].AddressLength = sizeof(ULONG);
            memcpy(&m_rgAddrs[ulTmp].Address, &prgSites[ulTmp].ulIpAddress, sizeof(ULONG));
            m_rgAddrs[ulTmp].guidSite = prgSites[ulTmp].guidSite;
        }
        cNextAddressToFill = cSites;

    }

    m_cAddrs = cNextAddressToFill;
    return(MQ_OK);

}

HRESULT CMsmqQmXlateInfo::ComputeIDCAddresses(
                    BOOL                            fThisLocalServer,
                    const IPSITE_SiteArrayEntry *   prgSites,
                    ULONG                           cSites,
                    const ULONG *                   prgIpAddrs,
                    ULONG                           cIpAddrs)
/*
Routine Description:
    Computes the addresses to return for an IDC, and saves them in the class.

    Algorithm:


Arguments:
    none

Return Value:
    HRESULT
*/
{
    ULONG cNextAddressToFill = 0;
    //
    // save addresses to return
    //
    if (cSites == 0)
    {
        //
        // there are no IP addresses with sites found for this computer.
        //
        if ((cIpAddrs > 0) &&
            ( fThisLocalServer))
        {
            //
            //  Return all the IP address of the computer as belonging
            //  to the best site.
            //
            //  One reason for doing this: is to return a correct address of
            //  this DC which is not a routing server ( required for client address
            //  recognition)
            //
            m_rgAddrs = new XLATQM_ADDR_SITE[ cIpAddrs ];
            for ( DWORD i = 0; i < cIpAddrs; i++)
            {
                m_rgAddrs[i].usAddressType = IP_ADDRESS_TYPE;
                m_rgAddrs[i].AddressLength = sizeof(ULONG);
                memcpy(&m_rgAddrs[i].Address, &prgIpAddrs[i], sizeof(ULONG));
                m_rgAddrs[i].guidSite = m_guidBestSite;
            }
            cNextAddressToFill = cIpAddrs;
        }
        else if (cIpAddrs > 0)
        {
            //
            //  The best solution would be to
            //  save IP address unknown address with machine's site.
            //

            m_rgAddrs = new XLATQM_ADDR_SITE[1];
            m_rgAddrs[0].usAddressType = IP_ADDRESS_TYPE;
            m_rgAddrs[0].AddressLength = sizeof(ULONG);
            memset(&m_rgAddrs[0].Address, 0, sizeof(ULONG)); //IPADDRS_UNKNOWN
            m_rgAddrs[0].guidSite = m_guidBestSite;
            cNextAddressToFill = 1;
        }
        else
        {
            ASSERT( !fThisLocalServer);
        }
    }
    else
    {
        //
        // computer has at least one address
        //
        // return addresses only for the computed site
        //
        //
        // save the indexes of the IP Addresses in the computed site
        //
        ULONG cMatchedIPAddrs = 0;
        AP<ULONG> rgulMatchedIPAddrs = new ULONG[cSites];
        for (ULONG ulTmp = 0; ulTmp < cSites; ulTmp++)
        {
            if (prgSites[ulTmp].guidSite == m_guidBestSite)
            {
                rgulMatchedIPAddrs[cMatchedIPAddrs] = ulTmp;
                cMatchedIPAddrs++;
            }
        }

        //
        // save the IP Addresses in the computed site
        //
        if (cMatchedIPAddrs == 0)
        {
            //
            // there are no IP addresses for the site that was computed for this machine.
            // save dummy IP address with machine's site.
            //
            m_rgAddrs = new XLATQM_ADDR_SITE[1];
            m_rgAddrs[0].usAddressType = IP_ADDRESS_TYPE;
            m_rgAddrs[0].AddressLength = sizeof(ULONG);
            memset(&m_rgAddrs[0].Address, 0, sizeof(ULONG)); //IPADDRS_UNKNOWN
            m_rgAddrs[0].guidSite = m_guidBestSite;
            cNextAddressToFill = 1;
        }
        else
        {
            //
            // there is at least one IP address for the computed site.
            // save them
            //
            m_rgAddrs = new XLATQM_ADDR_SITE[cMatchedIPAddrs];
            for (ulTmp = 0; ulTmp < cMatchedIPAddrs; ulTmp++, cNextAddressToFill++)
            {
                m_rgAddrs[cNextAddressToFill].usAddressType = IP_ADDRESS_TYPE;
                m_rgAddrs[cNextAddressToFill].AddressLength = sizeof(ULONG);
                memcpy(&m_rgAddrs[cNextAddressToFill].Address, &prgSites[rgulMatchedIPAddrs[ulTmp]].ulIpAddress, sizeof(ULONG));
                m_rgAddrs[cNextAddressToFill].guidSite = prgSites[rgulMatchedIPAddrs[ulTmp]].guidSite;
            }
        }

    }

    //
    //  Only if the machine doesn't have IP addresses, Assume an unknown IP address
    //
    if ( cNextAddressToFill == 0)
    {
        //
        //  Assume an unknown IP address
        //
        m_rgAddrs = new XLATQM_ADDR_SITE[1];
        m_rgAddrs[0].usAddressType = IP_ADDRESS_TYPE;
        m_rgAddrs[0].AddressLength = sizeof(ULONG);
        memset(&m_rgAddrs[0].Address, 0, sizeof(ULONG)); //IPADDRS_UNKNOWN
        m_rgAddrs[0].guidSite = m_guidBestSite;
        cNextAddressToFill = 1;
    }

    m_cAddrs = cNextAddressToFill;

    return MQ_OK;
}



HRESULT CMsmqQmXlateInfo::FetchMachineParameters(
                OUT BOOL *      pfForeignMachine,
                OUT BOOL *      pfRoutingServer,
                OUT LPWSTR *    ppwszMachineName,
                OUT LPWSTR *    ppwszMachineDnsName)
/*
*/
{
    //
    // get machine name from object
    //
    HRESULT hr;
    hr = GetMachineNameAndDnsFromQMObject(ObjectDN(),
                                          ppwszMachineName,
                                          ppwszMachineDnsName);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("CMsmqQmXlateInfo::FetchMachineParameters()=%lx"), hr));
        return LogHR(hr, s_FN, 100);
    }

    //
    //  Is it a foreign machine
    //
    MQPROPVARIANT varForeign;
    varForeign.vt = VT_UI1;

    hr = GetDsProp(MQ_QM_FOREIGN_ATTRIBUTE,
                   MQ_QM_FOREIGN_ADSTYPE,
                   VT_UI1,
                   FALSE /*fMultiValued*/,
                   &varForeign);
    if ( hr ==  E_ADS_PROPERTY_NOT_FOUND)
    {
        varForeign.bVal = DEFAULT_QM_FOREIGN;
        hr = MQ_OK;
    }
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("CMsmqQmXlateInfo::FetchMachineParameters(%ls)=%lx"), MQ_QM_FOREIGN_ATTRIBUTE, hr));
        return LogHR(hr, s_FN, 110);
    }
    *pfForeignMachine = varForeign.bVal;
    //
    //  Is it a routing server machine
    //
    MQPROPVARIANT varRoutingServer;
    varRoutingServer.vt = VT_UI1;

    hr = GetDsProp(MQ_QM_SERVICE_ROUTING_ATTRIBUTE,     // [adsrv] MQ_QM_SERVICE_ATTRIBUTE
                   MQ_QM_SERVICE_ROUTING_ADSTYPE,       // [adsrv] MQ_QM_SERVICE_ADSTYPE
                   VT_UI1,
                   FALSE /*fMultiValued*/,
                   &varRoutingServer);
    if ( hr ==  E_ADS_PROPERTY_NOT_FOUND)
    {
        varRoutingServer.bVal = DEFAULT_N_SERVICE;
        hr = MQ_OK;
    }
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("CMsmqQmXlateInfo::FetchMachineParameters(%ls)=%lx"), MQ_QM_SERVICE_ATTRIBUTE, hr));
        return LogHR(hr, s_FN, 90);
    }
    *pfRoutingServer = varRoutingServer.bVal;    // [adsrv] ulVal >= SERVICE_SRV;
    return(MQ_OK);
}


HRESULT CMsmqQmXlateInfo::ComputeAddresses()
/*++

Routine Description:
    Computes the Addresses to return for the machine, and saves them in the class.
    If the  Addresses are already computed, it returns immediately.

    Algorithm:
    if there are addresses computed already return them

    compute best site (if not already computed)

    Get a list of (IPaddress, site) for the machine

    if (machine is a sitegate) save all addresses
    if (machine is not a sitegate) save only addresses that are in the computed site

    if number of saved addresses == 0 save dummy IP address as the machine's IP Address

    BUGBUG: if for sitegate it is not harmful to return all ipaddresses (even if not on the returned site)
            maybe it is OK to do so for a regular machine as well.

Arguments:
    none

Return Value:
    HRESULT

--*/
{
    HRESULT hr;

    //
    // return if already computed
    //
    if (m_fComputedAddresses)
    {
        return MQ_OK;
    }
    //
    // compute best site (if not already computed)
    //
    hr = ComputeBestSite();
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("CMsmqQmXlateInfo::ComputeAddresses:ComputeBestSite()=%lx"), hr));
        return LogHR(hr, s_FN, 1711);
    }

    //
    //  Fetch computer parameters
    //
    BOOL    fRoutingServer;
    AP<WCHAR> pwszMachineName;
    AP<WCHAR> pwszMachineDnsName;
    hr = FetchMachineParameters(
                &m_fForeignMachine,
                &fRoutingServer,
                &pwszMachineName,
                &pwszMachineDnsName
				);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("CMsmqQmXlateInfo::ComputeAddresses:FetchMachineParameters()=%lx"), hr));
        return LogHR(hr, s_FN, 1712);
    }

    //
    // check if machine is sitegate
    //
    m_fMachineIsSitegate = g_pMySiteInformation->CheckMachineIsSitegate(ObjectGuid());



    if ( m_fForeignMachine != MSMQ_MACHINE)
    {
        //
        //  It is a foreign machine
        //
        m_rgAddrs = new XLATQM_ADDR_SITE[m_cSites];
        for ( ULONG i = 0; i < m_cSites; i++)
        {
            m_rgAddrs[i].usAddressType = FOREIGN_ADDRESS_TYPE;
            m_rgAddrs[i].AddressLength = FOREIGN_ADDRESS_LEN;
            *reinterpret_cast<GUID *>(&m_rgAddrs[i].Address) = m_rgguidSites[i];
            m_rgAddrs[i].guidSite = m_rgguidSites[i];
        }
        m_cAddrs = m_cSites;
        m_fComputedAddresses = TRUE;
        return MQ_OK;

    }

    //
    // get list of IP Addresses per site of this machine
    //
    AP<IPSITE_SiteArrayEntry> rgSites;
    ULONG cSites;
    AP<ULONG>  rgIpAddrs;
    ULONG cIpAddrs;
    hr = g_pcIpSite->FindSitesByComputerName(
							pwszMachineName,
							pwszMachineDnsName,
							&rgSites,
							&cSites,
							&rgIpAddrs,
							&cIpAddrs
							);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("CMsmqQmXlateInfo::ComputeAddresses:g_pcIpSite->FindSitesByComputerName()=%lx"), hr));
        return LogHR(hr, s_FN, 1649);
    }

    if (m_fMachineIsSitegate)
    {
        //
        //  Prepare sitegate addresses
        //
        hr = ComputeSiteGateAddresses(
                    rgSites,
                    cSites,
                    rgIpAddrs,
                    cIpAddrs
					);


    }
    else if (fRoutingServer)
    {
        hr = ComputeRoutingServerAddresses(
                    rgSites,
                    cSites,
                    rgIpAddrs,
                    cIpAddrs
					);

    }
    else
    {
        BOOL fThisLocalServer = FALSE;
        //
        //  Special case if the address calculated belongs to the local server
        //
        if (_wcsicmp( g_pwcsServerName, pwszMachineName) == 0)
        {
            fThisLocalServer = TRUE;
        }

        hr = ComputeIDCAddresses(
                    fThisLocalServer,
                    rgSites,
                    cSites,
                    rgIpAddrs,
                    cIpAddrs
					);
    }


    //
    // m_rgAddrs, m_cAddrs & m_fMachineIsSitegate are now set to the correct values
    //
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("CMsmqQmXlateInfo::ComputeAddresses failed=%lx"), hr));
        return LogHR(hr, s_FN, 1653);
    }
    m_fComputedAddresses = TRUE;
    return MQ_OK;

}



HRESULT CMsmqQmXlateInfo::ComputeCNs()
/*++

Routine Description:
    Computes the CN's to return for the machine, and saves them in the class.
    If the CN's are already computed, it returns immediately.

    Algorithm:
    if there are CN's computed already return immediately

    compute IP addresses to return (if not already computed) - this computes the best site as well

    if machine is a sitegate the saved CN's are the sites from the saved (ipAddress, site) list, all of them,
        w/o checking of sitegates on route to them

    if machine is not a sitegate:
       if there is a sitegate to the best site - the saved CN's are duplicates(the number of IP addresses returned) of the best site
       if there is no sitegate to the best site - the saved CN's are duplicates(the number of IP addresses returned) of the DS site

Arguments:
    none

Return Value:
    HRESULT

--*/
{
    HRESULT hr;

    //
    // return if already computed
    //
    if (m_fComputedCNs)
    {
        return MQ_OK;
    }

    //
    // compute Addresses (if not already computed)
    //
    hr = ComputeAddresses();
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("CMsmqQmXlateInfo::ComputeCNs:ComputeIPAddresses()=%lx"), hr));
        return LogHR(hr, s_FN, 1654);
    }

    //
    // if machine is a sitegate, CN == site for each of its IP Addresses
    // note that for a sitegate we save all of its addresses, not only those that are
    // in its computed site.
    //
    if (m_fMachineIsSitegate)
    {
        //
        // Fill the CN's array
        // It is a must that the number of the CN's we return is the number of the
        // returned IP addresses
        //
        m_rgCNs = new GUID[m_cAddrs];
        for (ULONG ulTmp = 0; ulTmp < m_cAddrs; ulTmp++)
        {
            m_rgCNs[ulTmp] = m_rgAddrs[ulTmp].guidSite;
        }
    }
    else
    { 
        GUID guidReturnedCN;
        if ( m_fForeignMachine == FOREIGN_MACHINE)
        {
            //
            //  For a foreign computer:
            // All the addresses refer anyway to the same site, so we take the first of
            // the saved list
            //
            guidReturnedCN = m_rgAddrs[0].guidSite;
        }
        else
        {
            guidReturnedCN = *(g_pMySiteInformation->GetSiteId());
        }

        //
        // Fill the CN's array
        // It is a must that the number of the CN's we return is the number of the
        // returned IP addresses
        //
        m_rgCNs = new GUID[m_cAddrs];
        for (ULONG ulTmp = 0; ulTmp < m_cAddrs; ulTmp++)
        {
            m_rgCNs[ulTmp] = guidReturnedCN;
        }
    } 

    //
    // m_rgCNs is now set to the correct values
    //
    m_fComputedCNs = TRUE;
    return MQ_OK;
}


STATIC HRESULT FillQmidsFromQmDNs(IN const PROPVARIANT * pvarQmDNs,
                                  OUT PROPVARIANT * pvarQmids)
/*++

Routine Description:
    Given a propvar of QM DN's, fills a propvar of QM id's
    returns an error if none of the QM DN's could be converted to guids

Arguments:
    pvarQmDNs       - QM distinguished names propvar
    pvarQmids       - returned QM ids propvar

Return Value:
    None

--*/
{

    //
    // sanity check
    //
    if (pvarQmDNs->vt != (VT_LPWSTR|VT_VECTOR))
    {
        ASSERT(0);
        return LogHR(MQ_ERROR, s_FN, 1716);
    }

    //
    // return an empty guid list if there is an empty DN list
    //
    if (pvarQmDNs->calpwstr.cElems == 0)
    {
        pvarQmids->vt = VT_CLSID|VT_VECTOR;
        pvarQmids->cauuid.cElems = 0;
        pvarQmids->cauuid.pElems = NULL;
        return MQ_OK;
    }

    //
    // DN list is not empty
    // allocate guids in an auto free propvar
    //
    CMQVariant varTmp;
    PROPVARIANT * pvarTmp = varTmp.CastToStruct();
    pvarTmp->cauuid.pElems = new GUID [pvarQmDNs->calpwstr.cElems];
    pvarTmp->cauuid.cElems = pvarQmDNs->calpwstr.cElems;
    pvarTmp->vt = VT_CLSID|VT_VECTOR;

    //
    //  Translate each of the QM DN into unique id
    //
    ASSERT(pvarQmDNs->calpwstr.pElems != NULL);
    PROPID prop = PROPID_QM_MACHINE_ID;
    PROPVARIANT varQMid;
    CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);
    DWORD dwNextToFile = 0;
    for ( DWORD i = 0; i < pvarQmDNs->calpwstr.cElems; i++)
    {
        varQMid.vt = VT_CLSID; // so returned guid will not be allocated
        varQMid.puuid = &pvarTmp->cauuid.pElems[dwNextToFile];

        
        WCHAR * pszDomainName = wcsstr(pvarQmDNs->calpwstr.pElems[i], x_DcPrefix);
        ASSERT(pszDomainName) ;
        HRESULT hr;
        //
        //  try local DC if FRS belongs to the same domain
        //
        if ( !wcscmp( pszDomainName, g_pwcsLocalDsRoot)) 
        {
            hr = g_pDS->GetObjectProperties(
                                eLocalDomainController,
                                &requestDsServerInternal,     // This routine is called from
                                                        // DSADS:LookupNext or DSADS::Get..
                                                        // impersonation, if required,
                                                        // has already been performed.
                                pvarQmDNs->calpwstr.pElems[i],
                                NULL,
                                1,
                                &prop,
                                &varQMid
                                );
        }
        else
        {
            hr = g_pDS->GetObjectProperties(
                                eGlobalCatalog,
                                &requestDsServerInternal,     // This routine is called from
                                                        // DSADS:LookupNext or DSADS::Get..
                                                        // impersonation, if required,
                                                        // has already been performed.
                                pvarQmDNs->calpwstr.pElems[i],
                                NULL,
                                1,
                                &prop,
                                &varQMid
                                );
        }
        if (SUCCEEDED(hr))
        {
            dwNextToFile++;
        }
    }

    if (dwNextToFile == 0)
    {
        //
        //  no FRS in the list is a valid one ( they were
        //  uninstalled probably)
        //
        pvarQmids->vt = VT_CLSID|VT_VECTOR;
        pvarQmids->cauuid.cElems = 0;
        pvarQmids->cauuid.pElems = NULL;
        return MQ_OK;
    }

    //
    // return results
    //
    pvarTmp->cauuid.cElems = dwNextToFile;
    *pvarQmids = *pvarTmp;   // set returned propvar
    pvarTmp->vt = VT_EMPTY;  // detach varTmp
    return MQ_OK;
}


HRESULT CMsmqQmXlateInfo::RetrieveFrss(
           IN  LPCWSTR          pwcsAttributeName,
           OUT MQPROPVARIANT *  ppropvariant
           )
/*++

Routine Description:
    Retrieves IN or OUT FRS property from the DS.
    In the DS we keep the distingushed name of the FRSs. DS client excpects
    to retrieve the unique-id of the FRSs. Therefore for each FRS ( according
    to its DN) we retrieve its unique-id.


Arguments:
    pwcsAttributeName   : attribute name string ( IN or OUT FRSs)
    ppropvariant        : propvariant in which the retrieved values are returned.

Return Value:
    HRESULT

--*/
{
    HRESULT hr;

    ASSERT((ppropvariant->vt == VT_NULL) || (ppropvariant->vt == VT_EMPTY));
    //
    //  Retrieve the DN of the FRSs
    //  into an auto free propvar
    //
    CMQVariant varFrsDn;
    hr = RetrieveFrssFromDs(
                    pwcsAttributeName,
                    varFrsDn.CastToStruct());
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("CMsmqQmXlateInfo::RetrieveFrss:pQMTrans->RetrieveOutFrss()=%lx "),hr));
        return LogHR(hr, s_FN, 1656);
    }

    HRESULT hr2 = FillQmidsFromQmDNs(varFrsDn.CastToStruct(), ppropvariant);
    return LogHR(hr2, s_FN, 1657);
}


HRESULT CMsmqQmXlateInfo::RetrieveFrssFromDs(
           IN  LPCWSTR          pwcsAttributeName,
           OUT MQPROPVARIANT *  pvar
           )
/*++

Routine Description:
    Retrieves the computer's frss.

Arguments:
    pwcsAttributeName   : attribute name string ( IN or OUT FRSs)
    ppropvariant        : propvariant in which the retrieved values are returned.

Return Value:
    HRESULT

--*/
{
    HRESULT hr;

    //
    // get the FRSs stored in the DS for the computer
    //
    hr = GetDsProp(pwcsAttributeName,
                   ADSTYPE_DN_STRING,
                   VT_VECTOR|VT_LPWSTR,
                   TRUE /*fMultiValued*/,
                   pvar);
    if (FAILED(hr) && (hr != E_ADS_PROPERTY_NOT_FOUND))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("CMsmqQmXlateInfo::RetrieveFrssFromDs:GetDsProp(%ls)=%lx"), MQ_QM_OUTFRS_ATTRIBUTE, hr));
        return LogHR(hr, s_FN, 1661);
    }

    //
    // if property is not there, we return 0 frss
    //
    if (hr == E_ADS_PROPERTY_NOT_FOUND)
    {
        pvar->vt = VT_LPWSTR|VT_VECTOR;
        pvar->calpwstr.cElems = 0;
        pvar->calpwstr.pElems = NULL;
        return MQ_OK;
    }

    return( MQ_OK);

}

//----------------------------------------------------------------------
//
// Routine to get a default translation object for MSMQ DS objects
//
//----------------------------------------------------------------------
HRESULT WINAPI GetMsmqQmXlateInfo(
                 IN  LPCWSTR                pwcsObjectDN,
                 IN  const GUID*            pguidObjectGuid,
                 IN  CDSRequestContext *    pRequestContext,
                 OUT CMsmqObjXlateInfo**    ppcMsmqObjXlateInfo)
/*++
    Abstract:
        Routine to get a translate object that will be passed to
        translation routines to all properties of the QM

    Parameters:
        pwcsObjectDN        - DN of the translated object
        pguidObjectGuid     - GUID of the translated object
        ppcMsmqObjXlateInfo - Where the translate object is put

    Returns:
      HRESULT
--*/
{
    *ppcMsmqObjXlateInfo = new CMsmqQmXlateInfo(pwcsObjectDN, pguidObjectGuid, pRequestContext);
    return MQ_OK;
}

//----------------------------------------------------------------------
//
// Translation routines
//
//----------------------------------------------------------------------

HRESULT WINAPI MQADSpRetrieveMachineSite(
                 IN  CMsmqObjXlateInfo * pTrans,
                 OUT PROPVARIANT * ppropvariant)
/*++

Routine Description:
    Translation routine for the Site property of QM 1.0

Arguments:
    pTrans       - translation context, saves state between all properties of this QM
    ppropvariant - returned value of the property. propvariant should be empty already
                   as this function doesn't free it before setting the value

Return Value:
    HRESULT

--*/
{
    HRESULT hr;

    //
    // get derived translation context
    //
    CMsmqQmXlateInfo * pQMTrans = (CMsmqQmXlateInfo *) pTrans;

    //
    // compute best site (if not already computed)
    //
    hr = pQMTrans->ComputeBestSite();
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("MQADSpRetrieveMachineSite:pQMTrans->ComputeBestSite()=%lx for site %ls"), hr, pQMTrans->ObjectDN()));
        return LogHR(hr, s_FN, 1663);
    }

    //
    // set the returned prop variant
    //
    //
    //  This is a special case where we do not necessarily allocate the memory for the guid
    //  in puuid. The caller may already have puuid set to a guid, and this is indicated by the
    //  vt member on the given propvar. It could be VT_CLSID if guid already allocated, otherwise
    //  we allocate it (and vt should be VT_NULL (or VT_EMPTY))
    //
    if (ppropvariant->vt != VT_CLSID)
    {
        ASSERT(((ppropvariant->vt == VT_NULL) || (ppropvariant->vt == VT_EMPTY)));
        ppropvariant->puuid = new GUID;
        ppropvariant->vt = VT_CLSID;
    }
    else if ( ppropvariant->puuid == NULL)
    {
        return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 1717);
    }
    *(ppropvariant->puuid) = *(pQMTrans->BestSite());
    return MQ_OK;
}


HRESULT WINAPI MQADSpRetrieveMachineAddresses(
                 IN  CMsmqObjXlateInfo * pTrans,
                 OUT PROPVARIANT * ppropvariant)
/*++

Routine Description:
    Translation routine for the IP Addresses property of QM 1.0

Arguments:
    pTrans       - translation context, saves state between all properties of this QM
    ppropvariant - returned value of the property

Return Value:
    HRESULT

--*/
{
    HRESULT hr;

    //
    // get derived translation context
    //
    CMsmqQmXlateInfo * pQMTrans = (CMsmqQmXlateInfo *) pTrans;

    //
    // compute IP Addresses (if not already computed)
    //
    hr = pQMTrans->ComputeAddresses();
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("MQADSpRetrieveMachineAddresses:pQMTrans->ComputeIPAddresses()=%lx for site %ls"), hr, pQMTrans->ObjectDN()));
        return LogHR(hr, s_FN, 1664);
    }

    //
    // allocate & fill the returned blob
    //
    ASSERT( FOREIGN_ADDRESS_LEN > IP_ADDRESS_LEN);
    ULONG cbAddresses = 0;
    AP<BYTE> pbAddresses = new BYTE[pQMTrans->CountAddrs() * (TA_ADDRESS_SIZE+FOREIGN_ADDRESS_LEN)];
    TA_ADDRESS * ptaaddr = (TA_ADDRESS *)((LPBYTE)pbAddresses);
    const XLATQM_ADDR_SITE * rgAddrs = pQMTrans->Addrs();
    for (ULONG ulTmp = 0; ulTmp < pQMTrans->CountAddrs(); ulTmp++)
    {
        ptaaddr->AddressType = rgAddrs[ulTmp].usAddressType;
        unsigned short len = rgAddrs[ulTmp].AddressLength;
        ptaaddr->AddressLength = len;
        memcpy(ptaaddr->Address, (LPBYTE)&rgAddrs[ulTmp].Address, len);
        ptaaddr = (TA_ADDRESS *)((LPBYTE)ptaaddr + TA_ADDRESS_SIZE + len);
        cbAddresses += TA_ADDRESS_SIZE + len;

    }

    //
    // set the returned prop variant
    //
    ppropvariant->blob.cbSize = cbAddresses;
    ppropvariant->blob.pBlobData = pbAddresses.detach();
    ppropvariant->vt = VT_BLOB;
    return MQ_OK;
}


HRESULT WINAPI MQADSpRetrieveMachineCNs(
                 IN  CMsmqObjXlateInfo * pTrans,
                 OUT PROPVARIANT * ppropvariant)
/*++

Routine Description:
    Translation routine for the CN property of QM 1.0

Arguments:
    pTrans       - translation context, saves state between all properties of this QM
    ppropvariant - returned value of the property

Return Value:
    HRESULT

--*/
{
    HRESULT hr;

    //
    // get derived translation context
    //
    CMsmqQmXlateInfo * pQMTrans = (CMsmqQmXlateInfo *) pTrans;

    //
    // compute CN's (if not already computed)
    //
    hr = pQMTrans->ComputeCNs();
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("MQADSpRetrieveMachine:pQMTrans->ComputeCNs()=%lx for site %ls"), hr, pQMTrans->ObjectDN()));
        return LogHR(hr, s_FN, 1666);
    }

    //
    // allocate & fill the returned blob
    //
    AP<GUID> pElems = new GUID[pQMTrans->CountAddrs()];
    memcpy(pElems, pQMTrans->CNs(), sizeof(GUID) * pQMTrans->CountAddrs());

    //
    // set the returned prop variant
    //
    ppropvariant->cauuid.cElems = pQMTrans->CountAddrs();
    ppropvariant->cauuid.pElems = pElems.detach();
    ppropvariant->vt = VT_CLSID | VT_VECTOR;
    return S_OK;
}


/*====================================================

MQADSpRetrieveMachineName

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADSpRetrieveMachineName(
                 IN  CMsmqObjXlateInfo * pTrans,
                 OUT PROPVARIANT * ppropvariant)
{
    //
    // get the machine name
    //
    AP<WCHAR> pwszMachineName;
    HRESULT hr = GetMachineNameFromQMObject(pTrans->ObjectDN(), &pwszMachineName);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("MQADSpRetrieveMachineName:GetMachineNameFromQMObject()=%lx"), hr));
        return LogHR(hr, s_FN, 1667);
    }

    CharLower(pwszMachineName);

    //
    // set the returned prop variant
    //
    ppropvariant->pwszVal = pwszMachineName.detach();
    ppropvariant->vt = VT_LPWSTR;
    return(MQ_OK);
}

/*====================================================

MQADSpRetrieveMachineDNSName

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADSpRetrieveMachineDNSName(
                 IN  CMsmqObjXlateInfo * pTrans,
                 OUT PROPVARIANT * ppropvariant)
{
    //
    // read dNSHostName of the computer object
    //
    WCHAR * pwcsComputerName = wcschr(pTrans->ObjectDN(), L',') + 1;
    WCHAR * pwcsDnsName; 
    HRESULT hr = MQADSpGetComputerDns(
                pwcsComputerName,
                &pwcsDnsName
                );
    if ( hr == HRESULT_FROM_WIN32(E_ADS_PROPERTY_NOT_FOUND))
    {
        //
        //    The dNSHostName attribute doesn't have value
        //
        ppropvariant->vt = VT_EMPTY;
        return MQ_OK;
    }
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 1718);
    }

    CharLower(pwcsDnsName);

    //
    // set the returned prop variant
    //
    ppropvariant->pwszVal = pwcsDnsName;
    ppropvariant->vt = VT_LPWSTR;
    return(MQ_OK);
}

/*====================================================

MQADSpRetrieveMachineMasterId

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADSpRetrieveMachineMasterId(
                 IN  CMsmqObjXlateInfo * pTrans,
                 OUT PROPVARIANT * ppropvariant)
{
    //
    //  BUGBUG - for the time being, returns the site
    //
    HRESULT hr2 = MQADSpRetrieveMachineSite(pTrans, ppropvariant);
    return LogHR(hr2, s_FN, 1719);
}

/*====================================================

MQADSpRetrieveMachineOutFrs

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADSpRetrieveMachineOutFrs(
                 IN  CMsmqObjXlateInfo * pTrans,
                 OUT PROPVARIANT * ppropvariant)
{
    HRESULT hr;

    //
    // get derived translation context
    //
    CMsmqQmXlateInfo * pQMTrans = (CMsmqQmXlateInfo *) pTrans;

    hr = pQMTrans->RetrieveFrss( MQ_QM_OUTFRS_ATTRIBUTE,
                               ppropvariant);
    return LogHR(hr, s_FN, 1721);

}

/*====================================================

MQADSpRetrieveMachineInFrs

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADSpRetrieveMachineInFrs(
                 IN  CMsmqObjXlateInfo * pTrans,
                 OUT PROPVARIANT * ppropvariant)
{
    HRESULT hr;

    //
    // get derived translation context
    //
    CMsmqQmXlateInfo * pQMTrans = (CMsmqQmXlateInfo *) pTrans;

    hr = pQMTrans->RetrieveFrss( MQ_QM_INFRS_ATTRIBUTE,
                               ppropvariant);
    return LogHR(hr, s_FN, 1722);
}

/*====================================================

MQADSpRetrieveQMService

Arguments:

Return Value:
                  [adsrv]
=====================================================*/
HRESULT WINAPI MQADSpRetrieveQMService(
                 IN  CMsmqObjXlateInfo * pTrans,
                 OUT PROPVARIANT * ppropvariant)
{
    HRESULT hr;

    //
    // get derived translation context
    //
    CMsmqQmXlateInfo * pQMTrans = (CMsmqQmXlateInfo *) pTrans;

    //
    // get the QM service type bits
    //
    MQPROPVARIANT varRoutingServer, varDsServer;  //, varDepClServer;
    varRoutingServer.vt = VT_UI1;
    varDsServer.vt      = VT_UI1;

    hr = pQMTrans->GetDsProp(MQ_QM_SERVICE_ROUTING_ATTRIBUTE,
                   MQ_QM_SERVICE_ROUTING_ADSTYPE,
                   VT_UI1,
                   FALSE,
                   &varRoutingServer);
    if (FAILED(hr))
    {
        if (hr == E_ADS_PROPERTY_NOT_FOUND)
        {
            //
            //  This can happen if some of the computers were installed
            //  with Beta2 DS servers
            //
            //  In this case, we return the old-service as is.
            //
            hr = pQMTrans->GetDsProp(MQ_QM_SERVICE_ATTRIBUTE,
                           MQ_QM_SERVICE_ADSTYPE,
                           VT_UI4,
                           FALSE,
                           ppropvariant);
            if (FAILED(hr))
            {
                return LogHR(hr, s_FN, 1723);
            }
            else
            {
                ppropvariant->vt = VT_UI4;
                return(MQ_OK);
            }

        }


        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("MQADSpRetrieveQMService:GetDsProp(MQ_QM_SERVICE_ROUTING_ATTRIBUTE)=%lx"), hr));
        return LogHR(hr, s_FN, 1668);
    }

    hr = pQMTrans->GetDsProp(MQ_QM_SERVICE_DSSERVER_ATTRIBUTE,
                   MQ_QM_SERVICE_DSSERVER_ADSTYPE,
                   VT_UI1,
                   FALSE,
                   &varDsServer);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("MQADSpRetrieveQMService:GetDsProp(MQ_QM_SERVICE_DSSERVER_ATTRIBUTE)=%lx"), hr));
        return LogHR(hr, s_FN, 1669);
    }


    //
    // set the returned prop variant
    //
    ppropvariant->vt    = VT_UI4;
    ppropvariant->ulVal = (varDsServer.bVal ? SERVICE_PSC : (varRoutingServer.bVal ? SERVICE_SRV : SERVICE_NONE));
    return(MQ_OK);
}

//----------------------------------------------------------------------
//
// Set routines
//
//----------------------------------------------------------------------

HRESULT WINAPI MQADSpCreateMachineSite(
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar)
{
    //
    // if someone asks to set the old prop for site (now computed), we change it to
    // setting the new multi-valued site prop (in the DS)
    //
    ASSERT(pPropVar->vt == VT_CLSID);
    *pdwNewPropID = PROPID_QM_SITE_IDS;
    pNewPropVar->vt = VT_CLSID|VT_VECTOR;
    pNewPropVar->cauuid.cElems = 1;
    pNewPropVar->cauuid.pElems = new GUID;
    pNewPropVar->cauuid.pElems[0] = *pPropVar->puuid;
    return S_OK;
}

HRESULT WINAPI MQADSpSetMachineSite(
                 IN IADs *             pAdsObj,
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar)
{
    //
    // if someone asks to set the old prop for site (now computed), we change it to
    // setting the new multi-valued site prop (in the DS)
    //
    UNREFERENCED_PARAMETER( pAdsObj);
	HRESULT hr2 = MQADSpCreateMachineSite(
					pPropVar,
					pdwNewPropID,
					pNewPropVar);
    return LogHR(hr2, s_FN, 1731);
}



STATIC HRESULT  SetMachineFrss(
                 IN const PROPID       propidFRS,
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar)
/*++

Routine Description:
    Translate PROPID_QM_??FRS to PROPID_QM_??FRS_DN, for set or create
    operation

Arguments:
    propidFRS   - the proerty that we translate to
    pPropVar    - the user supplied property value
    pdwNewPropID - the property that we translate to
    pNewPropVar  - the translated property value

Return Value:
    HRESULT

--*/
{
    //
    //  When the user tries to set PROPID_QM_OUTFRS or
    //  PROPID_QM_INFRS, we need to translate the frss'
    //  unqiue-id to their DN.
    //
    ASSERT(pPropVar->vt == (VT_CLSID|VT_VECTOR));
    *pdwNewPropID = propidFRS;

    if ( pPropVar->cauuid.cElems == 0)
    {
        //
        //  No FRSs
        //
        pNewPropVar->calpwstr.cElems = 0;
        pNewPropVar->calpwstr.pElems = NULL;
        pNewPropVar->vt = VT_LPWSTR|VT_VECTOR;
       return(S_OK);
    }
    HRESULT hr;
    //
    //  Translate unique id to DN
    //
    pNewPropVar->calpwstr.cElems = pPropVar->cauuid.cElems;
    pNewPropVar->calpwstr.pElems = new LPWSTR[ pPropVar->cauuid.cElems];
    memset(  pNewPropVar->calpwstr.pElems, 0, pPropVar->cauuid.cElems * sizeof(LPWSTR));
    pNewPropVar->vt = VT_LPWSTR|VT_VECTOR;

    PROPID prop = PROPID_QM_FULL_PATH;
    PROPVARIANT var;
    CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);

    for (DWORD i = 0; i < pPropVar->cauuid.cElems; i++)
    {
        var.vt = VT_NULL;

        hr = g_pDS->GetObjectProperties(
                    eGlobalCatalog,	
                    &requestDsServerInternal,     // This routine is called from
                                            // DSADS:LookupNext or DSADS::Get..
                                            // impersonation, if required,
                                            // has already been performed.
 	                NULL,
                    &pPropVar->cauuid.pElems[i],
                    1,
                    &prop,
                    &var);
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 1733);
        }
        pNewPropVar->calpwstr.pElems[i] = var.pwszVal;
    }
    return(S_OK);
}


/*====================================================

MQADSpCreateMachineOutFrss

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADSpCreateMachineOutFrss(
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar)
{
        HRESULT hr2 = SetMachineFrss(
                         PROPID_QM_OUTFRS_DN,
                         pPropVar,
                         pdwNewPropID,
                         pNewPropVar);
        return LogHR(hr2, s_FN, 1734);
}
/*====================================================

MQADSpSetMachineOutFrss

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADSpSetMachineOutFrss(
                 IN IADs *             pAdsObj,
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar)
{
        UNREFERENCED_PARAMETER( pAdsObj);
        HRESULT hr2 = SetMachineFrss(
                         PROPID_QM_OUTFRS_DN,
                         pPropVar,
                         pdwNewPropID,
                         pNewPropVar);
        return LogHR(hr2, s_FN, 1746);
}


/*====================================================

MQADSpCreateMachineInFrss

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADSpCreateMachineInFrss(
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar)
{
        HRESULT hr2 = SetMachineFrss(
                         PROPID_QM_INFRS_DN,
                         pPropVar,
                         pdwNewPropID,
                         pNewPropVar);
        return LogHR(hr2, s_FN, 1747);
}

/*====================================================

MQADSpSetMachineInFrss

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADSpSetMachineInFrss(
                 IN IADs *             pAdsObj,
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar)
{
        UNREFERENCED_PARAMETER( pAdsObj);
        HRESULT hr2 = SetMachineFrss(
                         PROPID_QM_INFRS_DN,
                         pPropVar,
                         pdwNewPropID,
                         pNewPropVar);
        return LogHR(hr2, s_FN, 1748);
}



/*====================================================

MQADSpSetMachineServiceInt

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADSpSetMachineServiceTypeInt(
                 IN  PROPID            propFlag,
                 IN IADs *             pAdsObj,
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar)
{
    //
    //  If service < SERVICE_SRV then nothing to do.
    //
    *pdwNewPropID = 0;
    UNREFERENCED_PARAMETER( pNewPropVar);
    
    //
    //  Set this value in msmqSetting
    //
    //
    //  First get the QM-id from msmqConfiguration
    //
    BS bsProp(MQ_QM_ID_ATTRIBUTE);
    CAutoVariant varResult;
    HRESULT  hr = pAdsObj->Get(bsProp, &varResult);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_TRACE, TEXT("MQADSpSetMachineService:pIADs->Get()=%lx"), hr));
        return LogHR(hr, s_FN, 1751);
    }

    //
    // translate to propvariant
    //
    CMQVariant propvarResult;
    hr = Variant2MqVal(propvarResult.CastToStruct(), &varResult, MQ_QM_ID_ADSTYPE, VT_CLSID);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("MQADSpSetMachineService:Variant2MqVal()=%lx"), hr));
        return LogHR(hr, s_FN, 1671);
    }

    //
    //  Locate all msmq-settings of the QM and change the service level
    //

    //
    //  Find the distinguished name of the msmq-setting
    //
    MQPROPERTYRESTRICTION propRestriction;
    propRestriction.rel = PREQ;
    propRestriction.prop = PROPID_SET_QM_ID;
    propRestriction.prval.vt = VT_CLSID;
    propRestriction.prval.puuid = propvarResult.GetCLSID();

    MQRESTRICTION restriction;
    restriction.cRes = 1;
    restriction.paPropRes = &propRestriction;

    PROPID prop = PROPID_SET_FULL_PATH;
    // PROPID propToChangeInSetting = PROPID_SET_SERVICE; [adsrv]

    CDsQueryHandle hQuery;
    CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);

    hr = g_pDS->LocateBegin(
            eSubTree,	
            eLocalDomainController,	
            &requestDsServerInternal,     // internal DS server operation
            NULL,
            &restriction,
            NULL,
            1,
            &prop,
            hQuery.GetPtr());
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_DS,DBGLVL_WARNING,TEXT("MQADSpSetMachineService : Locate begin failed %lx"),hr));
        return LogHR(hr, s_FN, 1754);
    }
    //
    //  Read the results
    //
    DWORD cp = 1;
    MQPROPVARIANT var;

    var.vt = VT_NULL;

    HRESULT hr1 = MQ_OK;
    while (SUCCEEDED(hr = g_pDS->LocateNext(
                hQuery.GetHandle(),
                &requestDsServerInternal,
                &cp,
                &var
                )))
    {
        if ( cp == 0)
        {
            //
            //  Not found -> nothing to change.
            //
            break;
        }
        AP<WCHAR> pClean = var.pwszVal;
        //
        //  change the msmq-setting object
        //
        CDSRequestContext requestDsServerInternal1( e_DoNotImpersonate, e_IP_PROTOCOL);
        hr = g_pDS->SetObjectProperties (
                        eLocalDomainController,
                        &requestDsServerInternal1, // no need to impersonate again,
                                            // this routine is called from 
                                            // dsads::Set.. which already performed
                                            // impersonation if required
                        var.pwszVal,
                        NULL,
                        1,
                        &propFlag,               //[adsrv]propToChangeInSetting,
                        pPropVar,
                        NULL /*pObjInfoRequest*/
                        );
        if (FAILED(hr))
        {
            hr1 = hr;
        }

    }
    if (FAILED(hr1))
    {
        return LogHR(hr1, s_FN, 1756);
    }

    return LogHR(hr, s_FN, 1757);
}

/*====================================================

MQADSpSetMachineServiceDs

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADSpSetMachineServiceDs(
                 IN IADs *             pAdsObj,
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar)
{
    HRESULT hr = MQADSpSetMachineServiceTypeInt(
					 PROPID_SET_SERVICE_DSSERVER,
					 pAdsObj,
					 pPropVar,
					 pdwNewPropID,
					 pNewPropVar);
    if (FAILED(hr))
    {
    	return LogHR(hr, s_FN, 1758);
    }
	
    //
    // we have to reset PROPID_SET_NT4 flag. 
    // In general this flag was reset by migration tool for PEC/PSC.
    // The problem is BSC. After BSC upgrade we have to change
    // PROPID_SET_NT4 flag to 0 and if this BSC is not DC we have to 
    // reset PROPID_SET_SERVICE_DSSERVER flag too. 
    // So, when QM runs first time after upgrade, it completes upgrade
    // process and tries to set PROPID_SET_SERVICE_DSSERVER. 
    // Together with this flag we can change PROPID_SET_NT4 too.
    //

    //
    // BUGBUG: we need to perform set only for former BSC.
    // Here we do it everytime for every server. 
    //
    PROPVARIANT propVarSet;
    propVarSet.vt = VT_UI1;
    propVarSet.bVal = 0;

    hr = MQADSpSetMachineServiceTypeInt(
				     PROPID_SET_NT4,
				     pAdsObj,
				     &propVarSet,
				     pdwNewPropID,
				     pNewPropVar);

    return LogHR(hr, s_FN, 1759);
}


/*====================================================

MQADSpSetMachineServiceRout

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADSpSetMachineServiceRout(
                 IN IADs *             pAdsObj,
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar)
{
    HRESULT hr2 = MQADSpSetMachineServiceTypeInt(
                 PROPID_SET_SERVICE_ROUTING,
                 pAdsObj,
                 pPropVar,
                 pdwNewPropID,
                 pNewPropVar);
    return LogHR(hr2, s_FN, 1761);
}

/*====================================================

MQADSpSetMachineService

Arguments:

Return Value:

=====================================================*/

// [adsrv] BUGBUG:  TBD: If there will be any setting of PROPID_QM_OLDSERVICE, we'll have to rewrite it...

HRESULT WINAPI MQADSpSetMachineService(
                 IN IADs *             pAdsObj,
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar)
{
    //
    //  If service < SERVICE_SRV then nothing to do.
    //
    *pdwNewPropID = 0;
    UNREFERENCED_PARAMETER( pNewPropVar);

    if ( pPropVar->ulVal < SERVICE_SRV)
    {
        return S_OK;
    }
    //
    //  Set this value in msmqSetting
    //
    //
    //  First get the QM-id from msmqConfiguration
    //
    BS bsProp(MQ_QM_ID_ATTRIBUTE);
    CAutoVariant varResult;
    HRESULT  hr = pAdsObj->Get(bsProp, &varResult);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_TRACE, TEXT("MQADSpSetMachineService:pIADs->Get()=%lx"), hr));
        return LogHR(hr, s_FN, 1762);
    }

    //
    // translate to propvariant
    //
    CMQVariant propvarResult;
    hr = Variant2MqVal(propvarResult.CastToStruct(), &varResult, MQ_QM_ID_ADSTYPE, VT_CLSID);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("MQADSpSetMachineService:Variant2MqVal()=%lx"), hr));
        return LogHR(hr, s_FN, 1673);
    }

    //
    //  Locate all msmq-settings of the QM and change the service level
    //

    //
    //  Find the distinguished name of the msmq-setting
    //
    MQPROPERTYRESTRICTION propRestriction;
    propRestriction.rel = PREQ;
    propRestriction.prop = PROPID_SET_QM_ID;
    propRestriction.prval.vt = VT_CLSID;
    propRestriction.prval.puuid = propvarResult.GetCLSID();

    MQRESTRICTION restriction;
    restriction.cRes = 1;
    restriction.paPropRes = &propRestriction;

    PROPID prop = PROPID_SET_FULL_PATH;

    CDsQueryHandle hQuery;
    CDSRequestContext requestDsServerInternal( e_DoNotImpersonate, e_IP_PROTOCOL);

    hr = g_pDS->LocateBegin(
            eSubTree,	
            eLocalDomainController,	
            &requestDsServerInternal,     // internal DS server operation
            NULL,
            &restriction,
            NULL,
            1,
            &prop,
            hQuery.GetPtr());
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_DS,DBGLVL_WARNING,TEXT("MQADSpSetMachineService : Locate begin failed %lx"),hr));
        return LogHR(hr, s_FN, 1764);
    }
    //
    //  Read the results
    //
    DWORD cp = 1;
    MQPROPVARIANT var;

    var.vt = VT_NULL;

    while (SUCCEEDED(hr = g_pDS->LocateNext(
                hQuery.GetHandle(),
                &requestDsServerInternal,
                &cp,
                &var
                )))
    {
        if ( cp == 0)
        {
            //
            //  Not found -> nothing to change.
            //
            break;
        }
        AP<WCHAR> pClean = var.pwszVal;
        //
        //  change the msmq-setting object
        //

        // [adsrv] TBD: here we will have to translate PROPID_QM_OLDSERVICE into set of 3 bits
        PROPID aFlagPropIds[] = {PROPID_SET_SERVICE_DSSERVER,
                                 PROPID_SET_SERVICE_ROUTING,
                                 PROPID_SET_SERVICE_DEPCLIENTS,
								 PROPID_SET_OLDSERVICE};

        MQPROPVARIANT varfFlags[4];
        for (DWORD j=0; j<3; j++)
        {
            varfFlags[j].vt   = VT_UI1;
            varfFlags[j].bVal = FALSE;
        }
        varfFlags[3].vt   = VT_UI4;
        varfFlags[3].ulVal = pPropVar->ulVal;


        switch(pPropVar->ulVal)
        {
        case SERVICE_SRV:
            varfFlags[1].bVal = TRUE;   // router
            varfFlags[2].bVal = TRUE;   // dep.clients server
            break;

        case SERVICE_BSC:
        case SERVICE_PSC:
        case SERVICE_PEC:
            varfFlags[0].bVal = TRUE;   // DS server
            varfFlags[1].bVal = TRUE;   // router
            varfFlags[2].bVal = TRUE;   // dep.clients server
            break;

        case SERVICE_RCS:
            return S_OK;                // nothing to set - we ignored downgrading
            break;

        default:
            ASSERT(0);
            return LogHR(MQ_ERROR, s_FN, 1766);
        }

        CDSRequestContext requestDsServerInternal1( e_DoNotImpersonate, e_IP_PROTOCOL);
        hr = g_pDS->SetObjectProperties (
                        eLocalDomainController,
                        &requestDsServerInternal1,       // no need to impersonate again,
                                            // this routine is called from 
                                            // dsads::Set.. which already performed
                                            // impersonation if required
                        var.pwszVal,
                        NULL,
                        4,
                        aFlagPropIds,
                        varfFlags,
                        NULL /*pObjInfoRequest*/
                        );

    }
    return LogHR(hr, s_FN, 1767);
}



/*====================================================

MQADSpQM1SetMachineSite

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADSpQM1SetMachineSite(
                 IN ULONG             /*cProps */,
                 IN const PROPID      * /*rgPropIDs*/,
                 IN const PROPVARIANT *rgPropVars,
                 IN ULONG             idxProp,
                 OUT PROPVARIANT      *pNewPropVar)
{
    const PROPVARIANT *pPropVar = &rgPropVars[idxProp];

    if ((pPropVar->vt != (VT_CLSID|VT_VECTOR)) ||
        (pPropVar->cauuid.cElems == 0) ||
        (pPropVar->cauuid.pElems == NULL))
    {
        ASSERT(0);
        return LogHR(MQ_ERROR, s_FN, 1768);
    }

    //
    // return the first site-id from the list
    //
    pNewPropVar->puuid = new CLSID;
    pNewPropVar->vt = VT_CLSID;
    *pNewPropVar->puuid = pPropVar->cauuid.pElems[0];
    return MQ_OK;
}


/*====================================================

MQADSpQM1SetMachineOutFrss

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADSpQM1SetMachineOutFrss(
                 IN ULONG             /* cProps */,
                 IN const PROPID      * /*rgPropIDs*/,
                 IN const PROPVARIANT *rgPropVars,
                 IN ULONG             idxProp,
                 OUT PROPVARIANT      *pNewPropVar)
{
    const PROPVARIANT *pPropVar = &rgPropVars[idxProp];
    HRESULT hr2=FillQmidsFromQmDNs(pPropVar, pNewPropVar);
    return LogHR(hr2, s_FN, 1771);
}

/*====================================================

MQADSpQM1SetMachineInFrss

Arguments:

Return Value:

=====================================================*/
HRESULT WINAPI MQADSpQM1SetMachineInFrss(
                 IN ULONG             /*cProps*/,
                 IN const PROPID      * /*rgPropIDs*/,
                 IN const PROPVARIANT *rgPropVars,
                 IN ULONG             idxProp,
                 OUT PROPVARIANT      *pNewPropVar)
{
    const PROPVARIANT *pPropVar = &rgPropVars[idxProp];
    HRESULT hr2 = FillQmidsFromQmDNs(pPropVar, pNewPropVar);
    return LogHR(hr2, s_FN, 1773);
}

/*====================================================

MQADSpQM1SetMachineService

Arguments:

Return Value:

=====================================================*/

HRESULT WINAPI MQADSpQM1SetMachineService(
                 IN ULONG             cProps,
                 IN const PROPID      *rgPropIDs,
                 IN const PROPVARIANT *rgPropVars,
                 IN ULONG             /*idxProp*/,
                 OUT PROPVARIANT      *pNewPropVar)
{
    BOOL fRouter      = FALSE,
         fDSServer    = FALSE,
		 fFoundRout   = FALSE,
		 fFoundDs     = FALSE,
		 fFoundDepCl  = FALSE;

    for ( DWORD i = 0; i< cProps ; i++)
    {
        switch (rgPropIDs[i])
        {
        // [adsrv] Even if today we don't get new server-type-specific props, we may tomorrow.
        case PROPID_QM_SERVICE_ROUTING:
            fRouter = (rgPropVars[i].bVal != 0);
			fFoundRout = TRUE;
            break;

        case PROPID_QM_SERVICE_DSSERVER:
            fDSServer  = (rgPropVars[i].bVal != 0);
			fFoundDs = TRUE;
            break;

        case PROPID_QM_SERVICE_DEPCLIENTS:
			fFoundDepCl = TRUE;
            break;

        default:
            break;

        }
    }

	// If anybody sets one of 3 proprties (rout, ds, depcl), he must do it for all 3 of them
	ASSERT( fFoundRout && fFoundDs && fFoundDepCl);

    pNewPropVar->vt    = VT_UI4;
    pNewPropVar->ulVal = (fDSServer ? SERVICE_PSC : (fRouter ? SERVICE_SRV : SERVICE_NONE));

	return MQ_OK;
}

/*====================================================

MQADSpQM1SetSecurity

    Translate security descriptor to NT4 format.

====================================================*/

HRESULT WINAPI MQADSpQM1SetSecurity(
                 IN ULONG             cProps,
                 IN const PROPID      *rgPropIDs,
                 IN const PROPVARIANT *rgPropVars,
                 IN ULONG             /*idxProp*/,
                 OUT PROPVARIANT      *pNewPropVar)
{
    DWORD dwIndex = 0 ;
    DWORD dwObjectType = 0 ;

    for ( DWORD i = 0; ((i < cProps) && (dwObjectType == 0)) ; i++ )
    {
        switch (rgPropIDs[i])
        {
            case PROPID_Q_SECURITY:
                dwIndex = i ;
                dwObjectType = MQDS_QUEUE ;
                break ;

            case PROPID_QM_SECURITY:
                dwIndex = i ;
                dwObjectType = MQDS_MACHINE ;
                break ;

            default:
                break ;
        }
    }

    if (dwObjectType == 0)
    {
        ASSERT(0) ;
        return LogHR(MQDS_WRONG_OBJ_TYPE, s_FN, 1776);
    }

    DWORD dwSD4Len = 0 ;
    P<SECURITY_DESCRIPTOR> pSD4 = NULL ;

    HRESULT hr = MQSec_ConvertSDToNT4Format( dwObjectType,
                (SECURITY_DESCRIPTOR*) rgPropVars[ dwIndex ].blob.pBlobData,
                                            &dwSD4Len,
                                            &pSD4 ) ;
    if (FAILED(hr))
    {
        ASSERT(0) ;
        return LogHR(hr, s_FN, 1777);
    }

    pNewPropVar->vt = VT_BLOB ;

    if (hr == MQSec_I_SD_CONV_NOT_NEEDED)
    {
        ASSERT(pSD4 == NULL) ;
        //
        // Copy input descriptor.
        //
        dwSD4Len = rgPropVars[ dwIndex ].blob.cbSize ;
        pNewPropVar->blob.pBlobData = (BYTE*) new BYTE[ dwSD4Len ] ;
        memcpy( pNewPropVar->blob.pBlobData,
                rgPropVars[ dwIndex ].blob.pBlobData,
                dwSD4Len ) ;
        pNewPropVar->blob.cbSize = dwSD4Len ;
    }
    else
    {
        pNewPropVar->blob.pBlobData = (BYTE*)pSD4.detach();
        pNewPropVar->blob.cbSize = dwSD4Len ;
    }

    return MQ_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdscore\xlatobj.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    xlatobj.cpp

Abstract:

    Implementation of routines that deal with translation of generic MSMQ objects:
    CMsmqObjXlateInfo

Author:

    Raanan Harari (raananh)

--*/

#include "ds_stdh.h"
#include <activeds.h>
#include "mqads.h"
#include "_propvar.h"
#include "dsutils.h"
#include "utils.h"

#include "xlatobj.tmh"

static WCHAR *s_FN=L"mqdscore/xlatobj";

//--------------------------------------------------------------------
// static functions fwd declaration
//--------------------------------------------------------------------

STATIC HRESULT GetPropvarByIADs(IN IADs * pIADs,
                                IN LPCWSTR pwszPropName,
                                IN ADSTYPE adstype,
                                IN VARTYPE vartype,
                                IN BOOL fMultiValued,
                                OUT PROPVARIANT * ppropvarResult);
STATIC HRESULT GetPropvarByDN(IN LPCWSTR pwszObjectDN,
                              IN LPCWSTR pwszPropName,
                              IN ADSTYPE adstype,
                              IN VARTYPE vartype,
                              IN BOOL fMultiValued,
                              OUT PROPVARIANT * ppropvarResult,
                              OUT IADs ** ppIADs);
STATIC HRESULT GetPropvarBySearchObj(IN IDirectorySearch *pSearchObj,
                                     IN ADS_SEARCH_HANDLE hSearch,
                                     IN LPCWSTR pwszPropName,
                                     IN ADSTYPE adstype,
                                     IN VARTYPE vartype,
                                     OUT PROPVARIANT * ppropvarResult);

//--------------------------------------------------------------------
// CMsmqObjXlateInfo implementation
//--------------------------------------------------------------------

CMsmqObjXlateInfo::CMsmqObjXlateInfo(
                    LPCWSTR             pwszObjectDN,
                    const GUID*         pguidObjectGuid,
                    CDSRequestContext *    pRequestContext)
                    : m_pRequestContext( pRequestContext)
/*++
    Constructor for the generic xlate info for an MSMQ objects
--*/
{
    //
    // record the DN of the object if any
    //
    if (pwszObjectDN)
    {
        m_pwszObjectDN = new WCHAR[wcslen(pwszObjectDN) + 1];
        wcscpy(m_pwszObjectDN, pwszObjectDN);
    }

    //
    // record the guid of the object if any
    //
    if (pguidObjectGuid)
    {
        m_pguidObjectGuid = new GUID;
        *m_pguidObjectGuid = *pguidObjectGuid;
    }
//
//    no need for following initialization since these are auto-release and inited
//    to NULL already
//
//    m_pIADs = NULL;
//    m_pSearchObj = NULL;
//
}


CMsmqObjXlateInfo::~CMsmqObjXlateInfo()
/*++
    Destructor for the generic xlate info for an MSMQ objects.
--*/
{
    //
    // members are auto release
    //
}


void CMsmqObjXlateInfo::InitGetDsProps(IN IADs * pIADs)
/*++
    Abstract:
        Initialization for GetDsProp call.
        GetDsProp will use the given IADs object when trying to
        get props for the object.

    Parameters:
        pIADs           - IADs interface for the object

    Returns:
      None
--*/
{
    pIADs->AddRef();  // keep it alive
    m_pIADs = pIADs;  // will auto release on destruction
}


void CMsmqObjXlateInfo::InitGetDsProps(IN IDirectorySearch * pSearchObj,
                                       IN ADS_SEARCH_HANDLE hSearch)
/*++
    Abstract:
        Initialization for GetDsProp call.
        GetDsProp will use the given search object first when trying to
        get props for the object, before binding to it using IADs.

    Parameters:
        pSearchObj      - search object
        hSearch         - search handle

    Returns:
      None
--*/
{
    pSearchObj->AddRef();      // keep it alive
    m_pSearchObj = pSearchObj; // will auto release on destruction
    m_hSearch = hSearch;
}


HRESULT CMsmqObjXlateInfo::GetDsProp(IN LPCWSTR pwszPropName,
                                     IN ADSTYPE adstype,
                                     IN VARTYPE vartype,
                                     IN BOOL fMultiValued,
                                     OUT PROPVARIANT * ppropvarResult)
/*++
    Abstract:
        Get a DS property value of the object as a propvariant, w/o going
        to translation routine or default value

    Parameters:
        pwszPropName    - property name
        adstype         - requested ADSTYPE
        vartype         - requested VARTYPE in result propvariant
        fMultiValued    - whether the property is multi-valued in the DS
        ppropvarResult  - propvariant to fill, should be empty already

    Returns:
      MQ_OK - success, ppropvarResult is filled
      E_ADS_PROPERTY_NOT_FOUND - property was not found
      other HRESULT errors
--*/
{
    HRESULT hr;
    CMQVariant propvarResult;
    BOOL fGotPropFromSearchObj = FALSE;

    //
    // start with getting the property from search object
    //
    if (m_pSearchObj.get() != NULL)
    {
        hr = GetPropvarBySearchObj(m_pSearchObj.get(),
                                   m_hSearch,
                                   pwszPropName,
                                   adstype,
                                   vartype,
                                   propvarResult.CastToStruct());
        if (FAILED(hr))
        {
            DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("GetDsProp:GetPropvarBySearchObj()=%lx"), hr));
            return LogHR(hr, s_FN, 10);
        }

        //
        // hr could be S_OK (if property found) or S_FALSE (if property was not requested in search)
        //
        if (hr == S_OK) //e.g. (hr != S_FALSE)
        {
            //
            // we don't need to check further
            //
            fGotPropFromSearchObj = TRUE;
        }
    }

    //
    // if search object was not helpfull, use IADs
    //
    if (!fGotPropFromSearchObj)
    {
        //
        // property was not found, use IADs
        //
        if (m_pIADs.get() != NULL)
        {
            //
            // there is already an open IADs for the object, use it
            //
            hr = GetPropvarByIADs(m_pIADs.get(),
                                  pwszPropName,
                                  adstype,
                                  vartype,
                                  fMultiValued,
                                  propvarResult.CastToStruct());
            if (FAILED(hr))
            {
                DBGMSG((DBGMOD_ADS, DBGLVL_TRACE, TEXT("GetDsProp:GetPropvarByIADs()=%lx"), hr));
                return LogHR(hr, s_FN, 20);
            }
        }
        else
        {
            //
            // IADs is not set, bind to the object, and save the IADs
            //
            R<IADs> pIADs;
            hr = GetPropvarByDN(ObjectDN(),
                                pwszPropName,
                                adstype,
                                vartype,
                                fMultiValued,
                                propvarResult.CastToStruct(),
                                &pIADs.ref());
            if (FAILED(hr))
            {
                DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("GetDsProp:GetPropvarByDN()=%lx"), hr));
                return LogHR(hr, s_FN, 30);
            }

            //
            // save the IADs
            // we must not AddRef it since we created it and we need to totally release
            // it on destruction, it is not a passed parameter we need to keep alive
            //
            m_pIADs = pIADs;
        }
    }

    //
    // return values
    //
    *ppropvarResult = *(propvarResult.CastToStruct());
    (propvarResult.CastToStruct())->vt = VT_EMPTY;
    return MQ_OK;
}


//--------------------------------------------------------------------
// external functions
//--------------------------------------------------------------------

HRESULT WINAPI GetDefaultMsmqObjXlateInfo(
                 IN  LPCWSTR                pwcsObjectDN,
                 IN  const GUID*            pguidObjectGuid,
                 IN  CDSRequestContext *    pRequestContext,
                 OUT CMsmqObjXlateInfo**    ppcMsmqObjXlateInfo)
/*++
    Abstract:
        Routine to get a default translate object that will be passed to
        translation routines to all properties of the translated object

    Parameters:
        pwcsObjectDN        - DN of the translated object
        pguidObjectGuid     - GUID of the translated object
        ppcMsmqObjXlateInfo - Where the translate object is put

    Returns:
      HRESULT
--*/
{
    *ppcMsmqObjXlateInfo = new CMsmqObjXlateInfo(
                                        pwcsObjectDN,
                                        pguidObjectGuid,
                                        pRequestContext);
    return MQ_OK;
}


//--------------------------------------------------------------------
// static functions
//--------------------------------------------------------------------

STATIC HRESULT GetPropvarByIADs(IN IADs * pIADs,
                                IN LPCWSTR pwszPropName,
                                IN ADSTYPE adstype,
                                IN VARTYPE vartype,
                                IN BOOL fMultiValued,
                                OUT PROPVARIANT * ppropvarResult)
/*++
    Abstract:
        Get a DS property as a propvariant, w/o going to translation routine,
        using IADs

    Parameters:
        pIADs           - IADs interface for the object
        pwszPropName    - property name
        adstype         - requested ADSTYPE
        vartype         - requested VARTYPE in result propvariant
        fMultiValued    - whether the property is multi-valued in the DS
        ppropvarResult  - propvariant to fill, should be empty already

    Returns:
      S_OK - success, ppropvarResult is filled
      other HRESULT errors
--*/
{
    HRESULT hr;
    //
    // get prop
    //
    CAutoVariant varResult;
    BS bsProp = pwszPropName;
    if (fMultiValued)
    {
        hr = pIADs->GetEx(bsProp, &varResult);
    }
    else
    {
        hr = pIADs->Get(bsProp, &varResult);
    }    
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_TRACE, TEXT("GetPropvarByIADs:pIADs->Get()/GetEx()=%lx"), hr));
        return LogHR(hr, s_FN, 40);
    }

    //
    // translate to propvariant
    //
    CMQVariant propvarResult;
    hr = Variant2MqVal(propvarResult.CastToStruct(), &varResult, adstype, vartype);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("GetPropvarByIADs:Variant2MqVal()=%lx"), hr));
        return LogHR(hr, s_FN, 50);
    }

    //
    // return values
    //
    *ppropvarResult = *(propvarResult.CastToStruct());
    (propvarResult.CastToStruct())->vt = VT_EMPTY;
    return S_OK;
}


STATIC HRESULT GetPropvarByDN(IN LPCWSTR pwszObjectDN,
                              IN LPCWSTR pwszPropName,
                              IN ADSTYPE adstype,
                              IN VARTYPE vartype,
                              IN BOOL fMultiValued,
                              OUT PROPVARIANT * ppropvarResult,
                              OUT IADs ** ppIADs)
/*++
    Abstract:
        Get a DS property as a propvariant, w/o going to translation routine,
        using its DN. It also returns the IADs for the object.

    Parameters:
        pwszObjectDN    - distinguished name of the object
        pwszPropName    - property name
        adstype         - requested ADSTYPE
        vartype         - requested VARTYPE in result propvariant
        fMultiValued    - whether the property is multi-valued in the DS
        ppropvarResult  - propvariant to fill, should be empty already
        ppIADs          - returned IADs interface for the object

    Returns:
      S_OK - success, ppropvarResult is filled
      other HRESULT errors
--*/
{
    HRESULT hr;

    //
    // Create ADSI path
    //
    AP<WCHAR> pwszPath = new WCHAR[1+wcslen(L"LDAP://")+wcslen(pwszObjectDN)];
    wcscpy(pwszPath, L"LDAP://");
    wcscat(pwszPath, pwszObjectDN);

    //
    // bind to the obj
    //
    R<IADs> pIADs;

	hr = ADsOpenObject(
			pwszPath,
			NULL,
			NULL,
			ADS_SECURE_AUTHENTICATION,
			IID_IADs,
			(void**)&pIADs
			);

    LogTraceQuery(pwszPath, s_FN, 59);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("GetPropvarByDN:ADsOpenObject()=%lx"), hr));
        return LogHR(hr, s_FN, 60);
    }

    //
    // get the prop
    //
    CMQVariant propvarResult;
    hr = GetPropvarByIADs(pIADs.get(), pwszPropName, adstype, vartype, fMultiValued, propvarResult.CastToStruct());
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("GetPropvarByDN:GetPropvarByIADs()=%lx"), hr));
        return LogHR(hr, s_FN, 70);
    }

    //
    // return values
    //
    *ppropvarResult = *(propvarResult.CastToStruct());
    (propvarResult.CastToStruct())->vt = VT_EMPTY;
    *ppIADs = pIADs.detach();
    return S_OK;
}


STATIC HRESULT GetPropvarBySearchObj(IN IDirectorySearch *pSearchObj,
                                     IN ADS_SEARCH_HANDLE hSearch,
                                     IN LPCWSTR pwszPropName,
                                     IN ADSTYPE adstype,
                                     IN VARTYPE vartype,
                                     OUT PROPVARIANT * ppropvarResult)
/*++
    Abstract:
        Get a DS property as a propvariant, w/o going to translation routine,
        using a search object.
        Note it might not find the property if it was not requested by the
        search originator.

    Parameters:
        pSearchObj      - search object
        hSearch         - search handle
        pwszPropName    - property name
        adstype         - requested ADSTYPE
        vartype         - requested VARTYPE in result propvariant
        ppropvarResult  - propvariant to fill, should be empty already

    Returns:
      S_OK - success, ppropvarResult is filled
      S_FALSE - property not requested by search originator, ppropvarResult is not filled
      other HRESULT errors
--*/
{
    //
    // check if prop is requested
    //
    ADS_SEARCH_COLUMN columnProp;
    HRESULT hr = pSearchObj->GetColumn(hSearch, const_cast<LPWSTR>(pwszPropName), &columnProp);
    if (FAILED(hr) && (hr != E_ADS_COLUMN_NOT_SET))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("GetPropvarBySearchObj:pSearchObj->GetColumn()=%lx"), hr));
        return LogHR(hr, s_FN, 80);
    }
    
    if (hr == E_ADS_COLUMN_NOT_SET)
    {
        //
        // property was not requested
        //
        return S_FALSE;
    }

    //
    // property was found, make sure the column is freed eventually
    //
    CAutoReleaseColumn cAutoReleaseColumnProp(pSearchObj, &columnProp);

    //
    // convert it to propvariant
    //
    CMQVariant propvarResult;
    hr = AdsiVal2MqVal(propvarResult.CastToStruct(),
                       vartype,
                       adstype,
                       columnProp.dwNumValues,
                       columnProp.pADsValues);
    if (FAILED(hr))
    {
        DBGMSG((DBGMOD_ADS, DBGLVL_ERROR, TEXT("GetPropvarBySearchObj:AdsiVal2MqVal()=%lx"), hr));
        return LogHR(hr, s_FN, 90);
    }

    //
    // return values
    //
    *ppropvarResult = *(propvarResult.CastToStruct());
    (propvarResult.CastToStruct())->vt = VT_EMPTY;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdssrv\midluser.cpp ===
#include "stdh.h"
#include "..\..\common\midluser.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdscore\xlatqm.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    xlatqm.cpp

Abstract:

    Definition of routines to translate QM info from NT5 Active DS
    to what MSMQ 1.0 (NT4) QM's expect

Author:

    Raanan Harari (raananh)

--*/

#ifndef __XLATQM_H__
#define __XLATQM_H__

#include "mqads.h"

HRESULT WINAPI GetMsmqQmXlateInfo(
                 IN  LPCWSTR                pwcsObjectDN,
                 IN  const GUID*            pguidObjectGuid,
                 IN  CDSRequestContext *    pRequestContext,
                 OUT CMsmqObjXlateInfo**    ppcMsmqObjXlateInfo);

HRESULT WINAPI MQADSpRetrieveMachineSite(
                 IN  CMsmqObjXlateInfo * pTrans,
                 OUT PROPVARIANT * ppropvariant);

HRESULT WINAPI MQADSpRetrieveMachineAddresses(
                 IN  CMsmqObjXlateInfo * pTrans,
                 OUT PROPVARIANT * ppropvariant);

HRESULT WINAPI MQADSpRetrieveMachineCNs(
                 IN  CMsmqObjXlateInfo * pTrans,
                 OUT PROPVARIANT * ppropvariant);

HRESULT WINAPI MQADSpRetrieveMachineName(
                 IN  CMsmqObjXlateInfo * pTrans,
                 OUT PROPVARIANT * ppropvariant);

HRESULT WINAPI MQADSpRetrieveMachineDNSName(
                 IN  CMsmqObjXlateInfo * pTrans,
                 OUT PROPVARIANT * ppropvariant);

HRESULT WINAPI MQADSpRetrieveMachineMasterId(
                 IN  CMsmqObjXlateInfo * pTrans,
                 OUT PROPVARIANT * ppropvariant);

HRESULT WINAPI MQADSpRetrieveQMService(
                 IN  CMsmqObjXlateInfo * pTrans,
                 OUT PROPVARIANT * ppropvariant);

HRESULT WINAPI MQADSpSetMachineServiceDs(
                 IN  CMsmqObjXlateInfo * pTrans,
                 OUT PROPVARIANT * ppropvariant);

HRESULT WINAPI MQADSpSetMachineServiceRout(
                 IN  CMsmqObjXlateInfo * pTrans,
                 OUT PROPVARIANT * ppropvariant);

HRESULT WINAPI MQADSpRetrieveMachineOutFrs(
                 IN  CMsmqObjXlateInfo * pTrans,
                 OUT PROPVARIANT * ppropvariant);

HRESULT WINAPI MQADSpRetrieveMachineInFrs(
                 IN  CMsmqObjXlateInfo * pTrans,
                 OUT PROPVARIANT * ppropvariant);


HRESULT WINAPI MQADSpSetMachineSite(
                 IN IADs *             pAdsObj,
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar);

HRESULT WINAPI MQADSpCreateMachineSite(
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar);

HRESULT WINAPI MQADSpSetMachineOutFrss(
                 IN IADs *             pAdsObj,
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar);

HRESULT WINAPI MQADSpCreateMachineOutFrss(
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar);

HRESULT WINAPI MQADSpSetMachineInFrss(
                 IN IADs *             pAdsObj,
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar);

HRESULT WINAPI MQADSpCreateMachineInFrss(
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar);

HRESULT WINAPI MQADSpSetMachineService(
                 IN IADs *             pAdsObj,
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar);

HRESULT WINAPI MQADSpSetMachineServiceDs(
                 IN IADs *             pAdsObj,
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar);

HRESULT WINAPI MQADSpSetMachineServiceRout(
                 IN IADs *             pAdsObj,
                 IN const PROPVARIANT *pPropVar,
                 OUT PROPID           *pdwNewPropID,
                 OUT PROPVARIANT      *pNewPropVar);

HRESULT WINAPI MQADSpQM1SetMachineSite(
                 IN ULONG             cProps,
                 IN const PROPID      *rgPropIDs,
                 IN const PROPVARIANT *rgPropVars,
                 IN ULONG             idxProp,
                 OUT PROPVARIANT      *pNewPropVar);

HRESULT WINAPI MQADSpQM1SetMachineOutFrss(
                 IN ULONG             cProps,
                 IN const PROPID      *rgPropIDs,
                 IN const PROPVARIANT *rgPropVars,
                 IN ULONG             idxProp,
                 OUT PROPVARIANT      *pNewPropVar);

HRESULT WINAPI MQADSpQM1SetMachineInFrss(
                 IN ULONG             cProps,
                 IN const PROPID      *rgPropIDs,
                 IN const PROPVARIANT *rgPropVars,
                 IN ULONG             idxProp,
                 OUT PROPVARIANT      *pNewPropVar);

HRESULT WINAPI MQADSpQM1SetMachineService(
                 IN ULONG             cProps,
                 IN const PROPID      *rgPropIDs,
                 IN const PROPVARIANT *rgPropVars,
                 IN ULONG             idxProp,
                 OUT PROPVARIANT      *pNewPropVar);

HRESULT WINAPI MQADSpQM1SetSecurity(
                 IN ULONG             cProps,
                 IN const PROPID      *rgPropIDs,
                 IN const PROPVARIANT *rgPropVars,
                 IN ULONG             idxProp,
                 OUT PROPVARIANT      *pNewPropVar);

HRESULT MQADSpGetComputerDns(
                IN  LPCWSTR     pwcsComputerName,
                OUT WCHAR **    ppwcsDnsName
                );


#endif //__XLATQM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdscore\_dsads.h ===
#ifndef ___DSADS_H__
#define ___DSADS_H__
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:
	_dsads.h

Abstract:
	Internal definitions for CADSI class implementation

Author:
    AlexDad
--*/

#include "activeds.h"
#include "mqads.h"

//---------------------------------------------------------
//
// CADSSearch: Internal object encapsulating ongoing search
//
//---------------------------------------------------------

class CADSSearch
{
public:
    CADSSearch(IDirectorySearch  *  pIDirSearch, 
               const PROPID      *  pPropIDs,    
               DWORD                cPropIDs,          
               DWORD                cRequestedFromDS,
               const MQClassInfo *  pClassInfo,               
               ADS_SEARCH_HANDLE    hSearch);
    ~CADSSearch();

    BOOL               Verify();
    IDirectorySearch  *pDSSearch();
    ADS_SEARCH_HANDLE  hSearch();
    PROPID             PropID(DWORD i);
    DWORD              NumPropIDs();
    DWORD              NumRequestedFromDS();
    const MQClassInfo *      ClassInfo();
    void               SetNoMoreResult();
    BOOL               WasLastResultReturned();

private:
    DWORD              m_dwSignature;   // to verify that handle was not falsified
    IDirectorySearch  *m_pDSSearch;     //IDirectorySearch interface captured;
    ADS_SEARCH_HANDLE  m_hSearch;       // ADSI search handle 
    PROPID            *m_pPropIDs;      // array of column PropIDs
    DWORD              m_cPropIDs;      // counter of columns requested in PropIDs
    DWORD              m_cRequestedFromDS; // counter of columns passed to DS (with Dn & Guid)
    const MQClassInfo * m_pClassInfo;    // pointer to class info
    BOOL               m_fNoMoreResults;
};


inline BOOL CADSSearch::Verify()
{
    // Checking the signature
    return (m_dwSignature == 0x1234);
}

inline IDirectorySearch  *CADSSearch::pDSSearch()
{
    return m_pDSSearch;
}
    
inline ADS_SEARCH_HANDLE CADSSearch::hSearch()
{
    return  m_hSearch;
}

inline  PROPID CADSSearch::PropID(DWORD i)
{
    ASSERT(i < m_cPropIDs);
    return m_pPropIDs[i];
}

inline DWORD CADSSearch::NumPropIDs()
{
    return m_cPropIDs;
}

inline DWORD CADSSearch::NumRequestedFromDS()
{
    return m_cRequestedFromDS;
}

inline void CADSSearch::SetNoMoreResult()
{
    m_fNoMoreResults = TRUE;
}
inline BOOL CADSSearch::WasLastResultReturned()
{
    return( m_fNoMoreResults);
}


inline const MQClassInfo * CADSSearch::ClassInfo()
{
    return m_pClassInfo;
}

#endif

STATIC HRESULT GetDNGuidFromSearchObj(IN IDirectorySearch  *pSearchObj,
                                      ADS_SEARCH_HANDLE  hSearch,
                                      OUT LPWSTR * ppwszObjectDN,
                                      OUT GUID ** ppguidObjectGuid);
STATIC HRESULT GetDNGuidFromIADs(IN IADs * pIADs,
                                 OUT LPWSTR * ppwszObjectDN,
                                 OUT GUID ** ppguidObjectGuid);

static HRESULT VerifyObjectCategory( IN IADs * pIADs,
                                  IN const WCHAR * pwcsExpectedCategory
                                 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdssrv\dscomm_s_.c ===
#pragma warning(push, 3)
#pragma warning(disable: 4701)
#include <dscomm_s.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdssrv\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by res.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdssrv\midlproc.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    midlproc.cpp

Abstract:

Author:

    Ronit Hartmann(ronith)

--*/

#include "stdh.h"
#include "dscomm.h"
#include "ds.h"
#include "notifydl.h"

#include "midlproc.tmh"

extern "C" void  __RPC_USER PCONTEXT_HANDLE_TYPE_rundown(PCONTEXT_HANDLE_TYPE phContext)
{
	 DSLookupEnd(phContext);
}


extern "C" void __RPC_USER PCONTEXT_HANDLE_READONLY_TYPE_rundown(PCONTEXT_HANDLE_READONLY_TYPE phContext)
{
    //
    // Obsolete
    //
}

extern "C" void __RPC_USER PCONTEXT_HANDLE_DELETE_TYPE_rundown(PCONTEXT_HANDLE_DELETE_TYPE phContext)
{
    CBasicDeletionNotification * pDelNotification = (CBasicDeletionNotification *)phContext;
    delete pDelNotification;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdssrv\dsapi.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    dsapi.cpp

Abstract:

    Includes ClIENT-SERVER APIs ( local interface)

Author:

    Ronit Hartmann (ronith)

--*/

#include "stdh.h"
#include "mqds.h"
#include "qmperf.h"
#include <mqsec.h>
#include <_registr.h>
#include <mqsec.h>
#include "dsreqinf.h"
#include <adserr.h>

#include "dsapi.tmh"

static WCHAR *s_FN=L"mqdssrv/dsapi";

#define STORE_AND_CLEAR_IMPERSONATION_FLAG(dwObjectType, fImpersonate)  \
    {                                                                   \
        fImpersonate = ((dwObjectType & IMPERSONATE_CLIENT_FLAG) != 0); \
        dwObjectType &= ~IMPERSONATE_CLIENT_FLAG;                       \
    }


// Validate that all the specified properties are allowed to be queried
// by applications via the DS API.
STATIC HRESULT ValidateProperties(DWORD cp, PROPID aProp[])
{
    DWORD i;
    PROPID *pPropID;

    if ((cp ==1) && (aProp[0] == PROPID_COM_SID))
    {
        //
        // Allow msmq services to query for their own machine account SID.
        //
        return MQ_OK ;
    }
    else if ((cp ==1) && (aProp[0] == PROPID_SET_FULL_PATH))
    {
        //
        // Happen when msmq service wants to update its dacl in
        // msmqConfiguration object after upgrade to win2k.
        //
        return MQ_OK ;
    }

    for (i = 0, pPropID = aProp;
         (i < cp) && !IS_PRIVATE_PROPID(*pPropID);
         i++, pPropID++)
	{
		NULL;
	}

    if (i < cp)
    {
        return LogHR(MQ_ERROR_ILLEGAL_PROPID, s_FN, 10);
    }

    return(MQ_OK);
}


// Validate that all the specified restrictions are allowed to be queried
// by applications via the DS API.
STATIC HRESULT ValidateRestrictions( DWORD cRes,
                                     MQPROPERTYRESTRICTION *paPropRes)
{
    if ((cRes == 2)                                  &&
        ((paPropRes[0]).prop == PROPID_SET_SERVICE) &&
        ((paPropRes[1]).prop == PROPID_SET_NT4))
    {
        //
        // Happen when msmq service wants to update its dacl in
        // msmqConfiguration object after upgrade to win2k.
        //
        return MQ_OK ;
    }

    DWORD i;
    MQPROPERTYRESTRICTION *pPropRes;

    for (i = 0, pPropRes = paPropRes;
         (i < cRes) && !IS_PRIVATE_PROPID(pPropRes->prop);
         i++, pPropRes++)
	{
		NULL;
	}

    if (i < cRes)
    {
        return LogHR(MQ_ERROR_ILLEGAL_PROPID, s_FN, 20);
    }

    return(MQ_OK);
}

/*====================================================

DSCreateObjectInternal

Arguments:

Return Value:

=====================================================*/

HRESULT
DSCreateObjectInternal( IN  DWORD                  dwObjectType,
                        IN  LPCWSTR                pwcsPathName,
                        IN  PSECURITY_DESCRIPTOR   pSecurityDescriptorIn,
                        IN  DWORD                  cp,
                        IN  PROPID                 aProp[],
                        IN  PROPVARIANT            apVar[],
                        IN  BOOL                   fIsKerberos,
                        OUT GUID*                  pObjGuid )
{
    BOOL fImpersonate;

    STORE_AND_CLEAR_IMPERSONATION_FLAG(dwObjectType, fImpersonate);

    if (dwObjectType == MQDS_ENTERPRISE)
    {
        //
        // On Windows 2000, we don't expect anyone to call this function and
        // create the enterprise object.
        //
        return LogHR(MQ_ERROR_ILLEGAL_ENTERPRISE_OPERATION, s_FN, 30);
    }
    else if (dwObjectType != MQDS_QUEUE)
    {
        //
        // The only instance when msmq application can create objects with
        // explicit security descriptor is when calling MQCreateQueue().
        // All other calls to this function are from msmq admin tools or
        // setup. These calls never pass a security descriptor. The code
        // below, SetDefaultValues(), will create a default descriptor for
        // msmq admin/setup objects.
        //
        if (pSecurityDescriptorIn != NULL)
        {
            ASSERT(0) ;
            return LogHR(MQ_ERROR_ILLEGAL_PROPERTY_VALUE, s_FN, 40);
        }

        //
        // Security property should never be supplied.
        //
        PROPID pSecId = GetObjectSecurityPropid( dwObjectType ) ;
        if (pSecId != ILLEGAL_PROPID_VALUE)
        {
            for ( DWORD i = 0; i < cp ; i++ )
            {
                if (pSecId == aProp[i])
                {
                    ASSERT(0) ;
                    return LogHR(MQ_ERROR_ILLEGAL_PROPID, s_FN, 50);
                }
            }
        }
    }

    HRESULT hr;
    DWORD cpObject;
    AP<PROPID> pPropObject = NULL;
    AP< PROPVARIANT> pVarObject = NULL;
    P<VOID> pDefaultSecurityDescriptor;
    P<BYTE> pMachineSid = NULL ;
    P<BYTE> pUserSid = NULL ;
    PSECURITY_DESCRIPTOR   pSecurityDescriptor = pSecurityDescriptorIn ;

    //
    // Update the access count to the server (performace info only)
    //
    UPDATE_COUNTER(&g_pdsCounters->nAccessServer,g_pdsCounters->nAccessServer++)

    try
    {
        if (dwObjectType == MQDS_USER)
        {
            hr = MQSec_GetThreadUserSid(TRUE, (PSID*) &pUserSid, NULL) ;
            if (FAILED(hr))
            {
                UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,
                                g_pdsCounters->nErrorsReturnedToApp++) ;
                LogHR(hr, s_FN, 60);
                return MQ_ERROR_ILLEGAL_USER;
            }
            ASSERT(IsValidSid(pUserSid)) ;

            BOOL fAnonymus = MQSec_IsAnonymusSid( pUserSid ) ;
            if (fAnonymus)
            {
                return LogHR(MQ_ERROR_ILLEGAL_USER, s_FN, 70);
            }
        }

        DWORD   cpEx = 0 ;
        PROPID  propIdEx = 0 ;
        PROPID *ppropIdEx = NULL ;

        if ((dwObjectType == MQDS_QUEUE) ||
            (dwObjectType == MQDS_SITE))
        {
            //
            // Fill with default vaules any missing part of the
            // security descriptor.
            //
            if (!pSecurityDescriptor)
            {
                //
                // If caller did not supply his own security descriptor then
                // create a default descriptor without owner. This is to
                // fix bug # 5286, that happen because of mismatch between
                // anonymous and guest. On win2k, we can create objects
                // without supplying owner. The active directory server will
                // add the owner from the impersonation token.
                // (note- on msmq1.0, the mqis implemented the security, so
                // it had to have a owner for each object).
                // Implementation- here we create a complete descriptor,
                // inlcuding owner. If eventually the call go to local active
                // directory, we'll remove the owner. If call is write-
                // requested to a MQIS server, the owner is needed.
                // The propid used here is a "dummy" one, used as place
                // holder to tell mqads code to remove the owner.
                //
                cpEx = 1 ;
                propIdEx = PROPID_Q_DEFAULT_SECURITY ;
                ppropIdEx = &propIdEx ;
            }

            hr = MQSec_GetDefaultSecDescriptor( dwObjectType,
                                           &pDefaultSecurityDescriptor,
                                            fImpersonate,
                                            pSecurityDescriptor,
                                            0, // seInfoToRemove,
                                            e_UseDefaultDacl ) ;
            if (FAILED(hr))
            {
                ASSERT(SUCCEEDED(hr));
                UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,
                                g_pdsCounters->nErrorsReturnedToApp++) ;
                LogHR(hr, s_FN, 80);
                return MQ_ERROR_ACCESS_DENIED;
            }
            pSecurityDescriptor = pDefaultSecurityDescriptor;
        }

        //
        //  Set default values for all the object properties,
        //  that were not provided by the caller
        //
        hr = SetDefaultValues(
                    dwObjectType,
                    pwcsPathName,
                    pSecurityDescriptor,
                    pUserSid,
                    cp,
                    aProp,
                    apVar,
                    &cpObject,
                    &pPropObject,
                    &pVarObject);
        if (FAILED(hr))
        {
            //
            // Update the error count of errors returned to application
            //
            UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)

            return LogHR(hr, s_FN, 90);
        }

        if (dwObjectType == MQDS_USER)
        {
            hr = VerifyInternalCert( cpObject,
                                     pPropObject,
                                     pVarObject,
                                    &pMachineSid );
            if (FAILED(hr))
            {
                //
                // Update the error count of errors returned to application
                //
                UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)

                return LogHR(hr, s_FN, 100);
            }
        }

        CDSRequestContext requestContext(fImpersonate, e_IP_PROTOCOL);
        if (dwObjectType == MQDS_MACHINE)
        {
            //
            // Bug 5241.
            // To support setup from nt4 machines, or win9x ones, when
            // logged on user is nt4 user. This setting (when fIsKerberos is
            // FALSE) will cause dscore to use server binding
            // (LDPA://server/path). Server binding is needed when called
            // from nt4 users.
            // For all other types of objects, the dscore code know how to
            // handle such nt4 users correctly.
            //
            requestContext.SetKerberos( fIsKerberos ) ;
        }

        hr = MQDSCreateObject( dwObjectType,
                               pwcsPathName,
                               cpObject,
                               pPropObject,
                               pVarObject,
                               cpEx,
                               ppropIdEx,
                               NULL,
                               &requestContext,
                               pObjGuid);
        if (FAILED(hr))
        {
            //
            // Update the error count of errors returned to application
            //
            UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)
            return LogHR(hr, s_FN, 110);
        }

        return LogHR(hr, s_FN, 120);
    }
    catch(const bad_alloc&)
    {
        //
        // Update the error count of errors returned to application
        //
        UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)

        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("Error -  EXCEPTION in DSCreateObject")));
        return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 130);
    }
}

/*====================================================

DSCreateObject

Arguments:

Return Value:

=====================================================*/

EXTERN_C
HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSCreateObject( IN  DWORD                  dwObjectType,
                IN  LPCWSTR                pwcsPathName,
                IN  PSECURITY_DESCRIPTOR   pSecurityDescriptor,
                IN  DWORD                  cp,
                IN  PROPID                 aProp[],
                IN  PROPVARIANT            apVar[],
                OUT GUID*                  pObjGuid )
{
    HRESULT hr = DSCreateObjectInternal( dwObjectType,
                                         pwcsPathName,
                                         pSecurityDescriptor,
                                         cp,
                                         aProp,
                                         apVar,
                                         TRUE /* fKerberos */,
                                         pObjGuid ) ;
    return LogHR(hr, s_FN, 2130);
}

/*====================================================

DSDeleteObjectInternal

Arguments:

Return Value:

=====================================================*/

HRESULT DSDeleteObjectInternal( IN  DWORD    dwObjectType,
                                IN  LPCWSTR  pwcsPathName )
{
    HRESULT hr;
    BOOL fImpersonate;

    //
    // Update the access count to the server (performace info only)
    //
    UPDATE_COUNTER(&g_pdsCounters->nAccessServer,g_pdsCounters->nAccessServer++)

    try
    {
        STORE_AND_CLEAR_IMPERSONATION_FLAG(dwObjectType, fImpersonate);

        CDSRequestContext requestContext( fImpersonate, e_IP_PROTOCOL);

        hr = MQDSDeleteObject( dwObjectType,
                               pwcsPathName,
                               NULL,
                               &requestContext) ;
        if (FAILED(hr))
        {
            //
            // Update the error count of errors returned to application
            //
            UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)
        }
        return LogHR(hr, s_FN, 140);
    }
    catch(const bad_alloc&)
    {
        //
        // Update the error count of errors returned to application
        //
        UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)

        DBGMSG((DBGMOD_DS, DBGLVL_ERROR,
                TEXT("Error -  EXCEPTION in DSDeleteObject")));
        return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 150);
    }
}

/*====================================================

DSDeleteObject

Arguments:

Return Value:

=====================================================*/

EXTERN_C
HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSDeleteObject( IN  DWORD     dwObjectType,
                IN  LPCWSTR   pwcsPathName )
{
    HRESULT hr = DSDeleteObjectInternal( dwObjectType,
                                         pwcsPathName ) ;
    return LogHR(hr, s_FN, 170);
}

/*====================================================

DSGetObjectProperties

Arguments:

Return Value:

=====================================================*/

EXTERN_C
HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSGetObjectProperties(
                       IN  DWORD                    dwObjectType,
                       IN  LPCWSTR                  pwcsPathName,
                       IN  DWORD                    cp,
                       IN  PROPID                   aProp[],
                       IN  PROPVARIANT              apVar[])
{
    HRESULT hr;
    BOOL fImpersonate;

    //
    // Update the access count to the server (performace info only)
    //
    UPDATE_COUNTER(&g_pdsCounters->nAccessServer,g_pdsCounters->nAccessServer++)

    try
    {
        STORE_AND_CLEAR_IMPERSONATION_FLAG(dwObjectType, fImpersonate);

        hr = ValidateProperties(cp, aProp);
        if (!SUCCEEDED(hr))
        {
            //
            // Update the error count of errors returned to application
            //
            UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)

            return LogHR(hr, s_FN, 180);
        }
        CDSRequestContext requestContext(fImpersonate, e_IP_PROTOCOL);

        hr = MQDSGetProps( dwObjectType,
                           pwcsPathName,
                           NULL,
                           cp,
                           aProp,
                           apVar,
                           &requestContext);
        if (FAILED(hr))
        {
            //
            // Update the error count of errors returned to application
            //
            UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)
        }
        return LogHR(hr, s_FN, 190);
    }
    catch(const bad_alloc&)
    {
        //
        // Update the error count of errors returned to application
        //
        UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)

        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("Error -  EXCEPTION in DSGetObjectProperties")));
        return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 200);
    }
}

/*====================================================

DSSetObjectPropertiesInternal

Arguments:

Return Value:

=====================================================*/

HRESULT
DSSetObjectPropertiesInternal( IN  DWORD         dwObjectType,
                               IN  LPCWSTR       pwcsPathName,
                               IN  DWORD         cp,
                               IN  PROPID        aProp[],
                               IN  PROPVARIANT   apVar[] )
{
    HRESULT hr;
    BOOL fImpersonate;

    //
    // Update the access count to the server (performace info only)
    //
    UPDATE_COUNTER(&g_pdsCounters->nAccessServer,g_pdsCounters->nAccessServer++)

    try
    {
        STORE_AND_CLEAR_IMPERSONATION_FLAG(dwObjectType, fImpersonate);

        //
        //  Only for RPC calls we would like to continue and verify which props 
        //  are asked for ( and this is only to keep the same functionalty as before).
        //  For QM calls we want to enable also retrive of "private" properties and thus
        //  to eliminate the need to call GetObjectSecurity...
        //
        if (fImpersonate)
        {
            hr = ValidateProperties(cp, aProp);
            if (!SUCCEEDED(hr))
            {
                //
                // Update the error count of errors returned to application
                //
                UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)

                return LogHR(hr, s_FN, 210);
            }
        }

        CDSRequestContext requestContext(fImpersonate, e_IP_PROTOCOL);

        hr = MQDSSetProps(  dwObjectType,
                            pwcsPathName,
                            NULL,
                            cp,
                            aProp,
                            apVar,
                            &requestContext);

        if (FAILED(hr))
        {
            //
            // Update the error count of errors returned to application
            //
            UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)
        }
        return LogHR(hr, s_FN, 220);
    }
    catch(const bad_alloc&)
    {
        //
        // Update the error count of errors returned to application
        //
        UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)

        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("Error -  EXCEPTION in DSSetObjectProperties")));
        return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 230);
    }
}

/*====================================================

DSSetObjectProperties

Arguments:

Return Value:

=====================================================*/

EXTERN_C
HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSSetObjectProperties(
                       IN  DWORD                    dwObjectType,
                       IN  LPCWSTR                  pwcsPathName,
                       IN  DWORD                    cp,
                       IN  PROPID                   aProp[],
                       IN  PROPVARIANT              apVar[])
{
    HRESULT hr = DSSetObjectPropertiesInternal( dwObjectType,
                                                pwcsPathName,
                                                cp,
                                                aProp,
                                                apVar ) ;
    return LogHR(hr, s_FN, 240);
}

/*====================================================

DSLookupBegin

Arguments:

Return Value:

=====================================================*/

EXTERN_C
HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSLookupBegin(
                IN  LPWSTR                  pwcsContext,
                IN  MQRESTRICTION*          pRestriction,
                IN  MQCOLUMNSET*            pColumns,
                IN  MQSORTSET*              pSort,
                OUT PHANDLE                 phEnume)
{
    HRESULT hr;
    BOOL fImpersonate;
    *phEnume = NULL;

    //
    // Update the access count to the server (performace info only)
    //
    UPDATE_COUNTER(&g_pdsCounters->nAccessServer,g_pdsCounters->nAccessServer++)

    try
    {
        STORE_AND_CLEAR_IMPERSONATION_FLAG(pColumns->cCol, fImpersonate);

        if (pRestriction)
        {
            hr = ValidateRestrictions(pRestriction->cRes, pRestriction->paPropRes);
            if (!SUCCEEDED(hr)) {

                //
                // Update the error count of errors returned to application
                //
                UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)

                return LogHR(hr, s_FN, 250);
            }
        }

       if ( pColumns->cCol == 0)
       {
            return LogHR(MQ_ERROR_ILLEGAL_MQCOLUMNS, s_FN, 260);
       }
       hr = ValidateProperties(pColumns->cCol, pColumns->aCol);


        if (!SUCCEEDED(hr)) {
            //
            // Update the error count of errors returned to application
            //
            UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)

            return LogHR(hr, s_FN, 270);
        }

        CDSRequestContext requestContext(fImpersonate, e_IP_PROTOCOL);

        hr = MQDSLookupBegin( pwcsContext,
                              pRestriction,
                              pColumns,
                              pSort,
                              phEnume,
                              &requestContext);

        if (FAILED(hr))
        {
            //
            // Update the error count of errors returned to application
            //
            UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)
        }
        return LogHR(hr, s_FN, 280);
    }
    catch(const bad_alloc&)
    {
        //
        // Update the error count of errors returned to application
        //
        UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)

        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("Error -  EXCEPTION in DSLookupBegin")));
        return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 290);
    }
}

/*====================================================

DSLookupNaxt

Arguments:

Return Value:

=====================================================*/

EXTERN_C
HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSLookupNext(
                IN      HANDLE          hEnum,
                IN OUT  DWORD*          pcProps,
                OUT     PROPVARIANT     aPropVar[])
{
    HRESULT hr;

    //
    // Update the access count to the server (performace info only)
    //
    UPDATE_COUNTER(&g_pdsCounters->nAccessServer,g_pdsCounters->nAccessServer++)

    try
    {

        hr = MQDSLookupNext( hEnum,
                             pcProps,
                             aPropVar);

        if (FAILED(hr))
        {
            //
            // Update the error count of errors returned to application
            //
            UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)
        }

        return LogHR(hr, s_FN, 300);
    }
    catch(const bad_alloc&)
    {
        //
        // Update the error count of errors returned to application
        //
        UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)

        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("Error -  EXCEPTION in DSLookupNext")));
        return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 310);
    }
}


/*====================================================

DSLookupEnd

Arguments:

Return Value:

=====================================================*/

EXTERN_C
HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSLookupEnd(
                IN  HANDLE                  hEnum)
{
    HRESULT hr;

    if ( hEnum == 0 )
    {
        return LogHR(MQ_ERROR_INVALID_HANDLE, s_FN, 320);
    }

    //
    // Update the access count to the server (performace info only)
    //
    UPDATE_COUNTER(&g_pdsCounters->nAccessServer,g_pdsCounters->nAccessServer++)

    try
    {
        hr = MQDSLookupEnd( hEnum);
        if (FAILED(hr))
        {
            //
            // Update the error count of errors returned to application
            //
            UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)
        }

        return LogHR(hr, s_FN, 330);
    }
    catch(const bad_alloc&)
    {
        //
        // Update the error count of errors returned to application
        //
        UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)

        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("Error -  EXCEPTION in DSLookupEnd")));
        return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 340);
    }
}

/*====================================================

DSInit

Arguments:

  See ..\mqdscli\dsapi.cpp

Return Value:

=====================================================*/

extern HMODULE  g_hInstance ;

EXTERN_C
HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSInit( 
	QMLookForOnlineDS_ROUTINE pfnLookDS       /* =NULL */,
	MQGetMQISServer_ROUTINE   pGetServers     /* =NULL */,
	BOOL                      fReserved       /* =FALSE */,
	BOOL                      fSetupMode      /* =FALSE */,
	BOOL                      fQMDll          /* =FALSE */,
	NoServerAuth_ROUTINE      pNoServerAuth   /* =NULL */,
	LPCWSTR                   szServerName    /* =NULL */
	)
{
#ifdef _DEBUG
    TCHAR tszFileName[MAX_PATH * 2];
    DWORD dwGet = GetModuleFileName( 
						g_hInstance,
						tszFileName,
						(MAX_PATH * 2) 
						);
    if (dwGet)
    {
        DWORD dwLen = lstrlen( tszFileName );
        lstrcpy(&tszFileName[ dwLen - 3 ], TEXT("ini"));

        UINT uiDbg = GetPrivateProfileInt(
						TEXT("Debug"),
						TEXT("StopBeforeInit"),
						0,
						tszFileName 
						);
        if (uiDbg)
        {
            ASSERT(0);
        }
    }
#endif

	//
	// server doesn't need those parameters.
	//
    ASSERT(pfnLookDS == NULL) ; 
    ASSERT(pGetServers == NULL);
    ASSERT(fReserved == FALSE);
    ASSERT(fSetupMode == FALSE);
    ASSERT(fQMDll == FALSE);
    ASSERT(pNoServerAuth == NULL) ;
    ASSERT(szServerName == NULL);

    HRESULT hr = MQ_OK;

    //
    //  Init DS provider
    //
    hr = MQDSInit();

    if ( FAILED(hr))
    {
        LogHR(hr, s_FN, 360);
        //
        // Update the error count of errors returned to application
        //
        UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)

        if (hr == MQ_ERROR_NOT_TRUSTED_DELEGATION)
        {
            ; // do nothing more
        }
        else
        {
			hr = MQ_ERROR_NO_DS;
        }
        return hr;
    }
    else
    {
		//
		// Update the access count to the server (performace info only)
		//
		UPDATE_COUNTER(&g_pdsCounters->nAccessServer,g_pdsCounters->nAccessServer++)
    }

    //
    // Init RPC interface of this site controller
    // Not needed in setup mode.
	//
    RPC_STATUS status = RpcServerInit();
    LogRPCStatus(status, s_FN, 400);

    return hr;
}


/*====================================================

DSGetObjectSecurity

Arguments:

Return Value:


=====================================================*/
EXTERN_C
HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSGetObjectSecurity(
                IN  DWORD                   dwObjectType,
                IN  LPCWSTR                  pwcsPathName,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor,
                IN  DWORD                   nLength,
                IN  LPDWORD                 lpnLengthNeeded)
{
    HRESULT hr;
    BOOL fImpersonate;

    //
    // Update the access count to the server (performace info only)
    //
    UPDATE_COUNTER(&g_pdsCounters->nAccessServer,g_pdsCounters->nAccessServer++)

    try
    {
        STORE_AND_CLEAR_IMPERSONATION_FLAG(dwObjectType, fImpersonate);

        CDSRequestContext requestContext(fImpersonate, e_IP_PROTOCOL);

        hr = MQDSGetObjectSecurity(dwObjectType,
                                   pwcsPathName,
                                   NULL,
                                   RequestedInformation,
                                   pSecurityDescriptor,
                                   nLength,
                                   lpnLengthNeeded,
                                   &requestContext);

        if (FAILED(hr))
        {
            LogHR(hr, s_FN, 410);
            //
            // Update the error count of errors returned to application
            //
            UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)
        }

        return(hr);
    }
    catch(const bad_alloc&)
    {
        //
        // Update the error count of errors returned to application
        //
        UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)

        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("Error -  EXCEPTION in DSGetObjectSecurity")));
        return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 420);
    }
}

/*====================================================

DSSetObjectSecurity

Arguments:

Return Value:


=====================================================*/
EXTERN_C
HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSSetObjectSecurity(
                IN  DWORD                   dwObjectType,
                IN  LPCWSTR                 pwcsPathName,
                IN  SECURITY_INFORMATION    SecurityInformation,
                IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor)
{
    HRESULT hr;
    BOOL fImpersonate;

    //
    // Update the access count to the server (performace info only)
    //
    UPDATE_COUNTER(&g_pdsCounters->nAccessServer,g_pdsCounters->nAccessServer++)

    try
    {
        STORE_AND_CLEAR_IMPERSONATION_FLAG(dwObjectType, fImpersonate);


        CDSRequestContext requestContext(fImpersonate, e_IP_PROTOCOL);

        hr = MQDSSetObjectSecurity(dwObjectType,
                                   pwcsPathName,
                                   NULL,
                                   SecurityInformation,
                                   pSecurityDescriptor,
                                   &requestContext);

        if (FAILED(hr))
        {
            //
            // Update the error count of errors returned to application
            //
            UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)
        }

        return LogHR(hr, s_FN, 430);
    }
    catch(const bad_alloc&)
    {
        //
        // Update the error count of errors returned to application
        //
        UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)

        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("Error -  EXCEPTION in DSSetObjectSecurity")));
        return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 440);
    }
}
/*====================================================

DSGetObjectSecurityGuid

Arguments:

Return Value:


=====================================================*/
HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSGetObjectSecurityGuid(
                IN  DWORD                   dwObjectType,
                IN  CONST GUID*             pObjectGuid,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor,
                IN  DWORD                   nLength,
                IN  LPDWORD                 lpnLengthNeeded)
{
    HRESULT hr;
    BOOL fImpersonate;

    //
    // Update the access count to the server (performace info only)
    //
    UPDATE_COUNTER(&g_pdsCounters->nAccessServer,g_pdsCounters->nAccessServer++)

    try
    {
        STORE_AND_CLEAR_IMPERSONATION_FLAG(dwObjectType, fImpersonate);

        if (RequestedInformation &
              (MQDS_KEYX_PUBLIC_KEY | MQDS_SIGN_PUBLIC_KEY))
        {
            ASSERT((RequestedInformation &
                   ~(MQDS_KEYX_PUBLIC_KEY | MQDS_SIGN_PUBLIC_KEY)) == 0) ;
            //
            // We bypass ADS access check and make this query with the
            // credential of local msmq service. This query fetch the
            // public key of a machine from ADS, so it's not a serious
            // security hole.
            // hey, "public key" is a public domain data, isn't it ?
            //
            // The reason we absolutely need this hole is as follow:
            // in mixed mode, if Windows 2000 ex-PEC renew its crypto keys,
            // all NT4 PSC will call this function to retrieve the new
            // public key. NT4 msmq service is impersonated as anonymous
            // user. If DACL is such that this query fail for anonymous
            // user, then all NT4 PSCs can no longer get replications from
            // Windows 2000 world.
            // So the possible damage is orders of magnitude more severe
            // than the possible hole opened here.
            //
            fImpersonate = FALSE ;
        }

        CDSRequestContext requestContext(fImpersonate, e_IP_PROTOCOL);

        hr = MQDSGetObjectSecurity(dwObjectType,
                                   NULL,
                                   pObjectGuid,
                                   RequestedInformation,
                                   pSecurityDescriptor,
                                   nLength,
                                   lpnLengthNeeded,
                                   &requestContext);

        if (FAILED(hr))
        {
            //
            // Update the error count of errors returned to application
            //
            UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)
        }
        return LogHR(hr, s_FN, 450);
    }
    catch(const bad_alloc&)
    {
        //
        // Update the error count of errors returned to application
        //
        UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)

        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("Error -  EXCEPTION in DSGetObjectSecurityGuid")));
        return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 460);
    }
}

/*====================================================

DSSetObjectSecurityGuidInternal

Arguments:

Return Value:

=====================================================*/

HRESULT
DSSetObjectSecurityGuidInternal(
                IN  DWORD                   dwObjectType,
                IN  CONST GUID*             pObjectGuid,
                IN  SECURITY_INFORMATION    SecurityInformation,
                IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor,
                IN  BOOL                    fIsKerberos )
{
    HRESULT hr;
    BOOL fImpersonate;

    //
    // Update the access count to the server (performace info only)
    //
    UPDATE_COUNTER(&g_pdsCounters->nAccessServer,g_pdsCounters->nAccessServer++)

    try
    {
        STORE_AND_CLEAR_IMPERSONATION_FLAG(dwObjectType, fImpersonate);


        CDSRequestContext requestContext(fImpersonate, e_IP_PROTOCOL);
        requestContext.SetKerberos( fIsKerberos ) ;

        hr = MQDSSetObjectSecurity(dwObjectType,
                                   NULL,
                                   pObjectGuid,
                                   SecurityInformation,
                                   pSecurityDescriptor,
                                   &requestContext);
        if (FAILED(hr))
        {
            LogHR(hr, s_FN, 470);
            if ((dwObjectType == MQDS_QUEUE) &&
                ((SecurityInformation & OWNER_SECURITY_INFORMATION) ==
                                               OWNER_SECURITY_INFORMATION))
            {
                //
                // On Windows 2000, queue may be created by local msmq service
                // on behalf of users on local machine. In that case, the
                // owner is the computer account, not the user. So for
                // not breaking existing applications, we won't fail
                // this call if owner was not set. rather, we'll ignore
                // the owner.
                //
                SecurityInformation &= (~OWNER_SECURITY_INFORMATION) ;
                if (SecurityInformation != 0)
                {
                    //
                    // If caller wanted to change only owner, and first
                    // try failed, then don't try again with nothing...
                    //
                    hr = MQDSSetObjectSecurity( dwObjectType,
                                                NULL,
                                                pObjectGuid,
                                                SecurityInformation,
                                                pSecurityDescriptor,
                                               &requestContext );
                    if (hr == MQ_OK)
                    {
                        hr = MQ_INFORMATION_OWNER_IGNORED ;
                    }
                    LogHR(hr, s_FN, 475) ;
                }
            }
        }

        if (FAILED(hr))
        {
            //
            // Update the error count of errors returned to application
            //
            UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)
        }

        return (hr);
    }
    catch(const bad_alloc&)
    {
        //
        // Update the error count of errors returned to application
        //
        UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)

        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("Error -  EXCEPTION in DSSetObjectSecurityGuid")));
        return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 480);
    }
}

/*====================================================

DSSetObjectSecurityGuid

Arguments:

Return Value:

=====================================================*/

HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSSetObjectSecurityGuid(
                IN  DWORD                   dwObjectType,
                IN  CONST GUID*             pObjectGuid,
                IN  SECURITY_INFORMATION    SecurityInformation,
                IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor)
{
    HRESULT hr =DSSetObjectSecurityGuidInternal(
                                        dwObjectType,
                                        pObjectGuid,
                                        SecurityInformation,
                                        pSecurityDescriptor,
                                        TRUE /* fKerberos */) ;
    return hr ;
}

/*====================================================

DSDeleteObjectGuidInternal

Arguments:

Return Value:

=====================================================*/

HRESULT DSDeleteObjectGuidInternal( IN  DWORD        dwObjectType,
                                    IN  CONST GUID*  pObjectGuid,
                                    IN  BOOL         fIsKerberos )
{
    HRESULT hr;
    BOOL fImpersonate;

    //
    // Update the access count to the server (performace info only)
    //
    UPDATE_COUNTER(&g_pdsCounters->nAccessServer,g_pdsCounters->nAccessServer++)

    try
    {
        STORE_AND_CLEAR_IMPERSONATION_FLAG(dwObjectType, fImpersonate);

        CDSRequestContext requestContext(fImpersonate, e_IP_PROTOCOL);
        requestContext.SetKerberos( fIsKerberos ) ;

        hr = MQDSDeleteObject( dwObjectType,
                               NULL,
                               pObjectGuid,
                               &requestContext);

        if (FAILED(hr))
        {
            //
            // Update the error count of errors returned to application
            //
            UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)
        }
        return LogHR(hr, s_FN, 490);
    }
    catch(const bad_alloc&)
    {
        //
        // Update the error count of errors returned to application
        //
        UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)

        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("Error -  EXCEPTION in DSDeleteObjectGuid")));
        return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 500);
    }

}
/*====================================================

DSDeleteObjectGuid

Arguments:

Return Value:

=====================================================*/

HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSDeleteObjectGuid(
                IN  DWORD                   dwObjectType,
                IN  CONST GUID*             pObjectGuid)
{
    HRESULT hr = DSDeleteObjectGuidInternal( dwObjectType,
                                             pObjectGuid,
                                             TRUE /* fKerberos */) ;
    return LogHR(hr, s_FN, 510);
}

/*====================================================

DSGetObjectPropertiesGuid

Arguments:

Return Value:


=====================================================*/

HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSGetObjectPropertiesGuid(
                IN  DWORD                   dwObjectType,
                IN  CONST GUID*             pObjectGuid,
                IN  DWORD                   cp,
                IN  PROPID                  aProp[],
                IN  PROPVARIANT             apVar[])
{
    HRESULT hr;
    BOOL fImpersonate;

    //
    // Update the access count to the server (performace info only)
    //
    UPDATE_COUNTER(&g_pdsCounters->nAccessServer,g_pdsCounters->nAccessServer++)

    try
    {
        STORE_AND_CLEAR_IMPERSONATION_FLAG(dwObjectType, fImpersonate);

        hr = ValidateProperties(cp, aProp);
        if (!SUCCEEDED(hr))
        {
            //
            // Update the error count of errors returned to application
            //
            UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)

            return LogHR(hr, s_FN, 520);
        }

        CDSRequestContext requestContext(fImpersonate, e_IP_PROTOCOL);

        hr = MQDSGetProps( dwObjectType,
                           NULL,
                           pObjectGuid,
                           cp,
                           aProp,
                           apVar,
                           &requestContext);
        if (FAILED(hr))
        {
            //
            // Update the error count of errors returned to application
            //
            UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)
        }

        return LogHR(hr, s_FN, 530);
    }
    catch(const bad_alloc&)
    {
        //
        // Update the error count of errors returned to application
        //
        UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)

        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("Error -  EXCEPTION in DSGetObjectPropertiesGuid")));
        return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 540);
    }
}

/*====================================================

DSSetObjectPropertiesGuidIntenral

Arguments:

Return Value:


=====================================================*/

HRESULT
DSSetObjectPropertiesGuidInternal(
                IN  DWORD                   dwObjectType,
                IN  CONST GUID*             pObjectGuid,
                IN  DWORD                   cp,
                IN  PROPID                  aProp[],
                IN  PROPVARIANT             apVar[],
                IN  BOOL                    fIsKerberos )
{
    HRESULT hr;
    BOOL fImpersonate;

    //
    // Update the access count to the server (performace info only)
    //
    UPDATE_COUNTER(&g_pdsCounters->nAccessServer,g_pdsCounters->nAccessServer++)

    try
    {
        STORE_AND_CLEAR_IMPERSONATION_FLAG(dwObjectType, fImpersonate);

        hr = ValidateProperties(cp, aProp);
        if (!SUCCEEDED(hr))
        {
            //
            // Update the error count of errors returned to application
            //
            UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)

            return LogHR(hr, s_FN, 560);
        }


        CDSRequestContext requestContext(fImpersonate, e_IP_PROTOCOL);
        requestContext.SetKerberos( fIsKerberos ) ;

        hr = MQDSSetProps(  dwObjectType,
                            NULL,
                            pObjectGuid,
                            cp,
                            aProp,
                            apVar,
                            &requestContext);
        if (FAILED(hr))
        {
            //
            // Update the error count of errors returned to application
            //
            UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)
        }

        return LogHR(hr, s_FN, 570);
    }
    catch(const bad_alloc&)
    {
        //
        // Update the error count of errors returned to application
        //
        UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)

        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("Error -  EXCEPTION in DSSetObjectPropertiesGuid")));
        return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 580);
    }
}

/*====================================================

DSSetObjectPropertiesGuid

Arguments:

Return Value:

=====================================================*/

HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSSetObjectPropertiesGuid(
                IN  DWORD                   dwObjectType,
                IN  CONST GUID*             pObjectGuid,
                IN  DWORD                   cp,
                IN  PROPID                  aProp[],
                IN  PROPVARIANT             apVar[])
{
    HRESULT hr = DSSetObjectPropertiesGuidInternal( dwObjectType,
                                                    pObjectGuid,
                                                    cp,
                                                    aProp,
                                                    apVar,
                                                    TRUE /* fKerberos */) ;
    return hr ;
}


/*====================================================

DSGetUserParams

Arguments:

Return Value:


=====================================================*/
EXTERN_C
HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSGetUserParams(
    DWORD dwFlags,
    DWORD dwSidLength,
    PSID pUserSid,
    DWORD *pdwSidReqLength,
    LPWSTR szAccountName,
    DWORD *pdwAccountNameLen,
    LPWSTR szDomainName,
    DWORD *pdwDomainNameLen
    )
{
    HRESULT hr = MQ_OK;

    //
    // Update the access count to the server (performace info only)
    //
    UPDATE_COUNTER(&g_pdsCounters->nAccessServer,g_pdsCounters->nAccessServer++)

    BOOL fImpersonate;
    STORE_AND_CLEAR_IMPERSONATION_FLAG(dwSidLength, fImpersonate);

    try
    {
        if (dwFlags & GET_USER_PARAM_FLAG_SID)
        {
            //
            // Get the SID of the calling user.
            //
            AP<char> pSDOwner;
            PSID pOwner;
            BOOL bDefaulted;

            // Get the default security descriptor and extract the owner.
            hr = MQSec_GetDefaultSecDescriptor( MQDS_QUEUE,
                                   (PSECURITY_DESCRIPTOR*)(char*)&pSDOwner,
                                          fImpersonate,
                                          NULL,
                                          DACL_SECURITY_INFORMATION, // seInfoToRemove
                                          e_UseDefaultDacl ) ;
            ASSERT(SUCCEEDED(hr)) ;
            if (FAILED(hr))
            {
                UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,
                                g_pdsCounters->nErrorsReturnedToApp++) ;
                LogHR(hr, s_FN, 640);
                return MQ_ERROR_ACCESS_DENIED;
            }

            BOOL bRet = GetSecurityDescriptorOwner( pSDOwner,
                                                   &pOwner,
                                                   &bDefaulted );
            ASSERT(bRet);

            BOOL fAnonymus = MQSec_IsAnonymusSid( pOwner ) ;
            if (fAnonymus)
            {
                UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)
                return LogHR(MQ_ERROR_ILLEGAL_USER, s_FN, 650);
            }

            // Prepare the result.
            *pdwSidReqLength = GetLengthSid(pOwner);
            ASSERT(*pdwSidReqLength);
            if (dwSidLength >= *pdwSidReqLength)
            {
                bRet = CopySid(dwSidLength, pUserSid, pOwner);
                ASSERT(bRet);
                hr = MQ_OK;
            }
            else
            {
                // Buffer is too small.
                hr = MQ_ERROR_SENDERID_BUFFER_TOO_SMALL;
            }
        }

        if (SUCCEEDED(hr) && (dwFlags & GET_USER_PARAM_FLAG_ACCOUNT))
        {
            //
            // Get the account name and account domain of the calling user.
            //
            char Sid_buff[64];
            PSID pLocSid;
            AP<char> pLongSidBuff;

            //
            // Get the SID of the calling user. Either use the value that was
            // previously obtained in this call, or call this function with
            // the GET_USER_PARAM_FLAG_SID flags set.
            //
            if (dwFlags & GET_USER_PARAM_FLAG_SID)
            {
                pLocSid = pUserSid;
            }
            else
            {
                DWORD dwReqLen;

                pLocSid = (PSID)Sid_buff;
                hr = DSGetUserParams(
                        GET_USER_PARAM_FLAG_SID,
                        (DWORD)sizeof(Sid_buff) |
                            (fImpersonate ? IMPERSONATE_CLIENT_FLAG : 0),
                        pLocSid,
                        &dwReqLen,
                        NULL,
                        NULL,
                        NULL,
                        NULL);
                if (FAILED(hr))
                {
                    if (hr == MQ_ERROR_SENDERID_BUFFER_TOO_SMALL)
                    {
                        pLocSid = pLongSidBuff = new char[dwReqLen];
                        hr = DSGetUserParams(
                                GET_USER_PARAM_FLAG_SID,
                                dwReqLen |
                                    (fImpersonate ? IMPERSONATE_CLIENT_FLAG : 0),
                                pLocSid,
                                &dwReqLen,
                                NULL,
                                NULL,
                                NULL,
                                NULL);
                    }
                }
            }

            if (SUCCEEDED(hr))
            {
                SID_NAME_USE eUse;
                if (!LookupAccountSid(
                        NULL,
                        pLocSid,
                        szAccountName,
                        pdwAccountNameLen,
                        szDomainName,
                        pdwDomainNameLen,
                        &eUse))
                {
                    if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
                    {
                        *szAccountName = '\0';
                        *szDomainName = '\0';
                        hr = MQ_ERROR_USER_BUFFER_TOO_SMALL;
                    }
                    else
                    {
                        hr = MQ_ERROR_COULD_NOT_GET_ACCOUNT_INFO;
                    }
                }
            }
            else
            {
                if (hr != MQ_ERROR_ILLEGAL_USER)
                {
                    hr = MQ_ERROR_COULD_NOT_GET_USER_SID;
                }
                else
                {
                    // The error was already counted.
                    return LogHR(hr, s_FN, 660);
                }
            }
        }
    }
    catch(const bad_alloc&)
    {
        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("Error -  EXCEPTION in DSGetUseParam")));

        hr = MQ_ERROR_INSUFFICIENT_RESOURCES;
    }

    if (FAILED(hr))
    {
        UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)
    }

    return LogHR(hr, s_FN, 670);
}

/*====================================================

DSTerminate

Arguments:      None

Return Value:   None

=====================================================*/
EXTERN_C
void
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSTerminate()
{
    //
    //  Terminate DS provider
    //
    MQDSTerminate();
}

/*====================================================

DSQMSetMachineProperties

Arguments:      None

Return Value:   None

=====================================================*/
EXTERN_C
HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSQMSetMachineProperties(
    IN  LPCWSTR          pwcsPathName,
    IN  DWORD            cp,
    IN  PROPID           aProp[],
    IN  PROPVARIANT      apVar[],
    IN  DSQMChallengeResponce_ROUTINE pfSignProc,
    IN  DWORD_PTR        dwContext
    )
{
    HRESULT hr;
    BYTE abChallenge[32];
    DWORD dwChallengeSize = sizeof(abChallenge);
    BYTE abSignature[128];
    DWORD dwSignatureMaxSize = sizeof(abSignature);
    DWORD dwSignatureSize = 0;
    struct DSQMSetMachinePropertiesStruct s;
    BOOL fImpersonate = dwContext != 0; // We get dwContext == 0 when we're
                                        // called directly (not via RPC), so
                                        // we should not try to impersonate.

    //
    // Update the access count to the server (performace info only)
    //
    UPDATE_COUNTER(&g_pdsCounters->nAccessServer,g_pdsCounters->nAccessServer++)

    try
    {

        //
        // Generate the challenge.
        //
        HCRYPTPROV  hProv = NULL ;
        hr = MQSec_AcquireCryptoProvider( eBaseProvider,
                                         &hProv ) ;
        if (!hProv || !CryptGenRandom(hProv, dwChallengeSize, abChallenge))
        {
            hr = MQ_ERROR_CORRUPTED_SECURITY_DATA;
        }
        else
        {

            //
            // if (dwContext != 0) we were called via RPC.
            //
            if (!dwContext)
            {
                dwContext = (DWORD_PTR)&s;

                s.cp = cp;
                s.aProp = aProp;
                s.apVar = apVar;
            }

            //
            // Call back to sign the challenge and the properties.
            //
            try
            {
                hr = (*pfSignProc)(
                            abChallenge,
                            dwChallengeSize,
                            dwContext,
                            abSignature,
                            &dwSignatureSize,
                            dwSignatureMaxSize);
            }
            catch(...)
            {
                //
                // Protect from RPC exceptions.
                //
                // Do not bother to assign some meaning full error code, since
                // we're going to call the normal DS api and the result of this
                // call is going to be the returned result.
                //
                hr = MQ_ERROR;
            }

            if (SUCCEEDED(hr))
            {
                //
                // Call MQIS. It'll validate the signature. If the signature is OK,
                // it'll set the properties.
                //
                hr = MQDSQMSetMachineProperties(
                        pwcsPathName,
                        cp,
                        aProp,
                        apVar,
                        abChallenge,
                        dwChallengeSize,
                        abSignature,
                        dwSignatureSize);
            }
        }

        if (FAILED(hr))
        {
            //
            // If we failed to set the properties by signing the properties,
            // try to do this in the usual way.
            //
            hr = DSSetObjectProperties(
                    MQDS_MACHINE | (fImpersonate ? IMPERSONATE_CLIENT_FLAG : 0),
                    pwcsPathName,
                    cp,
                    aProp,
                    apVar);
        }
    }
    catch(const bad_alloc&)
    {
        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("Error -  EXCEPTION in DSQMSetMachineProperties")));

        hr = MQ_ERROR_INSUFFICIENT_RESOURCES;
    }

    if (FAILED(hr))
    {
        UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)
    }

    return LogHR(hr, s_FN, 673);
}

/*======================================================================

 DSCreateServersCache

This function is called only from local QM, only on MQIS servers. It's
never called from clients through RPC. The RPC calls from clients are
processed in dsifsrv.cpp, where results are read from registry, without
querying local MQIS database.

Arguments:      None

Return Value:   None

========================================================================*/

EXTERN_C
HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSCreateServersCache()
{
    HRESULT hr = MQDSCreateServersCache() ;
    return LogHR(hr, s_FN, 676);
}

/*====================================================

DSQMGetObjectSecurity

Arguments:      None

Return Value:   None

=====================================================*/
EXTERN_C
HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSQMGetObjectSecurity(
    IN  DWORD                   dwObjectType,
    IN  CONST GUID*             pObjectGuid,
    IN  SECURITY_INFORMATION    RequestedInformation,
    IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor,
    IN  DWORD                   nLength,
    IN  LPDWORD                 lpnLengthNeeded,
    IN  DSQMChallengeResponce_ROUTINE
                                pfChallengeResponceProc,
    IN  DWORD_PTR               dwContext
    )
{
    HRESULT hr;
    BYTE abChallenge[32];
    DWORD dwChallengeSize = sizeof(abChallenge);
    BYTE abChallengeResponce[128];
    DWORD dwChallengeResponceMaxSize = sizeof(abChallengeResponce);
    DWORD dwChallengeResponceSize = 0;

    //
    // Update the access count to the server (performace info only)
    //
    UPDATE_COUNTER(&g_pdsCounters->nAccessServer,g_pdsCounters->nAccessServer++)

    try
    {
        BOOL fTryUsualWay = TRUE ;
        //
        // Generate the challenge.
        //
        HCRYPTPROV  hProv = NULL ;
        hr = MQSec_AcquireCryptoProvider( eBaseProvider,
                                         &hProv ) ;
        if (!hProv || !CryptGenRandom(hProv, dwChallengeSize, abChallenge))
        {
            hr = MQ_ERROR_CORRUPTED_SECURITY_DATA;
        }
        else
        {
            try
            {
                //
                // Call back to sign the challenge.
                //
                hr = (*pfChallengeResponceProc)(
                            abChallenge,
                            dwChallengeSize,
                            dwContext,
                            abChallengeResponce,
                            &dwChallengeResponceSize,
                            dwChallengeResponceMaxSize);
            }
            catch(...)
            {
                //
                // Protect from RPC exceptions.
                //
                // Do not bother to assign some meaning full error code, since
                // we're going to call the normal DS api and the result of this
                // call is going to be the returned result.
                //
                hr = MQ_ERROR;
            }

            if (SUCCEEDED(hr))
            {
                //
                // Call MQIS. It'll validate the challenge responce. If the
                // challenge responce is OK, it'll set the properties.
                //
                hr = MQDSQMGetObjectSecurity(
                        dwObjectType,
                        pObjectGuid,
                        RequestedInformation,
                        pSecurityDescriptor,
                        nLength,
                        lpnLengthNeeded,
                        abChallenge,
                        dwChallengeSize,
                        abChallengeResponce,
                        dwChallengeResponceSize);

                if (hr == MQ_ERROR_SECURITY_DESCRIPTOR_TOO_SMALL)
                {
                    //
                    // that's a "good" error, and caller should allocate
                    // a buffer. Don't try to call again the "usual" way.
                    //
                    fTryUsualWay = FALSE ;
                }
            }
        }

        if (FAILED(hr) && fTryUsualWay)
        {
            //
            // If we failed to get the security by signing the challenge,
            // try to do this in the usual way.
            //
            hr = DSGetObjectSecurityGuid(
                    dwObjectType | (dwContext ? IMPERSONATE_CLIENT_FLAG : 0),
                    pObjectGuid,
                    RequestedInformation,
                    pSecurityDescriptor,
                    nLength,
                    lpnLengthNeeded);

            if ( ((hr == MQ_ERROR_ACCESS_DENIED) ||
                  (hr == E_ADS_BAD_PATHNAME))              &&
                (RequestedInformation & SACL_SECURITY_INFORMATION))
            {
                //
                // Return this error to be compatible with msmq1.0 machines.
                // They'll try to retrieve the security descriptor without
                // the SACL.
                // Otherwise, a nt4 machine without crypto functionality
                // (for example- french machines or nt4 cluster) won't be
                // able to boot.
                //
                hr = MQ_ERROR_PRIVILEGE_NOT_HELD ;
            }
        }
    }
    catch(const bad_alloc&)
    {
        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("Error -  EXCEPTION in DSQMGetObjectSecurity")));

        hr = MQ_ERROR_INSUFFICIENT_RESOURCES;
    }

    if (FAILED(hr))
    {
        UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)
    }

    return LogHR(hr, s_FN, 690);
}



/*====================================================

DSGetComputerSites

Arguments:

Return Value:


=====================================================*/
HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSGetComputerSites(
            IN  LPCWSTR     pwcsComputerName,
            OUT DWORD  *    pdwNumSites,
            OUT GUID **     ppguidSites
            )
{
    //
    // Update the access count to the server (performace info only)
    //
    UPDATE_COUNTER(&g_pdsCounters->nAccessServer,g_pdsCounters->nAccessServer++)
    HRESULT hr;

    try
    {
        hr = MQDSGetComputerSites(
                    pwcsComputerName,
                    pdwNumSites,
                    ppguidSites
                    );
        if (FAILED(hr))
        {
            //
            // Update the error count of errors returned to application
            //
            UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)
        }

        return LogHR(hr, s_FN, 730);
    }
    catch(const bad_alloc&)
    {
        //
        // Update the error count of errors returned to application
        //
        UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)

        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("Error -  EXCEPTION in DSGetComputerSites")));
        return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 740);
    }
}

/*====================================================

DSGetObjectPropertiesEx

    For retrieving MSMQ 2.0 properties


Arguments:

Return Value:

=====================================================*/

EXTERN_C
HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSGetObjectPropertiesEx(
                       IN  DWORD                    dwObjectType,
                       IN  LPCWSTR                  pwcsPathName,
                       IN  DWORD                    cp,
                       IN  PROPID                   aProp[],
                       IN  PROPVARIANT              apVar[] )
                       /*IN  BOOL                     fSearchDSserver )*/
{
    HRESULT hr;
    BOOL fImpersonate;

    //
    // Update the access count to the server (performace info only)
    //
    UPDATE_COUNTER(&g_pdsCounters->nAccessServer,g_pdsCounters->nAccessServer++)

    try
    {
        STORE_AND_CLEAR_IMPERSONATION_FLAG(dwObjectType, fImpersonate);

        CDSRequestContext requestContext(fImpersonate, e_IP_PROTOCOL);

        hr = MQDSGetPropsEx(
                           dwObjectType,
                           pwcsPathName,
                           NULL,
                           cp,
                           aProp,
                           apVar,
                           &requestContext);
        if (FAILED(hr))
        {
            //
            // Update the error count of errors returned to application
            //
            UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)
        }
        return LogHR(hr, s_FN, 750);
    }
    catch(const bad_alloc&)
    {
        //
        // Update the error count of errors returned to application
        //
        UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)

        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("Error -  EXCEPTION in DSGetObjectPropertiesEx")));
        return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 760);
    }
}

/*====================================================

DSGetObjectPropertiesGuidEx

    For retrieving MSMQ 2.0 properties


Arguments:

Return Value:


=====================================================*/

HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSGetObjectPropertiesGuidEx(
                IN  DWORD                   dwObjectType,
                IN  CONST GUID*             pObjectGuid,
                IN  DWORD                   cp,
                IN  PROPID                  aProp[],
                IN  PROPVARIANT             apVar[] )
                /*IN  BOOL                     /*fSearchDSserver) */
{
    HRESULT hr;
    BOOL fImpersonate;

    //
    // Update the access count to the server (performace info only)
    //
    UPDATE_COUNTER(&g_pdsCounters->nAccessServer,g_pdsCounters->nAccessServer++)

    try
    {
        STORE_AND_CLEAR_IMPERSONATION_FLAG(dwObjectType, fImpersonate);

        CDSRequestContext requestContext(fImpersonate, e_IP_PROTOCOL);

        hr = MQDSGetPropsEx(
                           dwObjectType,
                           NULL,
                           pObjectGuid,
                           cp,
                           aProp,
                           apVar,
                           &requestContext);
        if (FAILED(hr))
        {
            //
            // Update the error count of errors returned to application
            //
            UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)
        }

        return LogHR(hr, s_FN, 770);
    }
    catch(const bad_alloc&)
    {
        //
        // Update the error count of errors returned to application
        //
        UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,g_pdsCounters->nErrorsReturnedToApp++)

        DBGMSG((DBGMOD_DS,DBGLVL_ERROR,TEXT("Error -  EXCEPTION in DSGetObjectPropertiesGuidEx")));
        return LogHR(MQ_ERROR_INSUFFICIENT_RESOURCES, s_FN, 780);
    }
}

//+---------------------------------------
//
//  DSRelaxSecurity
//
//+---------------------------------------

HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSRelaxSecurity( DWORD dwRelaxFlag )
{
    HRESULT hr = MQDSRelaxSecurity( dwRelaxFlag ) ;
    return LogHR(hr, s_FN, 790);
}

//+-----------------------------------------
//
//   DSGetGCListInDomainInternal
//
//+-----------------------------------------

HRESULT
DSGetGCListInDomainInternal(
	IN  LPCWSTR     pwszComputerName,
	IN  LPCWSTR     pwszDomainName,
	OUT LPWSTR     *lplpwszGCList 
	)
{
    HRESULT hr;

    try
    {
        //
        // Update the access count to the server (performace info only)
        //
        UPDATE_COUNTER(&g_pdsCounters->nAccessServer,
                        g_pdsCounters->nAccessServer++);

        hr = MQDSGetGCListInDomain(
                 pwszComputerName,
                 pwszDomainName,
                 lplpwszGCList 
				 );
    }
    catch(const bad_alloc&)
    {
        //
        // Update the error count of errors returned to application
        //
        UPDATE_COUNTER(&g_pdsCounters->nErrorsReturnedToApp,
                        g_pdsCounters->nErrorsReturnedToApp++);

        DBGMSG((DBGMOD_DS, DBGLVL_ERROR,
                             TEXT("Error -  EXCEPTION in DSGetGCList")));

        hr = MQ_ERROR_INSUFFICIENT_RESOURCES;
    }

    return LogHR(hr, s_FN, 800);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdssrv\dsutil.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    dsutil.cpp

Abstract:

    DS utilities

Author:

    Ronit Hartmann (ronith)

--*/

#include "stdh.h"
#include "mqds.h"
#include "_rstrct.h"
#include "_mqini.h"
#include <mqsec.h>
#include "mqcert.h"
#include "uniansi.h"

#include "dsutil.tmh"

static WCHAR *s_FN=L"mqdssrv/dsutil";

typedef CMap < PROPID, PROPID, int, int> CMapPropidToIndex;

const PROPID x_propQueueToFilterOut[] = {PROPID_Q_INSTANCE};

HMODULE  g_hInstance = NULL ;

//+----------------------------------------------
//
//  PROPID  GetObjectSecurityPropid()
//
//+----------------------------------------------

PROPID  GetObjectSecurityPropid( DWORD dwObjectType )
{
    PROPID pId = (PROPID)ILLEGAL_PROPID_VALUE;

    switch ( dwObjectType )
    {
        case MQDS_QUEUE:
            pId = PROPID_Q_SECURITY;
            break;

        case MQDS_MACHINE:
            pId = PROPID_QM_SECURITY;
            break ;

        case MQDS_SITE:
            pId = PROPID_S_SECURITY;
            break;

        case MQDS_CN:
            pId = PROPID_CN_SECURITY;
            break ;

        case MQDS_USER:
        case MQDS_COMPUTER:
        case MQDS_SITELINK:
            //
            // These objects do not have security property (at least not as
            // far as msmq is concerned).
            //
            break ;

        default:
            //
            // We don't expect this code to be called for other types of
            // objects.
            //
            ASSERT(0);
            break;
    }

    return pId ;
}

/*====================================================

SetDefaultValues

Arguments:

Return Value:

=====================================================*/

HRESULT SetDefaultValues(
                IN  DWORD                  dwObjectType,
                IN  LPCWSTR                pwcsPathName,
                IN  PSECURITY_DESCRIPTOR   pSecurityDescriptor,
                IN  PSID                   pUserSid,
                IN  DWORD                  cp,
                IN  PROPID                 aProp[],
                IN  PROPVARIANT            apVar[],
                OUT DWORD*                 pcpOut,
                OUT PROPID **              ppOutProp,
                OUT PROPVARIANT **         ppOutPropvariant)

{
    //
    //  The only property that we set default value is the
    //  object security.
    //
    //  For other properties:
    //  If they are mandatory, then the caller must provide them (otherwise
    //  object creation will fail).
    //  If they are not mandatory, no default values are set. Those properties
    //  will not have value in NT5 ( and will not consume object space).
    //  When retrieved through MQADS, default values will be returned ( even
    //  though the default values are not stored in NT5 DS).
    //
    PROPID propSecurity = (PROPID)ILLEGAL_PROPID_VALUE;
    DWORD iSid = (DWORD)-1;

    DWORD dwNumPropertiesToFilterOut = 0;
    const PROPID * ppropToFilterOut = NULL;

    switch ( dwObjectType)
    {
        case MQDS_QUEUE:
            ppropToFilterOut = x_propQueueToFilterOut;
            dwNumPropertiesToFilterOut = sizeof(x_propQueueToFilterOut)/sizeof(PROPID);
            propSecurity = PROPID_Q_SECURITY;
            break;

        case MQDS_SITE:
            propSecurity = PROPID_S_SECURITY;
            break;

        case MQDS_MACHINE:
        case MQDS_CN:
        case MQDS_USER:
        case MQDS_SITELINK:
        case MQDS_COMPUTER:
            //
            // These object types do not need a security descriptor.
            //
            break;

        default:
            ASSERT(0);
            break;
    }

    //
    //  Allocate a copy of provariants and propids
    //  This operation is performed even if the caller
    //  had supplied the security property
    //
    DWORD securityIndex = cp;
    DWORD dwNumOfObjectProps = cp ;

    if (propSecurity != ILLEGAL_PROPID_VALUE)
    {
        //
        // User object get SID as "extra" prop, not security descriptor.
        //
        ASSERT(dwObjectType != MQDS_USER) ;
        dwNumOfObjectProps++;
    }
    else if (dwObjectType == MQDS_USER)
    {
        //
        //  Need to add one extra space, for PROPID_U_SID
        //
        iSid = dwNumOfObjectProps;
        dwNumOfObjectProps++;
    }

    //
    // Allocate new arrays of prop IDs and propvariants.
    //
    AP<PROPVARIANT> pAllPropvariants;
    AP<PROPID> pAllPropids;
    ASSERT( dwNumOfObjectProps > 0);
    pAllPropvariants = new PROPVARIANT[dwNumOfObjectProps];
    pAllPropids = new PROPID[dwNumOfObjectProps];
    memset(pAllPropids, 0, (sizeof(PROPID) * dwNumOfObjectProps)) ;

    if ( cp > 0)
    {
        memcpy (pAllPropvariants, apVar, sizeof(PROPVARIANT) * cp);
        memcpy (pAllPropids, aProp, sizeof(PROPID) * cp);
    }

    //
    //  Remove properties that need to be filtered out
    //
    for (DWORD i = 0; i <  dwNumPropertiesToFilterOut; i++)
    {
        ASSERT( ppropToFilterOut != NULL);
        for (DWORD j = 0; j < cp;)
        {
            if ( pAllPropids[j] == ppropToFilterOut[i])
            {
                //
                //  remove the propid & var
                //
                if ( j < cp -1)
                {
                    memcpy (&pAllPropvariants[j],
                            &pAllPropvariants[j + 1],
                            sizeof(PROPVARIANT) * (cp - j - 1));
                    memcpy (&pAllPropids[j],
                            &pAllPropids[j + 1],
                            sizeof(PROPID) * (cp - j - 1));
                }
                pAllPropids[cp - 1] = 0;
                dwNumOfObjectProps--;
                securityIndex--;
                if ( iSid != -1) iSid--;
            }
            else
            {
                j++;
            }
        }
    }

    //
    //  Set the security property
    //
#ifdef _DEBUG
    //
    // First verify that we're sane
    //
    if (pSecurityDescriptor)
    {
        SECURITY_DESCRIPTOR_CONTROL sdc;
        DWORD dwSDRev;

        ASSERT(GetSecurityDescriptorControl( pSecurityDescriptor,
                                            &sdc,
                                            &dwSDRev )) ;
        ASSERT(dwSDRev == SECURITY_DESCRIPTOR_REVISION);
        ASSERT(sdc & SE_SELF_RELATIVE);
    }
#endif

    if (propSecurity != ILLEGAL_PROPID_VALUE)
    {
        ASSERT(pSecurityDescriptor);

        pAllPropvariants[ securityIndex ].blob.cbSize =
                       GetSecurityDescriptorLength( pSecurityDescriptor ) ;
        pAllPropvariants[ securityIndex ].blob.pBlobData =
                                     (unsigned char *) pSecurityDescriptor;
        pAllPropvariants[ securityIndex ].vt = VT_BLOB;
        pAllPropids[ securityIndex ] = propSecurity;
    }

    if (dwObjectType == MQDS_USER)
    {
        //
        // Set the SID property of the user object according to the owner
        // field of the security descriptor.
        //
        ASSERT(iSid != -1);

        pAllPropvariants[iSid].vt = VT_BLOB;
        pAllPropvariants[iSid].blob.cbSize = GetLengthSid(pUserSid) ;
        pAllPropvariants[iSid].blob.pBlobData = (unsigned char *)pUserSid ;
        pAllPropids[iSid] = PROPID_U_SID;
    }

    *pcpOut =  dwNumOfObjectProps;
    *ppOutProp =  pAllPropids.detach();
    *ppOutPropvariant = pAllPropvariants.detach();
    return(MQ_OK);
}


/*====================================================

VerifyInternalCert

Arguments:

Return Value:


=====================================================*/

HRESULT VerifyInternalCert(
             IN  DWORD                  cp,
             IN  PROPID                 aProp[],
             IN  PROPVARIANT            apVar[],
             OUT BYTE                 **ppMachineSid )
{
    //
    // Verify that the self signature of internal certificates is OK.
    //
    DWORD i;
    HRESULT hr = MQ_OK;
    BOOL    fMachine = FALSE ; // TRUE for computer object.

    //
    // Find the certificate property.
    //
    for ( i = 0 ; i < cp ; i++)
    {
        if (aProp[i] == PROPID_U_SIGN_CERT)
        {
            break ;
        }
        else if (aProp[i] == PROPID_COM_SIGN_CERT)
        {
            fMachine = TRUE ;
            break ;
        }
    }
    if (i == cp)
    {
        ASSERT(0);
        return LogHR(MQ_ERROR_INSUFFICIENT_PROPERTIES, s_FN, 10);
    }

    //
    // Create a certificate object.
    //
    R<CMQSigCertificate> pCert ;

    hr = MQSigCreateCertificate( &pCert.ref(),
                                 NULL,
                                 apVar[i].blob.pBlobData,
                                 apVar[i].blob.cbSize ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 20);
    }

    // Look for the locality and the common name.
    //
    BOOL fInternalCert = FALSE;
    P<WCHAR> pwszLoc = NULL;
    P<WCHAR> wszCN = NULL;

    hr = pCert->GetIssuer( &pwszLoc,
                           NULL,
                           NULL,
                           &wszCN ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 30);
    }
    else if (pwszLoc)
    {
        fInternalCert = (lstrcmpi(pwszLoc, MQ_CERT_LOCALITY) == 0) ;
    }

    if (!fInternalCert)
    {
        //
        // Not an internal certificate. Quit !
        //
        return LogHR(hr, s_FN, 40);
    }

    //
    // Verify that the self signature is OK.
    //
    hr= pCert->IsCertificateValid( pCert.get(),
                                   x_dwCertValidityFlags,
                                   NULL,
                                   TRUE ) ; // ignore NotBefore.
    if (FAILED(hr))
    {
        LogHR(hr, s_FN, 50);
        return MQ_ERROR_INVALID_CERTIFICATE;
    }

    //
    // Replace system sid in PROPID_U_SID with SID of machine account.
    //
    for ( i = 0 ; i < cp ; i++ )
    {
        if (aProp[i] == PROPID_U_SID)
        {
            if (MQSec_IsSystemSid((PSID)apVar[i].blob.pBlobData))
            {
                DWORD dwSize = 0 ;
                *ppMachineSid = (BYTE*)
                             MQSec_GetLocalMachineSid( TRUE, &dwSize ) ;
                apVar[i].blob.pBlobData = *ppMachineSid ;
                apVar[i].blob.cbSize = dwSize ;
                aProp[i] = PROPID_COM_SID ;
            }
            else if (fMachine)
            {
                //
                // SID of computer object. Replace propid that was set in
                // SetDefaultValues().
                //
                aProp[i] = PROPID_COM_SID ;
            }
            break ;
        }
    }
    if (i == cp)
    {
        ASSERT(0);
        return LogHR(MQ_ERROR_INSUFFICIENT_PROPERTIES, s_FN, 60);
    }

    //
    // Verify that the user's SID matches the DOMAIN\account in the
    // certificate's common name.
    //
    LPWSTR pComma;

    if (!wszCN || ((pComma = wcschr(wszCN, L',')) == NULL))
    {
        ASSERT(0);
        return LogHR(MQ_ERROR_INVALID_CERTIFICATE, s_FN, 70);
    }

    *pComma = L'\0';

    BYTE  abSid[128] ;
    PSID  pSid = (PSID)abSid;
    DWORD dwSidLen = sizeof(abSid);
    AP<BYTE> pbLongSid;
    WCHAR wszRefDomain[64];
    DWORD dwRefDomainLen = sizeof(wszRefDomain) / sizeof(WCHAR);
    LPWSTR pwszRefDomain = wszRefDomain;
    AP<WCHAR> wszLongRefDomain;
    SID_NAME_USE eUse;

    //
    // Get the user's SID according to the DOMAIN\account found in
    // the certificate's common name.
    //
    if (!LookupAccountName(
            NULL,
            wszCN,
            pSid,
            &dwSidLen,
            pwszRefDomain,
            &dwRefDomainLen,
            &eUse))
    {
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
        {
            if (dwSidLen > sizeof(abSid))
            {
                //
                // Allocate a larger buffer for the SID.
                //
                pbLongSid = new BYTE[dwSidLen];
                pSid = (PSID)pbLongSid;
            }

            if (dwRefDomainLen > sizeof(wszRefDomain) / sizeof(WCHAR))
            {
                //
                // Allocate a larger buffer for the reference
                // domain name.
                //
                wszLongRefDomain = new WCHAR[dwRefDomainLen];
                pwszRefDomain = wszLongRefDomain;
            }

            if (!LookupAccountName(
                    NULL,
                    wszCN,
                    pSid,
                    &dwSidLen,
                    pwszRefDomain,
                    &dwRefDomainLen,
                    &eUse))
            {
                ASSERT(0);
                hr = MQ_ERROR_INVALID_CERTIFICATE;
            }
        }
        else
        {
            hr = MQ_ERROR_INVALID_CERTIFICATE;
        }
    }

    if (SUCCEEDED(hr))
    {
        if (!EqualSid(pSid, (PSID)apVar[i].blob.pBlobData))
        {
            return LogHR(MQ_ERROR_INVALID_CERTIFICATE, s_FN, 80);
        }
    }

    return LogHR(hr, s_FN, 90);
}


//-------------------------------------
//
//  DllMain
//
//-------------------------------------

BOOL WINAPI DllMain (HMODULE hMod, DWORD fdwReason, LPVOID lpvReserved)
{
    BOOL result = TRUE;

    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
            WPP_INIT_TRACING(L"Microsoft\\MSMQ");

            g_hInstance = hMod ;
            MQUInitGlobalScurityVars() ;
            break;
        }

        case DLL_THREAD_ATTACH:
            break;

        case DLL_PROCESS_DETACH:
            WPP_CLEANUP();
            break;

        case DLL_THREAD_DETACH:
            break;

    }
    return(result);
}

void LogMsgHR(HRESULT hr, LPWSTR wszFileName, USHORT usPoint)
{
    WRITE_MSMQ_LOG(( MSMQ_LOG_ERROR,
                     e_LogDS,
                     LOG_DS_ERRORS,
                     L"DSSRV Error: %s/%d. HR: %x", 
                     wszFileName,
                     usPoint,
                     hr)) ;
}

void LogMsgNTStatus(NTSTATUS status, LPWSTR wszFileName, USHORT usPoint)
{
    WRITE_MSMQ_LOG(( MSMQ_LOG_ERROR,
                     e_LogDS,
                     LOG_DS_ERRORS,
                     L"DSSRV Error: %s/%d. NTStatus: %x", 
                     wszFileName,
                     usPoint,
                     status)) ;
}

void LogMsgRPCStatus(RPC_STATUS status, LPWSTR wszFileName, USHORT usPoint)
{
    WRITE_MSMQ_LOG(( MSMQ_LOG_ERROR,
                     e_LogDS,
                     LOG_DS_ERRORS,
                     L"DSSRV Error: %s/%d. RPCStatus: %x", 
                     wszFileName,
                     usPoint,
                     status)) ;
}

void LogMsgBOOL(BOOL b, LPWSTR wszFileName, USHORT usPoint)
{
    WRITE_MSMQ_LOG(( MSMQ_LOG_ERROR,
                     e_LogDS,
                     LOG_DS_ERRORS,
                     L"DSSRV Error: %s/%d. BOOL: %x", 
                     wszFileName,
                     usPoint,
                     b)) ;
}

void LogIllegalPoint(LPWSTR wszFileName, USHORT dwLine)
{
        WRITE_MSMQ_LOG(( MSMQ_LOG_ERROR,
                         e_LogDS,
                         LOG_DS_ERRORS,
                         L"DSSRV Error: %s/%d. Point", 
                         wszFileName,
                         dwLine)) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdssrv\notifydl.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    notifydel.h

Abstract:


Author:

    Ronit Hartmann (ronith)

--*/
#ifndef _NOTIFYDEL_H_
#define _NOTIFYDEL_H_

#include "stdh.h"
#include "mqds.h"

class CBasicDeletionNotification
{
public:
    CBasicDeletionNotification() {};
    virtual ~CBasicDeletionNotification() {};

    virtual HRESULT ObtainPreDeleteInformation(
        IN   LPCWSTR		pwcsQueueName
        ) = 0;
    virtual HRESULT PerformPostDeleteOperations() = 0;

private:

};


class CQueueDeletionNotification : public CBasicDeletionNotification
{
public:
    CQueueDeletionNotification();
    ~CQueueDeletionNotification();

    virtual HRESULT ObtainPreDeleteInformation(
        IN   LPCWSTR		pwcsQueueName
        );
    virtual HRESULT PerformPostDeleteOperations();

private:
    AP<WCHAR>         m_pwcsQueueName;
    GUID              m_guidQmId;
    BOOL              m_fForeignQm;
    BOOL              m_fOwnedByNT4Site;
    GUID              m_guidOwnerNT4Site;

};

inline CQueueDeletionNotification::CQueueDeletionNotification()
                :   m_pwcsQueueName(NULL)
{
}

inline CQueueDeletionNotification::~CQueueDeletionNotification()
{
}

inline HRESULT CQueueDeletionNotification::PerformPostDeleteOperations()
{
    return( MQDSPostDeleteQueueActions(
        m_pwcsQueueName,
        &m_guidQmId,
        &m_fForeignQm,
        &m_fOwnedByNT4Site,
        &m_guidOwnerNT4Site
        ));

}

inline HRESULT CQueueDeletionNotification::ObtainPreDeleteInformation(
        IN   LPCWSTR		pwcsQueueName
        )
{
    HRESULT hr;
    hr = MQDSPreDeleteQueueGatherInfo(
                pwcsQueueName,
                &m_guidQmId,
                &m_fForeignQm,
                &m_fOwnedByNT4Site,
                &m_guidOwnerNT4Site
                );
    if (FAILED(hr))
    {
        return(hr);
    }
    //
    //  keep a copy of the queue name 
    //
    m_pwcsQueueName = new WCHAR[ 1 + wcslen(pwcsQueueName)];
    wcscpy( m_pwcsQueueName, pwcsQueueName);
    return MQ_OK ;
}



class CMachineDeletionNotification : public CBasicDeletionNotification
{
public:
    CMachineDeletionNotification();
    ~CMachineDeletionNotification();

    virtual HRESULT ObtainPreDeleteInformation(
        IN   LPCWSTR		pwcsMachineName
        );
    virtual HRESULT PerformPostDeleteOperations();

private:
    AP<WCHAR>         m_pwcsMachineName;
    BOOL              m_fOwnedByNT4Site;
    GUID              m_guidOwnerNT4Site;
};

inline CMachineDeletionNotification::CMachineDeletionNotification()
{
}

inline CMachineDeletionNotification::~CMachineDeletionNotification()
{
}

inline HRESULT CMachineDeletionNotification::PerformPostDeleteOperations()
{
    return( MQDSPostDeleteMachineActions(
        m_pwcsMachineName,
        &m_fOwnedByNT4Site,
        &m_guidOwnerNT4Site
        ));
}

inline HRESULT CMachineDeletionNotification::ObtainPreDeleteInformation(
        IN   LPCWSTR		pwcsMachineName
        )
{
    HRESULT hr;
    hr = MQDSPreDeleteMachineGatherInfo(
                pwcsMachineName,
                &m_fOwnedByNT4Site,
                &m_guidOwnerNT4Site
                );
    if (FAILED(hr))
    {
        return(hr);
    }
    //
    //  keep a copy of the machine name 
    //
    m_pwcsMachineName = new WCHAR[ 1 + wcslen(pwcsMachineName)];
    wcscpy( m_pwcsMachineName, pwcsMachineName);
    return MQ_OK ;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdssrv\dsifsrv.cpp ===
/*++

Copyright (c) 1995-99  Microsoft Corporation

Module Name:

    dsifrpc.cpp

Abstract:

    Implementation of MQIS CLIENT-SERVER API interface, server side.

Author:

    ronit hartmann (ronith)
    Doron Juater   (DoronJ)  25-May-1997, copied from rpcsrv.cpp

--*/

#include "stdh.h"
#include "mqds.h"
#include "mqutil.h"
#include "_mqdef.h"
#include "servlist.h"
#include "notifydl.h"
#include "dscomm.h"
#include <mqkeyhlp.h>
#include <mqsec.h>
#include <_mqrpc.h>
#include <dscore.h>

#include "dsifsrv.tmh"

static WCHAR *s_FN=L"mqdssrv/dsifsrv";

HRESULT
DSGetGCListInDomainInternal(
	IN  LPCWSTR     pwszComputerName,
	IN  LPCWSTR     pwszDomainName,
	OUT LPWSTR     *lplpwszGCList 
	);


/*====================================================

RoutineName: SignProperties

Arguments:

Return Value:

=====================================================*/

STATIC HRESULT
SignProperties( DWORD        cp,
                PROPID       aProp[  ],
                PROPVARIANT  apVar[  ],
                PCONTEXT_HANDLE_SERVER_AUTH_TYPE pServerAuthCtx,
                PBYTE                            pbServerSignature,
                DWORD                           *pdwServerSignatureSize,
                IN  ULONG    ulAuthnSvc = RPC_C_AUTHN_WINNT)
{
    //
    // SSL server authentication should not be used when using Kerberos.
    // For Kerberos, we're using the built in mutual authentication feature.
    //
    ASSERT(g_hProvVer) ;

    HRESULT hr;
    DWORD   dwErr ;
    //
    // Create a hash object.
    //
    CHCryptHash hHash;

    if (!CryptCreateHash(g_hProvVer, CALG_MD5, NULL, 0, &hHash))
    {
        dwErr = GetLastError() ;
        LogHR(dwErr, s_FN, 40);

        return MQ_ERROR_INSUFFICIENT_RESOURCES ;
    }

    //
    // Hash the properties.
    //
    hr = HashProperties(hHash, cp, aProp, apVar);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 50);
    }

    ASSERT(*pdwServerSignatureSize > pServerAuthCtx->cbHeader + pServerAuthCtx->cbTrailer);

    //
    // Get the hash value.
    //
    DWORD dwHashSize = *pdwServerSignatureSize - pServerAuthCtx->cbHeader - pServerAuthCtx->cbTrailer;
    PBYTE pbHashVal = pbServerSignature + pServerAuthCtx->cbHeader;

    if (!CryptGetHashParam(hHash, HP_HASHVAL, pbHashVal, &dwHashSize, 0))
    {
        dwErr = GetLastError() ;
        LogHR(dwErr, s_FN, 60);

        return MQ_ERROR_CORRUPTED_SECURITY_DATA ;
    }

    //
    // Seal the hash value.
    //
    *pdwServerSignatureSize = pServerAuthCtx->cbHeader + dwHashSize + pServerAuthCtx->cbTrailer;
    hr = MQSealBuffer(pServerAuthCtx->pvhContext, pbServerSignature, *pdwServerSignatureSize);

    return LogHR(hr, s_FN, 70);
}

/*====================================================

RoutineName: SignBuffer

Arguments:

Return Value:

=====================================================*/

HRESULT
SignBuffer(
    DWORD cbSize,
    PBYTE pBuffer,
    PCONTEXT_HANDLE_SERVER_AUTH_TYPE pServerAuthCtx,
    PBYTE pbServerSignature,
    DWORD *pdwServerSignatureSize)
{
    //
    // Make the buffer in a form of a VT_BLOB PROPVARIANT and sign it.
    //
    PROPVARIANT PropVar;

    PropVar.vt = VT_BLOB;
    PropVar.blob.cbSize = cbSize;
    PropVar.blob.pBlobData = pBuffer;

    HRESULT hr2 = SignProperties(1,
                          NULL,
                          &PropVar,
                          pServerAuthCtx,
                          pbServerSignature,
                          pdwServerSignatureSize);
    return LogHR(hr2, s_FN, 80);
}

//+-----------------------------------------------------------------------
//
//  BOOL CheckAuthLevel()
//
//  Check that the authentication level is at least the packet level. We
//  allow the connect level only if the user is the guest user or the
//  anonymous user.
//
//+-----------------------------------------------------------------------

BOOL CheckAuthLevel( IN handle_t hBind,
                     OUT ULONG  *pulAuthnSvc = NULL )
{
    RPC_STATUS Status;
    ULONG      ulAuthnLevel;

    ULONG  ulAuthnSvc ;
    ULONG *pSvc = pulAuthnSvc ;
    if (!pSvc)
    {
        pSvc = &ulAuthnSvc ;
    }
    *pSvc = 0 ;

    Status = RpcBindingInqAuthClient(hBind,
                                     NULL,
                                     NULL,
                                     &ulAuthnLevel,
                                     pSvc,
                                     NULL);
    if((Status == RPC_S_OK) &&
       ((*pSvc == RPC_C_AUTHN_WINNT) || (*pSvc == RPC_C_AUTHN_GSS_KERBEROS)) &&
       (ulAuthnLevel >= RPC_C_AUTHN_LEVEL_PKT))
    {
        //
        // Authentication level is high enough.
        //
        return TRUE;
    }

    LogRPCStatus(Status, s_FN, 90);

    //
    // We have low authentication level, verify that the user is the guest
    // user, or the anonymous user, i.e., an un-authenticated user.
    //

    BOOL fUnAuthenticated ;
    HRESULT hr = MQSec_IsUnAuthenticatedUser(&fUnAuthenticated) ;
    LogHR(hr, s_FN, 100);

    return(SUCCEEDED(hr) && fUnAuthenticated) ;
}

//+-----------------------------------------------------------------------
//
//  HRESULT  _CheckIfGoodServer()
//
//  see mqdscore\dsntlm.cpp for explanation regarding ntlm support.
//
//  Parameters-
//      pKerberosUser: return TRUE if rpc call can be considered as
//          Kerberos.  This mean the call is either local (local rpc protocol)
//          or come on wire and was authenticated with Kerberos. See
//          DeleteObjectGuid for its main use.
//
//+-----------------------------------------------------------------------

STATIC
HRESULT _CheckIfGoodServer( OUT BOOL     *pKerberosUser,
                            IN  handle_t  hBind,
                            ULONG         ulAuthnSvc,
                            DWORD         dwObjectType,
                            LPCWSTR       pwcsPathName,
                            const GUID   *pObjectGuid,
                            IN DWORD              cProps,
                            IN const PROPID      *pPropIDs = NULL,
                            IN enum enumNtlmOp    eNtlmOp  = e_Create)
{
    if (pKerberosUser)
    {
        *pKerberosUser = TRUE ;
    }

    if (ulAuthnSvc == RPC_C_AUTHN_GSS_KERBEROS)
    {
        return MQ_OK ;
    }

    //
    // ntlm.
    //
    unsigned int iTransport = 0 ;
    RPC_STATUS status = I_RpcBindingInqTransportType( hBind,
                                                     &iTransport ) ;
    if ((status == RPC_S_OK) && (iTransport == TRANSPORT_TYPE_LPC))
    {
        //
        // local rpc. At present (27-Aug-1998) it's OK, as Kerberos.
        // Must find if this is a feature.
        //
        return MQ_OK ;
    }

    if (pKerberosUser)
    {
        *pKerberosUser = FALSE ;
    }

    //
    // We need the propid (in MQDSCore) to chose the right object
    // context in the DS. When calling MQSetSecurity(), or DSDelete(),
    // caller do not provide a propid, so generate it here.
    //
    PROPID PropIdSec = 0 ;
    PROPID *pPropId = const_cast<PROPID*> (pPropIDs) ;

    if (pPropId == NULL)
    {
        switch ( dwObjectType)
        {
            case MQDS_QUEUE:
                PropIdSec = PROPID_Q_SECURITY;
                break;

            case MQDS_MACHINE:
                PropIdSec = PROPID_QM_SECURITY;
                break;

            case MQDS_SITE:
                PropIdSec = PROPID_S_SECURITY;
                break;

            case MQDS_USER:
                PropIdSec = PROPID_U_ID ;
                break ;

            case MQDS_ENTERPRISE:
            default:
                //
                // Enterprise object is alwasy accessible from local server.
                //
                return(MQ_OK);
                break;
        }
        pPropId = &PropIdSec ;
        cProps = 1 ;
    }

    HRESULT hr = DSCoreCheckIfGoodNtlmServer( dwObjectType,
                                              pwcsPathName,
                                              pObjectGuid,
                                              cProps,
                                              pPropId,
                                              eNtlmOp ) ;
    if (hr == MQ_ERROR_NO_DS)
    {
        DBGMSG((DBGMOD_DSAPI, DBGLVL_TRACE, TEXT(
          "MQDSSRV: Refusing to NTLM client, ObjType- %lut, eNtlmOp- %lut"),
                                                   dwObjectType, eNtlmOp)) ;
    }
    return LogHR(hr, s_FN, 110);
}

//+---------------------------------------------------------------------
//
//  BOOL _IsQueryImpersonationNeeded( DWORD dwObjectType )
//
//  return TRUE if impersonation is needed on the ADS operation.
//
//+---------------------------------------------------------------------

STATIC BOOL
_IsQueryImpersonationNeeded( DWORD dwObjectType )
{
    static BOOL s_fAlreadyInit = FALSE ;
    static BOOL s_fNeedQueryImpersonation = TRUE ;

    BOOL fImpersonate = TRUE ;

    if ((dwObjectType == MQDS_CN)       ||
        (dwObjectType == MQDS_SITE)     ||
        (dwObjectType == MQDS_SITELINK) ||
        (dwObjectType == MQDS_ENTERPRISE))
    {
        //
        // For these objects, don't impersonate the client and make the
        // query in the context of the local MSMQ service. This is done
        // to support MSMQ1.0 clients. They use ntlm and are impersonated
        // as anonymous. They need to query sites objects for routing
        // information. If we would impersonate them, then we have to give
        // everyone read access on the configuration containre object.
        // to bypass this restriction (on the configuration object), we do
        // not impersonate. That's not really a security hole. Querying
        // MSMQ routing data is not a security sensitive operation.
        //
        fImpersonate = FALSE ;
    }
    else if (s_fAlreadyInit)
    {
        fImpersonate = s_fNeedQueryImpersonation ;
    }
    else
    {
        //
        // In the NameStyle property of the MSMQService object we keep the
        // global "relaxation" flag. If set, we do not impersonate on any
        // query. So all Get/Locate operation are enabled to everyone.
        // This is needed in order to support nt4 and local users without
        // asking admin to do any manual setting.
        // Read now the NameStyle flag.
        // if flag is FALSE, the relaxation is not enabled and we'll
        // impersonate the caller.
        //
        CDSRequestContext requestContext( e_DoNotImpersonate,
                                          e_ALL_PROTOCOLS );
        PROPID PropId = PROPID_E_NAMESTYLE ;
        PROPVARIANT var ;
        var.vt = VT_NULL ;

        HRESULT hr = MQDSGetProps( MQDS_ENTERPRISE,
                                   NULL,
                                   NULL,
                                   1,
                                   &PropId,
                                   &var,
                                   &requestContext);
        LogHR(hr, s_FN, 120);

        if (SUCCEEDED(hr) && (var.bVal != MQ_E_RELAXATION_DEFAULT))
        {
            s_fNeedQueryImpersonation = !(var.bVal) ;

            if (!s_fNeedQueryImpersonation)
            {
                DBGMSG((DBGMOD_DSAPI, DBGLVL_TRACE, TEXT(
                                     "MQDSSRV: Relaxing security."))) ;
            }
        }

        s_fAlreadyInit = TRUE ;
        fImpersonate = s_fNeedQueryImpersonation ;
    }

    return fImpersonate ;
}

/*====================================================

RoutineName: S_DSCreateObject

Arguments:

Return Value:

=====================================================*/

HRESULT S_DSCreateObject(
                 handle_t               hBind,
                 DWORD                  dwObjectType,
                 LPCWSTR                pwcsPathName,
                 DWORD                  dwSDLength,
                 unsigned char *        pSecurityDescriptor,
                 DWORD                  cp,
                 PROPID                 aProp[  ],
                 PROPVARIANT            apVar[  ],
                 GUID*                  pObjGuid)
{
#if 0
    //
    // DoronJ, 25-oct-98
    // MQDS_NT4_USER does not exist anymore.
    // Nevertheless, I left this code, commented out, as a "template"
    // for possible use in the future.
    //

    static const DWORD  s_dwNotAllowedObjects[] = { MQDS_NT4_USER } ;
    static const DWORD  s_dwNotAllowedLen =
       sizeof(s_dwNotAllowedObjects) / sizeof(s_dwNotAllowedObjects[0]) ;

    for ( int j = 0 ; j < s_dwNotAllowedLen ; j++ )
    {
        if (dwObjectType == s_dwNotAllowedObjects[ j ])
        {
            //
            // It's not allowed to call this function with this object
            // type. This prevents using MQDS_NT4_USER by a network user.
            // Only the migration tool use this object type while calling
            // mqdssrv. But the migration tool calls DSCreateObject()
            // directly. So here we "close" a possible security hole, which
            // might have been exploited to register false certificates.
            // The issue here is that NT4_USER bypass the code which extract
            // the caller SID from the impersonation token. Instead, the
            // NT4_USER code supply its own SID.
            // bug 3485.
            //
            return LogHR(MQ_ERROR_ACCESS_DENIED, s_FN, 150);
        }
    }
#endif

    ULONG  ulAuthnSvc ;
    if (!CheckAuthLevel(hBind, &ulAuthnSvc))
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 160);
    }

    BOOL fKerberos = TRUE ;
    HRESULT hr = _CheckIfGoodServer( &fKerberos,
                                     hBind,
                                     ulAuthnSvc,
                                     dwObjectType,
                                     pwcsPathName,
                                     NULL,
                                     cp,
                                     aProp ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 170);
    }

    dwObjectType |= IMPERSONATE_CLIENT_FLAG;

    hr = DSCreateObjectInternal( dwObjectType,
                                 pwcsPathName,
                                 (PSECURITY_DESCRIPTOR)pSecurityDescriptor,
                                 cp,
                                 aProp,
                                 apVar,
                                 fKerberos,
                                 pObjGuid );

    return LogHR(hr, s_FN, 180);
}

/*====================================================

RoutineName: S_DSDeleteObject

Arguments:

Return Value:

=====================================================*/

HRESULT S_DSDeleteObject( handle_t   hBind,
                          DWORD      dwObjectType ,
                          LPCWSTR    pwcsPathName )
{
    ULONG  ulAuthnSvc ;
    if (!CheckAuthLevel(hBind, &ulAuthnSvc))
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 190);
    }

    HRESULT hr = _CheckIfGoodServer( NULL,
                                     hBind,
                                     ulAuthnSvc,
                                     dwObjectType,
                                     pwcsPathName,
                                     NULL, // pGuid
                                     0,
                                     NULL,
                                     e_Delete ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 200);
    }

    dwObjectType |= IMPERSONATE_CLIENT_FLAG;

    hr = DSDeleteObject( dwObjectType, pwcsPathName);

    return LogHR(hr, s_FN, 210);
}

/*====================================================

RoutineName: S_DSGetProps

Arguments:

Return Value:

=====================================================*/
HRESULT S_DSGetProps(
                        handle_t     hBind,
                        DWORD dwObjectType,
                        LPCWSTR pwcsPathName,
                        DWORD        cp,
                        PROPID       aProp[  ],
                        PROPVARIANT  apVar[  ],
                        PCONTEXT_HANDLE_SERVER_AUTH_TYPE pServerAuthCtx,
                        PBYTE pbServerSignature,
                        DWORD *pdwServerSignatureSize)
{
    HRESULT hr;

    ULONG  ulAuthnSvc ;
    if (!CheckAuthLevel(hBind, &ulAuthnSvc))
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 220);
    }

    BOOL fImpersonate = _IsQueryImpersonationNeeded( dwObjectType ) ;

    if (fImpersonate)
    {
        hr = _CheckIfGoodServer( NULL,
                                 hBind,
                                 ulAuthnSvc,
                                 dwObjectType,
                                 pwcsPathName,
                                 NULL,   // guid
                                 cp,
                                 aProp,
                                 e_GetProps ) ;
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 230);
        }

        dwObjectType |= IMPERSONATE_CLIENT_FLAG;
    }

    hr = DSGetObjectProperties(  dwObjectType,
                                 pwcsPathName,
                                 cp,
                                 aProp,
                                 apVar );
    LogHR(hr, s_FN, 240);


    if (SUCCEEDED(hr) && pServerAuthCtx->pvhContext)
    {
        hr = SignProperties(cp,
                            aProp,
                            apVar,
                            pServerAuthCtx,
                            pbServerSignature,
                            pdwServerSignatureSize,
                            ulAuthnSvc) ;
        LogHR(hr, s_FN, 250);
    }
    else
    {
        *pdwServerSignatureSize = 0;
    }

    return LogHR(hr, s_FN, 270);
}

/*====================================================

RoutineName: S_DSSetProps

Arguments:

Return Value:

=====================================================*/

HRESULT S_DSSetProps( handle_t     hBind,
                      DWORD        dwObjectType,
                      LPCWSTR      pwcsPathName,
                      DWORD        cp,
                      PROPID       aProp[  ],
                      PROPVARIANT  apVar[  ] )
{
    ULONG  ulAuthnSvc ;
    if (!CheckAuthLevel(hBind, &ulAuthnSvc))
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 280);
    }

    HRESULT hr = _CheckIfGoodServer( NULL,
                                     hBind,
                                     ulAuthnSvc,
                                     dwObjectType,
                                     pwcsPathName,
                                     NULL,
                                     cp,
                                     aProp ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 290);
    }

    dwObjectType |= IMPERSONATE_CLIENT_FLAG;

    hr = DSSetObjectProperties( dwObjectType,
                                pwcsPathName,
                                cp,
                                aProp,
                                apVar ) ;
    return LogHR(hr, s_FN, 300);
}

/*====================================================

RoutineName: S_DSGetObjectSecurity

Arguments:

Return Value:

=====================================================*/
HRESULT S_DSGetObjectSecurity(
                        handle_t                hBind,
                        DWORD                   dwObjectType,
                        LPCWSTR                 pwcsPathName,
                        SECURITY_INFORMATION    RequestedInformation,
                        unsigned char*          pSecurityDescriptor,
                        DWORD                   nLength,
                        LPDWORD                 lpnLengthNeeded,
                        PCONTEXT_HANDLE_SERVER_AUTH_TYPE pServerAuthCtx,
                        PBYTE                   pbServerSignature,
                        DWORD *                 pdwServerSignatureSize)
{
    ULONG  ulAuthnSvc ;
    if (!CheckAuthLevel(hBind, &ulAuthnSvc))
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 320);
    }

    HRESULT hr = MQ_OK ;
    BOOL fImpersonate = _IsQueryImpersonationNeeded( dwObjectType ) ;

    if (fImpersonate)
    {
        hr = _CheckIfGoodServer( NULL,
                                 hBind,
                                 ulAuthnSvc,
                                 dwObjectType,
                                 pwcsPathName,
                                 NULL, // pGuid
                                 0,
                                 NULL,
                                 e_GetProps ) ;
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 330);
        }

        dwObjectType |= IMPERSONATE_CLIENT_FLAG;
    }

    hr = DSGetObjectSecurity( dwObjectType,
                              pwcsPathName,
                              RequestedInformation,
                              (PSECURITY_DESCRIPTOR)pSecurityDescriptor,
                              nLength,
                              lpnLengthNeeded);
    LogHR(hr, s_FN, 340);

    if (SUCCEEDED(hr) && pServerAuthCtx->pvhContext)
    {
        hr = SignBuffer(*lpnLengthNeeded,
                        pSecurityDescriptor,
                        pServerAuthCtx,
                        pbServerSignature,
                        pdwServerSignatureSize);
    }
    else
    {
        *pdwServerSignatureSize = 0;
    }

    return LogHR(hr, s_FN, 350);
}

/*====================================================

RoutineName: S_DSSetObjectSecurity

Arguments:

Return Value:

=====================================================*/
HRESULT S_DSSetObjectSecurity(
                handle_t                hBind,
                DWORD                   dwObjectType,
                LPCWSTR                 pwcsPathName,
                SECURITY_INFORMATION    SecurityInformation,
                unsigned char*          pSecurityDescriptor,
                DWORD                   nLength)
{
    ULONG  ulAuthnSvc ;
    if (!CheckAuthLevel(hBind, &ulAuthnSvc))
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 370);
    }

    HRESULT hr = _CheckIfGoodServer( NULL,
                                     hBind,
                                     ulAuthnSvc,
                                     dwObjectType,
                                     pwcsPathName,
                                     NULL,
                                     0 ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 380);
    }

    dwObjectType |= IMPERSONATE_CLIENT_FLAG;

    hr = DSSetObjectSecurity( dwObjectType,
                              pwcsPathName,
                              SecurityInformation,
                              (PSECURITY_DESCRIPTOR)pSecurityDescriptor);

    return LogHR(hr, s_FN, 390);
}

/*====================================================

RoutineName: S_DSLookupBegin

Arguments:

Return Value:

=====================================================*/

HRESULT S_DSLookupBegin(
                       handle_t               hBind,
                       PPCONTEXT_HANDLE_TYPE  pHandle,
                       LPWSTR                 pwcsContext,
                       MQRESTRICTION          *pRestriction,
                       MQCOLUMNSET            *pColumns,
                       MQSORTSET              *pSort,
                       PCONTEXT_HANDLE_SERVER_AUTH_TYPE pServerAuthCtx )
{
    ULONG  ulAuthnSvc ;
    if (!CheckAuthLevel(hBind, &ulAuthnSvc))
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 400);
    }

    BOOL fImpersonate = _IsQueryImpersonationNeeded( MQDS_QUEUE ) ;

    HRESULT hr = MQ_OK ;
    if (fImpersonate)
    {
        hr = _CheckIfGoodServer( NULL,
                                 hBind,
                                 ulAuthnSvc,
                                 0,
                                 NULL,
                                 NULL,
                                 pColumns->cCol,
                                 pColumns->aCol,
                                 e_Locate ) ;
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 410);
        }

        pColumns->cCol |= IMPERSONATE_CLIENT_FLAG;
    }

    hr = DSLookupBegin( pwcsContext,
                        (MQRESTRICTION *)pRestriction,
                        (MQCOLUMNSET *)pColumns,
                        (MQSORTSET *)pSort,
                        (HANDLE*)pHandle ) ;
    return LogHR(hr, s_FN, 420);
}

/*====================================================

RoutineName: S_DSLookupNext

Arguments:

Return Value:

=====================================================*/
HRESULT S_DSLookupNext(
                     handle_t               hBind,
                     PCONTEXT_HANDLE_TYPE   Handle,
                     DWORD                  *dwSize,
                     DWORD                  *dwOutSize,
                     PROPVARIANT            *pbBuffer,
                     PCONTEXT_HANDLE_SERVER_AUTH_TYPE pServerAuthCtx,
                     PBYTE                  pbServerSignature,
                     DWORD *                pdwServerSignatureSize)
{
    HRESULT hr;

    ULONG  ulAuthnSvc ;
    if (!CheckAuthLevel(hBind, &ulAuthnSvc))
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 430);
    }

    DWORD dwInSize = *dwSize ;
    hr = DSLookupNext( (HANDLE)Handle, &dwInSize, pbBuffer);
    *dwOutSize = dwInSize ;

    if (SUCCEEDED(hr) && pServerAuthCtx->pvhContext)
    {
        hr = SignProperties( *dwOutSize,
                              NULL,
                              pbBuffer,
                              pServerAuthCtx,
                              pbServerSignature,
                              pdwServerSignatureSize,
                              ulAuthnSvc ) ;
    }
    else
    {
        *pdwServerSignatureSize = 0;
    }

    return LogHR(hr, s_FN, 440);
}

/*====================================================

RoutineName: S_DSLookupEnd

Arguments:

Return Value:

=====================================================*/
HRESULT S_DSLookupEnd(
                        handle_t                hBind,
                        PPCONTEXT_HANDLE_TYPE   pHandle)
{
    HRESULT hr;

    if (!CheckAuthLevel(hBind))
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 450);
    }

    hr = DSLookupEnd( (HANDLE)*pHandle);
    *pHandle = NULL;

    return LogHR(hr, s_FN, 460);
}

/*====================================================

RoutineName: S_DSFlush

Arguments:

Return Value:

=====================================================*/

HRESULT S_DSFlush( handle_t  hBind )
{
    return LogHR(MQ_ERROR_FUNCTION_NOT_SUPPORTED, s_FN, 470);
}


/*====================================================

RoutineName: S_DSDeleteObjectGuid

Arguments:

Return Value:

=====================================================*/
HRESULT S_DSDeleteObjectGuid(
                            handle_t    hBind,
                            DWORD       dwObjectType,
                            CONST GUID *pGuid)
{
    ULONG  ulAuthnSvc ;
    if (!CheckAuthLevel(hBind, &ulAuthnSvc))
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 480);
    }

    BOOL fKerberos = TRUE ;
    HRESULT hr = _CheckIfGoodServer( &fKerberos,
                                      hBind,
                                      ulAuthnSvc,
                                      dwObjectType,
                                      NULL,   // Pathname
                                      pGuid,
                                      0,
                                      NULL,
                                      e_Delete ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 490);
    }

    dwObjectType |= IMPERSONATE_CLIENT_FLAG;

    HRESULT hr2 = DSDeleteObjectGuidInternal( dwObjectType,
                                              pGuid,
                                              fKerberos ) ;
    return LogHR(hr2, s_FN, 500);
}

/*====================================================

RoutineName: S_DSGetPropsGuid

Arguments:

Return Value:

=====================================================*/
HRESULT S_DSGetPropsGuid(
                        handle_t     hBind,
                        DWORD        dwObjectType,
                        CONST GUID  *pGuid,
                        DWORD        cp,
                        PROPID       aProp[  ],
                        PROPVARIANT  apVar[  ],
                        PCONTEXT_HANDLE_SERVER_AUTH_TYPE pServerAuthCtx,
                        PBYTE pbServerSignature,
                        DWORD *pdwServerSignatureSize)
{
    HRESULT hr;

    ULONG  ulAuthnSvc ;
    if (!CheckAuthLevel(hBind, &ulAuthnSvc))
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 510);
    }

    BOOL fImpersonate = _IsQueryImpersonationNeeded( dwObjectType ) ;

    if (fImpersonate)
    {
        hr = _CheckIfGoodServer( NULL,
                                 hBind,
                                 ulAuthnSvc,
                                 dwObjectType,
                                 NULL,  // PathName,
                                 pGuid,
                                 cp,
                                 aProp,
                                 e_GetProps ) ;
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 520);
        }

        dwObjectType |= IMPERSONATE_CLIENT_FLAG;
    }

    hr = DSGetObjectPropertiesGuid(dwObjectType, pGuid, cp, aProp, apVar);
    LogHR(hr, s_FN, 530);

    if (SUCCEEDED(hr) && pServerAuthCtx->pvhContext)
    {
        hr = SignProperties( cp,
                             aProp,
                             apVar,
                             pServerAuthCtx,
                             pbServerSignature,
                             pdwServerSignatureSize,
                             ulAuthnSvc ) ;
    }
    else
    {
        *pdwServerSignatureSize = 0;
    }

    return LogHR(hr, s_FN, 540);
}

/*====================================================

RoutineName: S_DSSetPropsGuid

Arguments:

Return Value:

=====================================================*/
HRESULT S_DSSetPropsGuid(
                        handle_t     hBind,
                        DWORD dwObjectType,
                        CONST GUID *pGuid,
                        DWORD        cp,
                        PROPID       aProp[  ],
                        PROPVARIANT  apVar[  ])
{
    ULONG  ulAuthnSvc ;
    if (!CheckAuthLevel(hBind, &ulAuthnSvc))
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 550);
    }

    BOOL fKerberos = TRUE ;
    HRESULT hr = _CheckIfGoodServer( &fKerberos,
                                     hBind,
                                     ulAuthnSvc,
                                     dwObjectType,
                                     NULL,
                                     pGuid,
                                     cp,
                                     aProp ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 560);
    }

    dwObjectType |= IMPERSONATE_CLIENT_FLAG;

    HRESULT hr2 = DSSetObjectPropertiesGuidInternal(
                                             dwObjectType,
                                             pGuid,
                                             cp,
                                             aProp,
                                             apVar,
                                             fKerberos ) ;
    return LogHR(hr2, s_FN, 570);
}


/*====================================================

RoutineName: S_DSSetObjectSecurityGuid

Arguments:

Return Value:

=====================================================*/
HRESULT S_DSSetObjectSecurityGuid(
                IN  handle_t                hBind,
                IN  DWORD                   dwObjectType,
                IN  CONST GUID*             pObjectGuid,
                IN  DWORD/*SECURITY_INFORMATION*/    SecurityInformation,
                IN  unsigned char*          pSecurityDescriptor,
                IN  DWORD                   nLength)
{
    ULONG  ulAuthnSvc ;
    if (!CheckAuthLevel(hBind, &ulAuthnSvc))
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 580);
    }

    BOOL fKerberos = TRUE ;
    HRESULT hr = _CheckIfGoodServer( &fKerberos,
                                     hBind,
                                     ulAuthnSvc,
                                     dwObjectType,
                                     NULL,
                                     pObjectGuid,
                                     0 ) ;
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 590);
    }

    dwObjectType |= IMPERSONATE_CLIENT_FLAG;

    hr = DSSetObjectSecurityGuidInternal(
                                 dwObjectType,
                                 pObjectGuid,
                                 SecurityInformation,
                                 (PSECURITY_DESCRIPTOR)pSecurityDescriptor,
                                 fKerberos );
    return LogHR(hr, s_FN, 600);
}

/*====================================================

RoutineName: S_DSGetObjectSecurityGuid

Arguments:

Return Value:

=====================================================*/
HRESULT S_DSGetObjectSecurityGuid(
                IN  handle_t                hBind,
                IN  DWORD                   dwObjectType,
                IN  CONST GUID*             pObjectGuid,
                IN  SECURITY_INFORMATION    RequestedInformation,
                OUT unsigned char*          pSecurityDescriptor,
                IN  DWORD                   nLength,
                OUT LPDWORD                 lpnLengthNeeded,
                IN  PCONTEXT_HANDLE_SERVER_AUTH_TYPE pServerAuthCtx,
                OUT LPBYTE                  pbServerSignature,
                IN OUT DWORD *              pdwServerSignatureSize)
{
    ULONG  ulAuthnSvc ;
    if (!CheckAuthLevel(hBind, &ulAuthnSvc))
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 610);
    }

    HRESULT hr = MQ_OK ;
    BOOL fImpersonate = _IsQueryImpersonationNeeded( dwObjectType ) ;

    if (fImpersonate)
    {
        hr = _CheckIfGoodServer( NULL,
                                 hBind,
                                 ulAuthnSvc,
                                 dwObjectType,
                                 NULL,
                                 pObjectGuid,
                                 0,
                                 NULL,
                                 e_GetProps ) ;
        if (FAILED(hr))
        {
            return LogHR(hr, s_FN, 620);
        }

        dwObjectType |= IMPERSONATE_CLIENT_FLAG;
    }

    hr = DSGetObjectSecurityGuid( dwObjectType,
                                  pObjectGuid,
                                  RequestedInformation,
                                  (PSECURITY_DESCRIPTOR)pSecurityDescriptor,
                                  nLength,
                                  lpnLengthNeeded);
    LogHR(hr, s_FN, 630);

    if (SUCCEEDED(hr) && pServerAuthCtx->pvhContext)
    {
        hr = SignBuffer(*lpnLengthNeeded,
                        pSecurityDescriptor,
                        pServerAuthCtx,
                        pbServerSignature,
                        pdwServerSignatureSize);
    }
    else
    {
        *pdwServerSignatureSize = 0;
    }

    return LogHR(hr, s_FN, 640);
}
/*====================================================

RoutineName: S_DSDemoteStopWrite

Arguments:

Return Value:

=====================================================*/
HRESULT
S_DSDemoteStopWrite(
    IN handle_t hBind
    )
{
    return LogHR(MQ_ERROR_FUNCTION_NOT_SUPPORTED, s_FN, 650);
}

/*====================================================

RoutineName: S_DSDemotePSC

Arguments:

Return Value:

=====================================================*/
HRESULT
S_DSDemotePSC(
    IN     handle_t    hBind,
    IN     LPCWSTR     lpwcsNewPSCName,
    OUT    DWORD *     pdwNumberOfLSN,
    OUT    _SEQNUM     asnLSN[]
    )
{
    return LogHR(MQ_ERROR_FUNCTION_NOT_SUPPORTED, s_FN, 660);
}
/*====================================================

RoutineName: S_DSDemotePSC

Arguments:

Return Value:

=====================================================*/
HRESULT
S_DSCheckDemotedPSC(
    IN     handle_t    hBind,
    IN     LPCWSTR     lpwcsNewPSCName
    )
{
    return LogHR(MQ_ERROR_FUNCTION_NOT_SUPPORTED, s_FN, 670);
}

/*====================================================

RoutineName: S_DSGetUserParam

Arguments:

Return Value:

=====================================================*/
HRESULT
S_DSGetUserParams(
    IN handle_t        hBind,
    DWORD              dwFalgs,
    IN DWORD           dwSidLength,
    OUT unsigned char  *pUserSid,
    OUT DWORD          *pdwSidReqLength,
    LPWSTR             szAccountName,
    DWORD              *pdwAccountNameLen,
    LPWSTR             szDomainName,
    DWORD              *pdwDomainNameLen,
    IN  PCONTEXT_HANDLE_SERVER_AUTH_TYPE
                       pServerAuthCtx,
    OUT LPBYTE         pbServerSignature,
    IN OUT DWORD *     pdwServerSignatureSize
    )
{
    dwSidLength |= IMPERSONATE_CLIENT_FLAG;

    ULONG  ulAuthnSvc ;
    if (!CheckAuthLevel(hBind, &ulAuthnSvc))
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 680);
    }

    *szAccountName = '\0';
    *szDomainName = '\0';

    HRESULT hr;

    hr = DSGetUserParams(
                dwFalgs,
                dwSidLength,
                (PSID)pUserSid,
                pdwSidReqLength,
                szAccountName,
                pdwAccountNameLen,
                szDomainName,
                pdwDomainNameLen);

    LogHR(hr, s_FN, 690);

    if (SUCCEEDED(hr) && pServerAuthCtx->pvhContext)
    {
        DWORD cp = 0;
        PROPVARIANT PropVar[3];

        if (dwFalgs & GET_USER_PARAM_FLAG_SID)
        {
            PropVar[cp].vt = VT_VECTOR | VT_UI1;
            PropVar[cp].caub.pElems = pUserSid;
            PropVar[cp].caub.cElems = *pdwSidReqLength;
            cp++;
        }

        if (dwFalgs & GET_USER_PARAM_FLAG_ACCOUNT)
        {
            PropVar[cp].vt = VT_LPWSTR;
            PropVar[cp].pwszVal = szAccountName;
            PropVar[cp+1].vt = VT_LPWSTR;
            PropVar[cp+1].pwszVal = szDomainName;
            cp += 2;
        }

        hr = SignProperties( cp,
                             NULL,
                             PropVar,
                             pServerAuthCtx,
                             pbServerSignature,
                             pdwServerSignatureSize,
                             ulAuthnSvc ) ;
    }
    else
    {
        *pdwServerSignatureSize = 0;
    }

    return LogHR(hr, s_FN, 700);
}

//
// A sign routine that servers as a wrapper to the RPC callback to sign
// routine on the client.
// This is done in order to convert the DWORD_PTR dwContext used by
// DSQMSetMachineProperties back to DWORD for RPC callback
//
HRESULT
DSQMSetMachinePropertiesSignProc(
    BYTE             *abChallenge,
    DWORD            dwCallengeSize,
    DWORD_PTR        dwContext,
    BYTE             *abSignature,
    DWORD            *pdwSignatureSize,
    DWORD            dwSignatureMaxSize)
{
    return S_DSQMSetMachinePropertiesSignProc(
               abChallenge,
               dwCallengeSize,
               DWORD_PTR_TO_DWORD(dwContext), //safe, we got that as a DWORD from S_DSQMSetMachineProperties
               abSignature,
               pdwSignatureSize,
               dwSignatureMaxSize);
}


/*====================================================

RoutineName: S_DSQMSetMachineProperties

Arguments:

Return Value:

=====================================================*/
HRESULT
S_DSQMSetMachineProperties(
    handle_t                hBind,
    LPCWSTR                 pwcsPathName,
    DWORD                   cp,
    PROPID                  aProp[],
    PROPVARIANT             apVar[],
    DWORD                   dwContext)
{
    HRESULT hr;

    ULONG  ulAuthnSvc ;
    if (!CheckAuthLevel(hBind, &ulAuthnSvc))
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 720);
    }
    else if ((cp == 1)                             &&
             (aProp[0] == PROPID_QM_UPGRADE_DACL))
    {
        if (ulAuthnSvc != RPC_C_AUTHN_GSS_KERBEROS)
        {
            //
            // For upgrade of DACL, we're supporting only win2k machines,
            // that authenticate with Kerberos.
            //
            return LogHR(MQ_ERROR_DS_ERROR, s_FN, 1270);
        }
    }

    hr = DSQMSetMachineProperties(
            pwcsPathName,
            cp,
            aProp,
            apVar,
            DSQMSetMachinePropertiesSignProc, //defined here as a wrapper to S_DSQMSetMachinePropertiesSignProc
            DWORD_TO_DWORD_PTR(dwContext)); //enlarge to DWORD_PTR

    if (hr == MQ_ERROR_ACCESS_DENIED)
    {
        //
        // This may happen when nt4 machine tries to change its own properties
        // and it talks with a domain controller that does not contain its
        // msmqConfiguration object. S_DSSet will check for this condition
        // (configuration object not on local domain controller) and return
        // ERROR_NO_DS. That error tells the caller to look for another DC.
        //
        // By default a domain controller does not have write permissions
        // on objects of another domain, and ntlm impersonation can not be
        // delegated to another controller. That's the reason for the
        // access-denied error.
        //
        hr = S_DSSetProps( hBind,
                           MQDS_MACHINE,
                           pwcsPathName,
                           cp,
                           aProp,
                           apVar ) ;
    }

    return LogHR(hr, s_FN, 730);
}

/*=======================================================================

RoutineName: S_DSCreateServersCache

Here MQIS server process RPC calls from clients. Data is retrieved from
registry, not by querying local MQIS database. Registry was prepared when
local QM on MQIS server call dsapi.cpp\DSCreateServersCache().

Arguments:

Return Value:

=========================================================================*/

HRESULT
S_DSCreateServersCache(
    handle_t                hBind,
    DWORD                   *pdwIndex,
    LPWSTR                  *lplpServersList,
    IN  PCONTEXT_HANDLE_SERVER_AUTH_TYPE
                            pServerAuthCtx,
    OUT LPBYTE              pbServerSignature,
    IN OUT DWORD *          pdwServerSignatureSize)
{
    //
    // First, open the registry key.
    //
    LONG    rc;
    DWORD   dwDisposition;
    HKEY    hKeyCache;

    WCHAR  tServersKeyName[ 256 ] = {0};
    wcscpy(tServersKeyName, GetFalconSectionName());
    wcscat(tServersKeyName, TEXT("\\"));
    wcscat(tServersKeyName, MSMQ_SERVERS_CACHE_REGNAME);
    ASSERT(wcslen(tServersKeyName) < (TABLE_SIZE(tServersKeyName)));

    rc = RegCreateKeyEx( 
				FALCON_REG_POS,
				tServersKeyName,
				0L,
				L"REG_SZ",
				REG_OPTION_NON_VOLATILE,
				KEY_WRITE | KEY_READ,
				NULL,
				&hKeyCache,
				&dwDisposition 
				);

    LogNTStatus(rc, s_FN, 740);
    if (rc != ERROR_SUCCESS)
    {
        DBGMSG((DBGMOD_QM, DBGLVL_ERROR, _TEXT("Fail to Open 'ServersCache' Key. Error %d"), rc));
        REPORT_WITH_STRINGS_AND_CATEGORY((
			CATEGORY_MQDS,
			MSMQ_INTERNAL_ERROR,
			1,
			L"S_DSCreateServersCache()"
			));

        return MQ_ERROR;
    }

    ASSERT(pdwIndex);
    ASSERT(lplpServersList);

    WCHAR wszData[WSZSERVERS_LEN];
    DWORD dwDataLen = sizeof(wszData);
    WCHAR wszValueName[512];
    DWORD dwValueLen = 512;
    DWORD dwType = REG_SZ;

    rc = RegEnumValue( 
			hKeyCache,
			*pdwIndex,
			wszValueName,
			&dwValueLen,
			NULL,
			&dwType,
			(BYTE *)&wszData[0],
			&dwDataLen 
			);

    if (rc == ERROR_MORE_DATA)
    {
        ASSERT(dwDataLen > sizeof(wszData));

        //
        // input buffer too small. This error is not documented in msdn,
        // but it's similar to behavior of RegQueryValue(), so let's assume
        // it's the same behavior.
        //
        P<BYTE> pBuf = new BYTE[dwDataLen];

        rc = RegEnumValue( 
				hKeyCache,
				*pdwIndex,
				wszValueName,
				&dwValueLen,
				NULL,
				&dwType,
				pBuf,
				&dwDataLen 
				);

        if (rc == ERROR_SUCCESS)
        {
            //
            // Truncate the servers list, to include no more than
            // WSZSERVERS_LEN characters. This means that clients can use
            // no more than ~90 BSCs for load balancing MQIS operations.
            // This is necessary for compatibility with existing clients.
            //
            dwDataLen = sizeof(wszData);
            memcpy(wszData, pBuf, dwDataLen);
        }
    }
    RegCloseKey(hKeyCache);

    HRESULT hr = MQ_OK;

    if (rc == ERROR_SUCCESS)
    {
        if (dwDataLen >= sizeof(wszData))
        {
            //
            // Long buffer (all of "wszData").
            // Remove one character to compensate for the single
            // character header that is added for client. Add NULL
            // termination at end of last server name.
            //
            LONG iStrLen = TABLE_SIZE(wszData) - 1;
            wszData[ iStrLen-1 ] = 0;
            WCHAR *pCh = wcsrchr(wszData, L',');
            if (pCh != 0)
                *pCh = 0;
        }

        LONG iLen = wcslen(wszValueName) +
                    1                    +  // ";"
                    wcslen(NEW_SITE_IN_REG_FLAG_STR) + // header
                    wcslen(wszData)                  +
                    1; // null terminator.

       *lplpServersList = new WCHAR[iLen];
       LPWSTR lpServers = *lplpServersList;
       lpServers[0] = L'\0';

       wcscat(lpServers, wszValueName);
       wcscat(lpServers, L";");
       wcscat(lpServers, NEW_SITE_IN_REG_FLAG_STR);
       wcscat(lpServers, wszData);
       ASSERT((LONG)wcslen(lpServers) < iLen);

       if (pServerAuthCtx->pvhContext)
       {
           PROPVARIANT PropVar[2];

           PropVar[0].vt = VT_UI4;
           PropVar[0].ulVal = *pdwIndex;
           PropVar[1].vt = VT_LPWSTR;
           PropVar[1].pwszVal = *lplpServersList;

           hr = SignProperties(
					2,
					NULL,
					PropVar,
					pServerAuthCtx,
					pbServerSignature,
					pdwServerSignatureSize
					);

           LogHR(hr, s_FN, 750);
       }
       else
       {
           *pdwServerSignatureSize = 0;
       }
    }
    else if (rc == ERROR_NO_MORE_ITEMS)
    {
       hr = MQDS_E_NO_MORE_DATA;
    }
    else
    {
       hr =  MQ_ERROR;
    }

    if (FAILED(hr))
    {
        *pdwServerSignatureSize = 0;
    }

    return LogHR(hr, s_FN, 760);
}

//
// A challenge response routine that servers as a wrapper to the RPC callback to
// challenge response routine on the client.
// This is done in order to convert the DWORD_PTR dwContext used by
// DSQMGetObjectSecurity back to DWORD for RPC callback
//
HRESULT
DSQMGetObjectSecurityChallengeResponceProc(
    BYTE    *abChallenge,
    DWORD   dwCallengeSize,
    DWORD_PTR   dwContext,
    BYTE    *pbChallengeResponce,
    DWORD   *pdwChallengeResponceSize,
    DWORD   dwChallengeResponceMaxSize)
{
    return S_DSQMGetObjectSecurityChallengeResponceProc(
               abChallenge,
               dwCallengeSize,
               DWORD_PTR_TO_DWORD(dwContext), //safe, we got that as a DWORD from S_DSQMGetObjectSecurity
               pbChallengeResponce,
               pdwChallengeResponceSize,
               dwChallengeResponceMaxSize);              
}


/*====================================================

RoutineName: S_DSQMGetObjectSecurity

Arguments:

Return Value:

=====================================================*/
HRESULT
S_DSQMGetObjectSecurity(
    handle_t                hBind,
    DWORD                   dwObjectType,
    CONST GUID*             pObjectGuid,
    SECURITY_INFORMATION    RequestedInformation,
    BYTE                    *pSecurityDescriptor,
    DWORD                   nLength,
    LPDWORD                 lpnLengthNeeded,
    DWORD                   dwContext,
    PCONTEXT_HANDLE_SERVER_AUTH_TYPE pServerAuthCtx,
    LPBYTE                  pbServerSignature,
    DWORD *                 pdwServerSignatureSize)
{
    HRESULT hr;

    if (!CheckAuthLevel(hBind))
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 780);
    }

    hr = DSQMGetObjectSecurity(
            dwObjectType,
            pObjectGuid,
            RequestedInformation,
            (PSECURITY_DESCRIPTOR)pSecurityDescriptor,
            nLength,
            lpnLengthNeeded,
            DSQMGetObjectSecurityChallengeResponceProc, //wrapper to S_DSQMGetObjectSecurityChallengeResponceProc
            DWORD_TO_DWORD_PTR(dwContext)); //enlarge to DWORD_PTR

    LogHR(hr, s_FN, 790);

    if (SUCCEEDED(hr) && pServerAuthCtx->pvhContext)
    {
        hr = SignBuffer(*lpnLengthNeeded,
                        pSecurityDescriptor,
                        pServerAuthCtx,
                        pbServerSignature,
                        pdwServerSignatureSize);
    }
    else
    {
        *pdwServerSignatureSize = 0;
    }

    return LogHR(hr, s_FN, 800);
}


/*====================================================

S_DSMQISStats

=====================================================*/
HRESULT
S_DSMQISStats(
    handle_t    hBind,
    MQISSTAT * * ppStat,
    LPDWORD pdwStatElem
    )
{

    return LogHR(MQ_ERROR_FUNCTION_NOT_SUPPORTED, s_FN, 810);
}

/*====================================================

RoutineName: InitServerAuth

Arguments:

Return Value:

=====================================================*/

InitServerAuth(
    DWORD       dwContext,
    DWORD       dwClientBufferMaxSize,
    LPBYTE      pbClientBuffer,
    DWORD       dwClientBufferSize,
    PCONTEXT_HANDLE_SERVER_AUTH_TYPE pServerAuth)
{
    HRESULT hr = MQ_OK ;
    static BOOL fServerCredsInitialized = FALSE;

    if (!fServerCredsInitialized)
    {
        //
        // Create the server's credentials handle.
        //
        hr =  MQsspi_InitServerAuthntication() ;
        LogHR(hr, s_FN, 820);
        if (FAILED(hr))
        {
            return   MQDS_E_CANT_INIT_SERVER_AUTH ;
        }
        fServerCredsInitialized = TRUE;
    }

    //
    // Create a context handle. This requires negotiation with the client.
    //

    BOOL fFirst = TRUE;
    PBYTE pbServerBuffer = NULL;
    DWORD dwServerBufferSize;
    HRESULT hrServer = MQ_OK;
    HRESULT hrClient = MQ_OK;

    //
    // Get the maximum size for the token buffer.
    //
    hr = GetSizes(&dwServerBufferSize);
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 830);
    }

    //
    // Allocate the token buffer.
    //
    pbServerBuffer = new BYTE[dwServerBufferSize];

    __try
    {

        do
        {
            //
            // Process the client's buffer and get a new buffer to send to the
            // client. A new buffer is received if the return code is not
            // MQ_OK (SEC_E_OK).
            //
            hrServer = ServerAcceptSecCtx(fFirst,
                                          &pServerAuth->pvhContext,
                                          pbServerBuffer,
                                          &dwServerBufferSize,
                                          pbClientBuffer,
                                          dwClientBufferSize);
            if (FAILED(hrServer))
            {
                break;
            }

            //
            // Send the server buffer to the client and receive a new buffer from
            // the client. A new buffer is received from the lient when the return
            // code in not MQ_OK (SEC_E_OK).
            //
            hrClient = S_InitSecCtx(dwContext,
                                    pbServerBuffer,
                                    dwServerBufferSize,
                                    dwClientBufferMaxSize,
                                    pbClientBuffer,
                                    &dwClientBufferSize);

            if (FAILED(hrClient))
            {
                break;
            }

            //
            // When the server return MQ_OK, the client must also return MQ_OK.
            // Otherwise it means that something went wrong.
            //
            if ((hrClient == MQ_OK) || (hrServer == MQ_OK))
            {
                break;
            }

            fFirst = FALSE;

        } while (1);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hrClient = MQDS_E_CANT_INIT_SERVER_AUTH;
    }

    //
    // Free the token buffer.
    //
    delete[] pbServerBuffer;

    //
    // If we already got a context handle and failed in the remaining
    // negotiation, we should delete the context handle.
    //
    if (pServerAuth->pvhContext &&
        ((hrServer != MQ_OK) || (hrClient != MQ_OK)))
    {
        FreeContextHandle(pServerAuth->pvhContext);
        pServerAuth->pvhContext = NULL;
    }

    LogHR(hr, s_FN, 840);

    if ((hrClient == MQ_OK) && (hrServer == MQ_OK))
    {
        //
        // Get the header and trailer sizes for the context.
        //
        hr = GetSizes(NULL,
                      pServerAuth->pvhContext,
                      &pServerAuth->cbHeader,
                      &pServerAuth->cbTrailer);
    }
    else
    {
        hr = MQDS_E_CANT_INIT_SERVER_AUTH;
    }

    return LogHR(hr, s_FN, 850);
}


extern "C"
HRESULT
S_DSCloseServerHandle(
    /* [out][in] */ PPCONTEXT_HANDLE_SERVER_AUTH_TYPE pphServerAuth
    )
{
    PCONTEXT_HANDLE_SERVER_AUTH_TYPE phServerAuth = *pphServerAuth;

    if (phServerAuth->pvhContext)
    {
        FreeContextHandle(phServerAuth->pvhContext);
    }

    delete phServerAuth;

    *pphServerAuth = 0;

    return MQ_OK;
}

/*====================================================

RoutineName: PCONTEXT_HANDLE_SERVER_AUTH_TYPE_rundown

Arguments:

Return Value:

=====================================================*/

extern "C"
void
__RPC_USER
PCONTEXT_HANDLE_SERVER_AUTH_TYPE_rundown(
    PCONTEXT_HANDLE_SERVER_AUTH_TYPE phServerAuth)
{
    DBGMSG((DBGMOD_DS, DBGLVL_WARNING, TEXT("MQDSSRV: in rundown"))) ;

    S_DSCloseServerHandle(&phServerAuth);
}


/*====================================================

RoutineName: S_DSValidateServer

Arguments:

Return Value:

=====================================================*/
HRESULT
S_DSValidateServer(IN   handle_t    hBind,
                   IN   const GUID * /*pguidEnterpriseId*/,
                   IN   BOOL        fSetupMode,
                   IN   DWORD       dwContext,
                   IN   DWORD       dwClientBuffMaxSize,
                   IN   PUCHAR      pClientBuff,
                   IN   DWORD       dwClientBuffSize,
                   OUT  PPCONTEXT_HANDLE_SERVER_AUTH_TYPE
                                    pphServerAuth)
{
    HRESULT hr = MQ_OK;

    if (!CheckAuthLevel(hBind))
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 860);
    }


    //
    // If the caller is interested in server authntication, go and
    // set it on. Otherwise, set a null server context.
    //

    SERVER_AUTH_STRUCT ServerAuth = {NULL, 0, 0};

    if (dwClientBuffSize)
    {
        hr = InitServerAuth(dwContext,
                            dwClientBuffMaxSize,
                            pClientBuff,
                            dwClientBuffSize,
                            &ServerAuth);
        LogHR(hr, s_FN, 870);
        if (FAILED(hr))
        {
            hr = MQDS_E_CANT_INIT_SERVER_AUTH;
        }
    }

    *pphServerAuth = new SERVER_AUTH_STRUCT;
    **pphServerAuth = ServerAuth;

    return(hr);
}


/*====================================================

RoutineName: S_DSDisableWriteOperations

Arguments:

Return Value:

=====================================================*/
HRESULT
S_DSDisableWriteOperations(
    handle_t               hBind,
    PPCONTEXT_HANDLE_TYPE  pphContext
    )
{
    *pphContext = NULL;
    return LogHR(MQ_ERROR_FUNCTION_NOT_SUPPORTED, s_FN, 880);
}

/*====================================================

RoutineName: S_DSEnableWriteOperations

Arguments:

Return Value:

=====================================================*/

HRESULT S_DSEnableWriteOperations(
                           handle_t               hBind,
                           PPCONTEXT_HANDLE_TYPE  pphContext)
{
    *pphContext = NULL;
    return LogHR(MQ_ERROR_FUNCTION_NOT_SUPPORTED, s_FN, 890);
}

/*====================================================

RoutineName: S_DSGetComputerSites

Arguments:

Return Value:

=====================================================*/
HRESULT S_DSGetComputerSites(
            handle_t            hBind,
            LPCWSTR             pwcsPathName,
            DWORD *             pdwNumberOfSites,
            GUID **             ppguidSites,
            PCONTEXT_HANDLE_SERVER_AUTH_TYPE pServerAuthCtx,
            PBYTE               pbServerSignature,
            DWORD *             pdwServerSignatureSize)
{
    HRESULT hr;


    if (!CheckAuthLevel(hBind))
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 900);
    }

    hr = DSGetComputerSites(
                    pwcsPathName,
                    pdwNumberOfSites,
                    ppguidSites
                    );
    LogHR(hr, s_FN, 910);

    if (SUCCEEDED(hr) && pServerAuthCtx->pvhContext)
    {
        hr = SignBuffer((*pdwNumberOfSites)* sizeof(GUID),
                        (unsigned char *)*ppguidSites,
                        pServerAuthCtx,
                        pbServerSignature,
                        pdwServerSignatureSize);
    }
    else
    {
        *pdwServerSignatureSize = 0;
    }


    return LogHR(hr, s_FN, 920);
}

/*====================================================

RoutineName: S_DSGetProps

Arguments:

Return Value:

=====================================================*/
HRESULT S_DSGetPropsEx(
                        handle_t     hBind,
                        DWORD        dwObjectType,
                        LPCWSTR      pwcsPathName,
                        DWORD        cp,
                        PROPID       aProp[  ],
                        PROPVARIANT  apVar[  ],
                        PCONTEXT_HANDLE_SERVER_AUTH_TYPE pServerAuthCtx,
                        PBYTE  pbServerSignature,
                        DWORD *pdwServerSignatureSize)
{
    HRESULT hr;

    ULONG  ulAuthnSvc ;
    if (!CheckAuthLevel(hBind, &ulAuthnSvc))
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 930);
    }

    BOOL fImpersonate = _IsQueryImpersonationNeeded( dwObjectType ) ;

    if (fImpersonate)
    {
        dwObjectType |= IMPERSONATE_CLIENT_FLAG;
    }

    hr = DSGetObjectPropertiesEx(
                                 dwObjectType,
                                 pwcsPathName,
                                 cp,
                                 aProp,
                                 apVar );
    LogHR(hr, s_FN, 940);

    if (SUCCEEDED(hr) && pServerAuthCtx->pvhContext)
    {
        hr = SignProperties(cp,
                            aProp,
                            apVar,
                            pServerAuthCtx,
                            pbServerSignature,
                            pdwServerSignatureSize,
                            ulAuthnSvc) ;
    }
    else
    {
        *pdwServerSignatureSize = 0;
    }

    return LogHR(hr, s_FN, 950);
}

/*====================================================

RoutineName: S_DSGetPropsGuidEx

Arguments:

Return Value:

=====================================================*/
HRESULT S_DSGetPropsGuidEx(
                        handle_t     hBind,
                        DWORD        dwObjectType,
                        CONST GUID  *pGuid,
                        DWORD        cp,
                        PROPID       aProp[  ],
                        PROPVARIANT  apVar[  ],
                        PCONTEXT_HANDLE_SERVER_AUTH_TYPE pServerAuthCtx,
                        PBYTE  pbServerSignature,
                        DWORD *pdwServerSignatureSize)
{
    HRESULT hr;

    ULONG  ulAuthnSvc ;
    if (!CheckAuthLevel(hBind, &ulAuthnSvc))
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 960);
    }

    BOOL fImpersonate = _IsQueryImpersonationNeeded( dwObjectType ) ;

    if (fImpersonate)
    {
        dwObjectType |= IMPERSONATE_CLIENT_FLAG;
    }

    hr = DSGetObjectPropertiesGuidEx(dwObjectType, pGuid, cp, aProp, apVar);
    LogHR(hr, s_FN, 970);

    if (SUCCEEDED(hr) && pServerAuthCtx->pvhContext)
    {
        hr = SignProperties(cp,
                            aProp,
                            apVar,
                            pServerAuthCtx,
                            pbServerSignature,
                            pdwServerSignatureSize,
                            ulAuthnSvc) ;
    }
    else
    {
        *pdwServerSignatureSize = 0;
    }

    return LogHR(hr, s_FN, 980);

}

/*====================================================

RoutineName: S_DSBeginDeleteNotification

Arguments:

Return Value:

=====================================================*/
HRESULT S_DSBeginDeleteNotification(
                      handle_t						hBind,
                      LPCWSTR						pwcsName,
	                  PPCONTEXT_HANDLE_DELETE_TYPE	pHandle,
                      PCONTEXT_HANDLE_SERVER_AUTH_TYPE pServerAuthCtx
	                  )
{
    *pHandle = NULL;
    P<CBasicDeletionNotification>  pDelNotification;
    //
    //  Find if it is a queue or a machine
    //
    WCHAR * pQueueDelimiter = wcschr( pwcsName, PN_DELIMITER_C);

    if ( pQueueDelimiter != NULL)
    {
        pDelNotification = new CQueueDeletionNotification();
    }
    else
    {
        pDelNotification = new CMachineDeletionNotification();
    }
    HRESULT hr;
    hr = pDelNotification->ObtainPreDeleteInformation(
                            pwcsName
                            );
    if (FAILED(hr))
    {
        return LogHR(hr, s_FN, 990);
    }
    *pHandle = pDelNotification.detach();
    return(MQ_OK);

}

/*====================================================

RoutineName: S_DSNotifyDelete

Arguments:

Return Value:

=====================================================*/
HRESULT
S_DSNotifyDelete(
     handle_t						    hBind,
	 PCONTEXT_HANDLE_DELETE_TYPE	    Handle
	)
{
    CBasicDeletionNotification * pDelNotification = (CBasicDeletionNotification *)Handle;
    HRESULT hr = pDelNotification->PerformPostDeleteOperations();
    return LogHR(hr, s_FN, 1000);
}

/*====================================================

RoutineName: S_DSEndDeleteNotification

Arguments:

Return Value:

=====================================================*/
void
S_DSEndDeleteNotification(
    handle_t						hBind,
	PPCONTEXT_HANDLE_DELETE_TYPE	pHandle
	)
{
    if ( *pHandle != NULL)
    {
        CBasicDeletionNotification * pDelNotification = (CBasicDeletionNotification *)(*pHandle);
        delete pDelNotification;
    }

    *pHandle = NULL;
}

/*====================================================

RoutineName: S_DSIsServerGC()

Arguments:

Return Value:

=====================================================*/

BOOL
S_DSIsServerGC( /*[in]*/ handle_t hBind )
{
    BOOL fGC = MQDSIsServerGC() ;
    return fGC ;
}

/*=========================================================================

RoutineName: S_DSUpdateMachineDacl()

Note: Unsupported anymore.

Return Value:

==========================================================================*/

HRESULT
S_DSUpdateMachineDacl( handle_t   hBind )
{
    return LogHR(MQ_ERROR_DS_ERROR, s_FN, 1260);
}

/*====================================================

RoutineName: S_DSGetGCListInDomain

Arguments:

Return Value:

=====================================================*/

HRESULT 
S_DSGetGCListInDomain(
	IN  handle_t                      hBind,
	IN  LPCWSTR                       pwszComputerName,
	IN  LPCWSTR                       pwszDomainName,
	OUT LPWSTR                       *lplpwszGCList,
	PCONTEXT_HANDLE_SERVER_AUTH_TYPE  pServerAuthCtx,
	PBYTE                             pbServerSignature,
	DWORD                            *pdwServerSignatureSize 
	)
{
    ULONG  ulAuthnSvc ;
    if (!CheckAuthLevel(hBind, &ulAuthnSvc))
    {
        return LogHR(MQ_ERROR_DS_ERROR, s_FN, 1300);
    }

    HRESULT hr = DSGetGCListInDomainInternal(
					pwszComputerName,
					pwszDomainName,
					lplpwszGCList 
					);

    LogHR(hr, s_FN, 1310);

    if (SUCCEEDED(hr) && pServerAuthCtx->pvhContext)
    {
        DWORD dwSize = (wcslen( *lplpwszGCList ) + 1) * sizeof(WCHAR);

        hr = SignBuffer( 
				dwSize,
				(BYTE*) (*lplpwszGCList),
				pServerAuthCtx,
				pbServerSignature,
				pdwServerSignatureSize 
				);
    }
    else
    {
        *pdwServerSignatureSize = 0;
    }

    return LogHR(hr, s_FN, 1320);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdssrv\rpcsrv.cpp ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    rpcsrv.cpp

Abstract:

    Implementation of DS CLIENT-SERVER API, server side.

Author:

    ronit hartmann (ronith)
    Ilan Herbst    (IlanH)   9-July-2000 

--*/

#include "stdh.h"
#include "mqutil.h"
#include "_mqdef.h"
#include "_mqrpc.h"
#include "dscomm.h"
#include <uniansi.h>
#include <mqsocket.h>

#include "rpcsrv.tmh"

#define  RPCSRV_START_MQIS_IP_EP   2101

static RPC_BINDING_VECTOR *g_pBindings ;  // used for rpc dynamic endpoints.

static WCHAR *s_FN=L"mqdssrv/rpcsrv";


STATIC
RPC_STATUS 
DSSpStartRpcServer(
	void
	)
/*++

Routine Description:
	Rpc Server Start listening.

Arguments:
	None.

Returned Value:
	RPC_S_OK if success, else failure code. 

--*/
{
	//
	// Issuing RPC Listen ourselves.
	//
	// Note for WinNT: all our interfaces are registed as "AUTOLISTEN".
	// The only reason we need this call here is to enable Win95 (and w2k)
	// clients to call us. Otherwise, when Win95 call RpcBindingSetAuthInfo()
	// it will get a Busy (0x6bb) error.
	//  BUGBUG, DoronJ, 15-Jan-97. This may be fixed if SetAuthInfo() specify
	//  a principal name.
	//
	// Note for Win95: On Win95 we must issue the listen.
	// RpcServerRegisterIfEx() was not implemented in the first release of
	// Win95. It was added only in the DCOM95 service pack.
	//
	// This initialization is needed also for w2k.
	// Otherwise RpcMgmt*() will get a Busy (0x6bb) error.
	// This is by design of the RPC but might be changed
	// ilanh 9-July-2000
	//
	
	//
	// fDontWait = TRUE, Functions return immediatly after completing 
	//
	RPC_STATUS status = RpcServerListen( 
							1,
							RPC_C_LISTEN_MAX_CALLS_DEFAULT,
							TRUE  // fDontWait
							);

    DBGMSG((
		DBGMOD_RPC, 
		DBGLVL_TRACE,
        _TEXT("MQDSSRV: RpcServerListen() returned 0x%x"),
		status
		));

	//
	// On WinNT, a listen may be issued by DTC, until they fix their
	// code to use RegisterIfEx() instead of RegisterIf().
	//
	if((status == RPC_S_OK) || (status == RPC_S_ALREADY_LISTENING))
		return (RPC_S_OK);

	ASSERT(("RpcServerListen returned status != RPC_S_OK", 0));

    return LogRPCStatus(status, s_FN, 5);
}


STATIC
RPC_STATUS
DSSpRpcServerUseProtseqEp(
    unsigned short __RPC_FAR * Protseq,
    unsigned int MaxCalls,
    unsigned short __RPC_FAR * Endpoint,
    void __RPC_FAR * SecurityDescriptor
    )
/*++

Routine Description:
	Register Dynamic EndPoint and fix EndPoint for the protocol 

Arguments:
	Protseq	- string identifier of the protocol sequence 
	MaxCalls - max rpc calls
	Endpoint - endpoint	(could be null for dynamic endpoint)
	SecurityDescriptor	- SecurityDescriptor

Returned Value:
	RPC_S_OK if success, else failure code. 

--*/
{
    //
    // Listen only on IP addresses we get from winsock.
    // This enables multiple QMs to listen each to its
    // own addresses, in a cluster environment. (ShaiK)
    //

    char szHostName[ MQSOCK_MAX_COMPUTERNAME_LENGTH ] = {0};
    if (SOCKET_ERROR == gethostname(szHostName, sizeof(szHostName)))
    {
        ASSERT(("IP not configured", 0));
        return LogRPCStatus(RPC_S_ACCESS_DENIED, s_FN, 10);
    }

    PHOSTENT pHostEntry = gethostbyname(szHostName);
    if ((pHostEntry == NULL) || (pHostEntry->h_addr_list == NULL))
    {
        ASSERT(("IP not configured", 0));
        return LogRPCStatus(RPC_S_ACCESS_DENIED, s_FN, 20);
    }

    for ( DWORD ix = 0; pHostEntry->h_addr_list[ix] != NULL; ++ix)
    {
        WCHAR wzAddress[50];
        ConvertToWideCharString(
            inet_ntoa(*(struct in_addr *)(pHostEntry->h_addr_list[ix])),
            wzAddress,
            TABLE_SIZE(wzAddress)
            );

        RPC_POLICY policy;
        policy.Length = sizeof(policy);
        policy.EndpointFlags = 0;
        policy.NICFlags = 0;

        RPC_STATUS status = RPC_S_OK;
        if (NULL != Endpoint)
        {
            status = I_RpcServerUseProtseqEp2(
                         wzAddress,
                         Protseq,
                         MaxCalls,
                         Endpoint,
                         SecurityDescriptor,
                         &policy
                         );

            DBGMSG((
				DBGMOD_RPC, 
				DBGLVL_INFO,
                _TEXT("MQDSSRV: I_RpcServerUseProtseqEp2 (%ls, %ls, %ls) returned 0x%x"),
                wzAddress, 
				Protseq, 
				Endpoint, 
				status
				));
        }
        else
        {
            status = I_RpcServerUseProtseq2(
                         wzAddress,
                         Protseq,
                         MaxCalls,
                         SecurityDescriptor,
                         &policy
                         );

            DBGMSG((
				DBGMOD_RPC, 
				DBGLVL_INFO,
                _TEXT("MQDSSRV: I_RpcServerUseProtseq2 (%ls, %ls) returned 0x%x"),
                wzAddress, 
				Protseq, 
				status
				));
        }

        if (RPC_S_OK != status)
        {
            return LogRPCStatus(status, s_FN, 30);
        }
    }

    return RPC_S_OK;

}


DWORD  DSSpRegisterDynamicEnpoint(
    IN unsigned int  cMaxCalls,
    IN unsigned char *pszSecurity,
    IN DWORD         dwFirstEP
    )
/*++

Routine Description:
	Register Dynamic EndPoint and fix EndPoint for the protocol 

Arguments:
	cMaxCalls - max rpc calls
	pszSecurity	- SecurityDescriptor
	dwFirstEP - first static EndPoint to try

Returned Value:
	The fix endpoint which will be used for the real interface communnication. 

--*/
{
    LPWSTR lpProtocol = RPC_TCPIP_NAME;

    //
    // Register this protocol for dynamic endpoint
    //
	RPC_STATUS status = DSSpRpcServerUseProtseqEp(
							lpProtocol,
							cMaxCalls,
							NULL, 	/* Endpoint */
							pszSecurity
							);
    
	if (status == RPC_S_OK)
	{
		//
		// Now register a fix endpoint which will be used for the real
		// interface communnication.
		//
		WCHAR wszEndpoint[24];
		for (DWORD j = dwFirstEP; j < dwFirstEP + 1000; j = j + 11)
		{
			swprintf(wszEndpoint, L"%lu", j);

			status = DSSpRpcServerUseProtseqEp(
						lpProtocol,
						cMaxCalls,
						wszEndpoint,
						pszSecurity
						);

			if (status == RPC_S_OK)
			{
			   return j;
			}

			LogRPCStatus(status, s_FN, 50);
		}
	}

	DBGMSG((
		DBGMOD_RPC, 
		DBGLVL_WARNING,
		_TEXT("MQDSSRV: DSSpRV_RegisterDynamicEnpoint: failed to register %ls"),
		lpProtocol
		));

	return 0;
}



//
// These are the fix ports used for real MQIS interface communication.
//
static DWORD s_dwIPPort  = 0 ;

/*====================================================

Function: RpcServerInit

Arguments:

Return Value:

=====================================================*/

RPC_STATUS RpcServerInit(void)
{
    DBGMSG((
		DBGMOD_DS, 
		DBGLVL_TRACE, 
		TEXT("MQDSSRV: RpcServerInit")
		));

    RPC_STATUS  status;
    unsigned char *pszSecurity = NULL;
    unsigned int cMaxCalls = RPC_C_LISTEN_MAX_CALLS_DEFAULT;

    //
    // See if we use dynamic or predefined endpoints. By default we use
    // dynamic endpoints.
    //
    BOOL  fUsePredefinedEP =  RPC_DEFAULT_PREDEFINE_DS_EP;
    DWORD ulDefault =  RPC_DEFAULT_PREDEFINE_DS_EP;

    READ_REG_DWORD( 
		fUsePredefinedEP,
		RPC_PREDEFINE_DS_EP_REGNAME,
		&ulDefault 
		);

    BOOL fIPRergistered = FALSE;
    if (fUsePredefinedEP)
    {
		//
		// Read the IP port for RPC.
		//
		WCHAR  wzDsIPEp[MAX_REG_DEFAULT_LEN];
		DWORD  dwSize = sizeof(wzDsIPEp);

		HRESULT hr = GetThisServerIpPort(wzDsIPEp, dwSize);
		if (FAILED(hr))
		{
		   return LogHR(hr, s_FN, 55);
		}

		RPC_STATUS  statusIP =  RpcServerUseProtseqEp( 
									RPC_TCPIP_NAME,
									cMaxCalls,
									wzDsIPEp,
									pszSecurity
									);

		DBGMSG((
		   DBGMOD_RPC, 
		   DBGLVL_TRACE,
		   _TEXT("MQDSSRV: RpcServerUseProtseqEp (tcp/ip) returned 0x%x"), 
		   statusIP
		   ));

		fIPRergistered = (statusIP == RPC_S_OK);
    }
    else
    {
		s_dwIPPort = DSSpRegisterDynamicEnpoint( 
						cMaxCalls,
						pszSecurity,
						RPCSRV_START_MQIS_IP_EP 
						);

		fIPRergistered =  (s_dwIPPort != 0);
    }

    if (!fUsePredefinedEP)
    {
		status = RpcServerInqBindings(&g_pBindings);
		if (status == RPC_S_OK)
		{
			status = RpcEpRegister( 
						dscomm_v1_0_s_ifspec,
						g_pBindings,
						NULL,
						NULL 
						);
		}

		DBGMSG((
			DBGMOD_DS, 
			DBGLVL_ERROR,
			TEXT("MQDSSRV: Registering Endpoints, status- %lxh"), 
			status
			));

		if (status != RPC_S_OK)
		{
			//
			// can't register endpoints, can't be rpc server
			//
			return(RPC_S_PROTSEQ_NOT_SUPPORTED) ;
		}
		status = RpcEpRegister( 
					dscomm2_v1_0_s_ifspec,
					g_pBindings,
					NULL,
					NULL 
					);

		LogRPCStatus(status, s_FN, 60);

		DBGMSG((
			DBGMOD_DS, 
			DBGLVL_ERROR,
			TEXT("MQDSSRV: Registering dscomm2 Endpoints, status- %lxh"), 
			status
			));

		if (status != RPC_S_OK)
		{
		  //
		  // can't register endpoints, can't be rpc server
		  //
		  return LogRPCStatus(RPC_S_PROTSEQ_NOT_SUPPORTED, s_FN, 70);
		}
	}

    if (!fIPRergistered)
    {
		//
		// can't register IP. Quit. We're quite useless.
		//
		DBGMSG((
			DBGMOD_DS, 
			DBGLVL_ERROR,
			TEXT("MQDSSRV: RpcServerInit can't use IP")
			));


		//
		// If use some local RPC need to check it here 
		//

		//
		// Can't use any RPC protocol. We're completely useless!
		//
		return LogRPCStatus(RPC_S_PROTSEQ_NOT_SUPPORTED, s_FN, 80);
    }

    //
    // We register this interface as AUTO_LISTEN, so we start listengin now,
    // and do not depend on a call to RpcListen elsewhere.
	// This is TRUE but RpcMgmt* will return error till we explicitly
	// call RpcServerListen()   ilanh 10-July-2000
    //
    status = RpcServerRegisterIfEx( 
				dscomm_v1_0_s_ifspec,
				NULL,
				NULL,
				RPC_IF_AUTOLISTEN,
				cMaxCalls,
				NULL 
				);

    DBGMSG((
		DBGMOD_RPC, 
		DBGLVL_TRACE,
        TEXT("MQDSSRV: RpcServerRegisterIf returned 0x%x"),
		status
		));

    if (status != RPC_S_OK)
    {
       return LogRPCStatus(status, s_FN, 90);
    }

    status = RpcServerRegisterIfEx( 
				dscomm2_v1_0_s_ifspec,
				NULL,
				NULL,
				RPC_IF_AUTOLISTEN,
				cMaxCalls,
				NULL
				);

    DBGMSG((
		DBGMOD_RPC, 
		DBGLVL_TRACE,
        TEXT("MQDSSRV: RpcServerRegisterIf of dscomm2 returned 0x%x"),
		status
		));

    if (status != RPC_S_OK)
    {
       return LogRPCStatus(status, s_FN, 100);
    }

    status = RpcServerRegisterAuthInfo(
				NULL, 
				RPC_C_AUTHN_WINNT, 
				NULL, 
				NULL
				);

    DBGMSG((
		DBGMOD_DS, 
		DBGLVL_TRACE,
        TEXT("MQDSSRV: RpcServerRegisterAuthInfo(ntlm) returned 0x%x"),
		status
		));

    if (status != RPC_S_OK)
    {
       return LogRPCStatus(status, s_FN, 110);
    }

    //
    // #3117, for NT5 Beta2
    // Jul/16/1998 RaananH, added kerberos support
    //
    // register kerberos authenticaton
    //
    // kerberos needs principal name
    //
    LPWSTR pwszPrincipalName = NULL;
    status = RpcServerInqDefaultPrincName(
				RPC_C_AUTHN_GSS_KERBEROS,
				&pwszPrincipalName
				);

    DBGMSG((
		DBGMOD_DS, 
		DBGLVL_TRACE,
        TEXT("MQDSSRV: RpcServerInqDefaultPrincName(kerberos) returned 0x%x"),
		status
		));

    if (status != RPC_S_OK)
    {
       return LogRPCStatus(status, s_FN, 120);
    }
    status = RpcServerRegisterAuthInfo( 
				pwszPrincipalName,
				RPC_C_AUTHN_GSS_KERBEROS,
				NULL,
				NULL 
				);

    RpcStringFree(&pwszPrincipalName);
    DBGMSG((
		DBGMOD_DS, 
		DBGLVL_TRACE,
        TEXT("MQDSSRV: RpcServerRegisterAuthInfo(kerberos) returned 0x%x"),
		status
		));

    if (status != RPC_S_OK)
    {
       return LogRPCStatus(status, s_FN, 130);
    }

	//
	// Call for RpcServerListen() ourself
	// Without this call although our interfaces are register as AUTO_LISTEN
	// RpcMgmt*() functions will return error
	//
	status = DSSpStartRpcServer();

    return (status);
}

/*====================================================

RoutineName: S_DSGetServerPort()

Arguments: None

Return Value:

=====================================================*/

DWORD
S_DSGetServerPort( 
	/*[in]*/  handle_t  hBind,
	/*[in]*/  DWORD     fIP 
	)
{

	//
	// Error return null port
	//
	if(fIP == (DWORD) -1)
		return 0;

	//
	// Support only IP port
	//
	if(fIP)
	  return s_dwIPPort;

	//
	// Error return null port - dont support IPX
	//
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\ac.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:
    ac.h

Abstract:
    Falcon AC Driver master include file

Author:
    Erez Haba (erezh) 25-Feb-96

Note:
    This file is compiled in Kernel Mode and User Mode.

--*/

#ifndef __AC_H
#define __AC_H

#include <acioctl.h>
#include <acdef.h>
#include <acapi.h>

#endif // __AC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\ds\mqdssrv\stdh.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    stdh.h

Abstract:

    precompiled header file for DS Server

Author:

    RaphiR
    Erez Haba (erezh) 25-Jan-96

--*/

#ifndef __STDH_H
#define __STDH_H

#include <_stdh.h>


#include <mqtypes.h>
#include "ds.h"
#include "dsinc.h"
#include "mqsymbls.h"
#include "mqprops.h"
#include "mqlog.h"

#ifdef MQUTIL_EXPORT
#undef MQUTIL_EXPORT
#endif
#define MQUTIL_EXPORT DLL_IMPORT
#include <_secutil.h>


// This flag or orred with the object type parameter to indicated that the
// function is called via RPC and so the client should be impersonated.
#define IMPERSONATE_CLIENT_FLAG 0x80000000

#define  ILLEGAL_PROPID_VALUE  (-1)

RPC_STATUS RpcServerInit(void);

HRESULT SetDefaultValues(
         IN  DWORD                  dwObjectType,
         IN  LPCWSTR                pwcsPathName,
         IN  PSECURITY_DESCRIPTOR   pSecurityDescriptor,
         IN  PSID                   pUserSid,
         IN  DWORD                  cp,
         IN  PROPID                 aProp[],
         IN  PROPVARIANT            apVar[],
         OUT DWORD*                 pcpOut,
         OUT PROPID **              ppOutProp,
         OUT PROPVARIANT **         ppOutPropvariant);

HRESULT AddModificationTime(
         IN  DWORD                  dwObjectType,
         IN  DWORD                  cp,
         IN  PROPID                 aProp[],
         IN  PROPVARIANT            apVar[],
         OUT DWORD*                 pcpOut,
         OUT PROPID **              ppOutProp,
         OUT PROPVARIANT **         ppOutPropvariant);

HRESULT InitDefaultValues();

PROPID  GetObjectSecurityPropid( DWORD dwObjectType ) ;

HRESULT VerifyInternalCert(
         IN  DWORD                  cp,
         IN  PROPID                 aProp[],
         IN  PROPVARIANT            apVar[],
         OUT BYTE                 **ppMachineSid ) ;

HRESULT DSDeleteObjectGuidInternal( IN  DWORD        dwObjectType,
                                    IN  CONST GUID*  pObjectGuid,
                                    IN  BOOL         fIsKerberos ) ;

HRESULT DSSetObjectPropertiesGuidInternal(
                IN  DWORD                   dwObjectType,
                IN  CONST GUID*             pObjectGuid,
                IN  DWORD                   cp,
                IN  PROPID                  aProp[],
                IN  PROPVARIANT             apVar[],
                IN  BOOL                    fIsKerberos ) ;

HRESULT DSSetObjectSecurityGuidInternal(
                IN  DWORD                   dwObjectType,
                IN  CONST GUID*             pObjectGuid,
                IN  SECURITY_INFORMATION    SecurityInformation,
                IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor,
                IN  BOOL                    fIsKerberos ) ;

HRESULT
DSCreateObjectInternal( IN  DWORD                  dwObjectType,
                        IN  LPCWSTR                pwcsPathName,
                        IN  PSECURITY_DESCRIPTOR   pSecurityDescriptor,
                        IN  DWORD                  cp,
                        IN  PROPID                 aProp[],
                        IN  PROPVARIANT            apVar[],
                        IN  BOOL                   fKerberos,
                        OUT GUID*                  pObjGuid ) ;

#endif // __STDH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\acioctl.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    acioctl.h

Abstract:

    Type definitions and data for Falcon AC driver

Author:

    Erez Haba (erezh) 1-Aug-95

Revision History:
--*/

#ifndef __ACIOCTL_H
#define __ACIOCTL_H

extern "C"
{
#include <devioctl.h>
}

//-- constants --------------------------------------------
//
//  Falcon Access Control unique identifier
//
//
#define FILE_DEVICE_MQAC 0x1965    //BUGBUG: find a number

//
//  Falcon IO control codes
//


//---------------------------------------------------------
//
//  RT INTERFACE TO AC DRIVER
//
//---------------------------------------------------------

//
//  Message apis
//
#define IOCTL_AC_SEND_MESSAGE_DEF(ctl_num)          CTL_CODE(FILE_DEVICE_MQAC, \
                                                             ctl_num, \
                                                             METHOD_NEITHER, \
                                                             FILE_WRITE_ACCESS)

#define IOCTL_AC_RECEIVE_MESSAGE_DEF(ctl_num)       CTL_CODE(FILE_DEVICE_MQAC, \
                                                             ctl_num, \
                                                             METHOD_BUFFERED, \
                                                             FILE_READ_ACCESS)

#define IOCTL_AC_RECEIVE_MESSAGE_BY_LOOKUP_ID_DEF(ctl_num) CTL_CODE(FILE_DEVICE_MQAC, \
                                                             ctl_num, \
                                                             METHOD_BUFFERED, \
                                                             FILE_READ_ACCESS)

//
//  Queue apis
//
#define IOCTL_AC_HANDLE_TO_FORMAT_NAME_DEF(ctl_num) CTL_CODE(FILE_DEVICE_MQAC, \
                                                             ctl_num, \
                                                             METHOD_NEITHER, \
                                                             FILE_ANY_ACCESS)

#define IOCTL_AC_PURGE_QUEUE_DEF(ctl_num)           CTL_CODE(FILE_DEVICE_MQAC, \
                                                             ctl_num, \
                                                             METHOD_NEITHER, \
                                                             FILE_READ_ACCESS)

//
//  QueueHandle apis
//
#define IOCTL_AC_GET_QUEUE_HANDLE_PROPS_DEF(ctl_num) CTL_CODE(FILE_DEVICE_MQAC, \
                                                              ctl_num, \
                                                              METHOD_NEITHER, \
                                                              FILE_ANY_ACCESS)

//
//  Cursor apis
//
#define IOCTL_AC_CREATE_CURSOR_DEF(ctl_num)         CTL_CODE(FILE_DEVICE_MQAC, \
                                                             ctl_num, \
                                                             METHOD_NEITHER, \
                                                             FILE_READ_ACCESS)

#define IOCTL_AC_CLOSE_CURSOR_DEF(ctl_num)          CTL_CODE(FILE_DEVICE_MQAC, \
                                                             ctl_num, \
                                                             METHOD_NEITHER, \
                                                             FILE_ANY_ACCESS)

#define IOCTL_AC_SET_CURSOR_PROPS_DEF(ctl_num)      CTL_CODE(FILE_DEVICE_MQAC, \
                                                             ctl_num, \
                                                             METHOD_NEITHER, \
                                                             FILE_ANY_ACCESS)

//
//  RT ioctls
//  32 bit - range is 0x11-0x25
//  64 bit - range is 0x41-0x55 (offset of 0x30), and we need also the 32 bit ioctls
//           for compatibility with 32 bit MSMQ apps
//
#ifdef _WIN64
//
// WIN64
//
// 32 bit ioctls with _32 suffix
//
#define IOCTL_AC_SEND_MESSAGE_32           IOCTL_AC_SEND_MESSAGE_DEF(0x011)
#define IOCTL_AC_RECEIVE_MESSAGE_32        IOCTL_AC_RECEIVE_MESSAGE_DEF(0x012)
#define IOCTL_AC_HANDLE_TO_FORMAT_NAME_32  IOCTL_AC_HANDLE_TO_FORMAT_NAME_DEF(0x013)
#define IOCTL_AC_PURGE_QUEUE_32            IOCTL_AC_PURGE_QUEUE_DEF(0x014)
#define IOCTL_AC_CREATE_CURSOR_32          IOCTL_AC_CREATE_CURSOR_DEF(0x021)
#define IOCTL_AC_CLOSE_CURSOR_32           IOCTL_AC_CLOSE_CURSOR_DEF(0x022)
#define IOCTL_AC_SET_CURSOR_PROPS_32       IOCTL_AC_SET_CURSOR_PROPS_DEF(0x023)
#define IOCTL_AC_RECEIVE_MESSAGE_BY_LOOKUP_ID_32   IOCTL_AC_RECEIVE_MESSAGE_BY_LOOKUP_ID_DEF(0x024)
#define IOCTL_AC_GET_QUEUE_HANDLE_PROPS_32 IOCTL_AC_GET_QUEUE_HANDLE_PROPS_DEF(0x25)
//
// 64 bit ioctls (no suffix), offset of 0x30 from 32 bit ioctls
//
#define IOCTL_AC_SEND_MESSAGE                 IOCTL_AC_SEND_MESSAGE_DEF(0x041)
#define IOCTL_AC_RECEIVE_MESSAGE              IOCTL_AC_RECEIVE_MESSAGE_DEF(0x042)
#define IOCTL_AC_HANDLE_TO_FORMAT_NAME        IOCTL_AC_HANDLE_TO_FORMAT_NAME_DEF(0x043)
#define IOCTL_AC_PURGE_QUEUE                  IOCTL_AC_PURGE_QUEUE_DEF(0x044)
#define IOCTL_AC_CREATE_CURSOR                IOCTL_AC_CREATE_CURSOR_DEF(0x051)
#define IOCTL_AC_CLOSE_CURSOR                 IOCTL_AC_CLOSE_CURSOR_DEF(0x052)
#define IOCTL_AC_SET_CURSOR_PROPS             IOCTL_AC_SET_CURSOR_PROPS_DEF(0x053)
#define IOCTL_AC_RECEIVE_MESSAGE_BY_LOOKUP_ID IOCTL_AC_RECEIVE_MESSAGE_BY_LOOKUP_ID_DEF(0x054)
#define IOCTL_AC_GET_QUEUE_HANDLE_PROPS       IOCTL_AC_GET_QUEUE_HANDLE_PROPS_DEF(0x55)
#else //!_WIN64
//
// WIN32
//
// 32 bit ioctls (no suffix)
//
#define IOCTL_AC_SEND_MESSAGE              IOCTL_AC_SEND_MESSAGE_DEF(0x011)
#define IOCTL_AC_RECEIVE_MESSAGE           IOCTL_AC_RECEIVE_MESSAGE_DEF(0x012)
#define IOCTL_AC_HANDLE_TO_FORMAT_NAME     IOCTL_AC_HANDLE_TO_FORMAT_NAME_DEF(0x013)
#define IOCTL_AC_PURGE_QUEUE               IOCTL_AC_PURGE_QUEUE_DEF(0x014)
#define IOCTL_AC_CREATE_CURSOR             IOCTL_AC_CREATE_CURSOR_DEF(0x021)
#define IOCTL_AC_CLOSE_CURSOR              IOCTL_AC_CLOSE_CURSOR_DEF(0x022)
#define IOCTL_AC_SET_CURSOR_PROPS          IOCTL_AC_SET_CURSOR_PROPS_DEF(0x023)
#define IOCTL_AC_RECEIVE_MESSAGE_BY_LOOKUP_ID  IOCTL_AC_RECEIVE_MESSAGE_BY_LOOKUP_ID_DEF(0x024)
#define IOCTL_AC_GET_QUEUE_HANDLE_PROPS    IOCTL_AC_GET_QUEUE_HANDLE_PROPS_DEF(0x25)
#endif //_WIN64

//---------------------------------------------------------
//
//  QM INTERFACE TO AC DRIVER
//
//---------------------------------------------------------

//
//  QM Control apis
//

//---------------------------------------------------------
//
//  NOTE: CONNECT must be first QM ioctl
//
#define IOCTL_AC_CONNECT_DEF(ctl_num)                    CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)
//
//---------------------------------------------------------

#define IOCTL_AC_SET_PERFORMANCE_BUFF_DEF(ctl_num)       CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_SET_MACHINE_PROPS_DEF(ctl_num)          CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_GET_SERVICE_REQUEST_DEF(ctl_num)        CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_STORE_COMPLETED_DEF(ctl_num)            CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_BUFFERED, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_CREATE_PACKET_COMPLETED_DEF(ctl_num)    CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_ACKING_COMPLETED_DEF(ctl_num)           CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_CAN_CLOSE_QUEUE_DEF(ctl_num)            CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_SET_QUEUE_PROPS_DEF(ctl_num)            CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_ASSOCIATE_QUEUE_DEF(ctl_num)            CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_ASSOCIATE_JOURNAL_DEF(ctl_num)          CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_ASSOCIATE_DEADXACT_DEF(ctl_num)         CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_PUT_RESTORED_PACKET_DEF(ctl_num)        CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_WRITE_ACCESS)

#define IOCTL_AC_GET_RESTORED_PACKET_DEF(ctl_num)        CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_READ_ACCESS)

#define IOCTL_AC_GET_PACKET_BY_COOKIE_DEF(ctl_num)       CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_READ_ACCESS)

#define IOCTL_AC_RESTORE_PACKETS_DEF(ctl_num)            CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_SET_MAPPED_LIMIT_DEF(ctl_num)            CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_CREATE_QUEUE_DEF(ctl_num)               CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_CREATE_GROUP_DEF(ctl_num)               CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_RELEASE_RESOURCES_DEF(ctl_num)          CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_GET_QUEUE_PROPS_DEF(ctl_num)            CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_CONVERT_PACKET_DEF(ctl_num)				CTL_CODE(FILE_DEVICE_MQAC, \
										                  		ctl_num, \
					                  							METHOD_NEITHER, \
                  												FILE_ANY_ACCESS)

#define IOCTL_AC_IS_SEQUENCE_ON_HOLD_DEF(ctl_num)        CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_SET_SEQUENCE_ACK_DEF(ctl_num)           CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_CREATE_DISTRIBUTION_DEF(ctl_num)        CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)


#define IOCTL_AC_INTERNAL_PURGE_QUEUE_DEF(ctl_num)       CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

//
//  QM Network interface apis
//
#define IOCTL_AC_ALLOCATE_PACKET_DEF(ctl_num)            CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_FREE_PACKET_DEF(ctl_num)                CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_PUT_PACKET_DEF(ctl_num)                 CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_WRITE_ACCESS)

#define IOCTL_AC_GET_PACKET_DEF(ctl_num)                 CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_BUFFERED, \
                                                                  FILE_READ_ACCESS)

#define IOCTL_AC_MOVE_QUEUE_TO_GROUP_DEF(ctl_num)        CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

//
//  QM remote read apis
//
#define IOCTL_AC_CREATE_REMOTE_PROXY_DEF(ctl_num)        CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_BEGIN_GET_PACKET_2REMOTE_DEF(ctl_num)   CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_BUFFERED, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_END_GET_PACKET_2REMOTE_DEF(ctl_num)     CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_CANCEL_REQUEST_DEF(ctl_num)             CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_PUT_REMOTE_PACKET_DEF(ctl_num)          CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

//
//  QM transactions apis
//
#define IOCTL_AC_CREATE_TRANSACTION_DEF(ctl_num)         CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_XACT_COMMIT1_DEF(ctl_num)               CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_XACT_COMMIT2_DEF(ctl_num)               CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_XACT_ABORT1_DEF(ctl_num)                CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_XACT_PREPARE_DEF(ctl_num)               CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_XACT_PREPARE_DEFAULT_COMMIT_DEF(ctl_num)   CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)


#define IOCTL_AC_PUT_PACKET1_DEF(ctl_num)                CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_WRITE_ACCESS)

#define IOCTL_AC_XACT_SET_CLASS_DEF(ctl_num)             CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_XACT_GET_INFORMATION_DEF(ctl_num)       CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_FREE_PACKET2_DEF(ctl_num)               CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_FREE_PACKET1_DEF(ctl_num)               CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_ARM_PACKET_TIMER_DEF(ctl_num)           CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_XACT_COMMIT3_DEF(ctl_num)               CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

#define IOCTL_AC_XACT_ABORT2_DEF(ctl_num)                CTL_CODE(FILE_DEVICE_MQAC, \
                                                                  ctl_num, \
                                                                  METHOD_NEITHER, \
                                                                  FILE_ANY_ACCESS)

//
//  QM ioctls to AC
//  32 bit - range is 0x101-0x250
//  64 bit - range is 0x401-0x550 (offset of 0x300). We don't need the 32 bit ioctls
//           since both QM, CPL and AC are 64 bit
//
#ifdef _WIN64
//
//  64 bit ioctls
//  NOTE: CONNECT must be first QM ioctl
//
//  QM Control apis
//
#define IOCTL_AC_CONNECT                    IOCTL_AC_CONNECT_DEF(0x401)
#define IOCTL_AC_SET_PERFORMANCE_BUFF       IOCTL_AC_SET_PERFORMANCE_BUFF_DEF(0x402)
#define IOCTL_AC_SET_MACHINE_PROPS          IOCTL_AC_SET_MACHINE_PROPS_DEF(0x403)
#define IOCTL_AC_GET_SERVICE_REQUEST        IOCTL_AC_GET_SERVICE_REQUEST_DEF(0x404)
#define IOCTL_AC_CREATE_PACKET_COMPLETED    IOCTL_AC_CREATE_PACKET_COMPLETED_DEF(0x405)
#define IOCTL_AC_STORE_COMPLETED            IOCTL_AC_STORE_COMPLETED_DEF(0x406)
#define IOCTL_AC_ACKING_COMPLETED           IOCTL_AC_ACKING_COMPLETED_DEF(0x407)
#define IOCTL_AC_CAN_CLOSE_QUEUE            IOCTL_AC_CAN_CLOSE_QUEUE_DEF(0x411)
#define IOCTL_AC_SET_QUEUE_PROPS            IOCTL_AC_SET_QUEUE_PROPS_DEF(0x412)
#define IOCTL_AC_ASSOCIATE_QUEUE            IOCTL_AC_ASSOCIATE_QUEUE_DEF(0x413)
#define IOCTL_AC_ASSOCIATE_JOURNAL          IOCTL_AC_ASSOCIATE_JOURNAL_DEF(0x414)
#define IOCTL_AC_ASSOCIATE_DEADXACT         IOCTL_AC_ASSOCIATE_DEADXACT_DEF(0x415)
#define IOCTL_AC_PUT_RESTORED_PACKET        IOCTL_AC_PUT_RESTORED_PACKET_DEF(0x416)
#define IOCTL_AC_GET_RESTORED_PACKET        IOCTL_AC_GET_RESTORED_PACKET_DEF(0x417)
#define IOCTL_AC_RESTORE_PACKETS            IOCTL_AC_RESTORE_PACKETS_DEF(0x418)
#define IOCTL_AC_SET_MAPPED_LIMIT           IOCTL_AC_SET_MAPPED_LIMIT_DEF(0x419)
#define IOCTL_AC_CREATE_QUEUE               IOCTL_AC_CREATE_QUEUE_DEF(0x420)
#define IOCTL_AC_CREATE_GROUP               IOCTL_AC_CREATE_GROUP_DEF(0x421)
#define IOCTL_AC_RELEASE_RESOURCES          IOCTL_AC_RELEASE_RESOURCES_DEF(0x423)
#define IOCTL_AC_GET_QUEUE_PROPS            IOCTL_AC_GET_QUEUE_PROPS_DEF(0x424)
#define IOCTL_AC_CONVERT_PACKET             IOCTL_AC_CONVERT_PACKET_DEF(0x425)
#define IOCTL_AC_IS_SEQUENCE_ON_HOLD        IOCTL_AC_IS_SEQUENCE_ON_HOLD_DEF(0x426)
#define IOCTL_AC_SET_SEQUENCE_ACK           IOCTL_AC_SET_SEQUENCE_ACK_DEF(0x427)
#define IOCTL_AC_GET_PACKET_BY_COOKIE       IOCTL_AC_GET_PACKET_BY_COOKIE_DEF(0x428)
#define IOCTL_AC_CREATE_DISTRIBUTION        IOCTL_AC_CREATE_DISTRIBUTION_DEF(0x429)
#define IOCTL_AC_INTERNAL_PURGE_QUEUE       IOCTL_AC_INTERNAL_PURGE_QUEUE_DEF(0x431)
//
//  QM Network interface apis
//
#define IOCTL_AC_ALLOCATE_PACKET            IOCTL_AC_ALLOCATE_PACKET_DEF(0x501)
#define IOCTL_AC_FREE_PACKET                IOCTL_AC_FREE_PACKET_DEF(0x502)
#define IOCTL_AC_PUT_PACKET                 IOCTL_AC_PUT_PACKET_DEF(0x503)
#define IOCTL_AC_GET_PACKET                 IOCTL_AC_GET_PACKET_DEF(0x504)
#define IOCTL_AC_MOVE_QUEUE_TO_GROUP        IOCTL_AC_MOVE_QUEUE_TO_GROUP_DEF(0x513)
//
//  QM remote read apis
//
#define IOCTL_AC_CREATE_REMOTE_PROXY        IOCTL_AC_CREATE_REMOTE_PROXY_DEF(0x521)
#define IOCTL_AC_BEGIN_GET_PACKET_2REMOTE    IOCTL_AC_BEGIN_GET_PACKET_2REMOTE_DEF(0x522)
#define IOCTL_AC_END_GET_PACKET_2REMOTE     IOCTL_AC_END_GET_PACKET_2REMOTE_DEF(0x523)
#define IOCTL_AC_CANCEL_REQUEST             IOCTL_AC_CANCEL_REQUEST_DEF(0x524)
#define IOCTL_AC_PUT_REMOTE_PACKET          IOCTL_AC_PUT_REMOTE_PACKET_DEF(0x525)
//
//  QM transactions apis
//
#define IOCTL_AC_CREATE_TRANSACTION         IOCTL_AC_CREATE_TRANSACTION_DEF(0x531)
#define IOCTL_AC_XACT_COMMIT1               IOCTL_AC_XACT_COMMIT1_DEF(0x532)
#define IOCTL_AC_XACT_COMMIT2               IOCTL_AC_XACT_COMMIT2_DEF(0x533)
#define IOCTL_AC_XACT_ABORT1                IOCTL_AC_XACT_ABORT1_DEF(0x534)
#define IOCTL_AC_XACT_PREPARE               IOCTL_AC_XACT_PREPARE_DEF(0x535)
#define IOCTL_AC_XACT_PREPARE_DEFAULT_COMMIT    IOCTL_AC_XACT_PREPARE_DEFAULT_COMMIT_DEF(0x536)
#define IOCTL_AC_PUT_PACKET1                IOCTL_AC_PUT_PACKET1_DEF(0x537)
#define IOCTL_AC_XACT_SET_CLASS             IOCTL_AC_XACT_SET_CLASS_DEF(0x538)
#define IOCTL_AC_XACT_GET_INFORMATION       IOCTL_AC_XACT_GET_INFORMATION_DEF(0x539)
#define IOCTL_AC_FREE_PACKET1               IOCTL_AC_FREE_PACKET1_DEF(0x53a)
#define IOCTL_AC_ARM_PACKET_TIMER           IOCTL_AC_ARM_PACKET_TIMER_DEF(0x53b)
#define IOCTL_AC_XACT_COMMIT3               IOCTL_AC_XACT_COMMIT3_DEF(0x53c)
#define IOCTL_AC_XACT_ABORT2                IOCTL_AC_XACT_ABORT2_DEF(0x53d)
#define IOCTL_AC_FREE_PACKET2               IOCTL_AC_FREE_PACKET2_DEF(0x53e)

#else //!_WIN64
//
//  32 bit ioctls
//  NOTE: CONNECT must be first QM ioctl
//
//  QM Control apis
//
#define IOCTL_AC_CONNECT                 IOCTL_AC_CONNECT_DEF(0x101)
#define IOCTL_AC_SET_PERFORMANCE_BUFF    IOCTL_AC_SET_PERFORMANCE_BUFF_DEF(0x102)
#define IOCTL_AC_SET_MACHINE_PROPS       IOCTL_AC_SET_MACHINE_PROPS_DEF(0x103)
#define IOCTL_AC_GET_SERVICE_REQUEST     IOCTL_AC_GET_SERVICE_REQUEST_DEF(0x104)
#define IOCTL_AC_CREATE_PACKET_COMPLETED IOCTL_AC_CREATE_PACKET_COMPLETED_DEF(0x105)
#define IOCTL_AC_STORE_COMPLETED         IOCTL_AC_STORE_COMPLETED_DEF(0x106)
#define IOCTL_AC_ACKING_COMPLETED        IOCTL_AC_ACKING_COMPLETED_DEF(0x107)
#define IOCTL_AC_CAN_CLOSE_QUEUE         IOCTL_AC_CAN_CLOSE_QUEUE_DEF(0x111)
#define IOCTL_AC_SET_QUEUE_PROPS         IOCTL_AC_SET_QUEUE_PROPS_DEF(0x112)
#define IOCTL_AC_ASSOCIATE_QUEUE         IOCTL_AC_ASSOCIATE_QUEUE_DEF(0x113)
#define IOCTL_AC_ASSOCIATE_JOURNAL       IOCTL_AC_ASSOCIATE_JOURNAL_DEF(0x114)
#define IOCTL_AC_ASSOCIATE_DEADXACT      IOCTL_AC_ASSOCIATE_DEADXACT_DEF(0x115)
#define IOCTL_AC_PUT_RESTORED_PACKET     IOCTL_AC_PUT_RESTORED_PACKET_DEF(0x116)
#define IOCTL_AC_GET_RESTORED_PACKET     IOCTL_AC_GET_RESTORED_PACKET_DEF(0x117)
#define IOCTL_AC_RESTORE_PACKETS         IOCTL_AC_RESTORE_PACKETS_DEF(0x118)
#define IOCTL_AC_SET_MAPPED_LIMIT        IOCTL_AC_SET_MAPPED_LIMIT_DEF(0x119)
#define IOCTL_AC_CREATE_QUEUE            IOCTL_AC_CREATE_QUEUE_DEF(0x120)
#define IOCTL_AC_CREATE_GROUP            IOCTL_AC_CREATE_GROUP_DEF(0x121)
#define IOCTL_AC_RELEASE_RESOURCES       IOCTL_AC_RELEASE_RESOURCES_DEF(0x123)
#define IOCTL_AC_GET_QUEUE_PROPS         IOCTL_AC_GET_QUEUE_PROPS_DEF(0x124)
#define IOCTL_AC_CONVERT_PACKET          IOCTL_AC_CONVERT_PACKET_DEF(0x125)
#define IOCTL_AC_IS_SEQUENCE_ON_HOLD     IOCTL_AC_IS_SEQUENCE_ON_HOLD_DEF(0x126)
#define IOCTL_AC_SET_SEQUENCE_ACK        IOCTL_AC_SET_SEQUENCE_ACK_DEF(0x127)
#define IOCTL_AC_GET_PACKET_BY_COOKIE    IOCTL_AC_GET_PACKET_BY_COOKIE_DEF(0x128)
#define IOCTL_AC_CREATE_DISTRIBUTION     IOCTL_AC_CREATE_DISTRIBUTION_DEF(0x129)
#define IOCTL_AC_INTERNAL_PURGE_QUEUE    IOCTL_AC_INTERNAL_PURGE_QUEUE_DEF(131)

//
//  QM Network interface apis
//
#define IOCTL_AC_ALLOCATE_PACKET         IOCTL_AC_ALLOCATE_PACKET_DEF(0x201)
#define IOCTL_AC_FREE_PACKET             IOCTL_AC_FREE_PACKET_DEF(0x202)
#define IOCTL_AC_PUT_PACKET              IOCTL_AC_PUT_PACKET_DEF(0x203)
#define IOCTL_AC_GET_PACKET              IOCTL_AC_GET_PACKET_DEF(0x204)
#define IOCTL_AC_MOVE_QUEUE_TO_GROUP     IOCTL_AC_MOVE_QUEUE_TO_GROUP_DEF(0x213)
//
//  QM remote read apis
//
#define IOCTL_AC_CREATE_REMOTE_PROXY     IOCTL_AC_CREATE_REMOTE_PROXY_DEF(0x221)
#define IOCTL_AC_BEGIN_GET_PACKET_2REMOTE IOCTL_AC_BEGIN_GET_PACKET_2REMOTE_DEF(0x222)
#define IOCTL_AC_END_GET_PACKET_2REMOTE  IOCTL_AC_END_GET_PACKET_2REMOTE_DEF(0x223)
#define IOCTL_AC_CANCEL_REQUEST          IOCTL_AC_CANCEL_REQUEST_DEF(0x224)
#define IOCTL_AC_PUT_REMOTE_PACKET       IOCTL_AC_PUT_REMOTE_PACKET_DEF(0x225)
//
//  QM transactions apis
//
#define IOCTL_AC_CREATE_TRANSACTION      IOCTL_AC_CREATE_TRANSACTION_DEF(0x231)
#define IOCTL_AC_XACT_COMMIT1            IOCTL_AC_XACT_COMMIT1_DEF(0x232)
#define IOCTL_AC_XACT_COMMIT2            IOCTL_AC_XACT_COMMIT2_DEF(0x233)
#define IOCTL_AC_XACT_ABORT1             IOCTL_AC_XACT_ABORT1_DEF(0x234)
#define IOCTL_AC_XACT_PREPARE            IOCTL_AC_XACT_PREPARE_DEF(0x235)
#define IOCTL_AC_XACT_PREPARE_DEFAULT_COMMIT IOCTL_AC_XACT_PREPARE_DEFAULT_COMMIT_DEF(0x236)
#define IOCTL_AC_PUT_PACKET1             IOCTL_AC_PUT_PACKET1_DEF(0x237)
#define IOCTL_AC_XACT_SET_CLASS          IOCTL_AC_XACT_SET_CLASS_DEF(0x238)
#define IOCTL_AC_XACT_GET_INFORMATION    IOCTL_AC_XACT_GET_INFORMATION_DEF(0x239)
#define IOCTL_AC_FREE_PACKET1            IOCTL_AC_FREE_PACKET1_DEF(0x23a)
#define IOCTL_AC_ARM_PACKET_TIMER        IOCTL_AC_ARM_PACKET_TIMER_DEF(0x23b)
#define IOCTL_AC_XACT_COMMIT3            IOCTL_AC_XACT_COMMIT3_DEF(0x23c)
#define IOCTL_AC_XACT_ABORT2             IOCTL_AC_XACT_ABORT2_DEF(0x23d)
#define IOCTL_AC_FREE_PACKET2            IOCTL_AC_FREE_PACKET2_DEF(0x23e)

#endif //_WIN64


#endif // __ACIOCTL_H 3
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\acapi.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:
    acapi.h

Abstract:
    Falcon interface to the AC driver.

Author:
    Erez Haba (erezh) 25-Feb-96

--*/

#ifndef _ACAPI_H
#define _ACAPI_H

#include <portapi.h>


extern TCHAR g_wzDeviceName[];
#define MQAC_NAME g_wzDeviceName

//---------------------------------------------------------
//
// IMPLEMENTATION
//
//---------------------------------------------------------

//---------------------------------------------------------
//
// Falcon RT DLL interface to AC driver
//
//---------------------------------------------------------

inline
HRESULT
ACCreateHandle(
    PHANDLE phDevice
    )
{
    return MQpCreateFileW(
            MQAC_NAME,
            FILE_READ_ACCESS | FILE_WRITE_ACCESS,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            CREATE_ALWAYS,
            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
            phDevice
            );
}

inline
HRESULT
ACCloseHandle(
    HANDLE hQueue
    )
{
    return MQpCloseHandle(hQueue);
}

//
//  Using this API, it is imposible to determine when the operation
//  is completed
//
inline
HRESULT
ACSendMessage(
    HANDLE hQueue,
    BOOL fCheckMachineQuota,
    CACSendParameters& SendParams
    )
{
    return MQpDeviceIoControl(
                hQueue,
                IOCTL_AC_SEND_MESSAGE,
                0,
                fCheckMachineQuota,
                &SendParams,
                sizeof(SendParams)
                );
}

inline
HRESULT
ACSendMessage(
    HANDLE hQueue,
    CACSendParameters& SendParams,
    LPOVERLAPPED lpOverlapped
    )
{
    return MQpDeviceIoControl(
                hQueue,
                IOCTL_AC_SEND_MESSAGE,
                0,
                TRUE,
                &SendParams,
                sizeof(SendParams),
                lpOverlapped
                );
}

inline
HRESULT
ACReceiveMessage(
    HANDLE hQueue,
    CACReceiveParameters& ReceiveParams,
    LPOVERLAPPED lpOverlapped
    )
{
    return MQpDeviceIoControl(
                hQueue,
                IOCTL_AC_RECEIVE_MESSAGE,
                &ReceiveParams,
                sizeof(ReceiveParams),
                0,
                0,
                lpOverlapped
                );
}

inline
HRESULT
ACReceiveMessageByLookupId(
    HANDLE hQueue,
    CACReceiveParameters& ReceiveParams,
    LPOVERLAPPED lpOverlapped
    )
{
    return MQpDeviceIoControl(
                hQueue,
                IOCTL_AC_RECEIVE_MESSAGE_BY_LOOKUP_ID,
                &ReceiveParams,
                sizeof(ReceiveParams),
                0,
                0,
                lpOverlapped
                );
}

inline
HRESULT
ACCreateCursor(
    HANDLE hQueue,
    CACCreateLocalCursor& cc
    )
{
    return MQpDeviceIoControl(
                hQueue,
                IOCTL_AC_CREATE_CURSOR,
                0,
                0,
                &cc,
                sizeof(cc)
                );
}

inline
HRESULT
ACCloseCursor(
    HANDLE hQueue,
    HACCursor32 hCursor
    )
{
    return MQpDeviceIoControl(
                hQueue,
                IOCTL_AC_CLOSE_CURSOR,
                0,
                0,
                LongToPtr(hCursor),
                0
                );
}

inline
HRESULT
ACSetCursorProperties(
    HANDLE hProxy,
    HACCursor32 hCursor,
    ULONG hRemoteCursor
    )
{
    return MQpDeviceIoControl(
                hProxy,
                IOCTL_AC_SET_CURSOR_PROPS,
                0,
                0,
                LongToPtr(hCursor),
                hRemoteCursor
                );
}

inline
HRESULT
ACHandleToFormatName(
    HANDLE hQueue,
    LPWSTR lpwcsFormatName,
    LPDWORD lpdwFormatNameLength
    )
{
    return MQpDeviceIoControl(
                hQueue,
                IOCTL_AC_HANDLE_TO_FORMAT_NAME,
                lpdwFormatNameLength,
                sizeof(DWORD),
                lpwcsFormatName,
                *lpdwFormatNameLength
                );
}

inline
HRESULT
ACPurgeQueue(
    HANDLE hQueue
    )
{
    return MQpDeviceIoControl(
                hQueue,
                IOCTL_AC_PURGE_QUEUE,
                0,
                0,
                0,
                0
                );
}


//---------------------------------------------------------
//
// QM control APIs
//
//---------------------------------------------------------

inline
HRESULT
ACPurgeQueue(
    HANDLE hQueue,
    BOOL   fDelete,
    USHORT usClass
    )
{
    return MQpDeviceIoControl(
                hQueue,
                IOCTL_AC_INTERNAL_PURGE_QUEUE,
                0,
                fDelete,
                0,
                usClass
                );
}


inline
HRESULT
ACSetQueueProperties(
    HANDLE hQueue,
    BOOL fJournalQueue,
    BOOL fAuthenticate,
    ULONG ulPrivLevel,
    ULONG ulQuota,
    ULONG ulJournalQuota,
    LONG lBasePriority,
    BOOL fTransactionalQueue,
    const GUID* pgConnectorQM,
    BOOL fUnknownQueueType
    )
{
    CACSetQueueProperties qp = {
        fJournalQueue,
        fAuthenticate,
        ulPrivLevel,
        ulQuota,
        ulJournalQuota,
        lBasePriority,
        fTransactionalQueue,
        fUnknownQueueType,
        pgConnectorQM
    };

    return MQpDeviceIoControl(
            hQueue,
            IOCTL_AC_SET_QUEUE_PROPS,
            0,
            0,
            &qp,
            sizeof(qp)
            );
}


inline
HRESULT
ACGetQueueProperties(
    HANDLE hQueue,
    CACGetQueueProperties& qp
    )
{
    return MQpDeviceIoControl(
            hQueue,
            IOCTL_AC_GET_QUEUE_PROPS,
            0,
            0,
            &qp,
            sizeof(qp)
            );
}


inline
HRESULT
ACGetQueueHandleProperties(
    HANDLE hQueue,
    CACGetQueueHandleProperties& qhp
    )
{
    return MQpDeviceIoControl(
               hQueue,
               IOCTL_AC_GET_QUEUE_HANDLE_PROPS,
               0,
               0,
               &qhp,
               sizeof(qhp)
               );
}


inline
HRESULT
ACCreateDistribution(
    DWORD              nQueues,
    const HANDLE       hQueues[],
    const bool         HttpSend[],
    DWORD              nTopLevelQueueFormats,
    const QUEUE_FORMAT TopLevelQueueFormats[],
    PHANDLE            phDistribution
    )
{
    
	HANDLE hDistribution;
    HRESULT rc = ACCreateHandle(&hDistribution);
    if (FAILED(rc))
    {
        return rc;
    }

    CACCreateDistributionParameters cdp = {
        TopLevelQueueFormats,
        nTopLevelQueueFormats,
        hQueues,
        HttpSend,
        nQueues
    };

    rc = MQpDeviceIoControl(
             hDistribution,
             IOCTL_AC_CREATE_DISTRIBUTION,
             0,
             0,
             &cdp,
             sizeof(cdp)
             );

    if (FAILED(rc))
    {
        ACCloseHandle(hDistribution);
		return rc;
    }
	
	*phDistribution = hDistribution;
	return rc;

} // ACCreateDistribution


inline
HRESULT
ACCreateQueue(
    BOOL fTargetQueue,
    const GUID* pDestGUID,
    const QUEUE_FORMAT* pQueueID,
    QueueCounters* pQueueCounters,
    LONGLONG liSeqID,
    ULONG ulSeqNo,
    PHANDLE phQueue
    )
{
    HANDLE hQueue;
    HRESULT rc =  ACCreateHandle(&hQueue);

    if(FAILED(rc))
    {
        return rc;
    }

    CACCreateQueueParameters cqp = {
        fTargetQueue,
        pDestGUID,
        pQueueID,
        pQueueCounters,
        liSeqID,
        ulSeqNo,
    };

    rc = MQpDeviceIoControl(
            hQueue,
            IOCTL_AC_CREATE_QUEUE,
            0,
            0,
            &cqp,
            sizeof(cqp)
            );

    if(FAILED(rc))
    {
        ACCloseHandle(hQueue);
		return rc;
    }

	*phQueue = hQueue;
    return rc;
}

inline
HRESULT
ACCreateRemoteProxy(
    const QUEUE_FORMAT* pQueueID,
    ULONG cli_pQMQueue,
    ULONG srv_pQMQueue,
    ULONG srv_hACQueue,
    PVOID pRRContext, //PCTX_RRSESSION_HANDLE_TYPE
    PVOID pCloseCS, //CRITICAL_SECTION* 
    PVOID cli_pQMQueue2, //CRRQueue*
    PHANDLE phQueue
    )
{
	HANDLE 	hQueue;
    HRESULT rc =  ACCreateHandle(&hQueue);

    if(FAILED(rc))
    {
        return rc;
    }

    CACCreateRemoteProxyParameters cpp = {
        pQueueID,
        cli_pQMQueue,
        hQueue,
        srv_pQMQueue,
        srv_hACQueue,
        pRRContext,
        pCloseCS,
        cli_pQMQueue2
    };

    rc = MQpDeviceIoControl(
            hQueue,
            IOCTL_AC_CREATE_REMOTE_PROXY,
            0,
            0,
            &cpp,
            sizeof(cpp)
            );

    if(FAILED(rc))
    {
        ACCloseHandle(hQueue);
		return rc;
    }

	*phQueue = hQueue;
    return rc;
}

inline
HRESULT
ACCreateTransaction(
    const XACTUOW* pXactUow,
    PHANDLE phQueue
    )
{
	HANDLE hQueue;
    HRESULT rc =  ACCreateHandle(&hQueue);

    if(FAILED(rc))
    {
        return rc;
    }

    rc = MQpDeviceIoControl(
            hQueue,
            IOCTL_AC_CREATE_TRANSACTION,
            0,
            0,
            const_cast<XACTUOW*>(pXactUow),
            sizeof(*pXactUow)
            );

    if(FAILED(rc))
    {
        ACCloseHandle(hQueue);
		return rc;
    }

	*phQueue = hQueue;
    return rc;
}

inline
HRESULT
ACGetServiceRequest(
    HANDLE hDevice,
    CACRequest* pRequest,
    LPOVERLAPPED lpOverlapped
    )
{
    return MQpDeviceIoControl(
            hDevice,
            IOCTL_AC_GET_SERVICE_REQUEST,
            0,
            0,
            pRequest,
            sizeof(*pRequest),
            lpOverlapped
            );
}


inline
HRESULT
ACCreatePacketCompleted(
    HANDLE    hDevice,
    CPacket * pOriginalDriverPacket,
    CPacket * pNewDriverPacket,
    HRESULT   result,
    USHORT    ack
    )
{   
    return MQpDeviceIoControl(
               hDevice,
               IOCTL_AC_CREATE_PACKET_COMPLETED,
               pOriginalDriverPacket,
               result,
               pNewDriverPacket,
               ack
               );
}


inline
HRESULT
ACStorageCompleted(
    HANDLE hDevice,
    ULONG count,
    VOID* const* pCookieList,
    HRESULT result
    )
{
    return MQpDeviceIoControl(
            hDevice,
            IOCTL_AC_STORE_COMPLETED,
            const_cast<VOID**>(pCookieList),
            count * sizeof(VOID*),
            (VOID*)(LONG_PTR)result,
            0
            );
}

inline
HRESULT
ACAckingCompleted(
    HANDLE hDevice,
    const VOID* pCookie
    )
{
    return MQpDeviceIoControl(
            hDevice,
            IOCTL_AC_ACKING_COMPLETED,
            0,
            0,
            const_cast<VOID*>(pCookie),
            0
            );
}

inline
HRESULT
ACXactGetInformation(
    HANDLE hXact,
    CACXactInformation *pInfo
    )
{
    return MQpDeviceIoControl(
            hXact,
            IOCTL_AC_XACT_GET_INFORMATION,
            0,
            0,
            pInfo,
            sizeof(*pInfo)
            );
}

inline
HRESULT
ACConnect(
    HANDLE hDevice,
    const GUID* pguidSourceQM,
    PWCHAR pStoragePath[AC_PATH_COUNT],
    ULONGLONG MessageID,
    ULONG ulPoolSize,
    LONGLONG liSeqIDAtRestore,
    BOOL  fXactCompatibilityMode
    )
{
    
    CACConnectParameters cp;
    cp.pgSourceQM = pguidSourceQM;
    cp.MessageID = MessageID;
    cp.ulPoolSize = ulPoolSize;
    cp.liSeqIDAtRestore = liSeqIDAtRestore;
    cp.fXactCompatibilityMode = fXactCompatibilityMode;

    for(int i = 0; i < AC_PATH_COUNT; ++i)
    {
        cp.pStoragePath[i] = pStoragePath[i];
    }

    return MQpDeviceIoControl(
            hDevice,
            IOCTL_AC_CONNECT,
            0,
            0,
            &cp,
            sizeof(cp)
            );
}

inline
HRESULT
ACSetMachineProperties(
    HANDLE hDevice,
    ULONG ulQuota
    )
{
    return MQpDeviceIoControl(
            hDevice,
            IOCTL_AC_SET_MACHINE_PROPS,
            0,
            0,
            0,
            ulQuota
            );
}

inline
HRESULT
ACAssociateQueue(
    HANDLE hFromQueue,
    HANDLE hToQueue,
    ULONG DesiredAccess,
    ULONG ShareAccess,
    bool  fProtocolSrmp
    )
{
    return MQpDeviceIoControl(
            hFromQueue,
            IOCTL_AC_ASSOCIATE_QUEUE,
            reinterpret_cast<PVOID>(fProtocolSrmp),
            DesiredAccess,
            hToQueue,
            ShareAccess
            );
}

inline
HRESULT
ACAssociateJournal(
    HANDLE hFromQueue,
    HANDLE hToQueue,
    ULONG DesiredAccess,
    ULONG ShareAccess
    )
{
    return MQpDeviceIoControl(
            hFromQueue,
            IOCTL_AC_ASSOCIATE_JOURNAL,
            0,
            DesiredAccess,
            hToQueue,
            ShareAccess
            );
}

inline
HRESULT
ACAssociateDeadxact(
    HANDLE hFromQueue,
    HANDLE hToQueue,
    ULONG DesiredAccess,
    ULONG ShareAccess
    )
{
    return MQpDeviceIoControl(
            hFromQueue,
            IOCTL_AC_ASSOCIATE_DEADXACT,
            0,
            DesiredAccess,
            hToQueue,
            ShareAccess
            );
}

inline
HRESULT
ACPutRestoredPacket(
    HANDLE hQueue,
    CPacket * pPacket
    )
{
    return MQpDeviceIoControl(
            hQueue,
            IOCTL_AC_PUT_RESTORED_PACKET,
            0,
            0,
            pPacket,
            0
            );
}

inline
HRESULT
ACGetRestoredPacket(
    HANDLE hDriver,
    CACRestorePacketCookie * pPacketCookie
    )
{

    return MQpDeviceIoControl(
            hDriver,
            IOCTL_AC_GET_RESTORED_PACKET,
            0,
            0,
            pPacketCookie,
            sizeof(CACRestorePacketCookie)
            );
}

inline
HRESULT
ACGetPacketByCookie(
    HANDLE hDriver,
    CACPacketPtrs * pPacketPtrs
    )
{
    return MQpDeviceIoControl(
               hDriver,
               IOCTL_AC_GET_PACKET_BY_COOKIE,
               0,
               0,
               pPacketPtrs,
               sizeof(CACPacketPtrs)
               );
}

inline
HRESULT
ACRestorePackets(
    HANDLE hDriver,
    PWSTR pLogPath,
    PWSTR pFilePath,
    ULONG ulFileID,
    ACPoolType pt
    )
{
    return MQpDeviceIoControl(
            hDriver,
            IOCTL_AC_RESTORE_PACKETS,
            pLogPath,
            pt,
            pFilePath,
            ulFileID
            );
}

inline
HRESULT
ACSetMappedLimit(
   HANDLE hDriver,	
   ULONG ulMaxMappedFiles
    )
{
    return MQpDeviceIoControl(
            hDriver,
            IOCTL_AC_SET_MAPPED_LIMIT,
            0,
            0,
            0,
            ulMaxMappedFiles
            );
}

inline
HRESULT
ACSetPerformanceBuffer(
    HANDLE hDriver,
    HANDLE hPerformanceSection,
    PVOID  pvPerformanceBuffer,
    QueueCounters *pMachineQueueCounters,
    QmCounters *pQmCounters
    )
{
#ifdef _WIN64
    CACSetPerformanceBuffer cPerf = {
        hPerformanceSection,
        pvPerformanceBuffer,
        pMachineQueueCounters,
        pQmCounters
    };
    return MQpDeviceIoControl(
            hDriver,
            IOCTL_AC_SET_PERFORMANCE_BUFF,
            0,
            0,
            &cPerf,
            sizeof(cPerf)
            );
#else //!_WIN64
    return MQpDeviceIoControl(
            hDriver,
            IOCTL_AC_SET_PERFORMANCE_BUFF,
            hPerformanceSection,
            reinterpret_cast<DWORD>(pQmCounters),
            pvPerformanceBuffer,
            reinterpret_cast<DWORD>(pMachineQueueCounters)
            );
#endif //_WIN64
}

inline
HRESULT
ACReleaseResources(
    HANDLE hDevice
    )
{
    return MQpDeviceIoControl(
                hDevice,
                IOCTL_AC_RELEASE_RESOURCES,
                0,
                0,
                0,
                0
                );
}


inline
HRESULT
ACConvertPacket(
	HANDLE       hDriver,
	CPacket *    pDriverPacket,
    BOOL         fStore,
	LPOVERLAPPED lpOverlapped
	)
{
   return MQpDeviceIoControl(
				hDriver,
                IOCTL_AC_CONVERT_PACKET,
                0,
                fStore,
                pDriverPacket,
                0,
                lpOverlapped
                );
}

inline
HRESULT
ACIsSequenceOnHold(
    HANDLE hQueue,
    CPacket * pDriverPacket
    )
{
    return MQpDeviceIoControl(
            hQueue,
            IOCTL_AC_IS_SEQUENCE_ON_HOLD,
            0,
            0,
            pDriverPacket,
            0
            );
}


inline
HRESULT
ACSetSequenceAck(
    HANDLE hQueue,
    LONGLONG liAckSeqID,
    ULONG    ulAckSeqN
    )
{
    CACSetSequenceAck ssa;
    ssa.liAckSeqID = liAckSeqID;
    ssa.ulAckSeqN  = ulAckSeqN;

    return MQpDeviceIoControl(
                hQueue,
                IOCTL_AC_SET_SEQUENCE_ACK,
                0,
                0,
                &ssa,
                sizeof(ssa)
                );
}


//---------------------------------------------------------
//
// QM network interface APIs
//
//---------------------------------------------------------

inline
HRESULT
ACAllocatePacket(
    HANDLE hDevice,
    ACPoolType pt,
    DWORD dwSize,
    CACPacketPtrs& PacketPtrs,
    BOOL fCheckMachineQuota = TRUE
    )
{

    return MQpDeviceIoControl(
            hDevice,
            IOCTL_AC_ALLOCATE_PACKET,
            reinterpret_cast<PVOID>((ULONG_PTR)fCheckMachineQuota),
            pt,
            &PacketPtrs,
            dwSize
            );
}

inline
HRESULT
ACFreePacket(
    HANDLE hDevice,
    CPacket * pDriverPacket,
    USHORT usClass = 0
    )
{
    return MQpDeviceIoControl(
            hDevice,
            IOCTL_AC_FREE_PACKET,
            0,
            0,
            pDriverPacket,
            usClass
            );
}

inline
HRESULT
ACFreePacket2(
    HANDLE hDevice,
    const VOID* pCookie,
    USHORT usClass = 0
    )
{
    return MQpDeviceIoControl(
            hDevice,
            IOCTL_AC_FREE_PACKET2,
            0,
            0,
            const_cast<VOID*>(pCookie),
            usClass
            );
}

inline
HRESULT
ACFreePacket1(
    HANDLE hDevice,
    const VOID* pCookie,
    USHORT usClass = 0
    )
{
    return MQpDeviceIoControl(
            hDevice,
            IOCTL_AC_FREE_PACKET1,
            0,
            0,
            const_cast<VOID*>(pCookie),
            usClass
            );
}

inline
HRESULT
ACArmPacketTimer(
    HANDLE hDevice,
    const VOID* pCookie,
    BOOL fTimeToBeReceived,
    ULONG ulDelay
    )
{
    return MQpDeviceIoControl(
            hDevice,
            IOCTL_AC_ARM_PACKET_TIMER,
            0,
            ulDelay,
            const_cast<VOID*>(pCookie),
            fTimeToBeReceived
            );
}

//
//  Using this API, it is imposible to determine when the operation
//  is completed
//
inline
HRESULT
ACPutPacket(
    HANDLE hQueue,
    CPacket * pDriverPacket
    )
{
    return MQpDeviceIoControl(
            hQueue,
            IOCTL_AC_PUT_PACKET,
            0,
            0,
            pDriverPacket,
            0
            );
}

//
//  Asynchronous, using an overlapped
//
inline
HRESULT
ACPutPacket(
    HANDLE hQueue,
    CPacket * pDriverPacket,
    LPOVERLAPPED lpOverlapped
    )
{
    return MQpDeviceIoControl(
            hQueue,
            IOCTL_AC_PUT_PACKET,
            0,
            0,
            pDriverPacket,
            0,
            lpOverlapped
            );
}

//
//  Asynchronous, using an overlapped;  with Receive setting
//
inline
HRESULT
ACPutPacket1(
    HANDLE hQueue,
    CPacket * pDriverPacket,
    LPOVERLAPPED lpOverlapped
    )
{
    return MQpDeviceIoControl(
            hQueue,
            IOCTL_AC_PUT_PACKET1,
            0,
            0,
            pDriverPacket,
            0,
            lpOverlapped
            );
}

inline
HRESULT
ACGetPacket(
    HANDLE hQueue,
    CACPacketPtrs& PacketPtrs,
    LPOVERLAPPED lpOverlapped
    )
{
    return MQpDeviceIoControl(
            hQueue,
            IOCTL_AC_GET_PACKET,
            0,
            0,
            &PacketPtrs,
            sizeof(PacketPtrs),
            lpOverlapped
            );
}

inline
HRESULT
ACCreateGroup(
    PHANDLE phGroup,
    BOOL    fPeekByPriority
    )
{
    HRESULT rc;
    rc = MQpCreateFileW(
            MQAC_NAME,
            GENERIC_READ,
            FILE_SHARE_READ,
            0,
            CREATE_ALWAYS,
            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
            phGroup
            );

    if(FAILED(rc))
    {
        return rc;
    }

    rc = MQpDeviceIoControl(
            *phGroup,
            IOCTL_AC_CREATE_GROUP,
            0,
            fPeekByPriority,
            0,
            0
            );

    if(FAILED(rc))
    {
        ACCloseHandle(*phGroup);
    }

    return rc;
}

inline
HRESULT
ACCanCloseQueue(
    HANDLE hQueue
    )
{
    return MQpDeviceIoControl(
            hQueue,
            IOCTL_AC_CAN_CLOSE_QUEUE,
            0,
            0,
            0,
            0
            );
}

inline
HRESULT
ACMoveQueueToGroup(
    HANDLE hQueue,
    HANDLE hGroup
    )
{
    return MQpDeviceIoControl(
            hQueue,
            IOCTL_AC_MOVE_QUEUE_TO_GROUP,
            0,
            0,
            hGroup,
            0
            );
}

//----------------------------------------------------
//
//   APIs for remote reading.
//
//----------------------------------------------------

inline
HRESULT
ACBeginGetPacket2Remote(
    HANDLE hQueue,
    CACGet2Remote& g2r,
    CACPacketPtrs& packetPtrs,
    LPOVERLAPPED lpOverlapped
    )
{
    return MQpDeviceIoControl(
            hQueue,
            IOCTL_AC_BEGIN_GET_PACKET_2REMOTE,
            &g2r,
            sizeof(g2r),
            &packetPtrs,
            sizeof(packetPtrs),
            lpOverlapped
            );
}

inline
HRESULT
ACEndGetPacket2Remote(
    HANDLE hQueue,
    CACGet2Remote& g2r
    )
{
    return MQpDeviceIoControl(
            hQueue,
            IOCTL_AC_END_GET_PACKET_2REMOTE,
            0,
            0,
            &g2r,
            sizeof(g2r)
            );
}

inline
HRESULT
ACCancelRequest(
    HANDLE hQueue,
    NTSTATUS status,
    ULONG ulTag
    )
{
    return MQpDeviceIoControl(
            hQueue,
            IOCTL_AC_CANCEL_REQUEST,
            0,
            status,
            0,
            ulTag
            );
}

inline
HRESULT
ACPutRemotePacket(
    HANDLE hQueue,
    ULONG ulTag,
    CPacket * pDriverPacket
    )
{
    return MQpDeviceIoControl(
            hQueue,
            IOCTL_AC_PUT_REMOTE_PACKET,
            0,
            0,
            pDriverPacket,
            ulTag
            );
}

//----------------------------------------------------
//
//   APIs for transaction processing
//
//----------------------------------------------------


inline
HRESULT
ACXactCommit1(
    HANDLE hXact,
    LPOVERLAPPED lpOverlapped
    )
{
    return MQpDeviceIoControl(
            hXact,
            IOCTL_AC_XACT_COMMIT1,
            0,
            0,
            0,
            0,
            lpOverlapped
            );
}

inline
HRESULT
ACXactCommit2(
    HANDLE hXact,
	LPOVERLAPPED lpOverlapped
    )
{
    return MQpDeviceIoControl(
            hXact,
            IOCTL_AC_XACT_COMMIT2,
            0,
            0,
            0,
			0,
            lpOverlapped
            );
}

inline
HRESULT
ACXactCommit3(
    HANDLE hXact
    )
{
    return MQpDeviceIoControl(
            hXact,
            IOCTL_AC_XACT_COMMIT3,
            0,
            0,
            0,
			0
            );
}

inline
HRESULT
ACXactAbort1(
    HANDLE hXact,
	LPOVERLAPPED lpOverlapped
    )
{
    return MQpDeviceIoControl(
            hXact,
            IOCTL_AC_XACT_ABORT1,
            0,
            0,
            0,
			0,
            lpOverlapped
            );
}

inline
HRESULT
ACXactAbort2(
    HANDLE hXact
    )
{
    return MQpDeviceIoControl(
            hXact,
            IOCTL_AC_XACT_ABORT2,
            0,
            0,
            0,
			0
            );
}


inline
HRESULT
ACXactPrepare(
    HANDLE hXact,
    LPOVERLAPPED lpOverlapped
    )
{
    return MQpDeviceIoControl(
            hXact,
            IOCTL_AC_XACT_PREPARE,
            0,
            0,
            0,
            0,
            lpOverlapped
            );
}

inline
HRESULT
ACXactPrepareDefaultCommit(
    HANDLE hXact,
    LPOVERLAPPED lpOverlapped
    )
{
    return MQpDeviceIoControl(
            hXact,
            IOCTL_AC_XACT_PREPARE_DEFAULT_COMMIT,
            0,
            0,
            0,
            0,
            lpOverlapped
            );
}


#endif // _ACAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\admcomnd.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    admcomnd.h


Abstract:

    Definitions of explorer commands passed to the QM
  
Author:

	David Reznick (t-davrez)


--*/
#ifndef __ADMCOMND_H
#define __ADMCOMND_H

#define ADMIN_COMMANDS_TITLE       (L"QM-Admin Commands")
#define ADMIN_RESPONSE_TITLE       (L"QM Response Message")
#define ADMIN_REPORTMSG_TITLE      (L"Report Message")
#define ADMIN_REPORTCONFLICT_TITLE (L"Report Message Conflict")    
#define ADMIN_PING_RESPONSE_TITLE  (L"Ping Response")    
#define ADMIN_DEPCLI_RESPONSE_TITLE  (L"Dependent Clients Response")    

#define ADMIN_SET_REPORTQUEUE    (L"Set Report Queue")
#define ADMIN_GET_REPORTQUEUE    (L"Get Report Queue")
#define ADMIN_SET_PROPAGATEFLAG  (L"Set Propagate Flag")
#define ADMIN_GET_PROPAGATEFLAG  (L"Get Propagate Flag")
#define ADMIN_SEND_TESTMSG       (L"Send Test Message")
#define ADMIN_GET_PRIVATE_QUEUES (L"Get Private Queues")
#define ADMIN_PING               (L"Ping")
#define ADMIN_GET_DEPENDENTCLIENTS (L"Get Dependent Clients")


#define PROPAGATE_STRING_FALSE (L"FALSE")
#define PROPAGATE_FLAG_FALSE ((unsigned char)0)

#define PROPAGATE_STRING_TRUE  (L"TRUE")
#define PROPAGATE_FLAG_TRUE  ((unsigned char)1)

#define ADMIN_STAT_OK            ((unsigned char)0)
#define ADMIN_STAT_ERROR         ((unsigned char)1)
#define ADMIN_STAT_NOVALUE       ((unsigned char)2)

#define COMMAND(x) (x,wcslen(x))

#define ADMIN_COMMAND_DELIMITER ';'

#define ADMIN_COMMANDS_TIMEOUT 0xffffffff
#define REPORT_MSGS_TIMEOUT    600                  // report message time to reach queue is 10 minutes

#define STRING_UUID_SIZE 38  // Wide-Characters (includiing - "{}")

#define MAX_ADMIN_RESPONSE_SIZE 1024

//
// QM response structure (The first byte of the response message holds the
//                        status)                           
//
struct QMResponse
{
    DWORD  dwResponseSize;

    UCHAR  uStatus;   
    UCHAR  uResponseBody[MAX_ADMIN_RESPONSE_SIZE];
};
//
// response structure For Get private Queue request                           
//
#ifdef _WIN64
#define QMGetPrivateQResponse_POS32 DWORD //should be 32 bit value also on win64
#else //!_WIN64
#define QMGetPrivateQResponse_POS32 LPVOID
#endif //_WIN64

#define MAX_GET_PRIVATE_RESPONSE_SIZE 4096
struct QMGetPrivateQResponse
{
    HRESULT hr;
    DWORD   dwNoOfQueues;
    DWORD   dwResponseSize;
    QMGetPrivateQResponse_POS32 pos;
    UCHAR   uResponseBody[MAX_GET_PRIVATE_RESPONSE_SIZE];
};


// 
// Client names structure - for passing the list of dependent clients
//
typedef struct _ClientNames {
    ULONG   cbClients;          // Number of client names
    ULONG   cbBufLen;           // Buffer length
    WCHAR   rwName[1];          // buffer with zero-trailed names
} ClientNames;

#endif __ADMCOMND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\acdef.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:
    acdef.h

Abstract:
    Falcon interface stractures used by the AC driver.

Author:
    Erez Haba (erezh) 25-Feb-96
    Shai Kariv (shaik) 11-May-2000

Note:
    This file is compiled in Kernel Mode and User Mode.

--*/

#ifndef _ACDEF_H
#define _ACDEF_H

#include <mqperf.h>
#include <xactdefs.h>
#include <qformat.h>

class CPacket;
struct CBaseHeader;

//
//  Number of pools used for storage
//  Reliable, Persistant, Journal, Deadletter
//
enum ACPoolType {
    ptReliable,
    ptPersistent,
    ptJournal,
    ptLastPool
};

//
//  Path count is pool count plus one for the log path
//
#define AC_PATH_COUNT (ptLastPool + 1)


//---------------------------------------------------------
//
//  class CACRequest
//  AC Request packet passed from AC to QM
//
//---------------------------------------------------------

//
//  Context used by remote reader, stored in CProxy
//
struct CRRContext {
    ULONG cli_pQMQueue;     // pointer to qm machine 'queue'
    HANDLE cli_hACQueue;    // local qm handle to ac queue
    ULONG srv_pQMQueue;     // remote qm queue object
    ULONG srv_hACQueue;     // remote qm handle to ac queue
    PVOID pRRContext;       // PCTX_RRSESSION_HANDLE_TYPE rpc context used
    PVOID pCloseCS;         // CRITICAL_SECTION* local qm critical seciton pointer
    //
    // real pointer to qm machine 'queue'. cli_pQMQueue above is
    // just a mapping, and only used for the RPC QMGetRemoteQueueName
    // (used by MQCreateCursor) where it is specified as DWORD. That DWORD
    // value is returned by RT->AC call ACCreateCursor in
    // CACCreateLocalCursor.
    //
    PVOID cli_pQMQueue2; // CRRQueue*
};

class CACRequest {
public:

    enum RequestFunction {
        rfAck,
        rfStorage,
        rfCreatePacket,
        rfMessageID,
        rfRemoteRead,
        rfRemoteCancelRead,
        rfRemoteCloseQueue,
        rfRemoteCloseCursor,
        rfRemotePurgeQueue,
        rfTimeout,
        rfEventLog,
    };

    CACRequest(RequestFunction _rf);

public:
    LIST_ENTRY m_link;

    RequestFunction rf;

    union {

        //
        //
        //
        struct {
            ACPoolType pt;
            BOOL fSuccess;
            ULONG ulFileCount;
        } EventLog;

        //
        //  Save message ID request
        //
        struct {
            ULONGLONG Value;
        } MessageID;

        //
        //  Storage request
        //
        struct {
            CBaseHeader* pPacket;
            CPacket* pDriverPacket;
            PVOID pAllocator;
			ULONG ulSize;
        } Storage;

        //
        // CreatePacket request
        //
        struct {
            CBaseHeader *  pPacket;
            CPacket *      pDriverPacket;
            bool           fProtocolSrmp;
        } CreatePacket;

        //
        //  Timeout request (xact)
        //
        struct {
            CBaseHeader* pPacket;
            CPacket* pDriverPacket;
            BOOL fTimeToBeReceived;
        } Timeout;

        //
        //  ACK/NACK request
        //
        struct {
            CBaseHeader* pPacket;
            CPacket* pDriverPacket;
            ULONG ulClass;
            BOOL fUser;
            BOOL fOrder;
        } Ack;

        //
        //  Remote requests
        //
        struct {

            //
            //  context needed for all requests
            //
            CRRContext Context;

            union {
                //
                //  Receive/Peek request
                //
                struct {
                    ULONG ulTag;            // request identifier
                    ULONG hRemoteCursor;
                    ULONG ulAction;
                    ULONG ulTimeout;
                    bool  fReceiveByLookupId;
                    ULONGLONG LookupId;
                } Read;

                //
                //  Cancel remote read request
                //
                struct {
                    ULONG ulTag;        // request identifier
                } CancelRead;

                //
                //  Close remote queue request
                //
                struct {
                } CloseQueue;

                //
                //  Close remote cursor request
                //
                struct {
                    ULONG hRemoteCursor;
                } CloseCursor;

                //
                //  Purge remote queue request
                //
                struct {
                } PurgeQueue;
            };
        } Remote;
    };
};

inline CACRequest::CACRequest(RequestFunction _rf)
{
    rf = _rf;
}

//---------------------------------------------------------
//
//  class CACCreateQueueParameters
//
//---------------------------------------------------------

class CACCreateQueueParameters {
public:
    BOOL fTargetQueue;
    const GUID* pDestGUID;
    const QUEUE_FORMAT* pQueueID;
    QueueCounters* pQueueCounters;
    LONGLONG liSeqID;               // Note: align on 8
    ULONG ulSeqN;
};

//---------------------------------------------------------
//
//  struct CACSetQueueProperties
//
//---------------------------------------------------------

struct CACSetQueueProperties {
    BOOL fJournalQueue;
    BOOL fAuthenticate;
    ULONG ulPrivLevel;
    ULONG ulQuota;
    ULONG ulJournalQuota;
    LONG lBasePriority;
    BOOL fTransactional;
    BOOL fUnknownType;
    const GUID* pgConnectorQM;
};


//---------------------------------------------------------
//
//  struct CACGetQueueProperties
//
//---------------------------------------------------------

struct CACGetQueueProperties {
    ULONG ulCount;
    ULONG ulQuotaUsed;
    ULONG ulJournalCount;
    ULONG ulJournalQuotaUsed;
    ULONG ulPrevNo;
    ULONG ulSeqNo;
    LONGLONG liSeqID;
};

//---------------------------------------------------------
//
//  struct CACGetQueueHandleProperties
//
//---------------------------------------------------------

struct CACGetQueueHandleProperties {
    //
    // SRMP protocol is used for http queue (direct=http or multicast) and for members
    // in distribution that are http queues.
    //
    bool  fProtocolSrmp;

    //
    // MSMQ proprietary protocol is used for non-http queue and for members in 
    // distribution that are non-http queues.
    //
    bool  fProtocolMsmq;
};

//---------------------------------------------------------
//
//  class CACRemoteProxyProp
//
//---------------------------------------------------------

class CACCreateRemoteProxyParameters {
public:
    const QUEUE_FORMAT* pQueueID;
    CRRContext Context;
};

//---------------------------------------------------------
//
//  class CACGet2Remote
//
//---------------------------------------------------------

class CACGet2Remote {
public:
   ULONG  RequestTimeout;
   ULONG  Action;
   HACCursor32 Cursor;
   CBaseHeader *  lpPacket;
   CPacket *  lpDriverPacket;
   ULONG* pTag;
   bool      fReceiveByLookupId;
   ULONGLONG LookupId;
};

//---------------------------------------------------------
//
//  class CACConnectParameters
//
//---------------------------------------------------------

class CACConnectParameters {
public:
   ULONGLONG MessageID;
   LONGLONG liSeqIDAtRestore;
   const GUID* pgSourceQM;
   ULONG ulPoolSize;
   PWCHAR pStoragePath[AC_PATH_COUNT];
   BOOL   fXactCompatibilityMode;
};

//---------------------------------------------------------
//
//  class CACXactInformation
//
//---------------------------------------------------------

class CACXactInformation {
public:
   	ULONG nReceives;
	ULONG nSends;
};

//---------------------------------------------------------
//
//  class CACSetSequenceAck
//
//---------------------------------------------------------

class CACSetSequenceAck {
public:
    LONGLONG liAckSeqID;
    ULONG    ulAckSeqN;
};

#ifdef _WIN64
//---------------------------------------------------------
//
//  class CACSetPerformanceBuffer
//
//---------------------------------------------------------

class CACSetPerformanceBuffer {
public:
   HANDLE hPerformanceSection;
   PVOID  pvPerformanceBuffer;
   QueueCounters *pMachineQueueCounters;
   QmCounters *pQmCounters;
};
#endif //_WIN64

//---------------------------------------------------------
//
//  class CACPacketPtrs
//
//---------------------------------------------------------

class CACPacketPtrs {
public:
   CBaseHeader * pPacket;
   CPacket *  pDriverPacket;
};

//---------------------------------------------------------
//
//  class CACRestorePacketCookie
//
//---------------------------------------------------------

class CACRestorePacketCookie {
public:
   ULONGLONG  SeqId;
   CPacket *  pDriverPacket;
};

//--------------------------------------------------------------
//
//  class CACCreateLocalCursor
//
//  Note: Parameters to create a local cursor.
//        CACCreateRemoteCursor (in qmrt.idl) defines parameters
//        for creating a remote cursor (used by dependent client
//        1.0 and 2.0).
//
//--------------------------------------------------------------

class CACCreateLocalCursor {
public:
	HACCursor32 hCursor;
	ULONG       srv_hACQueue;
	ULONG       cli_pQMQueue;
};

//--------------------------------------------------------------
//
//  class CACCreateDistributionParameters
//
//--------------------------------------------------------------

class CACCreateDistributionParameters {
public:
	const QUEUE_FORMAT * TopLevelQueueFormats;
    ULONG                nTopLevelQueueFormats;
    const HANDLE *       hQueues;
    const bool *         HttpSend;
    ULONG                nQueues;
};

//------------------------------------------------------------------
//
// MESSAGE_PROPERTIES macro.
//
//------------------------------------------------------------------
#define MESSAGE_PROPERTIES(AC_POINTER)                         \
    USHORT   AC_POINTER            pClass;                     \
    OBJECTID AC_POINTER AC_POINTER ppMessageID;                \
    UCHAR    AC_POINTER AC_POINTER ppCorrelationID;            \
                                                               \
    ULONG    AC_POINTER            pSentTime;                  \
    ULONG    AC_POINTER            pArrivedTime;               \
                                                               \
    UCHAR    AC_POINTER            pPriority;                  \
    UCHAR    AC_POINTER            pDelivery;                  \
    UCHAR    AC_POINTER            pAcknowledge;               \
                                                               \
    UCHAR    AC_POINTER            pAuditing;                  \
    ULONG    AC_POINTER            pApplicationTag;            \
                                                               \
    UCHAR    AC_POINTER AC_POINTER ppBody;                     \
    ULONG                          ulBodyBufferSizeInBytes;    \
    ULONG                          ulAllocBodyBufferInBytes;   \
    ULONG    AC_POINTER            pBodySize;                  \
                                                               \
    WCHAR    AC_POINTER AC_POINTER ppTitle;                    \
    ULONG                          ulTitleBufferSizeInWCHARs;  \
    ULONG    AC_POINTER            pulTitleBufferSizeInWCHARs; \
                                                               \
    ULONG                          ulAbsoluteTimeToQueue;      \
    ULONG    AC_POINTER            pulRelativeTimeToQueue;     \
    ULONG                          ulRelativeTimeToLive;       \
    ULONG    AC_POINTER            pulRelativeTimeToLive;      \
                                                               \
    UCHAR    AC_POINTER            pTrace;                     \
    ULONG    AC_POINTER            pulSenderIDType;            \
    UCHAR    AC_POINTER AC_POINTER ppSenderID;                 \
    ULONG    AC_POINTER            pulSenderIDLenProp;         \
                                                               \
    ULONG    AC_POINTER            pulPrivLevel;               \
    ULONG                          ulAuthLevel;                \
    UCHAR    AC_POINTER            pAuthenticated;             \
                                                               \
    ULONG    AC_POINTER            pulHashAlg;                 \
    ULONG    AC_POINTER            pulEncryptAlg;              \
                                                               \
    UCHAR    AC_POINTER AC_POINTER ppSenderCert;               \
    ULONG                          ulSenderCertLen;            \
    ULONG    AC_POINTER            pulSenderCertLenProp;       \
                                                               \
    WCHAR    AC_POINTER AC_POINTER ppwcsProvName;              \
    ULONG                          ulProvNameLen;              \
    ULONG    AC_POINTER            pulAuthProvNameLenProp;     \
                                                               \
    ULONG    AC_POINTER            pulProvType;                \
    BOOL                           fDefaultProvider;           \
                                                               \
    UCHAR    AC_POINTER AC_POINTER ppSymmKeys;                 \
    ULONG                          ulSymmKeysSize;             \
    ULONG    AC_POINTER            pulSymmKeysSizeProp;        \
                                                               \
    UCHAR                          bEncrypted;                 \
    UCHAR                          bAuthenticated;             \
                                                               \
    USHORT                         uSenderIDLen;               \
    UCHAR    AC_POINTER AC_POINTER ppSignature;                \
    ULONG                          ulSignatureSize;            \
    ULONG    AC_POINTER            pulSignatureSizeProp;       \
                                                               \
    GUID     AC_POINTER AC_POINTER ppSrcQMID;                  \
    XACTUOW  AC_POINTER            pUow;                       \
                                                               \
    UCHAR    AC_POINTER AC_POINTER ppMsgExtension;             \
    ULONG                          ulMsgExtensionBufferInBytes;\
    ULONG    AC_POINTER            pMsgExtensionSize;          \
                                                               \
    GUID     AC_POINTER AC_POINTER ppConnectorType;            \
    ULONG    AC_POINTER            pulBodyType;                \
                                                               \
    ULONG    AC_POINTER            pulVersion;                 \
    UCHAR    AC_POINTER            pbFirstInXact;              \
    UCHAR    AC_POINTER            pbLastInXact;               \
    OBJECTID AC_POINTER AC_POINTER ppXactID;                   \
                                                               \
    ULONGLONG AC_POINTER           pLookupId;                  \
                                                               \
    WCHAR    AC_POINTER AC_POINTER ppSrmpEnvelope;             \
    ULONG    AC_POINTER            pSrmpEnvelopeBufferSizeInWCHARs; \
                                                               \
    UCHAR    AC_POINTER AC_POINTER ppCompoundMessage;          \
    ULONG                          CompoundMessageSizeInBytes; \
    ULONG    AC_POINTER            pCompoundMessageSizeInBytes;\
                                                               \
    ULONG                          EodStreamIdSizeInBytes;     \
    ULONG    AC_POINTER            pEodStreamIdSizeInBytes;    \
    UCHAR    AC_POINTER AC_POINTER ppEodStreamId;              \
    ULONG                          EodOrderQueueSizeInBytes;   \
    ULONG    AC_POINTER            pEodOrderQueueSizeInBytes;  \
    UCHAR    AC_POINTER AC_POINTER ppEodOrderQueue;            \
                                                               \
    LONGLONG AC_POINTER            pEodAckSeqId;               \
    LONGLONG AC_POINTER            pEodAckSeqNum;              \
    ULONG                          EodAckStreamIdSizeInBytes;  \
    ULONG    AC_POINTER            pEodAckStreamIdSizeInBytes; \
    UCHAR    AC_POINTER AC_POINTER ppEodAckStreamId;


//------------------------------------------------------------------
//
// SEND_PARAMETERS macro.
//
//------------------------------------------------------------------
#define SEND_PARAMETERS(AC_POINTER, AC_QUEUE_FORMAT)           \
    AC_QUEUE_FORMAT AC_POINTER     AdminMqf;                   \
    ULONG                          nAdminMqf;                  \
    AC_QUEUE_FORMAT AC_POINTER     ResponseMqf;                \
    ULONG                          nResponseMqf;               \
    UCHAR    AC_POINTER AC_POINTER ppSignatureMqf;             \
    ULONG                          SignatureMqfSize;		   \
    UCHAR    AC_POINTER AC_POINTER ppXmldsig;                  \
    ULONG                          ulXmldsigSize;              \
    WCHAR    AC_POINTER AC_POINTER ppSoapHeader;               \
    WCHAR    AC_POINTER AC_POINTER ppSoapBody;                 \
                                                               

//------------------------------------------------------------------
//
// RECEIVE_PARAMETERS macro.
//
//------------------------------------------------------------------
#define RECEIVE_PARAMETERS(AC_POINTER)                           \
    HACCursor32                    Cursor;                       \
    ULONG                          RequestTimeout;               \
    ULONG                          Action;                       \
    ULONG                          Asynchronous;                 \
    ULONGLONG                      LookupId;                     \
                                                                 \
    WCHAR AC_POINTER AC_POINTER    ppDestFormatName;             \
    ULONG AC_POINTER               pulDestFormatNameLenProp;     \
                                                                 \
    WCHAR AC_POINTER AC_POINTER    ppAdminFormatName;            \
    ULONG AC_POINTER               pulAdminFormatNameLenProp;    \
                                                                 \
    WCHAR AC_POINTER AC_POINTER    ppResponseFormatName;         \
    ULONG AC_POINTER               pulResponseFormatNameLenProp; \
                                                                 \
    WCHAR AC_POINTER AC_POINTER    ppOrderingFormatName;         \
    ULONG AC_POINTER               pulOrderingFormatNameLenProp; \
                                                                 \
    WCHAR AC_POINTER AC_POINTER    ppDestMqf;                    \
    ULONG AC_POINTER               pulDestMqfLenProp;            \
                                                                 \
    WCHAR AC_POINTER AC_POINTER    ppAdminMqf;                   \
    ULONG AC_POINTER               pulAdminMqfLenProp;           \
                                                                 \
    WCHAR AC_POINTER AC_POINTER    ppResponseMqf;                \
    ULONG AC_POINTER               pulResponseMqfLenProp;        \
                                                                 \
    UCHAR AC_POINTER AC_POINTER    ppSignatureMqf;               \
    ULONG                          SignatureMqfSize;             \
    ULONG AC_POINTER               pSignatureMqfSize;


//------------------------------------------------------------------
//
// CACMessageProperties, CACSendParameters, CACReceiveParameters
//
// Note: changes here should also be reflected in:
//       * 64 bit Helper structures (ac\acctl32.*)
//       * Dependent client handling (qm\depclient.cpp)
//       * Corresponding XXX_32 structs (in this module)
//
//------------------------------------------------------------------

#ifndef _WIN64
#pragma pack(push, 4)
#endif

class CACMessageProperties {
    //
    // Private constructor prevents creating this object explicitly. Friend declaration allows aggregation.
    // 
    friend class CACSendParameters;
    friend class CACReceiveParameters;
private:
    CACMessageProperties() {}

public:
    MESSAGE_PROPERTIES(*);
};


class CACSendParameters {
public:
    CACSendParameters() { memset(this, 0, sizeof(*this)); };

public:
    CACMessageProperties MsgProps;
    SEND_PARAMETERS(*, QUEUE_FORMAT);
};


class CACReceiveParameters {
public:
    CACReceiveParameters() { memset(this, 0, sizeof(*this)); };

public:
    CACMessageProperties MsgProps;
    RECEIVE_PARAMETERS(*);
};

#ifndef _WIN64
#pragma pack(pop)
#endif

//------------------------------------------------------------------
//
// CACMessageProperties_32, CACSendParameters_32, CACReceiveParameters_32
//
//------------------------------------------------------------------

#ifdef _WIN64

#pragma pack(push, 4)

class CACMessageProperties_32 {
    //
    // Private constructor prevents creating this object explicitly. Friend declaration allows aggregation.
    // 
    friend class CACSendParameters_32;
    friend class CACReceiveParameters_32;
private:
    CACMessageProperties_32() {}

public:
    MESSAGE_PROPERTIES(*POINTER_32);
};


class CACSendParameters_32 {
public:
    CACSendParameters_32() { memset(this, 0, sizeof(*this)); };

public:
    CACMessageProperties_32 MsgProps;
    SEND_PARAMETERS(*POINTER_32, QUEUE_FORMAT_32);
};


class CACReceiveParameters_32 {
public:
    CACReceiveParameters_32() { memset(this, 0, sizeof(*this)); };

public:
    CACMessageProperties_32 MsgProps;
    RECEIVE_PARAMETERS(*POINTER_32);
};

#pragma pack(pop)

#endif // _WIN64


//
// The following compile time asserts verify that the 32 bit structs on x86 system
// and their representations on ia64 system (XXX_32) are the same.
//
const size_t xSizeOfMessageProperties32 = 292;
const size_t xSizeOfSendParameters32 = 332;
const size_t xSizeOfReceiveParameters32 = 384;
#ifdef _WIN64
C_ASSERT(sizeof(CACMessageProperties_32) == xSizeOfMessageProperties32);
C_ASSERT(sizeof(CACSendParameters_32) == xSizeOfSendParameters32);
C_ASSERT(sizeof(CACReceiveParameters_32) == xSizeOfReceiveParameters32);
#else
C_ASSERT(sizeof(CACMessageProperties) == xSizeOfMessageProperties32);
C_ASSERT(sizeof(CACSendParameters) == xSizeOfSendParameters32);
C_ASSERT(sizeof(CACReceiveParameters) == xSizeOfReceiveParameters32);
#endif

//+----------------------------------------------------------------------
//
// Helper code to compute size (in bytes) of provider name in packet.
//
//+----------------------------------------------------------------------
inline ULONG AuthProvNameSize(const CACMessageProperties * pMsgProps)
{
    return static_cast<ULONG>(sizeof(ULONG) + 
		    ((wcslen(*(pMsgProps->ppwcsProvName)) + 1) * sizeof(WCHAR)));
}

//+----------------------------------------------------------------------
//
// Helper code to compute size (in bytes) of provider name in packet 
// for MSMQ protocol.
//
//+----------------------------------------------------------------------
inline ULONG ComputeAuthProvNameSize(const CACMessageProperties * pMsgProps)
{
    ULONG ulSize = 0 ;

    if ( (pMsgProps->ulSignatureSize != 0) && (!(pMsgProps->fDefaultProvider)) )
    {
        ulSize = AuthProvNameSize(pMsgProps);
    }

    return ulSize ;
}

#endif // _ACDEF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\adsiutil.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:
	adsiutil.h

Abstract:
	General declarations and utilities for using ADSI.

Author:
    Doron Juster (DoronJ)   23-June-1999

--*/

#ifndef __ADSIUTIL_H__
#define __ADSIUTIL_H__

#include <iads.h>
#include <adshlp.h>

//+---------------------------------------
//
// prototype of ADSI apis.
//
//+---------------------------------------

typedef
HRESULT
(WINAPI *ADsOpenObject_ROUTINE)(
    LPCWSTR lpszPathName,
    LPCWSTR lpszUserName,
    LPCWSTR lpszPassword,
    DWORD  dwReserved,
    REFIID riid,
    void * * ppObject
    );

typedef
BOOL
(WINAPI *FreeADsMem_ROUTINE) (
   LPVOID pMem
);

//+--------------------------------------------------
//
// helper class - Auto release for CoInitialize
//
//+--------------------------------------------------

class CCoInit
{
public:
    CCoInit()
    {
        m_fInited = FALSE;
    }

    ~CCoInit()
    {
        if (m_fInited)
            CoUninitialize();
    }

    HRESULT CoInitialize()
    {
        HRESULT hr;

        hr = ::CoInitializeEx(NULL, COINIT_MULTITHREADED );
        m_fInited = SUCCEEDED(hr);
        return(hr);
    }

private:
    BOOL m_fInited;
};


#endif //  __ADSIUTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\autoauthz.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:
    autoauthz.h

Abstract:
    Auto handle classes, free the handle resoruce when destructed.

Author:
    Ilan Herbst (ilanh) 18-Mar-2001

--*/

#pragma once

#ifndef _MSMQ_AUTOAUTHZ_H_
#define _MSMQ_AUTOAUTHZ_H_

#include "authz.h"

//---------------------------------------------------------
//
//  class CAUTHZ_RESOURCE_MANAGER_HANDLE
//
//---------------------------------------------------------
class CAUTHZ_RESOURCE_MANAGER_HANDLE {
public:
    CAUTHZ_RESOURCE_MANAGER_HANDLE(AUTHZ_RESOURCE_MANAGER_HANDLE h = 0) : m_h(h)  {}
   ~CAUTHZ_RESOURCE_MANAGER_HANDLE()                       { if (m_h != 0) AuthzFreeResourceManager(m_h); }

    AUTHZ_RESOURCE_MANAGER_HANDLE* operator &()            { return &m_h; }
    operator AUTHZ_RESOURCE_MANAGER_HANDLE() const         { return m_h; }
    AUTHZ_RESOURCE_MANAGER_HANDLE detach()                 { AUTHZ_RESOURCE_MANAGER_HANDLE h = m_h; m_h = 0; return h; }

private:
    CAUTHZ_RESOURCE_MANAGER_HANDLE(const CAUTHZ_RESOURCE_MANAGER_HANDLE&);
    CAUTHZ_RESOURCE_MANAGER_HANDLE& operator=(const CAUTHZ_RESOURCE_MANAGER_HANDLE&);

private:
    AUTHZ_RESOURCE_MANAGER_HANDLE m_h;
};


//---------------------------------------------------------
//
//  class CAUTHZ_CLIENT_CONTEXT_HANDLE
//
//---------------------------------------------------------
class CAUTHZ_CLIENT_CONTEXT_HANDLE {
public:
    CAUTHZ_CLIENT_CONTEXT_HANDLE(AUTHZ_CLIENT_CONTEXT_HANDLE h = 0) : m_h(h)  {}
   ~CAUTHZ_CLIENT_CONTEXT_HANDLE()                       { if (m_h != 0) AuthzFreeContext(m_h); }

    AUTHZ_CLIENT_CONTEXT_HANDLE* operator &()            { return &m_h; }
    operator AUTHZ_CLIENT_CONTEXT_HANDLE() const         { return m_h; }
    AUTHZ_CLIENT_CONTEXT_HANDLE detach()                 { AUTHZ_CLIENT_CONTEXT_HANDLE h = m_h; m_h = 0; return h; }

private:
    CAUTHZ_CLIENT_CONTEXT_HANDLE(const CAUTHZ_CLIENT_CONTEXT_HANDLE&);
    CAUTHZ_CLIENT_CONTEXT_HANDLE& operator=(const CAUTHZ_CLIENT_CONTEXT_HANDLE&);

private:
    AUTHZ_CLIENT_CONTEXT_HANDLE m_h;
};

#endif // _MSMQ_AUTOAUTHZ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\autorel.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    autorel.h

Abstract:

    Some classes for automatically releasing resources.

Author:

    Boaz Feldbaum (BoazF) 26-Jun-1997

Revision History:

--*/

#ifndef __AUTOREL_H
#define __AUTOREL_H

class CAutoCloseFileHandle
{
public:
    CAutoCloseFileHandle(HANDLE h =INVALID_HANDLE_VALUE) { m_h = h; };
    ~CAutoCloseFileHandle() { if (m_h != INVALID_HANDLE_VALUE) CloseHandle(m_h); };

public:
    CAutoCloseFileHandle & operator =(HANDLE h) {m_h = h; return *this; };
    HANDLE * operator &() { return &m_h; };
    operator HANDLE() { return m_h; };

private:
    HANDLE m_h;
};

class CAutoCloseHandle
{
public:
    CAutoCloseHandle(HANDLE h =NULL) { m_h = h; };
    ~CAutoCloseHandle() { if (m_h) CloseHandle(m_h); };

public:
    CAutoCloseHandle & operator =(HANDLE h) {m_h = h; return *this; };
    HANDLE * operator &() { return &m_h; };
    operator HANDLE() { return m_h; };

private:
    HANDLE m_h;
};

class CAutoCloseRegHandle
{
public:
    CAutoCloseRegHandle(HKEY h =NULL) { m_h = h; };
    ~CAutoCloseRegHandle() { if (m_h) RegCloseKey(m_h); };

public:
    CAutoCloseRegHandle & operator =(HKEY h) { m_h = h; return(*this); };
    HKEY * operator &() { return &m_h; };
    operator HKEY() { return m_h; };

private:
    HKEY m_h;
};

class CAutoFreeLibrary
{
public:
    CAutoFreeLibrary(HINSTANCE hLib =NULL) { m_hLib = hLib; };
    ~CAutoFreeLibrary() { if (m_hLib) FreeLibrary(m_hLib); };

public:
    CAutoFreeLibrary & operator =(HINSTANCE hLib) { m_hLib = hLib; return(*this); };
    HINSTANCE * operator &() { return &m_hLib; };
    operator HINSTANCE() { return m_hLib; };
    HINSTANCE detach() { HINSTANCE hLib = m_hLib; m_hLib = NULL; return hLib; };

private:
    HINSTANCE m_hLib;
};

#endif // __AUTOREL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\ad.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ad.h

Abstract:

    Message Queuing's Active Dirctory Header File

--*/

#ifndef __AD_H__
#define __AD_H__


#include "mqaddef.h"
#include "dsproto.h"



//********************************************************************
//                           A P I
//********************************************************************

//
//  Creating objects
//
HRESULT
ADCreateObject(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName,
                IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor,
                IN  const DWORD             cp,
                IN  const PROPID            aProp[],
                IN  const PROPVARIANT       apVar[],
                OUT GUID*                   pObjGuid
                );
//
//  Deleting objects
//
HRESULT
ADDeleteObject(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName
                );

HRESULT
ADDeleteObjectGuid(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  const GUID*             pguidObject
                );
//
//  Retreive object properties
//
HRESULT
ADGetObjectProperties(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName,
                IN  const DWORD             cp,
                IN  const PROPID            aProp[],
                IN OUT PROPVARIANT          apVar[]
                );

HRESULT
ADGetObjectPropertiesGuid(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  const GUID*             pguidObject,
                IN  const DWORD             cp,
                IN  const PROPID            aProp[],
                IN  OUT PROPVARIANT         apVar[]
                );


HRESULT
ADQMGetObjectSecurity(
                IN  AD_OBJECT               eObject,
                IN  const GUID*             pguidObject,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor,
                IN  DWORD                   nLength,
                IN  LPDWORD                 lpnLengthNeeded,
                IN  DSQMChallengeResponce_ROUTINE
                                            pfChallengeResponceProc,
                IN  DWORD_PTR               dwContext
                );


HRESULT
ADGetObjectSecurity(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  const PROPID            prop,
                IN OUT  PROPVARIANT *       pVar
                );

HRESULT
ADGetObjectSecurityGuid(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  const GUID*             pguidObject,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  const PROPID            prop,
                IN OUT  PROPVARIANT *       pVar
                );


//
// Setting object properties
//
HRESULT
ADSetObjectProperties(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName,
                IN  const DWORD             cp,
                IN  const PROPID            aProp[],
                IN  const PROPVARIANT       apVar[]
                );

HRESULT
ADSetObjectPropertiesGuid(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  const GUID*             pguidObject,
                IN  const DWORD             cp,
                IN  const PROPID            aProp[],
                IN  const PROPVARIANT       apVar[]
                );




HRESULT
ADQMSetMachineProperties(
                IN  LPCWSTR             pwcsObjectName,
                IN  const DWORD         cp,
                IN  const PROPID        aProp[],
                IN  const PROPVARIANT   apVar[],
                IN  DSQMChallengeResponce_ROUTINE pfSignProc,
                IN  DWORD_PTR           dwContext
                );

HRESULT
ADSetObjectSecurity(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  LPCWSTR                 pwcsObjectName,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  const PROPID            prop,
                IN  const PROPVARIANT *     pVar
                );


HRESULT
ADSetObjectSecurityGuid(
                IN  AD_OBJECT               eObject,
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  const GUID*             pguidObject,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  const PROPID            prop,
                IN  const PROPVARIANT *     pVar
                );

//
//  Initailzation
//
HRESULT
ADInit( 
                IN QMLookForOnlineDS_ROUTINE pLookDS,
                IN MQGetMQISServer_ROUTINE pGetServers ,
                IN bool  fDSServerFunctionality,
                IN bool  fSetupMode,
                IN bool  fQMDll,
		        IN bool  fIgnoreWorkGroup,
                IN NoServerAuth_ROUTINE pNoServerAuth,
                IN LPCWSTR szServerName,
                IN bool  fDisableDownlevelNotifications
                );

HRESULT
ADSetupInit( 
                IN    unsigned char   ucRoll,
                IN    LPWSTR          pwcsPathName,
                IN    const GUID *    pguidMasterId,
                IN    bool            fDSServerFunctionality
                );

//
//  Termination
//
void
ADTerminate();






//
//  This routine is kept only for MSMQ 1.0 purposes.
//
HRESULT
ADCreateServersCache();




HRESULT
ADGetComputerSites(
                IN  LPCWSTR     pwcsComputerName,
                OUT DWORD  *    pdwNumSites,
                OUT GUID **     ppguidSites
                );


HRESULT
ADBeginDeleteNotification(
                IN AD_OBJECT                eObject,
                IN LPCWSTR                  pwcsDomainController,
                IN  bool					fServerName,
                IN LPCWSTR					pwcsObjectName,
                IN OUT HANDLE   *           phEnum
                );
HRESULT
ADNotifyDelete(
                IN  HANDLE                  hEnum
                );

HRESULT
ADEndDeleteNotification(
                IN  HANDLE                  hEnum
                );




//
// Locating objects
//


HRESULT
ADQueryMachineQueues(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  const GUID *            pguidMachine,
                IN  const MQCOLUMNSET*      pColumns,
                OUT PHANDLE                 phEnume
                );



HRESULT
ADQuerySiteServers(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN const GUID *             pguidSite,
                IN AD_SERVER_TYPE           serverType,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                );

HRESULT
ADQueryUserCert(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN const BLOB *             pblobUserSid,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                );

HRESULT
ADQueryConnectors(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN const GUID *             pguidSite,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                );

HRESULT
ADQueryForeignSites(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                );

HRESULT
ADQueryLinks(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN const GUID *             pguidSite,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                );

HRESULT
ADQueryAllLinks(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                );


HRESULT
ADQueryAllSites(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN const MQCOLUMNSET*       pColumns,
                OUT PHANDLE                 phEnume
                );

HRESULT
ADQueryQueues(
                IN  LPCWSTR                 pwcsDomainController,
                IN  bool					fServerName,
                IN  const MQRESTRICTION*    pRestriction,
                IN  const MQCOLUMNSET*      pColumns,
                IN  const MQSORTSET*        pSort,
                OUT PHANDLE                 phEnume
                );

HRESULT
ADQueryResults(
                IN      HANDLE          hEnum,
                IN OUT  DWORD*          pcProps,
                OUT     PROPVARIANT     aPropVar[]
                );

HRESULT
ADEndQuery(
                IN  HANDLE                  hEnum
                );

eDsEnvironment
ADGetEnterprise( void);

eDsProvider
ADProviderType( void);

DWORD
ADRawDetection(void);

HRESULT
ADGetADsPathInfo(
                IN  LPCWSTR                 pwcsADsPath,
                OUT PROPVARIANT *           pVar,
                OUT eAdsClass *             pAdsClass
                );


//-------------------------------------------------------
//
// auto release for ADQuery handles
//
class CADQueryHandle
{
public:
    CADQueryHandle()
    {
        m_h = NULL;
    }

    CADQueryHandle(HANDLE h)
    {
        m_h = h;
    }

    ~CADQueryHandle()
    {
        if (m_h)
        {
            ADEndQuery(m_h);
        }
    }

    HANDLE detach()
    {
        HANDLE hTmp = m_h;
        m_h = NULL;
        return hTmp;
    }

    operator HANDLE() const
    {
        return m_h;
    }

    HANDLE* operator &()
    {
        return &m_h;
    }

    CADQueryHandle& operator=(HANDLE h)
    {
        if (m_h)
        {
            ADEndQuery(m_h);
        }
        m_h = h;
        return *this;
    }

private:
    HANDLE m_h;
};




#endif // __AD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\cancel.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:
    cancel.h

Abstract:
    Keep track of outgoing RPC calls and cancel delayed pending requests

Author:
    Ronit Hartmann (ronith)

--*/

#ifndef __CANCEL_H
#define __CANCEL_H

#include "autorel.h"
#include "cs.h"

class MQUTIL_EXPORT CCancelRpc
{
public:
    CCancelRpc();
    ~CCancelRpc();
	void Add(	IN	HANDLE	hThread,
				IN	time_t	timeCallIssued);
	void Remove(  IN HANDLE hThread);


	void CancelRequests( IN	time_t timeIssuedBefore);

    //
    // We cannot initialize everything in constructor because we use
    // global object and it'll fail to construct when setup loads this dll
    // (during setup we don't have yet the timeout in registry for example)
    //
    void Init(void);

	void ShutDownCancelThread();

private:
    static DWORD WINAPI CancelThread(LPVOID);
    inline void ProcessEvents(void);

    CCriticalSection			m_cs;
	CMap< HANDLE, HANDLE, time_t, time_t> m_mapOutgoingRpcRequestThreads;

    CAutoCloseHandle m_hRpcPendingEvent;
    CAutoCloseHandle m_hTerminateThreadEvent;
    CAutoCloseHandle m_hCancelThread;

	bool m_fThreadIntializationComplete;
	
	LONG m_RefCount;
    DWORD m_dwRpcCancelTimeout;

	HMODULE m_hModule;
}; 
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\autorel2.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    autorel2.h

Abstract:

    Auto release classes 

Author:

    Shai Kariv (shaik) Jan 12, 1999

Revision History:

--*/

#ifndef _MSMQ_AUTOREL2_H_
#define _MSMQ_AUTOREL2_H_

#include <propidl.h>

class CServiceHandle
{
public:
    explicit CServiceHandle(SC_HANDLE h = NULL) { m_h = h; };
    ~CServiceHandle() { if (m_h) CloseServiceHandle(m_h); };

    operator SC_HANDLE() const { return m_h; };
    //CServiceHandle& operator=(SC_HANDLE h)   { m_h = h; return *this; }

private:
    //
    // Prevent copy
    //
    CServiceHandle(const CServiceHandle & );
    CServiceHandle& operator=(const CServiceHandle &);

private:
    SC_HANDLE m_h;

}; //CServiceHandle


class CFindHandle
{
public:
    explicit CFindHandle(HANDLE h = NULL) { m_h = h; };
    ~CFindHandle() { if (m_h) FindClose(m_h); };

    operator HANDLE() const { return m_h; };
    //CFindHandle& operator=(HANDLE h)   { m_h = h; return *this; }

private:
    //
    // Prevent copy
    //
    CFindHandle(const CFindHandle & );
    CFindHandle& operator=(const CFindHandle &);

private:
    HANDLE m_h;

}; //CFindHandle


class CBlob
{
public:
    explicit CBlob() { BLOB b; b.pBlobData = NULL; b.cbSize = 0; m_blob = b; };
    CBlob(const BLOB & b) {m_blob = b; };
    ~CBlob() { delete m_blob.pBlobData; };

    CBlob& operator =(BLOB b) { m_blob = b; return(*this); };
    operator BLOB() const { return m_blob; };

private:
    //
    // Prevent copy
    //
    CBlob(const CBlob & );
    CBlob& operator=(const CBlob &);

private:
    BLOB m_blob;

}; //CBlob


class CCaclsid
{
public:
    explicit CCaclsid() { CACLSID c; c.pElems = NULL; c.cElems = 0; m_caclsid = c; };
    CCaclsid(const CACLSID & c) { m_caclsid = c; };
    ~CCaclsid() { delete m_caclsid.pElems; };

    CCaclsid& operator =(CACLSID c) { m_caclsid = c; return(*this); };
    operator CACLSID() const { return m_caclsid; };

private:
    //
    // Prevent copy
    //
    CCaclsid(const CCaclsid & );
    CCaclsid& operator=(const CCaclsid &);

private:
    CACLSID m_caclsid;

}; //CCaclsid


class CSecDescPointer
{
public:
    explicit CSecDescPointer(PSECURITY_DESCRIPTOR p = NULL) { m_p = p; };
    ~CSecDescPointer() { if (m_p) delete [] reinterpret_cast<char*>(m_p); };

    CSecDescPointer& operator =(PSECURITY_DESCRIPTOR p) { m_p = p; return(*this); };
    operator char*() { return reinterpret_cast<char*>(m_p); };

private:
    //
    // Prevent copy
    //
    CSecDescPointer(const CSecDescPointer & );
    CSecDescPointer& operator=(const CSecDescPointer &);

private:
    PSECURITY_DESCRIPTOR m_p;

}; //CSecDescPointer


class CEventSource
{
public:
    explicit CEventSource(HANDLE h = NULL) { m_h = h; };
    ~CEventSource() { if (m_h) DeregisterEventSource(m_h); };

    operator HANDLE() const { return m_h; };
    CEventSource& operator=(HANDLE h)   { m_h = h; return *this; }

private:
    //
    // Prevent copy
    //
    CEventSource(const CEventSource & );
    CEventSource& operator=(const CEventSource &);

private:
    HANDLE m_h;

}; //CEventSource


#endif //_MSMQ_AUTOREL2_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\bupdate.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
	bupdate.h

Abstract:
	DS update class

	This class includes all the information of the update performed on the DS

Author:

    Ronit Hartmann (ronith)

--*/

#ifndef __BUPDATE_H__
#define __BUPDATE_H__

#include "factory.h"
#include "seqnum.h"
//
// type of operation
//
#define DS_UPDATE_CREATE        ((unsigned char) 0x00)
#define DS_UPDATE_SET           ((unsigned char) 0x01)
#define DS_UPDATE_DELETE        ((unsigned char) 0x02)
#define DS_UPDATE_SYNC          ((unsigned char) 0x03)

#define UPDATE_OK				0x00000000	// everything is fine
#define UPDATE_DUPLICATE		0x00000001	// receiving an old update
#define UPDATE_OUT_OF_SYNC		0x00000002	// we need a sync, probably we missed information
#define UPDATE_UNKNOWN_SOURCE	0x00000003	// we need a sync, probably we missed information

//
//  dwNeedCopy values
//
#define UPDATE_COPY             0x00000000
#define UPDATE_DELETE_NO_COPY   0x00000001
#define UPDATE_NO_COPY_NO_DELETE    0x00000002

#ifndef MQUTIL_EXPORT
#ifdef _MQUTIL
#define MQUTIL_EXPORT  DLL_EXPORT
#else
#define MQUTIL_EXPORT  DLL_IMPORT
#endif
#endif

class MQUTIL_EXPORT CDSBaseUpdate
{
public:
    CDSBaseUpdate();
	~CDSBaseUpdate();

	HRESULT Init(
			IN	const GUID	*	pguidMasterId,
			IN	const CSeqNum &	sn,
            IN  const CSeqNum & snThisMasterIntersitePrevSeqNum,
            IN  const CSeqNum & snPurge,
			IN  BOOL            fOriginatedByThisMaster,
            IN	unsigned char	bCommand,
			IN	DWORD			dwNeedCopy,
			IN	LPWSTR			pwcsPathName,
			IN	DWORD			cp,
			IN	PROPID*         aProp,
			IN	PROPVARIANT*    aVar);


	HRESULT Init(
			IN	const GUID *	pguidMasterId,
			IN	const CSeqNum &	sn,
            IN  const CSeqNum & snThisMasterIntersitePrevSeqNum,
            IN  const CSeqNum & snPurge,
			IN  BOOL            fOriginatedByThisMaster,
			IN	unsigned char	bCommand,
			IN	DWORD			dwNeedCopy,
			IN	CONST GUID *	pguidIdentifier,
			IN	DWORD			cp,
			IN	PROPID*         aProp,
			IN	PROPVARIANT*    aVar);

	HRESULT Init(
			IN	const unsigned char *	pBuffer,
			OUT	DWORD *					pUpdateSize,
            IN  BOOL                    fReplicationService = FALSE);
	
	HRESULT	GetSerializeSize(
			OUT DWORD *			pdwSize);

    HRESULT	Serialize(
			OUT	unsigned char *	pBuffer,
			OUT DWORD * pdwSize,
			IN  BOOL    fInterSite);


	const CSeqNum & GetSeqNum() const;
	
	const CSeqNum & GetPrevSeqNum() const;
	
	const CSeqNum & GetPurgeSeqNum() const;
	
	void	SetPrevSeqNum(IN CSeqNum & snPrevSeqNum);
	
	const GUID *	GetMasterId();
	unsigned char   GetCommand();
	DWORD           GetObjectType();
	LPWSTR          GetPathName();
	unsigned char   getNumOfProps();
	PROPID *        GetProps();
	PROPVARIANT *   GetVars();
	GUID *          GetGuidIdentifier();

#ifdef _DEBUG
    inline BOOL  WasInc() { return m_cpInc ; }
#endif

private:

	HRESULT	SerializeProperty(
			IN	PROPVARIANT&	Var,
			OUT	unsigned char *	pBuffer,
			OUT DWORD *			pdwSize);

	HRESULT	InitProperty(
			IN	const unsigned char *	pBuffer,
			OUT DWORD *					pdwSize,
			IN	PROPID					PropId,
			OUT	PROPVARIANT&			rVar);

	HRESULT	CopyProperty(
			IN	PROPVARIANT&	SrcVar,
			IN	PROPVARIANT*	pDstVar);

	void	DeleteProperty(
			IN	PROPVARIANT&	Var);


	unsigned char	m_bCommand;
	GUID			m_guidMasterId;
	CSeqNum			m_snPrev;
    BOOL            m_fOriginatedByThisMaster;     // TRUE - update was originate by this server

	CSeqNum			m_sn;
	CSeqNum			m_snPurge;
	LPWSTR			m_pwcsPathName;
	unsigned char	m_cp;
	PROPID*         m_aProp;
    PROPVARIANT*    m_aVar;

	GUID *			m_pGuid;
	BOOL			m_fUseGuid; // If true object will preform DB operations by guid and
								// not by path name
    BOOL            m_fNeedRelease; // TRUE if the destructor has to delete class variables

#ifdef _DEBUG
    BOOL            m_cpInc ;
#endif
};


inline CDSBaseUpdate::CDSBaseUpdate():
#ifdef _DEBUG
                                m_cpInc(FALSE),
#endif
                                m_bCommand(0),
								m_fOriginatedByThisMaster(FALSE),
                                m_guidMasterId(GUID_NULL),
                                m_pwcsPathName(NULL),
                                m_cp(0),
                                m_aProp(0),
                                m_aVar(NULL),
                                m_pGuid(NULL)
{
    // default constructor init m_snPrev , m_snPurge & m_sn to smallest value
}

inline 	const GUID * CDSBaseUpdate::GetMasterId()
{
	return(&m_guidMasterId);
}

inline const CSeqNum & CDSBaseUpdate::GetSeqNum() const	
{
	return(m_sn);
}

inline const CSeqNum & CDSBaseUpdate::GetPrevSeqNum() const	
{
	return(m_snPrev);
}

inline void	CDSBaseUpdate::SetPrevSeqNum(IN CSeqNum & snPrevSeqNum)
{
	m_snPrev = snPrevSeqNum;
}

inline const CSeqNum & CDSBaseUpdate::GetPurgeSeqNum() const	
{
	return(m_snPurge);
}

inline unsigned char CDSBaseUpdate::GetCommand()
{
	return(m_bCommand);

}
inline  DWORD CDSBaseUpdate::GetObjectType()
{
    if ( m_bCommand != DS_UPDATE_DELETE)
    {
	    return( PROPID_TO_OBJTYPE( *m_aProp));
    }
    else
    {
        //
        //  For deleted object - the second variant holds the Object type
        //
        ASSERT(m_aProp[1] == PROPID_D_OBJTYPE);
        ASSERT(m_cp == 2);
        return(m_aVar[1].bVal);
    }
}
inline LPWSTR CDSBaseUpdate::GetPathName()
{
	return(m_pwcsPathName);
}
inline unsigned char CDSBaseUpdate::getNumOfProps()
{
	return(m_cp);
}
inline PROPID * CDSBaseUpdate::GetProps()
{
	return(m_aProp);
}
inline PROPVARIANT * CDSBaseUpdate::GetVars()
{
	return(m_aVar);
}

inline GUID * CDSBaseUpdate::GetGuidIdentifier()
{
	return( m_pGuid);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\crtwin.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    crtwin.h

Abstract:

    Convert many system calls to crt calls, easy porting to Win95. Include it
    After you include windows headers.

Author:

    Erez Haba (erez) 20-Oct-96

--*/
#ifndef __CRTWIN_H
#define __CRTWIN_H

#undef lstrlen
#define lstrlen _tcslen

#undef lstrcmp
#define lstrcmp _tcscmp

#undef lstrcmpi
#define lstrcmpi _tcsicmp

#undef lstrcat
#define lstrcat _tcscat

#undef lstrcpy
#define lstrcpy _tcscpy

#undef wsprintf
#define wsprintf swprintf

#endif // __CRTWIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\autorel3.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    autorel3.h

Abstract:

    Cluster related auto release classes

Author:

    Shai Kariv (shaik) Jan 12, 1999

Revision History:

--*/

#ifndef _MSMQ_AUTOREL3_H_
#define _MSMQ_AUTOREL3_H_


//
// Cluster related classes
//

class CAutoCluster
{
public:
	explicit CAutoCluster(HCLUSTER h = NULL) { m_h = h; };
	~CAutoCluster() { if (m_h) CloseCluster(m_h); };

	operator HCLUSTER() const { return m_h; };
    CAutoCluster& operator=(HCLUSTER h)   { m_h = h; return *this; }
    
private:
    //
    // Prevent copy
    //
    CAutoCluster(const CAutoCluster & );
    CAutoCluster& operator=(const CAutoCluster &);

private:
	HCLUSTER m_h;

}; //CAutoCluster


class CClusterEnum
{
public:
    explicit CClusterEnum(HCLUSENUM h = NULL) { m_h = h; };
    ~CClusterEnum() { if (m_h) ClusterCloseEnum(m_h); };

    operator HCLUSENUM() const { return m_h; };
    CClusterEnum& operator=(HCLUSENUM h)   { m_h = h; return *this; }
    
private:
    //
    // Prevent copy
    //
    CClusterEnum(const CClusterEnum & );
    CClusterEnum& operator=(const CClusterEnum &);

private:
    HCLUSENUM m_h;

}; //CClusterEnum


class CGroupEnum
{
public:
    explicit CGroupEnum(HGROUPENUM h = NULL) { m_h = h; };
    ~CGroupEnum() { if (m_h) ClusterGroupCloseEnum(m_h); };

    operator HGROUPENUM() const { return m_h; };
    CGroupEnum& operator=(HGROUPENUM h)   { m_h = h; return *this; }
    
private:
    //
    // Prevent copy
    //
    CGroupEnum(const CGroupEnum & );
    CGroupEnum& operator=(const CGroupEnum &);

private:
    HGROUPENUM m_h;

}; //CGroupEnum


class CResourceEnum
{
public:
    explicit CResourceEnum(HRESENUM h = NULL) { m_h = h; };
    ~CResourceEnum() { if (m_h) ClusterResourceCloseEnum(m_h); };

    operator HRESENUM() const { return m_h; };
    CResourceEnum& operator=(HRESENUM h)   { m_h = h; return *this; }
    
private:
    //
    // Prevent copy
    //
    CResourceEnum(const CResourceEnum & );
    CResourceEnum& operator=(const CResourceEnum &);

private:
    HRESENUM m_h;

}; //CResourceEnum


class CClusterResource
{
public:
    explicit CClusterResource(HRESOURCE h = NULL) { m_h = h; };
    ~CClusterResource() { if (m_h) CloseClusterResource(m_h); };

    operator HRESOURCE() const { return m_h; };
    HRESOURCE * operator &() { return &m_h; };
    CClusterResource& operator=(HRESOURCE h)   { ASSERT(!m_h || !h); m_h = h; return *this; }
    HRESOURCE detach() { HRESOURCE h = m_h; m_h = 0; return h; };

private:
    //
    // Prevent copy
    //
    CClusterResource(const CClusterResource & );
    CClusterResource& operator=(const CClusterResource &);

private:
    HRESOURCE m_h;

}; //CClusterResource


class CClusterGroup
{
public:
    explicit CClusterGroup(HGROUP h = NULL) { m_h = h; };
    ~CClusterGroup() { if (m_h) CloseClusterGroup(m_h); };

    operator HGROUP() const { return m_h; };
    HGROUP * operator &() { return &m_h; };
    CClusterGroup& operator=(HGROUP h)   { ASSERT(!m_h || !h); m_h = h; return *this; }
    HGROUP detach() { HGROUP h = m_h; m_h = 0; return h; };

private:
    //
    // Prevent copy
    //
    CClusterGroup(const CClusterGroup & );
    CClusterGroup& operator=(const CClusterGroup &);

private:
    HGROUP m_h;

}; //CClusterGroup


class CClusterNode
{
public:
    explicit CClusterNode(HNODE h = NULL) { m_h = h; };
    ~CClusterNode() { if (m_h) CloseClusterNode(m_h); };

    operator HNODE() const { return m_h; };
    HNODE * operator &() { return &m_h; };
    CClusterNode& operator=(HNODE h)   { ASSERT(!m_h || !h); m_h = h; return *this; }
    HNODE detach() { HNODE h = m_h; m_h = 0; return h; };

private:
    //
    // Prevent copy
    //
    CClusterNode(const CClusterNode & );
    CClusterNode& operator=(const CClusterNode &);

private:
    HNODE m_h;

}; //CClusterNode


class CEnvironment
{
public:
    explicit CEnvironment(LPVOID p = NULL) { m_p = p; };
    ~CEnvironment() { if (m_p) ResUtilFreeEnvironment(m_p); };

    operator PWCHAR() { return static_cast<PWCHAR>(m_p); };
    operator PBYTE()  { return static_cast<PBYTE>(m_p); };
    //CEnvironment& operator=(LPVOID p)   { m_p = p; return *this; }

private:
    //
    // Prevent copy
    //
    CEnvironment(const CEnvironment & );
    CEnvironment& operator=(const CEnvironment &);

private:
    LPVOID m_p;

}; //CEnvironment


#endif //_MSMQ_AUTOREL3_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\ds.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ds.h

Abstract:

    Message Queuing's Directory Service Header File

--*/

#ifndef __DS_H__
#define __DS_H__

#ifdef _DS_
#define DS_EXPORT  DLL_EXPORT
#else
#define DS_EXPORT  DLL_IMPORT
#endif

//
// DS_EXPORT_IN_DEF_FILE
// Exports that are defined in a def file should not be using __declspec(dllexport)
//  otherwise the linker issues a warning
//
#ifdef _DS_
#define DS_EXPORT_IN_DEF_FILE
#else
#define DS_EXPORT_IN_DEF_FILE  DLL_IMPORT
#endif

#include <dsproto.h>
#include "mqdsdef.h"

#ifdef __cplusplus
extern "C"
{
#endif


//********************************************************************
//                           A P I
//********************************************************************


HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSCreateObject(
                IN  DWORD                   dwObjectType,
                IN  LPCWSTR                 lpwcsPathName,
                IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor,
                IN  DWORD                   cp,
                IN  PROPID                  aProp[],
                IN  PROPVARIANT             apVar[],
                OUT GUID*                   pObjGuid);

HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSSetObjectSecurity(
                IN  DWORD                   dwObjectType,
                IN  LPCWSTR                 lpwcsPathName,
                IN  SECURITY_INFORMATION    SecurityInformation,
                IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor);

HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSGetObjectSecurity(
                IN  DWORD                   dwObjectType,
                IN  LPCWSTR                 lpwcsPathName,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor,
                IN  DWORD                   nLength,
                IN  LPDWORD                 lpnLengthNeeded);

HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSDeleteObject(
                IN  DWORD                   dwObjectType,
                IN  LPCWSTR                 lpwcsPathName);

HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSGetObjectProperties(
                IN  DWORD                   dwObjectType,
                IN  LPCWSTR                 lpwcsPathName,
                IN  DWORD                   cp,
                IN  PROPID                  aProp[],
                IN  PROPVARIANT             apVar[]);

HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSSetObjectProperties(
                IN  DWORD                   dwObjectType,
                IN  LPCWSTR                 lpwcsPathName,
                IN  DWORD                   cp,
                IN  PROPID                  aProp[],
                IN  PROPVARIANT             apVar[]);

HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSLookupBegin(
                IN  LPWSTR                  lpwcsContext,
                IN  MQRESTRICTION*          pRestriction,
                IN  MQCOLUMNSET*            pColumns,
                IN  MQSORTSET*              pSort,
                OUT PHANDLE                 phEnume);

HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSLookupNext(
                IN      HANDLE          hEnum,
                IN OUT  DWORD*          pcProps,
                OUT     PROPVARIANT     aPropVar[]);

HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSLookupEnd(
                IN  HANDLE                  hEnum);


HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSSetObjectSecurityGuid(
                IN  DWORD                   dwObjectType,
                IN  CONST GUID*             pObjectGuid,
                IN  SECURITY_INFORMATION    SecurityInformation,
                IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor);

HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSGetObjectSecurityGuid(
                IN  DWORD                   dwObjectType,
                IN  CONST GUID*             pObjectGuid,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor,
                IN  DWORD                   nLength,
                IN  LPDWORD                 lpnLengthNeeded);

HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSDeleteObjectGuid(
                IN  DWORD                   dwObjectType,
                IN  CONST GUID*             pObjectGuid);

HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSGetObjectPropertiesGuid(
                IN  DWORD                   dwObjectType,
                IN  CONST GUID*             pObjectGuid,
                IN  DWORD                   cp,
                IN  PROPID                  aProp[],
                IN  PROPVARIANT             apVar[]);

HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSSetObjectPropertiesGuid(
                IN  DWORD                   dwObjectType,
                IN  CONST GUID*             pObjectGuid,
                IN  DWORD                   cp,
                IN  PROPID                  aProp[],
                IN  PROPVARIANT             apVar[]);

HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSInit( QMLookForOnlineDS_ROUTINE pLookDS = NULL,
        MQGetMQISServer_ROUTINE pGetServers = NULL,
        BOOL  fReserved = FALSE,
        BOOL  fSetupMode     = FALSE,
        BOOL  fQMDll         = FALSE,
        NoServerAuth_ROUTINE pNoServerAuth = NULL,
        LPCWSTR szServerName = NULL) ;


void
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSTerminate(
    VOID
    );

//
// Flags for DSGetUserParams
//
#define GET_USER_PARAM_FLAG_SID              1
#define GET_USER_PARAM_FLAG_ACCOUNT          2

HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSGetUserParams(
            IN     DWORD      dwFalgs,
            IN     DWORD      dwSidLength,
            OUT    PSID       pUserSid,
            OUT    DWORD      *pdwSidReqLength,
            OUT    LPWSTR     szAccountName,
            IN OUT DWORD      *pdwAccountNameLen,
            OUT    LPWSTR     szDomainName,
            IN OUT DWORD      *pdwDomainNameLen);

HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSQMSetMachineProperties(
    IN  LPCWSTR          pwcsPathName,
    IN  DWORD            cp,
    IN  PROPID           aProp[],
    IN  PROPVARIANT      apVar[],
    IN  DSQMChallengeResponce_ROUTINE pfSignProc,
    IN  DWORD_PTR        dwContext
    );

HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSCreateServersCache(
    VOID
    );

HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSQMGetObjectSecurity(
    IN  DWORD                   dwObjectType,
    IN  CONST GUID*             pObjectGuid,
    IN  SECURITY_INFORMATION    RequestedInformation,
    IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor,
    IN  DWORD                   nLength,
    IN  LPDWORD                 lpnLengthNeeded,
    IN  DSQMChallengeResponce_ROUTINE pfChallengeResponceProc,
    IN  DWORD_PTR               dwContext
    );

HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSGetComputerSites(
            IN  LPCWSTR     pwcsComputerName,
            OUT DWORD  *    pdwNumSites,
            OUT GUID **     ppguidSites
            );

//
// In the two GetObj..Ex api below, "fSearchDSserver" tell the mqdslci code
// whether or not to search an online DS server. By default, it's TRUE.
// The code that query public key of target machines set it to FALSE.
// See mqsec\encrypt\pbkeys.cpp for details.
//

HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSGetObjectPropertiesEx(
                IN  DWORD                   dwObjectType,
                IN  LPCWSTR                 lpwcsPathName,
                IN  DWORD                   cp,
                IN  PROPID                  aProp[],
                IN  PROPVARIANT             apVar[] ) ;
/*                IN  BOOL                    fSearchDSserver = TRUE );*/

HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSGetObjectPropertiesGuidEx(
                IN  DWORD                   dwObjectType,
                IN  CONST GUID*             pObjectGuid,
                IN  DWORD                   cp,
                IN  PROPID                  aProp[],
                IN  PROPVARIANT             apVar[] ) ;
/*                IN  BOOL                    fSearchDSserver = TRUE );*/

HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSBeginDeleteNotification(
                 IN LPCWSTR						pwcsQueueName,
                 IN OUT HANDLE   *              phEnum
	             );
HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSNotifyDelete(
        IN  HANDLE                  hEnum
	    );

HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSEndDeleteNotification(
        IN  HANDLE                  hEnum
        );

HRESULT
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSRelaxSecurity(DWORD dwRelaxFlag) ;

void
DS_EXPORT_IN_DEF_FILE
APIENTRY
DSFreeMemory(
        IN PVOID pMemory
        );

#ifdef __cplusplus
}
#endif

#endif // __DS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\autoreln.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    autoreln.h

Abstract:

    auto release classes for netapi. And for LocalFree buffer, used
    extensively in security apis.

Author:

    Doron Juster (DoronJ)  25-May-1999

Revision History:

--*/

#ifndef _MSMQ_AUTORELN_H_
#define _MSMQ_AUTORELN_H_

//
//  return type for 'identifier::operator >' is not a UDT or reference to a UDT.
//  Will produce errors if applied using infix notation
//
#pragma warning(disable: 4284)

//----------------------------------------
//
//  Auto delete pointer for net api
//
//----------------------------------------
template<class T>
class PNETBUF {
private:
    T* m_p;

public:
    PNETBUF(T* p = 0) : m_p(p)    {}
   ~PNETBUF()                     { if (m_p != 0) NetApiBufferFree(m_p); }

    operator T*() const     { return m_p; }
    T* operator->() const   { return m_p; }
    T* get() const          { return m_p; }
    T* detach()             { T* p = m_p; m_p = 0; return p; }
    void free()             { if (m_p != 0) NetApiBufferFree(detach()); }

    T** operator&()
    {
        ASSERT(("Auto NETBUF pointer in use, can't take it's address", m_p == 0));
        return &m_p;
    }


    PNETBUF& operator=(T* p)
    {
        ASSERT(("Auto NETBUF pointer in use, can't assign it", m_p == 0));
        m_p = p;
        return *this;
    }

private:
    PNETBUF(const PNETBUF&);
	PNETBUF<T>& operator=(const PNETBUF<T>&);
};

//+----------------------------------
//
// class CAutoLocalFreePtr
//
//+----------------------------------

class CAutoLocalFreePtr
{
private:
    BYTE *m_p;

public:
    CAutoLocalFreePtr(BYTE *p = 0) : m_p(p) {};
    ~CAutoLocalFreePtr() { if (m_p != 0) LocalFree(m_p); };

    operator BYTE*() const     { return m_p; }
    BYTE* operator->() const   { return m_p; }
    BYTE* get() const          { return m_p; }
    BYTE* detach()             { BYTE* p = m_p; m_p = 0; return p; }
    void free()				   { if (m_p != 0) LocalFree(detach()); }

    BYTE** operator&()
    {
        ASSERT(("Auto LocalFree pointer in use, can't take it's address", m_p == 0));
        return &m_p;
    }


	CAutoLocalFreePtr& operator =(BYTE *p)
    {
        ASSERT(("Auto LocalFree pointer in use, can't assign it", m_p == 0));
        m_p = p;
        return *this;
    }

private:
    CAutoLocalFreePtr(const CAutoLocalFreePtr&);
	CAutoLocalFreePtr& operator=(const CAutoLocalFreePtr&);

};

#endif //_MSMQ_AUTORELN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\dcomreg5.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    dcomreg5.h

Abstract:

    Registry for reading dcom95 version.

Author:

    Doron Juster  (DoronJ)  19-Aug-97

--*/

#define DCOM95_VERSION_REGISTRY  \
                 TEXT("CLSID\\{bdc67890-4fc0-11d0-a805-00aa006d2ea4}")
#define DCOM95_VERSION_REGISTRY_ENTRY   "InstalledVersion"

#define DCOM95_1ST_VER_NUMBER  4
#define DCOM95_2ND_VER_NUMBER  71
#define DCOM95_4TH_VER_NUMBER  426

#define DCOM95_4TH_VER_NUMBER_NOLARGE  426
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\formatnm.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:
    FormatNm.h

Abstract:
    CFormatName class - easier handling of format name.

Author:
    Yoel Arnon (YoelA) 14-Mar-96

Revision History:
--*/
#define FORMAT_NAME_INIT_BUFFER 128

class CFormatName : public CString
{
public:
    CFormatName() {};


    void FromPathName(LPCTSTR strPathName)
    {
      ULONG ulBufferSize = FORMAT_NAME_INIT_BUFFER;
      ULONG ulOldBuffer = 0;

      while (ulOldBuffer < ulBufferSize)
      {
         ulOldBuffer = ulBufferSize;
         MQPathNameToFormatName(
            strPathName,
            GetBuffer(ulBufferSize),
            &ulBufferSize);
         ReleaseBuffer();
      }
   }

    CFormatName &operator= (CLSID &uuid)
    {
      ULONG ulBufferSize = FORMAT_NAME_INIT_BUFFER;
      ULONG ulOldBuffer = 0;

      while (ulOldBuffer < ulBufferSize)
      {
         ulOldBuffer = ulBufferSize;
         MQInstanceToFormatName(&uuid,
                                GetBuffer(ulBufferSize),
                                &ulBufferSize);
         ReleaseBuffer();
      }
        return *this;
    }

   CFormatName(CLSID *puuid)
   {
        *this = *puuid;
   }

   CFormatName(LPCTSTR strPathName) : CString(strPathName)
   {
   }
};

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\mixmode.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    mixmode.h

Abstract:

    Definition for mixed mode environment (NT5/MSMQ2 + NT4/MSMQ1 servers
    in same enterprise.

Author:

    Doron Juster  (DoronJ)   07-Apr-97  Created

--*/

//
// names of default containers, which are created by the migration tool.
//
#define  MIG_DEFAULT_COMPUTERS_CONTAINER  (TEXT("msmqComputers"))
#define  MIG_DEFAULT_USERS_CONTAINER      (TEXT("msmqUsers"))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\factory.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
	factory.h

Abstract:
	Factory Template for Shared Objects

Author:
	RaphiR

--*/
/*
 * CFactory is a template class used for create and delete objects
 * of shared class. In the shared class, an object will be created
 * only once for a specific key. If it exists already, its reference
 * count will be incremented.
 *
 * A shared class has to be derived from CSharedObject class.
 */
#ifndef __FACTORY_H__
#define __FACTORY_H__


//---------------------------------------
//    CInterlocakedSharedObject definition
// Base class for shared objects classes 
// used in different threads
//---------------------------------------
class CInterlockedSharedObject
{
	public:
		
		CInterlockedSharedObject()		{ref = 0; }
		void AddRef()		{InterlockedIncrement(&ref);}
		long Release()		{InterlockedDecrement(&ref); ASSERT(ref>=0); return ref;}
        long GetRef()       {return ref;}
		virtual ~CInterlockedSharedObject()	{ ASSERT(ref == 0); }

	private:
		// Should be aligned on 32 bit boundary
		long ref;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\mgmtrpc.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name: mgmtrpc.h

Abstract: rpc related code.


Author:

    Doron Juster  (DoronJ)   25-Feb-98

--*/

#define  QMMGMT_PROTOCOL   (TEXT("ncalrpc"))
#define  QMMGMT_ENDPOINT   (TEXT("QMMgmtFacility"))
#define  QMMGMT_OPTIONS    (TEXT("Security=Impersonation Dynamic True"))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\dsproto.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

   dsproto.h

Abstract:

    Definition of DS functions prototypes.

Author:

    Doron Juster (DoronJ)


--*/

#ifndef __DSPROTO_H__
#define __DSPROTO_H__


typedef HRESULT
(APIENTRY *DSCreateObject_ROUTINE)(
                IN  DWORD                   dwObjectType,
                IN  LPCWSTR                 pwcsPathName,
                IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor,
                IN  DWORD                   cp,
                IN  PROPID                  aProp[],
                IN  PROPVARIANT             apVar[],
                OUT GUID*                   pObjGuid);

#define MQDS_SIGN_PUBLIC_KEY ((SECURITY_INFORMATION)0x80000000)
#define MQDS_KEYX_PUBLIC_KEY ((SECURITY_INFORMATION)0x40000000)

typedef struct MQDS_PublicKey_tag
{
    DWORD dwPublikKeyBlobSize;
    BYTE abPublicKeyBlob[1];
} MQDS_PublicKey, *PMQDS_PublicKey;

typedef HRESULT
(APIENTRY *DSSetObjectSecurity_ROUTINE)(
                IN  DWORD                   dwObjectType,
                IN  LPCWSTR                 pwcsPathName,
                IN  SECURITY_INFORMATION    SecurityInformation,
                IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor);

typedef HRESULT
(APIENTRY *DSGetObjectSecurity_ROUTINE)(
                IN  DWORD                   dwObjectType,
                IN  LPCWSTR                 pwcsPathName,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor,
                IN  DWORD                   nLength,
                IN  LPDWORD                 lpnLengthNeeded);

typedef HRESULT
(APIENTRY *DSDeleteObject_ROUTINE)(
                IN  DWORD                   dwObjectType,
                IN  LPCWSTR                 pwcsPathName);

typedef HRESULT
(APIENTRY *DSGetObjectProperties_ROUTINE)(
                IN  DWORD                   dwObjectType,
                IN  LPCWSTR                 pwcsPathName,
                IN  DWORD                   cp,
                IN  PROPID                  aProp[],
                IN  PROPVARIANT             apVar[]);

typedef HRESULT
(APIENTRY *DSGetObjectPropertiesEx_ROUTINE)(
                IN  DWORD                   dwObjectType,
                IN  LPCWSTR                 pwcsPathName,
                IN  DWORD                   cp,
                IN  PROPID                  aProp[],
                IN  PROPVARIANT             apVar[]);

typedef HRESULT
(APIENTRY *DSSetObjectProperties_ROUTINE)(
                IN  DWORD                   dwObjectType,
                IN  LPCWSTR                 pwcsPathName,
                IN  DWORD                   cp,
                IN  PROPID                  aProp[],
                IN  PROPVARIANT             apVar[]);

typedef HRESULT
(APIENTRY *DSLookupBegin_ROUTINE)(
                IN  LPWSTR                  pwcsContext,
                IN  MQRESTRICTION*          pRestriction,
                IN  MQCOLUMNSET*            pColumns,
                IN  MQSORTSET*              pSort,
                OUT HANDLE*                 pHandle);

typedef HRESULT
(APIENTRY *DSLookupNext_ROUTINE)(
                IN  HANDLE                  hEnum,
                OUT DWORD*                  pcPropsRead,
                OUT PROPVARIANT             aPropVar[]);

typedef HRESULT
(APIENTRY *DSLookupEnd_ROUTINE)(
                IN  HANDLE                  hEnum);

typedef void
(APIENTRY *QMLookForOnlineDS_ROUTINE) (
                void* pvoid,
                DWORD dwtemp) ;

typedef HRESULT
(APIENTRY *MQGetMQISServer_ROUTINE)(
                IN BOOL *pfRemote ) ;

typedef BOOL
(APIENTRY *NoServerAuth_ROUTINE)(
                void);

typedef HRESULT
(APIENTRY *DSInit_ROUTINE)( QMLookForOnlineDS_ROUTINE pLookDS   = NULL,
                            MQGetMQISServer_ROUTINE pGetServers = NULL,
                            BOOL  fReserved = FALSE,
                            BOOL  fSetupMode     = FALSE,
                            BOOL  fQMDll         = FALSE,
                            NoServerAuth_ROUTINE pNoServerAuth = NULL,
                            LPCWSTR szServerName = NULL ) ;

typedef HRESULT
(APIENTRY *DSGetObjectPropertiesGuid_ROUTINE)(
                IN  DWORD                   dwObjectType,
                IN  CONST GUID*             pObjectGuid,
                IN  DWORD                   cp,
                IN  PROPID                  aProp[],
                IN  PROPVARIANT             apVar[]);

typedef HRESULT
(APIENTRY *DSGetObjectPropertiesGuidEx_ROUTINE)(
                IN  DWORD                   dwObjectType,
                IN  CONST GUID*             pObjectGuid,
                IN  DWORD                   cp,
                IN  PROPID                  aProp[],
                IN  PROPVARIANT             apVar[]);

typedef HRESULT
(APIENTRY * DSSetObjectPropertiesGuid_ROUTINE)(
                IN  DWORD                   dwObjectType,
                IN  CONST GUID*             pObjectGuid,
                IN  DWORD                   cp,
                IN  PROPID                  aProp[],
                IN  PROPVARIANT             apVar[]);

typedef HRESULT
(APIENTRY * DSDeleteObjectGuid_ROUTINE)(
                IN  DWORD                   dwObjectType,
                IN  CONST GUID*             pObjectGuid);

typedef HRESULT
(APIENTRY * DSSetObjectSecurityGuid_ROUTINE)(
                IN  DWORD                   dwObjectType,
                IN  CONST GUID *            pObjectGuid,
                IN  SECURITY_INFORMATION    SecurityInformation,
                IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor);

typedef HRESULT
(APIENTRY * DSGetObjectSecurityGuid_ROUTINE)(
                IN  DWORD                   dwObjectType,
                IN  CONST GUID *            pObjectGuid,
                IN  SECURITY_INFORMATION    RequestedInformation,
                IN  PSECURITY_DESCRIPTOR    pSecurityDescriptor,
                IN  DWORD                   nLength,
                IN  LPDWORD                 lpnLengthNeeded);

typedef void
(APIENTRY * DSTerminate_ROUTINE) () ;

typedef HRESULT
(APIENTRY *DSQMChallengeResponce_ROUTINE)(
     IN     BYTE    *pbChallenge,
     IN     DWORD   dwChallengeSize,
     IN     DWORD_PTR dwContext,
     OUT    BYTE    *pbSignature,
     OUT    DWORD   *pdwSignatureSize,
     IN     DWORD   dwSignatureMaxSize);

struct DSQMSetMachinePropertiesStruct
{
    DWORD cp;
    PROPID *aProp;
    PROPVARIANT *apVar;
    DSQMChallengeResponce_ROUTINE pfSignProc;
};

typedef HRESULT
(APIENTRY * DSQMSetMachineProperties_ROUTINE)(
                IN    LPCWSTR         pwcsPathName,
                IN    DWORD           cp,
                IN    PROPID          aProp[],
                IN    PROPVARIANT     apVar[],
                IN    DSQMChallengeResponce_ROUTINE
                                      pfSignProc,
                IN    DWORD_PTR       dwContext);

typedef HRESULT
(APIENTRY * DSCreateServersCache_ROUTINE)() ;

typedef HRESULT
(APIENTRY * DSQMGetObjectSecurity_ROUTINE)(
                IN    DWORD                 dwObjectType,
                IN    CONST GUID*           pObjectGuid,
                IN    SECURITY_INFORMATION  RequestedInformation,
                IN    PSECURITY_DESCRIPTOR  pSecurityDescriptor,
                IN    DWORD                 nLength,
                IN    LPDWORD               lpnLengthNeeded,
                IN    DSQMChallengeResponce_ROUTINE
                                            pfChallengeResponceProc,
                IN    DWORD_PTR             dwContext);

typedef HRESULT
(APIENTRY * DSGetUserParams_ROUTINE)(
            IN     DWORD      dwFalgs,
            IN     DWORD      dwSidLength,
            OUT    PSID       pUserSid,
            OUT    DWORD      *pdwSidReqLength,
            OUT    LPWSTR     szAccountName,
            IN OUT DWORD      *pdwAccountNameLen,
            OUT    LPWSTR     szDomainName,
            IN OUT DWORD      *pdwDomainNameLen);

typedef HRESULT
(APIENTRY * DSGetComputerSites_ROUTINE) (
            IN  LPCWSTR     pwcsComputerName,
            OUT DWORD  *    pdwNumSites,
            OUT GUID **     ppguidSites
            );

typedef HRESULT
(APIENTRY * DSRelaxSecurity_ROUTINE) (DWORD dwRelaxFlag) ;

typedef HRESULT
(APIENTRY *DSBeginDeleteNotification_ROUTINE) (
                 IN LPCWSTR						pwcsQueueName,
                 IN OUT HANDLE   *              phEnum
	             );

typedef HRESULT
(APIENTRY *DSNotifyDelete_ROUTINE) (
				IN  HANDLE                  hEnum
				);

typedef HRESULT
(APIENTRY *DSEndDeleteNotification_ROUTINE) (
				IN  HANDLE                  hEnum
				);

typedef void
(APIENTRY *DSFreeMemory_ROUTINE) (
				IN  PVOID					pMemory
				);

#endif // __DSPROTO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\mqaddef.h ===
/*++

Copyright (c) 1995-99  Microsoft Corporation

Module Name:

	mqaddef.h

Abstract:

	Message Queuing's Active Service defines


--*/
#ifndef __MQADDEF_H__
#define __MQADDEF_H__


//********************************************************************
//				AD object types
//********************************************************************

enum AD_OBJECT {
    eQUEUE,
    eMACHINE,
    eSITE,
    eENTERPRISE,
    eUSER,
    eROUTINGLINK,
    eSERVER,
    eSETTING,
    eCOMPUTER,
    eMQUSER,
    eNumberOfObjectTypes
};

//********************************************************************
//				AD server types
//********************************************************************
enum AD_SERVER_TYPE{
    eRouter,
    eDS
};

//********************************************************************
//				Routing link neighnbor
//********************************************************************
enum eLinkNeighbor
{
    eLinkNeighbor1,
    eLinkNeighbor2
};

//********************************************************************
//				Environment 
//********************************************************************
enum eDsEnvironment
{
    eUnknown,
    eMqis,
    eAD
};

//********************************************************************
//				Providers 
//********************************************************************
enum eDsProvider
{
	eUnknownProvider,
	eWorkgroup,
    eMqdscli,
    eMqad
};

//********************************************************************
//				Object classes 
//********************************************************************
enum eAdsClass
{
	eGroup,
	eAliasQueue,
    eQueue
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\getmqds.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
    getds.h

Abstract:
    Find MQDS servers in my site through ADS

Author:
    Raanan Harari (RaananH)

--*/

#ifndef __GETMQDS_H__
#define __GETMQDS_H__

#include "autorel.h"
#include "adsiutil.h"
#include "cs.h"

//-------------------------------------------------------
//
// prototypes for ADS access routines
// these prototypes are verified against the real functions in dsads.cpp
// where we statically link to them.
//
#include <lmcons.h>     //for NET_API_FUNCTION
#include <dsgetdc.h>    //for DSGETDCAPI
typedef
DSGETDCAPI
DWORD
(WINAPI *DsGetSiteName_ROUTINE)(
    IN LPCWSTR ComputerName OPTIONAL,
    OUT LPWSTR *SiteName
);

typedef
DSGETDCAPI
DWORD
(WINAPI *DsGetDcName_ROUTINE)(
    IN LPCWSTR ComputerName OPTIONAL,
    IN LPCWSTR DomainName OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN LPCWSTR SiteName OPTIONAL,
    IN ULONG Flags,
    OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
);

typedef NET_API_STATUS
(NET_API_FUNCTION *NetApiBufferFree_ROUTINE)(
    IN LPVOID Buffer
    );

//
// entry for each server
//
struct MqDsServerInAds
{
    AP<WCHAR> pwszName;     //server's name
    BOOL      fIsADS;       //whether it is NT5 ADS or NT4 MQIS
};

class CGetMqDS
{
public:
    CGetMqDS();
    ~CGetMqDS();
    HRESULT FindMqDsServersInAds(OUT ULONG * pcServers,
                                 OUT MqDsServerInAds ** prgServers);
private:

    HRESULT _FindMqDsServersInAds(OUT ULONG * pcServers,
                                  OUT MqDsServerInAds ** prgServers);

	BOOLEAN GetServerDNS(IN LPCWSTR   pwszSettingsDN,
                         OUT LPWSTR * ppwszServerName);

    BOOL                        m_fInited;
    BOOL                        m_fAdsExists;
    CAutoFreeLibrary            m_hLibActiveds;
    CAutoFreeLibrary            m_hLibNetapi32;
    DsGetSiteName_ROUTINE       m_pfnDsGetSiteName;
    DsGetDcName_ROUTINE         m_pfnDsGetDcName;
    NetApiBufferFree_ROUTINE    m_pfnNetApiBufferFree;
    ADsOpenObject_ROUTINE       m_pfnADsOpenObject;

    BOOL                        m_fInitedAds;
    AP<WCHAR>                   m_pwszConfigurationSiteServers;
    AP<WCHAR>                   m_pwszSearchFilter;
    ADS_SEARCHPREF_INFO         m_sSearchPrefs[2];
    LPCWSTR                     m_sSearchAttrs[3];
    LPWSTR                      m_pwszSiteName;
    CCriticalSection            m_cs;

    //
    // buffer to save (and free) Optional DC name for binding (incase ADSI default is not good)
    //
    AP<WCHAR>                   m_pwszBufferForOptionalDcForBinding;
    //
    // string that follows LDAP:// and specifies which DC to bind to.
    // It is initialized to point to an empty string (in the constructor), but can be changed later
    // to point to the above buffer incase we need to use a specific DC in binding.
    //
    LPCWSTR                     m_pwszOptionalDcForBinding;

    void Init();
    HRESULT InitAds();
    HRESULT MakeComputerDcFirst( IN ULONG cServers,
                                 IN OUT MqDsServerInAds * rgServers);
    HRESULT MakeComputerDcFirstByUsingDsGetDcName(
                                 IN ULONG cServers,
                                 IN OUT MqDsServerInAds * rgServers,
                                 OUT BOOL *pfComputerDcIsFirst);
};

//
// Read the relaxation status from the mSMQServices object. Used by setup.
//
HRESULT  APIENTRY  GetNt4RelaxationStatus(ULONG *pulRelax) ;

#endif //__GETMQDS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\mqcacert.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    mqcacert.h

Description:

    Header file for the various CA certificates management routines.

Author:

    Boaz Feldbaum (BoazF) 19-May-1997.

--*/

#ifndef _MQCQCERT_H_

#define _MQCQCERT_H_

#include <autoptr.h>

class MQ_CA_CONFIG {
public:
    MQ_CA_CONFIG() {}

    AP<WCHAR> szCaRegName;
    AP<WCHAR> szCaSubjectName;
    P<BYTE> pbSha1Hash;
    DWORD dwSha1HashSize;
    BOOL fEnabled;
    BOOL fDeleted;

private:
    MQ_CA_CONFIG(const MQ_CA_CONFIG&);
    MQ_CA_CONFIG& operator=(const MQ_CA_CONFIG&);
};

#define MQ_CA_CERT_ENABLED_PROP_ID CERT_FIRST_USER_PROP_ID
#define MQ_CA_CERT_SUBJECT_PROP_ID (CERT_FIRST_USER_PROP_ID + 1)

#ifndef MQUTIL_EXPORT
#ifdef _MQUTIL
#define MQUTIL_EXPORT  DLL_EXPORT
#else
#define MQUTIL_EXPORT  DLL_IMPORT
#endif
#endif

#ifndef DLL_EXPORT
#define DLL_EXPORT  __declspec(dllexport)
#endif

#ifndef DLL_IMPORT
#define DLL_IMPORT  __declspec(dllimport)
#endif

MQUTIL_EXPORT
HRESULT
MQGetCaConfig(
    DWORD *pnCerts,
    MQ_CA_CONFIG **MqCaConfig
    );

MQUTIL_EXPORT
HRESULT
MQSetCaConfig(
    DWORD nCerts,
    MQ_CA_CONFIG *MqCaConfig
    );

MQUTIL_EXPORT
void
MQFreeCaConfig(
    IN  MQ_CA_CONFIG* pvCaConfig
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\mqcert.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:
    mqcert.h

Abstract:
    This dll replaces digsig.dll which is obsolete now and will not be
    available on NT5. The main functionality in mqcert.dll is to create
    a certificate or read the parameters from an existing  certificate.

    The dll exports four functions:
    - MQSigCreateCertificate
    - MQSigOpenUserCertStore
    - MQSigCloneCertFromReg
    - MQSigCloneCertFromSysStore

    and expose two classes:
    - CMQSigCertificate
    - CMQSigCertStore

    When calling the funtions, an object (CMQSigCertificate or
    CMQSigCertSotre) is always created and returned to caller. The caller
    then uses the objects for the actual work. Caller must use the Release()
    method to delete the objects and free resources held by them.

Author:
    Doron Juster (DoronJ)  04-Dec-1997

Revision History:

--*/

#ifndef _MQCERT_H_
#define _MQCERT_H_

#include "mqsymbls.h"
#include "mqcrypt.h"
#include "mqtempl.h"

//********************************************************************
//
//              E R R O R / S T A T U S   C O D E S
//
//********************************************************************

#include "_mqsecer.h"

//*****************************************
//
//  D E F I N T I O N s
//
//*****************************************

//
// default protocol for personnal certificates store
//
const char   x_szPersonalSysProtocol[] = {"My"} ;
const WCHAR  x_wszPersonalSysProtocol[] = {L"My"} ;

//
// Define the default validity check done on a certificate.
//
const DWORD  x_dwCertValidityFlags  (CERT_STORE_REVOCATION_FLAG |
                                     CERT_STORE_SIGNATURE_FLAG  |
                                     CERT_STORE_TIME_VALIDITY_FLAG) ;

//********************************
//
//  Exported APIs
//
//********************************

class  CMQSigCertStore ;
class  CMQSigCertificate ;

#ifdef __cplusplus
extern "C"
{
#endif

HRESULT APIENTRY
MQSigCreateCertificate( OUT CMQSigCertificate **ppCert,
                        IN  PCCERT_CONTEXT      pCertContext = NULL,
                        IN  PBYTE               pCertBlob = NULL,
                        IN  DWORD               dwCertSize = 0 ) ;

struct MQSigOpenCertParams
{
    HKEY  hCurrentUser ;
    bool  bWriteAccess ;
    bool  bCreate ;
    bool  bMachineStore ;
};

HRESULT APIENTRY
MQSigOpenUserCertStore( OUT CMQSigCertStore **ppStore,
                        IN  LPSTR      lpszRegRoot,
                        IN  struct MQSigOpenCertParams *pParams ) ;

HRESULT APIENTRY
MQSigCloneCertFromReg( OUT CMQSigCertificate **ppCert,
                 const IN  LPSTR               lpszRegRoot,
                 const IN  LONG                iCertIndex ) ;

HRESULT APIENTRY
MQSigCloneCertFromSysStore( OUT CMQSigCertificate **ppCert,
                      const IN  LPSTR               lpszProtocol,
                      const IN  LONG                iCertIndex ) ;

//+-------------------------------------
//
//  typedef for use in GetProcAddress
//
//+-------------------------------------

typedef HRESULT
(APIENTRY *MQSigCreateCertificate_ROUTINE) (
                        OUT CMQSigCertificate **ppCert,
                        IN  PCCERT_CONTEXT      pCertContext = NULL,
                        IN  PBYTE               pCertBlob = NULL,
                        IN  DWORD               dwCertSize = 0 ) ;

typedef HRESULT
(APIENTRY *MQSigOpenUserCertStore_ROUTINE) (
                        OUT CMQSigCertStore **ppStore,
                        IN  LPSTR      lpszRegRoot,
                        IN  BOOL       fWriteAccess = FALSE ,
                        IN  BOOL       fCreate = FALSE ) ;

typedef HRESULT
(APIENTRY *MQSigCloneCertFromStore_ROUTINE) (
                        OUT CMQSigCertificate **ppCert,
                  const IN  LPSTR               lpszRegRoot,
                  const IN  LONG                iCertIndex ) ;

typedef HRESULT
(APIENTRY *MQSigCloneCertFromSysStore_ROUTINE) (
                            OUT CMQSigCertificate **ppCert,
                      const IN  LPSTR               lpszProtocol,
                      const IN  LONG                iCertIndex ) ;

#ifdef __cplusplus
}
#endif

//******************************
//
//  class  CMQSigCertificate
//
//******************************

class  CMQSigCertificate
{
    friend
           HRESULT APIENTRY
           MQSigCreateCertificate(
                             OUT CMQSigCertificate **ppCert,
                             IN  PCCERT_CONTEXT      pCertContext,
                             IN  PBYTE               pCertBlob,
                             IN  DWORD               dwCertSize ) ;

    public:
        CMQSigCertificate() ;
        ~CMQSigCertificate() ;

        virtual HRESULT   EncodeCert( IN BOOL     fMachine,
                                      OUT BYTE  **ppCertBuf,
                                      OUT DWORD  *pdwSize ) ;
         //
         // "EncodeCert" is the last method to call when creating a
         // certificate. It follows all the "PutXX" methods which set the
         // various fields of the certifiacte. The returned buffer (pCertBuf)
         // is the encoded and signed certificate.
         //

        virtual HRESULT   GetCertDigest(OUT GUID  *pguidDigest) ;

        virtual HRESULT   GetCertBlob(OUT BYTE  **ppCertBuf,
                                      OUT DWORD *pdwSize) const ;
          //
          // ppCertBuf only points to the internal buffer in the object.
          // Caller must not free it or change it in any way.
          //

        virtual HRESULT   AddToStore( IN HCERTSTORE hStore ) const ;
         //
         // Add the certificate to a certificates store.
         //

        virtual HRESULT   DeleteFromStore() ;
         //
         // Delete the certificate from store.
         //

        virtual HRESULT   Release( BOOL fKeepContext = FALSE ) ;

        //-------------------------------------------------
        //  PUT methods. Set up the certificate fields.
        //-------------------------------------------------

        virtual HRESULT   PutIssuer( LPWSTR lpwszLocality,
                                      LPWSTR lpwszOrg,
                                      LPWSTR lpwszOrgUnit,
                                      LPWSTR lpwszDomain,
                                      LPWSTR lpwszUser,
                                      LPWSTR lpwszMachine ) ;


        virtual HRESULT   PutSubject( LPWSTR lpwszLocality,
                                       LPWSTR lpwszOrg,
                                       LPWSTR lpwszOrgUnit,
                                       LPWSTR lpwszDomain,
                                       LPWSTR lpwszUser,
                                       LPWSTR lpwszMachine ) ;


        virtual HRESULT   PutValidity( WORD wYears ) ;
         //
         // The granularity of this setting is a year.
         // The cert is valid for "dwYears", starting with the issue date.
         //

        virtual HRESULT   PutPublicKey( IN  BOOL  fRenew,
                                        IN  BOOL  fMachine,
                                        OUT BOOL *pfCreated = NULL ) ;
         //
         // if fRenew is TRUE, then previous private/public keys pair are
         // deleted (if they exsited) and recreated.
         // Otherwise, old keys are used if available. If not available,
         // they are created.
         // On return, pfCreate is TRUE if a new key was created.
         //

        //-------------------------------------------------
        //  GET methods. Retrieve the certificate fields.
        //-------------------------------------------------

        virtual HRESULT   GetIssuer( OUT LPWSTR *ppszLocality,
                                     OUT LPWSTR *ppszOrg,
                                     OUT LPWSTR *ppszOrgUnit,
                                     OUT LPWSTR *ppszCommon ) const ;

        virtual HRESULT   GetIssuerInfo(
                                 OUT CERT_NAME_INFO **ppNameInfo ) const ;
         //
         // ppNameInfo can be used when calling "GetNames", to retrieve
         // the name components of the certificate. The caller must
         // free (delete) the memory allocated for ppNameInfo.
         //

        virtual HRESULT   GetSubject( OUT LPWSTR *ppszLocality,
                                      OUT LPWSTR *ppszOrg,
                                      OUT LPWSTR *ppszOrgUnit,
                                      OUT LPWSTR *ppszCommon ) const ;

        virtual HRESULT   GetSubjectInfo(
                                 OUT CERT_NAME_INFO **ppNameInfo ) const ;
         //
         // ppNameInfo can be used when calling "GetNames", to retrieve
         // the name components of the certificate. The caller must
         // free (delete) the memory allocated for ppNameInfo.
         //

        virtual HRESULT   GetNames( IN CERT_NAME_INFO *pNameInfo,
                                    OUT LPWSTR         *ppszLocality,
                                    OUT LPWSTR         *ppszOrg,
                                    OUT LPWSTR         *ppszOrgUnit,
                                    OUT LPWSTR         *ppszCommon,
                               OUT LPWSTR  *ppEmailAddress = NULL ) const ;

        virtual HRESULT   GetValidity( OUT FILETIME *pftNotBefore,
                                       OUT FILETIME *pftNotAfter ) const ;

        virtual HRESULT   GetPublicKey( IN  HCRYPTPROV hProv,
                                        OUT HCRYPTKEY  *phKey ) const ;

        //-------------------------------------------------
        //  Validation methods, to validate a certificate
        //-------------------------------------------------

        virtual HRESULT   IsTimeValid(IN FILETIME *pTime = NULL) const ;

        virtual HRESULT   IsCertificateValid(
                IN CMQSigCertificate *pIssuerCert,
                IN DWORD              dwFlags =  x_dwCertValidityFlags,
                IN FILETIME          *pTime   = NULL,
                IN BOOL               fIgnoreNotBefore = FALSE)  const ;

        virtual PCCERT_CONTEXT GetContext() const ;

    private:
        CHCryptProv m_hProvCreate ;
         //
         // auto-release handle for crypto provider. Used for creating
         // a certificate. May be used to create public/private key pair.
         //

        HCRYPTPROV  m_hProvRead ;
         //
         // "Read-Only" handle of crypto provider. This is a replica of a
         // dll global handle, used by all objects and all threads. It is
         // released when dll is unloaded. It must not be released by any
         // object.
         //

        BOOL        m_fCreatedInternally ;
        CpCertInfo  m_pCertInfo ; // auto released pointer.
          // this CERT_INFO structure is built only when a certificate
          // is created from scratch.

        CERT_INFO   *m_pCertInfoRO ;
          //
          // Read-Only pointer to CERT_INFO. It points either to m_pCertInfo,
          // if we create a certificate, or to m_pCertContext->pCertInfo,
          // if a certificate is imported. NEVER release this pointer.
          //

        //
        // The following variables are used to create internal certificates.
        //
        DWORD              m_dwSerNum ;
        CRYPT_OBJID_BLOB   m_SignAlgID ;

        P<CERT_PUBLIC_KEY_INFO> m_pPublicKeyInfo ;
         //
         // Buffer for encoded and exported public key.
         //

        BYTE      *m_pEncodedCertBuf ;
         //
         // this buffer holds the encoded certificate.
         //
        DWORD      m_dwCertBufSize ;

        PCCERT_CONTEXT      m_pCertContext ;
         //
         //  Certificate context. Exist only when create an object from
         //  existing certificate.
         //

        BOOL   m_fKeepContext ;
         //
         // This flag indicates that the context must not be freed when
         // deleting this certificate object. You set it to TRUE only by
         // calling Release( TRUE ).
         //

        BOOL   m_fDeleted ;
         //
         // TRUE if the certificate was deleted from store.  (or at least
         // DeleteFromStore() was called). In that case, the certificate
         // context (m_pCertContext) is not valid any more. It as freed
         // by the delete operation, even if the operation failed.
         //

	    CMQSigCertificate(const CMQSigCertificate&);
		CMQSigCertificate& operator=(const CMQSigCertificate&);

        HRESULT   _InitCryptProviderRead() ;
        HRESULT   _InitCryptProviderCreate( IN BOOL fCreate,
                                            IN BOOL fMachine ) ;
         //
         // Initialize the crypto provider.
         // if fCreate is TRUE then a new pair of public/private keys is
         // always created. Old keys are deleted if available.
         //

        HRESULT   _Create(IN PCCERT_CONTEXT  pCertContext) ;
         //
         // Create an empty certificate (if pEncodedCert is NULL) or
         // initialize a certificate from that encoded buffer.
         //

        //
        // Methds to encode names.
        //
        HRESULT   _EncodeName( LPWSTR  lpszLocality,
                               LPWSTR  lpszOrg,
                               LPWSTR  lpszOrgUnit,
                               LPWSTR  lpszDomain,
                               LPWSTR  lpszUser,
                               LPWSTR  lpszMachine,
                               BYTE   **ppBuf,
                               DWORD  *pdwBufSize ) ;

        HRESULT   _EncodeNameRDN( CERT_RDN_ATTR *rgNameAttr,
                                  DWORD  cbRDNs,
                                  BYTE   **ppBuf,
                                  DWORD  *pdwBufSize ) ;

        HRESULT   _DecodeName( IN  BYTE  *pEncodedName,
                               IN  DWORD dwEncodedSize,
                               OUT BYTE  **pBuf,
                               OUT DWORD *pdwBufSize ) const ;

        HRESULT   _GetAName( IN  CERT_RDN  *pRDN,
                             OUT LPWSTR     *ppszName ) const ;

} ;

//******************************
//
//  class  CMQSigCertStore
//
//******************************

class  CMQSigCertStore
{
    friend
         HRESULT APIENTRY
         MQSigOpenUserCertStore( OUT CMQSigCertStore **pStore,
                                 IN  LPSTR      lpszRegRoot,
                                 IN  struct MQSigOpenCertParams *pParams ) ;

    public:
        CMQSigCertStore() ;
        ~CMQSigCertStore() ;

        virtual HRESULT     Release() ;
        virtual HCERTSTORE  GetHandle() ;

    private:
        HCERTSTORE  m_hStore ;
         //
         //  Handle of opened store.
         //

        HCRYPTPROV m_hProv ;
         //
         // This is a global handle in mqcert.dll.
         // Must not be released by this object.
         //

        HKEY        m_hKeyStoreReg ;
         //
         // Registry location of store.
         //

         //
         // Initialize the crypto provider.
         //
        HRESULT   _InitCryptProvider() ;

         //
         // Open the store.
         //
        HRESULT   _Open( IN  LPSTR      lpszRegRoot,
                         IN  struct MQSigOpenCertParams *pParams ) ;
} ;

//***************************
//
//  Inline Methods
//
//***************************

//+-----------------------------------------------------------------------
//
//  HRESULT CMQSigCertificate::GetCertBlob()
//
//+-----------------------------------------------------------------------

inline HRESULT CMQSigCertificate::GetCertBlob(OUT BYTE  **ppCertBuf,
                                              OUT DWORD *pdwSize) const
{
    if (!m_pEncodedCertBuf)
    {
        return MQSec_E_INVALID_CALL ;
    }

    *ppCertBuf = m_pEncodedCertBuf ;
    *pdwSize = m_dwCertBufSize ;

    return MQSec_OK ;
}

//+-----------------------------------------------
//
//   CMQSigCertificate::GetContext() const
//
//+-----------------------------------------------

inline PCCERT_CONTEXT CMQSigCertificate::GetContext() const
{
    ASSERT(m_pCertContext) ;
    return m_pCertContext ;
}

//+-----------------------------------------------------------------------
//
//  inline HCERTSTORE CMQSigCertStore::GetHandle()
//
//+-----------------------------------------------------------------------

inline HCERTSTORE CMQSigCertStore::GetHandle()
{
    return m_hStore ;
}

#endif  //  _MQCERT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\mqdbmgr.h ===
/*++

Copyright (c) 1995-96  Microsoft Corporation

Module Name:
      mqdbmgr.h

Abstract:
   Define constants and API exported by mqdbmgr.dll.
   mqdbmgr.dll provides other QM modules with a simple interface to a
   relational database.

   For more information, see MQDBMGR.DOC in the Falcon documentation.

Author:
   Doron Juster (DoronJ)

Revisions:
   DoronJ      09-Jan-96   Created

--*/

#ifndef __MQDBMGR_H__
#define __MQDBMGR_H__

#include "mqsymbls.h"


//********************************************************************
//                       E R R O R / S T A T U S   C O D E S
//********************************************************************

#define  MQDB_OK  0

#define MQDB_E_BASE  (MQ_E_BASE + 0x0700)
#define MQDB_I_BASE  (MQ_I_BASE + 0x0700)

#define MQDB_E_UNKNOWN             (MQDB_E_BASE + 0x0000)    // Unidentified problem
#define MQDB_E_INVALID_CALL        (MQDB_E_BASE + 0x0001)    // Illegal call
#define MQDB_E_DB_NOT_FOUND        (MQDB_E_BASE + 0x0002)    // Can't find the database.
#define MQDB_E_BAD_CCOLUMNS        (MQDB_E_BASE + 0x0003)    // Invalid number of columns
#define MQDB_E_BAD_HDATABASE       (MQDB_E_BASE + 0x0004)    // Invalid database handle
#define MQDB_E_CANT_CREATE_TABLE   (MQDB_E_BASE + 0x0005)
#define MQDB_E_CANT_DELETE_TABLE   (MQDB_E_BASE + 0x0006)
#define MQDB_E_INVALID_TYPE        (MQDB_E_BASE + 0x0007)    // Invalid column type
#define MQDB_E_TABLE_NOT_FOUND     (MQDB_E_BASE + 0x0008)    // Can't find the table
#define MQDB_E_BAD_HTABLE          (MQDB_E_BASE + 0x0009)    // Invalid table handle
#define MQDB_E_CANT_CREATE_INDEX   (MQDB_E_BASE + 0x000A)
#define MQDB_E_INDEX_ALREADY_EXIST (MQDB_E_BASE + 0x000B)
#define MQDB_E_DATABASE            (MQDB_E_BASE + 0x000C)    // Database problems
#define MQDB_E_INVALID_DATA        (MQDB_E_BASE + 0x000D)    // Invalid data
#define MQDB_E_OUTOFMEMORY         (MQDB_E_BASE + 0x000E)    // Not enough memory
#define MQDB_E_TABLE_ALREADY_EXIST (MQDB_E_BASE + 0x000F)
#define MQDB_E_CANT_DELETE_INDEX   (MQDB_E_BASE + 0x0010)
#define MQDB_E_BAD_HQUERY          (MQDB_E_BASE + 0x0011)    // Invalid query handle
#define MQDB_E_NO_MORE_DATA        (MQDB_E_BASE + 0x0012)
#define MQDB_E_DLL_NOT_INIT        (MQDB_E_BASE + 0x0013)    // Dll not initialized yet
#define MQDB_E_CANT_INIT_JET       (MQDB_E_BASE + 0x0014)    // can't init Jet engine
#define MQDB_E_TABLE_FULL          (MQDB_E_BASE + 0x0015)    // Table full. Can't insert record.
#define MQDB_E_NON_UNIQUE_SORT     (MQDB_E_BASE + 0x0016)    // Happen on SQL server when ORDER BY clause get same column name more than once.
#define MQDB_E_NO_ROW_UPDATED      (MQDB_E_BASE + 0x0017)    // An update command didn't update any row.
#define MQDB_E_DBMS_NOT_AVAILABLE  (MQDB_E_BASE + 0x0018)    //
#define MQDB_E_UNSUPPORTED_DBMS    (MQDB_E_BASE + 0x0019)    // The database system is not supported (e.g., SQL6.5 SP2)
#define MQDB_E_DB_READ_ONLY        (MQDB_E_BASE + 0x001a)    // Database in read-only mode.
#define MQDB_E_BAD_SIZE_VALUE      (MQDB_E_BASE + 0x001b)    // Database size is wrong
#define MQDB_E_DEADLOCK            (MQDB_E_BASE + 0x001c)    // operation failed because of deadlock.

//********************************************************************
//          D A T A   T Y P E S
//********************************************************************

#define MQDB_VERSION_STRING_LEN  64

typedef struct _MQDBVERSION {
   DWORD dwMinor ;
   DWORD dwMajor ;
   DWORD dwProvider ;
   char  szDBMSName[ MQDB_VERSION_STRING_LEN ] ;
   char  szDBMSVer[ MQDB_VERSION_STRING_LEN ] ;
} MQDBVERSION, *LPMQDBVERSION ;

#define  MQDB_ODBC  1
#define  MQDB_DAO3  2

typedef LONG      MQDBSTATUS ;
typedef HANDLE    MQDBHANDLE ;
typedef HANDLE *  LPMQDBHANDLE ;

typedef struct _MQDBOPENDATABASE {
   IN LPSTR    lpszDatabaseName ;
   IN LPSTR    lpszDatabasePath ;
   IN LPSTR    lpszUserName ;
   IN LPSTR    lpszPassword ;
   IN BOOL     fCreate ;
   OUT MQDBHANDLE    hDatabase ;
} MQDBOPENDATABASE, *LPMQDBOPENDATABASE ;

// !!!!!!!!!!  IMPORTANT  !!!!!!!!!!!!!
// Don't forget to update the relevant, database specific types, when
// updating COLUMNTYPE.
// for ODBC, update mqdbodbc.h, "dbODBCSQLTypes"

#define MQDB_NUMOF_TYPES   8

typedef enum _MQDBCOLUMNTYPE {
   MQDB_SHORT = 0,     // 16bit short integer
   MQDB_LONG,          // 32bit long integer
   MQDB_STRING,        // NULL terminated Ascii string
   MQDB_USTRING,       // NULL terminated Unicode string.
   MQDB_USTRING_UPPER, // NULL terminated Unicode string (see below)
   MQDB_FIXBINARY,     // Fixed length long binary field
   MQDB_VARBINARY,     // Variable length long binary field.
   MQDB_IDENTITY       // Long Identity column.
} MQDBCOLUMNTYPE ;

// !!!!!!!!!!  IMPORTANT  !!!!!!!!!!!!!  See above

typedef struct _MQDBCOLUMNDEF{
   LPSTR             lpszColumnName ;
   MQDBCOLUMNTYPE    mqdbColumnType ;
   LONG              nColumnLength ;
   BOOL              fPrimaryKey ;
   BOOL              fUnique ;
} MQDBCOLUMNDEF ;

typedef struct _MQDBCOLUMNDEFEX{
   WORD              cbSize ;
   LPSTR             lpszColumnName ;
   MQDBCOLUMNTYPE    mqdbColumnType ;
   LONG              nColumnLength ;
   BOOL              fPrimaryKey ;
   BOOL              fUnique ;
   BOOL              fNull ;
} MQDBCOLUMNDEFEX ;

typedef struct _MQDBCOLUMNVAL {
   WORD            cbSize ;
   LPSTR           lpszColumnName ;
   LONG            nColumnValue ;
   LONG            nColumnLength ;
   MQDBCOLUMNTYPE  mqdbColumnType ;
   DWORD           dwReserve_A ;
} MQDBCOLUMNVAL, *LPMQDBCOLUMNVAL ;


// !!!!!!!!!!  IMPORTANT  !!!!!!!!!!!!!
// Don't forget to update the relevant, database specific op-string, when
// updating MQDBOP.
// for ODBC, update mqdbodbc.h, "dbODBCOpStrings"

#define MQDB_NUMOF_OPS  8

typedef enum _MQDBOP {
   EQ = 0, // Equal
   NE,     // Not Equal
   GE,     // Great than or Equal
   GT,     // Great than
   LE,     // Less than or Equal
   LT,     // Less than
   OR,     // Logical OR.
   AND     // Logical AND
} MQDBOP ;

// !!!!!!!!!!  IMPORTANT  !!!!!!!!!!!!!  See above

// The MQDBCOLUMNSEARCH structure is used whenever a search is done in the
// database before an operation is performed. For example, in
// MQDBDeleteRecord, you first search for the proper record(s) and then
// delete it (them).  The search condition is met when:
//
//          mqdbColumnVal.lpszColumnName  mqdbOp mqdbColumnVal.nColumnValue
// Example:         "MsgID"                 EQ          6

typedef struct _MQDBCOLUMNSEARCH {
   MQDBCOLUMNVAL  mqdbColumnVal ;
   MQDBOP         mqdbOp ;
   BOOL           fPrepare ; // True if search value is to be prepared.
} MQDBCOLUMNSEARCH, *LPMQDBCOLUMNSEARCH ;

// The MQDBJOINOP defines the way a Join is performed.

typedef  struct _MQDBJOINOP {
   LPSTR    lpszLeftColumnName ;
   LPSTR    lpszRightColumnName ;
   MQDBOP   opJoin ;
   BOOL     fOuterJoin ;
} MQDBJOINOP, *LPMQDBJOINOP ;

// The MQDBSEARCHORDER structure is used to define order of records which
// are retrieved in a query.

#define MQDB_NUMOF_ORDER_OP  2

typedef enum _MQDBORDER {
   ASC = 0,
   DESC
} MQDBORDER ;

typedef struct _MQDBSEARCHORDER {
   LPSTR       lpszColumnName ;
   MQDBORDER   nOrder ;
} MQDBSEARCHORDER, *LPMQDBSEARCHORDER ;

typedef enum _MQDBTRANSACOP {
   AUTO,       // Make every call an isolated transaction.
   BEGIN,      // Begin a transaction.
   COMMIT,     // Commit a transaction.
   ROLLBACK,   // Roll back a transaction.
} MQDBTRANSACOP ;

//
//  enum which list all "set-able" options.
//
typedef enum _MQDBOPTION {
   MQDBOPT_MULTIPLE_QUERIES,
   MQDBOPT_INSERT_IDENTITY,
   MQDBOPT_NOLOCK_QUERIES,
   MQDBOPT_QUERY_TIMEOUT
} MQDBOPTION ;

//
// enum which list operation to be performed by calling MQDBExecute
//
typedef enum _MQDBEXEC {
   MQDBEXEC_UPDATE_STATISTICS,
   MQDBEXEC_SPACE_USED
} MQDBEXEC ;

//
// enum to list argregate function
//
typedef enum _MQDBAGGR {
    MQDBAGGR_MAX = 0,
    MQDBAGGR_MIN,
    MQDBAGGR_AVRG
} MQDBAGGR ;

//********************************************************************
//
//          A P I   P R O T O T Y P E S
//
//********************************************************************

MQDBSTATUS APIENTRY  MQDBGetVersion( IN MQDBHANDLE         hDatabase,
                                     IN OUT LPMQDBVERSION  pVersoin ) ;

MQDBSTATUS APIENTRY  MQDBInitialize() ;

MQDBSTATUS APIENTRY  MQDBTerminate() ;

MQDBSTATUS APIENTRY  MQDBOpenDatabase(
                     IN OUT  LPMQDBOPENDATABASE pDatabase) ;

MQDBSTATUS APIENTRY  MQDBCloseDatabase(
                     IN MQDBHANDLE  hDatabase) ;

MQDBSTATUS APIENTRY  MQDBCreateTable(
                     IN MQDBHANDLE     hDatabase,
                     IN LPSTR          lpszTableName,
                     IN MQDBCOLUMNDEF  aColumnDef[],
                     IN LONG           cColumns) ;

MQDBSTATUS APIENTRY  MQDBCreateTableEx(
                     IN MQDBHANDLE       hDatabase,
                     IN LPSTR            lpszTableName,
                     IN MQDBCOLUMNDEFEX  aColumnDefEx[],
                     IN LONG             cColumns) ;

MQDBSTATUS APIENTRY  MQDBDeleteTable(
                     IN MQDBHANDLE    hDatabase,
                     IN LPSTR         lpszTableName) ;

MQDBSTATUS APIENTRY  MQDBOpenTable(
                     IN MQDBHANDLE     hDatabase,
                     IN LPSTR          lpszTableName,
                     OUT LPMQDBHANDLE  phTable) ;

MQDBSTATUS APIENTRY  MQDBCloseTable(
                     IN MQDBHANDLE     hTable) ;

MQDBSTATUS APIENTRY  MQDBCreateIndex(
                     IN MQDBHANDLE  hTable,
                     IN LPSTR lpszIndexName,
                     IN LPSTR lpszColumnName[],
                     IN LONG  cColumns,
                     IN BOOL  fUnique,
                     IN BOOL  fClustered) ;

MQDBSTATUS APIENTRY  MQDBDeleteIndex(
                     IN MQDBHANDLE  hTable,
                     IN LPSTR       lpszIndexName,
                     IN BOOL        fUnique,
                     IN BOOL        fClustered) ;

MQDBSTATUS APIENTRY  MQDBInsertRecord(
                     IN MQDBHANDLE        hTable,
                     IN MQDBCOLUMNVAL     aColumnVal[],
                     IN LONG              cColumns,
                     IN OUT LPMQDBHANDLE  lphInsert) ;

MQDBSTATUS APIENTRY  MQDBUpdateRecord(
                     IN MQDBHANDLE        hTable,
                     IN MQDBCOLUMNVAL     aUpdateColumnVal[],
                     IN LONG              cUpdateColumns,
                     IN MQDBCOLUMNSEARCH  *pWhereColumnSearch,
                     IN LPSTR             lpszSearchCondition,
                     IN OUT LPMQDBHANDLE  lphInsert) ;

MQDBSTATUS APIENTRY  MQDBUpdateRecordEx(
                     IN MQDBHANDLE        hTable,
                     IN MQDBCOLUMNVAL     aUpdateColumnVal[],
                     IN LONG              cUpdateColumns,
                     IN MQDBCOLUMNSEARCH  *pWhereColumnSearch,
                     IN LONG              cWhere,
                     IN MQDBOP            opWhere,
                     IN OUT LPMQDBHANDLE  lphInsert) ;

MQDBSTATUS APIENTRY  MQDBTruncateTable(
                     IN MQDBHANDLE        hTable ) ;

MQDBSTATUS APIENTRY  MQDBDeleteRecord(
                     IN MQDBHANDLE        hTable,
                     IN MQDBCOLUMNSEARCH  *pWhereColumnSearch,
                     IN LPSTR             lpszSearchCondition) ;

MQDBSTATUS APIENTRY  MQDBDeleteRecordEx(
                     IN MQDBHANDLE        hTable,
                     IN MQDBCOLUMNSEARCH  *pWhereColumnSearch,
                     IN LONG              cWhere,
                     IN MQDBOP            opWhere) ;

MQDBSTATUS APIENTRY  MQDBOpenQuery(
                     IN MQDBHANDLE        hTable,
                     IN MQDBCOLUMNVAL     aColumnVal[],
                     IN LONG              cColumns,
                     IN MQDBCOLUMNSEARCH  *pWhereColumnSearch,
                     IN LPSTR             lpszSearchCondition,
                     IN LPMQDBSEARCHORDER lpOrder,
                     IN LONG              cOrders,
                     OUT LPMQDBHANDLE     phQuery,
                     IN BOOL              fGetFirst,
                     IN DWORD             dwTimeout = 0 ) ;

MQDBSTATUS APIENTRY  MQDBOpenQueryEx(
                     IN MQDBHANDLE        hTable,
                     IN MQDBCOLUMNVAL     aColumnVal[],
                     IN LONG              cColumns,
                     IN MQDBCOLUMNSEARCH  pWhereColumnSearch[],
                     IN LONG              cWhere,
                     IN MQDBOP            opWhere,
                     IN LPMQDBSEARCHORDER lpOrder,
                     IN LONG              cOrders,
                     OUT LPMQDBHANDLE     phQuery,
                     IN BOOL              fGetFirst,
                     IN DWORD             dwTimeout = 0 ) ;

MQDBSTATUS APIENTRY  MQDBOpenAggrQuery(
                     IN MQDBHANDLE        hTable,
                     IN MQDBCOLUMNVAL     aColumnVal[],
                     IN MQDBAGGR          mqdbAggr,
                     IN MQDBCOLUMNSEARCH  pWhereColumnSearch[],
                     IN LONG              cWhere,
                     IN MQDBOP            opWhere,
                     IN DWORD             dwTimeout = 0 ) ;

MQDBSTATUS APIENTRY  MQDBGetData(
                     IN MQDBHANDLE     hQuery,
                     IN MQDBCOLUMNVAL  aColumnVal[]) ;

MQDBSTATUS APIENTRY  MQDBCloseQuery(
                     IN MQDBHANDLE     hQuery) ;

MQDBSTATUS APIENTRY  MQDBOpenJoinQuery(
                     IN MQDBHANDLE        hDatabase,
                     IN LPSTR             lpszLeftTableName,
                     IN LPSTR             lpszRightTableName,
                     IN MQDBCOLUMNVAL     aColumnVal[],
                     IN LONG              cLefts,
                     IN LONG              cRights,
                     IN LPMQDBJOINOP      opJoin,
                     IN MQDBCOLUMNSEARCH  pWhereColumnSearch[],
                     IN LONG              cWhereLeft,
                     IN LONG              cWhereRight,
                     IN MQDBOP            opWhere,
                     IN LPMQDBSEARCHORDER pOrder,
                     IN LONG              cOrders,
                     OUT LPMQDBHANDLE     phQuery,
                     IN BOOL              fGetFirst,
                     IN DWORD             dwTimeout = 0 ) ;

MQDBSTATUS APIENTRY  MQDBTransaction(
                     IN  MQDBHANDLE     hDatabase,
                     IN  MQDBTRANSACOP  mqdbTransac) ;

MQDBSTATUS APIENTRY  MQDBFreeBuf( IN LPVOID  lpMem ) ;

MQDBSTATUS APIENTRY  MQDBSetOption(
                     IN MQDBHANDLE     hDatabase,
                     IN MQDBOPTION     mqdbOption,
                     IN DWORD          dwValue,
                     IN LPSTR          lpszValue,
                     IN MQDBHANDLE     hQuery = NULL ) ;

MQDBSTATUS APIENTRY  MQDBEscape(
                     IN MQDBHANDLE     hDatabase,
                     IN LPSTR          lpszCommand ) ;

MQDBSTATUS APIENTRY  MQDBExecute(
                     IN MQDBHANDLE     hDatabase,
                     IN MQDBHANDLE     hTable,
                     IN MQDBEXEC       ExecOp,
                     IN OUT DWORD      *pdwValue,
                     IN LPSTR          lpszValue ) ;

///////////////////////////////////
//
//  Usefull Macros
//
///////////////////////////////////

#define INIT_COLUMNDEF(Col)            \
   Col.lpszColumnName = NULL ;         \
   Col.mqdbColumnType = MQDB_LONG ;    \
   Col.nColumnLength  = 0 ;            \
   Col.fPrimaryKey    = FALSE ;        \
   Col.fUnique        = FALSE ;

#define INIT_COLUMNDEFEX(Col)                         \
   Col.cbSize         = sizeof(MQDBCOLUMNDEFEX) ;     \
   Col.lpszColumnName = NULL ;                        \
   Col.mqdbColumnType = MQDB_LONG ;                   \
   Col.nColumnLength  = 0 ;                           \
   Col.fPrimaryKey    = FALSE ;                       \
   Col.fUnique        = FALSE ;                       \
   Col.fNull          = TRUE ;

#define INIT_COLUMNVAL(Col)                        \
   Col.cbSize         = sizeof(MQDBCOLUMNVAL) ;    \
   Col.lpszColumnName = NULL ;                     \
   Col.nColumnValue   = 0 ;                        \
   Col.nColumnLength  = 0 ;                        \
   Col.mqdbColumnType = MQDB_LONG ;                \
   Col.dwReserve_A    = 0

#define INIT_COLUMNSEARCH(Col)            \
   INIT_COLUMNVAL(Col.mqdbColumnVal) ;    \
   Col.mqdbOp = EQ ;                      \
   Col.fPrepare = FALSE ;

#define SET_COLUMN_NAME(Col, name)     \
   Col.lpszColumnName = name ;

#define SET_COLUMN_VALUE(Col, Val)     \
   Col.nColumnValue = (LONG) (Val) ;

#endif // __MQDBMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\mqdsdef.h ===
/*++

Copyright (c) 1995-99  Microsoft Corporation

Module Name:

	mqdsdef.h

Abstract:

	Message Queuing's Directory Service defines

    Note: when this file was first created in msmq1.0, it indeed defined
          only type of objects stored in MQIS. As time passed, and as
          we moved to msmq2.0 on Windows 2000, this file also define type
          of internal objects, those that are never stored in active
          directory, but are used internally in msmq code.

--*/
#ifndef __MQDSDEF_H__
#define __MQDSDEF_H__


//********************************************************************
//				DS object types
//********************************************************************

// dwObjectType values
#define	MQDS_QUEUE		    1
#define MQDS_MACHINE	    2
#define	MQDS_SITE		    3
#define MQDS_DELETEDOBJECT	4
#define MQDS_CN			    5
#define MQDS_ENTERPRISE	    6
#define MQDS_USER           7
#define MQDS_SITELINK       8

//
// The following are not applicable to msmq2.0 on Windows 2000.
//
// DO NOT RECYCLE THE NUMBERS !!!
//
#define MQDS_PURGE		    9
#define MQDS_BSCACK		    10

//  for internal use only
#define MQDS_MACHINE_CN     11

//
// MAX_MQIS_TYPES is used in NT5 replication service, as array size for
// several arrays which map from object type to propid.
//
#define MAX_MQIS_TYPES      11

//
//  ADS objects
//
#define MQDS_SERVER     50
#define MQDS_SETTING    51
#define MQDS_COMPUTER   52

//
//  This is a temporary object : until msmq is in NT5 schema.
//  It is required for displaying MSMQ queues on left pane of MMC
//
#define MQDS_LEFTPANEQUEUE 53

//
// special object: MSMQ users that do not belong to NT5 domain
//
#define MQDS_MQUSER    54

//
// This type is used when running setup of a msmq1.0 client. It's used
// for creation of the default security descriptor of the msmqConfiguration
// object.
//
#define MQDS_MSMQ10_MACHINE  55

//
// This type is used when run time call local msmq service to create a local
// publib queue. that's new feature of win2000, whereas by default users do
// not have permissions to create queues, only LocalSystem msmq service has
// this permission.
//
#define MQDS_LOCAL_PUBLIC_QUEUE  56

//
// This type is used by the "mqforgn" tool to handle msmqConfiguration
// objects of foreign computers.
//
#define  MQDS_FOREIGN_MACHINE  57

//
//	MQDS_PRIVATE_COMPUTER type represents computer properties that
//	are calculated by the computer and not retrieved from the DS
//
#define MQDS_PRIVATE_COMPUTER	  58

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\mqcertui.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    mqcertui.h

Abstract:

    Dialogs for certificate related user interface.

Author:

    Boaz Feldbaum (BoazF)  15-Oct-1996
    Doron Juster  (DoronJ) 15-dec-1997, remove digsig, use crypto2.0

--*/

#include "mqcert.h"

#ifdef __cplusplus
extern "C"
{
#endif

BOOL
ShowPersonalCertificates(
        HWND                hWndParent,
        CMQSigCertificate  *pCertList[],
        DWORD               nCerts );

BOOL
SelectPersonalCertificateForRemoval(
        HWND                hWndParent,
        CMQSigCertificate  *pCertList[],
        DWORD               nCerts,
        CMQSigCertificate **ppCert ) ;

BOOL
SelectPersonalCertificateForRegister(
        HWND                hWndParent,
        CMQSigCertificate  *pCertList[],
        DWORD               nCerts,
        CMQSigCertificate **ppCert ) ;


#define CERT_TYPE_INTERNAL 1
#define CERT_TYPE_PERSONAL 2
#define CERT_TYPE_CA 3
#define CERT_TYPE_MASK 0xff

void
ShowCertificate(
        HWND                hParentWnd,
        CMQSigCertificate  *pCert,
        DWORD               dwFlags );


#define ID_UPDATE_CERTS 1000

INT_PTR
CaConfig(
    HWND     hParentWnd,
    DWORD    nCerts,
    PBYTE    pbCerts[],
    DWORD    dwCertSize[],
    LPCWSTR  szCertNames[],
    BOOL     fEnabled[],
    BOOL     fDeleted[],
    BOOL     fAllowDeletion
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\mqcrypt.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:
    mqcrypt.h

Abstract:
    Falcon cryptographic stuff

Author:
    Boaz Feldbaum (BoazF) 16-Oct-1996

Revision History:

--*/

#ifndef _MQCRYPT_H_
#define _MQCRYPT_H_

#include <winreg.h>
#include <wincrypt.h>
#pragma warning(disable: 4100)

//+------------------------------------------------------------
//
// A helper class for automatically releasing the CSP context.
//
//+------------------------------------------------------------

class CHCryptProv
{
public:
    CHCryptProv() : m_hProv(NULL) {}
    CHCryptProv(HCRYPTPROV hProv) : m_hProv(hProv) {}
    ~CHCryptProv() ;
    HCRYPTPROV * operator &() { return &m_hProv; }
    operator HCRYPTPROV() { return m_hProv; }
    CHCryptProv &operator =(HCRYPTPROV hProv) { m_hProv = hProv; return *this; }
private:
    HCRYPTPROV m_hProv;
};

inline CHCryptProv::~CHCryptProv()
{
    if (m_hProv)
    {
       CryptReleaseContext(m_hProv, 0);
    }
}

//+---------------------------------------------------------
//
// A helper class for automatically destroying a key.
//
//+---------------------------------------------------------

class CHCryptKey
{
public:
    CHCryptKey() : m_hKey(NULL) {}
    CHCryptKey(HCRYPTKEY hKey) : m_hKey(hKey) {}
    ~CHCryptKey() { if (m_hKey) CryptDestroyKey(m_hKey); }
    HCRYPTKEY * operator &() { return &m_hKey; }
    operator HCRYPTKEY() { return m_hKey; }
    CHCryptKey &operator =(HCRYPTKEY hKey) { m_hKey = hKey; return *this; }
private:
    HCRYPTKEY m_hKey;
};

//+--------------------------------------------------------
//
// A helper class for automatically destroying a hash.
//
//+--------------------------------------------------------

class CHCryptHash
{
public:
    CHCryptHash() : m_hHash(NULL) {}
    CHCryptHash(HCRYPTHASH hHash) : m_hHash(hHash) {}
    ~CHCryptHash() { if (m_hHash) CryptDestroyHash(m_hHash); }
    HCRYPTHASH * operator &() { return &m_hHash; }
    operator HCRYPTHASH() { return m_hHash; }
    CHCryptHash &operator =(HCRYPTHASH hHash) { m_hHash = hHash; return *this; }
private:
    HCRYPTHASH m_hHash;
};

//
// A helper class for automatically closing a certificate store.
//
class CHCertStore
{
public:
    CHCertStore() : m_hStore(NULL) {}
    CHCertStore(HCERTSTORE hStore) : m_hStore(hStore) {}
    ~CHCertStore()
        { if (m_hStore) CertCloseStore(m_hStore, CERT_CLOSE_STORE_FORCE_FLAG); }
    HCERTSTORE * operator &() { return &m_hStore; }
    operator HCERTSTORE() { return m_hStore; }
    CHCertStore &operator =(HCERTSTORE hStore) { m_hStore = hStore; return *this; }
private:
    HCERTSTORE m_hStore;
};

//+------------------------------------------------------------------
//
// A helper class for automatically freeing a certificate context.
//
//+------------------------------------------------------------------

class CPCCertContext
{
public:
    CPCCertContext() : m_pCert(NULL) {}
    CPCCertContext(PCCERT_CONTEXT pCert) : m_pCert(pCert) {}
    ~CPCCertContext() { if (m_pCert) CertFreeCertificateContext(m_pCert); }
    PCCERT_CONTEXT * operator &() { return &m_pCert; }
    operator PCCERT_CONTEXT() { return m_pCert; }
    CPCCertContext &operator =(PCCERT_CONTEXT pCert) { m_pCert = pCert; return *this; }
private:
    PCCERT_CONTEXT m_pCert;
};

//+-----------------------------------------------------------------
//
// A helper class for cleanup of a CERT_INFO structure.
//
//+-----------------------------------------------------------------

class CpCertInfo
{
private:
    CERT_INFO *m_p ;

public:
    CpCertInfo() : m_p(NULL)         {}
   ~CpCertInfo() ;

    operator CERT_INFO*() const           { return m_p; }
    CERT_INFO*  operator->() const        { return m_p; }
    CERT_INFO*  operator=(CERT_INFO* p)   { m_p = p; return m_p ; }
};

inline CpCertInfo::~CpCertInfo()
{
    if (m_p)
    {
        if (m_p->Issuer.pbData)
        {
            ASSERT(m_p->Issuer.cbData > 0) ;
            delete m_p->Issuer.pbData ;
        }
        if (m_p->Subject.pbData)
        {
            ASSERT(m_p->Subject.cbData > 0) ;
            delete m_p->Subject.pbData ;
        }
        delete m_p ;
    }
}

//+----------------------------------
//
// Some constant definitions
//
//+----------------------------------

//
// Registry where internal certificate is kept. This is a registry based
// certificates store.
//
#define MQ_INTERNAL_CERT_STORE_REG  "Software\\Microsoft\\MSMQ\\CertStore"
#define MQ_INTERNAL_CERT_STORE_LOC  TEXT(MQ_INTERNAL_CERT_STORE_REG)

//
// Validity of internal certificate.
// 8 years take leap year into account.
//
#define INTERNAL_CERT_DURATION_YEARS   8

//
// "locality" value for internal certificate.
//
#define MQ_CERT_LOCALITY            TEXT("MSMQ")
#define MQ_CERT_LOCALITY_A          "MSMQ"

//
// Name of container for public/private key of internal certificate.
// Different name if internal certificate created from a LocalSystem service.
//
#define MSMQ_INTCRT_KEY_CONTAINER_W            L"MSMQ"
#define MSMQ_INTCRT_KEY_CONTAINER_A             "MSMQ"
#define MSMQ_SERVICE_INTCRT_KEY_CONTAINER_A     "MSMQ_SERVICE"
#define MSMQ_SERVICE_INTCRT_KEY_CONTAINER_W    L"MSMQ_SERVICE"

#define MAX_MESSAGE_SIGNATURE_SIZE     128 // bytes
#define MAX_MESSAGE_SIGNATURE_SIZE_EX  256 // bytes

//
// Default algorithems.
//
#define PROPID_M_DEFUALT_HASH_ALG       CALG_SHA1
#define PROPID_M_DEFUALT_ENCRYPT_ALG    CALG_RC2

#endif //_MQCRYPT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\mqencryp.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    mqencryp.h

Abstract:

    Definitions used for encryption.

Author:

    Doron Juster  (DoronJ)   19-Nov-98  Created

--*/

#include <wincrypt.h>
//
// Define constants for the SDK mq.h file.
//
#define MQMSG_PRIV_BASE_PROVIDER     \
                        L"Microsoft Base Cryptographic Provider v1.0" ;
#define MQMSG_PRIV_ENHANCED_PROVIDER \
                        L"Microsoft Enhanced Cryptographic Provider v1.0" ;

//
// The following structures are used to store machine public keys in the DS.
// Each machine may store multiple keys, for multiple providers.
// The structure are only headers and skeleton, as all data is of variable
// length and it's serialized.
//

typedef struct _mqdsPublicKey
{
    ULONG    ulKeyLen ;
    ULONG    ulProviderLen ;  // provider name, including terminator, in bytes
    ULONG    ulProviderType ; // provider type.
    DWORD    aBuf[1] ;        // buffer for key and provider.
                              // first provider, then key.
                              // DWORD, for alignment.
} MQDSPUBLICKEY ;

#define SIZEOF_MQDSPUBLICKEY (sizeof(MQDSPUBLICKEY) - sizeof(DWORD))

typedef struct _mqdsPublicKeys
{
    ULONG          ulLen ;   // len of the whole structure.
    ULONG          cNumofKeys ;
    MQDSPUBLICKEY  aPublicKeys[1] ;
} MQDSPUBLICKEYS ;

#define SIZEOF_MQDSPUBLICKEYS \
                 (sizeof(MQDSPUBLICKEYS) - sizeof(MQDSPUBLICKEY))

//
// Define the MSMQ default encryption providers
//
// Base provider, 40 bits
//
const WCHAR x_MQ_Encryption_Provider_40[] = MQMSG_PRIV_BASE_PROVIDER ;
const DWORD x_MQ_Encryption_Provider_40_len =
                 sizeof( x_MQ_Encryption_Provider_40 ) / sizeof(WCHAR) ;

const DWORD x_MQ_Encryption_Provider_Type_40 = PROV_RSA_FULL ;
const DWORD x_MQ_Block_Size_40  = 8 ;
const DWORD x_MQ_SymmKeySize_40 = 0x4C ;

//
// Enhanced provider, 128 bits
//
const WCHAR x_MQ_Encryption_Provider_128[] = MQMSG_PRIV_ENHANCED_PROVIDER ;
const DWORD x_MQ_Encryption_Provider_128_len =
                 sizeof( x_MQ_Encryption_Provider_128 ) / sizeof(WCHAR) ;

const DWORD x_MQ_Encryption_Provider_Type_128 = PROV_RSA_FULL ;
const DWORD x_MQ_Block_Size_128  =  8 ;
const DWORD x_MQ_SymmKeySize_128 =  0x8C ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\mqexcept.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:
    mqexcept.h

    Header file for the structured exceptions wrapper class. The class generates
    reports in the application log about exceptions that occures while the QM is
    running.

Author:

    Boaz Feldbaum (BoazF) 26-Mar-1996.

--*/

#ifndef _MQEXCEPT_H_
#define _MQEXCEPT_H_

#ifdef _MQUTIL
#define MQUTIL_EXPORT  DLL_EXPORT
#else
#define MQUTIL_EXPORT  DLL_IMPORT
#endif
/*
// The number of stack DWORDs dumped into the applcaiton log.
#define STACK_DUMP_SIZE     24

class MQUTIL_EXPORT MQException
{
public:
    MQException(unsigned int u,  _EXCEPTION_POINTERS* pExp);
    MQException( MQException& );
    ~MQException();
    void ReportException(WORD wCategory, LPCTSTR pszFunction);

private:
    unsigned int m_iExceptionCode;
    DWORD m_nExceptionRecords;
    DWORD m_nExceptionRecordsBuffSize;
    BYTE *m_pExceptionRecords;
#ifdef _M_IX86
    DWORD m_StackDump[STACK_DUMP_SIZE];
#endif
    CONTEXT m_Context;
    BOOL m_bValid;
};
MQUTIL_EXPORT
void
MQInstallExceptionsTranslator();

MQUTIL_EXPORT
void
MQUnInstallExceptionsTranslator();
*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\mqf2format.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:
    mqf2format.h

Abstract:
    Convert a QUEUE_FORMATs to FORMAT_NAME string

Author:
    Ilan Herbst (ilanh) 03-Nov-2000


--*/

#ifndef __MQF2FORMAT_H
#define __MQF2FORMAT_H

#include <wchar.h>
#include <mqformat.h>
#include <fntoken.h>

inline
bool
MQpGetMqfProperty(
    const QUEUE_FORMAT*	pqf,
	ULONG				nMqf,
    ULONG*				pLength,
    WCHAR*				pUserBuffer
    )
/*++
Routine Description:
	Get FormatName string representation of mqf.
	If pUserBuffer is NULL, the function will return the needed length
	and MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL.
	This will be also the case if pUserBuffer is not NULL but to small.
	in that case this function will raise ASSERT

Arguments:
	pqf - pointer to QUEUE_FORMAT array
	nMqf - pqf size
    pLength - in/out, *ppUserBuffer string length in WCHARs on input, actual length on output.
	pUserBuffer - FormatName string buffer. can be NULL for getting needed length.

Returned Value:
	HRESULT

--*/
{
	ASSERT(pqf != NULL);
	ASSERT(nMqf > 0);
	ASSERT(pLength != NULL);

    ULONG BufferLength = 0;
    if(pUserBuffer != NULL)
    {
		BufferLength = *pLength;
	}
	*pLength = 0;

	HRESULT hr = MQ_OK;
    for ( ; nMqf-- != 0; ++pqf)
    {
	    ASSERT(pqf->GetType() != QUEUE_FORMAT_TYPE_UNKNOWN);

		bool fLastElement = (nMqf == 0);

        //
        // Add next queue format to string
        //
        ULONG Length = 0;
		hr = MQpQueueFormatToFormatName(
					pqf,
					pUserBuffer,
					BufferLength,
					&Length,
					!fLastElement
					);

		ASSERT(SUCCEEDED(hr) || 
			   ((pUserBuffer == NULL) && (hr == MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL)));

        //
        // Dont count the null terminator right after it
        //
        if (!fLastElement)
        {
            --Length;
        }

        //
        // Update required length, remaining length, and pointer in buffer
        //
        *pLength += Length;
        if(pUserBuffer != NULL)
        {
			if(BufferLength < Length)
			{
				ASSERT(("Buffer Length is to small", BufferLength >= Length));
				BufferLength = 0;
			}
			else
			{
				BufferLength -= Length;
				pUserBuffer += Length;
			}
        }
    }

    return (hr == MQ_OK);

} // MQpGetMqfProperty


inline
LPWSTR
MQpMqfToFormatName(
    const QUEUE_FORMAT *	pqf,
	ULONG					nMqf,
    ULONG *					pLength
    )
/*++
Routine Description:
	Get FormatName string representation of mqf.
	This function allocate the FormatName string buffer
	that need to be free by the caller.

Arguments:
	pqf - pointer to QUEUE_FORMAT array
	nMqf - pqf size
    pLength - in\out, *ppUserBuffer string length in WCHARs on input, actual length on output.
	ppUserBuffer - output, pointer to the allocated FormatName string buffer.

Returned Value:
	HRESULT

--*/
{
	ASSERT(pqf != NULL);
	ASSERT(nMqf > 0);
	ASSERT(pLength != NULL);

	//
	// Get Buffer Length
	//

	bool fSuccess = MQpGetMqfProperty(
						pqf, 
						nMqf, 
						pLength, 
						NULL
						);

	ASSERT(!fSuccess);
	ASSERT(*pLength > 0);

	//
	// Get FormatName string
	//
	AP<WCHAR> pFormatName = new WCHAR[*pLength];
	fSuccess = MQpGetMqfProperty(
					pqf, 
					nMqf, 
					pLength, 
					pFormatName.get()
					);

	ASSERT(fSuccess);

	return pFormatName.detach();
}  // MQpMqfToFormatName


#endif //  __MQF2FORMAT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\mqfutils.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:
    mqfutils.h

Abstract:
    Mqf utils functions

Author:
    Ilan Herbst (ilanh) 05-Nov-2000


--*/

#ifndef __MQFUTILS_H
#define __MQFUTILS_H

#include <qformat.h>
#include <acdef.h>


inline
void
MQpMqf2SingleQ(
    ULONG nMqf,
    const QUEUE_FORMAT mqf[],
    QUEUE_FORMAT * * ppQueueFormat
    )
/*++

Routine Description:

    Map multi queue format to old style single queue format.

    Mapping algorithm:

      * If no elements in the MQF, no mapping.
      * If first element in the MQF can be mapped (e.g. not of type DL=), it is
        copied onto the specified buffer.
      * Otherwise, no mapping.


Arguments:

    nMqf          - Number of queue format elements in the MQF. May be 0.

    mqf           - Array of queue formats.

    ppQueueFormat - Pointer to pointer to old style single queue format.
                    On input, points to pointer to queue format buffer.
                    On output, if mapping succeeds, buffer contains  old style
                    queue format; if mapping fails, pointer to NULL
                    pointer.

Return Value:

    None.

--*/
{
    ASSERT(("Must have a valid pointer to pointer", ppQueueFormat  != NULL));
    ASSERT(("Must have a valid pointer", *ppQueueFormat != NULL));

    //
    // No elements in MQF, no mapping.
    //
    if (nMqf == 0)
    {
        *ppQueueFormat = NULL;
        return;
    }

    //
    // Map the first element in the MQF, if it's a single queue.
    //
    if (mqf[0].GetType() != QUEUE_FORMAT_TYPE_DL &&
        mqf[0].GetType() != QUEUE_FORMAT_TYPE_MULTICAST)
    {
        **ppQueueFormat = mqf[0];
        return;
    }

    //
    // No mapping
    //
    *ppQueueFormat = NULL;

} // MQpMqf2SingleQ


inline
bool
MQpNeedDestinationMqfHeader(
    const QUEUE_FORMAT        DestinationMqf[],
    ULONG                     nDestinationMqf
    )
/*++

Routine Description:

    Check if this packet needs to include MQF headers.

Arguments:

    DestinationMqf  - Array of destination queue formats.

    nDestinationMqf - Number of entries in array. Minimum is 1.

Return Value:

    true - need Destination MQF header.
    false - don't need Destination MQF header.

--*/
{
    ASSERT(nDestinationMqf >= 1);
    if (nDestinationMqf > 1)
    {
        //
        // Multiple destinations
        //
        return true;
    }

    if (DestinationMqf[0].GetType() == QUEUE_FORMAT_TYPE_DL)
    {
        //
        // Destination is a DL
        //
        return true;
    }

    return false;

} // MQpNeedDestinationMqfHeader


inline
bool
MQpNeedMqfHeaders(
    const QUEUE_FORMAT        DestinationMqf[],
    ULONG                     nDestinationMqf,
    const CACSendParameters * pSendParams
    )
/*++

Routine Description:

    Check if this packet needs to include MQF headers.

Arguments:

    DestinationMqf  - Array of destination queue formats.

    nDestinationMqf - Number of entries in array. Minimum is 1.

    pSendParameters - Pointer to send parameters structure.

Return Value:

    true - MQF headers need to be included on this packet.
    false - MQF headers do not need to be included on this packet.

--*/
{
	if(MQpNeedDestinationMqfHeader(DestinationMqf, nDestinationMqf))
	{
		return true;
	}

    if (pSendParams->nAdminMqf > 1)
    {
        //
        // Multiple admin queues
        //
        return true;
    }

    if (pSendParams->nAdminMqf == 1 &&
        pSendParams->AdminMqf[0].GetType() == QUEUE_FORMAT_TYPE_DL)
    {
        //
        // Admin is a DL
        //
        return true;
    }

    if (pSendParams->nResponseMqf > 1)
    {
        //
        // Multiple Response queues
        //
        return true;
    }

    if (pSendParams->nResponseMqf == 1 &&
        pSendParams->ResponseMqf[0].GetType() == QUEUE_FORMAT_TYPE_DL)
    {
        //
        // Response is a DL
        //
        return true;
    }

    return false;

} // MQpNeedMqfHeaders


#endif //  __MQFUTILS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\mqformat.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:
    mqformat.h

Abstract:
    Convert a QUEUE_FORMAT struc to FORMAT_NAME string

Author:
    Boaz Feldbaum (BoazF) 5-Mar-1996

Revision History:
    Erez Haba (erezh) 12-Mar-1996
    Erez Haba (erezh) 17-Jan-1997

--*/

#ifndef __MQFORMAT_H
#define __MQFORMAT_H

#include <wchar.h>
#include <qformat.h>
#include <fntoken.h>

#if !defined(NTSTATUS) && !defined(_NTDEF_)
#define NTSTATUS HRESULT
#endif


inline
ULONG
MQpPublicToFormatName(
    const QUEUE_FORMAT* pqf,
    LPCWSTR pSuffix,
    ULONG buff_size,
    LPWSTR pfn
    )
{
    ASSERT(pqf->GetType() == QUEUE_FORMAT_TYPE_PUBLIC);

    const GUID* pg = &pqf->PublicID();

    _snwprintf(
        pfn,
        buff_size,
        FN_PUBLIC_TOKEN // "PUBLIC"
        FN_EQUAL_SIGN   // "="
        GUID_FORMAT     // "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
        FN_SUFFIX_FORMAT,  // "%s"
        GUID_ELEMENTS(pg),
        pSuffix
        );
    
    //
    //  return format name buffer length *not* including suffix length
    //  "PUBLIC=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\0"
    //
    return (
        FN_PUBLIC_TOKEN_LEN + 1 +
        GUID_STR_LENGTH +  1
        );
} // MQpPublicToFormatName


inline
ULONG
MQpDlToFormatName(
    const QUEUE_FORMAT* pqf,
    ULONG buff_size,
    LPWSTR pfn
    )
{
    ASSERT(pqf->GetType() == QUEUE_FORMAT_TYPE_DL);

    const DL_ID id = pqf->DlID();
    const GUID * pguid = &id.m_DlGuid;

    if (id.m_pwzDomain != NULL)
    {
        _snwprintf(
            pfn,
            buff_size,
            FN_DL_TOKEN         // "DL"
            FN_EQUAL_SIGN       // "="
            GUID_FORMAT         // "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
            FN_AT_SIGN          // "@"
            FN_DOMAIN_FORMAT,   // "%s"
            GUID_ELEMENTS(pguid),
            id.m_pwzDomain
            );

        //
        //  return format name buffer length
        //  "DL=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx@DomainName\0"
        //
        return static_cast<ULONG>(
            FN_DL_TOKEN_LEN + 1 +
            GUID_STR_LENGTH + 1 +
            wcslen(id.m_pwzDomain) + 1
            );
    }

    _snwprintf(
        pfn,
        buff_size,
        FN_DL_TOKEN         // "DL"
        FN_EQUAL_SIGN       // "="
        GUID_FORMAT,        // "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
        GUID_ELEMENTS(pguid)
        );
    
    //
    //  return format name buffer length
    //  "DL=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\0"
    //
    return (
        FN_DL_TOKEN_LEN + 1 +
        GUID_STR_LENGTH + 1
        );
} // MQpDlToFormatName


inline
ULONG
MQpPrivateToFormatName(
    const QUEUE_FORMAT* pqf,
    LPCWSTR pSuffix,
    ULONG buff_size,
    LPWSTR pfn
    )
{
    ASSERT(pqf->GetType() == QUEUE_FORMAT_TYPE_PRIVATE);

    const GUID* pg = &pqf->PrivateID().Lineage;

    _snwprintf(
        pfn,
        buff_size,
        FN_PRIVATE_TOKEN        // "PRIVATE"
        FN_EQUAL_SIGN           // "="
        GUID_FORMAT             // "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
        FN_PRIVATE_SEPERATOR    // "\\"
        FN_PRIVATE_ID_FORMAT       // "xxxxxxxx"
        FN_SUFFIX_FORMAT,          // "%s"
        GUID_ELEMENTS(pg),
        pqf->PrivateID().Uniquifier,
        pSuffix
        );
    
    //
    //  return format name buffer length *not* including suffix length
    //  "PRIVATE=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\\xxxxxxxx\0"
    //
    return (
        FN_PRIVATE_TOKEN_LEN + 1 + 
        GUID_STR_LENGTH + 1 + 8 + 1
        );
} // MQpPrivateToFormatName


inline
ULONG
MQpDirectToFormatName(
    const QUEUE_FORMAT* pqf,
    LPCWSTR pSuffix,
    ULONG buff_size,
    LPWSTR pfn
    )
{
    ASSERT(pqf->GetType() == QUEUE_FORMAT_TYPE_DIRECT);

    _snwprintf(
        pfn,
        buff_size,
        FN_DIRECT_TOKEN     // "DIRECT"
            FN_EQUAL_SIGN   // "="
            L"%s"           // "OS:bla-bla"
            FN_SUFFIX_FORMAT,  // "%s"
        pqf->DirectID(),
        pSuffix
        );

    //
    //  return format name buffer length *not* including suffix length
    //  "DIRECT=OS:bla-bla\0"
    //
    return static_cast<ULONG>(
        FN_DIRECT_TOKEN_LEN + 1 +
        wcslen(pqf->DirectID()) + 1
        );
} // MQpDirectToFormatName


inline
ULONG
MQpMachineToFormatName(
    const QUEUE_FORMAT* pqf,
    LPCWSTR pSuffix,
    ULONG buff_size,
    LPWSTR pfn
    )
{
    ASSERT(pqf->GetType() == QUEUE_FORMAT_TYPE_MACHINE);

    const GUID* pg = &pqf->MachineID();
    _snwprintf(
        pfn,
        buff_size,
        FN_MACHINE_TOKEN    // "MACHINE"
            FN_EQUAL_SIGN   // "="
            GUID_FORMAT     // "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
            FN_SUFFIX_FORMAT,  // "%s"
        GUID_ELEMENTS(pg),
        pSuffix
        );

    //
    //  return format name buffer length *not* including suffix length
    //  "MACHINE=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\0"
    //
    return (
        FN_MACHINE_TOKEN_LEN + 1 +
        GUID_STR_LENGTH + 1
        );
} // MQpMachineToFormatName


inline
ULONG
MQpConnectorToFormatName(
    const QUEUE_FORMAT* pqf,
    LPCWSTR pSuffix,
    ULONG buff_size,
    LPWSTR pfn
    )
{
    ASSERT(pqf->GetType() == QUEUE_FORMAT_TYPE_CONNECTOR);

    const GUID* pg = &pqf->ConnectorID();
    _snwprintf(
        pfn,
        buff_size,
        FN_CONNECTOR_TOKEN  // "CONNECTOR"
            FN_EQUAL_SIGN   // "="
            GUID_FORMAT     // "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
            FN_SUFFIX_FORMAT,  // "%s"
        GUID_ELEMENTS(pg),
        pSuffix
        );

    //
    //  return format name buffer length *not* including suffix length
    //  "CONNECTOR=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\0"
    //
    return (
        FN_CONNECTOR_TOKEN_LEN + 1 +
        GUID_STR_LENGTH + 1
        );
} // MQpConnectorToFormatName


inline
VOID
MQpMulticastIdToString(
    const MULTICAST_ID& id,
    LPWSTR pBuffer
    )
/*++

Routine Description:

    Serialize MULTICAST_ID struct into a string.
    We cannot call inet_addr in this module since it compiles in kernel mode.

Arguments:

    id - Reference to MULTICAST_ID struct.

    pBuffer - Points to buffer to hold string. Buffer size must be at least MAX_PATH wchars.

Returned Value:

    None.

--*/
{
    swprintf(
        pBuffer, 
        L"%d.%d.%d.%d:%d", 
        (id.m_address & 0x000000FF),
        (id.m_address & 0x0000FF00) >> 8, 
        (id.m_address & 0x00FF0000) >> 16,
        (id.m_address & 0xFF000000) >> 24,
        id.m_port
        );
} // MQpMulticastIdToString


inline
ULONG
MQpMulticastToFormatName(
    const QUEUE_FORMAT* pqf,
    ULONG buff_size,
    LPWSTR pfn
    )
{
    ASSERT(pqf->GetType() == QUEUE_FORMAT_TYPE_MULTICAST);

    WCHAR buffer[260];
    MQpMulticastIdToString(pqf->MulticastID(), buffer);

    _snwprintf(
        pfn,
        buff_size,
        FN_MULTICAST_TOKEN  // "MULTICAST"
        FN_EQUAL_SIGN       // "="
        L"%s",              // "%s"
        buffer
        );
    
    //
    //  return format name buffer length
    //  "MULTICAST=a.b.c.d:p\0"
    //
    return static_cast<ULONG>(
        FN_MULTICAST_TOKEN_LEN + 1 +
        wcslen(buffer) + 1
        );
} // MQpMulticastToFormatName


//
// Convert a QUEUE_FORMAT union to a format name string.
//
inline
NTSTATUS
MQpQueueFormatToFormatName(
    const QUEUE_FORMAT* pqf,    // queue format to translate
    LPWSTR pfn,                 // lpwcsFormatName format name buffer
    ULONG buff_size,            // format name buffer size
    PULONG pulFormatNameLength, // required buffer lenght of format name
    bool fSerializeMqfSeperator // serialize an MQF seperator on the buffer
    )
{
	if(static_cast<long>(buff_size * 2) < 0)
		return MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL;

    //
    //  Sanity check
    //
    ASSERT(pqf->IsValid());

    const LPCWSTR suffixes[] = {
        FN_NONE_SUFFIX,
        FN_JOURNAL_SUFFIX,
        FN_DEADLETTER_SUFFIX,
        FN_DEADXACT_SUFFIX,
        FN_XACTONLY_SUFFIX,
    };

    const ULONG suffixes_len[] = {
        FN_NONE_SUFFIX_LEN,
        FN_JOURNAL_SUFFIX_LEN,
        FN_DEADLETTER_SUFFIX_LEN,
        FN_DEADXACT_SUFFIX_LEN,
        FN_XACTONLY_SUFFIX_LEN,
    };


    ULONG fn_size = suffixes_len[pqf->Suffix()];
    LPCWSTR pSuffix = suffixes[pqf->Suffix()];
    if (fSerializeMqfSeperator)
    {
        //
        // MQF element should not have suffix.
        //
        ASSERT(pqf->Suffix() == QUEUE_SUFFIX_TYPE_NONE);

        //
        // Set the MQF separator as suffix
        //
        fn_size = STRLEN(FN_MQF_SEPARATOR);
        pSuffix = FN_MQF_SEPARATOR;
    }


    switch(pqf->GetType())
    {
        case QUEUE_FORMAT_TYPE_PUBLIC:
            fn_size += MQpPublicToFormatName(pqf, pSuffix, buff_size, pfn);
            break;

        case QUEUE_FORMAT_TYPE_DL:
            fn_size += MQpDlToFormatName(pqf, buff_size, pfn);
            break;

        case QUEUE_FORMAT_TYPE_PRIVATE:
            fn_size += MQpPrivateToFormatName(pqf, pSuffix, buff_size, pfn);
            break;

        case QUEUE_FORMAT_TYPE_DIRECT:
            fn_size += MQpDirectToFormatName(pqf, pSuffix, buff_size, pfn);
            break;

        case QUEUE_FORMAT_TYPE_MACHINE:
            ASSERT(("This type cannot be an MQF element", !fSerializeMqfSeperator));
            fn_size += MQpMachineToFormatName(pqf, pSuffix, buff_size, pfn);
            break;

        case QUEUE_FORMAT_TYPE_CONNECTOR:
            ASSERT(("This type cannot be an MQF element", !fSerializeMqfSeperator));
            fn_size += MQpConnectorToFormatName(pqf, pSuffix, buff_size, pfn);
            break;

        case QUEUE_FORMAT_TYPE_MULTICAST:
            ASSERT(pqf->Suffix() == QUEUE_SUFFIX_TYPE_NONE);
            fn_size += MQpMulticastToFormatName(pqf, buff_size, pfn);
            break;

        default:
            //
            //  ASSERT(0) with no level 4 warning
            //
            ASSERT(pqf->GetType() == QUEUE_FORMAT_TYPE_DIRECT);
    }

    *pulFormatNameLength = fn_size;
    if(buff_size < fn_size)
    {
        //
        //  put a null terminator, and indicate buffer too small
        //
        if(buff_size > 0)
        {
            pfn[buff_size - 1] = 0;
        }
        return MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL;
    }

    return MQ_OK;
}

#endif //  __MQFORMAT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\mqlog.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    mqlog.h

Abstract:

    Functions definitions for error logging in all bits (release, checked, debug).

Author:

    AlexDad   18-July-99  Created

--*/

#ifndef __MQLOG_H
#define __MQLOG_H

#define NTSTATUS HRESULT
#define STATUS_SUCCESS                          ((NTSTATUS)0x00000000L) // ntsubauth

//
// Error logging functions
//
extern void LogMsgHR(        HRESULT hr,        LPWSTR wszFileName, USHORT point);
extern void LogMsgNTStatus(  NTSTATUS status,   LPWSTR wszFileName, USHORT point);
extern void LogMsgRPCStatus( RPC_STATUS status, LPWSTR wszFileName, USHORT point);
extern void LogMsgBOOL(      BOOL b,            LPWSTR wszFileName, USHORT point);
extern void LogIllegalPoint(                       LPWSTR wszFileName, USHORT point);

// Following inline functions are optimized to take minimum space - there is a lot of calls 
inline HRESULT LogHR(HRESULT hr, PWCHAR pwszFileName, USHORT usPoint)
{
    if (FAILED(hr))
    {
        LogMsgHR(hr, pwszFileName, usPoint);
    }
    return hr;
}

inline NTSTATUS LogNTStatus(NTSTATUS status, PWCHAR pwszFileName, USHORT usPoint)
{
    if (status != STATUS_SUCCESS)
    {
        LogMsgNTStatus(status, pwszFileName, usPoint);
    }
    return status;
}

inline RPC_STATUS LogRPCStatus(RPC_STATUS status, PWCHAR pwszFileName, USHORT usPoint)
{
    if (status != RPC_S_OK)
    {
        LogMsgRPCStatus(status, pwszFileName, usPoint);
    }
    return status;
}

inline BOOL LogBOOL(BOOL b, PWCHAR pwszFileName, USHORT usPoint)
{
    if (!b)
    {
        LogMsgBOOL(b, pwszFileName, usPoint);
    }
    return b;
}

#endif  // __MQLOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\mqperf.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    mqperf.h

Abstract:

    Some common definitions used by the performance monitoring code. The
    definitions here are used both by the code that generates the performance
    data (e.g., QM), and the code that shows the data (e.g., Explorer).

Author:

    Boaz Feldbaum (BoazF)  June 30, 1996

--*/

#ifndef _MQPERF_H_
#define _MQPERF_H_

#define PERF_QUEUE_OBJECT   TEXT("MSMQ Queue")
#define PERF_SESSION_OBJECT TEXT("MSMQ Session")
#define PERF_QM_OBJECT      TEXT("MSMQ Service")
#define PERF_DS_OBJECT      TEXT("MSMQ IS")

#define PERF_OUT_HTTP_SESSION_OBJECT	L"MSMQ Outgoing HTTP Session"
#define PERF_IN_HTTP_OBJECT				L"MSMQ Incoming HTTP Messages"
#define PERF_OUT_PGM_SESSION_OBJECT		L"MSMQ Outgoing Multicast Session"
#define PERF_IN_PGM_SESSION_OBJECT		L"MSMQ Incoming Multicast Session"
// the following structures will be used to map the counter arrays returned by AddInstance

//
// QM General Counters
//
typedef struct _QmCounters
{
    ULONG   nSessions;
    ULONG   nIPSessions;
	ULONG   nOutHttpSessions;
	ULONG   nInPgmSessions;
	ULONG   nOutPgmSessions;


    ULONG   nInPackets;     // Total Incoming packets
    ULONG   tInPackets;

    ULONG   nOutPackets;    // Total Outgoing packets
    ULONG   tOutPackets;

    ULONG   nTotalPacketsInQueues;
    ULONG   nTotalBytesInQueues;
} QmCounters ;

//
// Counters per active sessions
//
typedef struct
{
    ULONG   nInPackets;
    ULONG   nOutPackets;
    ULONG   nInBytes;
    ULONG   nOutBytes;

    ULONG   tInPackets;
    ULONG   tOutPackets;
    ULONG   tInBytes;
    ULONG   tOutBytes;

} SessionCounters;


//
// Counters per active sessions
//
class COutSessionCounters
{
public:
    ULONG   nOutPackets;
    ULONG   nOutBytes;

    ULONG   tOutPackets;
    ULONG   tOutBytes;
};

//
// Counters per active sessions
//
class CInSessionCounters
{
public:
    ULONG   nInPackets;
    ULONG   nInBytes;

    ULONG   tInPackets;
    ULONG   tInBytes;
};
//
// Counters per queue
//
typedef struct
{
    ULONG   nInPackets;
    ULONG   nInBytes;
} QueueCounters;



//
// Counters for MQIS
//

typedef struct
{
    ULONG nSyncRequests;
    ULONG nSyncReplies;
    ULONG nReplReqReceived;
    ULONG nReplReqSent;
    ULONG nAccessServer;
    ULONG nWriteReqSent;
    ULONG nErrorsReturnedToApp;
} DSCounters;

#ifdef _MQIS_BLD
    extern __declspec(dllexport) DSCounters *g_pdsCounters;
#else
    extern __declspec(dllimport) DSCounters *g_pdsCounters;
#endif

#endif // _MQPERF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\mqprfsym.h ===
//
//  mqctrnm.h
//
//  Offset definition file for extensible counter objects and counters
//
//  These "relative" offsets must start at 0 and be multiples of 2 i.e.
//  even numbers. In the Open Procedure, they will be added to the
//  "First Counter" and "First Help" values for the device they belong to,
//  in order to determine the absolute location of the counter and
//  object names and corresponding Explain text in the registry.
//
//  This file is used by the extensible counter DLL code as well as the
//  counter name and Explain text definition file .INI file that is used
//  by LODCTR to load the names into the registry.
//

#define QMOBJ                   0
#define NUMSESSIONS             2
#define NUMIPSESSIONS           4
//#define NUMIPXSESSIONS          6      Entry was removed for msmq 3.0
#define NUM_OUTGOING_HTTP_SESSIONS	6
#define NUM_INCOMING_PGM_SESSIONS	8
#define NUM_OUTGOING_PGM_SESSIONS	10

#define NUMINQMPACKETS          12
#define TOTALINQMPACKETS       14
#define NUMOUTQMPACKETS        16
#define TOTALOUTQMPACKETS      18
#define TOTALPACKETSINQUEUES   20
#define TOTALBYTESINQUEUES     22


#define SESSIONOBJ             24
#define NUMSESSINPACKETS       26
#define NUMSESSOUTPACKETS      28
#define NUMSESSINBYTES         30
#define NUMSESSOUTBYTES        32
#define TOTALSESSINPACKETS     34
#define TOTALSESSINBYTES       36
#define TOTALSESSOUTPACKETS    38
#define TOTALSESSOUTBYTES      40

#define QUEUEOBJ               42
#define TOTALQUEUEINPACKETS    44
#define TOTALQUEUEINBYTES      46
#define TOTALJOURNALINPACKETS  48
#define TOTALJOURNALINBYTES    50

#define DSOBJ                       52
#define NUMOFSYNCREQUESTS           54
#define NUMOFSYNCREPLIES            56
#define NUMOFREPLREQRECV            58
#define NUMOFREPLREQSENT            60
#define NUMOFACCESSTOSRVR           62
#define NUMOFWRITEREQSENT           64
#define NUMOFERRRETURNEDTOAPP       66

#define IN_HTTP_OBJ					68
#define IN_HTTP_NUMSESSINPACKETS    70
#define IN_HTTP_NUMSESSINBYTES      72
#define IN_HTTP_TOTALSESSINPACKETS  74
#define IN_HTTP_TOTALSESSINBYTES    76

#define OUT_HTTP_SESSION_OBJ		78
#define OUT_HTTP_NUMSESSOUTPACKETS	80
#define OUT_HTTP_NUMSESSOUTBYTES	82
#define OUT_HTTP_TOTALSESSOUTPACKETS 84
#define OUT_HTTP_TOTALSESSOUTBYTES   86

#define OUT_PGM_SESSION_OBJ			88
#define OUT_PGM_NUMSESSOUTPACKETS	90
#define OUT_PGM_NUMSESSOUTBYTES		92
#define OUT_PGM_TOTALSESSOUTPACKETS 94
#define OUT_PGM_TOTALSESSOUTBYTES   96

#define IN_PGM_SESSION_OBJ			98
#define IN_PGM_NUMSESSINPACKETS     100
#define IN_PGM_NUMSESSINBYTES       102
#define IN_PGM_TOTALSESSINPACKETS   104
#define IN_PGM_TOTALSESSINBYTES     106
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\mqprops.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    mqprops.h

Abstract:

    Falcon Properties

--*/

#ifndef __MQPROPS_H
#define __MQPROPS_H

#include <mqdsdef.h>

// begin_mq_h


//********************************************************************
//  API FLAGS
//********************************************************************

//
//  MQOpenQueue - Access values
//
#define MQ_RECEIVE_ACCESS       0x00000001
#define MQ_SEND_ACCESS          0x00000002
#define MQ_PEEK_ACCESS          0x00000020
#define MQ_ADMIN_ACCESS         0x00000080

//
//  MQOpenQueue - Share values
//
#define MQ_DENY_NONE            0x00000000
#define MQ_DENY_RECEIVE_SHARE   0x00000001

//
//  MQReceiveMessage - Action values
//
#define MQ_ACTION_RECEIVE       0x00000000
// end_mq_h
#define MQ_ACTION_PEEK_MASK     0x80000000  // indicate a peek operation
// begin_mq_h
#define MQ_ACTION_PEEK_CURRENT  0x80000000
#define MQ_ACTION_PEEK_NEXT     0x80000001

//
//  MQReceiveMessageByLookupId - Action values
//
// end_mq_h
#define MQ_LOOKUP_MASK            0x40000000
#define MQ_LOOKUP_PEEK_MASK       0x40000010
#define MQ_LOOKUP_RECEIVE_MASK    0x40000020
// begin_mq_h
#define MQ_LOOKUP_PEEK_CURRENT    0x40000010
#define MQ_LOOKUP_PEEK_NEXT       0x40000011
#define MQ_LOOKUP_PEEK_PREV       0x40000012
#define MQ_LOOKUP_PEEK_FIRST      0x40000014
#define MQ_LOOKUP_PEEK_LAST       0x40000018

#define MQ_LOOKUP_RECEIVE_CURRENT 0x40000020
#define MQ_LOOKUP_RECEIVE_NEXT    0x40000021
#define MQ_LOOKUP_RECEIVE_PREV    0x40000022
#define MQ_LOOKUP_RECEIVE_FIRST   0x40000024
#define MQ_LOOKUP_RECEIVE_LAST    0x40000028
// end_mq_h



#define PRIVATE_QUEUE_PATH_INDICATIOR L"PRIVATE$\\"
#define PRIVATE_QUEUE_PATH_INDICATIOR_LENGTH \
    STRLEN(PRIVATE_QUEUE_PATH_INDICATIOR)

#define SYSTEM_QUEUE_PATH_INDICATIOR L"SYSTEM$"
#define SYSTEM_QUEUE_PATH_INDICATIOR_LENGTH \
    STRLEN(SYSTEM_QUEUE_PATH_INDICATIOR)

#define PN_DELIMITER_C      L'\\'
#define PN_LOCAL_MACHINE_C  L'.'

#define ORDER_QUEUE_PRIVATE_INDEX      4
// begin_mq_h

//
// MQSendMessage,  MQReceiveMessage:  special cases for the transaction parameter
//
#define MQ_NO_TRANSACTION             NULL
#define MQ_MTS_TRANSACTION            (ITransaction *)1
#define MQ_XA_TRANSACTION             (ITransaction *)2
#define MQ_SINGLE_MESSAGE             (ITransaction *)3

//********************************************************************
//  PRIORITY LIMITS
//********************************************************************

//
//  Message priorities
//
#define MQ_MIN_PRIORITY          0    // Minimal message priority
#define MQ_MAX_PRIORITY          7    // Maximal message priority


//********************************************************************
//  MESSAGE PROPERTIES
//********************************************************************
#define PROPID_M_BASE					 0
#define PROPID_M_CLASS                   (PROPID_M_BASE + 1)     /* VT_UI2           */
#define PROPID_M_MSGID                   (PROPID_M_BASE + 2)     /* VT_UI1|VT_VECTOR */
#define PROPID_M_CORRELATIONID           (PROPID_M_BASE + 3)     /* VT_UI1|VT_VECTOR */
#define PROPID_M_PRIORITY                (PROPID_M_BASE + 4)     /* VT_UI1           */
#define PROPID_M_DELIVERY                (PROPID_M_BASE + 5)     /* VT_UI1           */
#define PROPID_M_ACKNOWLEDGE             (PROPID_M_BASE + 6)     /* VT_UI1           */
#define PROPID_M_JOURNAL                 (PROPID_M_BASE + 7)     /* VT_UI1           */
#define PROPID_M_APPSPECIFIC             (PROPID_M_BASE + 8)     /* VT_UI4           */
#define PROPID_M_BODY                    (PROPID_M_BASE + 9)     /* VT_UI1|VT_VECTOR */
#define PROPID_M_BODY_SIZE               (PROPID_M_BASE + 10)    /* VT_UI4           */
#define PROPID_M_LABEL                   (PROPID_M_BASE + 11)    /* VT_LPWSTR        */
#define PROPID_M_LABEL_LEN               (PROPID_M_BASE + 12)    /* VT_UI4           */
#define PROPID_M_TIME_TO_REACH_QUEUE     (PROPID_M_BASE + 13)    /* VT_UI4           */
#define PROPID_M_TIME_TO_BE_RECEIVED     (PROPID_M_BASE + 14)    /* VT_UI4           */
#define PROPID_M_RESP_QUEUE              (PROPID_M_BASE + 15)    /* VT_LPWSTR        */
#define PROPID_M_RESP_QUEUE_LEN          (PROPID_M_BASE + 16)    /* VT_UI4           */
#define PROPID_M_ADMIN_QUEUE             (PROPID_M_BASE + 17)    /* VT_LPWSTR        */
#define PROPID_M_ADMIN_QUEUE_LEN         (PROPID_M_BASE + 18)    /* VT_UI4           */
#define PROPID_M_VERSION                 (PROPID_M_BASE + 19)    /* VT_UI4           */
#define PROPID_M_SENDERID                (PROPID_M_BASE + 20)    /* VT_UI1|VT_VECTOR */
#define PROPID_M_SENDERID_LEN            (PROPID_M_BASE + 21)    /* VT_UI4           */
#define PROPID_M_SENDERID_TYPE           (PROPID_M_BASE + 22)    /* VT_UI4           */
#define PROPID_M_PRIV_LEVEL              (PROPID_M_BASE + 23)    /* VT_UI4           */
#define PROPID_M_AUTH_LEVEL              (PROPID_M_BASE + 24)    /* VT_UI4           */
#define PROPID_M_AUTHENTICATED           (PROPID_M_BASE + 25)    /* VT_UI1           */
#define PROPID_M_HASH_ALG                (PROPID_M_BASE + 26)    /* VT_UI4           */
#define PROPID_M_ENCRYPTION_ALG          (PROPID_M_BASE + 27)    /* VT_UI4           */
#define PROPID_M_SENDER_CERT             (PROPID_M_BASE + 28)    /* VT_UI1|VT_VECTOR */
#define PROPID_M_SENDER_CERT_LEN         (PROPID_M_BASE + 29)    /* VT_UI4           */
#define PROPID_M_SRC_MACHINE_ID          (PROPID_M_BASE + 30)    /* VT_CLSID         */
#define PROPID_M_SENTTIME                (PROPID_M_BASE + 31)    /* VT_UI4           */
#define PROPID_M_ARRIVEDTIME             (PROPID_M_BASE + 32)    /* VT_UI4           */
#define PROPID_M_DEST_QUEUE              (PROPID_M_BASE + 33)    /* VT_LPWSTR        */
#define PROPID_M_DEST_QUEUE_LEN          (PROPID_M_BASE + 34)    /* VT_UI4           */
#define PROPID_M_EXTENSION               (PROPID_M_BASE + 35)    /* VT_UI1|VT_VECTOR */
#define PROPID_M_EXTENSION_LEN           (PROPID_M_BASE + 36)    /* VT_UI4           */
#define PROPID_M_SECURITY_CONTEXT        (PROPID_M_BASE + 37)    /* VT_UI4           */
#define PROPID_M_CONNECTOR_TYPE          (PROPID_M_BASE + 38)    /* VT_CLSID         */
#define PROPID_M_XACT_STATUS_QUEUE       (PROPID_M_BASE + 39)    /* VT_LPWSTR        */
#define PROPID_M_XACT_STATUS_QUEUE_LEN   (PROPID_M_BASE + 40)    /* VT_UI4           */
#define PROPID_M_TRACE                   (PROPID_M_BASE + 41)    /* VT_UI1           */
#define PROPID_M_BODY_TYPE               (PROPID_M_BASE + 42)    /* VT_UI4           */
#define PROPID_M_DEST_SYMM_KEY           (PROPID_M_BASE + 43)    /* VT_UI1|VT_VECTOR */
#define PROPID_M_DEST_SYMM_KEY_LEN       (PROPID_M_BASE + 44)    /* VT_UI4           */
#define PROPID_M_SIGNATURE               (PROPID_M_BASE + 45)    /* VT_UI1|VT_VECTOR */
#define PROPID_M_SIGNATURE_LEN           (PROPID_M_BASE + 46)    /* VT_UI4           */
#define PROPID_M_PROV_TYPE               (PROPID_M_BASE + 47)    /* VT_UI4           */
#define PROPID_M_PROV_NAME               (PROPID_M_BASE + 48)    /* VT_LPWSTR        */
#define PROPID_M_PROV_NAME_LEN           (PROPID_M_BASE + 49)    /* VT_UI4           */
#define PROPID_M_FIRST_IN_XACT           (PROPID_M_BASE + 50)    /* VT_UI1           */
#define PROPID_M_LAST_IN_XACT            (PROPID_M_BASE + 51)    /* VT_UI1           */
#define PROPID_M_XACTID                  (PROPID_M_BASE + 52)    /* VT_UI1|VT_VECTOR */
#define PROPID_M_AUTHENTICATED_EX        (PROPID_M_BASE + 53)    /* VT_UI1           */
#define PROPID_M_RESP_FORMAT_NAME        (PROPID_M_BASE + 54)    /* VT_LPWSTR        */
#define PROPID_M_RESP_FORMAT_NAME_LEN    (PROPID_M_BASE + 55)    /* VT_UI4           */
// end_mq_h

//
//Place holder for future properties. (PROPID_M_BASE + 56) and (PROPID_M_BASE + 57)
//

// begin_mq_h
#define PROPID_M_DEST_FORMAT_NAME        (PROPID_M_BASE + 58)    /* VT_LPWSTR        */
#define PROPID_M_DEST_FORMAT_NAME_LEN    (PROPID_M_BASE + 59)    /* VT_UI4           */
#define PROPID_M_LOOKUPID                (PROPID_M_BASE + 60)    /* VT_UI8           */
#define PROPID_M_SOAP_ENVELOPE			 (PROPID_M_BASE + 61)    /* VT_LPWSTR        */
#define PROPID_M_SOAP_ENVELOPE_LEN		 (PROPID_M_BASE + 62)    /* VT_UI4           */
#define PROPID_M_COMPOUND_MESSAGE		 (PROPID_M_BASE + 63)    /* VT_UI1|VT_VECTOR */
#define PROPID_M_COMPOUND_MESSAGE_SIZE	 (PROPID_M_BASE + 64)    /* VT_UI4           */
#define PROPID_M_SOAP_HEADER             (PROPID_M_BASE + 65)    /* VT_LPWSTR        */
#define PROPID_M_SOAP_BODY               (PROPID_M_BASE + 66)    /* VT_LPWSTR        */
// end_mq_h


#if PROPID_M_BASE != 0
#error PROPID_M_BASE != 0
#endif

#define LAST_M_PROPID      PROPID_M_SOAP_BODY
// begin_mq_h

//
// Message Property Size
//
#define PROPID_M_MSGID_SIZE         20
#define PROPID_M_CORRELATIONID_SIZE 20
#define PROPID_M_XACTID_SIZE        20


//********************************************************************
//  MESSAGE CLASS VALUES
//********************************************************************
//
//  Message class values are 16 bits laid out as follows:
//
//   1 1 1 1 1 1
//   5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +-+-+-+-------+-----------------+
//  |S|R|H|Reserve|   Class code    |
//  +-+-+-+-------+-----------------+
//
//  where
//
//      S - is the severity flag
//          0 - Normal Message/Positive Acknowledgment (ACK)
//          1 - Negative Acknowledgment (NACK)
//
//      R - is the receive flag
//          0 - Arrival ACK/NACK
//          1 - Receive ACK/NACK
//
//      H - is http flag
//          0 - no http
//          1 - http 

#define MQCLASS_CODE(s, r, code) ((USHORT)(((s) << 15) | ((r) << 14) | (code)))
#define MQCLASS_NACK(c)     ((c) & 0x8000)
#define MQCLASS_RECEIVE(c)  ((c) & 0x4000)

#define MQCLASS_NACK_HTTP(c) (((c) & 0xA000) == 0xA000)


// end_mq_h
#define MQCLASS_POS_ARRIVAL(c)  (((c) & 0xC000) == 0x0000)
#define MQCLASS_POS_RECEIVE(c)  (((c) & 0xC000) == 0x4000)
#define MQCLASS_NEG_ARRIVAL(c)  (((c) & 0xC000) == 0x8000)
#define MQCLASS_NEG_RECEIVE(c)  (((c) & 0xC000) == 0xC000)

#define CREATE_MQHTTP_CODE(HttpStatusCode) (0xA000 | (HttpStatusCode))


#define MQCLASS_IS_VALID(c) (!(((UINT_PTR)(c)) & ~((UINT_PTR)0xE1FF)))
// begin_mq_h

//
//  Normal message
//
#define MQMSG_CLASS_NORMAL                      MQCLASS_CODE(0, 0, 0x00)

//
//  Report message
//
#define MQMSG_CLASS_REPORT                      MQCLASS_CODE(0, 0, 0x01)

//
//  Arrival acknowledgment. The message has reached its destination queue
//
#define MQMSG_CLASS_ACK_REACH_QUEUE             MQCLASS_CODE(0, 0, 0x02)
// end_mq_h

//
//  Order acknoledgment used internally by falcon
//  BUGBUG: we can remove it and use MQMSG_CLASS_ACK_REACH_QUEUE instade (erezh)
//
#define MQMSG_CLASS_ORDER_ACK                   MQCLASS_CODE(0, 0, 0xff)
// begin_mq_h

//
//  Receive acknowledgment. The message has been received by an application
//
#define MQMSG_CLASS_ACK_RECEIVE                 MQCLASS_CODE(0, 1, 0x00)


//-----------------------------------------------
//
//  Negative arrival acknowledgments
//

//
//  Destination queue cannot be reached, the queue may have been deleted
//
#define MQMSG_CLASS_NACK_BAD_DST_Q              MQCLASS_CODE(1, 0, 0x00)

//
//  The message was purged before reaching its destination queue
//
#define MQMSG_CLASS_NACK_PURGED                 MQCLASS_CODE(1, 0, 0x01)

//
//  Time to reach queue has expired
//
#define MQMSG_CLASS_NACK_REACH_QUEUE_TIMEOUT    MQCLASS_CODE(1, 0, 0x02)

//
//  The message has exceeded the queue quota
//
#define MQMSG_CLASS_NACK_Q_EXCEED_QUOTA         MQCLASS_CODE(1, 0, 0x03)

//
//  The sender does not have send access rights to the queue.
//
#define MQMSG_CLASS_NACK_ACCESS_DENIED          MQCLASS_CODE(1, 0, 0x04)

//
//  The message hop count was exceeded
//
#define MQMSG_CLASS_NACK_HOP_COUNT_EXCEEDED     MQCLASS_CODE(1, 0, 0x05)

//
//  The message signature is bad. The message could not be authenticated.
//
#define MQMSG_CLASS_NACK_BAD_SIGNATURE          MQCLASS_CODE(1, 0, 0x06)

//
//  The message could not be decrypted.
//
#define MQMSG_CLASS_NACK_BAD_ENCRYPTION         MQCLASS_CODE(1, 0, 0x07)

//
//  The message could not be encrypted for the destination.
//
#define MQMSG_CLASS_NACK_COULD_NOT_ENCRYPT      MQCLASS_CODE(1, 0, 0x08)

//
//  The message was sent to a non-transactional queue within a transaction.
//
#define MQMSG_CLASS_NACK_NOT_TRANSACTIONAL_Q    MQCLASS_CODE(1, 0, 0x09)

//
//  The message was sent to a transactional queue not within a transaction.
//
#define MQMSG_CLASS_NACK_NOT_TRANSACTIONAL_MSG  MQCLASS_CODE(1, 0, 0x0A)

//
//  The requested crypto provider for encryption is not supported by the destination.
//
#define MQMSG_CLASS_NACK_UNSUPPORTED_CRYPTO_PROVIDER  MQCLASS_CODE(1, 0, 0x0B)


//-----------------------------------------------
//
//  Negative receive acknowledgments
//

//
//  The queue was deleted, after the message arrived
//
#define MQMSG_CLASS_NACK_Q_DELETED              MQCLASS_CODE(1, 1, 0x00)

//
//  The message was purged at the destination queue
//
#define MQMSG_CLASS_NACK_Q_PURGED               MQCLASS_CODE(1, 1, 0x01)

//
//  Time to receive has expired while the message was still in its destination queue
//  (generated by destination)
//
#define MQMSG_CLASS_NACK_RECEIVE_TIMEOUT        MQCLASS_CODE(1, 1, 0x02)

//
//  Time to receive has expired while the message was still in its local outgoing queue
//  (generated locally by sender)
//
#define MQMSG_CLASS_NACK_RECEIVE_TIMEOUT_AT_SENDER  MQCLASS_CODE(1, 1, 0x03)


//------ PROPID_M_ACKNOWLEDGE ---------------
#define MQMSG_ACKNOWLEDGMENT_NONE           0x00

#define MQMSG_ACKNOWLEDGMENT_POS_ARRIVAL    0x01
#define MQMSG_ACKNOWLEDGMENT_POS_RECEIVE    0x02
#define MQMSG_ACKNOWLEDGMENT_NEG_ARRIVAL    0x04
#define MQMSG_ACKNOWLEDGMENT_NEG_RECEIVE    0x08
// end_mq_h
#define MQMSG_ACKNOWLEDGMENT_IS_VALID(a)   (!(((UINT_PTR)(a)) & ~((UINT_PTR)0x0F)))
// begin_mq_h

#define MQMSG_ACKNOWLEDGMENT_NACK_REACH_QUEUE ((UCHAR)( \
            MQMSG_ACKNOWLEDGMENT_NEG_ARRIVAL ))

#define MQMSG_ACKNOWLEDGMENT_FULL_REACH_QUEUE ((UCHAR)( \
            MQMSG_ACKNOWLEDGMENT_NEG_ARRIVAL |  \
            MQMSG_ACKNOWLEDGMENT_POS_ARRIVAL ))

#define MQMSG_ACKNOWLEDGMENT_NACK_RECEIVE ((UCHAR)( \
            MQMSG_ACKNOWLEDGMENT_NEG_ARRIVAL |  \
            MQMSG_ACKNOWLEDGMENT_NEG_RECEIVE ))

#define MQMSG_ACKNOWLEDGMENT_FULL_RECEIVE ((UCHAR)( \
            MQMSG_ACKNOWLEDGMENT_NEG_ARRIVAL |  \
            MQMSG_ACKNOWLEDGMENT_NEG_RECEIVE |  \
            MQMSG_ACKNOWLEDGMENT_POS_RECEIVE ))
// end_mq_h
#define MQCLASS_MATCH_ACKNOWLEDGMENT(c, a) ( \
            (((a) & MQMSG_ACKNOWLEDGMENT_POS_ARRIVAL) && MQCLASS_POS_ARRIVAL(c)) || \
            (((a) & MQMSG_ACKNOWLEDGMENT_POS_RECEIVE) && MQCLASS_POS_RECEIVE(c)) || \
            (((a) & MQMSG_ACKNOWLEDGMENT_NEG_ARRIVAL) && MQCLASS_NEG_ARRIVAL(c)) || \
            (((a) & MQMSG_ACKNOWLEDGMENT_NEG_RECEIVE) && MQCLASS_NEG_RECEIVE(c)) )
// begin_mq_h

//------ PROPID_M_DELIVERY ------------------
#define MQMSG_DELIVERY_EXPRESS              0
#define MQMSG_DELIVERY_RECOVERABLE          1

//----- PROPID_M_JOURNAL --------------------
#define MQMSG_JOURNAL_NONE                  0
#define MQMSG_DEADLETTER                    1
#define MQMSG_JOURNAL                       2

//----- PROPID_M_TRACE ----------------------
#define MQMSG_TRACE_NONE                    0
#define MQMSG_SEND_ROUTE_TO_REPORT_QUEUE    1

//----- PROPID_M_SENDERID_TYPE --------------
#define MQMSG_SENDERID_TYPE_NONE            0
#define MQMSG_SENDERID_TYPE_SID             1
// end_mq_h
#define MQMSG_SENDERID_TYPE_QM              2
// begin_mq_h

//----- PROPID_M_PRIV_LEVEL -----------------
#define MQMSG_PRIV_LEVEL_NONE               0
#define MQMSG_PRIV_LEVEL_BODY               0x01
#define MQMSG_PRIV_LEVEL_BODY_BASE          0x01
#define MQMSG_PRIV_LEVEL_BODY_ENHANCED      0x03

//----- PROPID_M_AUTH_LEVEL -----------------
#define MQMSG_AUTH_LEVEL_NONE				0
#define MQMSG_AUTH_LEVEL_ALWAYS				1

//
// MQMSG_AUTH_LEVEL_MSMQxx are obsolete 
// you should use MQMSG_AUTH_LEVEL_SIGxx
//
#define MQMSG_AUTH_LEVEL_MSMQ10				2
#define MQMSG_AUTH_LEVEL_MSMQ20				4

#define MQMSG_AUTH_LEVEL_SIG10 				2
#define MQMSG_AUTH_LEVEL_SIG20 				4
#define MQMSG_AUTH_LEVEL_SIG30 				8

// end_mq_h

//
// bits 0-3 in use for MSMQ signatures
//
#define AUTH_LEVEL_MASK						((ULONG)0x0000000f)
#define IS_VALID_AUTH_LEVEL(level)			(((level) & ~AUTH_LEVEL_MASK) == 0)

//
// bits 16-31 for new signatures (http signatures)
// 
#define MQMSG_AUTH_LEVEL_XMLDSIG_V1			0x10000

// begin_mq_h

//----- PROPID_M_AUTHENTICATED -----------------
//----- PROPID_M_AUTHENTICATED_EX --------------
#define MQMSG_AUTHENTICATION_NOT_REQUESTED  0
#define MQMSG_AUTHENTICATION_REQUESTED      1

//
// MQMSG_AUTHENTICATION_REQUESTED_EX is obsolete 
// use the values MQMSG_AUTHENTICATED_SIGxx
// for PROPID_M_AUTHENTICATED_EX
//
#define MQMSG_AUTHENTICATION_REQUESTED_EX   3

#define MQMSG_AUTHENTICATED_SIG10			1
#define MQMSG_AUTHENTICATED_SIG20			3
#define MQMSG_AUTHENTICATED_SIG30			5
#define MQMSG_AUTHENTICATED_SIGXML			9


//----- PROPID_M_FIRST_IN_XACT --------------
#define MQMSG_NOT_FIRST_IN_XACT             0
#define MQMSG_FIRST_IN_XACT                 1

//----- PROPID_M_LAST_IN_XACT  --------------
#define MQMSG_NOT_LAST_IN_XACT              0
#define MQMSG_LAST_IN_XACT                  1

// end_mq_h

//------------- Default Values --------------
#define DEFAULT_M_PRIORITY                  ((MQ_MAX_PRIORITY + MQ_MIN_PRIORITY) >> 1)
#define DEFAULT_M_DELIVERY                  MQMSG_DELIVERY_EXPRESS
#define DEFAULT_M_ACKNOWLEDGE               MQMSG_ACKNOWLEDGMENT_NONE
#define DEFAULT_M_JOURNAL                   MQMSG_JOURNAL_NONE
#define DEFAULT_M_APPSPECIFIC               0
#define DEFAULT_M_PRIV_LEVEL                MQMSG_PRIV_LEVEL_NONE
#define DEFAULT_M_AUTH_LEVEL                MQMSG_AUTH_LEVEL_NONE
#define DEFAULT_M_SENDERID_TYPE             MQMSG_SENDERID_TYPE_SID

#define PPROPID_Q_BASE (PRIVATE_PROPID_BASE + PROPID_Q_BASE)

// begin_mq_h


//********************************************************************
//  QUEUE PROPERTIES
//********************************************************************
#define PROPID_Q_BASE           100
#define PROPID_Q_INSTANCE       (PROPID_Q_BASE +  1)  /* VT_CLSID     */
#define PROPID_Q_TYPE           (PROPID_Q_BASE +  2)  /* VT_CLSID     */
#define PROPID_Q_PATHNAME       (PROPID_Q_BASE +  3)  /* VT_LPWSTR    */
#define PROPID_Q_JOURNAL        (PROPID_Q_BASE +  4)  /* VT_UI1       */
#define PROPID_Q_QUOTA          (PROPID_Q_BASE +  5)  /* VT_UI4       */
#define PROPID_Q_BASEPRIORITY   (PROPID_Q_BASE +  6)  /* VT_I2        */
#define PROPID_Q_JOURNAL_QUOTA  (PROPID_Q_BASE +  7)  /* VT_UI4       */
#define PROPID_Q_LABEL          (PROPID_Q_BASE +  8)  /* VT_LPWSTR    */
#define PROPID_Q_CREATE_TIME    (PROPID_Q_BASE +  9)  /* VT_I4        */
#define PROPID_Q_MODIFY_TIME    (PROPID_Q_BASE + 10)  /* VT_I4        */
#define PROPID_Q_AUTHENTICATE   (PROPID_Q_BASE + 11)  /* VT_UI1       */
#define PROPID_Q_PRIV_LEVEL     (PROPID_Q_BASE + 12)  /* VT_UI4       */
#define PROPID_Q_TRANSACTION    (PROPID_Q_BASE + 13)  /* VT_UI1       */
// end_mq_h
#define PROPID_Q_SCOPE         (PROPID_Q_BASE + 14)   /* VT_UI1       */
#define PROPID_Q_QMID          (PROPID_Q_BASE + 15)   /* VT_CLSID     */
#define PROPID_Q_MASTERID      (PROPID_Q_BASE + 16)   /* VT_CLSID     */
#define PROPID_Q_SEQNUM        (PROPID_Q_BASE + 17)   /* VT_BLOB      */
#define PROPID_Q_HASHKEY       (PROPID_Q_BASE + 18)   /* VT_UI4       */
#define PROPID_Q_LABEL_HASHKEY (PROPID_Q_BASE + 19)   /* VT_UI4       */
#define PROPID_Q_NT4ID         (PROPID_Q_BASE + 20)   /* VT_CLSID     */
//
// Q_NT4ID is the guid of the queue on NT4 (MSMQ1.0). This is used
// for migration, to create a queue with predefined objectGUID.
//
#define PROPID_Q_FULL_PATH     (PROPID_Q_BASE + 21)   /* VT_LPWSTR    */
#define PROPID_Q_DONOTHING     (PROPID_Q_BASE + 22)   /* VT_UI1       */
//
// Q_DONOTHING is used when creating replicated object (by the replication
// service) to ignore property which are not supported by NT5 DS, like
// creation time or SeqNum. The PropId of these ones are changed to
// Q_DONOTHING before calling DSCreateObject or DSSetProps.
//
#define PROPID_Q_NAME_SUFFIX   (PROPID_Q_BASE + 23)   /* VT_LPWSTR    */
//
//  used only if queue name > cn
//

// begin_mq_h
#define PROPID_Q_PATHNAME_DNS  (PROPID_Q_BASE + 24)  /* VT_LPWSTR    */
#define PROPID_Q_MULTICAST_ADDRESS (PROPID_Q_BASE + 25)  /* VT_LPWSTR */
#define PROPID_Q_ADS_PATH      (PROPID_Q_BASE + 26)  /* VT_LPWSTR    */
// end_mq_h
#define PROPID_Q_SECURITY      (PPROPID_Q_BASE + 1)   /* VT_BLOB      */
//
//  PROPID_Q_SECURITY returns the security in NT4 format. In set or create
//  operation it can be in NT4 or NT5 format.
//
#define PROPID_Q_OBJ_SECURITY  (PPROPID_Q_BASE + 2)   /* VT_BLOB      */
//
//  PROPID_Q_OBJ_SECURTIY can be use to retrieve the security in
//  NT5 format.
//
#define PROPID_Q_SECURITY_INFORMATION  (PPROPID_Q_BASE + 3)   /* VT_UI4  */
//
//  The SECURITY_INFORMATION bitfield associated with setting or retrieving
//  security descriptor. This property is used internally by MSMQ, it's
//  not visible outside of mqsvc code.
//
#define PROPID_Q_DEFAULT_SECURITY      (PPROPID_Q_BASE + 4)   /* VT_UI4  */
//
//  see mqdssrv\dsapi.cpp, DSCreateObjectInternal for explanations about
//  PROPID_Q_DEFAULT_SECURITY.
//

#define LAST_Q_PROPID      PROPID_Q_ADS_PATH
// begin_mq_h


//----- PROPID_Q_JOURNAL ------------------
#define MQ_JOURNAL_NONE     (unsigned char)0
#define MQ_JOURNAL          (unsigned char)1

//----- PROPID_Q_TYPE ------------------
//  {55EE8F32-CCE9-11cf-B108-0020AFD61CE9}
#define MQ_QTYPE_REPORT {0x55ee8f32, 0xcce9, 0x11cf, \
                        {0xb1, 0x8, 0x0, 0x20, 0xaf, 0xd6, 0x1c, 0xe9}}

//  {55EE8F33-CCE9-11cf-B108-0020AFD61CE9}
#define MQ_QTYPE_TEST   {0x55ee8f33, 0xcce9, 0x11cf, \
                        {0xb1, 0x8, 0x0, 0x20, 0xaf, 0xd6, 0x1c, 0xe9}}

//----- PROPID_Q_TRANSACTION ------------------
#define MQ_TRANSACTIONAL_NONE     (unsigned char)0
#define MQ_TRANSACTIONAL          (unsigned char)1

//----- PROPID_Q_AUTHENTICATE ------------------
#define MQ_AUTHENTICATE_NONE      (unsigned char)0
#define MQ_AUTHENTICATE           (unsigned char)1

//----- PROPID_Q_PRIV_LEVEL ------------------
#define MQ_PRIV_LEVEL_NONE        (unsigned long)0
#define MQ_PRIV_LEVEL_OPTIONAL    (unsigned long)1
#define MQ_PRIV_LEVEL_BODY        (unsigned long)2
// end_mq_h


//----- PROPID_Q_SCOPE ------------------
#define SITE_SCOPE          (unsigned char)0
#define ENTERPRISE_SCOPE    (unsigned char)1


//------------- Default Values ----------
#define DEFAULT_Q_JOURNAL       MQ_JOURNAL_NONE
#define DEFAULT_Q_BASEPRIORITY  0

//
// Default for system private queues (order, mqis, admin)
//
#define DEFAULT_SYS_Q_BASEPRIORITY  0x7fff

#define DEFAULT_Q_QUOTA         0xFFFFFFFF
#define DEFAULT_Q_JOURNAL_QUOTA 0xFFFFFFFF
#define DEFAULT_Q_SCOPE         ENTERPRISE_SCOPE
#define DEFAULT_Q_TRANSACTION   MQ_TRANSACTIONAL_NONE
#define DEFAULT_Q_AUTHENTICATE  MQ_AUTHENTICATE_NONE
#define DEFAULT_Q_PRIV_LEVEL    MQ_PRIV_LEVEL_OPTIONAL

//
// Properties of objects can be public properties or private properties.
// Public properties of objects can be set and modified using the DS API
// Private properties of objects can be only set internally by the SD.
// In order to distinguish between private and public properties we set the
// value of the ID number of public properties to be less than 1000. Private
// properties has values higher than 1000. The hunderts number of each
// property should be equal to the value of the property identifier. This way
// we can easily associate a property ID with the object.
//
#define PRIVATE_PROPID_BASE 1000
#define PROPID_OBJ_GRANULARITY 100
#define PROPID_TO_OBJTYPE(pid) ((((pid) > PRIVATE_PROPID_BASE) ? ((pid) - PRIVATE_PROPID_BASE) : (pid)) / PROPID_OBJ_GRANULARITY)
#define IS_PRIVATE_PROPID(pid) ((pid) > PRIVATE_PROPID_BASE)

#if (PROPID_Q_BASE != (MQDS_QUEUE * PROPID_OBJ_GRANULARITY))
#error "PROPID_Q_BASE != (MQDS_QUEUE * PROPID_OBJ_GRANULARITY)"
#endif


// begin_mq_h


//********************************************************************
//  MACHINE PROPERTIES
//********************************************************************
#define PROPID_QM_BASE 200

// end_mq_h
#define PPROPID_QM_BASE (PRIVATE_PROPID_BASE + PROPID_QM_BASE)

#if (PROPID_QM_BASE != (MQDS_MACHINE * PROPID_OBJ_GRANULARITY))
#error "PROPID_QM_BASE != (MQDS_MACHINE * PROPID_OBJ_GRANULARITY)"
#endif
//
//  PROPID_QM_SITE_ID is a obsolete property ( replaced by PROPID_QM_SITE_IDS)
//  NOTE: when used in create machine, will also create computer object if there isn't one
//  =====
//
// begin_mq_h
#define PROPID_QM_SITE_ID                   (PROPID_QM_BASE +  1) /* VT_CLSID            */
#define PROPID_QM_MACHINE_ID                (PROPID_QM_BASE +  2) /* VT_CLSID            */
#define PROPID_QM_PATHNAME                  (PROPID_QM_BASE +  3) /* VT_LPWSTR           */
#define PROPID_QM_CONNECTION                (PROPID_QM_BASE +  4) /* VT_LPWSTR|VT_VECTOR */
#define PROPID_QM_ENCRYPTION_PK             (PROPID_QM_BASE +  5) /* VT_UI1|VT_VECTOR	 */
// end_mq_h
#define PROPID_QM_ADDRESS                   (PROPID_QM_BASE +  6) /* VT_BLOB             */
#define PROPID_QM_CNS                       (PROPID_QM_BASE +  7) /* VT_CLSID|VT_VECTOR  */
#define PROPID_QM_OUTFRS                    (PROPID_QM_BASE +  8) /* VT_CLSID|VT_VECTOR  */
#define PROPID_QM_INFRS                     (PROPID_QM_BASE +  9) /* VT_CLSID|VT_VECTOR  */
#define PROPID_QM_SERVICE                   (PROPID_QM_BASE + 10) /* VT_UI4              */
#define PROPID_QM_MASTERID                  (PROPID_QM_BASE + 11) /* VT_CLSID            */
#define PROPID_QM_HASHKEY                   (PROPID_QM_BASE + 12) /* VT_UI4              */
#define PROPID_QM_SEQNUM                    (PROPID_QM_BASE + 13) /* VT_BLOB             */
#define PROPID_QM_QUOTA                     (PROPID_QM_BASE + 14) /* VT_UI4              */
#define PROPID_QM_JOURNAL_QUOTA             (PROPID_QM_BASE + 15) /* VT_UI4              */
#define PROPID_QM_MACHINE_TYPE              (PROPID_QM_BASE + 16) /* VT_LPWSTR           */
#define PROPID_QM_CREATE_TIME               (PROPID_QM_BASE + 17) /* VT_I4               */
#define PROPID_QM_MODIFY_TIME               (PROPID_QM_BASE + 18) /* VT_I4               */
#define PROPID_QM_FOREIGN                   (PROPID_QM_BASE + 19) /* VT_UI1              */
#define PROPID_QM_OS                        (PROPID_QM_BASE + 20) /* VT_UI4              */
#define PROPID_QM_FULL_PATH                 (PROPID_QM_BASE + 21) /* VT_LPWSTR           */
#define PROPID_QM_SITE_IDS                  (PROPID_QM_BASE + 22) /* VT_CLSID|VT_VECTOR  */
#define PROPID_QM_OUTFRS_DN                 (PROPID_QM_BASE + 23) /* VT_LPWSTR|VT_VECTOR */
#define PROPID_QM_INFRS_DN                  (PROPID_QM_BASE + 24) /* VT_LPWSTR|VT_VECTOR */

#define PROPID_QM_NT4ID                     (PROPID_QM_BASE + 25) /* VT_CLSID            */
//
// QM_NT4ID is the guid of the QM on NT4 (MSMQ1.0). This is used
// for migration, to create a QM with predefined objectGUID.
//
#define PROPID_QM_DONOTHING                 (PROPID_QM_BASE + 26) /* VT_UI1              */
//
// QM_DONOTHING is used when creating replicated object (by the replication
// service) to ignore property which are not supported by NT5 DS, like
// creation time or SeqNum. The PropId of these ones are changed to
// QM_DONOTHING before calling DSCreateObject or DSSetProps.
//

#define PROPID_QM_SERVICE_ROUTING           (PROPID_QM_BASE + 27) /* VT_UI1             */
#define PROPID_QM_SERVICE_DSSERVER          (PROPID_QM_BASE + 28) /* VT_UI1             */
#define PROPID_QM_SERVICE_DEPCLIENTS        (PROPID_QM_BASE + 29) /* VT_UI1             */
#define PROPID_QM_OLDSERVICE                (PROPID_QM_BASE + 30) /* VT_UI4             */
// begin_mq_h
#define PROPID_QM_ENCRYPTION_PK_BASE        (PROPID_QM_BASE + 31)  /* VT_UI1|VT_VECTOR  */
#define PROPID_QM_ENCRYPTION_PK_ENHANCED    (PROPID_QM_BASE + 32)  /* VT_UI1|VT_VECTOR  */
#define PROPID_QM_PATHNAME_DNS              (PROPID_QM_BASE + 33)  /* VT_LPWSTR         */
// end_mq_h

#define PROPID_QM_OBJ_SECURITY        (PROPID_QM_BASE + 34) /* VT_BLOB           */
//
//  PROPID_QM_SECURITY returns the security in NT4 format. In set or create
//  operation it can be in NT4 or NT5 format.
//
//  PROPID_QM_OBJ_SECURTIY can be use to retrieve the security in
//  NT5 format.
//
#define PROPID_QM_MIG_GC_NAME         (PROPID_QM_BASE + 35) /* VT_LPWSTR         */
//
//  PROPID_QM_MIG_GC_NAME is the name of a GC controller in another domain.
//  This GC will create migrated objects with predefined GUIDs.
//
#define PROPID_QM_MIG_PROVIDER        (PROPID_QM_BASE + 36) /* VT_UL4            */
//
//  PROPID_QM_MIG_PROVIDER is used to save ldap queries when running
//  migration tool and replication service. See ds\mqdscore\dsmigrat.cpp
//
#define PROPID_QM_SECURITY_INFORMATION (PROPID_QM_BASE +37)  /* VT_UI4         */
//
//  The SECURITY_INFORMATION bitfield associated with setting or retrieving
//  security descriptor. This property is used internally by MSMQ, it's
//  not visible outside of mqsvc code.
//
#define PROPID_QM_ENCRYPT_PKS         (PROPID_QM_BASE + 38) /* VT_BLOB           */
#define PROPID_QM_SIGN_PKS            (PROPID_QM_BASE + 39) /* VT_BLOB           */
//
//  PROPID_QM_ENCRYPT_PKS is used to handle the new msmq2.0 format of
//  public keys: structure that pack multiple keys for multiple providers.
//  Use same DS attribute as  PROPID_QM_ENCRYPT_PK.
//  Similar for PROPID_QM_SIGN_PKS
//
#define PROPID_QM_WORKGROUP_ID        (PROPID_QM_BASE + 40) /* VT_BLOB           */
//
//  PROPID_QM_WORKGROUP_ID is the GUID of QM in workgroup mode. It's used
//  when the machine join domain and we create the msmqConfiguration object
//  with same guid.
//
#define PROPID_QM_OWNER_SID           (PROPID_QM_BASE + 41) /* VT_BLOB           */
//
//  PROPID_QM_OWNER_SID is the sid of the user that run setup. It is passed
//  from the msmq service that create the msmqConfiguration object so the
//  server add it with full control to DACL of the newly created object.
//
#define PROPID_QM_GROUP_IN_CLUSTER    (PROPID_QM_BASE + 42) /* VT_UI1            */
//
// PROPID_QM_GROUP_IN_CLUSTER tells the server that this is a msmq on group,
// in a cluster, so default security of msmqConfiguration object must allow
// everyone to create queues.
//
#define PROPID_QM_DESCRIPTION         (PROPID_QM_BASE + 43) /* VT_LPWSTR           */
//
// PROPID_QM_DESCRIPTION is used only for address replication: we change it and
// the change will be replicated to GC. Then replication service sends
// replication message with the new properties, including new machine address
//

#define PROPID_QM_SECURITY      (PPROPID_QM_BASE + 1) /* VT_BLOB             */
#define PROPID_QM_SIGN_PK       (PPROPID_QM_BASE + 2) /* VT_BLOB             */
#define PROPID_QM_ENCRYPT_PK    (PPROPID_QM_BASE + 3) /* VT_BLOB             */

#define PROPID_QM_UPGRADE_DACL  (PPROPID_QM_BASE + 4) /* VT_UI1              */
//
// PROPID_QM_UPGRADE_DACL is a dummy propid, to ask PEC to upgrade Dacl of
// calling machine.
//

#define LAST_QM_PROPID    PROPID_QM_PATHNAME_DNS

/*
 *
    Flags definition of PROPID_QM_FOREIGN
 *
 */
#define FOREIGN_MACHINE         1
#define MSMQ_MACHINE            0

//------------- Default Values ----------

#define DEFAULT_QM_QUOTA         0xFFFFFFFF
#define DEFAULT_QM_JOURNAL_QUOTA 0xFFFFFFFF
#define DEFAULT_QM_FOREIGN       MSMQ_MACHINE

/*
 *
[T] - Basic VARTYPE value of this property.
[R] - Property value may be referenced (VT_BYREF).
[N] - Property value can be retrieved without specifying basic VARTYPE
      (assigning VT_NULL instead), Falcon will assign the property
      type and will allocated memory if required.
 *
 */

/*
 *
    Old flags definition of PROPID_QM_SERVICE - we keep them for migration [adsrv]
 *
 */

#define SERVICE_NONE     ((ULONG) 0x00000000)
#define SERVICE_SRV      ((ULONG) 0x00000001)
#define SERVICE_BSC      ((ULONG) 0x00000002)
#define SERVICE_PSC      ((ULONG) 0x00000004)
#define SERVICE_PEC      ((ULONG) 0x00000008)
#define SERVICE_RCS      ((ULONG) 0x00000010)

//------------- Default Values ----------
#define DEFAULT_N_SERVICE   FALSE   // [adsrv] SERVICE_NONE

#define MSMQ_GROUP_NOT_IN_CLUSTER   0
#define MSMQ_GROUP_IN_CLUSTER       1

/*
 *
    Flags definition of PROPID_QM_OS
 *
 */
#define MSMQ_OS_NONE     ((ULONG) 0x00000000)
#define MSMQ_OS_FOREIGN  ((ULONG) 0x00000100)
#define MSMQ_OS_95       ((ULONG) 0x00000200)
#define MSMQ_OS_NTW      ((ULONG) 0x00000300)
#define MSMQ_OS_NTS      ((ULONG) 0x00000400)
#define MSMQ_OS_NTE      ((ULONG) 0x00000500)

//------------- Default Values ----------
#define DEFAULT_QM_OS   MSMQ_OS_NONE

//********************************************************************
//  SITE PROPERTIES
//********************************************************************
#define PROPID_S_BASE MQDS_SITE * PROPID_OBJ_GRANULARITY
#define PPROPID_S_BASE (PRIVATE_PROPID_BASE + PROPID_S_BASE)
/*                                                    [T]                [R] [N]*/
/*                                                  ----------------------------*/
#define PROPID_S_PATHNAME     (PROPID_S_BASE + 1)  /* VT_LPWSTR           -   + */
#define PROPID_S_SITEID       (PROPID_S_BASE + 2)  /* VT_CLSID            -   + */
#define PROPID_S_GATES        (PROPID_S_BASE + 3)  /* VT_CLSID|VT_VECTOR  -   + */
#define PROPID_S_PSC          (PROPID_S_BASE + 4)  /* VT_LPWSTR           -   + */
#define PROPID_S_INTERVAL1    (PROPID_S_BASE + 5)  /* VT_UI2              -   + */
#define PROPID_S_INTERVAL2    (PROPID_S_BASE + 6)  /* VT_UI2              -   + */
#define PROPID_S_MASTERID     (PROPID_S_BASE + 7)  /* VT_CLSID            -   + */
#define PROPID_S_SEQNUM       (PROPID_S_BASE + 8)  /* VT_BLOB             -   + */
#define PROPID_S_FULL_NAME    (PROPID_S_BASE + 9)  /* VT_LPWSTR                 */
#define PROPID_S_NT4_STUB     (PROPID_S_BASE + 10) /* VT_UI2                    */
#define PROPID_S_FOREIGN      (PROPID_S_BASE + 11) /* VT_UI1                    */

#define PROPID_S_DONOTHING    (PROPID_S_BASE + 12) /* VT_UI1                    */
//
// S_DONOTHING is used when creating replicated object (by the replication
// service) to ignore property which are not supported by NT5 DS, like
// site gate or SeqNum. The PropId of these ones are changed to
// S_DONOTHING before calling DSCreateObject or DSSetProps.
//

#define PROPID_S_SECURITY     (PPROPID_S_BASE + 1) /* VT_BLOB                   */
#define PROPID_S_PSC_SIGNPK   (PPROPID_S_BASE + 2) /* VT_BLOB                   */
#define PROPID_S_SECURITY_INFORMATION  (PPROPID_S_BASE + 3)   /* VT_UI4         */
//
//  The SECURITY_INFORMATION bitfield associated with setting or retrieving
//  security descriptor. This property is used internally by MSMQ, it's
//  not visible outside of mqsvc code.
//

//
// PROPID_S_NT4_STUB is set to 1 by the migration tool to indicate that
// this site was created by the migration tool and it has the objectGuid
// of the original site in MSMQ1.0 MQIS database.
//


//------------- Default Values ----------
#define DEFAULT_S_INTERVAL1     2  /* sec */
#define DEFAULT_S_INTERVAL2     10 /* sec */

//********************************************************************
//  DELETED OBJECT PROPERTIES
//********************************************************************
#define PROPID_D_BASE MQDS_DELETEDOBJECT * PROPID_OBJ_GRANULARITY
#define PPROPID_D_BASE (PRIVATE_PROPID_BASE + PROPID_D_BASE)
/*                                                   [T]          [R] [N]    */
/*                                                   ----------------------  */
#define PROPID_D_SEQNUM       (PPROPID_D_BASE + 1) /* VT_BLOB                */
#define PROPID_D_MASTERID     (PPROPID_D_BASE + 2) /* VT_CLSID               */
#define PROPID_D_SCOPE        (PPROPID_D_BASE + 3) /* VT_UI1       -   +     */
#define PROPID_D_OBJTYPE      (PPROPID_D_BASE + 4) /* VT_UI1       _   +     */
#define PROPID_D_IDENTIFIER   (PPROPID_D_BASE + 5) /* VT_CLSID     -   +     */
#define PROPID_D_TIME         (PPROPID_D_BASE + 6) /* VT_I4        -   +     */


//********************************************************************
//  CNS PROPERTIES
//********************************************************************
#define PROPID_CN_BASE MQDS_CN * PROPID_OBJ_GRANULARITY
#define PPROPID_CN_BASE (PRIVATE_PROPID_BASE + PROPID_CN_BASE)
/*                                                     [T]        [R] [N]    */
/*                                                     --------------------  */
#define PROPID_CN_PROTOCOLID  (PROPID_CN_BASE + 1)  /* VT_UI1      -   +     */
#define PROPID_CN_NAME        (PROPID_CN_BASE + 2)  /* VT_LPWSTR             */
#define PROPID_CN_GUID        (PROPID_CN_BASE + 3)  /* VT_CLSID              */
#define PROPID_CN_MASTERID    (PROPID_CN_BASE + 4)  /* VT_CLSID    -   +     */
#define PROPID_CN_SEQNUM      (PROPID_CN_BASE + 5)  /* VT_BLOB               */
#define PROPID_CN_SECURITY    (PPROPID_CN_BASE + 1) /* VT_BLOB               */

//********************************************************************
//  ENTERPRISE PROPERTIES
//********************************************************************
#define PROPID_E_BASE MQDS_ENTERPRISE * PROPID_OBJ_GRANULARITY
#define PPROPID_E_BASE (PRIVATE_PROPID_BASE + PROPID_E_BASE)
/*                                                                [T]       */
/*                                                          --------------  */
#define PROPID_E_NAME            (PROPID_E_BASE + 1)        /* VT_LPWSTR    */
#define PROPID_E_NAMESTYLE       (PROPID_E_BASE + 2)        /* VT_UI1       */
#define PROPID_E_CSP_NAME        (PROPID_E_BASE + 3)        /* VT_LPWSTR    */
#define PROPID_E_PECNAME         (PROPID_E_BASE + 4)        /* VT_LPWSTR    */
#define PROPID_E_S_INTERVAL1     (PROPID_E_BASE + 5)        /* VT_UI2       */
#define PROPID_E_S_INTERVAL2     (PROPID_E_BASE + 6)        /* VT_UI2       */
#define PROPID_E_MASTERID        (PROPID_E_BASE + 7)        /* VT_CLSID     */
#define PROPID_E_SEQNUM          (PROPID_E_BASE + 8)        /* VT_BLOB      */
#define PROPID_E_ID              (PROPID_E_BASE + 9)        /* VT_CLSID     */
#define PROPID_E_CRL             (PROPID_E_BASE + 10)       /* VT_BLOB      */
#define PROPID_E_CSP_TYPE        (PROPID_E_BASE + 11)       /* VT_UI4       */
#define PROPID_E_ENCRYPT_ALG     (PROPID_E_BASE + 12)       /* VT_UI4       */
#define PROPID_E_SIGN_ALG        (PROPID_E_BASE + 13)       /* VT_UI4       */
#define PROPID_E_HASH_ALG        (PROPID_E_BASE + 14)       /* VT_UI4       */
#define PROPID_E_CIPHER_MODE     (PROPID_E_BASE + 15)       /* VT_UI4       */
#define PROPID_E_LONG_LIVE       (PROPID_E_BASE + 16)       /* VT_UI4       */
#define PROPID_E_VERSION         (PROPID_E_BASE + 17)       /* VT_UI2       */
#define PROPID_E_NT4ID           (PROPID_E_BASE + 18)       /* VT_CLSID     */
//
// E_NT4ID is the guid of the enterprise on NT4 (MSMQ1.0). This is used
// for migration, to create an enterprise with predefined objectGUID.
//
#define PROPID_E_SECURITY        (PPROPID_E_BASE + 1)       /* VT_BLOB      */

//-------PROPID_E_NAMESTYLE---------------
// now used for security relaxation.
//
#define MQ_E_RELAXATION_DEFAULT  2
#define MQ_E_RELAXATION_ON       1
#define MQ_E_RELAXATION_OFF      0


//-------PROPID_E_CSP_NAME---------------
// now used for downlevel notification support.
//
#define MQ_E_DOWNLEVEL_ON        L"Y"
#define MQ_E_DOWNLEVEL_OFF       L"N"

//-------Default Values-------------------
#define DEFAULT_E_NAMESTYLE     MQ_E_RELAXATION_DEFAULT
#define DEFAULT_E_DEFAULTCSP    MQ_E_DOWNLEVEL_ON
#define DEFAULT_E_DEFAULTCSP_LEN    STRLEN(DEFAULT_E_DEFAULTCSP)
#define DEFAULT_E_PROV_TYPE     1       // PROV_RSA_FULL
#define DEFAULT_E_VERSION       200



//********************************************************************
//  USER PROPERTIES
//********************************************************************
#define PROPID_U_BASE MQDS_USER * PROPID_OBJ_GRANULARITY
/*                                                                [T]       */
/*                                                          --------------  */
#define PROPID_U_SID             (PROPID_U_BASE + 1)        /* VT_BLOB      */
#define PROPID_U_SIGN_CERT       (PROPID_U_BASE + 2)        /* VT_BLOB      */
#define PROPID_U_MASTERID        (PROPID_U_BASE + 3)        /* VT_CLSID     */
#define PROPID_U_SEQNUM          (PROPID_U_BASE + 4)        /* VT_BLOB      */
#define PROPID_U_DIGEST          (PROPID_U_BASE + 5)        /* VT_UUID      */
#define PROPID_U_ID              (PROPID_U_BASE + 6)        /* VT_UUID      */

//********************************************************************
//  MQUSER PROPERTIES
//********************************************************************
#define PROPID_MQU_BASE MQDS_MQUSER * PROPID_OBJ_GRANULARITY
/*                                                                [T]       */
/*                                                          --------------  */
#define PROPID_MQU_SID             (PROPID_MQU_BASE + 1)        /* VT_BLOB      */
#define PROPID_MQU_SIGN_CERT       (PROPID_MQU_BASE + 2)        /* VT_BLOB      */
#define PROPID_MQU_MASTERID        (PROPID_MQU_BASE + 3)        /* VT_CLSID     */
#define PROPID_MQU_SEQNUM          (PROPID_MQU_BASE + 4)        /* VT_BLOB      */
#define PROPID_MQU_DIGEST          (PROPID_MQU_BASE + 5)        /* VT_UUID      */
#define PROPID_MQU_ID              (PROPID_MQU_BASE + 6)        /* VT_UUID      */
#define PROPID_MQU_SECURITY        (PROPID_MQU_BASE + 7)        /* VT_BLOB      */

//********************************************************************
//  SITELINKS PROPERTIES
//********************************************************************
#define PROPID_L_BASE MQDS_SITELINK * PROPID_OBJ_GRANULARITY
/*                                                                [T]       */
/*                                                          --------------  */
#define PROPID_L_NEIGHBOR1       (PROPID_L_BASE + 1)        /* VT_CLSID     */
#define PROPID_L_NEIGHBOR2       (PROPID_L_BASE + 2)        /* VT_CLSID     */
#define PROPID_L_COST            (PROPID_L_BASE + 3)        /* VT_UI4       */
#define PROPID_L_MASTERID        (PROPID_L_BASE + 4)        /* VT_CLSID     */
#define PROPID_L_SEQNUM          (PROPID_L_BASE + 5)        /* VT_BLOB      */
#define PROPID_L_ID              (PROPID_L_BASE + 6)        /* VT_CLSID     */
#define PROPID_L_GATES_DN        (PROPID_L_BASE + 7)        /* VT_LPWSTR | VT_VECTOR */
#define PROPID_L_NEIGHBOR1_DN    (PROPID_L_BASE + 8)        /* VT_LPWSTR    */
#define PROPID_L_NEIGHBOR2_DN    (PROPID_L_BASE + 9)        /* VT_LPWSTR    */
#define PROPID_L_DESCRIPTION     (PROPID_L_BASE + 10)       /* VT_LPWSTR    */
#define PROPID_L_FULL_PATH       (PROPID_L_BASE + 11)       /* VT_LPWSTR    */
//
//   PROPID_L_ACTUAL_COST contain the link cost as is.
//   PROPID_L_COST performs translation of the cost ( cost to
//   foreign sites is incremented)
//
#define PROPID_L_ACTUAL_COST     (PROPID_L_BASE + 12)       /* VT_UI4       */
#define PROPID_L_GATES           (PROPID_L_BASE + 13)       /* VT_CLSID | VT_VECTOR */

//-------PROPID_L_COST---------------
#define MQ_MAX_LINK_COST    999999


//********************************************************************
//  PURGE PROPERTIES
//********************************************************************
#define PROPID_P_BASE MQDS_PURGE * PROPID_OBJ_GRANULARITY
/*                                                                [T]       */
/*                                                          --------------  */
#define PROPID_P_MASTERID        (PROPID_P_BASE + 1)        /* VT_CLSID     */
#define PROPID_P_PURGED_SN       (PROPID_P_BASE + 2)        /* VT_BLOB      */
#define PROPID_P_ALLOWED_SN      (PROPID_P_BASE + 3)        /* VT_BLOB      */
#define PROPID_P_ACKED_SN        (PROPID_P_BASE + 4)        /* VT_BLOB      */
#define PROPID_P_ACKED_SN_PEC    (PROPID_P_BASE + 5)        /* VT_BLOB      */
#define PROPID_P_STATE			 (PROPID_P_BASE + 6)		/* VT_UI1		*/

//********************************************************************
//  BSCACK PROPERTIES
//********************************************************************
#define PROPID_B_BASE MQDS_BSCACK * PROPID_OBJ_GRANULARITY
/*                                                                [T]       */
/*                                                          --------------  */
#define PROPID_B_BSC_MACHINE_ID  (PROPID_B_BASE + 1)        /* VT_CLSID     */
#define PROPID_B_ACK_TIME        (PROPID_B_BASE + 2)        /* VT_I4        */

//********************************************************************
//  Site Server PROPERTIES
//********************************************************************
#define PROPID_SRV_BASE MQDS_SERVER * PROPID_OBJ_GRANULARITY

#define PROPID_SRV_NAME         (PROPID_SRV_BASE + 1)      /* VT_LPWSTR */
#define PROPID_SRV_ID           (PROPID_SRV_BASE + 2)      /* VT_CLSID  */
#define PROPID_SRV_FULL_PATH    (PROPID_SRV_BASE + 3)      /* VT_LPWSTR */

//********************************************************************
//  MSMQ SETTING PROPERTIES
//********************************************************************
#define PROPID_SET_BASE MQDS_SETTING * PROPID_OBJ_GRANULARITY

#define PROPID_SET_NAME         (PROPID_SET_BASE + 1)      /* VT_LPWSTR */
#define PROPID_SET_SERVICE      (PROPID_SET_BASE + 2)      /* VT_UI4    */
#define PROPID_SET_QM_ID        (PROPID_SET_BASE + 3)      /* VT_CLSID  */
#define PROPID_SET_APPLICATION  (PROPID_SET_BASE + 4)      /* VT_LPWSTR */
#define PROPID_SET_FULL_PATH    (PROPID_SET_BASE + 5)      /* VT_LPWSTR */
#define PROPID_SET_NT4          (PROPID_SET_BASE + 6)      /* VT_UI1    */
//
// SET_NT4 is TRUE if the server is NT4/MSMQ1.0. FALSE otherwise.
//
#define PROPID_SET_MASTERID     (PROPID_SET_BASE + 7)      /* VT_CLSID  */
#define PROPID_SET_SITENAME     (PROPID_SET_BASE + 8)      /* VT_LPWSTR */
//
// PROPID_SET_MASTERID is the NT4 style site guid. It's written on the
// MSMQSetting object which belong to a MSMQ PSC server object. This is the
// best place to keep it, as a server, in NT5 DS, can be in a different site,
// as compared to NT4 MSMQ1 DS. So if it's a server (PROPID_SET_SERVICE is
// SERVICE_PSC or SERVICE_PEC) then MASTERID is the NT4 style site guid which
// is also the masterID for the site's objects. This is used for replication.
//
// PROPID_SET_SITENAME is the site name as written in NT4 MSMQ1 DS.
//

// [adsrv]
#define PROPID_SET_SERVICE_ROUTING     (PROPID_SET_BASE + 9)      /* VT_UI1 */
#define PROPID_SET_SERVICE_DSSERVER    (PROPID_SET_BASE + 10)     /* VT_UI1 */
#define PROPID_SET_SERVICE_DEPCLIENTS  (PROPID_SET_BASE + 11)     /* VT_UI1 */
#define PROPID_SET_OLDSERVICE          (PROPID_SET_BASE + 12)     /* VT_UI4 */

//********************************************************************
//  COMPUTER PROPERTIES
//********************************************************************

#define PROPID_COM_BASE MQDS_COMPUTER * PROPID_OBJ_GRANULARITY

#define PROPID_COM_FULL_PATH         (PROPID_COM_BASE + 1)      /* VT_LPWSTR */
#define PROPID_COM_SAM_ACCOUNT       (PROPID_COM_BASE + 2)      /* VT_LPWSTR */

//
//  COM_CONTAINER Can be used only as extended property when creating
//  the computer object.
//
#define PROPID_COM_CONTAINER         (PROPID_COM_BASE + 3)      /* VT_LPWSTR */

//
// ACCOUNT_CONTROL property is translated to DS attribute userAccountControl
// and it must be set to 4128 (Decimal) when creating a computer object.
// Otherwise, you can't loggin from that computer. Bug 3153.
//
#define PROPID_COM_ACCOUNT_CONTROL   (PROPID_COM_BASE + 4)      /* VT_UI4    */
#define PROPID_COM_DNS_HOSTNAME      (PROPID_COM_BASE + 5)      /* VT_LPWSTR */
//
// PROPID_COM_SID is the SID of the computer object. This property is read
// from the active directory when create a msmqConfiguration object, in
// order to add it to the msmqConfiguration dacl.
//
#define PROPID_COM_SID               (PROPID_COM_BASE + 6)      /* VT_BLOB */

//
// the following properties are used to store/retrieve certificate of
// services. These ones are kept in the computer object.
//
#define PROPID_COM_SIGN_CERT         (PROPID_COM_BASE + 7)      /* VT_BLOB     */
#define PROPID_COM_DIGEST            (PROPID_COM_BASE + 8)      /* VT_CLSID    */
#define PROPID_COM_ID                (PROPID_COM_BASE + 9)      /* VT_CLSID    */
//
//  PROPID_COM_VERSION is supported only in MQAD
//
#define PROPID_COM_VERSION           (PROPID_COM_BASE + 10)     /* VT_LPWSTR   */

//------------- Default Values ----------
#define DEFAULT_COM_ACCOUNT_CONTROL   (UF_PASSWD_NOTREQD | UF_WORKSTATION_TRUST_ACCOUNT)

//
// PROPID_COM_SAM_ACCOUNT (or sAMAccountName property in the Active Directory)
// should be shorter than 20 characters.
// 6295 - ilanh - 03-Jan-2001
//
#define MAX_COM_SAM_ACCOUNT_LENGTH 19

// begin_mq_h

//********************************************************************
//  PRIVATE COMPUTER PROPERTIES
//********************************************************************
#define PROPID_PC_BASE 5800

// end_mq_h

#if (PROPID_PC_BASE != (MQDS_PRIVATE_COMPUTER * PROPID_OBJ_GRANULARITY))
#error "PROPID_PC_BASE != (MQDS_PRIVATE_COMPUTER * PROPID_OBJ_GRANULARITY)"
#endif

// begin_mq_h
#define PROPID_PC_VERSION             (PROPID_PC_BASE + 1) /* VT_UI4            */
#define PROPID_PC_DS_ENABLED          (PROPID_PC_BASE + 2) /* VT_BOOL           */
// end_mq_h

#define FIRST_PRIVATE_COMPUTER_PROPID  PROPID_PC_BASE
#define LAST_PRIVATE_COMPUTER_PROPID   PROPID_PC_DS_ENABLED


// begin_mq_h

//********************************************************************
//  LOCAL ADMIN MSMQ MACHINE PROPERTIES
//********************************************************************
#define PROPID_MGMT_MSMQ_BASE           0
#define PROPID_MGMT_MSMQ_ACTIVEQUEUES   (PROPID_MGMT_MSMQ_BASE + 1) /* VT_LPWSTR | VT_VECTOR  */
#define PROPID_MGMT_MSMQ_PRIVATEQ       (PROPID_MGMT_MSMQ_BASE + 2) /* VT_LPWSTR | VT_VECTOR  */
#define PROPID_MGMT_MSMQ_DSSERVER       (PROPID_MGMT_MSMQ_BASE + 3) /* VT_LPWSTR */
#define PROPID_MGMT_MSMQ_CONNECTED      (PROPID_MGMT_MSMQ_BASE + 4) /* VT_LPWSTR */
#define PROPID_MGMT_MSMQ_TYPE           (PROPID_MGMT_MSMQ_BASE + 5) /* VT_LPWSTR */
#define PROPID_MGMT_MSMQ_BYTES_IN_ALL_QUEUES (PROPID_MGMT_QUEUE_BASE + 6)    /* VT_UI8    */


//
// Returned Value for PROPID_MGMT_MSMQ_CONNECTED property
//
#define MSMQ_CONNECTED      L"CONNECTED"
#define MSMQ_DISCONNECTED   L"DISCONNECTED"


//********************************************************************
//  LOCAL ADMIN MSMQ QUEUE PROPERTIES
//********************************************************************
#define PROPID_MGMT_QUEUE_BASE                  0
#define PROPID_MGMT_QUEUE_PATHNAME              (PROPID_MGMT_QUEUE_BASE + 1)    /* VT_LPWSTR */
#define PROPID_MGMT_QUEUE_FORMATNAME            (PROPID_MGMT_QUEUE_BASE + 2)    /* VT_LPWSTR */
#define PROPID_MGMT_QUEUE_TYPE                  (PROPID_MGMT_QUEUE_BASE + 3)    /* VT_LPWSTR */
#define PROPID_MGMT_QUEUE_LOCATION              (PROPID_MGMT_QUEUE_BASE + 4)    /* VT_LPWSTR */
#define PROPID_MGMT_QUEUE_XACT                  (PROPID_MGMT_QUEUE_BASE + 5)    /* VT_LPWSTR */
#define PROPID_MGMT_QUEUE_FOREIGN               (PROPID_MGMT_QUEUE_BASE + 6)    /* VT_LPWSTR */
#define PROPID_MGMT_QUEUE_MESSAGE_COUNT         (PROPID_MGMT_QUEUE_BASE + 7)    /* VT_UI4    */
#define PROPID_MGMT_QUEUE_BYTES_IN_QUEUE        (PROPID_MGMT_QUEUE_BASE + 8)    /* VT_UI4    */
#define PROPID_MGMT_QUEUE_JOURNAL_MESSAGE_COUNT (PROPID_MGMT_QUEUE_BASE + 9)    /* VT_UI4    */
#define PROPID_MGMT_QUEUE_BYTES_IN_JOURNAL      (PROPID_MGMT_QUEUE_BASE + 10)   /* VT_UI4    */
#define PROPID_MGMT_QUEUE_STATE                 (PROPID_MGMT_QUEUE_BASE + 11)   /* VT_LPWSTR */
#define PROPID_MGMT_QUEUE_NEXTHOPS              (PROPID_MGMT_QUEUE_BASE + 12)   /* VT_LPWSTR|VT_VECTOR  */
#define PROPID_MGMT_QUEUE_EOD_LAST_ACK          (PROPID_MGMT_QUEUE_BASE + 13)   /* VT_BLOB   */
#define PROPID_MGMT_QUEUE_EOD_LAST_ACK_TIME     (PROPID_MGMT_QUEUE_BASE + 14)   /* VT_I4     */
#define PROPID_MGMT_QUEUE_EOD_LAST_ACK_COUNT    (PROPID_MGMT_QUEUE_BASE + 15)   /* VT_UI4    */
#define PROPID_MGMT_QUEUE_EOD_FIRST_NON_ACK     (PROPID_MGMT_QUEUE_BASE + 16)   /* VT_BLOB   */
#define PROPID_MGMT_QUEUE_EOD_LAST_NON_ACK      (PROPID_MGMT_QUEUE_BASE + 17)   /* VT_BLOB   */
#define PROPID_MGMT_QUEUE_EOD_NEXT_SEQ          (PROPID_MGMT_QUEUE_BASE + 18)   /* VT_BLOB   */
#define PROPID_MGMT_QUEUE_EOD_NO_READ_COUNT     (PROPID_MGMT_QUEUE_BASE + 19)   /* VT_UI4    */
#define PROPID_MGMT_QUEUE_EOD_NO_ACK_COUNT      (PROPID_MGMT_QUEUE_BASE + 20)   /* VT_UI4    */
#define PROPID_MGMT_QUEUE_EOD_RESEND_TIME       (PROPID_MGMT_QUEUE_BASE + 21)   /* VT_I4     */
#define PROPID_MGMT_QUEUE_EOD_RESEND_INTERVAL   (PROPID_MGMT_QUEUE_BASE + 22)   /* VT_UI4    */
#define PROPID_MGMT_QUEUE_EOD_RESEND_COUNT      (PROPID_MGMT_QUEUE_BASE + 23)   /* VT_UI4    */
#define PROPID_MGMT_QUEUE_EOD_SOURCE_INFO       (PROPID_MGMT_QUEUE_BASE + 24)   /* VT_VARIANT|VT_VECTOR */


//
// Olbselete alternative names for "Bytes in ..."
//
#define PROPID_MGMT_QUEUE_USED_QUOTA            PROPID_MGMT_QUEUE_BYTES_IN_QUEUE          
#define PROPID_MGMT_QUEUE_JOURNAL_USED_QUOTA    PROPID_MGMT_QUEUE_BYTES_IN_JOURNAL        

//
// Returned value for PROPID_MGMT_QUEUE_TYPE
//
#define MGMT_QUEUE_TYPE_PUBLIC      L"PUBLIC"
#define MGMT_QUEUE_TYPE_PRIVATE     L"PRIVATE"
#define MGMT_QUEUE_TYPE_MACHINE     L"MACHINE"
#define MGMT_QUEUE_TYPE_CONNECTOR   L"CONNECTOR"
#define MGMT_QUEUE_TYPE_MULTICAST   L"MULTICAST"

//
// Returned value for PROPID_MGMT_QUEUE_STATE
//
#define MGMT_QUEUE_STATE_LOCAL          L"LOCAL CONNECTION"
#define MGMT_QUEUE_STATE_NONACTIVE      L"INACTIVE"
#define MGMT_QUEUE_STATE_WAITING        L"WAITING"
#define MGMT_QUEUE_STATE_NEED_VALIDATE  L"NEED VALIDATION"
#define MGMT_QUEUE_STATE_ONHOLD         L"ONHOLD"
#define MGMT_QUEUE_STATE_CONNECTED      L"CONNECTED"
#define MGMT_QUEUE_STATE_DISCONNECTING  L"DISCONNECTING"
#define MGMT_QUEUE_STATE_DISCONNECTED   L"DISCONNECTED"

//
// Returned value for PROPID_MGMT_QUEUE_LOCATION
//
#define MGMT_QUEUE_LOCAL_LOCATION   L"LOCAL"
#define MGMT_QUEUE_REMOTE_LOCATION  L"REMOTE"

// 
// Returned Value for PROPID_MGMT_QUEUE_XACT and PROPID_MGMT_QUEUE_FOREIGN
//

#define MGMT_QUEUE_UNKNOWN_TYPE     L"UNKNOWN"

//
// Obselete names left for backword compatibility.
//

#define MGMT_QUEUE_CORRECT_TYPE     L"YES"
#define MGMT_QUEUE_INCORRECT_TYPE   L"NO"

//
// Names for Returned Value for PROPID_MGMT_QUEUE_XACT 
//

//#define MGMT_QUEUE_UNKNOWN_TYPE     	L"UNKNOWN"
#define MGMT_QUEUE_TRANSACTIONAL_TYPE  	L"YES"
#define MGMT_QUEUE_NOT_TRANSACTIONAL_TYPE   L"NO"

//
// Names for Returned Value for PROPID_MGMT_QUEUE_FOREIGN
//

//#define MGMT_QUEUE_UNKNOWN_TYPE     	L"UNKNOWN"
#define MGMT_QUEUE_FOREIGN_TYPE         L"YES"
#define MGMT_QUEUE_NOT_FOREIGN_TYPE     L"NO"

//
// Object parameter values for MQMgmtAction API
//
#define MO_MACHINE_TOKEN    L"MACHINE"
#define MO_QUEUE_TOKEN      L"QUEUE"

//
// Action parameter values for MQMgmtAction API
//
#define MACHINE_ACTION_CONNECT      L"CONNECT"
#define MACHINE_ACTION_DISCONNECT   L"DISCONNECT"
#define MACHINE_ACTION_TIDY         L"TIDY"

#define QUEUE_ACTION_PAUSE      L"PAUSE"
#define QUEUE_ACTION_RESUME     L"RESUME"
#define QUEUE_ACTION_EOD_RESEND L"EOD_RESEND"

// end_mq_h


// begin_mq_h
//
// LONG_LIVED is the default for PROPID_M_TIME_TO_REACH_QUEUE. If calls
// to MQSendMessage() specify this value, or not specify this property at
// all, then the actual timeout is obtained from Active Directory.
//
#define LONG_LIVED    0xfffffffe
// end_mq_h

#endif // __MQPROPS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\mqkeyhlp.h ===
/*++

Copyright (c) 1996-98 Microsoft Corporation

Module Name:
    mqkeyhlp.h

Abstract:
    Helper functions that exist in MQKEYHLP.DLL.
    These functions are being called directrly by Falcon and are used
    for server authentication.

Author:
    Boaz Feldbaum (BoazF)   16-Oct-1996
    Doron Juster  (DoronJ)  20-May-1998, adapt to MSMQ2.0

Revision History:

--*/

#ifndef _MQKEYHLP_H_
#define _MQKEYHLP_H_

//+--------------------------------
//
// Server side functions.
//
//+--------------------------------

//
// This function retrieve the MSQM server certificate from the service
// "My" store and initialize the server credentials handle. This is the
// first step for initializing server authentication over schannel.
//
HRESULT  MQsspi_InitServerAuthntication() ;

HRESULT
ServerAcceptSecCtx( BOOL    fFisrt,
                    LPVOID *pvhServerContext,
                    LPBYTE  pbServerBuffer,
                    DWORD  *pdwServerBufferSize,
                    LPBYTE  pbClientBuffer,
                    DWORD   dwClientBufferSize );

//+--------------------------------
//
// Client side functions.
//
//+--------------------------------

HRESULT
GetClientCredHandleAndInitSecCtx(
    LPCWSTR szServerName,
    LPVOID *pvClientCredHandle,
    LPVOID *pvClientSecurityContext,
    LPBYTE pbTokenBuffer,
    DWORD *pdwTokenBufferSize
    );

HRESULT
APIENTRY
ClientInitSecCtx(
    LPVOID phClientCred,
    LPVOID phClientContext,
    UCHAR *pServerBuff,
    DWORD dwServerBuffSize,
    DWORD dwMaxClientBuffSize,
    UCHAR *pClientBuff,
    DWORD *pdwClientBuffSize
    );

HRESULT
GetSizes(
    DWORD *pcbMaxToken,
    LPVOID pvhContext =NULL,
    DWORD *pcbHeader =NULL,
    DWORD *pcbTrailer =NULL,
    DWORD *pcbMaximumMessage =NULL,
    DWORD *pcBuffers =NULL,
    DWORD *pcbBlockSize =NULL
    );

void
FreeContextHandle(
    LPVOID pvhContextHandle
    );

HRESULT
MQSealBuffer(
    LPVOID pvhContext,
    PBYTE pbBuffer,
    DWORD cbSize);

HRESULT
MQUnsealBuffer(
    LPVOID pvhContext,
    PBYTE pbBuffer,
    DWORD cbSize,
    PBYTE *ppbUnsealed);

HRESULT
MQsspi_GetNames(
    LPVOID pvhContext,
    LPSTR szServerName,
    DWORD *pdwServerNameLen,
    LPSTR szIssuerName,
    DWORD *pdwIssuerNameLen
    );

HRESULT
GetCertificateNames(
    LPBYTE pbCertificate,
    DWORD cbCertificate,
    LPSTR szSubject,
    DWORD *pdwSubjectLen,
    LPSTR szIssuer,
    DWORD *pdwIssuerLen
    );

HRESULT
CheckContextCredStatus(
    LPVOID pvhContext,
    PBYTE pbServerCertificate,
    DWORD *pcbServerCertificateBuffSize
    );

#endif // _MQKEYHLP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\mqnames.h ===
//
//  All components should refer to other only by the names below
//
#ifdef _TOOL
#define MQ1REPL_DLL_NAME  	TEXT("mq1repl.dll")
#define MQADS_DLL_NAME    	TEXT("tmqads.dll")
#define MQAD_DLL_NAME    	TEXT("tmqad.dll")
#define MQCERTUI_DLL_NAME 	TEXT("mqcertui.dll")
#define MQCLUS_DLL_NAME   	TEXT("mqclus.dll")
#define MQDBODBC_DLL_NAME 	TEXT("mqdbodbc.dll")
#define MQDSCLI_DLL_NAME  	TEXT("tmqdscli.dll")
#define MQDSSRV_DLL_NAME  	TEXT("tmqdssrv.dll")
#define MQMIGRAT_DLL_NAME 	TEXT("mqmigrat.dll")
#define MQOA_DLL_NAME     	TEXT("mqoa.dll")
#define MQPERF_DLL_NAME   	TEXT("mqperf.dll")
#define MQQM_DLL_NAME     	TEXT("tmqqm.dll")
#define MQRPERF_DLL_NAME   	TEXT("mqrperf.dll")
#define MQRT_DLL_NAME   	TEXT("mqrt.dll")
#define MQSEC_DLL_NAME  	TEXT("tmqsec.dll")
#define MQSNAP_DLL_NAME   	TEXT("mqsnap.dll")
#define MQUPGRD_DLL_NAME   	TEXT("mqupgrd.dll")
#define MQUTIL_DLL_NAME   	TEXT("tmqutil.dll")

#else

#define MQ1REPL_DLL_NAME  	TEXT("mq1repl.dll")
#define MQAD_DLL_NAME    	TEXT("mqad.dll")
#define MQADS_DLL_NAME    	TEXT("mqads.dll")
#define MQCERTUI_DLL_NAME 	TEXT("mqcertui.dll")
#define MQCLUS_DLL_NAME   	TEXT("mqclus.dll")
#define MQDBODBC_DLL_NAME 	TEXT("mqdbodbc.dll")
#define MQDSCLI_DLL_NAME  	TEXT("mqdscli.dll")
#define MQDSSRV_DLL_NAME  	TEXT("mqdssrv.dll")
#define MQMIGRAT_DLL_NAME 	TEXT("mqmigrat.dll")
#define MQOA_DLL_NAME     	TEXT("mqoa.dll")
#define MQPERF_DLL_NAME   	TEXT("mqperf.dll")
#define MQQM_DLL_NAME     	TEXT("mqqm.dll")
#define MQRPERF_DLL_NAME   	TEXT("mqrperf.dll")
#define MQRT_DLL_NAME   	TEXT("mqrt.dll")
#define MQSEC_DLL_NAME   	TEXT("mqsec.dll")
#define MQSNAP_DLL_NAME   	TEXT("mqsnap.dll")
#define MQUPGRD_DLL_NAME   	TEXT("mqupgrd.dll")
#define MQUTIL_DLL_NAME   	TEXT("mqutil.dll")

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\mqtempl.h ===
//
// This file is obsolete, use autoptr.h.
// erezh 23-May-2000
//
#include <autoptr.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\mqreport.h ===
/////////////////////////////////////////////////////////////////
//
//
//              File : report.h
//
//
/////////////////////////////////////////////////////////////////

#ifndef _REPORT_H_
#define _REPORT_H_

#include <_mqlog.h>
#include <cs.h>

#define DLL_EXPORT  __declspec(dllexport)
#define DLL_IMPORT  __declspec(dllimport)

const WCHAR x_wszLogFileName[]     = L"\\debug\\msmq.log" ;

const DWORD x_cLogFileNameLen = sizeof(x_wszLogFileName)/sizeof(WCHAR);

const WCHAR x_wszReplLogFileName[] = L"\\debug\\mq1sync.log" ;
const DWORD x_cReplLogFileNameLen = sizeof(x_wszReplLogFileName)/sizeof(WCHAR);

//
// constants
//

#define EVENTLOGID          DWORD

//
//  Constants for categories in event log
//

#define  EVENTLOG_MAX_CATEGORIES   2

//
// definitions of possible debugging output locations
//

#define DBGLOC_DBGR      0x0001
#define DBGLOC_DBGWIN    0x0002
#define DBGLOC_LOG       0x0004

//
// definitions of possible packet tracing
//
#define DBGPKT_SEND      0x0001
#define DBGPKT_RCV       0x0002
#define DBGPKT_SESSION   0x0004
//
// definitions of standard message levels
//

#define DBGMOD_API              0x00000001
#define DBGMOD_QMACK            0x00000002
#define DBGMOD_RPC              0x00000004
#define DBGMOD_NETSESSION       0x00000008
#define DBGMOD_TRAP             0x00000010
#define DBGMOD_MSGTRACK         0x00000020
#define DBGMOD_ORPHAN           0x00000040
#define DBGMOD_PROP             0x00000080
#define DBGMOD_DSAPI            0x00000100
#define DBGMOD_DS               0x00000200
#define DBGMOD_PSAPI            0x00000400
#define DBGMOD_SECURITY         0x00000800
#define DBGMOD_ROUTING          0x00001000
#define DBGMOD_PERF             0x00002000
#define DBGMOD_QM               0x00004000
#define DBGMOD_EXPLORER         0x00008000
#define DBGMOD_XACT             0x00010000
#define DBGMOD_XACT_SEND        0x00020000
#define DBGMOD_XACT_RCV         0x00040000
#define DBGMOD_LOG              0x00080000
#define DBGMOD_WIN95            0x00100000
#define DBGMOD_ADS              0x00200000
#define DBGMOD_REPLSERV         0x00400000
#define DBGMOD_ALL              0xFFFFFFFF


//
// definitions of debugging levels to be used outside DBGMSG macro.
// For DBGMSG use the old DBGLVL_XXXX (now defined in msmqwpp.tpl)
//
#define MQ_DBGLVL_ERROR   1
#define MQ_DBGLVL_WARNING 2
#define MQ_DBGLVL_TRACE   3
#define MQ_DBGLVL_INFO    MQ_DBGLVL_TRACE

#ifdef _MQUTIL
#define DLL_IMPORT_EXPORT DLL_EXPORT
#else
#define DLL_IMPORT_EXPORT DLL_IMPORT
#endif

//
// Structure for compact keeping of error history
//
typedef struct ErrorHistoryCell
{
    time_t        m_time;                  // is actually int64
    LONG        m_status;                 // may be HR, RPCStatus, NTStatus, BOOL
    USHORT      m_eLogComponent;        // practically - QM, RT, DBG 
    USHORT      m_usPoint;                // Unique-per-file log point number 
    DWORD      m_tid;                    // thread ID
    WCHAR       m_wszFileName[16];      // program file name
} ErrorHistoryCell;

#define ERROR_HISTORY_SIZE     30

//
// Structure for compact keeping of event history
//
typedef struct EventHistoryCell
{
    time_t        m_time;                  // is actually int64
    EVENTLOGID  m_evid;                   // Event ID
} EventHistoryCell;


#define EVENT_HISTORY_SIZE     60

///////////////////////////////////////////////////////////////////////////
//
// class COutputReport
//
// Description : a class for outputing debug messages and event-log messages
//
///////////////////////////////////////////////////////////////////////////

class DLL_IMPORT_EXPORT COutputReport
{
    public:

        // constructor / destructor
        COutputReport (void);


        inline void SetDbgInst(HINSTANCE hInst);

        // event-log functions (valid in release and debug version)
        void ReportMsg       ( EVENTLOGID id,
                               DWORD   cMemSize  = 0,
                               LPVOID  pMemDump  = NULL,
                               WORD    cParams   = 0,
                               LPCTSTR *pParams  = NULL,
                               WORD    wCategory = 0 );

        void ReportStringMsg  (WORD wCategory,
                               EVENTLOGID id,
                               WORD cCount, ...) ;

        void RestartLogging() ;

        void WriteMsmqLog( 
                           DWORD dwLevel,
                           enum enumLogComponents eLogComponent,
                           DWORD dwSubComponent,
                           WCHAR * Format, ...) ;
        
        void KeepErrorHistory(
                           enum enumLogComponents eLogComponent,
                           LPCWSTR wszFileName, 
                           USHORT usPoint, 
                           LONG status) ;

        void KeepEventHistory(EVENTLOGID evid);
        
    private:

        enum { BAD_SEVERITY_CODE=0 };

        //
        // debug mode methods
        //

        void UpdateRegistry(LPCTSTR pszRegKey);
        WORD GetSeverityCode  (EVENTLOGID elid);
        void InitLogging( enum enumLogComponents eLogComponent ) ;


        HINSTANCE m_hInst;
        HANDLE    m_hEventLog;
        BOOL      m_bUpdatedRegistry;

        WCHAR     m_wszLogFileName[ MAX_PATH ] ;
        BOOL      m_fLogFileInited ;

        //
        // Variables for logging
        //
        CCriticalSection m_LogCS ;
        BOOL      m_fLoggingDisabled ;
        BOOL      m_fLogEverything ;
        BOOL      m_fRefreshLogTypes ;
        DWORD     m_dwLogTypes ;
        DWORD     m_aLogComponentsBits[ e_cLogComponents ] ;
            
        //
        // Cyclical storage for recent errors and events. Is filled even without enabled error logging.
        // May help for debugging, post-mortems, crash dumps, or snapshot user dumps
        //
        DWORD        m_dwCurEventHistoryIndex;      // index of the next event history cell to used
        DWORD        m_dwCurErrorHistoryIndex;      // index of the next error history cell to used
        char         m_HistorySignature[8];           // holds "MSMQERR" for lookup in dump
        
        //
        // Log history - for debugging & post-mortem
        //
        ErrorHistoryCell  m_ErrorHistory[ERROR_HISTORY_SIZE]; // array to be sought in debugging      

        //
        //  Event history - for debugging & post-mortem
        //
        EventHistoryCell  m_EventHistory[EVENT_HISTORY_SIZE];
        
};

//
// wrapper api
//

void APIENTRY  WriteToMsmqLog( DWORD dwLevel,
                               enum enumLogComponents eLogComponent,
                               DWORD dwSubComponent,
                               WCHAR *wszBuf ) ;

typedef void (APIENTRY  *WriteToMsmqLog_ROUTINE) (
                             DWORD dwLevel,
                             enum enumLogComponents eLogComponent,
                             DWORD dwSubComponent,
                             WCHAR *wszBuf ) ;

/**************************************************************************/
//
// Macro definitions
//
//   The following macros describe the interface of the programmer with the
//   COutputReport class.
//
/**************************************************************************/

////////////////////////////////////////////////////////////////////////////
//
// WRITE_MSMQ_LOG(data)
//
// Write to log file. Definitions from _mqlog.h
//
// Syntax:  WRITE_MSMQ_LOG(( dwLevel,
//                           eLogComponent,
//                           dwSubComponent,
//                           Format,
//                           Arg1, Arg2 )) ;
//
// For example:
//     WRITE_MSMQ_LOG((  LOG_ERROR,
//                       e_LogDS,
//                       LOG_DS_CREATE_ON_GC,
//                       TEXT("Ops, fatal error at %s, hr- %lxh"),
//                       L"My Jerk Code", 0xc00e0001 )) ;
//
////////////////////////////////////////////////////////////////////////////

#define WRITE_MSMQ_LOG(data)       Report.WriteMsmqLog data

#define KEEP_ERROR_HISTORY(data)   Report.KeepErrorHistory data

//
// REPORT macros - Used for reporting to the event-log
//

////////////////////////////////////////////////////////////////////////////
//
// REPORT_CATEGORY(data)
//
// Reporting a simple message with no additional information.
//
// Syntax: REPORT_CATEGORY((a_message_type), wCategory);
//
////////////////////////////////////////////////////////////////////////////

#define REPORT_CATEGORY(id, wCategory)            \
            Report.ReportMsg ( id,                \
                               0,                 \
                               NULL,              \
                               0,                 \
                               NULL,              \
                               wCategory ) ;

///////////////////////////////////////////////////////////////////////////
//
// REPORT_WITH_STRINGS_AND_CATEGORY(data)
//
//  Reporting a message and attaching additional strings to it.
//
//  Syntax : REPORT_WITH_STRINGS_AND_CATEGORY((a_message_category,
//                                             a_message_type,
//                                             first_string,second_string,...));
//
//
//  For example : To report the message like "An error occured in module ...", which is
//                defined as MSG2 and you need to add the module's name.
//   -  REPORT_WITH_STRINGS((MSG2,TEXT("qm.cpp")));
//
///////////////////////////////////////////////////////////////////////////

#define REPORT_WITH_STRINGS_AND_CATEGORY(data) Report.ReportStringMsg data

//
// for processes who use the report class and need to import the dll
//

extern DLL_IMPORT_EXPORT COutputReport Report;

/***************************************************************************************************/


//////////////////////////////////////////////////
// inline functions ( in release code as well )
//////////////////////////////////////////////////


inline void COutputReport::SetDbgInst(HINSTANCE hInst)
{
    m_hInst = hInst;
}

#endif  // of _REPORT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\mqsocket.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    mqsocket.h

Abstract:

    Falcon specific definition for use with winsock.

Author:

    Doron Juster  (DoronJ)  20-Mar-1997

--*/

#ifndef __MQSOCKET_H
#define __MQSOCKET_H

#define MQSOCK_MAX_COMPUTERNAME_LENGTH   256

#endif // __MQSOCKET_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\mqsec.h ===
//++
//
// Copyright (c) 1996-1998 Microsoft Coroporation
//
// Module Name  : mqsec.h
//
// Abstract     : Security related definitions
//
// Module Author: Boaz Feldbaum and Yoel Arnon
//
// History:  Doron Juster (DoronJ), add definition for mqsec.dll
//
//--

#ifndef __MQSEC_H_
#define __MQSEC_H_

#include "_mqsecer.h"
#include "mqencryp.h"

//+-------------------------------
//
//  CImpersonate
//
//+-------------------------------

//
// This object class is not need on Win95.
//
// CImpersonate is an object that impersonates the calling user. If the
// client is an RPC client, impersonation is done using RPC functions, else
// impersonation is done by calling ImpersonateSelf.

class CImpersonate
{
public:
    CImpersonate(BOOL fClient, BOOL fImpersonate = FALSE) ;
    virtual ~CImpersonate() ;

    virtual BOOL   Impersonate(BOOL);     // Impersonate/Revert to self.
    virtual HANDLE GetAccessToken( IN  DWORD dwAccessType = TOKEN_QUERY,
                                   IN  BOOL  fThreadTokenOnly = FALSE ) ;
    virtual DWORD  GetImpersonationStatus();

    virtual BOOL   GetThreadSid( OUT BYTE **ppSid ) ;

    virtual BOOL   IsImpersonatedAsSystem() ;

private:
    virtual BOOL   IsImpersonatedAsAnonymous() ;

private:
    BOOL   m_fClient;
    BOOL   m_fImpersonating;
    HANDLE m_hAccessTokenHandle;
    DWORD  m_dwStatus;

    bool m_fImpersonateAnonymous;	// a flag to indicate impersonate anonymous
};


//
// Structure for Absolute security descriptor
//
struct CAbsSecurityDsecripror
{
public:
	CAbsSecurityDsecripror() {}

public:
    AP<char> m_pOwner;
    AP<char> m_pPrimaryGroup;
    AP<char> m_pDacl;
    AP<char> m_pSacl;
    AP<char> m_pObjAbsSecDescriptor;

private:
    CAbsSecurityDsecripror(const CAbsSecurityDsecripror&);
	CAbsSecurityDsecripror& operator=(const CAbsSecurityDsecripror&);

};


//+--------------------------------------
//
//  enums and other useful macros
//
//+--------------------------------------

#define  MQSEC_SD_ALL_INFO  ( OWNER_SECURITY_INFORMATION |      \
                              GROUP_SECURITY_INFORMATION |      \
                              DACL_SECURITY_INFORMATION  |      \
                              SACL_SECURITY_INFORMATION )

//+-----------------------------------------------------------------------
//
//  enum enumProvider
//
//  This enumerates the crypto providers supported by msmq for encryption.
//  The "Foreign" entries are used by the "mqforgn" tool to insert public
//  keys into the msmqConfiguration objects of foreign machines.
//
//+-----------------------------------------------------------------------

enum enumProvider
{
    eBaseProvider,
    eEnhancedProvider,
    eForeignBaseProvider,
    eForeignEnhProvider
} ;

enum enumCryptoProp
{
    eProvName,
    eProvType,
    eSessionKeySize,
    eContainerName,
    eBlockSize
} ;

//+----------------------------------------------------------------------
//
// The functions exported by mqsec.dll are internals and should not
// be included in mq.h in the sdk.
//
//+----------------------------------------------------------------------

//
// Function to manipulate security descriptors.
//

enum  enumDaclType {
    e_UseDefaultDacl = 0,
    e_GrantFullControlToEveryone,
    e_UseDefDaclAndCopyControl
} ;

HRESULT  APIENTRY MQSec_GetDefaultSecDescriptor(
                       IN  DWORD                 dwObjectType,
                       OUT PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
                       IN  BOOL                  fImpersonate,
                       IN  PSECURITY_DESCRIPTOR  pInSecurityDescriptor,
                       IN  SECURITY_INFORMATION  seInfoToRemove,
                       IN  enum  enumDaclType    eDaclType ) ;

typedef HRESULT (APIENTRY *MQSec_GetDefaultSecDescriptor_ROUTINE) (
                        DWORD                 dwObjectType,
                        PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
                        BOOL                  fImpersonate,
                        PSECURITY_DESCRIPTOR  pInSecurityDescriptor,
                        SECURITY_INFORMATION  seInfoToRemove,
                        enum  enumDaclType    eDaclType ) ;

HRESULT  APIENTRY MQSec_MergeSecurityDescriptors(
                        IN  DWORD                  dwObjectType,
                        IN  SECURITY_INFORMATION   SecurityInformation,
                        IN  PSECURITY_DESCRIPTOR   pInSecurityDescriptor,
                        IN  PSECURITY_DESCRIPTOR   pObjSecurityDescriptor,
                        OUT PSECURITY_DESCRIPTOR  *ppSecurityDescriptor
                        );


HRESULT APIENTRY  MQSec_MakeSelfRelative(
                                IN  PSECURITY_DESCRIPTOR   pIn,
                                OUT PSECURITY_DESCRIPTOR  *ppOut,
                                OUT DWORD                 *pdwSize ) ;

//
// Function to manipulate crypto provider and crypto keys.
//

HRESULT APIENTRY  MQSec_PackPublicKey(
                             IN      BYTE            *pKeyBlob,
                             IN      ULONG            ulKeySize,
                             IN      LPCWSTR          wszProviderName,
                             IN      ULONG            ulProviderType,
                             IN OUT  MQDSPUBLICKEYS **ppPublicKeysPack ) ;

HRESULT APIENTRY  MQSec_UnpackPublicKey(
                               IN  MQDSPUBLICKEYS  *pPublicKeysPack,
                               IN  LPCWSTR          wszProviderName,
                               IN  ULONG            ulProviderType,
                               OUT BYTE           **ppKeyBlob,
                               OUT ULONG           *pulKeySize ) ;

HRESULT APIENTRY  MQSec_GetCryptoProvProperty(
                                     IN  enum enumProvider     eProvider,
                                     IN  enum enumCryptoProp   eProp,
                                     OUT LPWSTR         *ppwszStringProp,
                                     OUT DWORD          *pdwProp ) ;

HRESULT APIENTRY  MQSec_AcquireCryptoProvider(
                                     IN  enum enumProvider  eProvider,
                                     OUT HCRYPTPROV        *phProv ) ;

typedef HRESULT
(APIENTRY *MQSec_StorePubKeys_ROUTINE) ( IN BOOL fRegenerate,
                                         IN enum enumProvider eBaseCrypProv,
                                         IN enum enumProvider eEnhCrypProv,
                                         OUT BLOB * pblobEncrypt,
                                         OUT BLOB * pblobSign ) ;

HRESULT APIENTRY MQSec_StorePubKeys( IN BOOL fRegenerate,
                                     IN enum enumProvider eBaseCrypProv,
                                     IN enum enumProvider eEnhCrypProv,
                                     OUT BLOB * pblobEncrypt,
                                     OUT BLOB * pblobSign ) ;

typedef HRESULT
(APIENTRY *MQSec_StorePubKeysInDS_ROUTINE) ( IN BOOL       fRegenerate,
                                    IN LPCWSTR    wszObjectName,
                                    IN DWORD      dwObjectType) ;

HRESULT  APIENTRY MQSec_StorePubKeysInDS( IN BOOL         fRegenerate,
                                 IN LPCWSTR      wszObjectName,
                                 IN DWORD        dwObjectType) ;

HRESULT  APIENTRY MQSec_GetPubKeysFromDS(
                                 IN  const GUID  *pMachineGuid,
                                 IN  LPCWSTR      lpwszMachineName,
                                 IN  enum enumProvider     eProvider,
                                 IN  DWORD        propIdKeys,
                                 OUT BYTE       **pPubKeyBlob,
                                 OUT DWORD       *pdwKeyLength ) ;

HRESULT  APIENTRY  MQSec_GetUserType( IN  PSID pSid,
                                      OUT BOOL *pfLocalUser,
                                      OUT BOOL *pfLocalSystem ) ;

typedef HRESULT  (APIENTRY  *MQSec_GetUserType_ROUTINE) (
                                      IN  PSID pSid,
                                      OUT BOOL *pfLocalUser,
                                      OUT BOOL *pfLocalSystem ) ;

BOOL    APIENTRY  MQSec_IsSystemSid( IN  PSID  pSid ) ;

BOOL    APIENTRY  MQSec_IsGuestSid( IN  PSID  pSid ) ;

BOOL    APIENTRY  MQSec_IsAnonymusSid( IN  PSID  pSid ) ;

HRESULT APIENTRY  MQSec_IsUnAuthenticatedUser(
                                         BOOL *pfUnAuthenticatedUser ) ;

HRESULT APIENTRY  MQSec_GetImpersonationObject(
                                       IN  BOOL           fClient,
                                       IN  BOOL           fImpersonate,
                                       OUT CImpersonate **ppImpersonate ) ;

HRESULT APIENTRY  MQSec_GetThreadUserSid(
                                       IN  BOOL           fImpersonate,
                                       OUT PSID  *        ppSid,
                                       OUT DWORD *        pdwSidLen ) ;

HRESULT APIENTRY  MQSec_GetProcessUserSid( OUT PSID  *ppSid,
                                           OUT DWORD *pdwSidLen ) ;

typedef HRESULT (APIENTRY * MQSec_GetProcessUserSid_ROUTINE) (
                                           OUT PSID  *ppSid,
                                           OUT DWORD *pdwSidLen ) ;

PSID    APIENTRY  MQSec_GetLocalMachineSid( IN  BOOL    fAllocate,
                                            OUT DWORD  *pdwSize ) ;

PSID    APIENTRY  MQSec_GetWorldSid() ;

PSID	APIENTRY  MQSec_GetAnonymousSid();

PSID	APIENTRY  MQSec_GetLocalSystemSid();

PSID    APIENTRY  MQSec_GetProcessSid() ;

enum  enumCopyControl {
    e_DoNotCopyControlBits = 0,
    e_DoCopyControlBits
} ;

BOOL    APIENTRY MQSec_CopySecurityDescriptor(
                    IN PSECURITY_DESCRIPTOR  pDstSecurityDescriptor,
                    IN PSECURITY_DESCRIPTOR  pSrcSecurityDescriptor,
                    IN SECURITY_INFORMATION  RequestedInformation,
                    IN enum  enumCopyControl eCopyControlBits ) ;

bool
APIENTRY
MQSec_MakeAbsoluteSD(
    PSECURITY_DESCRIPTOR   pObjSecurityDescriptor,
	CAbsSecurityDsecripror* pAbsSecDescriptor
	);

bool
APIENTRY
MQSec_SetSecurityDescriptorDacl(
    IN  PACL pNewDacl,
    IN  PSECURITY_DESCRIPTOR   pObjSecurityDescriptor,
    OUT AP<BYTE>&  pSecurityDescriptor
	);


HRESULT APIENTRY  MQSec_ConvertSDToNT4Format(
                     IN  DWORD                 dwObjectType,
                     IN  SECURITY_DESCRIPTOR  *pSD5,
                     OUT DWORD                *pdwSD4Len,
                     OUT SECURITY_DESCRIPTOR **ppSD4,
                     IN  SECURITY_INFORMATION  sInfo = MQSEC_SD_ALL_INFO ) ;

enum  enumDaclDefault {
    e_DoNotChangeDaclDefault = 0,
    e_MakeDaclNonDefaulted
} ;

HRESULT APIENTRY  MQSec_ConvertSDToNT5Format(
                     IN  DWORD                 dwObjectType,
                     IN  SECURITY_DESCRIPTOR  *pSD4,
                     OUT DWORD                *pdwSD5Len,
                     OUT SECURITY_DESCRIPTOR **ppSD5,
                     IN  enum  enumDaclDefault eUnDefaultDacl,
                     IN  PSID                  pComputerSid  = NULL ) ;

HRESULT APIENTRY  MQSec_SetPrivilegeInThread( LPCTSTR lpwcsPrivType,
                                              BOOL    bEnabled ) ;

typedef HRESULT  (APIENTRY *MQSec_SetPrivilegeInThread_FN)
                             ( LPCTSTR lpwcsPrivType, BOOL bEnabled ) ;

HRESULT APIENTRY  MQSec_AccessCheck(
                            IN  SECURITY_DESCRIPTOR *pSD,
                            IN  DWORD                dwObjectType,
                            IN  LPCWSTR              pwszObjectName,
                            IN  DWORD                dwDesiredAccess,
                            IN  LPVOID               pId,
                            IN  BOOL                 fImpAsClient = FALSE,
                            IN  BOOL                 fImpersonate = FALSE ) ;

HRESULT
APIENTRY
MQSec_AccessCheckForSelf(
	IN  SECURITY_DESCRIPTOR *pSD,
	IN  DWORD                dwObjectType,
	IN  PSID                 pSelfSid,
	IN  DWORD                dwDesiredAccess,
	IN  BOOL                 fImpersonate
	);

BOOL    APIENTRY  MQSec_CanGenerateAudit() ;

//+----------------------------------------------
//
//  Message Authentication functions.
//
//+----------------------------------------------

//
// This structure is used to gather the message flags that are supplied by
// caller to MQSendMessage() and hash them.
//
struct _MsgFlags
{
    UCHAR  bDelivery ;
    UCHAR  bPriority ;
    UCHAR  bAuditing ;
    UCHAR  bAck      ;
    USHORT usClass   ;
    ULONG  ulBodyType ;
} ;

struct _MsgPropEntry
{
    ULONG       dwSize ;
    const BYTE *pData ;
} ;

struct _MsgHashData
{
    ULONG                cEntries ;
    struct _MsgPropEntry aEntries[1] ;
} ;

HRESULT APIENTRY  MQSigHashMessageProperties(
                                 IN HCRYPTHASH           hHash,
                                 IN struct _MsgHashData *pHashData ) ;

//+----------------------------------------------
//
// sspi functions (server authentication).
//
//+----------------------------------------------

typedef HRESULT (APIENTRY *MQsspi_UPDATECACONFIG_FN)(BOOL);

HRESULT  APIENTRY MQsspi_UpdateCaConfig(BOOL fOldCertsOnly);

HRESULT  MQsspi_GetCaCert( LPCWSTR  szCaName,
                           PBYTE    pbSha1Hash,
                           DWORD    dwSha1HashSize,
                           DWORD   *pdwCertLen,
                           LPBYTE  *ppCert );

BOOL  MQsspi_IsSecuredServerConn(BOOL fRefresh) ;
BOOL  MQsspi_SetSecuredServerConn( BOOL fSecured ) ;
void  MQsspi_MigrateSecureCommFlag(void) ;

// begin_mq_h

//+-----------------------------------------
//
// Flags for MQRegisterCertificate()
//
//+-----------------------------------------

#define MQCERT_REGISTER_ALWAYS        0x01
#define MQCERT_REGISTER_IF_NOT_EXIST  0x02

// end_mq_h

#define MQCERT_CREATE_LOCALLY         0x80000000
    //
    // or this flag, MQCERT_CREATE_LOCALLY, with the other.
    // This create an internal certificate locally, without registering
    // it in the active directory. Useful for workgroup and local users.
    // Enable content authentication, not user authentication.
    //

//
// flags in HKCU, CERTIFICATE_REGISTERD_REGNAME, that indicate result
// of autoregistration of internal certificate.
//
#define INTERNAL_CERT_REGISTERED   1

// begin_mq_h

//********************************************************************
//  SECURITY Flags (Queue access control)
//********************************************************************

#define MQSEC_DELETE_MESSAGE                0x1
#define MQSEC_PEEK_MESSAGE                  0x2
#define MQSEC_WRITE_MESSAGE                 0x4
#define MQSEC_DELETE_JOURNAL_MESSAGE        0x8
#define MQSEC_SET_QUEUE_PROPERTIES          0x10
#define MQSEC_GET_QUEUE_PROPERTIES          0x20
#define MQSEC_DELETE_QUEUE                  DELETE
#define MQSEC_GET_QUEUE_PERMISSIONS         READ_CONTROL
#define MQSEC_CHANGE_QUEUE_PERMISSIONS      WRITE_DAC
#define MQSEC_TAKE_QUEUE_OWNERSHIP          WRITE_OWNER

#define MQSEC_RECEIVE_MESSAGE               (MQSEC_DELETE_MESSAGE | \
                                             MQSEC_PEEK_MESSAGE)

#define MQSEC_RECEIVE_JOURNAL_MESSAGE       (MQSEC_DELETE_JOURNAL_MESSAGE | \
                                             MQSEC_PEEK_MESSAGE)

#define MQSEC_QUEUE_GENERIC_READ            (MQSEC_GET_QUEUE_PROPERTIES | \
                                             MQSEC_GET_QUEUE_PERMISSIONS | \
                                             MQSEC_RECEIVE_MESSAGE | \
                                             MQSEC_RECEIVE_JOURNAL_MESSAGE)

#define MQSEC_QUEUE_GENERIC_WRITE           (MQSEC_GET_QUEUE_PROPERTIES | \
                                             MQSEC_GET_QUEUE_PERMISSIONS | \
                                             MQSEC_WRITE_MESSAGE)

#define MQSEC_QUEUE_GENERIC_EXECUTE         0

#define MQSEC_QUEUE_GENERIC_ALL             (MQSEC_RECEIVE_MESSAGE | \
                                             MQSEC_RECEIVE_JOURNAL_MESSAGE | \
                                             MQSEC_WRITE_MESSAGE | \
                                             MQSEC_SET_QUEUE_PROPERTIES | \
                                             MQSEC_GET_QUEUE_PROPERTIES | \
                                             MQSEC_DELETE_QUEUE | \
                                             MQSEC_GET_QUEUE_PERMISSIONS | \
                                             MQSEC_CHANGE_QUEUE_PERMISSIONS | \
                                             MQSEC_TAKE_QUEUE_OWNERSHIP)
// end_mq_h

//
// Machine security flags
//
#define MQSEC_DELETE_DEADLETTER_MESSAGE     0x1
#define MQSEC_PEEK_DEADLETTER_MESSAGE       0x2
#define MQSEC_CREATE_QUEUE                  0x4
#define MQSEC_SET_MACHINE_PROPERTIES        0x10
#define MQSEC_GET_MACHINE_PROPERTIES        0x20
#define MQSEC_DELETE_JOURNAL_QUEUE_MESSAGE  0x40
#define MQSEC_PEEK_JOURNAL_QUEUE_MESSAGE    0x80
#define MQSEC_DELETE_MACHINE                DELETE
#define MQSEC_GET_MACHINE_PERMISSIONS       READ_CONTROL
#define MQSEC_CHANGE_MACHINE_PERMISSIONS    WRITE_DAC
#define MQSEC_TAKE_MACHINE_OWNERSHIP        WRITE_OWNER

#define MQSEC_RECEIVE_DEADLETTER_MESSAGE    (MQSEC_DELETE_DEADLETTER_MESSAGE | \
                                             MQSEC_PEEK_DEADLETTER_MESSAGE)

#define MQSEC_RECEIVE_JOURNAL_QUEUE_MESSAGE (MQSEC_DELETE_JOURNAL_QUEUE_MESSAGE | \
                                             MQSEC_PEEK_JOURNAL_QUEUE_MESSAGE)

#define MQSEC_MACHINE_GENERIC_READ          (MQSEC_GET_MACHINE_PROPERTIES | \
                                             MQSEC_GET_MACHINE_PERMISSIONS | \
                                             MQSEC_RECEIVE_DEADLETTER_MESSAGE | \
                                             MQSEC_RECEIVE_JOURNAL_QUEUE_MESSAGE)

#define MQSEC_MACHINE_GENERIC_WRITE         (MQSEC_GET_MACHINE_PROPERTIES | \
                                             MQSEC_GET_MACHINE_PERMISSIONS | \
                                             MQSEC_CREATE_QUEUE)

#define MQSEC_MACHINE_GENERIC_EXECUTE       0

#define MQSEC_MACHINE_GENERIC_ALL           (MQSEC_RECEIVE_DEADLETTER_MESSAGE | \
                                             MQSEC_RECEIVE_JOURNAL_QUEUE_MESSAGE | \
                                             MQSEC_CREATE_QUEUE | \
                                             MQSEC_SET_MACHINE_PROPERTIES | \
                                             MQSEC_GET_MACHINE_PROPERTIES | \
                                             MQSEC_DELETE_MACHINE | \
                                             MQSEC_GET_MACHINE_PERMISSIONS | \
                                             MQSEC_CHANGE_MACHINE_PERMISSIONS | \
                                             MQSEC_TAKE_MACHINE_OWNERSHIP)

#define MQSEC_MACHINE_WORLD_RIGHTS          (MQSEC_GET_MACHINE_PROPERTIES | \
                                             MQSEC_GET_MACHINE_PERMISSIONS)

#define MQSEC_MACHINE_SELF_RIGHTS       (MQSEC_GET_MACHINE_PROPERTIES     | \
                                         MQSEC_GET_MACHINE_PERMISSIONS    | \
                                         MQSEC_SET_MACHINE_PROPERTIES     | \
                                         MQSEC_CHANGE_MACHINE_PERMISSIONS | \
                                         MQSEC_CREATE_QUEUE)
//
// Site security flags
//
#define MQSEC_CREATE_FRS                    0x1
#define MQSEC_CREATE_BSC                    0x2
#define MQSEC_CREATE_MACHINE                0x4
#define MQSEC_SET_SITE_PROPERTIES           0x10
#define MQSEC_GET_SITE_PROPERTIES           0x20
#define MQSEC_DELETE_SITE                   DELETE
#define MQSEC_GET_SITE_PERMISSIONS          READ_CONTROL
#define MQSEC_CHANGE_SITE_PERMISSIONS       WRITE_DAC
#define MQSEC_TAKE_SITE_OWNERSHIP           WRITE_OWNER

#define MQSEC_SITE_GENERIC_READ             (MQSEC_GET_SITE_PROPERTIES | \
                                             MQSEC_GET_SITE_PERMISSIONS)

#define MQSEC_SITE_GENERIC_WRITE            (MQSEC_GET_SITE_PROPERTIES | \
                                             MQSEC_GET_SITE_PERMISSIONS | \
                                             MQSEC_CREATE_MACHINE)

#define MQSEC_SITE_GENERIC_EXECUTE          0

#define MQSEC_SITE_GENERIC_ALL              (MQSEC_CREATE_FRS | \
                                             MQSEC_CREATE_BSC | \
                                             MQSEC_CREATE_MACHINE | \
                                             MQSEC_SET_SITE_PROPERTIES | \
                                             MQSEC_GET_SITE_PROPERTIES | \
                                             MQSEC_DELETE_SITE | \
                                             MQSEC_GET_SITE_PERMISSIONS | \
                                             MQSEC_CHANGE_SITE_PERMISSIONS | \
                                             MQSEC_TAKE_SITE_OWNERSHIP)

//
// CN security flags
//
#define MQSEC_CN_OPEN_CONNECTOR             0x1
#define MQSEC_SET_CN_PROPERTIES             0x10
#define MQSEC_GET_CN_PROPERTIES             0x20
#define MQSEC_DELETE_CN                     DELETE
#define MQSEC_GET_CN_PERMISSIONS            READ_CONTROL
#define MQSEC_CHANGE_CN_PERMISSIONS         WRITE_DAC
#define MQSEC_TAKE_CN_OWNERSHIP             WRITE_OWNER

#define MQSEC_CN_GENERIC_READ               (MQSEC_GET_CN_PROPERTIES | \
                                             MQSEC_GET_CN_PERMISSIONS)

#define MQSEC_CN_GENERIC_WRITE              (MQSEC_GET_CN_PROPERTIES | \
                                             MQSEC_GET_CN_PERMISSIONS)

#define MQSEC_CN_GENERIC_EXECUTE            0

#define MQSEC_CN_GENERIC_ALL                (MQSEC_CN_OPEN_CONNECTOR | \
                                             MQSEC_SET_CN_PROPERTIES | \
                                             MQSEC_GET_CN_PROPERTIES | \
                                             MQSEC_DELETE_CN | \
                                             MQSEC_GET_CN_PERMISSIONS | \
                                             MQSEC_CHANGE_CN_PERMISSIONS | \
                                             MQSEC_TAKE_CN_OWNERSHIP)
//
// Enterprise security flags
//
#define MQSEC_CREATE_USER                   0x1
#define MQSEC_CREATE_SITE                   0x2
#define MQSEC_CREATE_CN                     0x4
#define MQSEC_SET_ENTERPRISE_PROPERTIES     0x10
#define MQSEC_GET_ENTERPRISE_PROPERTIES     0x20
#define MQSEC_DELETE_ENTERPRISE             DELETE
#define MQSEC_GET_ENTERPRISE_PERMISSIONS    READ_CONTROL
#define MQSEC_CHANGE_ENTERPRISE_PERMISSIONS WRITE_DAC
#define MQSEC_TAKE_ENTERPRISE_OWNERSHIP     WRITE_OWNER

#define MQSEC_ENTERPRISE_GENERIC_READ       (MQSEC_CREATE_USER | \
                                             MQSEC_GET_ENTERPRISE_PROPERTIES | \
                                             MQSEC_GET_ENTERPRISE_PERMISSIONS)

#define MQSEC_ENTERPRISE_GENERIC_WRITE      (MQSEC_CREATE_USER | \
                                             MQSEC_GET_ENTERPRISE_PROPERTIES | \
                                             MQSEC_GET_ENTERPRISE_PERMISSIONS | \
                                             MQSEC_CREATE_SITE | \
                                             MQSEC_CREATE_CN | \
                                             MQSEC_CREATE_USER)

#define MQSEC_ENTERPRISE_GENERIC_EXECUTE    0

#define MQSEC_ENTERPRISE_GENERIC_ALL        (MQSEC_CREATE_USER | \
                                             MQSEC_CREATE_CN | \
                                             MQSEC_CREATE_SITE | \
                                             MQSEC_SET_ENTERPRISE_PROPERTIES | \
                                             MQSEC_GET_ENTERPRISE_PROPERTIES | \
                                             MQSEC_DELETE_ENTERPRISE | \
                                             MQSEC_GET_ENTERPRISE_PERMISSIONS | \
                                             MQSEC_CHANGE_ENTERPRISE_PERMISSIONS | \
                                             MQSEC_TAKE_ENTERPRISE_OWNERSHIP)

#endif // __MQSEC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\mqspx.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    mqspx.h

Abstract:

    SPX definitions

--*/

#ifndef __MQSPX_H__
#define __MQSPX_H__



RPC_STATUS spx_get_host_by_name( 
                                 SOCKADDR_IPX * netaddr,
                          IN OUT int *        count,
                                 char* host,
                                 int        protocol,
                                 unsigned   Timeout,
                                 unsigned * CacheTime);

RPC_STATUS InitializeSpxCache();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\mqtime.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    mqtime.h

Abstract:

    This header file contains definitions for message queue time handeling.

Author:

    Boaz Feldbaum (BoazF) 17 Jul, 1996

--*/

#ifndef _MQTIME_H_
#define _MQTIME_H_

/**************************************************************

  Function:
        MqSysTime

  Parameters:
        None.

  Description:
        The function returns the number of seconds passed from 
        January 1, 1970. 
        
        This function replaces the CRT function time(). time() 
        returns a different result during day light saving 
        time, depending on whether or not the system is set to 
        automatically adjust the time acording to the day light
        saving time period. 

**************************************************************/
inline ULONG MqSysTime()
{
    LARGE_INTEGER liSysTime;

    // Get the current system time in FILETIME format.
    GetSystemTimeAsFileTime((FILETIME*)&liSysTime);

    // GetSystemTimeAsFileTime() returns the system time in number 
    // of 100-nanosecond intervals since January 1, 1601. We
    // should return the number of seconds since January 1, 1970.
    // So we should subtract the number of 100-nanosecond intervals
    // since January 1, 1601 up until January 1, 1970, then divide
    // the result by 10**7.
    liSysTime.QuadPart -= 0x019db1ded53e8000;
    liSysTime.QuadPart /= 10000000;

    return(liSysTime.LowPart);
}

#endif // _MQTIME_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\mqupgrd.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    mqupgrd.h

Abstract:

    header for functions exported from  mqupgrd.dll

Author:

    Shai Kariv  (ShaiK)  21-Oct-98

--*/


#ifndef _MQUPGRD_H
#define _MQUPGRD_H

typedef HRESULT
    (APIENTRY *pfCreateMsmqObj_ROUTINE) (VOID);

typedef VOID (APIENTRY *RemoveStartMenuShortcuts_ROUTINE) (VOID);

typedef VOID (APIENTRY *CleanupOnCluster_ROUTINE) (LPCWSTR);

#endif //_MQUPGRD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\mqtg.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    mqtrig.h

Abstract:
    MSMQ trigger, constant value

Author:
    Uri Habusha (urih) 26-Jun-2000

--*/

#pragma once

#ifndef __MQTRIG_H__
#define __MQTRIG_H__


const TCHAR xDefaultTriggersServiceName[] = L"MSMQTriggers";
const TCHAR xTriggersResourceType[] = L"MSMQTriggers";

const WCHAR xTriggersComplusApplicationName[] = L"MQTriggersApp";

const TCHAR xDefaultTriggersDisplayName[] = L"Message Queueing Triggers";

// Registry keys
#define REGKEY_TRIGGER_POS                 HKEY_LOCAL_MACHINE
const TCHAR REGKEY_TRIGGER_PARAMETERS[] = _T("Software\\Microsoft\\MSMQ\\Triggers");
const TCHAR REG_SUBKEY_CLUSTERED[] = _T("\\Clustered\\");
const TCHAR REG_SUBKEY_RULES[] = _T("\\Data\\Rules\\");
const TCHAR REG_SUBKEY_TRIGGERS[] = _T("\\Data\\Triggers\\");
const TCHAR REGISTRY_TRIGGER_MSG_PROCESSING_TYPE[] = _T("MsgProcessingType");


// Define the maximum size of a registry key (255 Unicode chars + null)
#define MAX_REGKEY_NAME_SIZE 512


// Configuration parameters
const TCHAR CONFIG_PARM_NAME_INITIAL_THREADS[] = _T("InitialThreads");
const TCHAR CONFIG_PARM_NAME_MAX_THREADS[] = _T("MaxThreads");
const TCHAR CONFIG_PARM_NAME_INIT_TIMEOUT[]	= _T("InitTimeout");
const TCHAR CONFIG_PARM_NAME_DEFAULTMSGBODYSIZE[] = _T("DefaultMsgBodySize");
const TCHAR CONFIG_PARM_NAME_PRODUCE_TRACE_INFO[] = _T("ProduceTraceInfo");
const TCHAR CONFIG_PARM_NAME_WRITE_TO_LOGQ[] = _T("WriteToLogQueue");
const TCHAR CONFIG_PARM_NAME_COMPLUS_INSTALLED[] = _T("ComplusCompInstalled");


// Define default values for some of the configuration parameters.
const DWORD CONFIG_PARM_DFLT_INITIAL_THREADS  = 5;
const DWORD CONFIG_PARM_DFLT_MAX_THREADS = 20;
const DWORD CONFIG_PARM_DFLT_DEFAULTMSGBODYSIZE = 2048;
const DWORD CONFIG_PARM_DFLT_INIT_TIMEOUT = 5*60000;
const DWORD CONFIG_PARM_DFLT_WRITE_TO_LOGQ =  0;

const DWORD CONFIG_PARM_DFLT_COMPLUS_NOT_INSTALLED = 0;
const DWORD CONFIG_PARM_COMPLUS_INSTALLED = 1;


#ifdef _DEBUG
	const DWORD CONFIG_PARM_DFLT_PRODUCE_TRACE_INFO = 1;
#else
	const DWORD CONFIG_PARM_DFLT_PRODUCE_TRACE_INFO = 0;
#endif 

const DWORD xDefaultMsbBodySizeMaxValue = 4193000;  // (~ 4MB - 1000) 
const DWORD xMaxThreadNumber = 100;
const DWORD xMaxRuleNameLen = 128;
const DWORD xMaxRuleDescriptionLen = 255;
const DWORD xMaxRuleConditionLen = 512;
const DWORD xMaxRuleActionLen = 512;

//
// Define the delimiters used when expressing actions, conditions and conditional-values
//
const TCHAR xConditionDelimiter = _T('\t');
const TCHAR xActionDelimiter = _T('\t');

const TCHAR xConditionValueDelimiter = _T('=');
const TCHAR xActionValueDelimiter = _T('\t');

const TCHAR xCOMAction[] = _T("COM");
const TCHAR xEXEAction[] = _T("EXE");

// Define the constants that will be used to set the rule result flag
const LONG xRuleResultStopProcessing	= 1;
const LONG xRuleResultActionExecutedFailed = 2;


enum eConditionTypeId
{
    eMsgLabelContains = 0,
    eMsgLabelDoesNotContain,
    eMsgBodyContains,
    eMsgBodyDoesNotContain,
    ePriorityEquals,
    ePriorityNotEqual,
    ePriorityGreaterThan,
    ePriorityLessThan,
    eAppspecificEquals,
    eAppspecificNotEqual,
    eAppSpecificGreaterThan,
    eAppSpecificLessThan,
    eSrcMachineEquals,
    eSrcMachineNotEqual,
};

const _bstr_t xConditionTypes[] = {
    _T("$MSG_LABEL_CONTAINS"),
    _T("$MSG_LABEL_DOES_NOT_CONTAIN"),
    _T("$MSG_BODY_CONTAINS"),
    _T("$MSG_BODY_DOES_NOT_CONTAIN"),
    _T("$MSG_PRIORITY_EQUALS"),
    _T("$MSG_PRIORITY_NOT_EQUAL"),
    _T("$MSG_PRIORITY_GREATER_THAN"),
    _T("$MSG_PRIORITY_LESS_THAN"),
    _T("$MSG_APPSPECIFIC_EQUALS"),
    _T("$MSG_APPSPECIFIC_NOT_EQUAL"),
    _T("$MSG_APPSPECIFIC_GREATER_THAN"),
    _T("$MSG_APPSPECIFIC_LESS_THAN"),
    _T("$MSG_SRCMACHINEID_EQUALS"),
    _T("$MSG_SRCMACHINEID_NOT_EQUAL"),
};


//
// Define the bstrs that represents message and / or trigger attributes
//
enum eInvokeParameters
{
    eMsgId = 0,
    eMsgLabel,
    eMsgBody,
    eMsgBodyAsString,
    eMsgPriority,
    eMsgArrivedTime,
    eMsgSentTime,
    eMsgCorrelationId,
    eMsgAppspecific,
    eMsgQueuePathName,
    eMsgQueueFormatName,
    eMsgRespQueueFormatName,
    eMsgDestQueueFormatName,
    eMsgAdminQueueFormatName,
    eMsgSrcMachineId,
    eMsgLookupId,
    eTriggerName,
    eTriggerId,
    eLiteralString,
    eLiteralNumber,
};

const _bstr_t xIvokeParameters[] = {
    _T("$MSG_ID"),
    _T("$MSG_LABEL"),
    _T("$MSG_BODY"),
    _T("$MSG_BODY_AS_STRING"),
    _T("$MSG_PRIORITY"),
    _T("$MSG_ARRIVEDTIME"),
    _T("$MSG_SENTTIME"),
    _T("$MSG_CORRELATION_ID"),
    _T("$MSG_APPSPECIFIC"),
    _T("$MSG_QUEUE_PATHNAME"),
    _T("$MSG_QUEUE_FORMATNAME"),
    _T("$MSG_RESPONSE_QUEUE_FORMATNAME"),
    _T("$MSG_DEST_QUEUE_FORMATNAME"),
    _T("$MSG_ADMIN_QUEUE_FORMATNAME"),
    _T("$MSG_SRCMACHINEID"),
    _T("$MSG_LOOKUP_ID"),
    _T("$TRIGGER_NAME"),
    _T("$TRIGGER_ID"),
};


#endif // __MQTRIG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\mqversion.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    mqversion.h

Abstract:

    MSMQ product version as returned by MSMQ API

Author:

    Shai Kariv (shaik) 24-Apr-2001

--*/

#ifndef _MQ_VERSION_H_
#define _MQ_VERSION_H_

//
// MSMQ major version as returned by MSMQ API
//
#define MSMQ_RMJ 3

//
// MSMQ minor version as returned by MSMQ API
//
#define MSMQ_RMM 0

#endif // _MQ_VERSION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\mqwin64a.h ===
/*--

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    mqwin64a.h

Abstract:

    win64 related definitions for MSMQ (Basic), suitable for AC as well

History:

    Raanan Harari (raananh) 30-Dec-1999 - Created for porting MSMQ 2.0 to win64

--*/

#pragma once

#ifndef _MQWIN64A_H_
#define _MQWIN64A_H_

#include <basetsd.h>

//
// Low and High dwords of DWORD64
//
#define HIGH_DWORD(dw64) PtrToUlong((void*)((DWORD64)(dw64) >> 32))
#define LOW_DWORD(dw64)  PtrToUlong((void*)((DWORD64)(dw64) & (DWORD64)0xffffffff))

//
// MQPtrToUlong, wrapper for PtrToUlong, just for debugging
//
#ifdef DEBUG
//
// in DEBUG, we may want to see the DWORD64 value after an ASSERT jumps, so we convert the
// value in a function. It cannot be inline, if it is, the compiler complains in the macro
// UINT64_TO_UINT below
// Make sure high dword is 0, or a sign extension of low dword
//
inline unsigned long MQPtrToUlong(UINT64 uintp)
{
  ASSERT((HIGH_DWORD(uintp) == 0) ||
                 ((HIGH_DWORD(uintp) == 0xffffffff) && ((INT)LOW_DWORD(uintp) < 0))
        );
  return PtrToUlong((void *)uintp);
}
#else //!DEBUG
//
// just define MQPtrToUlong as a macro, anyway we would not be able to view the 64 bit value
//
#define MQPtrToUlong(uintp) PtrToUlong((void *)(uintp))
#endif //DEBUG

//
// Safe truncations from 64 bit to 32 bit
//
#define UINT64_TO_UINT(uintp)    MQPtrToUlong((UINT64)(uintp))
#define INT64_TO_INT(intp)       ((INT)UINT64_TO_UINT(intp))

//
// INT_PTR_TO_INT, UINT_PTR_TO_UINT
//
#ifdef _WIN64
//
// Win64, xxx_PTR are 64 bits, truncate to 32 bit
//
#define INT_PTR_TO_INT(intp)     INT64_TO_INT(intp)
#define UINT_PTR_TO_UINT(uintp)  UINT64_TO_UINT(uintp)
#else //!_WIN64
//
// Win32, xxx_PTR are 32 bits, no truncations needed
//
#define INT_PTR_TO_INT(intp) (intp)
#define UINT_PTR_TO_UINT(uintp) (uintp)
#endif //_WIN64

//
// BOOL_PTR
//
#ifndef BOOL_PTR
#define BOOL_PTR INT_PTR
#endif //BOOL_PTR

//
// DWORD_PTR_TO_DWORD
//
#define DWORD_PTR_TO_DWORD(dwp) UINT_PTR_TO_UINT(dwp)

//
// DWORD_TO_DWORD_PTR
//
#define DWORD_TO_DWORD_PTR(dw) ((DWORD_PTR)(UlongToPtr((DWORD)(dw))))

//
// HANDLE_TO_DWORD
// NT handles can be safely cast to 32 bit DWORD
//
#define HANDLE_TO_DWORD(hndl) DWORD_PTR_TO_DWORD(hndl)

//
// DWORD_TO_HANDLE
// from 32 bit DWORD back to NT handle (need to sign extend the dword)
//
#define DWORD_TO_HANDLE(dw) LongToPtr((long)(dw))

//
// MQLoWord, wrapper for LOWORD, just for debugging
//
#ifdef DEBUG
//
// in DEBUG, we may want to see the DWORD value after an ASSERT jumps, so we convert the
// value in a function. It cannot be inline, if it is, the compiler complains in the macro
// DWORD_TO_WORD below
// Make sure high word is 0, or a sign extension of low word
//
inline WORD MQLoWord(DWORD dw)
{
  ASSERT((HIWORD(dw) == 0) ||
                 ((HIWORD(dw) == 0xffff) && ((SHORT)LOWORD(dw) < 0))
         );
  return LOWORD(dw);
}
#else //!DEBUG
//
// just define MQLoWord as a macro, anyway we would not be able to view the DWORD value
//
#define MQLoWord(dw) LOWORD(dw)
#endif //DEBUG

//
// DWORD_TO_WORD
// Not really related to 64 bit, but needed to remove some warnings
// Safe truncations from 32 bit to 16 bit
//
#define DWORD_TO_WORD(dw) MQLoWord(dw)

//
// TIME32 - 32 bit time (what used to be time_t in win32). BUGBUG bug year 2038
//
#ifndef TIME32
#ifdef _WIN64
#define TIME32 long
#else //!_WIN64
#define TIME32 time_t
#endif //_WIN64
#else //TIME32
#error TIME32 already defined
#endif //TIME32

//
// HACCursor32 - 32 bit AC Cursor (used to be HANDLE in win32)
//
#ifdef _WIN64
#define HACCursor32 ULONG
#else //!_WIN64
#define HACCursor32 HANDLE
#endif //_WIN64

//
// HANDLE32 - 32 bit handle (what used to be HANDLE in win32)
//
#ifndef HANDLE32
#ifdef _WIN64
#define HANDLE32 long
#else //!_WIN64
#define HANDLE32 HANDLE
#endif //_WIN64
#else //HANDLE32
#error HANDLE32 already defined
#endif //HANDLE32


//
// PTR_TO_PTR32
// Truncate PTR32 to PTR
//
#ifdef _WIN64
template <class T>
inline T* POINTER_32 PTR_TO_PTR32(T* pT)
{
  return (T* POINTER_32)(INT_PTR_TO_INT(pT));
}
#endif //_WIN64

//
// ComparePointersAVL (positive if p1 > p2, negative if p1 < p2, zero if p1 == p2)
//
inline int ComparePointersAVL(PVOID p1, PVOID p2)
{
#ifdef _WIN64
   INT_PTR iDiff = (INT_PTR)p1 - (INT_PTR)p2;
   if (iDiff > 0)        //p1 > p2
   {
      return 1;
   }
   else if (iDiff < 0)   //p1 < p2
   {
      return -1;
   }
   else //iDiff == 0       p1 == p2
   {
      return 0;
   }
#else //!_WIN64
   return ((int)p1 - (int)p2);
#endif //_WIN64
}

//
// VT_INTPTR, V_INTPTR, V_INTPTR_REF
//
#ifdef _WIN64
#define VT_INTPTR        VT_I8
#define V_INTPTR(X)      V_I8(X)
#define V_INTPTR_REF(X)  V_I8REF(X)
#else //!_WIN64
#define VT_INTPTR        VT_I4
#define V_INTPTR(X)      V_I4(X)
#define V_INTPTR_REF(X)  V_I4REF(X)
#endif //_WIN64

#endif //_MQWIN64A_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\mqwin64.cpp ===
/*--

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    mqwin64.cpp

Abstract:

    win64 related code for MSMQ (Enhanced), cannot be part of AC
    this file needs to be included once for inside a module that uses the functions below

History:

    Raanan Harari (raananh) 30-Dec-1999 - Created for porting MSMQ 2.0 to win64

--*/

#ifndef _MQWIN64_CPP_
#define _MQWIN64_CPP_

#pragma once

#include <mqwin64.h>

//
// We have code that needs the name of this file for logging (also in release build)
//
const WCHAR s_FN_MQWin64_cpp[] = L"mqwin64.cpp";

//
// Several wrappers to CContextMap that also do MSMQ logging, exception handling etc...
//
// Not inline because they may be called from a function with a different
// exception handling mechanism. We might want to introduce _SEH functions for use from SEH routines
//

//
// external function for logging
//
#ifdef _WIN64
	extern void LogIllegalPointValue(DWORD64 dw64, LPCWSTR wszFileName, USHORT usPoint);
#else
	extern void LogIllegalPointValue(DWORD dw, LPCWSTR wszFileName, USHORT usPoint);
#endif

//
// MQ_AddToContextMap, can throw bad_alloc
//
DWORD MQ_AddToContextMap(CContextMap& map,
                          PVOID pvContext,
                          LPCWSTR s_FN,
                          USHORT usPoint
#ifdef DEBUG
                          ,LPCSTR pszFile, int iLine
#endif //DEBUG
                         )
{
    DWORD dwContext;
    ASSERT(pvContext != NULL);
    try
    {
        dwContext = map.AddContext(pvContext
#ifdef DEBUG
                                   , pszFile, iLine
#endif //DEBUG
                                  );
    }
    catch(...)
    {
        ASSERT(0);
        //
        // log this point
        //
        LogIllegalPointValue(
#ifdef _WIN64
						(DWORD64)pvContext,
#else
						(DWORD)pvContext,
#endif //_WIN64
						s_FN_MQWin64_cpp, 
						10);
        //
        // log caller's point
        //
        LogIllegalPointValue(
#ifdef _WIN64
						(DWORD64)pvContext,
#else
						(DWORD)pvContext,
#endif //_WIN64
						s_FN, 
						usPoint);
        //
        // re-throw the exception
        //
        throw;        
    }
    //
    // everything is OK, return context dword
    //
    ASSERT(dwContext != 0);
    return dwContext;
}

//
// MQ_DeleteFromContextMap, doesn't throw exceptions
//
void MQ_DeleteFromContextMap(CContextMap& map,
                              DWORD dwContext,
                              LPCWSTR s_FN,
                              USHORT usPoint)
{
    try
    {
        map.DeleteContext(dwContext);
    }
    catch(...)
    {
        ASSERT_BENIGN(0);
        //
        // log this point
        //
        LogIllegalPointValue(dwContext, s_FN_MQWin64_cpp, 20);
        //
        // log caller's point
        //
        LogIllegalPointValue(dwContext, s_FN, usPoint);
        //
        // swallow the exception, we can continue working even if delete wasn't successfull
        //
    }
}

//
// MQ_GetFromContextMap, can throw CContextMap::illegal_index
//
PVOID MQ_GetFromContextMap(CContextMap& map,
                            DWORD dwContext,
                            LPCWSTR s_FN,
                            USHORT usPoint)
{
    PVOID pvContext;
    try
    {
        pvContext = map.GetContext(dwContext);
    }
    catch(...)
    {
        ASSERT_BENIGN(0);
        //
        // log this point
        //
        LogIllegalPointValue(dwContext, s_FN_MQWin64_cpp, 30);
        //
        // log caller's point
        //
        LogIllegalPointValue(dwContext, s_FN, usPoint);
        //
        // re-throw the exception
        //
        throw;
    }
    //
    // everything is OK, return context ptr
    //
    ASSERT(pvContext != NULL);
    return pvContext;    
}

#endif //_MQWIN64_CPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\mqutil.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    mqutils.h

Abstract:

    Falcon helper functions and utilities

Author:

    Erez Haba (erezh) 16-Jan-96

Revision History:
--*/

#ifndef __MQUTILS_H
#define __MQUTILS_H

#include <mqsymbls.h>
#include <mqtypes.h>
#include <_guid.h>
#include <_propvar.h>
#include <_rstrct.h>
#include <_registr.h>
#include <_secutil.h>
#include <unknwn.h>
#include <cs.h>
#include <autorel.h>

MQUTIL_EXPORT CCriticalSection *GetRegCS(); // publishes the CS for QM usage

MQUTIL_EXPORT
HRESULT
XactGetDTC(
    IUnknown **ppunkDtc,
    ULONG     *pcbTmWhereabouts,
    BYTE     **ppbTmWhereabouts
    );

HRESULT 
MQUTIL_EXPORT 
APIENTRY 
GetComputerNameInternal( 
    WCHAR * pwcsMachineName,
    DWORD * pcbSize
    );

HRESULT 
MQUTIL_EXPORT 
APIENTRY 
GetComputerDnsNameInternal( 
    WCHAR * pwcsMachineDnsName,
    DWORD * pcbSize
    );

bool
MQUTIL_EXPORT
APIENTRY
IsLocalSystemCluster(
    VOID
    );

HRESULT MQUTIL_EXPORT GetThisServerIpPort( WCHAR * pwcsIpEp, DWORD dwSize);

//
// Close debug window and debug threads
//
VOID APIENTRY ShutDownDebugWindow(VOID);
typedef VOID (APIENTRY *ShutDownDebugWindow_ROUTINE) (VOID);


//
// MQUTIL_EXPORT_IN_DEF_FILE
// Exports that are defined in a def file should not be using __declspec(dllexport)
//  otherwise the linker issues a warning
//
#ifdef _MQUTIL
#define MQUTIL_EXPORT_IN_DEF_FILE
#else
#define MQUTIL_EXPORT_IN_DEF_FILE  DLL_IMPORT
#endif

extern "C" DWORD  MQUTIL_EXPORT_IN_DEF_FILE APIENTRY MSMQGetOperatingSystem();
extern "C" LPWSTR MQUTIL_EXPORT_IN_DEF_FILE APIENTRY MSMQGetQMTypeString();
typedef LPWSTR  (APIENTRY *MSMQGetQMTypeString_ROUTINE)           (VOID);
typedef DWORD   (APIENTRY *MSMQGetOperatingSystem_ROUTINE)        (VOID);

//
// BugBug: these two definitions are copied to setup\dll\stdafx.h
//
typedef DWORD (*GetQMOperatingSystem_ROUTINE)();

#endif // __MQUTILS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\mqwin64.h ===
/*--

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    mqwin64.h

Abstract:

    win64 related definitions for MSMQ (Enhanced), CANNOT be part of AC

History:

    Raanan Harari (raananh) 30-Dec-1999 - Created for porting MSMQ 2.0 to win64

--*/

#ifndef _MQWIN64_H_
#define _MQWIN64_H_

#pragma once

#include <mqwin64a.h>

//
// we have code that needs the name of this file for logging (also in release build)
//
extern const __declspec(selectany) WCHAR s_FN_MQWin64[] = L"mqwin64.h";


//
// CAutoCloseHandle32
// on win64 it is much like CAutoCloseHandle, just based on HANDLE32 instead of HANDLE
// on win32 it is defined as to CAutoCloseHandle
//
#ifdef _WIN64
class CAutoCloseHandle32
{
public:
    CAutoCloseHandle32(HANDLE32 h = NULL) { m_h = h; };
    ~CAutoCloseHandle32() { if (m_h) CloseHandle(DWORD_TO_HANDLE(m_h)); };

public:
    CAutoCloseHandle32 & operator =(HANDLE32 h) {m_h = h; return *this; };
    HANDLE32 * operator &() { return &m_h; };
    operator HANDLE32() { return m_h; };
    operator HANDLE() { return DWORD_TO_HANDLE(m_h); };

private:
    HANDLE32 m_h;
};
#else //!_WIN64
#define CAutoCloseHandle32 CAutoCloseHandle
#endif //_WIN64

//
// mapping between a PTR and DWORD
//
#include <cs.h>

//
// the mapped DWORD looks like this:
// 0xABCDEFGH, where 0x00ABCDEF is the index into the mapping table, 0xGH is the generation of the entry
// The generation of the entry is incremented each time an entry is re-used (unless the table is shrinked,
// in which case when it grows up, it starts again with a zero generation), so that we can tell for
// a mapped DWORD whether it is still valid (e.g. belongs to the current generation), or an invalid DWORD
// (e.g. belongs to another generation)
//
#define DWCONTEXT_GENERATION(dwContext)      (BYTE)((DWORD)(dwContext) & 0x000000ff)
#define DWCONTEXT_INDEX(dwContext)           (DWORD)((DWORD)(dwContext) >> 8)
#define MAKE_DWCONTEXT(dwIndex, bGeneration) (DWORD)(((DWORD)(dwIndex) << 8) + (BYTE)((DWORD)(bGeneration) & 0x000000ff))
#define NEXT_GENERATION(bGeneration)         (BYTE)((DWORD)(bGeneration + 1) & 0x000000ff)
#define MAX_DWCONTEXT_TABLE_SIZE             0x00ffffff

//
// class CContextMap - Map between PVOID ptr and a DWORD value
//
class CContextMap
{
public:
    //
    //exceptions thrown
    //bad_alloc can also be thrown (from AddContext)
    //
    struct illegal_index : public std::exception {};  //CContextMap::illegal_index, from GetContext/DeleteContext.
														  // this can be thrown when the index is out of bounds, bad generation, 
														  // or the context pointed by it is empty (NULL).

    //
    // the functions are not defined virtual, but they can be if someone needs to inherit
    // from this class...there is no core problem regarding it, just need to remove the inline def from 
    // the function implementation
    //
    CContextMap();
    /*virtual*/ ~CContextMap();
    /*virtual*/ DWORD AddContext(PVOID pvContext
#ifdef DEBUG
                                 ,LPCSTR pszFile, int iLine
#endif //DEBUG
                                );
    /*virtual*/ PVOID GetContext(DWORD dwContext);
    /*virtual*/ void DeleteContext(DWORD dwContext);

protected:

    //
    // allocation control:
    //   e_GrowSize must be a power of 2
    //   e_ShrinkSize must be greater than e_GrowSize.
    //      if there are more than e_ShrinkSize empty entries at the end of the table, tha table is shortened
    // BUGBUG - need to come up with a better allocation/free mechanism that is not exponential in nature
    //
    enum {
        e_GrowSize = 16,
        e_ShrinkSize = 24
    };

    //
    // Entry in Map
    //
    typedef struct {
        PVOID pvContext;
        BYTE bGeneration;
#ifdef DEBUG
        LPCSTR pszFile;
        int iLine;
#endif //DEBUG
    } ContextEntry;

    /*virtual*/ ContextEntry * FindContext(DWORD dwContext);
    /*virtual*/ void Grow();
    /*virtual*/ void Shrink();
    /*virtual*/ void Reallocate(ULONG cContexts);

private:
    ULONG m_cContexts;
    ULONG m_idxTop;
    ContextEntry* m_pContexts;    
    ULONG m_cUsedContexts;
    CCriticalSection m_cs;
};

inline CContextMap::CContextMap()
{
    m_idxTop = 0;
    m_pContexts = NULL;
    m_cContexts = 0;
    m_cUsedContexts = 0;
}

inline CContextMap::~CContextMap()
{
	//
	// Note: these asserts are not necessary. There are possible situations
	// where the map is not empty on distruction. For example - when there are open
	// remote queues, and the service goes down.
	//
    //ASSERT(m_idxTop == 0);
    //ASSERT(m_cUsedContexts == 0);
    
	delete [] m_pContexts;
}

//
// AddContext
// returns a DWORD for the context ptr (actually its index in a table (1-based, not zero-based))
// throws a bad_alloc exception if it can't add the context ptr
//
inline DWORD CContextMap::AddContext(PVOID pvContext
#ifdef DEBUG
                              ,LPCSTR pszFile, int iLine
#endif //DEBUG
                              )
{
    ASSERT(pvContext != 0);
    CS lock(m_cs);
    //
    //  First look at top index
    //
    if(m_idxTop < m_cContexts)
    {
        ContextEntry * pEntry = &m_pContexts[m_idxTop];
        pEntry->pvContext = pvContext;
#ifdef DEBUG
        ASSERT(pEntry->pszFile == NULL);
        ASSERT(pEntry->iLine == 0);
        pEntry->pszFile = pszFile;
        pEntry->iLine = iLine;
#endif //DEBUG
        m_cUsedContexts++;
        m_idxTop++;
        return MAKE_DWCONTEXT(m_idxTop, pEntry->bGeneration);
    }
    //
    //  Look for a hole in the already allocated table
    //
    if (m_cUsedContexts < m_cContexts)
    {
        for(ULONG idx = 0; idx < m_cContexts; idx++)
        {
           if(m_pContexts[idx].pvContext == NULL)
           {
               ContextEntry * pEntry = &m_pContexts[idx];
               pEntry->pvContext = pvContext;
#ifdef DEBUG
               ASSERT(pEntry->pszFile == NULL);
               ASSERT(pEntry->iLine == 0);
               pEntry->pszFile = pszFile;
               pEntry->iLine = iLine;
#endif //DEBUG
               m_cUsedContexts++;
               return MAKE_DWCONTEXT(idx + 1, pEntry->bGeneration);
           }
        }
        //
        // we should not get here, we must find a hole when m_cUsedContexts < m_cContexts
        //
        ASSERT(0);
    }
    //
    //  No free entry, grow the table
    //
    Grow(); //this can throw bad_alloc
    ASSERT(m_idxTop < m_cContexts);
    //
    //  Fill top index
    //
    ContextEntry * pEntry = &m_pContexts[m_idxTop];
    pEntry->pvContext = pvContext;
#ifdef DEBUG
    ASSERT(pEntry->pszFile == NULL);
    ASSERT(pEntry->iLine == 0);
    pEntry->pszFile = pszFile;
    pEntry->iLine = iLine;
#endif //DEBUG
    m_cUsedContexts++;
    m_idxTop++;
    return MAKE_DWCONTEXT(m_idxTop, pEntry->bGeneration);
}

//
// GetContext
// returns the PVOID ptr that is saved for the DWORD context
// throws a CContextMap::illegal_index exception if it can't find the context ptr
//
inline PVOID CContextMap::GetContext(DWORD dwContext)
//
//
{
    CS lock(m_cs);
    //
    // Find context entry
    //
    ContextEntry * pEntry = FindContext(dwContext); //this may throw
    return pEntry->pvContext;
}

//
// DeleteContext
// deletes the PVOID ptr that is saved for the DWORD context
// throws a CContextMap::illegal_index exception if it can't find the context ptr
//
inline void CContextMap::DeleteContext(DWORD dwContext)
{
    CS lock(m_cs);
    //
    // Find context entry
    //
    ContextEntry * pEntry = FindContext(dwContext); //this may throw
    //
    // delete the reference
    // increment the generation in preparation for entry re-use later
    //
    pEntry->pvContext = NULL;
    pEntry->bGeneration = NEXT_GENERATION(pEntry->bGeneration);
#ifdef DEBUG
    pEntry->pszFile = NULL;
    pEntry->iLine = 0;
#endif //DEBUG
    m_cUsedContexts--;
    //
    // set new top
    //
    if (DWCONTEXT_INDEX(dwContext) == m_idxTop)
    {
        m_idxTop--;
        while (m_idxTop > 0)
        {
            if (m_pContexts[m_idxTop - 1].pvContext == NULL)
            {
                m_idxTop--;
            }
            else
            {
                break;
            }
        }
    }
    //
    // try to shrink
    //        
    Shrink();
}

inline CContextMap::ContextEntry * CContextMap::FindContext(DWORD dwContext)
{
    DWORD dwIndex = DWCONTEXT_INDEX(dwContext);
    //
    // check index valid
    //
    if ((dwIndex < 1) || (dwIndex > m_idxTop))
    {
        //
        // Illegal index, throw an exception
        //
        ASSERT_BENIGN(0);
        throw CContextMap::illegal_index();
    }
    CContextMap::ContextEntry * pEntry = &m_pContexts[dwIndex - 1];
    //
    //  check context generation
    //
    BYTE bGeneration = DWCONTEXT_GENERATION(dwContext);
    if (bGeneration != pEntry->bGeneration)
    {
        //
        // Invalid generation, dwContext uses a different generation than this entry, throw an exception
        //
        ASSERT_BENIGN(0);
        throw CContextMap::illegal_index();
    }
    //
    //  check context valid
    //
    if (pEntry->pvContext == NULL)
    {
        //
        // Illegal context.
        // Cannot differentiate illegal index from illegal context. illegal context can happen because of
        // an illegal index, and an illegal index can be caused by a deleted context (e.g. illegal context)
        // and the table being shortened.
        // throw an exception
        //
        ASSERT_BENIGN(0);
        throw CContextMap::illegal_index();
    }
    return pEntry;
}

inline void CContextMap::Grow()
{
    ASSERT(m_cUsedContexts == m_cContexts);
    ASSERT(m_idxTop == m_cContexts);
    Reallocate(m_cContexts + e_GrowSize); //this may throw
}

#define ALIGNUP_ULONG(x, g) (((ULONG)((x) + ((g)-1))) & ~((ULONG)((g)-1)))

inline void CContextMap::Shrink()
{
    if((m_cContexts - m_idxTop) >= e_ShrinkSize)
    {
        try
        {
            Reallocate(ALIGNUP_ULONG(m_idxTop + 1, e_GrowSize));
        }
        catch(const std::bad_alloc&)
        {
            //
            // allocation of smaller table failed, no problem, we can still use the existing larger table
            //
        }
    }
}

inline void CContextMap::Reallocate(ULONG cContexts)
{
    ASSERT(m_idxTop <= cContexts);
    ASSERT(cContexts != m_cContexts);
    //
    // check size of new table
    //
    if (cContexts > MAX_DWCONTEXT_TABLE_SIZE)
    {
        //
        // New table will be too large, indexes may not fit into the index mask in the mapped dword
        //
        ASSERT(0);
        throw std::bad_alloc();
    }
    //
    // alloc new table
    //
    ContextEntry* pContexts = new ContextEntry[cContexts]; //this may throw bad_alloc
    if(pContexts == NULL)
    {
        ASSERT(0);
        throw std::bad_alloc();
    }
    memcpy(pContexts, m_pContexts, m_idxTop*sizeof(ContextEntry));
    memset(pContexts + m_idxTop, 0, (cContexts - m_idxTop)*sizeof(ContextEntry));
    m_cContexts = cContexts;
    delete [] m_pContexts;
    m_pContexts = pContexts;
}

//
// Several wrappers to CContextMap that also do MSMQ logging, exception handling etc...
//
// Not inline because they may be called from a function with a different
// exception handling mechanism. We might want to introduce _SEH functions for use from SEH routines
// Implementation is in mqwin64.cpp
//

//
// MQ_AddToContextMap, can throw bad_alloc
//
DWORD MQ_AddToContextMap(CContextMap& map,
                          PVOID pvContext,
                          LPCWSTR s_FN,
                          USHORT usPoint
#ifdef DEBUG
                          ,LPCSTR pszFile, int iLine
#endif //DEBUG
                         );

//
// MQ_DeleteFromContextMap, doesn't throw exceptions
//
void MQ_DeleteFromContextMap(CContextMap& map,
                              DWORD dwContext,
                              LPCWSTR s_FN,
                              USHORT usPoint);

//
// MQ_GetFromContextMap, can throw CContextMap::illegal_index
//
PVOID MQ_GetFromContextMap(CContextMap& map,
                            DWORD dwContext,
                            LPCWSTR s_FN,
                            USHORT usPoint);

//
// ADD_TO_CONTEXT_MAP
//
//
// It adds a context ptr to a map, and returns its id as a DWORD
// On debug we also save the file/line with the context
//
#ifdef DEBUG
#define ADD_TO_CONTEXT_MAP(map, pvContext, s_FN, usPoint) MQ_AddToContextMap(map, pvContext, s_FN, usPoint, __FILE__, __LINE__)
#else //!DEBUG
#define ADD_TO_CONTEXT_MAP(map, pvContext, s_FN, usPoint) MQ_AddToContextMap(map, pvContext, s_FN, usPoint)
#endif //DEBUG


//
// DELETE_FROM_CONTEXT_MAP
//

//
// It deletes the mapping betweeb a DWORD and a context ptr, based on the dword value
//
#define DELETE_FROM_CONTEXT_MAP(map, dwContext, s_FN, usPoint) MQ_DeleteFromContextMap(map, dwContext, s_FN, usPoint)


//
// GET_FROM_CONTEXT_MAP
//
//
// It gets the associated context based on the DWORD id value
//
#define GET_FROM_CONTEXT_MAP(map, dwContext, s_FN, usPoint) MQ_GetFromContextMap(map, dwContext, s_FN, usPoint)


//
// CAutoDeleteDwordContext
//
class CAutoDeleteDwordContext
{
public:
    inline CAutoDeleteDwordContext(CContextMap &map, DWORD dwContext)
    {
        m_pmap = &map;
        m_dwContext = dwContext;
    };
    
    inline ~CAutoDeleteDwordContext()
    {
        if (m_dwContext)
        {
            try
            {
                m_pmap->DeleteContext(m_dwContext);
            }
            catch(...)
            {
                //
                // ignore errors
                //
            }
        }
    }

    inline DWORD detach()
    {
        DWORD dwContext = m_dwContext;
        m_dwContext = 0;
        return dwContext;
    };

private:
    CContextMap *m_pmap;
    DWORD m_dwContext;
};

#endif //_MQWIN64_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\perfctr.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name : perfctr.h

Abstract    :

This file defines the functions and data structers needed to add counter objects and counters to the
performance monitor.

The user will specify in advance the counter objects and their counters in an include file named perfdata.h

The counter objects will be stored in an  array.
For each counter object the user will specify :

    a) The name of the object.
    b) The maximum number of instances the object will have.
    c) The number of counters for the object.
    d) An array of counters for the object.
    e) The objects name index as specified in the .ini file that was passed to 'lodctr' utility.
    f) The objects help index as specified in the .ini file that was passed to 'lodctr' utility.


Counters will be stored in an array.
For each counter the user will supply the following entries:

    a) The counters name index as specified in the .ini file that was passed to 'lodctr' utility.
    b) The counters help index as specified in the .ini file that was passed to 'lodctr' utility.
    c) The scale for the counter (this value is the power of 10 that will be used to scale the counter)
    d) The counter type. Counter types can be found in winperf.h. Note that you can use only 32 Bit counters
       with this library.Also counters that need their own time measurement can not be used.


Data organization in shared memory of objects
Objects will be stored in a block of shared memory.
Each object will be allocated sapce in the shared memory block with the following organization;

PERF_OBJECT_TYPE (performance monitor definition of object counter)

    1 PERF_COUNTER_DEFINITION (performance monitor definition of counter)
    .
    .
    .
    N PERF_COUNTER_DEFINITION

    1 instance definition
        PERF_INSTANCE_DEFINITION (performance monitor definition of instance)
        Instance name
        PERF_COUNTER_BLOCK  (number of counters)
        Counter data -----> The user will be given a direct pointer to this array for fast updates

    2 instance definition
    .
    .
    .
    N instance definition

    This layout is the exact lay out that is passed to the performance monitor so when the DLL will be sampled
    all it will need to do is copy this definition for each object into the buffer passed by the performance
    monitor.

    To simplify the code all instance names will have a fixed length of INSTANCE_NAME_LEN characters
    Since the users access the counters directly we can't change the address of the counters.
    When an instance is deleted its entry will be filled with a INVALID_INSTANCE_CODE code.
    New allocations of instances will be added to the first free block.

    The functions which removes and add instances are protected by critical sections so multiple
    threads may be used to add and remove instances.

    There is include file named perfdata.h. In this file global data that is used by the application and the DLL
    is defined.After this file is modified the DLL should be recompiled.




Prototype   :

Author:

    Gadi Ittah (t-gadii)

--*/

#ifndef _PERFCTR_H_
#define _PERFCTR_H_


#include <winperf.h>

#define INSTANCE_NAME_LEN 64
#define INSTANCE_NAME_LEN_IN_BYTES (INSTANCE_NAME_LEN * sizeof(WCHAR))

#define IN
#define OUT

// some defiens used to signal the objects state
#define PERF_INVALID        0xFEFEFEFE
#define PERF_VALID          0xCECECECE

typedef struct _PerfCounterDef
{
    DWORD dwCounterNameTitleIndex;  // The counters name index
    DWORD dwCounterHelpTitleIndex;  // The counters help index (for the NT perforamce monitor this value is
                                    // identical to the name index)
    DWORD dwDefaultScale;           // The scale for the counter (in powers of 10)
    DWORD dwCounterType;            // The counter type.
} PerfCounterDef;

typedef struct _PerfObjectDef
{
   LPTSTR   pszName;                    // name of object must be uniqe
   DWORD    dwMaxInstances;             // the maximum number of instances this object will have
   DWORD    dwObjectNameTitleIndex;     // The objects name index.
   DWORD    dwObjectHelpTitleIndex;     // The objects help index.
   PerfCounterDef * pCounters;          // A pointer to the objects array of counters
   DWORD    dwNumOfCounters;            // The number of counters for the object

} PerfObjectDef;


typedef struct _PerfObjectInfo
{

   DWORD    dwNumOfInstances;   // the number of instances the object has
   PVOID    pSharedMem;         // A pointer to the objects postion in shared memory
} PerfObjectInfo;


// some macros to make code more readable

#define COUNTER_BLOCK_SIZE(NumCounters) sizeof (DWORD)* (NumCounters)+sizeof (PERF_COUNTER_BLOCK)

#define INSTANCE_SIZE(NumCounters) (sizeof (DWORD)* NumCounters+ \
                                    sizeof (PERF_COUNTER_BLOCK)+ \
                                    INSTANCE_NAME_LEN_IN_BYTES+  \
                                    sizeof (PERF_INSTANCE_DEFINITION))

#define OBJECT_DEFINITION_SIZE(NumCounters) (sizeof (PERF_OBJECT_TYPE)+\
                                             NumCounters*sizeof(PERF_COUNTER_DEFINITION))



// Functions that are used by the DLL and the application

void MapObjects (BYTE * pSharedMemBase,DWORD dwObjectCount,PerfObjectDef * pObjects,PerfObjectInfo * pObjectDefs);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\msmq.inc ===
############################################################################
#
#   Copyright (C) 2000, Microsoft Corporation.
#
#   All rights reserved.
#
#   This file contains default definitions for building the MSMQ project
#   under the NT build environment. It should be included into the sources
#   file of any component with a line of the form
#
#   !include $(FROOT)\src\inc\msmq.inc
#
############################################################################

#
# "C" functions can throw exceptions, don't optimize.
#
USER_C_FLAGS=$(USER_C_FLAGS) /EHc-

#
# Set highest warning level
#
MSC_WARNING_LEVEL=/W4

#
# Use the DLL version of the C runtime libraries
#
USE_MSVCRT=1

#
# Use C++ Standard Template Libraries
#
USE_STL=1

#
# Use C++ exception handling (/GX)
#
USE_NATIVE_EH=1

#
# Include all windows headers
#
NOT_LEAN_AND_MEAN=1

#
# Set compilation to Unicode
#
C_DEFINES=$(C_DEFINES) -DUNICODE -D_UNICODE

#
# Set to debug/checked build
#
!IF !$(FREEBUILD)
C_DEFINES=$(C_DEFINES) /D_DEBUG
!ENDIF

#
# Temporary set for checked builds
#
!IF !$(FREEBUILD)
C_DEFINES=$(C_DEFINES) /D_CHECKED
!ENDIF

#
# make dlldata.c file name prefixed by the name of the idl file.
#
USE_IDLBASED_DLLDATA=1

#
# Set MC flags so it gives unique names instead of MSG00001.bin (to avoid MP collisions)
#
MC_FLAGS=-b

#
# Set default location for pass 0 generated files.
# Use the same defaults as in inetsrv
#
MC_SOURCEDIR=$(O)
PASS0_HEADERDIR=$(O)
PASS0_CLIENTDIR=$(O)
PASS0_SERVERDIR=$(O)
PASS0_SOURCEDIR=$(O)
MIDL_TLBDIR=$(O)

#
# Generate browser file for check x86 builds
#
!IF !$(FREEBUILD) && $(386)
BROWSER_INFO=1
!ENDIF

!IF "$(MQBSC)" == ""
NO_BROWSER_FILE=1
!ENDIF

#
# When MQT is defined, build verbose version (with TALK compiled)
#
!IF "$(MQT)" != ""
C_DEFINES=$(C_DEFINES) /D_TOOL
!ENDIF

#
# The MSMQ libraries include path
#
MSMQ_LIBINC_PATH=$(FROOT)\src\lib\inc

#
# The MSMQ include path
#
MSMQ_INC_PATH=$(FROOT)\src\inc

#
# The MSMQ generated files path
#
MSMQ_BINS_PATH=$(FROOT)\src\bins\$(O)

#
# We need mfc42 for RC compilations that include afxres.h, however, we need it last so we can
# override it, that is why we don't use MFC_INCLUDES
#
# SDK_LIB_PATH is included to grant access to stdole32.tlb
#
INCLUDES=$(MSMQ_LIBINC_PATH);$(MSMQ_INC_PATH);$(MSMQ_BINS_PATH);$(SDK_LIB_PATH);$(SDK_INC_PATH)\mfc42

#
# We want to keep checked results in objd directory
#
CHECKED_ALT_DIR=1

#
# Genereate Codeview and NTSD debug information, make PDB files
#
NTDEBUGTYPE=both 
USE_PDB=1

#
# The MSMQ library path
#
MSMQ_LIB_PATH=$(FROOT)\src\lib\$(O)

#
# Set MSMQ version file
#
MASTER_VERSION_FILE=$(FROOT)\src\inc\version.h

#
# Set all-bins target directory
#
ALL_BINS=$(FROOT)\src\bins\$(_OBJ_DIR)

#
# Remove build noise with -D on header without .h suffix
#
CONDITIONAL_INCLUDES=\
    $(CONDITIONAL_INCLUDES) \
    new list map set algorithm string iostream vector sstream iomanip functional fstream limits utility \
    winwlm.h rpcmac.h rpcerr.h macpub.h macapi.h macname1.h macname2.h macocidl.h \
    ntamd64.h \

#
# Enable Wpp tracing porcessor
#
RUN_WPP=\
    $(SOURCES) \
    -noshrieks \
    -gen:{$(FROOT)\src\inc\msmqwpp.tpl}*.tmh \
    -ini:$(FROOT)\src\inc\msmqwpp.ini \
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\perfdata.h ===
//*********************************************************************
//*
//* perfdata.h
//*
//*********************************************************************

#ifndef _PERFDATA_H
#define _PERFDATA_H

#include <winperf.h>
#include "perfctr.h"


#include "mqprfsym.h" /* a file which holds the index's for the name's and help's (this is the same file
                        used in the .INI file for the lodctl utility */

/*
 * Maximum number of queues and sessions that can be monitored.
 *
 * 97 queues and 20 sessions sums up to just a little less than 16K (4 pages).
 * When modifying these constants, see that you use all the allocated pages
 * as much as possible.
 *
 * Use the following to calculate the required memmoey size:
 *
 *      NCQM -  Number of performance counters per QM object (9)
 *      S -     Number monitored of sessions (20)
 *      NCS -   Number of performance counters per session (8)
 *      Q -     Number of queues (97)
 *      NCQ -   Number of performance counters per queue (4)
 *      NCDS -  Number of performance counters per DS object (7)
 *
 *      MemSize = S*(NCS*4 + 108) + Q*(NCQ*4 + 108) + (NCS + NCQ)*40 +
 *                (MCQM + NCDS)*44 + 264
 *
 * Currently the above computes to 16276.
 *
 */
#define MAX_MONITORED_QUEUES    97
#define MAX_MONITORED_SESSIONS  20


/* The object array*/
extern PerfObjectDef ObjectArray [];
extern DWORD dwPerfObjectsCount;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\ph.h ===
/*++
               
Copyright (c) 1996  Microsoft Corporation

Module Name:

    ph.h

Abstract:

    Falcon Packet Header master include file

Author:

    Erez Haba (erezh) 5-Feb-96

Environment:

    Kerenl Mode, User Mode

--*/

#ifndef __PH_H
#define __PH_H

#include "limits.h"   // for UINT_MAX


/*+++

    Falcon Packet header sections order

+------------------------------+-----------------------------------------+----------+
| SECTION NAME                 | DESCRIPTION                             | SIZE     |
+------------------------------+-----------------------------------------+----------+
| Base                         | Basic packet info. Fixed size.          |  Fixed   |
+---------------+--------------+-----------------------------------------+----------+
| User          |              |                                         |          |
+---------------+              +-----------------------------------------+----------+
| Xact          |              |                                         |          |
+---------------+              +-----------------------------------------+----------+
| Security      |              |                                         |          |
+---------------+   Internal   +-----------------------------------------+----------+
| Properties    |              |                                         |          |
+---------------+              +-----------------------------------------+----------+
| Debug         |              |                                         |          |
+---------------+              +-----------------------------------------+----------+
| MQF           |              | MQF:  MSMQ 3.0 (Whistler) or higher.    |          |
+---------------+--------------+-----------------------------------------+----------+
| SRMP                         | SRMP: MSMQ 3.0 (Whistler) or higher.    |          |
+------------------------------+-----------------------------------------+----------+
| EOD                          | EOD:  MSMQ 3.0 (Whistler) or higher.    |          |
+------------------------------+-----------------------------------------+----------+
| SOAP                         | Write-only props, not sent on wire.     |          |
+------------------------------+-----------------------------------------+----------+
| Session                      |                                         |          |
+------------------------------+-----------------------------------------+----------+

---*/

//
//  Alignment on DWORD bounderies
//
#define ALIGNUP4_ULONG(x) ((((ULONG)(x))+3) & ~((ULONG)3))
#define ISALIGN4_ULONG(x) (((ULONG)(x)) == ALIGNUP4_ULONG(x))
#define ALIGNUP4_PTR(x) ((((ULONG_PTR)(x))+3) & ~((ULONG_PTR)3))
#define ISALIGN4_PTR(x) (((ULONG_PTR)(x)) == ALIGNUP4_PTR(x))

//
//  Alignment on USHORT bounderies
//
#define ALIGNUP2_ULONG(x) ((((ULONG)(x))+1) & ~((ULONG)1))
#define ISALIGN2_ULONG(x) (((ULONG)(x)) == ALIGNUP2_ULONG(x))
#define ALIGNUP2_PTR(x) ((((ULONG_PTR)(x))+1) & ~((ULONG_PTR)1))
#define ISALIGN2_PTR(x) (((ULONG_PTR)(x)) == ALIGNUP2_PTR(x))

void ReportAndThrow(LPCSTR ErrorString);


inline size_t mqwcsnlen(const wchar_t * s, size_t MaxSize)
{
	for (size_t size = 0; (size<MaxSize) && (*(s+size) !=L'\0') ; size++);

    ASSERT(("String length must be 32 bit max", size <= UINT_MAX));
    return size;
}


inline ULONG_PTR SafeAlignUp4Ptr(ULONG_PTR ptr)
{
	ULONG_PTR ret = ALIGNUP4_PTR(ptr);
	if (ret < ptr)
	{
		ReportAndThrow("SafeAlignUp4Ptr cause overflow");
	}
	return ret;
}


inline ULONG_PTR SafeAddPointers(int count, ULONG_PTR PtrArray[])
{
	ULONG_PTR oldSum, sum = 0;

	for (int j=0; j<count; j++)
	{
		oldSum = sum;
		sum += PtrArray[j];
		if (sum < oldSum)
		{
		    ReportAndThrow("SafeAddPointers cause overflow");
		}
	}
	return sum;
}


template <class T> void ChekPtrIsAlligned(const UCHAR* p)
/*
	Checks pointer allignment to the specified type.
*/
{
	if((ULONG_PTR)p % TYPE_ALIGNMENT(T) != 0)
	{
		ReportAndThrow("ChekPtrIsAlligned: pointer is not alligned for the given poindted type");		
	}
}


//
// template function to get data from buffer which need to be verified
// for bounderies first
//

template <class T> UCHAR * GetSafeDataAndAdvancePointer(
	const UCHAR  * pBuffer,
    const UCHAR  * pEnd,
    T* 			   pData
    )
{
	ChekPtrIsAlligned<T>(pBuffer);
	
	if ((pEnd != NULL) && (pBuffer > pEnd - sizeof(T)))
	{
        ReportAndThrow("GetSafeDataAndAdvancePointer: too small buffer to read from");
	}
	*pData = *(reinterpret_cast<const T*>(pBuffer));
	pBuffer += sizeof(T);
	return const_cast<UCHAR*>(pBuffer);
}


#include <_ta.h>
#include "qformat.h"
#include "phbase.h"
#include "phuser.h"
#include "phprop.h"
#include "phsecure.h"
#include "phxact.h"
#include "phdebug.h"
#include "phmqf.h"
#include "phmqfsign.h"
#include "phSrmpEnv.h"
#include "phCompoundMsg.h"
#include "pheod.h"
#include "pheodack.h"
#include "phSoap.h"

#endif // __PH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\phbase.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    phbase.h

Abstract:

    Falcon Packet header base

Author:

    Uri Habusha (urih) 1-Feb-96

--*/

#ifndef __PHBASE_H
#define __PHBASE_H

#include <mqprops.h>

//
// Packet Version
//
#define FALCON_PACKET_VERSION 0x10

#define FALCON_USER_PACKET     0x0
#define FALCON_INTERNAL_PACKET 0x1

//
//  BUGBUG: FALCON_SIGNATURE is none portable
//
#define FALCON_SIGNATURE       'ROIL'

//
//  define INFINITE for infinite timeout
//  It is defined here since it is not defined in the DDK
//  INFINITE is defined in winbase.h
//

#ifndef INFINITE
#define INFINITE            0xFFFFFFFF  // Infinite timeout
#endif

/*+++

    Packet Base header, used in INTERNAL and USER packets.

+----------------+-------------------------------------------------------+----------+
| FIELD NAME     | DESCRIPTION                                           | SIZE     |
+----------------+-------------------------------------------------------+----------+
| Version number | Version number is used to identify the  packet format.| 1 byte   |
+----------------+-------------------------------------------------------+----------+
|OnDisk Signature| Signature that is kept on disk only.                  | 1 bytes  |
+----------------+-------------------------------------------------------+----------+
| Flags          | The flag field is a bit map indicating                | 2 bytes  |
|                | format and inclusion of other data sections in        |          |
|                | the packet.                                           |          |
|                |                                                       |          |
|                |  1 1 1 1 1 1                                          |          |
|                |  5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0                      |          |
|                | +---------+-+---+-+-+-+-+-+-----+                     |          |
|                | |0 0 0 0 0|F|T T|R|A|D|S|I|P P P|                     |          |
|                | +---------+-+---+-+-+-+-+-+-----+                     |          |
|                |                                                       |          |
|                | Bits                                                  |          |
|                | 0:2      Packet priority (0 to 7,  7 is high)         |          |
|                |                                                       |          |
|                | 3        Internal packet                              |          |
|                |              0 - Falcon user packet                   |          |
|                |              1 - Falcon internal packet               |          |
|                |                                                       |          |
|                | 4        Session information indication               |          |
|                |              0 - not included                         |          |
|                |              1 - included                             |          |
|                |                                                       |          |
|                | 5        Debug section indication                     |          |
|                |              0 - not included                         |          |
|                |              1 - included                             |          |
|                |                                                       |          |
|                | 6        ACK on receiving.                            |          |
|                |              0 - No immediate ACK                     |          |
|                |              1 - immediate ACK                        |          |
|                |                                                       |          |
|                | 7        Reserved (was: Duplicate packet)             |          |
|                |              0 - No duplicate, first transmition.     |          |
|                |              1 - Possibly duplicate packet.           |          |
|                |                                                       |          |
|                | 8:9      Trace Packet                                 |          |
|                |              0 - Don't strore tracing information     |          |
|                |              1 - Strore tracing information           |          |
|                |                                                       |          |
|                | 10       Packet fragmentation                         |          |
|                |              0 - Packet is not a fragmented           |          |
|                |              1 - Packet is fragmented                 |          |
|                |                                                       |          |
|                | 11:15    Reserved, MUST be set to zero                |          |
+----------------+-------------------------------------------------------+----------+
| Signature/CRC  |                                                       | 4 bytes  |
+----------------+-------------------------------------------------------+----------+
| Packet size    | The size of packet in bytes.                          | 4 bytes  |
+----------------+-------------------------------------------------------+----------+
|Absolute Time2Q | on disk: Absolute time, on wire: Relative time        | 4 bytes  |
+----------------+-------------------------------------------------------+----------+

---*/




#pragma pack(push,1)

//
// struct CBaseHeader
//

struct CBaseHeader {
public:

    inline CBaseHeader(ULONG ulPacketSize);

    static ULONG CalcSectionSize(void);
    inline PCHAR GetNextSection(void) const;

    inline void  SetPacketSize(ULONG ulPacketSize);
    inline ULONG GetPacketSize(void) const;

    inline UCHAR GetVersion(void) const;
    inline BOOL  VersionIsValid(void) const;

    inline BOOL  SignatureIsValid(void) const;
	inline void  SetSignature(void);

    inline void  SetPriority(UCHAR bPriority);
    inline UCHAR GetPriority(void) const;

    inline void SetType(UCHAR bType);
    inline UCHAR GetType(void) const;

    inline void IncludeSession(BOOL);
    inline BOOL SessionIsIncluded(void) const;

    inline void IncludeDebug(BOOL);
    inline BOOL DebugIsIncluded(void) const;

    inline void SetImmediateAck(BOOL);
    inline BOOL AckIsImmediate(void) const;

    inline void  SetTrace(USHORT);
    inline USHORT GetTraced(void) const;

    inline void SetFragmented(BOOL);
    inline BOOL IsFragmented(void) const;

    inline void  SetAbsoluteTimeToQueue(ULONG ulTimeout);
    inline ULONG GetAbsoluteTimeToQueue(void) const;

	inline PUCHAR GetCRCBuffer();
	inline GetCRCBufferSize();
	inline void SetCRC(ULONG ulCRC);
	inline ULONG GetCRC();
	inline BOOL ValidCRC(ULONG ulCRC);
	inline void SetOnDiskSignature();
	inline void ClearOnDiskSignature();
	inline BOOL ValidOnDiskSignature();

	void SectionIsValid(DWORD MessageSizeLimit) const;
	inline const PCHAR GetPacketEnd() const;

	template <class SECTION_PTR> SECTION_PTR section_cast(void* pSection) const
	{
			SECTION_PTR tmp;		  

			const PCHAR PacketEnd =  GetPacketEnd();
			if(reinterpret_cast<PCHAR>(pSection) + sizeof(*tmp) >  PacketEnd)
			{
				throw std::range_error("");
			}


			const PCHAR PacketStart =  GetPacketStart();
			if(pSection <  PacketStart)
			{
				throw std::range_error("");
			}

	  	
			return reinterpret_cast<SECTION_PTR>(pSection);
	}


private:
	inline const PCHAR GetPacketStart() const;

private:

//
// BEGIN Network Monitor tag
//
    UCHAR  m_bVersion;
    UCHAR  m_bOnDiskSignature;
    union {
        USHORT m_wFlags;
        struct {
            USHORT m_bfPriority : 3;
            USHORT m_bfInternal : 1;
            USHORT m_bfSession  : 1;
            USHORT m_bfDebug    : 1;
            USHORT m_bfAck      : 1;
            USHORT m_bfReserved : 1; // was m_bfDuplicate now obsolete
            USHORT m_bfTrace    : 2;
            USHORT m_bfFragment : 1;
        };
    };

	union {
		ULONG m_ulSignature;
		ULONG m_ulCRC;
	};
	
	ULONG  m_ulPacketSize;
    ULONG  m_ulAbsoluteTimeToQueue;
//
// END Network Monitor tag
//
};

#pragma pack(pop)




/*======================================================================

 Function:      CBaseHeader::CBaseHeader

 Description:   Packet contructor

 =======================================================================*/
inline CBaseHeader::CBaseHeader(ULONG ulPacketSize) :
    m_bVersion(FALCON_PACKET_VERSION),
    m_wFlags(DEFAULT_M_PRIORITY),
    m_ulSignature(FALCON_SIGNATURE),
    m_ulPacketSize(ulPacketSize),
    m_ulAbsoluteTimeToQueue(INFINITE)
{
    SetType(FALCON_USER_PACKET);
}



/*===========================================================

  Routine Name: CBaseHeader::GetPacketEnd

  Description:  Calculate the pointer after the packet end.

  Arguments:

  Return Value:

=============================================================*/
inline const PCHAR CBaseHeader::GetPacketEnd() const
{
	const PCHAR pPachetStart = (PCHAR)this;
	const PCHAR pPacketEnd = pPachetStart + GetPacketSize();
	return pPacketEnd;	
}


/*===========================================================

  Routine Name: CBaseHeader::GetPacketStart

  Description:  Return	pointer to packet start.

  Arguments:

  Return Value:

=============================================================*/
inline const PCHAR CBaseHeader::GetPacketStart() const
{
	return (PCHAR)this;	
}



/*======================================================================

 Function:     CBaseHeader::GetSectionSize

 Description:

 =======================================================================*/
inline PCHAR CBaseHeader::GetNextSection(void) const
{
    return (PCHAR)this + sizeof(*this);
}

/*======================================================================

 Function:     CBaseHeader::CalcSectionSize

 Description:

 =======================================================================*/
inline ULONG CBaseHeader::CalcSectionSize(void)
{
    return sizeof(CBaseHeader);
}


/*======================================================================

 Function:     CBaseHeader::SetPacketSize

 Description:  Set Packet Size field

 =======================================================================*/
inline void CBaseHeader::SetPacketSize(ULONG ulPacketSize)
{
    m_ulPacketSize = ulPacketSize;
}

/*======================================================================

 Function:     CBaseHeader::GetPacketSize

 Description:  Returns the packet size

 =======================================================================*/
inline ULONG CBaseHeader::GetPacketSize(void) const
{
    return m_ulPacketSize;
}

/*======================================================================

 Function:     CBaseHeader::GetVersion

 Description:  returns the packet version field

 =======================================================================*/
inline UCHAR CBaseHeader::GetVersion(void) const
{
    return m_bVersion;
}

/*======================================================================

 Function:     CBaseHeader::VersionIsValid

 Description:  returns the packet version field

 =======================================================================*/
inline BOOL CBaseHeader::VersionIsValid(void) const
{
    return (m_bVersion == FALCON_PACKET_VERSION);
}

/*======================================================================

 Function:     CBaseHeader::SignatureIsValid

 Description:  return TRUE if Falcon packet signature is ok, False otherwise

 =======================================================================*/
inline BOOL CBaseHeader::SignatureIsValid(void) const
{
    return(m_ulSignature == FALCON_SIGNATURE);
}


/*======================================================================

 Function:     CBaseHeader::SetSignature

 Description:  Set packet signature to a valid signature

 =======================================================================*/
inline void  CBaseHeader::SetSignature(void)
{
	m_ulSignature = FALCON_SIGNATURE;
}

/*======================================================================

 Function:     CBaseHeader::SetPriority

 Description:  Set the packet priority bits in FLAGS field

 =======================================================================*/
inline void CBaseHeader::SetPriority(UCHAR bPriority)
{
    m_bfPriority = bPriority;
}

/*======================================================================

 Function:     CBaseHeader::GetPriority

 Description:  returns the packet priority

 =======================================================================*/
inline UCHAR CBaseHeader::GetPriority(void) const
{
    return (UCHAR)m_bfPriority;
}

/*======================================================================

 Function:     CBaseHeader::SetType

 Description:  Set the packet type field

 =======================================================================*/
inline void CBaseHeader::SetType(UCHAR bType)
{
    m_bfInternal = bType;
}

/*======================================================================

 Function:     CBaseHeader::GetType

 Description:  returns the packet type

 =======================================================================*/
inline UCHAR CBaseHeader::GetType(void) const
{
    return((UCHAR)m_bfInternal);
}

/*======================================================================

 Function:     CBaseHeader::SetSessionInclusion

 Description:  Set the secttion inclusion bit in Flags field

 =======================================================================*/
inline void CBaseHeader::IncludeSession(BOOL f)
{
    m_bfSession = (USHORT)f;
}

/*======================================================================

 Function:    CBaseHeader::IsSessionIncluded

 Description: returns TRUE if session section included, FALSE otherwise

 =======================================================================*/
inline BOOL CBaseHeader::SessionIsIncluded(void) const
{
    return m_bfSession;
}

/*======================================================================

 Function:     CBaseHeader::SetDbgInclusion

 Description:  Set the debug section inclusion bit in FLAGS field

 =======================================================================*/
inline void CBaseHeader::IncludeDebug(BOOL f)
{

    m_bfDebug = (USHORT)f;
}

/*======================================================================

 Function:     CBaseHeader::IsDbgIncluded

 Description:  returns TRUE if debug section included, FALSE otherwise

 =======================================================================*/
inline BOOL CBaseHeader::DebugIsIncluded(void) const
{
    return m_bfDebug;
}

/*======================================================================

 Function:     CBaseHeader::SetImmediateAck

 Description:  Set ACK immediately bit in Flag field

 =======================================================================*/
inline void CBaseHeader::SetImmediateAck(BOOL f)
{
    m_bfAck = (USHORT)f;
}

/*======================================================================

 Function:     CBaseHeader::IsImmediateAck

 Description:  Return TRUE if the ACK immediately bit is set, FALSE otherwise

 =======================================================================*/
inline BOOL CBaseHeader::AckIsImmediate(void) const
{
    return m_bfAck;
}

/*======================================================================

 Function:      CBaseHeader::SetTrace

 Description:   Set the Trace packet bit in FLAGS section

 =======================================================================*/
inline void CBaseHeader::SetTrace(USHORT us)
{
    m_bfTrace = us;
}

/*======================================================================

 Function:    CBaseHeader::GetTraced

 =======================================================================*/
inline USHORT CBaseHeader::GetTraced(void) const
{
    return m_bfTrace;
}

/*======================================================================

 Function:    CBaseHeader::SetSegmented

 Description: set the segmented bit in FLAGS field

 =======================================================================*/
inline void CBaseHeader::SetFragmented(BOOL f)
{
    m_bfFragment = (USHORT)f;
}

/*======================================================================

 Function:     CBaseHeader::IsFragmented

 Description:  returns TRUE if the segmented bit is set, FALSE otherwise

 =======================================================================*/
inline BOOL CBaseHeader::IsFragmented(void) const
{
    return m_bfFragment;
}

/*======================================================================

 Function:     CBaseHeader::SetAbsoluteTimeToQueue

 Description:  Set The Message Time-out to queue field

 =======================================================================*/
inline void CBaseHeader::SetAbsoluteTimeToQueue(ULONG ulTimeout)
{
    m_ulAbsoluteTimeToQueue = ulTimeout;
}

/*======================================================================

 Function:     CBaseHeader::GetAbsoluteTimeToQueue

 Description:  Returns the message Time-Out to queue

 =======================================================================*/
inline ULONG CBaseHeader::GetAbsoluteTimeToQueue(void) const
{
    return m_ulAbsoluteTimeToQueue;
}

/*======================================================================

 Function:     CBaseHeader::GetCRCBuffer

 Description:  Returns a pointer to the beginning of the CRC

 =======================================================================*/
inline PUCHAR CBaseHeader::GetCRCBuffer()
{
	return (PUCHAR) &m_ulCRC;
}

/*======================================================================

 Function:     CBaseHeader::GetCRCBufferSize

 Description:  Returns the size of the CRC

 =======================================================================*/
inline CBaseHeader::GetCRCBufferSize()
{
	return sizeof m_ulCRC;
}

/*======================================================================

 Function:     CBaseHeader::SetCRC

 Description:  Sets the CRC

 =======================================================================*/
inline void CBaseHeader::SetCRC(ULONG ulCRC)
{
	m_ulCRC = ulCRC;
}

/*======================================================================

 Function:     CBaseHeader::ValidCRC

 Description:  Validates the CRC against ulCRC

 =======================================================================*/
inline BOOL CBaseHeader::ValidCRC(ULONG ulCRC)
{
	return m_ulCRC == ulCRC;
}

/*======================================================================

 Function:     CBaseHeader::GetCRC

 Description:  Gets the CRC

 =======================================================================*/
inline ULONG CBaseHeader::GetCRC()
{
	return m_ulCRC;
}

/*======================================================================

 Function:     CBaseHeader::SetOnDiskSignature

 Description:  Sets the header signature

 =======================================================================*/
inline void CBaseHeader::SetOnDiskSignature()
{
	m_bOnDiskSignature = 0x7c;
}

/*======================================================================

 Function:     CBaseHeader::ClearOnDiskSignature

 Description:  Clears the header signature

 =======================================================================*/
inline void CBaseHeader::ClearOnDiskSignature()
{
	m_bOnDiskSignature = 0;
}
/*======================================================================

 Function:     CBaseHeader::ValidOnDiskSignature

 Description:  Checks the header signature

 =======================================================================*/
inline BOOL CBaseHeader::ValidOnDiskSignature()
{
	return (m_bOnDiskSignature & 0xff) == 0x7c;
}

#endif // __PHBASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\phcompoundmsg.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    phCompoundMsg.h

Abstract:

    Packet header for Compound Message.

Author:

    Shai Kariv  (shaik)  11-Oct-2000

--*/

#ifndef __PHCOMPOUND_MSG_H
#define __PHCOMPOUND_MSG_H


/*+++

    Note: Packet may contain 0 or 2 SRMP headers (one for envelope, one for CompoundMessage).
          Packet may not contain only 1 SRMP header.

    CompoundMessage header fields:
    
+----------------+-------------------------------------------------------+----------+
| FIELD NAME     | DESCRIPTION                                           | SIZE     |
+----------------+-------------------------------------------------------+----------+
| Header ID      | Identification of the header                          | 2 bytes  |
+----------------+-------------------------------------------------------+----------+
| Reserved       | Reserved for future extensions. Must be set to zero.  | 2 bytes  |
+----------------+-------------------------------------------------------+----------+
| HTTP Body Size | Size of the HTTP Body in BYTEs.                       | 4 bytes  |
+----------------+-------------------------------------------------------+----------+
| Msg Body Size  | Size of the message body part in BYTEs.               | 4 bytes  |
+----------------+-------------------------------------------------------+----------+
| Msg Body Offset| Offset of the message body in the data, in BYTEs.     | 4 bytes  |
+----------------+-------------------------------------------------------+----------+
| Data           | The data bytes.                                       | Variable |
+----------------+-------------------------------------------------------+----------+

---*/


#pragma pack(push, 1)
#pragma warning(disable: 4200)  //  zero-sized array in struct/union (enabeld later)


class CCompoundMessageHeader
{
public:

    //
    // Construct the Compound Message header
    //
    CCompoundMessageHeader(
        UCHAR * pHttpHeader, 
        ULONG   HttpHeaderSizeInBytes, 
        UCHAR * pHttpBody, 
        ULONG   HttpBodySizeInBytes, 
        ULONG   MsgBodySizeInBytes,
        ULONG   MsgBodyOffsetInBytes,
        USHORT id
        );

    //
    // Get size in BYTEs of the Compound Message header.
    //
    static ULONG CalcSectionSize(ULONG HeaderSizeInBytes, ULONG DataSizeInBytes);

    //
    // Get pointer to first byte after the Compound Message header
    //
    PCHAR  GetNextSection(VOID) const;
      
    //
    // Copy the data from the Compound Message header
    //
    VOID   GetData(UCHAR * pBuffer, ULONG BufferSizeInBytes) const;

    //
    // Get pointer to the data in the Compound Message header
    //
    const UCHAR* GetPointerToData(VOID) const;

    //
    // Get the size of the data in BYTEs from the Compound Message header
    //
    ULONG  GetDataSizeInBytes(VOID) const;

    //
    // Copy the message body part of the data from the Compound Message header
    //
    VOID   GetBody(UCHAR * pBuffer, ULONG BufferSizeInBytes) const;

    //
    // Get pointer to the message body part of the data in the Compound Message header
    //
    const UCHAR* GetPointerToBody(VOID) const;

    //
    // Get the size of the message body part of the data in BYTEs from the Compound Message header
    //
    ULONG  GetBodySizeInBytes(VOID) const;

private:

    //
    // ID number of the Compound Message header
    //
    USHORT m_id;

    //
    // Reserved (for alignment)
    //
    USHORT m_ReservedSetToZero;

    //
    // Size in BYTEs of the data
    //
    ULONG  m_DataSize;

    //
    // Size in BYTEs of the message body part of the data
    //
    ULONG m_MsgBodySize;

    //
    // Offset in BYTEs of the message body part of the data
    //
    ULONG m_MsgBodyOffset;

    //
    // Buffer with the data
    //
    UCHAR  m_buffer[0];

}; // CCompoundMessageHeader


#pragma warning(default: 4200)  //  zero-sized array in struct/union
#pragma pack(pop)



////////////////////////////////////////////////////////
//
//  Implementation
//

inline
CCompoundMessageHeader::CCompoundMessageHeader(
    UCHAR*  pHttpHeader,
    ULONG   HttpHeaderSizeInBytes,
    UCHAR*  pHttpBody, 
    ULONG   HttpBodySizeInBytes, 
    ULONG   MsgBodySizeInBytes,
    ULONG   MsgBodyOffsetInBytes,
    USHORT  id
    ) :
    m_id(id),
    m_ReservedSetToZero(0),
    m_DataSize(HttpHeaderSizeInBytes + HttpBodySizeInBytes),
    m_MsgBodySize(MsgBodySizeInBytes),
    m_MsgBodyOffset(MsgBodyOffsetInBytes + HttpHeaderSizeInBytes)
{
    ASSERT(MsgBodyOffsetInBytes + MsgBodySizeInBytes <=  HttpBodySizeInBytes);
    ASSERT(HttpHeaderSizeInBytes != 0);
    ASSERT(pHttpHeader != NULL);
 	
    memcpy(&m_buffer[0], pHttpHeader, HttpHeaderSizeInBytes);
    
    if (HttpBodySizeInBytes != 0)
    {
        memcpy(&m_buffer[HttpHeaderSizeInBytes], pHttpBody, HttpBodySizeInBytes);
    }
} // CCompoundMessageHeader::CCompoundMessageHeader


inline 
ULONG
CCompoundMessageHeader::CalcSectionSize(
    ULONG HeaderSizeInBytes,
    ULONG DataSizeInBytes
    )
{
    size_t cbSize = sizeof(CCompoundMessageHeader) + HeaderSizeInBytes + DataSizeInBytes;

    //
    // Align the entire header size to 4 bytes boundaries
    //
    cbSize = ALIGNUP4_ULONG(cbSize);
    return static_cast<ULONG>(cbSize);

} // CCompoundMessageHeader::CalcSectionSize


inline PCHAR CCompoundMessageHeader::GetNextSection(VOID) const
{
    size_t cbSize = sizeof(CCompoundMessageHeader) + m_DataSize;
    cbSize = ALIGNUP4_ULONG(cbSize);

    return (PCHAR)this + cbSize;

} // CCompoundMessageHeader::GetNextSection


inline VOID CCompoundMessageHeader::GetData(UCHAR * pBuffer, ULONG BufferSizeInBytes) const
{
    ULONG size = min(BufferSizeInBytes, m_DataSize);

    if (size != 0)
    {
        memcpy(pBuffer, &m_buffer[0], size);
    }
} // CCompoundMessageHeader::GetData


inline const UCHAR* CCompoundMessageHeader::GetPointerToData(VOID) const
{
    return &m_buffer[0];

} // CCompoundMessageHeader::GetPointerToData


inline ULONG CCompoundMessageHeader::GetDataSizeInBytes(VOID) const
{
    return m_DataSize;

} // CCompoundMessageHeader::GetDataSizeInBytes


inline VOID CCompoundMessageHeader::GetBody(UCHAR * pBuffer, ULONG BufferSizeInBytes) const
{
    ULONG size = min(BufferSizeInBytes, m_MsgBodySize);

    if (size != 0)
    {
        memcpy(pBuffer, &m_buffer[m_MsgBodyOffset], size);
    }
} // CCompoundMessageHeader::GetBody


inline const UCHAR* CCompoundMessageHeader::GetPointerToBody(VOID) const
{
    if (m_MsgBodySize == 0)
    {
        return NULL;
    }

    return &m_buffer[m_MsgBodyOffset];

} // CCompoundMessageHeader::GetPointerToBody


inline ULONG CCompoundMessageHeader::GetBodySizeInBytes(VOID) const
{
    return m_MsgBodySize;

} // CCompoundMessageHeader::GetBodySizeInBytes



#endif // __PHCOMPOUND_MSG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\phdebug.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    phdebug.h

Abstract:

    Packet header for message tracing.

Author:

    Shai Kariv  (shaik)  24-Apr-2000

--*/

#ifndef __PHDEBUG_H
#define __PHDEBUG_H


#pragma pack(push, 1)
#pragma warning(disable: 4200)  //  zero-sized array in struct/union (enabeld later)


struct CDebugSection {
public:
    CDebugSection(IN const QUEUE_FORMAT* pReportQueue);

    static ULONG CalcSectionSize(IN const QUEUE_FORMAT* pReportQueue);

    PCHAR GetNextSection(void) const;

    void SetReportQueue(IN const QUEUE_FORMAT* pReportQueue);

    BOOL GetReportQueue(OUT QUEUE_FORMAT* pReportQueue);

	void SectionIsValid(PCHAR PacketEnd) const;

private:
    enum QType {
        qtNone      = 0,    //  0 - None                    ( 0 bytes)
        qtGUID      = 1,    //  1 - Public  Queue           (16 bytes)
        qtPrivate   = 2,    //  2 - Private Queue           (20 bytes)
        qtDirect    = 3     //  3 - Direct  Queue           (var size)
    };
//
// BEGIN Network Monitor tag
//
    union {
        USHORT   m_wFlags;
        struct {
            USHORT m_bfRQT: 2;
        };
    };
    WORD m_wReserved;
    UCHAR m_abReportQueue[0];
//
// END Network Monitor tag
//


};

#pragma warning(default: 4200)  //  zero-sized array in struct/union
#pragma pack(pop)

/*======================================================================

 Function:

 Description:

 =======================================================================*/
inline
CDebugSection::CDebugSection(
        IN const QUEUE_FORMAT* pReportQueue
        ) :
        m_wFlags(0),
        m_wReserved(0)
{
    SetReportQueue(pReportQueue);
}

/*======================================================================

 Function:

 Description:

 =======================================================================*/
inline ULONG
CDebugSection::CalcSectionSize(const QUEUE_FORMAT* pReportQueue)
{
    ULONG ulSize = sizeof(CDebugSection);

    switch (pReportQueue->GetType())
    {
        case QUEUE_FORMAT_TYPE_PUBLIC:
            ulSize += sizeof(GUID);
            break;

        case QUEUE_FORMAT_TYPE_UNKNOWN:
            //
            // Report queue is unknown.
            //
            // AC sets an unknown report queue on the packet
            // when including the MQF header, so that MSMQ 1.0/2.0
            // reporting QMs will not append Debug header to the
            // packet.  (ShaiK, 15-May-2000)
            //
            break;

	    default:
	        ASSERT(0);
    }

    return ALIGNUP4_ULONG(ulSize);
}

/*======================================================================

 Function:

 Description:

 =======================================================================*/
 inline PCHAR CDebugSection::GetNextSection(void) const
 {
    int size = sizeof(*this);
    switch (m_bfRQT)
    {
    case qtNone:
        size += 0;
        break;
    case qtGUID:
        size += sizeof(GUID);
        break;
    default:
        ASSERT(0);
    }

    return (PCHAR)this + ALIGNUP4_ULONG(size);
 }


/*======================================================================

 Function:

 Description:

 =======================================================================*/
inline void
CDebugSection::SetReportQueue(IN const QUEUE_FORMAT* pReportQueue)
{
    PUCHAR pQueue = m_abReportQueue;

    switch (pReportQueue->GetType())
    {
        case QUEUE_FORMAT_TYPE_PUBLIC:
            //
            //  Report Queue is PUBLIC
            //
            m_bfRQT = qtGUID;
            *(GUID*)pQueue = pReportQueue->PublicID();
            break;

        case QUEUE_FORMAT_TYPE_UNKNOWN:
        {
            //
            // Report queue is unknown.
            //
            // AC sets an unknown report queue on the packet
            // when including the MQF header, so that MSMQ 1.0/2.0
            // reporting QMs will not append Debug header to the
            // packet.  (ShaiK, 15-May-2000)
            //
            m_bfRQT = qtNone;
            break;
        }
        default:
            ASSERT(0);
    }

}

inline BOOL CDebugSection::GetReportQueue(QUEUE_FORMAT* pReportQueue)
{
    PUCHAR pQueue = m_abReportQueue;

    switch (m_bfRQT)
    {
        case qtNone:
            //
            // Report queue is unknown.
            //
            // AC sets an unknown report queue on the packet
            // when including the MQF header, so that MSMQ 1.0/2.0
            // reporting QMs will not append Debug header to the
            // packet.  (ShaiK, 15-May-2000)
            //
            pReportQueue->UnknownID(0);
            break;

        case qtGUID:
            //
            //  Report Queue is PUBLIC
            //
            pReportQueue->PublicID(*(GUID*)pQueue);
            break;

        default:
            ASSERT(0);
            return FALSE;
    }

    return TRUE;
}

#endif // __PHDEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\pheodack.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    pheodack.h

Abstract:

    Packet header for Exactly Once Delivery Ack over http.

Author:

    Shai Kariv  (shaik)  22-Oct-2000

--*/

#ifndef __PHEODACK_H
#define __PHEODACK_H


/*+++

    EodAck header fields:
    
+----------------+-------------------------------------------------------+----------+
| FIELD NAME     | DESCRIPTION                                           | SIZE     |
+----------------+-------------------------------------------------------+----------+
| Header ID      | Identification of the header                          | 2 bytes  |
+----------------+-------------------------------------------------------+----------+
| Reserved       | Reserved for future extensions. Must be set to zero.  | 2 bytes  |
+----------------+-------------------------------------------------------+----------+
| Seq ID         | Seq ID.                                               | 8 bytes  |
+----------------+-------------------------------------------------------+----------+
| Seq number     | Seq number.                                           | 8 bytes  |
+----------------+-------------------------------------------------------+----------+
| Stream ID Size | Size of the stream ID in bytes.                       | 4 bytes  |
+----------------+-------------------------------------------------------+----------+
| Buffer         | Buffer that holds the stream ID.                      | Variable |
+----------------+-------------------------------------------------------+----------+

---*/


#pragma pack(push, 1)
#pragma warning(disable: 4200)  //  zero-sized array in struct/union (enabeld later)


class CEodAckHeader
{
public:

    //
    // Construct the EodAck header
    //
    CEodAckHeader(
        USHORT      id, 
        LONGLONG * pSeqId,
        LONGLONG * pSeqNum,
        ULONG       cbStreamIdSize, 
        UCHAR *     pStreamId
        );

    //
    // Get size in bytes of the EodAck header
    //
    static ULONG CalcSectionSize(ULONG cbStreamIdSize);

    //
    // Get pointer to first byte after the EodAck header
    //
    PCHAR  GetNextSection(VOID) const;

    //
    // Get the Seq ID from the EodAck header
    //
    LONGLONG GetSeqId(VOID) const;

    //
    // Get the Seq number form the EodAck header
    //
    LONGLONG GetSeqNum(VOID) const;

    //
    // Get the size of the stream ID in bytes from the EodAck header
    //
    ULONG  GetStreamIdSizeInBytes(VOID) const;

    //
    // Get the stream ID from the EodAck header
    //
    VOID   GetStreamId(UCHAR * pBuffer, ULONG cbBufferSize) const;

    //
    // Get pointer to the stream ID in the EodAck header
    //
    const UCHAR* GetPointerToStreamId(VOID) const;

private:

    //
    // ID number of the EodAck header
    //
    USHORT m_id;

    //
    // Reserved (for alignment)
    //
    USHORT m_ReservedSetToZero;

    //
    // Seq ID
    //
    LONGLONG m_SeqId;

    //
    // Seq number
    //
    LONGLONG m_SeqNum;

    //
    // Size in bytes of the stream ID
    //
    ULONG  m_cbStreamIdSize;

    //
    // Buffer with the stream ID
    //
    UCHAR  m_buffer[0];

}; // CEodAckHeader


#pragma warning(default: 4200)  //  zero-sized array in struct/union
#pragma pack(pop)



////////////////////////////////////////////////////////
//
//  Implementation
//

inline
CEodAckHeader::CEodAckHeader(
    USHORT      id,
    LONGLONG * pSeqId,
    LONGLONG * pSeqNum,
    ULONG       cbStreamIdSize, 
    UCHAR *     pStreamId
    ) :
    m_id(id),
    m_ReservedSetToZero(0),
    m_SeqId(pSeqId == NULL ? 0 : *pSeqId),
    m_SeqNum(pSeqNum == NULL ? 0 : * pSeqNum),
    m_cbStreamIdSize(cbStreamIdSize)
{
    if (cbStreamIdSize != 0)
    {
        memcpy(&m_buffer[0], pStreamId, cbStreamIdSize);
    }
} // CEodAckHeader::CEodAckHeader

    
inline 
ULONG
CEodAckHeader::CalcSectionSize(
    ULONG cbStreamIdSize
    )
{
    size_t cbSize = sizeof(CEodAckHeader) + cbStreamIdSize;

    //
    // Align the entire header size to 4 bytes boundaries
    //
    cbSize = ALIGNUP4_ULONG(cbSize);
    return static_cast<ULONG>(cbSize);

} // CEodAckHeader::CalcSectionSize


inline PCHAR CEodAckHeader::GetNextSection(VOID) const
{
    size_t cbSize = sizeof(CEodAckHeader) + m_cbStreamIdSize;
    cbSize = ALIGNUP4_ULONG(cbSize);

    return (PCHAR)this + cbSize;

} // CEodAckHeader::GetNextSection


inline LONGLONG CEodAckHeader::GetSeqId(VOID) const
{
    return m_SeqId;

} // CEodAckHeader::GetSeqId


inline LONGLONG CEodAckHeader::GetSeqNum(VOID) const
{
    return m_SeqNum;

} // CEodAckHeader::GetSeqNum


inline ULONG CEodAckHeader::GetStreamIdSizeInBytes(VOID) const
{
    return m_cbStreamIdSize;

} // CEodAckHeader::GetStreamIdSizeInBytes


inline VOID CEodAckHeader::GetStreamId(UCHAR * pBuffer, ULONG cbBufferSize) const
{
    ULONG cbSize = min(cbBufferSize, m_cbStreamIdSize);

    if (cbSize != 0)
    {
        memcpy(pBuffer, &m_buffer[0], cbSize);
    }
} // CEodAckHeader::GetStreamId


inline const UCHAR* CEodAckHeader::GetPointerToStreamId(VOID) const
{
    return &m_buffer[0];

} // GetPointerToStreamId



#endif // __PHEODACK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\pheod.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    pheod.h

Abstract:

    Packet header for Exactly Once Delivery over http.

Author:

    Shai Kariv  (shaik)  22-Oct-2000

--*/

#ifndef __PHEOD_H
#define __PHEOD_H


/*+++

    EOD header fields:
    
+----------------+-------------------------------------------------------+----------+
| FIELD NAME     | DESCRIPTION                                           | SIZE     |
+----------------+-------------------------------------------------------+----------+
| Header ID      | Identification of the header                          | 2 bytes  |
+----------------+-------------------------------------------------------+----------+
| Reserved       | Reserved for future extensions. Must be set to zero.  | 2 bytes  |
+----------------+-------------------------------------------------------+----------+
| Stream ID Size | Size of the stream ID in bytes.                       | 4 bytes  |
+----------------+-------------------------------------------------------+----------+
| Order Q Size   | Size of the order queue in bytes.                     | 4 bytes  |
+----------------+-------------------------------------------------------+----------+
| Buffer         | Buffer that holds the stream ID and order queue.      | Variable |
+----------------+-------------------------------------------------------+----------+

---*/


#pragma pack(push, 1)
#pragma warning(disable: 4200)  //  zero-sized array in struct/union (enabeld later)


class CEodHeader
{
public:

    //
    // Construct the EOD header
    //
    CEodHeader(
        USHORT      id, 
        ULONG       cbStreamIdSize, 
        UCHAR *     pStreamId,
        ULONG       cbOrderQueueSize,
        UCHAR *     pOrderQueue
        );

    //
    // Get size in bytes of the EOD header
    //
    static ULONG CalcSectionSize(ULONG cbStreamIdSize, ULONG cbOrderQueueSize);

    //
    // Get pointer to first byte after the EOD header
    //
    PCHAR  GetNextSection(VOID) const;

    //
    // Get the size of the stream ID in bytes from the EOD header
    //
    ULONG  GetStreamIdSizeInBytes(VOID) const;

    //
    // Get the stream ID from the EOD header
    //
    VOID   GetStreamId(UCHAR * pBuffer, ULONG cbBufferSize) const;

    //
    // Get pointer to the stream ID in the EOD header
    //
    const UCHAR* GetPointerToStreamId(VOID) const;

    //
    // Get the size of the order queue in bytes from the EOD header
    //
    ULONG  GetOrderQueueSizeInBytes(VOID) const;

    //
    // Get pointer to the order queue in the EOD header
    //
    const UCHAR* GetPointerToOrderQueue(VOID) const;

private:

    //
    // ID number of the EOD header
    //
    USHORT m_id;

    //
    // Reserved (for alignment)
    //
    USHORT m_ReservedSetToZero;

    //
    // Size in bytes of the stream ID
    //
    ULONG  m_cbStreamIdSize;

    //
    // Size in bytes of the order queue
    //
    ULONG  m_cbOrderQueueSize;

    //
    // Buffer with the stream ID and order queue
    //
    UCHAR  m_buffer[0];

}; // CEodHeader


#pragma warning(default: 4200)  //  zero-sized array in struct/union
#pragma pack(pop)



////////////////////////////////////////////////////////
//
//  Implementation
//

inline
CEodHeader::CEodHeader(
    USHORT      id,
    ULONG       cbStreamIdSize, 
    UCHAR *     pStreamId,
    ULONG       cbOrderQueueSize,
    UCHAR *     pOrderQueue
    ) :
    m_id(id),
    m_ReservedSetToZero(0),
    m_cbStreamIdSize(cbStreamIdSize),
    m_cbOrderQueueSize(cbOrderQueueSize)
{
    if (cbStreamIdSize != 0)
    {
        memcpy(&m_buffer[0], pStreamId, cbStreamIdSize);
    }

    if (cbOrderQueueSize != 0)
    {
        memcpy(&m_buffer[cbStreamIdSize], pOrderQueue, cbOrderQueueSize);
    }
} // CEodHeader::CEodHeader

    
inline 
ULONG
CEodHeader::CalcSectionSize(
    ULONG cbStreamIdSize,
    ULONG cbOrderQueueSize
    )
{
    size_t cbSize = sizeof(CEodHeader) + cbStreamIdSize + cbOrderQueueSize;

    //
    // Align the entire header size to 4 bytes boundaries
    //
    cbSize = ALIGNUP4_ULONG(cbSize);
    return static_cast<ULONG>(cbSize);

} // CEodHeader::CalcSectionSize


inline PCHAR CEodHeader::GetNextSection(VOID) const
{
    size_t cbSize = sizeof(CEodHeader) + m_cbStreamIdSize + m_cbOrderQueueSize;
    cbSize = ALIGNUP4_ULONG(cbSize);

    return (PCHAR)this + cbSize;

} // CEodHeader::GetNextSection


inline ULONG CEodHeader::GetStreamIdSizeInBytes(VOID) const
{
    return m_cbStreamIdSize;

} // CEodHeader::GetStreamIdSizeInBytes


inline VOID CEodHeader::GetStreamId(UCHAR * pBuffer, ULONG cbBufferSize) const
{
    ULONG cbSize = min(cbBufferSize, m_cbStreamIdSize);

    if (cbSize != 0)
    {
        memcpy(pBuffer, &m_buffer[0], cbSize);
    }
} // CEodHeader::GetStreamId


inline const UCHAR* CEodHeader::GetPointerToStreamId(VOID) const
{
    return &m_buffer[0];

} // GetPointerToStreamId


inline ULONG CEodHeader::GetOrderQueueSizeInBytes(VOID) const
{
    return m_cbOrderQueueSize;

} // CEodHeader::GetOrderQueueSizeInBytes


inline const UCHAR* CEodHeader::GetPointerToOrderQueue(VOID) const
{
    return &m_buffer[m_cbStreamIdSize];

} // GetPointerToStreamId



#endif // __PHEOD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\phintr.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    qmpkt.h

Abstract:

    Handle packet in QM side

Author:

    Uri Habusha  (urih)


--*/

#ifndef __QM_INTERNAL_PACKET__
#define __QM_INTERNAL_PACKET__

#include "ph.h"

#define STORED_ACK_BITFIELD_SIZE 32
#define INTERNAL_SESSION_PACKET              1
#define INTERNAL_ESTABLISH_CONNECTION_PACKET 2
#define INTERNAL_CONNECTION_PARAMETER_PACKET 3

#define ESTABLISH_CONNECTION_BODY_SIZE       512
#define CONNECTION_PARAMETERS_BODY_SIZE      512


/*
================= Session Packet =====================

+-----------------------+------------------------------------------------+----------+
| Field Name            | Description                                    |Field Size|
+-----------------------+------------------------------------------------+----------+
|ACK Sequence number    | The transmitted packet sequence number.        | 2 bytes  |
+-----------------------+------------------------------------------------+----------+
|Store ACK sequence     | The reliable packet sequence number.           | 2 bytes  |
|number (ps)            |                                                |          |
+-----------------------+------------------------------------------------+----------+
|Storage Ack bits       | Bit i:refers to recoverable packet no. Ps+I+ 1 | 4 bytes  |
|                       |    0 - no acknowledgment.                      |          |
|                       |    1 - the packet is acknowledgment.           |          |
+-----------------------+------------------------------------------------+----------+
| Window size           | number of packet in specific priority that     | 2 bytes  |
|                       | can be sent before getting a new window size.  |          |
+-----------------------+------------------------------------------------+----------+
| window priority       |message priority, in which the window size refer| 1 byte   |         |
+-----------------------+------------------------------------------------+----------+
| Reserved              |                                                | 1 byte   |
+-----------------------+------------------------------------------------+----------+

*/

#pragma pack(push, 1)

struct  CSessionSection {
    public:
        CSessionSection(WORD     wAckSequenceNo,
                        WORD     wAckRecoverNo,
                        DWORD    wAckRecoverBitField,
                        WORD     wSyncAckSequenceNo,
                        WORD     wSyncAckRecoverNo,
                        WORD     wWindowSize
                       );

        CSessionSection() {};

        static ULONG CalcSectionSize(void);

        inline WORD GetAcknowledgeNo(void) const;
        inline WORD GetStorageAckNo(void) const;
        inline DWORD GetStorageAckBitField(void) const;
        inline void GetSyncNo(WORD* wSyncAckSequenceNo,
                              WORD* wSyncAckRecoverNo);
        WORD GetWindowSize(void) const;

    private:
//
// BEGIN Network Monitor tag
//
        WORD    m_wAckSequenceNo;
        WORD    m_wAckRecoverNo;
        DWORD   m_wAckRecoverBitField;
        WORD    m_wSyncAckSequenceNo;
        WORD    m_wSyncAckRecoverNo;
        WORD    m_wWinSize;
        UCHAR   m_bWinPriority;
        UCHAR   m_bReserve;
//
// END Network Monitor tag
//
};
#pragma pack(pop)


/*====================================================


 Routine Name: CSession::Csession

 Description: Constructor

 Arguments:  wAckSequenceNo - Acknowledge sequence number
             wAckRecoverNo  - Acknowledge Recover packet number
             wAckRecoverBitField - Acknowledge recover bit field

=====================================================*/
inline
CSessionSection::CSessionSection(WORD     wAckSequenceNo,
                                 WORD     wAckRecoverNo,
                                 DWORD    wAckRecoverBitField,
                                 WORD     wSyncAckSequenceNo,
                                 WORD     wSyncAckRecoverNo,
                                 WORD     wWindowSize
                                )
{
    m_wAckSequenceNo      = wAckSequenceNo;
    m_wAckRecoverNo       = wAckRecoverNo;
    m_wAckRecoverBitField = wAckRecoverBitField;
    m_wSyncAckSequenceNo  = wSyncAckSequenceNo;
    m_wSyncAckRecoverNo   = wSyncAckRecoverNo;
    m_wWinSize            = wWindowSize;
    m_bWinPriority        = 0x0;
    m_bReserve            = 0x0;
}


/*====================================================

RoutineName

Arguments:

Return Value:

=====================================================*/
inline ULONG
CSessionSection::CalcSectionSize(void)
{
    return sizeof(CSessionSection);
}
/*====================================================

RoutineName

Arguments:

Return Value:

=====================================================*/
inline WORD
CSessionSection::GetAcknowledgeNo(void) const
{
    return(m_wAckSequenceNo);
}

/*====================================================

RoutineName

Arguments:

Return Value:

=====================================================*/
inline WORD
CSessionSection::GetStorageAckNo(void) const
{
    return(m_wAckRecoverNo);
}

/*====================================================

RoutineName

Arguments:

Return Value:

=====================================================*/
inline void
CSessionSection::GetSyncNo(WORD* wSyncAckSequenceNo,
                           WORD* wSyncAckRecoverNo)
{
    *wSyncAckSequenceNo = m_wSyncAckSequenceNo;
    *wSyncAckRecoverNo  = m_wSyncAckRecoverNo;
}

/*====================================================

RoutineName

Arguments:

Return Value:

=====================================================*/
inline DWORD
CSessionSection::GetStorageAckBitField(void) const
{
    return(m_wAckRecoverBitField);
}

/*====================================================

RoutineName

Arguments:

Return Value:

=====================================================*/
inline WORD 
CSessionSection::GetWindowSize(void) const
{
    return m_wWinSize;
}
/*
======================== Establish Connection Section ================================

+-----------------------+------------------------------------------------+----------+
| Field Name            | Description                                    |Field Size|
+-----------------------+------------------------------------------------+----------+
|Client QM Guid         | The Client QM Identifier                       | 16 bytes |
+-----------------------+------------------------------------------------+----------+
|SErver QM Guid         | The Server QM Identifier                       | 16 bytes |
+-----------------------+------------------------------------------------+----------+
|Time Stamp             | send packet time stamp. use for determine the  | 4 bytes  |
|                       | line quality                                   |          |
+-----------------------+------------------------------------------------+----------+
|Flags                  |                                                | 4 bytes  |
|                       | Version                  1 byte                |          |
|                       | Check new session flag   1 bit                 |          |
|                       | Server flag              1 bit                 |          |
|                       | QoS flag                 1 bit                 |          |
+-----------------------+------------------------------------------------+----------+
|Body                   |                                                | 512 bytes|
+-----------------------+------------------------------------------------+----------+

*/
#pragma pack(push, 1)

struct CECSection {
    public:
        CECSection(const GUID* ClientQMId,
                   const GUID* ServerQMId,
                   BOOL  fServer,
                   bool  fQoS
                  );

        CECSection(const GUID* ClientQMId,
                   const GUID* ServerQMId,
                   ULONG dwTime,
                   BOOL  fServer,
                   bool  fQoS
                  );

        static ULONG CalcSectionSize(void);

        void CheckAllowNewSession(BOOL);
        BOOL CheckAllowNewSession() const;

        const GUID* GetServerQMGuid() const;
        const GUID* GetClientQMGuid() const;
        ULONG GetTimeStamp() const;
        DWORD GetVersion() const;
        BOOL  IsOtherSideServer()const;
        bool  IsOtherSideQoS()const;


    private:
//
// BEGIN Network Monitor tag
//
        GUID    m_guidClientQM;
        GUID    m_guidServerQM;
        ULONG   m_ulTimeStampe;
        union {
            ULONG m_ulFlags;
            struct {
                ULONG m_bVersion : 8;
                ULONG m_fCheckNewSession : 1;
                ULONG m_fServer : 1;
                ULONG m_fQoS    : 1;
            };
        };

        UCHAR   m_abBody[ESTABLISH_CONNECTION_BODY_SIZE];
//
// END Network Monitor tag
//

};

#pragma pack(pop)

/*================================================================

 Routine Name: CECPacket::CECPacket

 Description: Constructor

==================================================================*/

inline  CECSection::CECSection(const GUID* ClientQMId,
                               const GUID* ServerQMId,
                               BOOL  fServer,
                               bool  fQoS
                              ) : m_guidClientQM(*ClientQMId),
                                  m_guidServerQM(*ServerQMId),
                                  m_ulTimeStampe(GetTickCount()),
                                  m_ulFlags(0)
{
    m_bVersion = FALCON_PACKET_VERSION;
    m_fServer = fServer;
    m_fQoS = fQoS ? 1 : 0;
}

inline  CECSection::CECSection(const GUID* ClientQMId,
                               const GUID* ServerQMId,
                               ULONG dwTime,
                               BOOL  fServer,
                               bool  fQoS
                              ) : m_guidClientQM(*ClientQMId),
                                  m_guidServerQM(*ServerQMId),
                                  m_ulTimeStampe(dwTime),
                                  m_ulFlags(0)
{
    m_bVersion = FALCON_PACKET_VERSION;
    m_fServer = fServer;
    m_fQoS = fQoS ? 1: 0;
}

inline ULONG
CECSection::CalcSectionSize(void)
{
    return sizeof(CECSection);
}

inline void 
CECSection::CheckAllowNewSession(BOOL f)
{
    m_fCheckNewSession = f;
}

inline BOOL 
CECSection::CheckAllowNewSession() const
{
    return m_fCheckNewSession;
}

inline const GUID*
CECSection::GetClientQMGuid(void) const
{
    return &m_guidClientQM;
}

inline const GUID*
CECSection::GetServerQMGuid(void) const
{
    return &m_guidServerQM;
}

inline DWORD
CECSection::GetTimeStamp(void) const
{
    return m_ulTimeStampe;
}

inline DWORD
CECSection::GetVersion(void) const
{
    return m_bVersion;
}

inline BOOL  
CECSection::IsOtherSideServer()const
{
    return m_fServer;
}

inline bool  
CECSection::IsOtherSideQoS()const
{
    return m_fQoS;
}

/*
==========================  Connection Parameters Section =============================

+-----------------------+------------------------------------------------+----------+
| Field Name            | Description                                    |Field Size|
+-----------------------+------------------------------------------------+----------+
| Window size           | number of packet that  can be sent before      | 2 bytes  |
|                       | getting an acknowledge                         |          |
+-----------------------+------------------------------------------------+----------+
|ACK Timeout            | The Max time can be passed before getting an   |          |
|                       | acknowledge                                    | 2 bytes  |
+-----------------------+------------------------------------------------+----------+
|Store ACK Timeout      | The Max time can be passed before getting an   |          |
|                       | acknowledge on persistence packet              | 2 bytes  |
+-----------------------+------------------------------------------------+----------+
|Max Segmentaion size   |                                                | 2 bytes  |
+-----------------------+------------------------------------------------+----------+

*/
#pragma pack(push, 1)

struct CCPSection {
    public:
        CCPSection(USHORT wWindowSize,
                   DWORD  dwRecoverAckTimeout,
                   DWORD  dwAckTimeout,
                   USHORT wSegmentSize
                  );

        static ULONG CalcSectionSize(void);

        USHORT GetWindowSize(void) const;
        void   SetWindowSize(USHORT);

        DWORD  GetRecoverAckTimeout(void) const;
        DWORD  GetAckTimeout(void) const;
        USHORT GetSegmentSize(void) const;

    private:
//
// BEGIN Network Monitor tag
//
        DWORD   m_dwRecoverAckTimeout;
        DWORD   m_dwAckTimeout;
        USHORT  m_wSegmentSize;
        USHORT  m_wWindowSize;

#if 0
        UCHAR   m_abBody[ CONNECTION_PARAMETERS_BODY_SIZE ] ;
#endif
//
// END Network Monitor tag
//
};

#pragma pack(pop)


/*================================================================

 Routine Name: CCPSection::CCPSection

 Description: Constructor

==================================================================*/

inline  CCPSection::CCPSection(USHORT wWindowSize,
                               DWORD  dwRecoverAckTimeout,
                               DWORD  dwAckTimeout,
                               USHORT wSegmentSize
                              ) : m_wWindowSize(wWindowSize),
                                  m_dwRecoverAckTimeout(dwRecoverAckTimeout),
                                  m_dwAckTimeout(dwAckTimeout),
                                  m_wSegmentSize(wSegmentSize)
{

}

inline ULONG
CCPSection::CalcSectionSize(void)
{
    return sizeof(CCPSection);
}

inline USHORT
CCPSection::GetWindowSize(void) const
{
    return m_wWindowSize;
}

inline void
CCPSection::SetWindowSize(USHORT wWindowSize)
{
    m_wWindowSize = wWindowSize;
}


inline DWORD
CCPSection::GetRecoverAckTimeout(void) const
{
    return m_dwRecoverAckTimeout;
}

inline DWORD
CCPSection::GetAckTimeout(void) const
{
    return m_dwAckTimeout;
}

inline USHORT
CCPSection::GetSegmentSize(void) const
{
    return m_wSegmentSize;
}

/*
=============================== Internal Section ==========================

+-----------------------+------------------------------------------------+----------+
| Field Name            | Description                                    |Field Size|
+-----------------------+------------------------------------------------+----------+
|                          Falcon BASE HEADER                                       |
|                                                                                   |
+-----------------------+------------------------------------------------+----------+
|Flags                  | 0-3: Packet Type                               | 2 bytes  |
|                       | 4:   Refuse connection bit                     |          |
+-----------------------+------------------------------------------------+----------+
|Reserve                |                                                | 2 bytes  |
+-----------------------+------------------------------------------------+----------+
|                         Specific packet body                                      |
+-----------------------+------------------------------------------------+----------+

*/
#pragma pack(push, 1)

struct CInternalSection {
    public:
        CInternalSection(USHORT usPacketType);

        static ULONG CalcSectionSize(void);
        PCHAR GetNextSection(void) const;

        USHORT GetPacketType(void) const;
        USHORT GetRefuseConnectionFlag(void) const;

        void SetRefuseConnectionFlag(void);

		void SectionIsValid(PCHAR PacketEnd) const;

    private:
//
// BEGIN Network Monitor tag
//
        USHORT            m_bReserved;
        union
        {
            USHORT m_wFlags;
            struct
            {
                USHORT m_bfType : 4;
                USHORT m_bfConnectionRefuse : 1;
            };
        };
//
// END Network Monitor tag
//
};

#pragma pack(pop)

inline
CInternalSection::CInternalSection(USHORT usPacketType
                                ) : m_bReserved(0),
                                    m_wFlags(0)
{
    m_bfType = usPacketType;
}

inline ULONG
CInternalSection::CalcSectionSize(void)
{
    return sizeof(CInternalSection);
}

inline PCHAR
CInternalSection::GetNextSection(void) const
{
    return (PCHAR)this + sizeof(*this);
}

inline USHORT
CInternalSection::GetPacketType(void) const
{
    return m_bfType;
}

inline USHORT
CInternalSection::GetRefuseConnectionFlag(void) const
{
    return m_bfConnectionRefuse;
}

inline void
CInternalSection::SetRefuseConnectionFlag(void)
{
    m_bfConnectionRefuse = (USHORT) TRUE;
}



#endif //__QM_INTERNAL_PACKET__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\phmqf.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    phmqf.h

Abstract:

    Packet header for Multi Queue Format.

Author:

    Shai Kariv  (shaik)  24-Apr-2000

--*/

#ifndef __PHMQF_H
#define __PHMQF_H

/*+++

    Note: Packet either contains none of the headers of all 4 (destination,
	admin, response, signature).

    BaseMqf header fields:
    
+----------------+-------------------------------------------------------+----------+
| FIELD NAME     | DESCRIPTION                                           | SIZE     |
+----------------+-------------------------------------------------------+----------+
| Header Size    | Size of the header, in bytes, including header size   | 4 bytes  |
+----------------+-------------------------------------------------------+----------+
| Header ID      | Identification of the header                          | 2 bytes  |
+----------------+-------------------------------------------------------+----------+
| Reserved       | Reserved for future extensions. Must be set to zero.  | 2 bytes  |
+----------------+-------------------------------------------------------+----------+
| nMqf           | Number of queue format elements.                      | 4 bytes  |
+----------------+-------------------------------------------------------+----------+
| Data           | Representation of the queue format names.             | Variable |
+----------------+-------------------------------------------------------+----------+

---*/


#pragma pack(push, 1)
#pragma warning(disable: 4200)  //  zero-sized array in struct/union (enabeld later)


class CBaseMqfHeader
{
public:

    //
    // Construct the base mqf header
    //
    CBaseMqfHeader(const QUEUE_FORMAT mqf[], ULONG nMqf, USHORT id);

    //
    // Get size in bytes of the base mqf header
    //
    static ULONG CalcSectionSize(const QUEUE_FORMAT mqf[], ULONG nMqf);

    //
    // Get pointer to first byte after the base mqf header
    //
    PCHAR  GetNextSection(VOID) const;
      
    //
    // Get array of multi queue formats from the base mqf header
    //
    VOID   GetMqf(QUEUE_FORMAT * mqf, ULONG nMqf);

    //
    // Get one queue format from the base mqf header buffer
    //
    UCHAR * GetQueueFormat(const UCHAR * pBuffer, QUEUE_FORMAT * pqf, UCHAR * pEnd = NULL);

    //
    // Get a pointer to the serialization buffer
    //
    UCHAR * GetSerializationBuffer(VOID);

    //
    // Get number of queue format elements in the base mqf header
    //
    ULONG  GetNumOfElements(VOID) const;

	void SectionIsValid(PCHAR PacketEnd);

private:

    //
    // Store one queue format data in the base mqf header buffer
    //
    UCHAR * SerializeQueueFormat(const QUEUE_FORMAT * pqf, UCHAR * pBuffer);

    //
    // Get size, in bytes, up to and including queue format
    //
    static size_t CalcQueueFormatSize(const QUEUE_FORMAT * pqf, size_t cbSize);

private:

    //
    // Size in bytes of the base mqf header including data
    //
    ULONG  m_cbSize;

    //
    // ID number of the base mqf header
    //
    USHORT m_id;

    //
    // Reserved (for alignment)
    //
    USHORT m_ReservedSetToZero;

    //
    // Number of queue format elements in the base mqf header
    //
    ULONG  m_nMqf;

    //
    // Buffer with all queue formats data
    //
    UCHAR  m_queues[0];

}; // CBaseMqfHeader


#pragma warning(default: 4200)  //  zero-sized array in struct/union
#pragma pack(pop)



////////////////////////////////////////////////////////
//
//  Implementation
//

inline
CBaseMqfHeader::CBaseMqfHeader(
    const QUEUE_FORMAT mqf[],
    ULONG              nMqf,
    USHORT             id
    ) :
    m_id(id),
    m_ReservedSetToZero(0),
    m_nMqf(nMqf)
{
    //
    // Store data of each queue format in the buffer
    //
    UCHAR * pBuffer = &m_queues[0];
    ASSERT(ISALIGN4_PTR(pBuffer));
    UCHAR * pStart = pBuffer;

    for (ULONG ix = 0 ; ix < nMqf; ++ix)
    {
        pBuffer = SerializeQueueFormat(&mqf[ix], pBuffer);
    }

    //
    // Calculate size of the entire header
    //
    m_cbSize = sizeof(*this) + static_cast<ULONG>(pBuffer - pStart);
    if (!ISALIGN4_ULONG(m_cbSize))
    {
        m_cbSize = ALIGNUP4_ULONG(m_cbSize);
    }
    ASSERT(m_cbSize == CalcSectionSize(mqf, nMqf));

} // CBaseMqfHeader::CBaseMqfHeader

    
inline 
ULONG
CBaseMqfHeader::CalcSectionSize(
    const QUEUE_FORMAT mqf[], 
    ULONG nMqf
    )
{
    size_t cbSize = sizeof(CBaseMqfHeader);

    //
    // Add size of each queue format data
    //
    for (ULONG ix = 0 ; ix < nMqf; ++ix)
    {
        cbSize = CalcQueueFormatSize(&mqf[ix], cbSize);
    }

    //
    // Align the entire header size to 4 bytes boundaries
    //
    cbSize = ALIGNUP4_ULONG(cbSize);
    return static_cast<ULONG>(cbSize);

} // CBaseMqfHeader::CalcSectionSize


inline ULONG CBaseMqfHeader::GetNumOfElements(VOID) const
{
    return m_nMqf;

} // CBaseMqfHeader::GetNumOfElements


inline PCHAR CBaseMqfHeader::GetNextSection(VOID) const
{
    ASSERT(ISALIGN4_ULONG(m_cbSize));
	ULONG_PTR ptrArray[] = {(ULONG_PTR)this, m_cbSize};
	ULONG_PTR size = SafeAddPointers (2, ptrArray);
    return (PCHAR)size;
} // CBaseMqfHeader::GetNextSection


inline VOID CBaseMqfHeader::GetMqf(QUEUE_FORMAT * mqf, ULONG nMqf)
{
    //
    // Caller must pass exactly the size we have
    //
    ASSERT(nMqf == m_nMqf);

    //
    // Get data of each queue format from the buffer and store it
    // as QUEUE_FORMAT in the specified array
    //
    UCHAR * pBuffer = &m_queues[0];
    ASSERT(ISALIGN4_PTR(pBuffer));

    for (ULONG ix = 0 ; ix < nMqf; ++ix)
    {
        pBuffer = GetQueueFormat(pBuffer, &mqf[ix]);
    }
} // CBaseMqfHeader::GetMqf


inline UCHAR * CBaseMqfHeader::GetSerializationBuffer(VOID)
{
    return &m_queues[0];
}


inline 
UCHAR * 
CBaseMqfHeader::SerializeQueueFormat(
    const QUEUE_FORMAT * pqf, 
    UCHAR *              pBuffer
    )
{
    //
    // Two bytes hold the queue format type.
    // Note that pBuffer is not necessarily aligned to 4 bytes boundaries here.
    //
    USHORT type = static_cast<USHORT>(pqf->GetType());
    (*reinterpret_cast<USHORT*>(pBuffer)) = type;
    pBuffer += sizeof(USHORT);

    //
    // Rest of bytes hold per-type data (e.g. GUID) and aligned appropriately
    //
    switch (type)
    {
        case QUEUE_FORMAT_TYPE_PUBLIC:
        {
            //
            // Align to 4 bytes boundaries and serialize GUID into the buffer
            //
            pBuffer = reinterpret_cast<UCHAR*>(ALIGNUP4_PTR(pBuffer));
            (*reinterpret_cast<GUID*>(pBuffer)) = pqf->PublicID();
            pBuffer += sizeof(GUID);
            ASSERT(ISALIGN4_PTR(pBuffer));
            break;
        }

        case QUEUE_FORMAT_TYPE_DL:
        {
            //
            // Align to 4 bytes boundaries and serialize GUID into the buffer
            //
            pBuffer = reinterpret_cast<UCHAR*>(ALIGNUP4_PTR(pBuffer));
            const DL_ID& id = pqf->DlID();
            (*reinterpret_cast<GUID*>(pBuffer)) = id.m_DlGuid;
            pBuffer += sizeof(GUID);

            //
            // Serialize the domain (string) if exists, empty string otherwise.
            //
            ASSERT(ISALIGN2_PTR(pBuffer));
            if (id.m_pwzDomain == NULL)
            {
                memcpy(pBuffer, L"", sizeof(WCHAR));
                pBuffer += sizeof(WCHAR);
                break;
            }

            size_t cbSize = (wcslen(id.m_pwzDomain) + 1) * sizeof(WCHAR);
            memcpy(pBuffer, id.m_pwzDomain, cbSize);
            pBuffer += cbSize;
            break;
        }

        case QUEUE_FORMAT_TYPE_PRIVATE:
        {
            //
            // Align to 4 bytes boundaries and serialize OBJECTID into the buffer
            //
            pBuffer = reinterpret_cast<UCHAR*>(ALIGNUP4_PTR(pBuffer));
            (*reinterpret_cast<OBJECTID*>(pBuffer)) = pqf->PrivateID();
            pBuffer += sizeof(OBJECTID);
            ASSERT(ISALIGN4_PTR(pBuffer));
            break;
        }

        case QUEUE_FORMAT_TYPE_DIRECT:
        {
            //
            // Serialize the direct ID (string) into the buffer.
            //
            ASSERT(ISALIGN2_PTR(pBuffer));
            LPCWSTR pDirectId = pqf->DirectID();
            ASSERT(pDirectId != NULL);
            size_t cbSize = (wcslen(pDirectId) + 1) * sizeof(WCHAR);
            memcpy(pBuffer, pDirectId, cbSize);
            pBuffer += cbSize;
            break;
        }

        case QUEUE_FORMAT_TYPE_MULTICAST:
        {
            //
            // Align to 4 bytes boundaries and serialize MULTICAST_ID into the buffer
            //
            pBuffer = reinterpret_cast<UCHAR*>(ALIGNUP4_PTR(pBuffer));
            const MULTICAST_ID& id = pqf->MulticastID();
            (*reinterpret_cast<ULONG*>(pBuffer)) = id.m_address;
            pBuffer += sizeof(ULONG);
            (*reinterpret_cast<ULONG*>(pBuffer)) = id.m_port;
            pBuffer += sizeof(ULONG);
            break;
        }

        default:
        {
            ASSERT(("Unexpected queue format type", 0));
            break;
        }
    }

    //
    // Return pointer to next available byte in buffer.
    //
    return pBuffer;

} // CBaseMqfHeader::SerializeQueueFormat


inline
UCHAR *
CBaseMqfHeader::GetQueueFormat(
    const UCHAR  * pBuffer,
    QUEUE_FORMAT * pqf,
    UCHAR        * pEnd //= NULL,
    )
{
    //
    // First 2 bytes hold the queue type.
    // Note that pBuffer is not necessarily aligned to 4 bytes boundaries here.
    //
    USHORT type;
    pBuffer = GetSafeDataAndAdvancePointer<USHORT>(pBuffer, pEnd, &type);

    //
    // Rest of bytes hold per-type data (e.g. GUID) and aligned appropriately
    //
    switch (type)
    {
        case QUEUE_FORMAT_TYPE_PUBLIC:
        {
            //
            // Align to 4 bytes boundaries and get the GUID from the buffer
            //
            pBuffer = reinterpret_cast<UCHAR*>(ALIGNUP4_PTR(pBuffer));
            GUID publicID;
			pBuffer = GetSafeDataAndAdvancePointer<GUID>(pBuffer, pEnd, &publicID);
            pqf->PublicID(publicID);
            ASSERT(ISALIGN4_PTR(pBuffer));
            break;
        }

        case QUEUE_FORMAT_TYPE_DL:
        {
            //
            // Align to 4 bytes boundaries and get the GUID from the buffer
            //
            pBuffer = reinterpret_cast<UCHAR*>(ALIGNUP4_PTR(pBuffer));
            DL_ID id;
			pBuffer = GetSafeDataAndAdvancePointer<GUID>(pBuffer, pEnd, &id.m_DlGuid);
            //
            // Get the domain (string) from the buffer. Empty string means no domain.
            //
            ASSERT(ISALIGN2_PTR(pBuffer));
            LPWSTR pDomain = const_cast<WCHAR*>(reinterpret_cast<const WCHAR*>(pBuffer));
            size_t cbSize = mqwcsnlen(pDomain, (pEnd - pBuffer) / sizeof(WCHAR));
            if (cbSize >= (pEnd - pBuffer) / sizeof(WCHAR))
            {
		        ReportAndThrow("MQF section is not valid: DL queue without NULL terminator");
            }
            id.m_pwzDomain = NULL;
            if (cbSize != 0)
            {
                id.m_pwzDomain = pDomain;
            }
            cbSize = (cbSize + 1) * sizeof(WCHAR);
            pBuffer += cbSize;

            pqf->DlID(id);
            break;
        }

        case QUEUE_FORMAT_TYPE_PRIVATE:
        {
            //
            // Align to 4 bytes boundaries and get the OBJECTID from the buffer
            //
            pBuffer = reinterpret_cast<UCHAR*>(ALIGNUP4_PTR(pBuffer));
			OBJECTID objectID;
			pBuffer = GetSafeDataAndAdvancePointer<OBJECTID>(pBuffer, pEnd, &objectID);
			if (0 == objectID.Uniquifier)
			{
		        ReportAndThrow("Mqf section is not valid: private queue Uniquifier can not be 0");
			}		

            pqf->PrivateID(objectID);
            ASSERT(ISALIGN4_PTR(pBuffer));
            break;
        }

        case QUEUE_FORMAT_TYPE_DIRECT:
        {
            //
            // Get the direct ID (string) from the buffer.
            //
            ASSERT(ISALIGN2_PTR(pBuffer));
            LPWSTR pDirectId = const_cast<LPWSTR>(reinterpret_cast<const WCHAR*>(pBuffer));
            size_t cbSize = mqwcsnlen(pDirectId, (pEnd - pBuffer) / sizeof(WCHAR));
            if (cbSize >= (pEnd - pBuffer) / sizeof(WCHAR))
            {
		        ReportAndThrow("MQF section is not valid: Direct queue without NULL terminator");
            }
            pqf->DirectID(pDirectId);

			cbSize = (cbSize + 1) * sizeof(WCHAR);
            pBuffer += cbSize;
            break;
        }

        case QUEUE_FORMAT_TYPE_MULTICAST:
        {
            //
            // Align to 4 bytes boundaries and get the address and port from the buffer
            //
            pBuffer = reinterpret_cast<UCHAR*>(ALIGNUP4_PTR(pBuffer));
            MULTICAST_ID id;
			pBuffer = GetSafeDataAndAdvancePointer<ULONG>(pBuffer, pEnd, &id.m_address);
 			pBuffer = GetSafeDataAndAdvancePointer<ULONG>(pBuffer, pEnd, &id.m_port);
			pqf->MulticastID(id);
            break;
        }

        default:
        {
	        ReportAndThrow("MQF section is not valid: Queue type is not valid");
        }
    }

    //
    // Return pointer to next available byte in buffer.
    //
    return const_cast<UCHAR*>(pBuffer);

} // CBaseMqfHeader::GetQueueFormat


inline
size_t
CBaseMqfHeader::CalcQueueFormatSize(
    const QUEUE_FORMAT * pqf,
    size_t               cbSize
    )
{
    //
    // Two bytes hold the queue type
    //
    cbSize += sizeof(USHORT);

    //
    // Rest of bytes hold per-type data (e.g. GUID) and aligned appropriately
    //
    switch (pqf->GetType())
    {
        case QUEUE_FORMAT_TYPE_PUBLIC:
        {
            cbSize = ALIGNUP4_ULONG(cbSize);
            cbSize += sizeof(GUID);
            ASSERT(ISALIGN4_ULONG(cbSize));
            break;
        }

        case QUEUE_FORMAT_TYPE_DL:
        {
            cbSize = ALIGNUP4_ULONG(cbSize);
            cbSize += sizeof(GUID);

            ASSERT(ISALIGN2_ULONG(cbSize));
            const DL_ID& id = pqf->DlID();
            if (id.m_pwzDomain == NULL)
            {
                cbSize += sizeof(WCHAR);
                break;
            }

            cbSize += (wcslen(id.m_pwzDomain) + 1) * sizeof(WCHAR);
            break;
        }

        case QUEUE_FORMAT_TYPE_PRIVATE:
        {
            cbSize = ALIGNUP4_ULONG(cbSize);
            cbSize += sizeof(OBJECTID);
            ASSERT(ISALIGN4_ULONG(cbSize));
            break;
        }

        case QUEUE_FORMAT_TYPE_DIRECT:
        {
            ASSERT(ISALIGN2_ULONG(cbSize));
            LPCWSTR pDirectId = pqf->DirectID();
            cbSize += (wcslen(pDirectId) + 1) * sizeof(WCHAR);
            break;
        }

        case QUEUE_FORMAT_TYPE_MULTICAST:
        {
            cbSize = ALIGNUP4_ULONG(cbSize);
            cbSize += sizeof(ULONG);
            cbSize += sizeof(ULONG);
            ASSERT(ISALIGN4_ULONG(cbSize));
            break;
        }

        default:
        {
            ASSERT(("Unexpected queue format type", 0));
            break;
        }
    }

    //
    // Note that cbSize is not necessarily aligned at this point.
    //
    return cbSize;

} // CBaseMqfHeader::CalcQueueFormatSize

#endif // __PHMQF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\phinfo.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    phinfo.h

Abstract:

    Falcon Packet header info, not passed on network, only stored on disk

Author:

    Erez Haba (erezh) 4-Jun-1996

--*/

#ifndef __PHINFO_H
#define __PHINFO_H

class CPacket;

//---------------------------------------------------------
//
// class CPacketInfo
//
//---------------------------------------------------------

#pragma pack(push, 1)

class CPacketInfo {
public:
    CPacketInfo(ULONGLONG SequentialId);

    ULONG SequentialIdLow32() const;
    ULONG SequentialIdHigh32() const;
    ULONGLONG SequentialId() const;
    void SequentialID(ULONGLONG SequentialId);

    ULONG ArrivalTime() const;
    void ArrivalTime(ULONG ulArrivalTime);

    BOOL InSourceMachine() const;
    void InSourceMachine(BOOL);

    BOOL InTargetQueue() const;
    void InTargetQueue(BOOL);

    BOOL InJournalQueue() const;
    void InJournalQueue(BOOL);

    BOOL InMachineJournal() const;
    void InMachineJournal(BOOL);

    BOOL InDeadletterQueue() const;
    void InDeadletterQueue(BOOL);

    BOOL InMachineDeadxact() const;
    void InMachineDeadxact(BOOL);

    BOOL InConnectorQueue() const;
    void InConnectorQueue(BOOL);

    BOOL InTransaction() const;
    void InTransaction(BOOL);

    BOOL TransactSend() const;
    void TransactSend(BOOL);

    const XACTUOW* Uow() const;
    void Uow(const XACTUOW* pUow);

	void SetOnDiskSignature();
	void ClearOnDiskSignature();
	BOOL ValidOnDiskSignature();

    BOOL SequentialIdMsmq3Format() const;
    void SequentialIdMsmq3Format(BOOL);

private:
    union {
        //
        // Used by MSMQ 3.0 (Whistler) and higher
        //
        ULONGLONG m_SequentialId;

        struct {
            //
            // Used by MSMQ 1.0 and 2.0 for m_pPacket
            //
            ULONG m_SequentialIdLow32;

            //
            // Used by MSMQ 1.0 and 2.0 for a 32 bit SequentialId
            //
            ULONG m_SequentialIdHigh32;
        };
    };
    ULONG m_ulArrivalTime;
    union {
        ULONG m_ulFlags;
        struct {
            ULONG m_bfInSourceMachine   : 1;    // The packet was originaly send from this machine
            ULONG m_bfInTargetQueue     : 1;    // The packet has reached destination queue
            ULONG m_bfInJournalQueue    : 1;    // The packet is in a journal queue
            ULONG m_bfInMachineJournal  : 1;    // The packet is in the machine journal
            ULONG m_bfInDeadletterQueue : 1;    // The packet is in a deadletter queue
            ULONG m_bfInMachineDeadxact : 1;    // The packet is in the machine deadxact
            ULONG m_bfTransacted        : 1;    // The packet is under transaction control
            ULONG m_bfTransactSend      : 1;    // The transacted packet is sent (not received)
            ULONG m_bfInConnectorQueue  : 1;    // The packet has reached the Connector queue
                                                // used in recovery of transacted messages in Connector
			ULONG m_bfSignature			: 12;	// Signature required for valid header
            ULONG m_bfSequentialIdMsmq3 : 1;    // SequentialId is in msmq3 format (i.e. 64 bit)
        };
    };
    XACTUOW m_uow;
};

#pragma pack(pop)


inline CPacketInfo::CPacketInfo(ULONGLONG SequentialId) :
    m_SequentialId(SequentialId),
    m_ulArrivalTime(0),
    m_ulFlags(0)
{
    memset(&m_uow, 0, sizeof(XACTUOW));
    SequentialIdMsmq3Format(TRUE);
}

inline ULONGLONG CPacketInfo::SequentialId() const
{
    return m_SequentialId;
}

inline ULONG CPacketInfo::SequentialIdLow32() const
{
    return m_SequentialIdLow32;
}

inline ULONG CPacketInfo::SequentialIdHigh32() const
{
    return m_SequentialIdHigh32;
}

inline void CPacketInfo::SequentialID(ULONGLONG SequentialId)
{
    m_SequentialId = SequentialId;
}

inline ULONG CPacketInfo::ArrivalTime() const
{
    return m_ulArrivalTime ;
}

inline void CPacketInfo::ArrivalTime(ULONG ulArrivalTime)
{
    m_ulArrivalTime = ulArrivalTime;
}

inline BOOL CPacketInfo::InSourceMachine() const
{
    return m_bfInSourceMachine;
}

inline void CPacketInfo::InSourceMachine(BOOL f)
{
    m_bfInSourceMachine = f;
}

inline BOOL CPacketInfo::InTargetQueue() const
{
    return m_bfInTargetQueue;
}

inline void CPacketInfo::InTargetQueue(BOOL f)
{
    m_bfInTargetQueue = f;
}

inline BOOL CPacketInfo::InJournalQueue() const
{
    return m_bfInJournalQueue;
}

inline void CPacketInfo::InJournalQueue(BOOL f)
{
    m_bfInJournalQueue = f;
}

inline BOOL CPacketInfo::InMachineJournal() const
{
    return m_bfInMachineJournal;
}

inline void CPacketInfo::InMachineJournal(BOOL f)
{
    m_bfInMachineJournal = f;
}

inline BOOL CPacketInfo::InDeadletterQueue() const
{
    return m_bfInDeadletterQueue;
}

inline void CPacketInfo::InDeadletterQueue(BOOL f)
{
    m_bfInDeadletterQueue = f;
}

inline BOOL CPacketInfo::InMachineDeadxact() const
{
    return m_bfInMachineDeadxact;
}

inline void CPacketInfo::InMachineDeadxact(BOOL f)
{
    m_bfInMachineDeadxact = f;
}

inline BOOL CPacketInfo::InConnectorQueue() const
{
    return m_bfInConnectorQueue;
}

inline void CPacketInfo::InConnectorQueue(BOOL f)
{
    m_bfInConnectorQueue = f;
}

inline BOOL CPacketInfo::InTransaction() const
{
    return m_bfTransacted;
}

inline void CPacketInfo::InTransaction(BOOL f)
{
    m_bfTransacted = f;
}

inline BOOL CPacketInfo::TransactSend() const
{
    return m_bfTransactSend;
}

inline void CPacketInfo::TransactSend(BOOL f)
{
   m_bfTransactSend = f;
}

inline const XACTUOW* CPacketInfo::Uow() const
{
    return &m_uow;
}

inline void CPacketInfo::Uow(const XACTUOW* pUow)
{
    memcpy(&m_uow, pUow, sizeof(XACTUOW));
}

inline void CPacketInfo::SetOnDiskSignature()
{
	m_bfSignature = 0xabc;
}

inline void CPacketInfo::ClearOnDiskSignature()
{
	m_bfSignature = 0;
}

inline BOOL CPacketInfo::ValidOnDiskSignature()
{
	return (m_bfSignature & 0xfff) == 0xabc;
}

inline BOOL CPacketInfo::SequentialIdMsmq3Format() const
{
    return m_bfSequentialIdMsmq3;
}

inline void CPacketInfo::SequentialIdMsmq3Format(BOOL f)
{
    m_bfSequentialIdMsmq3 = f;
}

#endif // __PHINFO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\phsecure.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    phsecure.h

Abstract:

    Handle Security section in Falcon Header

Author:

    Uri Habusha (urih) 5-Feb-96

--*/

#ifndef __PHSECURE_H
#define __PHSECURE_H

#include <mqmacro.h>

#pragma pack(push, 1)
#pragma warning(disable: 4200)  //  zero-sized array in struct/union (enabeld later)

//
// The following structures are used to add new security related data into
// the m_abSecurityInfo[] buffer. By "new" I mean anything which was not in
// MSMQ1.0 or win2k RTM.
// The new data appear at the end of the buffer. If we add new subsections in
// future releases of MSMQ, they will be backward compatible because old
// versions of msmq will see them an unknown type and ignore them.
// compatibility with msmq1.0 and win2k rtm:
// These versions of msmq look at m_ulProvInfoSize to determine size of name
// of authentication provider and then read the provider name as string, using
// wcslen. so I'll add the new section after the null termination and update
// m_ulProvInfoSize to reflect new size (authentication provider + new data).
// So old code will compute size correctly, will read provider correctly and
// will ignore all new data.
//

//
// define types of subsections.
//
enum enumSecInfoType
{
    //
    // Used for testing only.
    //
    e_SecInfo_Test = 0,
    //
    // This one is the extra signature, done by run-time in the context of
    // the user process, using the user private key.
    //
    e_SecInfo_User_Signature_ex = 1,

    //
    // This one is the extra signature, done by msmq service, using the
    // private key of the service. The msmq service will add this signature,
    // (instead of being add by the run time) for dependent clients and for
    // connector applications that sign by themselves. The default is that
    // user sign. We can't sent a packet without this extra signature,
    // because it will be rejected by the receiver side.
    //
    e_SecInfo_QM_Signature_ex
} ;

//
//  Structure members:
// eType- type of subsection.
// wSubSectionLen- length of the entire subsection structure, including data.
// wFlags- flags to specify features of this subsection. This word is context
//   sensitive and depend on the type of subsection. So each type of
//   subsection may have its own definition of a bitfield structure.
//   m_bfDefault- 1 if the section has default data. In that case, the aData
//     buffer is not present.
// aData[]- buffer containing the data. This buffer may have internal
//          structure, known to the specific code.
//
struct _SecuritySubSectionEx
{
    enum enumSecInfoType eType ;
    USHORT               wSubSectionLen ;

    union
    {
        USHORT wFlags;
        struct _DefaultFlag
        {
            USHORT m_bfDefault    : 1;
        } _DefaultFlags ;
        struct _UserSigEx
        {
            //
            // This is the structure definitions for subsection type
            // e_SecInfo_User_Signature_ex.
            // a 0 mean the relevant field is not included in the enhanced
            // signature.
            //
            USHORT m_bfTargetQueue  : 1;
            USHORT m_bfSourceQMGuid : 1;
            //
            // Flags provider by caller to MQSendMessage()
            //
            USHORT m_bfUserFlags  : 1;
            USHORT m_bfConnectorType : 1;
        } _UserSigEx ;
    } _u ;

    CHAR   aData[0] ;
} ;

//
//  Structure members:
// cSubSectionCount - number of subsections.
// wSectionLen - overall length of this section, including all subsections.
// aData[]- buffer containing all the subsection.
//
struct _SecuritySectionEx
{
    USHORT  cSubSectionCount ;
    USHORT  wSectionLen ;

    CHAR    aData[0] ;
} ;

//
//  struct CSecurityHeader
//

struct CSecurityHeader {
public:

    inline CSecurityHeader();

    static ULONG CalcSectionSize(USHORT, USHORT, USHORT, ULONG, ULONG);
    inline PCHAR GetNextSection(void) const;

    inline void SetAuthenticated(BOOL);
    inline BOOL IsAuthenticated(void) const;

    inline void SetLevelOfAuthentication(UCHAR);
    inline UCHAR GetLevelOfAuthentication(void) const;

    inline void SetEncrypted(BOOL);
    inline BOOL IsEncrypted(void) const;

    inline void SetSenderIDType(USHORT wSenderID);
    inline USHORT GetSenderIDType(void) const;

    inline void SetSenderID(const UCHAR *pbSenderID, USHORT wSenderIDSize);
    inline const UCHAR* GetSenderID(USHORT* pwSize) const;

    inline void SetSenderCert(const UCHAR *pbSenderCert, ULONG ulSenderCertSize);
    inline const UCHAR* GetSenderCert(ULONG* pulSize) const;
    inline BOOL SenderCertExist(void) const;

    inline void SetEncryptedSymmetricKey(const UCHAR *pbEncryptedKey, USHORT wEncryptedKeySize);
    inline const UCHAR* GetEncryptedSymmetricKey(USHORT* pwSize) const;

    inline void SetSignature(const UCHAR *pbSignature, USHORT wSignatureSize);
	inline USHORT GetSignatureSize(void) const;
    inline const UCHAR* GetSignature(USHORT* pwSize) const;

    inline void SetProvInfoEx( ULONG    ulSize,
                               BOOL     bDefProv,
                               LPCWSTR  wszProvName,
                               ULONG    dwPRovType ) ;
    inline void GetProvInfo(BOOL *pbDefProv, LPCWSTR *wszProvName, ULONG *pdwPRovType) const;

    inline void SetSectionEx(const UCHAR *pSection, ULONG wSectionSize);
    inline const struct _SecuritySubSectionEx *
                     GetSubSectionEx( enum enumSecInfoType eType ) const ;

	void SectionIsValid(PCHAR PacketEnd) const;
	
private:
    inline const UCHAR *GetSectionExPtr() const ;
    inline void SetProvInfo(BOOL bDefProv, LPCWSTR wszProvName, ULONG dwPRovType);

//
// BEGIN Network Monitor tag
//   m_bfSecInfoEx- this flag indicates that "m_abSecurityInfo" buffer
//      contains more data than was in MSMQ1.0 and win2k rtm.
//      In MSMQ1.0, this buffer optionally contained the security provider
//      used for authentication (at the end of the bufferm after sender
//      sid and flags).
//
    union {
        USHORT m_wFlags;
        struct {
            USHORT m_bfSenderIDType			: 4;
            USHORT m_bfAuthenticated		: 1;
            USHORT m_bfEncrypted			: 1;
            USHORT m_bfDefProv				: 1;
            USHORT m_bfSecInfoEx			: 1;
            USHORT m_LevelOfAuthentication	: 4;
        };
    };
    USHORT m_wSenderIDSize;
    USHORT m_wEncryptedKeySize;
    USHORT m_wSignatureSize;
    ULONG  m_ulSenderCertSize;
    ULONG  m_ulProvInfoSize;
    UCHAR  m_abSecurityInfo[0];
//
// END Network Monitor tag
//
};

#pragma warning(default: 4200)  //  zero-sized array in struct/union
#pragma pack(pop)

/*=============================================================

 Routine Name:  CSecurityHeader::

 Description:

===============================================================*/
inline CSecurityHeader::CSecurityHeader():
    m_wFlags(0),
    m_wSenderIDSize(0),
    m_wEncryptedKeySize(0),
    m_wSignatureSize(0),
    m_ulSenderCertSize(0),
    m_ulProvInfoSize(0)
{
}

/*=============================================================

 Routine Name:  CSecurityHeader::

 Description:

===============================================================*/
inline
ULONG
CSecurityHeader::CalcSectionSize(
    USHORT wSenderIDSize,
    USHORT wEncryptedKeySize,
    USHORT wSignatureSize,
    ULONG  ulSenderCertSize,
    ULONG  ulProvInfoSize
    )
{
    if (!wSenderIDSize &&
        !wEncryptedKeySize &&
        !wSignatureSize &&
        !ulSenderCertSize &&
        !ulProvInfoSize)
    {
        return 0;
    }
    else
    {
        // If the message is signed, we must have also the user identity.
        return (
               sizeof(CSecurityHeader) +
               ALIGNUP4_ULONG(wSenderIDSize) +
               ALIGNUP4_ULONG(wEncryptedKeySize) +
               ALIGNUP4_ULONG(wSignatureSize) +
               ALIGNUP4_ULONG(ulSenderCertSize) +
               ALIGNUP4_ULONG(ulProvInfoSize)
               );
    }
}

/*=============================================================

 Routine Name:  CSecurityHeader::

 Description:

===============================================================*/
inline PCHAR CSecurityHeader::GetNextSection(void) const
{
    // At least one of the security parameters should exist inorder to
    // have the security header, otherwise no need to include it in the
    // message.
    ASSERT(m_wSenderIDSize ||
           m_wEncryptedKeySize ||
           m_wSignatureSize ||
           m_ulSenderCertSize ||
           m_ulProvInfoSize);

	ULONG_PTR ptrArray[] = {(ULONG_PTR)this,
					        sizeof(*this),
							SafeAlignUp4Ptr(m_wSenderIDSize),
							SafeAlignUp4Ptr(m_wEncryptedKeySize),
							SafeAlignUp4Ptr(m_wSignatureSize),
							SafeAlignUp4Ptr(m_ulSenderCertSize),
							SafeAlignUp4Ptr(m_ulProvInfoSize)
							};
	ULONG_PTR size = SafeAddPointers (7, ptrArray);
	return (PCHAR)size;
}

/*=============================================================

 Routine Name:  CSecurityHeader::SetAuthenticated

 Description:   Set the authenticated bit

===============================================================*/
inline void CSecurityHeader::SetAuthenticated(BOOL f)
{
    m_bfAuthenticated = (USHORT)f;
}

/*=============================================================

 Routine Name:   CSecurityHeader::IsAuthenticated

 Description:    Returns TRUE if the msg is authenticated, False otherwise

===============================================================*/
inline BOOL
CSecurityHeader::IsAuthenticated(void) const
{
    return m_bfAuthenticated;
}

/*=============================================================

 Routine Name:  CSecurityHeader::SetLevelOfAuthentication

 Description:   Set the Level Of Authentication

===============================================================*/
inline void CSecurityHeader::SetLevelOfAuthentication(UCHAR Level)
{
    ASSERT(Level < 16); // There are four bits for LevelOfAuthentication.
    m_LevelOfAuthentication = (USHORT)Level;
}

/*==========================================================================

 Routine Name:   CSecurityHeader::GetLevelOfAuthentication

 Description:    Return the Level Of Authentication.

===========================================================================*/
inline UCHAR
CSecurityHeader::GetLevelOfAuthentication(void) const
{
    return m_LevelOfAuthentication;
}

/*=============================================================

 Routine Name:  CSecurityHeader::SetEncrypted

 Description:   Set Encrypted message bit

===============================================================*/
inline void CSecurityHeader::SetEncrypted(BOOL f)
{
    m_bfEncrypted = (USHORT)f;
}

/*=============================================================

 Routine Name:   CSecurityHeader::IsEncrypted

 Description:    Returns TRUE if the msg is Encrypted, False otherwise

===============================================================*/
inline BOOL CSecurityHeader::IsEncrypted(void) const
{
    return m_bfEncrypted;
}

/*=============================================================

 Routine Name:  CSecurityHeader::SetSenderIDType

 Description:

===============================================================*/
inline void CSecurityHeader::SetSenderIDType(USHORT wSenderID)
{
    ASSERT(wSenderID < 16); // There are four bits for the user ID type.
    m_bfSenderIDType = wSenderID;
}

/*=============================================================

 Routine Name:  CSecurityHeader::GetSenderIDType

 Description:

===============================================================*/
inline USHORT CSecurityHeader::GetSenderIDType(void) const
{
    return m_bfSenderIDType;
}

/*=============================================================

 Routine Name:  CSecurityHeader::SetSenderID

 Description:

===============================================================*/
inline void CSecurityHeader::SetSenderID(const UCHAR *pbSenderID, USHORT wSenderIDSize)
{
    // Should set the user identity BEFORE setting the encription and
    // authentication sections.
    ASSERT(!m_wEncryptedKeySize &&
           !m_wSignatureSize &&
           !m_ulSenderCertSize &&
           !m_ulProvInfoSize);
    m_wSenderIDSize = wSenderIDSize;
    memcpy(m_abSecurityInfo, pbSenderID, wSenderIDSize);
}

/*=============================================================

 Routine Name:  CSecurityHeader::GetSenderID

 Description:

===============================================================*/
inline const UCHAR* CSecurityHeader::GetSenderID(USHORT* pwSize) const
{
    *pwSize = m_wSenderIDSize;
    return m_abSecurityInfo;
}

/*=============================================================

 Routine Name:

 Description:

===============================================================*/
inline
void
CSecurityHeader::SetEncryptedSymmetricKey(
    const UCHAR *pbEncryptedKey,
    USHORT wEncryptedKeySize
    )
{
    // Should set the encryption section BEFORE setting the authentication
    // section.
    ASSERT(m_wEncryptedKeySize ||
           (!m_wSignatureSize && !m_ulSenderCertSize && !m_ulProvInfoSize));
    ASSERT(!m_wEncryptedKeySize || (m_wEncryptedKeySize == wEncryptedKeySize));
    m_wEncryptedKeySize = wEncryptedKeySize;
    //
    // It is possible to call this function with no buffer for the encrypted
    // key. This is done by the device driver. the device driver only makes
    // room in the security header for the symmetric key. The QM writes
    // the symmetric key in the security header after encrypting the message
    // body.
    //
    if (pbEncryptedKey)
    {
        memcpy(
            &m_abSecurityInfo[ALIGNUP4_ULONG(m_wSenderIDSize)],
            pbEncryptedKey,
            wEncryptedKeySize);
    }
}

/*=============================================================

 Routine Name:

 Description:

===============================================================*/
inline const UCHAR* CSecurityHeader::GetEncryptedSymmetricKey(USHORT* pwSize) const
{
    *pwSize = m_wEncryptedKeySize;
    return &m_abSecurityInfo[ALIGNUP4_ULONG(m_wSenderIDSize)];
}
/*=============================================================

 Routine Name:   CSecurityHeader::SetSignature

 Description:

===============================================================*/
inline void CSecurityHeader::SetSignature(const UCHAR *pbSignature, USHORT wSignatureSize)
{
    ASSERT(!m_ulSenderCertSize && !m_ulProvInfoSize);
    m_wSignatureSize = wSignatureSize;
    memcpy(
        &m_abSecurityInfo[ALIGNUP4_ULONG(m_wSenderIDSize) +
                          ALIGNUP4_ULONG(m_wEncryptedKeySize)],
        pbSignature,
        wSignatureSize
        );
}

/*=============================================================

 Routine Name:  CSecurityHeader::GetSignatureSize

 Description:

===============================================================*/
inline USHORT CSecurityHeader::GetSignatureSize(void) const
{
    return m_wSignatureSize;
}

/*=============================================================

 Routine Name:  CSecurityHeader::GetSignature

 Description:

===============================================================*/
inline const UCHAR* CSecurityHeader::GetSignature(USHORT* pwSize) const
{
    *pwSize = m_wSignatureSize;
    return &m_abSecurityInfo[ALIGNUP4_ULONG(m_wSenderIDSize) +
                             ALIGNUP4_ULONG(m_wEncryptedKeySize)];
}

/*=============================================================

 Routine Name:  CSecurityHeader::SetSenderCert

 Description:

===============================================================*/
inline void CSecurityHeader::SetSenderCert(const UCHAR *pbSenderCert, ULONG ulSenderCertSize)
{
    // Should set the user identity BEFORE setting the encription and
    // authentication sections.
    ASSERT(!m_ulProvInfoSize);
    m_ulSenderCertSize = ulSenderCertSize;
    memcpy(&m_abSecurityInfo[ALIGNUP4_ULONG(m_wSenderIDSize) +
                             ALIGNUP4_ULONG(m_wEncryptedKeySize) +
                             ALIGNUP4_ULONG(m_wSignatureSize)],
           pbSenderCert,
           ulSenderCertSize);
}

/*=============================================================

 Routine Name:  CSecurityHeader::GetSenderCert

 Description:

===============================================================*/
inline const UCHAR* CSecurityHeader::GetSenderCert(ULONG* pulSize) const
{
    *pulSize = m_ulSenderCertSize;
    return &m_abSecurityInfo[ALIGNUP4_ULONG(m_wSenderIDSize) +
                             ALIGNUP4_ULONG(m_wEncryptedKeySize) +
                             ALIGNUP4_ULONG(m_wSignatureSize)];
}

/*=============================================================

 Routine Name:  CSecurityHeader::SenderCertExist

 Description:	Returns TRUE if Sender Certificate exist

===============================================================*/
inline BOOL CSecurityHeader::SenderCertExist(void) const
{
    return(m_ulSenderCertSize != 0);
}

/*=============================================================

 Routine Name:  CSecurityHeader::SetProvInfo

 Description:

===============================================================*/
inline
void
CSecurityHeader::SetProvInfo(
    BOOL bDefProv,
    LPCWSTR wszProvName,
    ULONG ulProvType)
{
    m_bfDefProv = (USHORT)bDefProv;
    if(!m_bfDefProv)
    {
        //
        // We fill the provider info only if this is not the default provider.
        //
        UCHAR *pProvInfo =
             &m_abSecurityInfo[ALIGNUP4_ULONG(m_wSenderIDSize) +
                               ALIGNUP4_ULONG(m_wEncryptedKeySize) +
                               ALIGNUP4_ULONG(m_wSignatureSize) +
                               ALIGNUP4_ULONG(m_ulSenderCertSize)];

        //
        // Write the provider type.
        //
        *(ULONG *)pProvInfo = ulProvType;
        pProvInfo += sizeof(ULONG);

        //
        // Write the provider name. we use unsafe API because the packet size
        // was computed before, if we did it wrong -> AV
        //
        wcscpy((WCHAR*)pProvInfo, wszProvName);

        //
        // Compute the size of the provider information.
        //
        m_ulProvInfoSize = static_cast<ULONG>((wcslen(wszProvName) + 1) * sizeof(WCHAR) + sizeof(ULONG));
    }
}

/*=============================================================

 Routine Name:  CSecurityHeader::SetProvInfoEx

 Description:

===============================================================*/
inline
void
CSecurityHeader::SetProvInfoEx(
        ULONG    ulSize,
        BOOL     bDefProv,
        LPCWSTR  wszProvName,
        ULONG    ulProvType )
{
    SetProvInfo(bDefProv, wszProvName, ulProvType);

    if (ulSize != 0)
    {
        ASSERT(ulSize >= m_ulProvInfoSize);
        if (ulSize > m_ulProvInfoSize)
        {
            m_ulProvInfoSize = ulSize;
        }
    }
}

/*=============================================================

 Routine Name:  CSecurityHeader::GetProvInfo

 Description:

===============================================================*/
inline
void
CSecurityHeader::GetProvInfo(
    BOOL *pbDefProv,
    LPCWSTR *wszProvName,
    ULONG *pulProvType) const
{
    *pbDefProv = m_bfDefProv;
    if(!m_bfDefProv)
    {
        //
        // We fill the provider type and name only if this is not the default
        // provider.
        //
        ASSERT(m_ulProvInfoSize);
        const UCHAR *pProvInfo =
             &m_abSecurityInfo[ALIGNUP4_ULONG(m_wSenderIDSize) +
                               ALIGNUP4_ULONG(m_wEncryptedKeySize) +
                               ALIGNUP4_ULONG(m_wSignatureSize) +
                               ALIGNUP4_ULONG(m_ulSenderCertSize)];

        //
        // Fill the provider type.
        //
        *pulProvType = *(ULONG *)pProvInfo;
        pProvInfo += sizeof(ULONG);

        //
        // Fill the provider name.
        //
        *wszProvName = (WCHAR*)pProvInfo;
    }
}

/*=============================================================

 Routine Name: CSecurityHeader::GetSectionExPtr()

===============================================================*/

inline const UCHAR *
CSecurityHeader::GetSectionExPtr() const
{
    if (m_bfSecInfoEx == 0)
    {
        return NULL ;
    }

    const UCHAR *pProvInfo =
             &m_abSecurityInfo[ALIGNUP4_ULONG(m_wSenderIDSize)     +
                               ALIGNUP4_ULONG(m_wEncryptedKeySize) +
                               ALIGNUP4_ULONG(m_wSignatureSize)    +
                               ALIGNUP4_ULONG(m_ulSenderCertSize)];
    //
    // First see if authentication provider is present.
    //
    if ((m_wSignatureSize != 0) && !m_bfDefProv)
    {
        //
        // Skip provider of authentication.
        //
        pProvInfo += sizeof(ULONG) ;

        size_t MaxLength = (m_ulProvInfoSize - 4) / sizeof(WCHAR);
		size_t Length = mqwcsnlen((WCHAR*)pProvInfo, MaxLength);
		if (Length >= MaxLength)
		{
			ReportAndThrow("provider string is not NULL terminated");
		}

		pProvInfo += sizeof(WCHAR) * (1 + Length);
        pProvInfo = (UCHAR*) ALIGNUP4_PTR(pProvInfo) ;
    }

    return pProvInfo ;
}

/*=============================================================

 Routine Name: CSecurityHeader::SetSectionEx()

===============================================================*/

inline void
CSecurityHeader::SetSectionEx(const UCHAR *pSection, ULONG wSectionSize)
{
    m_bfSecInfoEx = 1 ;

    UCHAR *pProvInfo = const_cast<UCHAR*> (GetSectionExPtr()) ;

    if (pProvInfo)
    {
        memcpy( pProvInfo,
                pSection,
                wSectionSize ) ;
    }
    else
    {
        m_bfSecInfoEx = 0 ;
    }

    ASSERT(m_bfSecInfoEx == 1) ;
}

/*=============================================================

 Routine Name: pGetSubSectionEx()

===============================================================*/

inline
struct _SecuritySubSectionEx  *pGetSubSectionEx(
                            IN enum enumSecInfoType  eType,
                            IN const UCHAR          *pSectionEx,
                            IN const UCHAR          *pEnd)
{
	if ((pEnd != NULL) && (pSectionEx + sizeof(_SecuritySectionEx) >= pEnd))
	{
        ReportAndThrow("Security section is not valid: No roon for _SecuritySectionEx");
	}
    struct _SecuritySectionEx *pSecEx = (struct _SecuritySectionEx *) pSectionEx ;
    USHORT  cSubSections = pSecEx->cSubSectionCount ;

    struct _SecuritySubSectionEx *pSubSecEx = (struct _SecuritySubSectionEx *) &(pSecEx->aData[0]) ;

    for ( USHORT j = 0 ; j < cSubSections ; j++ )
    {
		if ((pEnd != NULL) && ((UCHAR*)pSubSecEx + sizeof(_SecuritySubSectionEx) > pEnd))
		{
	        ReportAndThrow("Security section is not valid: No roon for _SecuritySubSectionEx");
		}

		//
		// no need to use safe functions because wSubSectionLen is only USHORT
		//
		
        ULONG ulSubSecLen = ALIGNUP4_ULONG((ULONG)pSubSecEx->wSubSectionLen) ;

        if ((NULL == pEnd) && (eType == pSubSecEx->eType))
        {
            return  pSubSecEx ;
        }

        UCHAR *pTmp = (UCHAR*) pSubSecEx ;
        pTmp += ulSubSecLen ;
        pSubSecEx = (struct _SecuritySubSectionEx *) pTmp ;
    }

    return NULL ;
}

/*=============================================================

 Routine Name: CSecurityHeader::GetSubSectionEx()

===============================================================*/

inline
const struct _SecuritySubSectionEx *
CSecurityHeader::GetSubSectionEx( enum enumSecInfoType eType ) const
{
    const UCHAR *pProvInfo = const_cast<UCHAR*> (GetSectionExPtr()) ;
    if (!pProvInfo)
    {
        return NULL ;
    }

    struct _SecuritySubSectionEx  *pSecEx =
                                 pGetSubSectionEx(eType, pProvInfo, NULL) ;
    return pSecEx ;
}

#endif // __PHSECURE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\phmqfsign.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    phmqfsign.h

Abstract:

    Packet header for MQF Signature.

Author:

    Ilan Herbst  (ilanh)  05-Nov-2000

--*/

#ifndef __PHMQFSIGN_H
#define __PHMQFSIGN_H


/*+++

    MQF Signature header fields:
    
+----------------+-------------------------------------------------------+----------+
| FIELD NAME     | DESCRIPTION                                           | SIZE     |
+----------------+-------------------------------------------------------+----------+
| Header ID      | Identification of the header                          | 2 bytes  |
+----------------+-------------------------------------------------------+----------+
| Reserved       | Reserved for future extensions. Must be set to zero.  | 2 bytes  |
+----------------+-------------------------------------------------------+----------+
| Signature Size | Size of the signature in bytes.                       | 4 bytes  |
+----------------+-------------------------------------------------------+----------+
| Signature      | Buffer that holds the signature                .      | Variable |
+----------------+-------------------------------------------------------+----------+

---*/


#pragma pack(push, 1)
#pragma warning(disable: 4200)  //  zero-sized array in struct/union (enabeld later)


class CMqfSignatureHeader
{
public:

    //
    // Construct the CMqfSignatureHeader header
    //
    CMqfSignatureHeader(
        USHORT      id, 
        ULONG       cbSignatureSize, 
        UCHAR *     pSignature
        );

    //
    // Get size in bytes of the CMqfSignatureHeader header
    //
    static ULONG CalcSectionSize(ULONG cbSignatureSize);

    //
    // Get pointer to first byte after the CMqfSignatureHeader header
    //
    PCHAR  GetNextSection(void) const;

    //
    // Get the size of the signature in bytes from the CMqfSignatureHeader header
    //
    ULONG  GetSignatureSizeInBytes(void) const;

    //
    // Get pointer to the signature in CMqfSignatureHeader header
    //
    const UCHAR* GetPointerToSignature(ULONG* pSize) const;

	void SectionIsValid(PCHAR PacketEnd) const;

private:

    //
    // ID number of the CMqfSignatureHeader header
    //
    USHORT m_id;

    //
    // Reserved (for alignment)
    //
    USHORT m_ReservedSetToZero;

    //
    // Size in bytes of the signature
    //
    ULONG  m_cbSignatureSize;

    //
    // Buffer with the signature
    //
    UCHAR  m_buffer[0];

}; // CMqfSignatureHeader


#pragma warning(default: 4200)  //  zero-sized array in struct/union
#pragma pack(pop)



////////////////////////////////////////////////////////
//
//  Implementation
//

inline
CMqfSignatureHeader::CMqfSignatureHeader(
    USHORT      id,
    ULONG       cbSignatureSize, 
    UCHAR *     pSignature
    ) :
    m_id(id),
    m_ReservedSetToZero(0),
    m_cbSignatureSize(cbSignatureSize)
{
    if (cbSignatureSize != 0)
    {
        memcpy(&m_buffer[0], pSignature, cbSignatureSize);
    }
} // CMqfSignatureHeader::CMqfSignatureHeader

    
inline 
ULONG
CMqfSignatureHeader::CalcSectionSize(
    ULONG cbSignatureSize
    )
{
    size_t cbSize = sizeof(CMqfSignatureHeader) + cbSignatureSize;

    //
    // Align the entire header size to 4 bytes boundaries
    //
    cbSize = ALIGNUP4_ULONG(cbSize);
    return static_cast<ULONG>(cbSize);

} // CMqfSignatureHeader::CalcSectionSize


inline PCHAR CMqfSignatureHeader::GetNextSection(void) const
{
	ULONG_PTR ptrArray[] = {sizeof(CMqfSignatureHeader), m_cbSignatureSize};
	ULONG_PTR size = SafeAddPointers (2, ptrArray);

	size = SafeAlignUp4Ptr(size);
	ULONG_PTR ptrArray2[] = {(ULONG_PTR)this, size};
	size = SafeAddPointers(2, ptrArray2);

    return (PCHAR)size;

} // CMqfSignatureHeader::GetNextSection


inline ULONG CMqfSignatureHeader::GetSignatureSizeInBytes(void) const
{
    return m_cbSignatureSize;

} // CMqfSignatureHeader::GetSignatureSizeInBytes


inline const UCHAR* CMqfSignatureHeader::GetPointerToSignature(ULONG* pSize) const
{
	*pSize = m_cbSignatureSize;
    return &m_buffer[0];

} // CMqfSignatureHeader::GetPointerToSignature




#endif // __PHMQFSIGN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\phsrmpenv.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    phSrmpEnv.h

Abstract:

    Packet header for SRMP Envelope.

Author:

    Shai Kariv  (shaik)  11-Oct-2000

--*/

#ifndef __PHSRMP_ENV_H
#define __PHSRMP_ENV_H


/*+++

    Note: Packet may contain 0 or 2 SRMP headers (one for envelope, one for CompoundMessage).
          Packet may not contain only 1 SRMP header.

    SrmpEnvelope header fields:
    
+----------------+-------------------------------------------------------+----------+
| FIELD NAME     | DESCRIPTION                                           | SIZE     |
+----------------+-------------------------------------------------------+----------+
| Header ID      | Identification of the header                          | 2 bytes  |
+----------------+-------------------------------------------------------+----------+
| Reserved       | Reserved for future extensions. Must be set to zero.  | 2 bytes  |
+----------------+-------------------------------------------------------+----------+
| Data Length    | Length of the data in WCHARs.                         | 4 bytes  |
+----------------+-------------------------------------------------------+----------+
| Data           | The data WCHARs including NULL terminator.            | Variable |
+----------------+-------------------------------------------------------+----------+

---*/


#pragma pack(push, 1)
#pragma warning(disable: 4200)  //  zero-sized array in struct/union (enabeld later)


class CSrmpEnvelopeHeader
{
public:

    //
    // Construct the SRMP Envelope header
    //
    CSrmpEnvelopeHeader(WCHAR * pData, ULONG DataLengthInWCHARs, USHORT id);

    //
    // Get size in BYTEs of the SRMP Envelope header.
    //
    static ULONG CalcSectionSize(ULONG DataLengthInWCHARs);

    //
    // Get pointer to first byte after the SRMP Envelope header
    //
    PCHAR  GetNextSection(VOID) const;
      
    //
    // Copy the data from the SRMP Envelope header
    //
    VOID   GetData(WCHAR * pBuffer, ULONG BufferLengthInWCHARs) const;

    //
    // Get the length of the data in WCHARs from the SRMP Envelope header
    //
    ULONG  GetDataLengthInWCHARs(VOID) const;

private:

    //
    // ID number of the SRMP Envelope header
    //
    USHORT m_id;

    //
    // Reserved (for alignment)
    //
    USHORT m_ReservedSetToZero;

    //
    // Length in WCHARs of the data
    //
    ULONG  m_DataLength;

    //
    // Buffer with the data
    //
    UCHAR  m_buffer[0];

}; // CSrmpEnvelopeHeader


#pragma warning(default: 4200)  //  zero-sized array in struct/union
#pragma pack(pop)



////////////////////////////////////////////////////////
//
//  Implementation
//

inline
CSrmpEnvelopeHeader::CSrmpEnvelopeHeader(
    WCHAR * pData, 
    ULONG   DataLengthInWCHARs, 
    USHORT  id
    ) :
    m_id(id),
    m_ReservedSetToZero(0),
    m_DataLength(DataLengthInWCHARs + 1)
{
    if (DataLengthInWCHARs != 0)
    {
        memcpy(&m_buffer[0], pData, DataLengthInWCHARs * sizeof(WCHAR));
    }

	//
	// Putting unicode null terminator at end of buffer.
	//
	m_buffer[DataLengthInWCHARs * sizeof(WCHAR)]     = '\0';
	m_buffer[DataLengthInWCHARs * sizeof(WCHAR) + 1] = '\0';

} // CSrmpEnvelopeHeader::CSrmpEnvelopeHeader


inline 
ULONG
CSrmpEnvelopeHeader::CalcSectionSize(
    ULONG DataLengthInWCHARs
    )
{
    size_t cbSize = sizeof(CSrmpEnvelopeHeader) + ((DataLengthInWCHARs + 1) * sizeof(WCHAR));

    //
    // Align the entire header size to 4 bytes boundaries
    //
    cbSize = ALIGNUP4_ULONG(cbSize);
    return static_cast<ULONG>(cbSize);

} // CSrmpEnvelopeHeader::CalcSectionSize


inline PCHAR CSrmpEnvelopeHeader::GetNextSection(VOID) const
{
    size_t cbSize = sizeof(CSrmpEnvelopeHeader) + (m_DataLength * sizeof(WCHAR));
    cbSize = ALIGNUP4_ULONG(cbSize);

    return (PCHAR)this + cbSize;

} // CSrmpEnvelopeHeader::GetNextSection


inline VOID CSrmpEnvelopeHeader::GetData(WCHAR * pBuffer, ULONG BufferLengthInWCHARs) const
{
    ULONG length = min(BufferLengthInWCHARs, m_DataLength);

    if (length != 0)
    {
        memcpy(pBuffer, &m_buffer[0], length * sizeof(WCHAR));
        pBuffer[length - 1] = L'\0';
    }
} // CSrmpEnvelopeHeader::GetData


inline ULONG CSrmpEnvelopeHeader::GetDataLengthInWCHARs(VOID) const
{
    return m_DataLength;

} // CSrmpEnvelopeHeader::GetDataLengthInWCHARs



#endif // __PHSRMP_ENV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\phprop.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    phprop.h

Abstract:

    Handle Message properties section

Author:

    Uri Habusha (urih) 5-Feb-96


--*/

#ifndef __PHPROP_H
#define __PHPROP_H

#include "mqprops.h"

#define TitleLengthInBytes (m_bTitleLength*sizeof(WCHAR))
/*

    Following is a description of the Message Property packet fields:

+-----------------+------------------------------------------------------+----------+
| FIELD NAME      | DESCRIPTION                                          | SIZE     |
+-----------------+------------------------------------------------------+----------+
| Reserved        | Must Be Zero                                         | 2 byte   |
+-----------------+------------------------------------------------------+----------+
| Flags           | 0:2: Packet acknowledgment mode:                     | 1 byte   |
|                 |   0  :  No acknowledgment                            |          |
|                 |   1  :  Negative acknowledgment                      |          |
|                 |   2  :  Full acknowledgment                          |          |
+-----------------+------------------------------------------------------+----------+
| Message Class   | The message class, an Falcon acknowledgment          | 1 byte   |
|                 | field.                                               |          |
+-----------------+------------------------------------------------------+----------+
| Correlation ID  | The message correlation number.                      | 4 bytes  |
+-----------------+------------------------------------------------------+----------+
| Application Tag | Application specific data.                           | 4 bytes  |
+-----------------+------------------------------------------------------+----------+
| message size    | The message body size.                               | 4 bytes  |
+-----------------+------------------------------------------------------+----------+
| message title   |                                                      | 0:128    |
+-----------------+------------------------------------------------------+----------+
| message boey    |                                                      | variable |
+-----------------+------------------------------------------------------+----------+

 */

#pragma pack(push, 1)
#pragma warning(disable: 4200)  //  zero-sized array in struct/union (enabeld later)

struct CPropertyHeader {
public:

    inline CPropertyHeader();

    static ULONG CalcSectionSize(ULONG ulTitleLength,
                                 ULONG ulMsgExtensionSize,
                                 ULONG ulBodySize);
    inline PCHAR GetNextSection(void) const;


    inline void  SetClass(USHORT usClass);
    inline USHORT GetClass(void) const;

    inline void  SetAckType(UCHAR bAckType);
    inline UCHAR GetAckType(void) const;

    inline void SetCorrelationID(const UCHAR * pCorrelationID);
    inline void GetCorrelationID(PUCHAR) const;
    inline const UCHAR *GetCorrelationID(void) const;

    inline void  SetApplicationTag(ULONG dwApplicationTag);
    inline ULONG GetApplicationTag(void) const;

    inline void  SetBody(const UCHAR* pBody, ULONG ulSize, ULONG ulAllocSize);
    inline void  GetBody(PUCHAR pBody, ULONG ulSize) const;
    inline const UCHAR* GetBodyPtr() const;
    inline ULONG GetBodySize(void) const;
    inline void  SetBodySize(ULONG ulBodySize);
    inline ULONG GetAllocBodySize(void) const;

    inline void SetMsgExtension(const UCHAR* pMsgExtension,
                                ULONG ulSize);
    inline void GetMsgExtension(PUCHAR pMsgExtension,
                                ULONG ulSize) const;
    inline const UCHAR* GetMsgExtensionPtr(void) const;
    inline ULONG GetMsgExtensionSize(void) const;

    inline void  SetTitle(const WCHAR* pwTitle, ULONG ulTitleLength);
    inline void  GetTitle(PWCHAR pwTitle, ULONG ulBufferSizeInWCHARs) const;
    inline const WCHAR* GetTitlePtr(void) const;
    inline ULONG GetTitleLength(void) const;

    inline void SetPrivLevel(ULONG);
    inline ULONG GetPrivLevel(void) const;
    inline ULONG GetPrivBaseLevel(void) const;

    inline void SetHashAlg(ULONG);
    inline ULONG GetHashAlg(void) const;

    inline void SetEncryptAlg(ULONG);
    inline ULONG GetEncryptAlg(void) const;

    inline void SetBodyType(ULONG);
    inline ULONG GetBodyType(void) const;

	void SectionIsValid(PCHAR PacketEnd) const;

private:
//
// BEGIN Network Monitor tag
//
    UCHAR m_bFlags;
    UCHAR m_bTitleLength;
    USHORT m_usClass;
    UCHAR m_acCorrelationID[PROPID_M_CORRELATIONID_SIZE];
    ULONG m_ulBodyType;
    ULONG m_ulApplicationTag;
    ULONG m_ulBodySize;
    ULONG m_ulAllocBodySize;
    ULONG m_ulPrivLevel;
    ULONG m_ulHashAlg;
    ULONG m_ulEncryptAlg;
    ULONG m_ulExtensionSize;
    UCHAR m_awTitle[0];
//
// END Network Monitor tag
//
};

#pragma warning(default: 4200)  //  zero-sized array in struct/union
#pragma pack(pop)

/*======================================================================

 Function:    CPropertyHeader::

 Description:

 =======================================================================*/
inline CPropertyHeader::CPropertyHeader() :
    m_bFlags(DEFAULT_M_ACKNOWLEDGE),
    m_bTitleLength(0),
    m_usClass(MQMSG_CLASS_NORMAL),
    m_ulBodyType(0),
    m_ulApplicationTag(0),
    m_ulBodySize(0),
    m_ulAllocBodySize(0),
    m_ulPrivLevel(MQMSG_PRIV_LEVEL_NONE),
    m_ulHashAlg(0),
    m_ulEncryptAlg(0),
    m_ulExtensionSize(0)
{
    memset(m_acCorrelationID, 0, PROPID_M_CORRELATIONID_SIZE);
    //
    // BUGBUG: CPropertyHeader::CPropertyHeader implementation
    //
}

/*======================================================================

 Function:    CPropertyHeader::

 Description:

 =======================================================================*/
inline ULONG CPropertyHeader::CalcSectionSize(ULONG ulTitleLength,
                                              ULONG ulMsgExtensionSize,
                                              ULONG ulBodySize)
{
    return ALIGNUP4_ULONG(
            sizeof(CPropertyHeader) +
            ulTitleLength * sizeof(WCHAR) +
            ulMsgExtensionSize +
            ulBodySize
            );
}

/*======================================================================

 Function:    CPropertyHeader::

 Description:

 =======================================================================*/
inline PCHAR CPropertyHeader::GetNextSection(void) const
{
	ULONG_PTR ptrArray[] = {sizeof(*this),
							TitleLengthInBytes,
							m_ulExtensionSize,
		                	m_ulAllocBodySize
		                	};

	ULONG_PTR size = SafeAddPointers(4, ptrArray);
	size = SafeAlignUp4Ptr(size);
	ULONG_PTR ptrArray2[] = {size, (ULONG_PTR)this};
	size = SafeAddPointers(2, ptrArray2);
	return (PCHAR)size;
}

/*======================================================================

 Function:    CPropertyHeader::SetClass

 Description: Set/Clear Message Class

 =======================================================================*/
inline void CPropertyHeader::SetClass(USHORT usClass)
{
    m_usClass = usClass;
}
/*======================================================================

 Function:     CPropertyHeader::GetClass

 Description:  Returns message class

 =======================================================================*/
inline USHORT CPropertyHeader::GetClass(void) const
{
    return m_usClass;
}

/*===========================================================

  Routine Name:  CPropertyHeader::SetAckType

  Description:   Set The Ack Type

=============================================================*/
inline void CPropertyHeader::SetAckType(UCHAR bAckType)
{
    //
    //  BUGBUG: ack type
    //

    m_bFlags = bAckType;
}

/*===========================================================

  Routine Name:  CPropertyHeader::GetAckType

  Description:   Returns The Ack Type

=============================================================*/
inline UCHAR CPropertyHeader::GetAckType(void) const
{
    //
    //  BUGBUG: ack type
    //

    return m_bFlags;
}

/*======================================================================

 Function:    CPropertyHeader::SetCorrelation

 Description: Set Message correlation

 =======================================================================*/
inline void CPropertyHeader::SetCorrelationID(const UCHAR * pCorrelationID)
{
    memcpy(m_acCorrelationID, pCorrelationID, PROPID_M_CORRELATIONID_SIZE);
}

/*======================================================================

 Function:    CPropertyHeader::GetCorrelation

 Description: Returns Message correlation

 =======================================================================*/
inline void CPropertyHeader::GetCorrelationID(PUCHAR pCorrelationID) const
{
    ASSERT (pCorrelationID != NULL);
    memcpy(pCorrelationID, m_acCorrelationID, PROPID_M_CORRELATIONID_SIZE);
}

/*======================================================================

 Function:    CPropertyHeader::GetCorrelation

 Description: Returns Message correlation

 =======================================================================*/
inline const UCHAR *CPropertyHeader::GetCorrelationID(void) const
{
    return m_acCorrelationID;
}

/*======================================================================

 Function:    CPropertyHeader::SetApplicationTag

 Description: Set Applecation specific data

 =======================================================================*/
inline void CPropertyHeader::SetApplicationTag(ULONG ulApplicationTag)
{
    m_ulApplicationTag = ulApplicationTag;
}

/*======================================================================

 Function:    CPropertyHeader::GetApplicationTag

 Description: Returns Applecation specific data

 =======================================================================*/
inline ULONG CPropertyHeader::GetApplicationTag(void) const
{
    return m_ulApplicationTag;
}

/*======================================================================

 Function:    CPropertyHeader::SetBody

 Description: Get Message body size

 =======================================================================*/
inline void CPropertyHeader::SetBody(const UCHAR * pBody, ULONG ulSize, ULONG ulAllocSize)
{
    m_ulAllocBodySize = ulAllocSize;
    m_ulBodySize = ulSize;
    memcpy(&m_awTitle[TitleLengthInBytes + m_ulExtensionSize], pBody, ulSize);
}

/*======================================================================

 Function:    CPropertyHeader::GetBody

 Description: Get Message body size

 =======================================================================*/
inline void CPropertyHeader::GetBody(PUCHAR pBody, ULONG ulSize) const
{
    memcpy( pBody,
            &m_awTitle[TitleLengthInBytes + m_ulExtensionSize],
            ((ulSize < m_ulBodySize) ?  ulSize : m_ulBodySize)
            );
}

/*======================================================================

 Function:    CPropertyHeader::GetBodyPtr

 Description: Get Message body size

 =======================================================================*/
inline const UCHAR* CPropertyHeader::GetBodyPtr() const
{
    return (PUCHAR)&m_awTitle[TitleLengthInBytes + m_ulExtensionSize];
}
/*======================================================================

 Function:    CPropertyHeader::GetBodySize

 Description: Get Message body size

 =======================================================================*/
inline ULONG CPropertyHeader::GetBodySize(void) const
{
    return m_ulBodySize;
}

/*======================================================================

 Function:    CPropertyHeader::SetBodySize

 Description: Set Message body size

 =======================================================================*/
inline void CPropertyHeader::SetBodySize(ULONG ulBodySize)
{
    ASSERT(ulBodySize <= m_ulAllocBodySize);
    m_ulBodySize = ulBodySize;
}

/*======================================================================

 Function:    CPropertyHeader::GetAllocBodySize

 Description: Get the allocated message body size

 =======================================================================*/
inline ULONG CPropertyHeader::GetAllocBodySize(void) const
{
    return m_ulAllocBodySize;
}

/*======================================================================

 Function:    CPropertyHeader::SetMsgExtension

 Description: Set Message Extension

 =======================================================================*/
inline void
CPropertyHeader::SetMsgExtension(const UCHAR* pMsgExtension,
                                 ULONG ulSize)
{
    m_ulExtensionSize = ulSize;
    memcpy(&m_awTitle[TitleLengthInBytes], pMsgExtension, ulSize);
}

/*======================================================================

 Function:    CPropertyHeader::GetMsgExtension

 Description: Get Message Extension

 =======================================================================*/
inline void
CPropertyHeader::GetMsgExtension(PUCHAR pMsgExtension,
                                 ULONG ulSize) const
{
    memcpy( pMsgExtension,
            &m_awTitle[TitleLengthInBytes],
            ((ulSize < m_ulExtensionSize) ?  ulSize : m_ulExtensionSize)
            );
}

/*======================================================================

 Function:    CPropertyHeader::GetMsgExtensionPtr

 Description: Get pointer to Message Extension

 =======================================================================*/
inline const UCHAR*
CPropertyHeader::GetMsgExtensionPtr(void) const
{
    return &m_awTitle[TitleLengthInBytes];
}

/*======================================================================

 Function:    CPropertyHeader::GetMsgExtensionSize

 Description: Get Message Extension size

 =======================================================================*/
inline ULONG CPropertyHeader::GetMsgExtensionSize(void) const
{
    return m_ulExtensionSize;
}

/*======================================================================

 Function:    CPropertyHeader::SetTitle

 Description: Set Message title

 =======================================================================*/
#ifndef MAXBYTE
// MAXBYTE is not in ntdef.h (DDK), MAXUCHAR is not define for winnt.h (WINDOWS)
#define MAXBYTE 0xff
#endif
inline void CPropertyHeader::SetTitle(const WCHAR* pwTitle, ULONG ulTitleLength)
{
    if(ulTitleLength > MAXBYTE)
    {
        ulTitleLength = MAXBYTE;
    }

    m_bTitleLength = (UCHAR)ulTitleLength;
    memcpy(m_awTitle, pwTitle, ulTitleLength * sizeof(WCHAR));
}

/*======================================================================

 Function:    CPropertyHeader::GetTitle

 Description: Get Message title

 =======================================================================*/
inline void CPropertyHeader::GetTitle(PWCHAR pwTitle, ULONG ulBufferSizeInWCHARs) const
{
    if(ulBufferSizeInWCHARs > m_bTitleLength)
    {
        ulBufferSizeInWCHARs = m_bTitleLength;
    }

    if(ulBufferSizeInWCHARs == 0)
    {
        return;
    }

    --ulBufferSizeInWCHARs;

    memcpy(pwTitle, m_awTitle, ulBufferSizeInWCHARs * sizeof(WCHAR));
    pwTitle[ulBufferSizeInWCHARs] = L'\0';
}

/*======================================================================

 Function:    CPropertyHeader::GetTitlePtr

 Description: Get Message title

 =======================================================================*/
inline const WCHAR* CPropertyHeader::GetTitlePtr(void) const
{
    return ((WCHAR*)m_awTitle);
}

/*======================================================================

 Function:    CPropertyHeader::GetTitleSize

 Description: Get the size of Message title

 =======================================================================*/
inline ULONG CPropertyHeader::GetTitleLength(void) const
{
    return(m_bTitleLength);
}

/*======================================================================

 Function:    CPropertyHeader::SetPrivLevel

 Description: Set the privacy level of the message in the message packet.

 =======================================================================*/
inline void CPropertyHeader::SetPrivLevel(ULONG ulPrivLevel)
{
    m_ulPrivLevel = ulPrivLevel;
}

/*======================================================================

 Function:    CPropertyHeader::GetPrivLevel

 Description: Get the privacy level of the message in the message packet.

 =======================================================================*/
inline ULONG CPropertyHeader::GetPrivLevel(void) const
{
    return(m_ulPrivLevel);
}

/*======================================================================

 Function:    CPropertyHeader::GetPrivBaseLevel

 Description: Get the privacy level of the message in the message packet.

 =======================================================================*/
inline ULONG CPropertyHeader::GetPrivBaseLevel(void) const
{
    return(m_ulPrivLevel & MQMSG_PRIV_LEVEL_BODY_BASE) ;
}

/*======================================================================

 Function:    CPropertyHeader::SetHashAlg

 Description: Set the hash algorithm of the message in the message packet.

 =======================================================================*/
inline void CPropertyHeader::SetHashAlg(ULONG ulHashAlg)
{
    m_ulHashAlg = ulHashAlg;
}

/*======================================================================

 Function:    CPropertyHeader::GetHashAlg

 Description: Get the hash algorithm of the message in the message packet.

 =======================================================================*/
inline ULONG CPropertyHeader::GetHashAlg(void) const
{
    return(m_ulHashAlg);
}

/*======================================================================

 Function:    CPropertyHeader::SetEncryptAlg

 Description: Set the encryption algorithm of the message in the message packet.

 =======================================================================*/
inline void CPropertyHeader::SetEncryptAlg(ULONG ulEncryptAlg)
{
    m_ulEncryptAlg = ulEncryptAlg;
}

/*======================================================================

 Function:    CPropertyHeader::GetEncryptAlg

 Description: Get the encryption algorithm of the message in the message packet.

 =======================================================================*/
inline ULONG CPropertyHeader::GetEncryptAlg(void) const
{
    return(m_ulEncryptAlg);
}

/*======================================================================

 Function:    CPropertyHeader::SetBodyType

 =======================================================================*/
inline void CPropertyHeader::SetBodyType(ULONG ulBodyType)
{
    m_ulBodyType = ulBodyType;
}

/*======================================================================

 Function:    CPropertyHeader::GetBodyType

 =======================================================================*/
inline ULONG CPropertyHeader::GetBodyType(void) const
{
    return  m_ulBodyType;
}

#endif // __PHPROP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\phuser.h ===
/*++
                
Copyright (c) 1995  Microsoft Corporation

Module Name:

    userhead.h

Abstract:

    Handle of PACKET class definition

Author:

    Uri Habusha (urih) 1-Feb-96

--*/

#ifndef __PHUSER_H
#define __PHUSER_H

/*+++

    User header fields. (following base header)

+----------------+-------------------------------------------------------+----------+
| FIELD NAME     | DESCRIPTION                                           | SIZE     |
+----------------+-------------------------------------------------------+----------+
| Source QM      | Identifier of the packet originating QM. (GUID)       | 16 bytes |
+----------------+-------------------------------------------------------+----------+
| Destination QM | Identifier of the destination QM. (GUID)              | 16 bytes |
+----------------+-------------------------------------------------------+----------+
|QM Time-to-Live | The packet time to live until dequeued by             |          |
|   Delta        | application (in seconds, relative to TTQ)             | 4 bytes  |
+----------------+-------------------------------------------------------+----------+
| Sent Time      | Abs time (in seconds) when packet was sent by user.   | 4 bytes  |
+----------------+-------------------------------------------------------+----------+
| Message ID     | The message number. unique per source QM.             | 4 bytes  |
+----------------+-------------------------------------------------------+----------+
| Flags          | A bit map of some of the packet parameters:           | 4 bytes  |
|                |                                                       |          |
|                |                                                       |          |
|                |                                                       |          |
|                |  3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1                      |          |
|                |  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6                      |          |
|                | +-----+-+-+-+-+-+-+-+-+-+-+-----+                     |          |
|                | |0 0 0|S|E|E|S|M|M|C|P|X|S|Resp |                     |          |
|                | +-----+-+-+-+-+-+-+-+-+-+-+-----+                     |          |
|                |                                                       |          |
|                |  1 1 1 1 1 1                                          |          |
|                |  5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0                      |          |
|                | +-----+-----+---+-+---+---------+                     |          |
|                | |Admin|Dest |Aud|R|Dlv|  Hop    |                     |          |
|                | +-----+-----+---+-+---+---------+                     |          |
|                |                                                       |          |
|                | Bits                                                  |          |
|                | 0:4      Hop count. Valid values 0 to 15.             |          |
|                |                                                       |          |
|                | 5:6      Delivery mode:                               |          |
|                |              0 - Guaranteed                           |          |
|                |              1 - Recoverable                          |          |
|                |              2 - On-Line                              |          |
|                |              3 - Reserved.                            |          |
|                |                                                       |          |
|                | 7        Routing mode                                 |          |
|                |              0 - Reserved                             |          |
|                |                                                       |          |
|                | 8        Audit dead letter file                       |          |
|                | 9        Audit journal file                           |          |
|                |                                                       |          |
|                | 10:12    Destination queue type                       |          |
|                |              0 - Illigal value                        |          |
|                |              1 - Illigal value                        |          |
|                |              2 - Illigal value                        |          |
|                |              3 - Illigal value                        |          |
|                |              4 - Private at Dest..QM       ( 4 bytes) |          |
|                |              5 - Illigal value                        |          |
|                |              6 - GUID                      (16 bytes) |          |
|                |              7 - Illigal value                        |          |
|                |                                                       |          |
|                | 13:15    Admin Queue type                             |          |
|                |              0 - None                      ( 0 bytes) |          |
|                |              1 - Same as Dest..Q           ( 0 bytes) |          |
|                |              2 - Illigal value                        |          |
|                |              3 - Private at Src...QM       ( 4 bytes) |          |
|                |              4 - Private at Dest..QM       ( 4 bytes) |          |
|                |              5 - Illigal value                        |          |
|                |              6 - GUID                      (16 bytes) |          |
|                |              7 - Private Queue             (20 bytes) |          |
|                |                                                       |          |
|                | 16:18    Response queue type                          |          |
|                |              0 - None                      ( 0 bytes) |          |
|                |              1 - Same as Dest..Q           ( 0 bytes) |          |
|                |              2 - Same as Admin.Q           ( 0 bytes) |          |
|                |              3 - Private at Src...QM       ( 4 bytes) |          |
|                |              4 - Private at Dest..QM       ( 4 bytes) |          |
|                |              5 - Private at Admin.QM       ( 4 bytes) |          |
|                |              6 - GUID                      (16 bytes) |          |
|                |              7 - Private Queue             (20 bytes) |          |
|                |                                                       |          |
|                | 19       Security section included                    |          |
|                |              0 - not included                         |          |
|                |              1 - included                             |          |
|                |                                                       |          |
|                | 20       Xact section included                        |          |
|                |              0 - not included                         |          |
|                |              1 - included                             |          |
|                |                                                       |          |
|                | 21       Properties section included                  |          |
|                |              0 - not included                         |          |
|                |              1 - included                             |          |
|                |                                                       |          |
|                | 22       Connector Type included                      |          |
|                |              0 - not included                         |          |
|                |              1 - included                             |          |
|                |                                                       |          |
|                | 23       MQF sections included                        |          |
|                |              0 - None of the MQF sections included    |          |
|                |              1 - All of the MQF sections included     |          |
|                |                                                       |          |
|                | 24       Multicast destination                        |          |
|                |              0 - Destination is not multicast         |          |
|                |              1 - Destination is multicast address     |          |
|                |                                                       |          |
|                | 25       SRMP sections included                       |          |
|                |              0 - None of the SRMP sections included   |          |
|                |              1 - All of the SRMP sections included    |          |
|                |                                                       |          |
|                | 26       EOD section included                         |          |
|                |              0 - not included                         |          |
|                |              1 - included                             |          |
|                |                                                       |          |
|                | 27       EOD-ACK section included                     |          |
|                |              0 - not included                         |          |
|                |              1 - included                             |          |
|                |                                                       |          |
|                | 28       SOAP sections included                       |          |
|                |              0 - not included                         |          |
|                |              1 - included                             |          |
|                |                                                       |          |
|                | 29:31    Reserved. MUST be set to zero.               |          |
+----------------+-------------------------------------------------------+----------+
| Destination Q  | Destination Queue Description                         |4-16 bytes|
+----------------+-------------------------------------------------------+----------+
| Admin Queue    | Admin Queue Description                               |0-20 bytes|
+----------------+-------------------------------------------------------+----------+
| Response Queue | Response Queue Description                            |0-20 bytes|
+----------------+-------------------------------------------------------+----------+

---*/


#pragma pack(push, 1)
#pragma warning(disable: 4200)  //  zero-sized array in struct/union (enabeld later)

//
// struct CUserHeader
//

struct CUserHeader {
private:

    //
    // Queue type: 3 bits (values 0-7 only)
    //
    enum QType {
        qtNone      = 0,    //  0 - None                    ( 0 bytes)
        qtAdminQ    = 1,    //  1 - Same as Admin.Q         ( 0 bytes)
        qtSourceQM  = 2,    //  2 - Private at Src...QM     ( 4 bytes)
        qtDestQM    = 3,    //  3 - Private at Dest..QM     ( 4 bytes)
        qtAdminQM   = 4,    //  4 - Private at Admin.QM     ( 4 bytes)
        qtGUID      = 5,    //  5 - Public  Queue           (16 bytes)
        qtPrivate   = 6,    //  6 - Private Queue           (20 bytes)
        qtDirect    = 7     //  7 - Direct  Queue           (var size)
     };

public:

    inline CUserHeader(
            const GUID* pSourceQM,
            const GUID* pDestinationQM,
            const QUEUE_FORMAT* pDestinationQueue,
            const QUEUE_FORMAT* pAdminQueue,
            const QUEUE_FORMAT* pResponseQueue,
            ULONG ulMessageID
           );

    static ULONG CalcSectionSize(
            const GUID* pSourceQM,
            const GUID* pDestinationQM,
            const GUID* pgConnectorType,
            const QUEUE_FORMAT* pDestinationQueue,
            const QUEUE_FORMAT* pAdminQueue,
            const QUEUE_FORMAT* pResponseQueue
            );

    inline PCHAR GetNextSection(PUCHAR PacketEnd = 0) const;

    inline void  SetSourceQM(const GUID* pGUID);
    inline const GUID* GetSourceQM(void) const;

    inline void  SetAddressSourceQM(const TA_ADDRESS *pa);
    inline const TA_ADDRESS *GetAddressSourceQM(void) const;

    inline void  SetDestQM(const GUID* pGUID);
    inline const GUID* GetDestQM(void) const;

    inline BOOL GetDestinationQueue(QUEUE_FORMAT*) const;
    inline BOOL GetAdminQueue(QUEUE_FORMAT*) const;
    inline BOOL GetResponseQueue(QUEUE_FORMAT*) const;

    inline void  SetTimeToLiveDelta(ULONG ulTimeout);
    inline ULONG GetTimeToLiveDelta(void) const;

    inline void  SetSentTime(ULONG ulSentTime);
    inline ULONG GetSentTime(void) const;

    inline void  SetMessageID(const OBJECTID* MessageID);
    inline void  GetMessageID(OBJECTID * pMessageId) const;

    inline void  IncHopCount(void);
    inline UCHAR GetHopCount(void) const;

    inline void  SetDelivery(UCHAR bDelivery);
    inline UCHAR GetDelivery(void) const;

    inline void  SetAuditing(UCHAR bAuditing);
    inline UCHAR GetAuditing(void) const;

    inline void IncludeSecurity(BOOL);
    inline BOOL SecurityIsIncluded(void) const;

    inline void IncludeXact(BOOL);
    inline BOOL IsOrdered(void) const;

    inline void IncludeProperty(BOOL);
    inline BOOL PropertyIsIncluded(void) const;

    inline VOID IncludeMqf(bool);
    inline bool MqfIsIncluded(VOID) const;

    inline VOID IncludeSrmp(bool);
    inline bool SrmpIsIncluded(VOID) const;

    inline VOID IncludeEod(bool);
    inline bool EodIsIncluded(VOID) const;

    inline VOID IncludeEodAck(bool);
    inline bool EodAckIsIncluded(VOID) const;

    inline VOID IncludeSoap(bool);
    inline bool SoapIsIncluded(VOID) const;

    inline void SetConnectorType(const GUID*);
    inline BOOL ConnectorTypeIsIncluded(void) const;
    inline const GUID* GetConnectorType(void) const;

	void SectionIsValid(PCHAR PacketEnd) const;

private:

    static int QueueSize(bool, ULONG, const UCHAR*, PUCHAR PacketEnd = NULL);
    inline BOOL GetQueue(const UCHAR*, bool, ULONG, QUEUE_FORMAT*) const;
    inline PUCHAR SetDirectQueue(PUCHAR, const WCHAR*);

private:

//
// BEGIN Network Monitor tag
//
    GUID    m_gSourceQM;
    union {
        GUID        m_gDestQM;
        TA_ADDRESS  m_taSourceQM;
    };
    ULONG   m_ulTimeToLiveDelta;
    ULONG   m_ulSentTime;
    ULONG   m_ulMessageID;
    union {
        ULONG   m_ulFlags;
        struct {
            ULONG m_bfHopCount  : 5;
            ULONG m_bfDelivery  : 2;
            ULONG m_bfRouting   : 1;
            ULONG m_bfAuditing  : 2;
            ULONG m_bfDQT       : 3;
            ULONG m_bfAQT       : 3;
            ULONG m_bfRQT       : 3;
            ULONG m_bfSecurity  : 1;
            ULONG m_bfXact      : 1;
            ULONG m_bfProperties: 1;
            ULONG m_bfConnectorType : 1;
            ULONG m_bfMqf       : 1;
            ULONG m_bfPgm       : 1;
            ULONG m_bfSrmp      : 1;
            ULONG m_bfEod       : 1;
            ULONG m_bfEodAck    : 1;
            ULONG m_bfSoap      : 1;
        };
    };

    UCHAR m_abQueues[0];
//
// END Network Monitor tag
//
};

#pragma warning(default: 4200)  //  zero-sized array in struct/union
#pragma pack(pop)


/*======================================================================

 Function:

 Description:

 =======================================================================*/
inline
CUserHeader::CUserHeader(
    const GUID* pSourceQM,
    const GUID* pDestinationQM,
    const QUEUE_FORMAT* pDestinationQueue,
    const QUEUE_FORMAT* pAdminQueue,
    const QUEUE_FORMAT* pResponseQueue,
    ULONG ulMessageID
    ) :
    m_gSourceQM(*pSourceQM),
    m_gDestQM(*pDestinationQM),
    m_ulTimeToLiveDelta(INFINITE),
    m_ulSentTime(0),
    m_ulMessageID(ulMessageID),
    m_ulFlags(0)
{
    ASSERT(pSourceQM);
    ASSERT(pDestinationQM);
    ASSERT(pDestinationQueue);

    //
    //  Set default flags
    //
    m_bfDelivery = DEFAULT_M_DELIVERY;
    m_bfRouting  = 0;                   //reserved
    m_bfAuditing = DEFAULT_M_JOURNAL;
    m_bfProperties = TRUE;

    //
    //  Set Queue Information.
    //  Queues that are the same should *point* to same QUEUE_FORMAT
    //
    PUCHAR pQueue = m_abQueues;
    ASSERT(ISALIGN4_PTR(pQueue));


    //
    //  Destination Queue
    //
    switch (pDestinationQueue->GetType())
    {
        case QUEUE_FORMAT_TYPE_PUBLIC:
            //
            //  Destination Queue is PUBLIC
            //
            m_bfDQT = qtGUID;
            *(GUID*)pQueue = pDestinationQueue->PublicID();
            pQueue += sizeof(GUID);
            break;

        case QUEUE_FORMAT_TYPE_PRIVATE:
            //
            //  Destination Queue is PRIVATE
            //
            ASSERT(("Mismatch between destination QM ID and the private queue ID", ((pDestinationQueue->PrivateID()).Lineage == *pDestinationQM)));

            m_bfDQT = qtDestQM;
            *(PULONG)pQueue = pDestinationQueue->PrivateID().Uniquifier;
            pQueue += sizeof(ULONG);
            break;

        case QUEUE_FORMAT_TYPE_DIRECT:
            //
            // Destination queue is direct
            //
            m_bfDQT = qtDirect;
            pQueue = SetDirectQueue(pQueue, pDestinationQueue->DirectID());
            break;

        case QUEUE_FORMAT_TYPE_MULTICAST:
        {
            //
            // Destination queue is multicast
            //
            m_bfDQT = qtNone;
            m_bfPgm = 1;
            const MULTICAST_ID& id = pDestinationQueue->MulticastID();
            *(PULONG)pQueue = id.m_address;
            pQueue += sizeof(ULONG);
            *(PULONG)pQueue = id.m_port;
            pQueue += sizeof(ULONG);
            break;
        }

        default:
            //
            //  Unexpected type, assert with no Warning level 4.
            //
            ASSERT(pDestinationQueue->GetType() == QUEUE_FORMAT_TYPE_DIRECT);
    }

    ASSERT(ISALIGN4_PTR(pQueue));

    //
    //  Admin Queue
    //

    if(pAdminQueue != 0)
    {
        switch (pAdminQueue->GetType())
        {
            case  QUEUE_FORMAT_TYPE_PUBLIC:
                //
                //  Admin Queue is PUBLIC
                //
                m_bfAQT = qtGUID;
                *(GUID*)pQueue = pAdminQueue->PublicID();
                pQueue += sizeof(GUID);
                break;

            case QUEUE_FORMAT_TYPE_PRIVATE:
                if(pAdminQueue->PrivateID().Lineage == *pSourceQM)
                {
                    //
                    //  Private Queue in source QM
                    //
                    m_bfAQT = qtSourceQM;
                    *(PULONG)pQueue = pAdminQueue->PrivateID().Uniquifier;
                    pQueue += sizeof(ULONG);
                }
                else if(
                    (pDestinationQueue->GetType() != QUEUE_FORMAT_TYPE_DIRECT) &&
                    (pAdminQueue->PrivateID().Lineage == *pDestinationQM))
                {
                    //
                    //  Private Queue in Destination QM
                    //
                    m_bfAQT = qtDestQM;
                    *(PULONG)pQueue = pAdminQueue->PrivateID().Uniquifier;
                    pQueue += sizeof(ULONG);
                }
                else
                {
                    //
                    //  Private Queue in some other Machine
                    //
                    m_bfAQT = qtPrivate;
                    *(OBJECTID*)pQueue = pAdminQueue->PrivateID();
                    pQueue += sizeof(OBJECTID);
                }
                break;

            case QUEUE_FORMAT_TYPE_DIRECT:
                //
                // Destination queue is direct
                //
                m_bfAQT = qtDirect;
                pQueue = SetDirectQueue(pQueue, pAdminQueue->DirectID());
                break;

            case QUEUE_FORMAT_TYPE_MULTICAST:
            case QUEUE_FORMAT_TYPE_DL:
            default:
                //
                //  Unexpected type, assert with no Warning level 4.
                //
                ASSERT(pAdminQueue->GetType() == QUEUE_FORMAT_TYPE_DIRECT);
        }
    }

    ASSERT(ISALIGN4_PTR(pQueue));

    //
    //  Response Queue
    //

    if(pResponseQueue != 0)
    {
        if(pResponseQueue == pAdminQueue)
        {
            //
            //  Same as admin queue (private or guid)
            //
            m_bfRQT = qtAdminQ;
        }
        else
        {
            switch(pResponseQueue->GetType())
            {
                case QUEUE_FORMAT_TYPE_PUBLIC:
                    //
                    //  GUID Queue that is not the same as admin queue.
                    //
                    m_bfRQT = qtGUID;
                    *(GUID*)pQueue = pResponseQueue->PublicID();
                    pQueue += sizeof(GUID);
                    break;

                case QUEUE_FORMAT_TYPE_PRIVATE:
                    if(pResponseQueue->PrivateID().Lineage == *pSourceQM)
                    {
                        //
                        //  Private Queue in source QM
                        //
                        m_bfRQT = qtSourceQM;
                        *(PULONG)pQueue = pResponseQueue->PrivateID().Uniquifier;
                        pQueue += sizeof(ULONG);
                    }
                    else if(
                        (pDestinationQueue->GetType() != QUEUE_FORMAT_TYPE_DIRECT) &&
                        (pResponseQueue->PrivateID().Lineage == *pDestinationQM))
                    {
                        //
                        //  Private Queue in Destination QM
                        //
                        m_bfRQT = qtDestQM;
                        *(PULONG)pQueue = pResponseQueue->PrivateID().Uniquifier;
                        pQueue += sizeof(ULONG);
                    }
                    else if((pAdminQueue !=0) &&
                            (pAdminQueue->GetType() == QUEUE_FORMAT_TYPE_PRIVATE) &&
                            (pResponseQueue->PrivateID().Lineage == pAdminQueue->PrivateID().Lineage))
                    {
                        //
                        //  Private Queue in Admin machine QM
                        //
                        m_bfRQT = qtAdminQM;
                        *(PULONG)pQueue = pResponseQueue->PrivateID().Uniquifier;
                        pQueue += sizeof(ULONG);
                    }
                    else
                    {
                        //
                        //  Private Queue in some other Machine
                        //
                        m_bfRQT = qtPrivate;
                        *(OBJECTID*)pQueue = pResponseQueue->PrivateID();
                        pQueue += sizeof(OBJECTID);
                    }
                    break;

                case QUEUE_FORMAT_TYPE_DIRECT:
                    {
                        //
                        // Destination queue is direct
                        //
                        m_bfRQT = qtDirect;
                        pQueue = SetDirectQueue(pQueue, pResponseQueue->DirectID());
                        break;
                    }

                case QUEUE_FORMAT_TYPE_MULTICAST:
                case QUEUE_FORMAT_TYPE_DL:
                default:
                    //
                    //  Unexpected type, assert with no Warning level 4.
                    //
                    ASSERT(pResponseQueue->GetType() == QUEUE_FORMAT_TYPE_DIRECT);
            }
        }
    }
    
    ASSERT(ISALIGN4_PTR(pQueue));
}

/*======================================================================

 Function:

 Description:

 =======================================================================*/
inline
ULONG
CUserHeader::CalcSectionSize(
    const GUID* pSourceQM,
    const GUID* pDestinationQM,
    const GUID* pgConnectorType,
    const QUEUE_FORMAT* pDestinationQueue,
    const QUEUE_FORMAT* pAdminQueue,
    const QUEUE_FORMAT* pResponseQueue
    )
{

    ULONG ulSize = sizeof(CUserHeader);

    //
    //  Destination Queue
    //
    switch(pDestinationQueue->GetType())
    {
        case QUEUE_FORMAT_TYPE_PUBLIC:
            ulSize += sizeof(GUID);
            break;

        case QUEUE_FORMAT_TYPE_PRIVATE:
            //
            //  Destination Queue is private
            //
            ulSize += sizeof(ULONG);
            break;

        case QUEUE_FORMAT_TYPE_DIRECT:
            //
            // Destination Queue is Direct
            //
            ulSize += ALIGNUP4_ULONG(sizeof(USHORT) +
                       (wcslen(pDestinationQueue->DirectID()) + 1) * sizeof(WCHAR));
            break;

        case QUEUE_FORMAT_TYPE_MULTICAST:
            //
            // Destination Queue is Multicast
            //
            ulSize += ALIGNUP4_ULONG(sizeof(ULONG) + sizeof(ULONG));
            break;

        case QUEUE_FORMAT_TYPE_DL:
            ASSERT(("DL type is not allowed", 0));
            break;
    }

    //
    //  Admin Queue
    //

    if(pAdminQueue != 0)
    {
        switch(pAdminQueue->GetType())
        {
            case QUEUE_FORMAT_TYPE_PUBLIC:
                //
                //  Admin Queue is PUBLIC
                //
                ulSize += sizeof(GUID);
                break;

            case QUEUE_FORMAT_TYPE_PRIVATE:
                if(pAdminQueue->PrivateID().Lineage == *pSourceQM)
                {
                    //
                    //  Private Queue in source QM
                    //
                    ulSize += sizeof(ULONG);
                }
                else if(
                    (pDestinationQueue->GetType() != QUEUE_FORMAT_TYPE_DIRECT) &&
                    (pAdminQueue->PrivateID().Lineage == *pDestinationQM))
                {
                    //
                    //  Private Queue in Destination QM
                    //
                    ulSize += sizeof(ULONG);
                }
                else
                {
                    //
                    //  Private Queue in some other Machine
                    //
                    ulSize += sizeof(OBJECTID);
                }
                break;

            case QUEUE_FORMAT_TYPE_DIRECT:
                //
                // Destination Queue is Direct
                //
                ulSize += ALIGNUP4_ULONG(sizeof(USHORT) +
                           (wcslen(pAdminQueue->DirectID()) + 1) * sizeof(WCHAR));
                break;

            case QUEUE_FORMAT_TYPE_MULTICAST:
            case QUEUE_FORMAT_TYPE_DL:
            default:
                ASSERT(("unexpected type", 0));
                break;
        }
    }

    //
    //  Response Queue
    //

    if(pResponseQueue != 0)
    {
        if(pResponseQueue == pAdminQueue)
        {
            //
            //  Same as admin queue (private or guid)
            //
        }
        else
        {
            switch(pResponseQueue->GetType())
            {
                case QUEUE_FORMAT_TYPE_PUBLIC:
                    //
                    //  GUID Queue that is not the same as admin queue.
                    //
                    ulSize += sizeof(GUID);
                    break;

                case QUEUE_FORMAT_TYPE_PRIVATE:
                    if (pResponseQueue->PrivateID().Lineage == *pSourceQM)
                    {
                        //
                        //  Private Queue in source QM
                        //
                        ulSize += sizeof(ULONG);
                    }
                    else if(
                        (pDestinationQueue->GetType() != QUEUE_FORMAT_TYPE_DIRECT) &&
                        (pResponseQueue->PrivateID().Lineage == *pDestinationQM))
                    {
                        //
                        //  Private Queue in Destination QM
                        //

                        ulSize += sizeof(ULONG);
                    }
                    else if((pAdminQueue != 0) &&
                            (pAdminQueue->GetType() == QUEUE_FORMAT_TYPE_PRIVATE) &&
                            (pResponseQueue->PrivateID().Lineage == pAdminQueue->PrivateID().Lineage))
                    {
                        //
                        //  Private Queue in Admin machine QM
                        //
                        ulSize += sizeof(ULONG);
                    }
                    else
                    {
                        //
                        //  Private Queue in some other Machine
                        //
                        ulSize += sizeof(GUID) + sizeof(ULONG);
                    }
                    break;

                case QUEUE_FORMAT_TYPE_DIRECT:
                    //
                    // Destination Queue is Direct
                    //
                    ulSize += ALIGNUP4_ULONG(sizeof(USHORT) +
                               (wcslen(pResponseQueue->DirectID()) + 1) * sizeof(WCHAR));
                    break;

                case QUEUE_FORMAT_TYPE_MULTICAST:
                case QUEUE_FORMAT_TYPE_DL:
                default:
                    ASSERT(("unexpected type", 0));
            }
        }
    }

    if (pgConnectorType)
    {
        ulSize += sizeof(GUID);
    }

    return ALIGNUP4_ULONG(ulSize);
}


/*======================================================================

 Function:

 Description:

 =======================================================================*/
 inline PCHAR CUserHeader::GetNextSection(PUCHAR PacketEnd) const
 {
    ULONG_PTR size = 0;
    size += QueueSize(m_bfPgm, m_bfDQT, &m_abQueues[0],PacketEnd);
    size += QueueSize(false,   m_bfAQT, &m_abQueues[size],PacketEnd);
    size += QueueSize(false,   m_bfRQT, &m_abQueues[size],PacketEnd);
    size += (int)(m_bfConnectorType ? sizeof(GUID) : 0);
    size += sizeof(*this);

    return (PCHAR)this + ALIGNUP4_ULONG(size);
 }

/*======================================================================

 Function:     CUserHeader::SetSrcQMGuid

 Description:  Set The source QM guid

 =======================================================================*/
inline void CUserHeader::SetSourceQM(const GUID* pGUID)
{
    m_gSourceQM = *pGUID;
}

/*======================================================================

 Function:     CUserHeader::GetSourceQM

 Description:  returns the source QM guid

 =======================================================================*/
inline const GUID* CUserHeader::GetSourceQM(void) const
{
    return &m_gSourceQM;
}

/*======================================================================

 Function:     CUserHeader::GetAddressSourceQM

 Description:  returns the source QM guid

 =======================================================================*/
inline const TA_ADDRESS *CUserHeader::GetAddressSourceQM(void) const
{
    return &m_taSourceQM;
}

/*======================================================================

 Function:     CUserHeader::SetAddressSourceQM

 Description:  Set The source QM address

 =======================================================================*/
inline void CUserHeader::SetAddressSourceQM(const TA_ADDRESS *pa)
{
    ULONG ul = TA_ADDRESS_SIZE + pa->AddressLength;

    memcpy((PVOID)&m_taSourceQM, 
           (PVOID)pa, 
           (ul < sizeof(GUID) ? ul : sizeof(GUID)));
}

/*======================================================================

 Function:    CUserHeader::SetDstQMGuid

 Description:

 =======================================================================*/
inline void CUserHeader::SetDestQM(const GUID* pGUID)
{
    m_gDestQM = *pGUID;
}

/*======================================================================

 Function:    CUserHeader::GetDstQMGuid

 Description:

 =======================================================================*/
inline const GUID* CUserHeader::GetDestQM(void) const
{
    return &m_gDestQM;
}

/*======================================================================

 Function:    CUserHeader::

 Description:

 =======================================================================*/
inline BOOL CUserHeader::GetDestinationQueue(QUEUE_FORMAT* pqf) const
{
    return GetQueue(&m_abQueues[0], m_bfPgm, m_bfDQT, pqf);
}

/*======================================================================

 Function:    CUserHeader::

 Description:

 =======================================================================*/
inline BOOL CUserHeader::GetAdminQueue(QUEUE_FORMAT* pqf) const
{
    //
    //  Prevent infinit recursion
    //
    ASSERT((m_bfAQT != qtAdminQ) && (m_bfAQT != qtAdminQM));

    int qsize = QueueSize(m_bfPgm, m_bfDQT, m_abQueues);
    return GetQueue(&m_abQueues[qsize], false, m_bfAQT, pqf);
}

/*======================================================================

 Function:    CUserHeader::

 Description:

 =======================================================================*/
inline BOOL CUserHeader::GetResponseQueue(QUEUE_FORMAT* pqf) const
{
    int qsize = QueueSize(m_bfPgm, m_bfDQT, &m_abQueues[0]);
    qsize +=    QueueSize(false,   m_bfAQT, &m_abQueues[qsize]);
    return GetQueue(&m_abQueues[qsize], false, m_bfRQT, pqf);
}

/*======================================================================

 Function:     CUserHeader::SetTimeToLiveDelta

 Description:  Set The Message Time-out to live field

 =======================================================================*/
inline void CUserHeader::SetTimeToLiveDelta(ULONG ulTimeout)
{
    m_ulTimeToLiveDelta = ulTimeout;
}

/*======================================================================

 Function:     CUserHeader::GetTimeToLiveDelta

 Description:  Returns the message Time-Out to Live

 =======================================================================*/
inline ULONG CUserHeader::GetTimeToLiveDelta(void) const
{
    return m_ulTimeToLiveDelta;
}

/*======================================================================

 Function:     CUserHeader::SetSentTime

 Description:  Set The Message Sent Time field

 =======================================================================*/
inline void CUserHeader::SetSentTime(ULONG ulSentTime)
{
    m_ulSentTime = ulSentTime;
}

/*======================================================================

 Function:     CUserHeader::GetSentTime

 Description:  Returns the message Sent Time

 =======================================================================*/
inline ULONG CUserHeader::GetSentTime(void) const
{
    return m_ulSentTime;
}

/*======================================================================

 Function:     CUserHeader::SetId

 Description:  Set Message ID (Uniq per QM)

 =======================================================================*/
inline void CUserHeader::SetMessageID(const OBJECTID* pMessageID)
{
    ASSERT(pMessageID->Lineage == *GetSourceQM());
    m_ulMessageID = pMessageID->Uniquifier;
}

/*======================================================================

 Function:    CUserHeader::GetId

 Description: Return the Message ID field

 =======================================================================*/
inline void CUserHeader::GetMessageID(OBJECTID* pMessageID) const
{
    pMessageID->Lineage = *GetSourceQM();
    pMessageID->Uniquifier = m_ulMessageID;
}

/*======================================================================

 Function:    CUserHeader::IncHopCount

 Description: Increment the message Hop count

 =======================================================================*/
inline void CUserHeader::IncHopCount(void)
{
    m_bfHopCount++;
}

/*======================================================================

 Function:    CUserHeader::GetHopCount

 Description: returns the message hop count

 =======================================================================*/
inline UCHAR CUserHeader::GetHopCount(void) const
{
    return (UCHAR)m_bfHopCount;
}

/*======================================================================

 Function:    CUserHeader::SetDeliveryMode

 Description: Set Messge Delivery mode

 =======================================================================*/
inline void CUserHeader::SetDelivery(UCHAR bDelivery)
{
    m_bfDelivery = bDelivery;
}

/*======================================================================

 Function:     CUserHeader::GetDeliveryMode

 Description:  return the message delivery mode

 =======================================================================*/
inline UCHAR CUserHeader::GetDelivery(void) const
{
    return (UCHAR)m_bfDelivery;
}

/*======================================================================

 Function:     CUserHeader::SetAuditing

 Description:  Set Auditing mode

 =======================================================================*/
inline void CUserHeader::SetAuditing(UCHAR bAuditing)
{
    m_bfAuditing = bAuditing;
}

/*======================================================================

 Function:      CUserHeader::GetAuditingMode

 Description:   return message auditing mode

 =======================================================================*/
inline UCHAR CUserHeader::GetAuditing(void) const
{
    return (UCHAR)m_bfAuditing;
}

/*======================================================================

 Function:    CUserHeader::

 Description: Set Message Security inclusion bit

 =======================================================================*/
inline void CUserHeader::IncludeSecurity(BOOL f)
{
    m_bfSecurity = f;
}

/*======================================================================

 Function:    CUserHeader::

 Description:

 =======================================================================*/
inline BOOL CUserHeader::SecurityIsIncluded(void) const
{
    return m_bfSecurity;
}

/*======================================================================

 Function:    CUserHeader::

 Description: Set Message Xaction inclusion bit

 =======================================================================*/
inline void CUserHeader::IncludeXact(BOOL f)
{
    m_bfXact= f;
}

/*======================================================================

 Function:    CUserHeader::

 Description:

 =======================================================================*/
inline BOOL CUserHeader::IsOrdered(void) const
{
    return m_bfXact;
}

/*======================================================================

 Function:    CUserHeader::SetPropertyInc

 Description: Set Message property inclusion bit

 =======================================================================*/
inline void CUserHeader::IncludeProperty(BOOL f)
{
    m_bfProperties = f;
}

/*======================================================================

 Function:    CUserHeader::IsPropertyInc

 Description: Returns TRUE if Message property section included, FALSE otherwise

 =======================================================================*/
inline BOOL CUserHeader::PropertyIsIncluded(VOID) const
{
    return m_bfProperties;
}

/*======================================================================

 Function:    CUserHeader::IncludeMqf

 Description: Set MQF sections inclusion bit

 =======================================================================*/
inline VOID CUserHeader::IncludeMqf(bool include)
{
    m_bfMqf = include ? 1 : 0;
}

/*======================================================================

 Function:    CUserHeader::MqfIsIncluded

 Description: Returns true if MQF sections included, false otherwise

 =======================================================================*/
inline bool CUserHeader::MqfIsIncluded(VOID) const
{
    return (m_bfMqf != 0);
}

/*======================================================================

 Function:    CUserHeader::IncludeSrmp

 Description: Set SRMP sections inclusion bit

 =======================================================================*/
inline VOID CUserHeader::IncludeSrmp(bool include)
{
    m_bfSrmp = include ? 1 : 0;
}

/*======================================================================

 Function:    CUserHeader::SrmpIsIncluded

 Description: Returns true if SRMP sections included, false otherwise

 =======================================================================*/
inline bool CUserHeader::SrmpIsIncluded(VOID) const
{
    return (m_bfSrmp != 0);
}

/*======================================================================

 Function:    CUserHeader::IncludeEod

 Description: Set Eod section inclusion bit

 =======================================================================*/
inline VOID CUserHeader::IncludeEod(bool include)
{
    m_bfEod = include ? 1 : 0;
}

/*======================================================================

 Function:    CUserHeader::EodIsIncluded

 Description: Returns true if Eod section included, false otherwise

 =======================================================================*/
inline bool CUserHeader::EodIsIncluded(VOID) const
{
    return (m_bfEod != 0);
}

/*======================================================================

 Function:    CUserHeader::IncludeEodAck

 Description: Set EodAck section inclusion bit

 =======================================================================*/
inline VOID CUserHeader::IncludeEodAck(bool include)
{
    m_bfEodAck = include ? 1 : 0;
}

/*======================================================================

 Function:    CUserHeader::EodAckIsIncluded

 Description: Returns true if EodAck section included, false otherwise

 =======================================================================*/
inline bool CUserHeader::EodAckIsIncluded(VOID) const
{
    return (m_bfEodAck != 0);
}

/*======================================================================

 Function:    CUserHeader::IncludeSoap

 Description: Set Soap sections inclusion bit

 =======================================================================*/
inline VOID CUserHeader::IncludeSoap(bool include)
{
    m_bfSoap = include ? 1 : 0;
}

/*======================================================================

 Function:    CUserHeader::SoapIsIncluded

 Description: Returns true if Soap sections included, false otherwise

 =======================================================================*/
inline bool CUserHeader::SoapIsIncluded(VOID) const
{
    return (m_bfSoap != 0);
}

/*======================================================================

 Function:    CUserHeader::

 Description:

 =======================================================================*/
inline int CUserHeader::QueueSize(bool fPgm, ULONG qt, const UCHAR* pQueue, PUCHAR PacketEnd)
{
    if (fPgm)
    {
        ASSERT(("if PGM packet then queue type is none", qt == qtNone));
        return (sizeof(ULONG) + sizeof(ULONG));
    }

    if(qt < qtSourceQM)
    {
        return 0;
    }

    if(qt < qtGUID)
    {
    	if (PacketEnd != NULL)
    	{
			ULONG Uniquifier;
			GetSafeDataAndAdvancePointer<ULONG>(pQueue, PacketEnd, &Uniquifier);
			if (0 == Uniquifier)
			{
		        ReportAndThrow("User section is not valid: Uniquifier can not be 0");
			}		
    	}
        return sizeof(ULONG);
    }

    if(qt == qtGUID)
    {
        return sizeof(GUID);
    }

    if (qt == qtPrivate)
    {
    	if (PacketEnd != NULL)
    	{
			pQueue += sizeof(GUID);
			ULONG Uniquifier;
			GetSafeDataAndAdvancePointer<ULONG>(pQueue, PacketEnd, &Uniquifier);
			if (0 == Uniquifier)
			{
		        ReportAndThrow("User section is not valid: private queue Uniquifier can not be 0");
			}		
    	}
        return (sizeof(GUID) + sizeof(ULONG));
    }

    if (qt == qtDirect)
    {
    	USHORT length;
    	GetSafeDataAndAdvancePointer<USHORT>(pQueue, PacketEnd, &length);

    	if (PacketEnd != NULL)
    	{
			WCHAR wch;
	    	GetSafeDataAndAdvancePointer<WCHAR>(&pQueue[length], PacketEnd, &wch);
	    	if (wch != L'\0')
	    	{
		        ReportAndThrow("User section is not valid: Direct queue need to be NULL terminated");
	    	}
    	}
        length += sizeof(USHORT);
        return ALIGNUP4_ULONG(length);
    }

    //
    //  Unexpected type, assert with no Warning level 4.
    //
    ASSERT(qt == qtDirect);

    return 0;
}

/*======================================================================

 Function:    CUserHeader::

 Description:

 =======================================================================*/
inline BOOL CUserHeader::GetQueue(const UCHAR* pQueue, bool fPgm, ULONG qt, QUEUE_FORMAT* pqf) const
{
    ASSERT(("If PGM packet then queue type is none", !fPgm || qt == qtNone));

    switch(qt)
    {
        case qtNone:
            if (fPgm)
            {
                MULTICAST_ID id;
                id.m_address = *(ULONG*)pQueue;
                id.m_port    = *(ULONG*)(pQueue + sizeof(ULONG));
                pqf->MulticastID(id);
                return TRUE;
            }

            pqf->UnknownID(0);
            return FALSE;

        case qtAdminQ:
            return GetAdminQueue(pqf);

        case qtSourceQM:
            pqf->PrivateID(*GetSourceQM(), *(PULONG)pQueue);
            return TRUE;

        case qtDestQM:
            pqf->PrivateID(*GetDestQM(), *(PULONG)pQueue);
            return TRUE;

        case qtAdminQM:
            //
            //  Note that this case implies that Admin queue exists
            //
            GetAdminQueue(pqf);
            pqf->PrivateID(pqf->PrivateID().Lineage, *(PULONG)pQueue);
            return TRUE;

        case qtGUID:
            pqf->PublicID(*(GUID*)pQueue);
            return TRUE;

        case qtPrivate:
            pqf->PrivateID(*(OBJECTID*)pQueue);
            return TRUE;

        case qtDirect:
            pqf->DirectID((WCHAR*)(pQueue + sizeof(USHORT)));
            return TRUE;

        default:
            //
            //  Unexpected type, assert with no Warning level 4.
            //
            ASSERT(qt != qtNone);
    };
    return FALSE;
}


/*======================================================================

 Function:    CUserHeader::SetDirectQueue

 Description: Set direct queue.

 =======================================================================*/
inline PUCHAR CUserHeader::SetDirectQueue(PUCHAR pQueue, const WCHAR* pwcsDirectQueue)
{
    ASSERT(ISALIGN4_PTR(pQueue));

    size_t size = (wcslen(pwcsDirectQueue) + 1) * sizeof(WCHAR);

    *reinterpret_cast<USHORT*>(pQueue) = static_cast<USHORT>(size);
    memcpy(pQueue + sizeof(USHORT), pwcsDirectQueue, size);
    return (pQueue + ALIGNUP4_ULONG(sizeof(USHORT) + size));
}


/*===========================================================

  Function: CUserHeader::SetConnectorType

  Description:

=============================================================*/
inline void CUserHeader::SetConnectorType(const GUID* pgConnectorType)
{
    ASSERT(pgConnectorType);

    int qsize = QueueSize(m_bfPgm, m_bfDQT, &m_abQueues[0]);
    qsize +=    QueueSize(false,   m_bfAQT, &m_abQueues[qsize]);
    qsize +=    QueueSize(false,   m_bfRQT, &m_abQueues[qsize]);
    memcpy(&m_abQueues[qsize], pgConnectorType, sizeof(GUID));

    m_bfConnectorType = TRUE;
}

/*===========================================================

  Function: CUserHeader::ConnectorTypeIsIncluded

  Description:

=============================================================*/
inline BOOL CUserHeader::ConnectorTypeIsIncluded(void) const
{
    return m_bfConnectorType;
}

/*===========================================================

  Function: CUserHeader::GetConnectorType

  Description:

=============================================================*/
inline const GUID* CUserHeader::GetConnectorType(void) const
{
    if(!ConnectorTypeIsIncluded())
    {
        return 0;
    }

    int qsize = QueueSize(m_bfPgm, m_bfDQT, &m_abQueues[0]);
    qsize +=    QueueSize(false,   m_bfAQT, &m_abQueues[qsize]);
    qsize +=    QueueSize(false,   m_bfRQT, &m_abQueues[qsize]);
    return reinterpret_cast<const GUID*>(&m_abQueues[qsize]);
}


#endif // __PHUSER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\pnotify.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    pnotify.h

Abstract:

    Notification message header definition

Author:


--*/

#ifndef __PNOTIFY_H
#define __PNOTIFY_H

#define DS_NOTIFICATION_MSG_VERSION 1
#define QM_NOTIFICATION_MSG_VERSION 2

//
// struct CNotificationHeader
//

struct CNotificationHeader {
public:

    inline void SetVersion(const unsigned char ucVersion);
    inline const unsigned char GetVersion(void) const;

    inline void SetNoOfNotifications( const unsigned char ucNoOfNotifications);
    inline const unsigned char GetNoOfNotifications( void) const;

    inline unsigned char * GetPtrToData( void) const;

    inline const DWORD GetBasicSize( void) const;


private:

    unsigned char   m_ucVersion;
    unsigned char   m_ucNoOfNotifications;
    unsigned char   m_ucData;
};

/*======================================================================

 Function:     CNotificationHeader::SetVersion

 Description:  Set version number

 =======================================================================*/
inline void CNotificationHeader::SetVersion(const unsigned char ucVersion)
{
    m_ucVersion = ucVersion;
}

/*======================================================================

 Function:     CNotificationHeader::GetVersion

 Description:  returns the version number

 =======================================================================*/
inline const unsigned char CNotificationHeader::GetVersion(void) const
{
    return m_ucVersion;
}

/*======================================================================

 Function:     CNotificationHeader::SetNoOfNotifications

 Description:  Set number of notifications

 =======================================================================*/
inline void CNotificationHeader::SetNoOfNotifications( const unsigned char ucNoOfNotifications)
{
    m_ucNoOfNotifications = ucNoOfNotifications;
}
/*======================================================================

 Function:     CNotificationHeader::GetNoOfNotifications

 Description:  returns the number of notifications

 =======================================================================*/
inline const unsigned char CNotificationHeader::GetNoOfNotifications( void) const
{
    return m_ucNoOfNotifications;
}
/*======================================================================

 Function:     CNotificationHeader::GetPtrToData

 Description:  returns pointer to packet data

 =======================================================================*/
inline  unsigned char * CNotificationHeader::GetPtrToData( void) const
{
    return (unsigned char *)&m_ucData;
}
/*======================================================================

 Function:     CNotificationHeader::GetBasicSize

 Description:  returns pointer to packet data

 =======================================================================*/
inline const DWORD CNotificationHeader::GetBasicSize( void) const
{
    return( sizeof(*this) - sizeof(m_ucData));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\phxact.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    phxact.h

Abstract:

    Handle Transaction Section in Falcon Header

Author:

    Alexdad    26-Nov-96

--*/

#ifndef __PHXACT_H
#define __PHXACT_H

#pragma pack(push, 1)
#pragma warning(disable: 4200)  //  zero-sized array in struct/union (enabeld later)

//
//  struct CXactHeader
//

struct CXactHeader {
public:

    inline CXactHeader(const GUID* pgConnectorQM);

    static ULONG CalcSectionSize(PVOID pUow, const GUID* pgConnectorQM);
    inline PCHAR GetNextSection(void) const;

    inline void     SetSeqID(LONGLONG liSeqID);
    inline LONGLONG GetSeqID(void) const;

    inline void    SetSeqN(ULONG ulSeqN);
    inline ULONG   GetSeqN(void) const;

    inline void    SetPrevSeqN(ULONG ulPrevSeqN);
    inline ULONG   GetPrevSeqN(void) const;

    inline void    SetConnectorQM(const GUID* pGUID);
    inline const GUID* GetConnectorQM(void) const;
    inline BOOL    ConnectorQMIncluded(void) const;

    inline void    SetCancelFollowUp(BOOL  fCancelFollowUp);
    inline BOOL    GetCancelFollowUp(void) const;

    inline PUCHAR  GetPrevSeqNBuffer() const;
    inline ULONG   GetPrevSeqNBufferSize() const;
	inline PUCHAR  GetConnectorQMBuffer() const;
	inline ULONG   GetConnectorQMBufferSize() const;

    inline UCHAR   GetFirstInXact(void) const;
    inline void    SetFirstInXact(UCHAR fFirst);

    inline UCHAR   GetLastInXact(void) const;
    inline void    SetLastInXact(UCHAR fLast);

    inline void    SetXactIndex(ULONG ulXactIndex);
    inline ULONG   GetXactIndex(void) const;

	void SectionIsValid(PCHAR PacketEnd) const;

private:
//
// BEGIN Network Monitor tag
//
    union {
        ULONG   m_ulFlags;
        struct {
            ULONG m_bfConnector      : 1;
            ULONG m_bfCancelFollowUp : 1;
            ULONG m_bfFirst          : 1;
            ULONG m_bfLast           : 1;
            ULONG m_bfXactIndex      : 20;
        };
    };
    LONGLONG m_liSeqID;
    ULONG    m_ulSeqN;
    ULONG    m_ulPrevSeqN;
    UCHAR    m_gConnectorQM[0];

//
// END Network Monitor tag
//
};

#pragma warning(default: 4200)  //  zero-sized array in struct/union
#pragma pack(pop)

/*=============================================================

 Routine Name:  CXactHeader::

 Description:

===============================================================*/
inline CXactHeader::CXactHeader(const GUID* pgConnectorQM):
    m_ulFlags(0),
    m_liSeqID(0),
    m_ulSeqN(0),
    m_ulPrevSeqN(0)
{
    if (pgConnectorQM)
    {
        m_bfConnector = TRUE;
        memcpy(m_gConnectorQM, pgConnectorQM, sizeof(GUID));
    }
}

/*=============================================================

 Routine Name:  CXactHeader::CalcSectionSize(PVOID pUow)

 Description:

===============================================================*/
inline ULONG CXactHeader::CalcSectionSize(PVOID pUow, const GUID* pgConnectorQM)
{
    ULONG ulSize = (ULONG)(pUow == NULL ? 0 : sizeof(CXactHeader));
    if (pUow && pgConnectorQM)
    {
        ulSize = ulSize + sizeof(GUID);
    }
    return ALIGNUP4_ULONG(ulSize);
}

/*=============================================================

 Routine Name:  CXactHeader::

 Description:

===============================================================*/
inline PCHAR CXactHeader::GetNextSection(void) const
{
    int size = sizeof(*this);

    size += (int)((m_bfConnector) ? sizeof(GUID) : 0);

    return (PCHAR)this + ALIGNUP4_ULONG(size);
}

/*======================================================================

 Function:    CXactHeader::SetSeqID

 Description: Sets the Sequence ID

 =======================================================================*/
inline void CXactHeader::SetSeqID(LONGLONG liSeqID)
{
    m_liSeqID = liSeqID;
}

/*======================================================================

 Function:    CXactHeader::GetSeqID

 Description: Gets the Sequence ID

 =======================================================================*/
inline LONGLONG CXactHeader::GetSeqID(void) const
{
    return m_liSeqID;
}

/*======================================================================

 Function:    CXactHeader::SetSeqN

 Description: Sets the Sequence Number

 =======================================================================*/
inline void CXactHeader::SetSeqN(ULONG ulSeqN)
{
    m_ulSeqN = ulSeqN;
}

/*======================================================================

 Function:    CXactHeader::GetSeqN

 Description: Gets the Sequence Number

 =======================================================================*/
inline ULONG CXactHeader::GetSeqN(void) const
{
    return m_ulSeqN;
}

/*======================================================================

 Function:    CXactHeader::SetPrevSeqN

 Description: Sets the Previous Sequence Number

 =======================================================================*/
inline void CXactHeader::SetPrevSeqN(ULONG ulPrevSeqN)
{
    m_ulPrevSeqN = ulPrevSeqN;
}

/*======================================================================

 Function:    CXactHeader::GetPrevSeqN

 Description: Gets the Previous Sequence Number

 =======================================================================*/
inline ULONG CXactHeader::GetPrevSeqN(void) const
{
    return m_ulPrevSeqN;
}

/*======================================================================

 Function:    CXactHeader::SetCancelFollowUp

 Description: Sets the flag of Follow-Up cancelation

 =======================================================================*/
inline void CXactHeader::SetCancelFollowUp(BOOL fCancelFollowUp)
{
    m_bfCancelFollowUp = fCancelFollowUp;
}

/*======================================================================

 Function:    CXactHeader::GetCancelFollowUp

 Description: Gets the flag of Follow-Up cancelation

 =======================================================================*/
inline BOOL CXactHeader::GetCancelFollowUp(void) const
{
    return m_bfCancelFollowUp;
}


/*======================================================================

 Function:    CXactHeader::SetFirstInXact

 Description: Sets the flag of First In Transaction

 =======================================================================*/
inline void CXactHeader::SetFirstInXact(UCHAR fFirst)
{
    m_bfFirst= fFirst;
}

/*======================================================================

 Function:    CXactHeader::GetFirstInXact

 Description: Gets the flag of First In Transaction

 =======================================================================*/
inline UCHAR CXactHeader::GetFirstInXact(void) const
{
    return (UCHAR)m_bfFirst;
}

/*======================================================================

 Function:    CXactHeader::SetLastInXact

 Description: Sets the flag of Last In Transaction

 =======================================================================*/
inline void CXactHeader::SetLastInXact(UCHAR fLast)
{
    m_bfLast= fLast;
}


/*======================================================================

 Function:    CXactHeader::GetLastInXact

 Description: Gets the flag of Last In Transaction

 =======================================================================*/
inline UCHAR CXactHeader::GetLastInXact(void) const
{
    return (UCHAR)m_bfLast;
}

/*======================================================================

 Function:    CXactHeader::SetXactIndex

 Description: Sets the Transaction Index

 =======================================================================*/
inline void CXactHeader::SetXactIndex(ULONG ulXactIndex)
{
    m_bfXactIndex = (ulXactIndex & 0x000FFFFF);
}

/*======================================================================

 Function:    CXactHeader::GetXactIndex

 Description: Gets the Transaction Index

 =======================================================================*/
inline ULONG CXactHeader::GetXactIndex(void) const
{
    return m_bfXactIndex;
}


/*======================================================================

 Function:    CXactHeader::SetConnectorQM

 Description:

 =======================================================================*/
inline void CXactHeader::SetConnectorQM(const GUID* pGUID)
{
    m_bfConnector = TRUE;
    memcpy(m_gConnectorQM, pGUID, sizeof(GUID));
}

/*======================================================================

 Function:    CXactHeader::GetConnectorQM

 Description:

 =======================================================================*/
inline const GUID* CXactHeader::GetConnectorQM(void) const
{
    ASSERT(m_bfConnector);
    return (GUID*)m_gConnectorQM;
}

/*======================================================================

 Function:    CXactHeader::ConnectorQMIncluded

 Description:

 =======================================================================*/
inline BOOL CXactHeader::ConnectorQMIncluded(void) const
{
    return m_bfConnector;
}

/*======================================================================

 Function:    CXactHeader::GetConnectorQMBuffer()

 Description:

 =======================================================================*/
inline PUCHAR CXactHeader::GetConnectorQMBuffer() const
{
	return (PUCHAR) m_gConnectorQM;
}

/*======================================================================

 Function:    CXactHeader::GetConnectorQMBufferSize

 Description:

 =======================================================================*/
inline ULONG CXactHeader::GetConnectorQMBufferSize() const
{
	return sizeof GUID;
}

/*======================================================================

 Function:    CXactHeader::GetPrevSeqNBuffer()

 Description:

 =======================================================================*/
inline PUCHAR CXactHeader::GetPrevSeqNBuffer() const
{
	return (PUCHAR) &m_ulPrevSeqN;
}

/*======================================================================

 Function:    CXactHeader::GetPrevSeqNBufferSize

 Description:

 =======================================================================*/
inline ULONG CXactHeader::GetPrevSeqNBufferSize() const
{
	return sizeof m_ulPrevSeqN;
}

#endif // __PHXACT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\phsoap.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    phsoap.h

Abstract:

    Packet sections for SOAP header and SOAP body write-only properties.

Author:

    Shai Kariv  (shaik)  11-Apr-2001

--*/

#ifndef __PH_SOAP_H
#define __PH_SOAP_H


/*+++

    Note: Packet may contain 0 or 2 SOAP sections (SOAP Header and SOAP Body),
          a SOAP section can be empty (with no date).
          Packet may not contain only 1 SOAP section

    SOAP section fields:
    
+----------------+-------------------------------------------------------+----------+
| FIELD NAME     | DESCRIPTION                                           | SIZE     |
+----------------+-------------------------------------------------------+----------+
| Section ID     | Identification of the section                         | 2 bytes  |
+----------------+-------------------------------------------------------+----------+
| Reserved       | Reserved for future extensions. Must be set to zero.  | 2 bytes  |
+----------------+-------------------------------------------------------+----------+
| Data Length    | Length of the data in WCHARs.                         | 4 bytes  |
+----------------+-------------------------------------------------------+----------+
| Data           | The data WCHARs including NULL terminator.            | Variable |
+----------------+-------------------------------------------------------+----------+

---*/


#pragma pack(push, 1)
#pragma warning(disable: 4200)  //  zero-sized array in struct/union (enabeld later)


class CSoapSection
{
public:

    //
    // Construct the SOAP section
    //
    CSoapSection(WCHAR * pData, ULONG DataLengthInWCHARs, USHORT id);

    //
    // Get size in BYTEs of the SOAP section
    //
    static ULONG CalcSectionSize(ULONG DataLengthInWCHARs);

    //
    // Get pointer to first byte after the SOAP section
    //
    PCHAR  GetNextSection(VOID) const;

	//
	// Get pointer to the data on the SOAP section
	//
    const WCHAR* GetPointerToData(VOID) const;

    //
    // Copy the data from the SOAP section
    //
    VOID   GetData(WCHAR * pBuffer, ULONG BufferLengthInWCHARs) const;

    //
    // Get the length of the data in WCHARs from the SOAP section
    //
    ULONG  GetDataLengthInWCHARs(VOID) const;

private:

    //
    // ID number of the SOAP section
    //
    USHORT m_id;

    //
    // Reserved (for alignment)
    //
    USHORT m_ReservedSetToZero;

    //
    // Length in WCHARs of the data
    //
    ULONG  m_DataLength;

    //
    // Buffer with the data
    //
    UCHAR  m_buffer[0];

}; // CSoapSection


#pragma warning(default: 4200)  //  zero-sized array in struct/union
#pragma pack(pop)



////////////////////////////////////////////////////////
//
//  Implementation
//

inline
CSoapSection::CSoapSection(
    WCHAR * pData, 
    ULONG   DataLengthInWCHARs, 
    USHORT  id
    ) :
    m_id(id),
    m_ReservedSetToZero(0),
    m_DataLength(DataLengthInWCHARs + 1)
{
    if (DataLengthInWCHARs != 0)
    {
        memcpy(&m_buffer[0], pData, DataLengthInWCHARs * sizeof(WCHAR));
    }

	//
	// Putting unicode null terminator at end of buffer.
	//
	m_buffer[DataLengthInWCHARs * sizeof(WCHAR)]     = '\0';
	m_buffer[DataLengthInWCHARs * sizeof(WCHAR) + 1] = '\0';

} // CSoapSection::CSoapSection


inline 
ULONG
CSoapSection::CalcSectionSize(
    ULONG DataLengthInWCHARs
    )
{
    size_t cbSize = sizeof(CSoapSection) + ((DataLengthInWCHARs + 1) * sizeof(WCHAR));

    //
    // Align the entire header size to 4 bytes boundaries
    //
    cbSize = ALIGNUP4_ULONG(cbSize);
    return static_cast<ULONG>(cbSize);

} // CSoapSection::CalcSectionSize


inline PCHAR CSoapSection::GetNextSection(VOID) const
{
    size_t cbSize = sizeof(CSoapSection) + (m_DataLength * sizeof(WCHAR));
    cbSize = ALIGNUP4_ULONG(cbSize);

    return (PCHAR)this + cbSize;

} // CSoapSection::GetNextSection


inline const WCHAR* CSoapSection::GetPointerToData(VOID) const
{
	//
	// A NULL terminated string is stored on the SOAP section so miminum
	// length is 1
	//
    if (m_DataLength <= 1)
    {
        return NULL;
    }

    return reinterpret_cast<const WCHAR*>(&m_buffer[0]);

} // CSoapSection::GetPointerToData


inline VOID CSoapSection::GetData(WCHAR * pBuffer, ULONG BufferLengthInWCHARs) const
{
    ULONG length = min(BufferLengthInWCHARs, m_DataLength);

    if (length != 0)
    {
        memcpy(pBuffer, &m_buffer[0], length * sizeof(WCHAR));
        pBuffer[length - 1] = L'\0';
    }
} // CSoapSection::GetData


inline ULONG CSoapSection::GetDataLengthInWCHARs(VOID) const
{
    return m_DataLength;

} // CSoapSection::GetDataLengthInWCHARs


#endif // __PH_SOAP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\portapi.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    portapi.h

Abstract:

    Mapping Win32 API to HRESULT APIs.

Author:

    Erez Haba (erezh) 23-Jan-96

Revision History:

--*/

#ifndef _PORTAPI_H
#define _PORTAPI_H

#define MQpDuplicateHandle DuplicateHandle

// --- implementation -------------------------------------
//
// Mapped Win32 APIs
//

inline
HRESULT
MQpCreateFileW(
    LPCWSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDistribution,
    DWORD dwFlagsAndAttributes,
    PHANDLE pHandle
   )
{
    HANDLE hFile = CreateFileW(
                    lpFileName,
                    dwDesiredAccess,
                    dwShareMode,
                    lpSecurityAttributes,
                    dwCreationDistribution,
                    dwFlagsAndAttributes,
                    0
                    );

    if(hFile == INVALID_HANDLE_VALUE)
    {
        //
        //  The create can fail on either, the AC driver has not been
        //  started, or this is not the QM service.
        //

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    *pHandle = hFile;

    return STATUS_SUCCESS;
}


inline
HRESULT
MQpCloseHandle(
    HANDLE handle
    )
{
    NTSTATUS rc = NtClose(handle);
    return rc;
}


inline
HRESULT
MQpDeviceIoControl(
    HANDLE hDevice,
    DWORD dwIoControlCode,
    LPVOID lpInBuffer,
    DWORD nInBufferSize,
    LPVOID lpOutBuffer,
    DWORD nOutBufferSize,
    LPOVERLAPPED lpOverlapped
    )
{
    ASSERT(lpOverlapped != 0);

    //
    //  NOTE: This section was taken out of NT source code.
    //

    lpOverlapped->Internal = STATUS_PENDING;

    NTSTATUS rc;
    rc = NtDeviceIoControlFile(
            hDevice,
            lpOverlapped->hEvent,
            0,  // APC routine
            ((DWORD_PTR)lpOverlapped->hEvent & (DWORD_PTR)1) ? 0 : lpOverlapped,
            (PIO_STATUS_BLOCK)&lpOverlapped->Internal,
            dwIoControlCode,
            lpInBuffer,
            nInBufferSize,
            lpOutBuffer,
            nOutBufferSize
            );

    return rc;
}


inline
HRESULT
MQpDeviceIoControl(
    HANDLE hDevice,
    DWORD dwIoControlCode,
    LPVOID lpInBuffer,
    DWORD nInBufferSize,
    LPVOID lpOutBuffer,
    DWORD nOutBufferSize
    )
{
    static IO_STATUS_BLOCK Iosb;

    NTSTATUS rc;
    rc = NtDeviceIoControlFile(
            hDevice,
            0,
            0,             // APC routine
            0,             // APC Context
            &Iosb,
            dwIoControlCode,  // IoControlCode
            lpInBuffer,       // Buffer for data to the FS
            nInBufferSize,
            lpOutBuffer,      // OutputBuffer for data from the FS
            nOutBufferSize    // OutputBuffer Length
            );

    return rc;
}


#endif // _PORTAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\privque.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:

    privque.h

Abstract:

   Definitions for system private queues

Author:

    Doron Juster  (DoronJ)   17-Apr-97  Created

--*/

#ifndef  __PRIVQUE_H_
#define  __PRIVQUE_H_

//
// System Private queue identifiers
//
#define REPLICATION_QUEUE_ID         1
#define ADMINISTRATION_QUEUE_ID      2
#define NOTIFICATION_QUEUE_ID        3
#define ORDERING_QUEUE_ID            4
#define NT5PEC_REPLICATION_QUEUE_ID  5

#define MIN_SYS_PRIVATE_QUEUE_ID   1
#define MAX_SYS_PRIVATE_QUEUE_ID   5

//
// System Private queue name
//
#define L_REPLICATION_QUEUE_NAME        L"mqis_queue$"
#define REPLICATION_QUEUE_NAME     (TEXT("mqis_queue$"))
#define ADMINISTRATION_QUEUE_NAME  (TEXT("admin_queue$"))
#define NOTIFICATION_QUEUE_NAME    (TEXT("notify_queue$"))
#define ORDERING_QUEUE_NAME        (TEXT("order_queue$"))

#define L_NT5PEC_REPLICATION_QUEUE_NAME    L"nt5pec_mqis_queue$"
#define NT5PEC_REPLICATION_QUEUE_NAME (TEXT("nt5pec_mqis_queue$"))

#endif //  __PRIVQUE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\rpccli.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name: rpccli.h

Abstract: rpc related code.


Author:

    Ilan Herbst    (ilanh)   9-July-2000 

--*/

#ifndef _RPCCLI_H_
#define _RPCCLI_H_


HRESULT 
GetRpcClientHandle(
	handle_t *phBind
	);

HRESULT 
QMRpcSendMsg(
    IN handle_t hBind,
    IN LPWSTR lpwszDestination,
    IN DWORD dwSize,
    IN const unsigned char *pBuffer,
    IN DWORD dwTimeout,
    IN unsigned char bAckMode,
    IN unsigned char bPriority,
    IN LPWSTR lpwszAdminResp
	);

//
// from replserv\mq1repl\replrpc.h
// 
#define  QMREPL_PROTOCOL   (TEXT("ncalrpc"))
#define  QMREPL_ENDPOINT   (TEXT("QmReplService"))
#define  QMREPL_OPTIONS    (TEXT("Security=Impersonation Dynamic True"))

#endif //_RPCCLI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\qm.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    qm.h

Abstract:

    QM DLL interface

Author:

    Uri Habusha (urih) 1-Jan-1996

--*/

#pragma once

#ifndef __QM_H__
#define __QM_H__


//---------------------------------------------------------
//
// QM APIs
//
//---------------------------------------------------------

#ifdef _QM_
#define QM_EXPORT  __declspec(dllexport)
#else
#define QM_EXPORT  __declspec(dllimport)
#endif


QM_EXPORT
int
APIENTRY
QMMain(
    int argc,
    LPCTSTR argv[]
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\qformat.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:
    qformat.h

Abstract:
    Falcon Internal Queue format represintation for FormatQueue string.

Author:
    Erez Haba (erezh) 14-Mar-96

Note:
    This file is compiled in Kernel Mode and User Mode.

--*/

#ifndef __QFORMAT_H
#define __QFORMAT_H

#ifndef _QUEUE_FORMAT_DEFINED
#define _QUEUE_FORMAT_DEFINED

#ifdef __midl
cpp_quote("#ifndef __cplusplus")
cpp_quote("#ifndef _QUEUE_FORMAT_DEFINED")
cpp_quote("#define _QUEUE_FORMAT_DEFINED")
#endif // __midl

enum QUEUE_FORMAT_TYPE {
    QUEUE_FORMAT_TYPE_UNKNOWN = 0,
    QUEUE_FORMAT_TYPE_PUBLIC,
    QUEUE_FORMAT_TYPE_PRIVATE,
    QUEUE_FORMAT_TYPE_DIRECT,
    QUEUE_FORMAT_TYPE_MACHINE,
    QUEUE_FORMAT_TYPE_CONNECTOR,
    QUEUE_FORMAT_TYPE_DL,
    QUEUE_FORMAT_TYPE_MULTICAST
};

//
// Note - four bits value. No more than 16 Suffixes are allowed
//
enum QUEUE_SUFFIX_TYPE {
    QUEUE_SUFFIX_TYPE_NONE = 0,
    QUEUE_SUFFIX_TYPE_JOURNAL,
    QUEUE_SUFFIX_TYPE_DEADLETTER,
    QUEUE_SUFFIX_TYPE_DEADXACT,
    QUEUE_SUFFIX_TYPE_XACTONLY,
};

#define QUEUE_FORMAT_SUFFIX_MASK 0x0F
//
// Queue type flags - bit flags in the high order four bits of QUEUE_FORMAT::m_SuffixAndFlags
// No more than four flags are allowed. Last four bits must be 0 (YoelA - 5/30/99).
// 
#define QUEUE_FORMAT_FLAG_SYSTEM 0x80


//---------------------------------------------------------
//
//  struct MULTICAST_ID
//
//  This struct is RPC'able. Use LPWSTR and not WCHAR* .
//
//---------------------------------------------------------
typedef struct _MULTICAST_ID {
    ULONG m_address;
    ULONG m_port;
} MULTICAST_ID;


//---------------------------------------------------------
//
//  struct DL_ID
//
//  This struct is RPC'able. Use LPWSTR and not WCHAR* .
//
//---------------------------------------------------------
#ifndef _WIN64
#pragma pack(push, 4)
#endif

typedef struct _DL_ID {
    GUID   m_DlGuid;
    LPWSTR m_pwzDomain;
} DL_ID;

#ifndef __midl
const size_t xSizeOfDlId32 = 20;
#ifndef _WIN64
C_ASSERT(sizeof(DL_ID) == xSizeOfDlId32);
#endif
#endif

#ifndef _WIN64
#pragma pack(pop)
#endif


//---------------------------------------------------------
//
//  struct DL_ID_32
//
//  This struct is not RPC'able. It is OK to use WCHAR* .
//
//---------------------------------------------------------
#ifdef _WIN64
#ifndef __midl

#pragma pack(push, 4)

typedef struct _DL_ID_32 {
    GUID               m_DlGuid;
    WCHAR * POINTER_32 m_pwzDomain;
} DL_ID_32;

C_ASSERT(sizeof(DL_ID_32) == xSizeOfDlId32);

#pragma pack(pop)

#endif // __midl
#endif // _WIN64


//---------------------------------------------------------
//
//  struct QUEUE_FORMAT
//
//  NOTE:   This structure should NOT contain virtual
//          functions. They are not RPC-able.
//
//---------------------------------------------------------

#ifdef _WIN64
struct QUEUE_FORMAT_32; //forward def
#endif //_WIN64

struct QUEUE_FORMAT {

#ifndef __midl
public:

    bool Legal() const;
    bool IsValid() const;

    QUEUE_FORMAT_TYPE GetType() const;
    QUEUE_SUFFIX_TYPE Suffix() const;
    void Suffix(QUEUE_SUFFIX_TYPE);

    QUEUE_FORMAT();
    void UnknownID(PVOID);

    QUEUE_FORMAT(const GUID&);
    void PublicID(const GUID&);
    const GUID& PublicID() const;

    QUEUE_FORMAT(const DL_ID&);
    void DlID(const DL_ID&);
    const DL_ID& DlID() const;

    QUEUE_FORMAT(const OBJECTID&);
    void PrivateID(const OBJECTID&);
    QUEUE_FORMAT(const GUID&, ULONG);
    void PrivateID(const GUID&, ULONG);
    const OBJECTID& PrivateID() const;

    QUEUE_FORMAT(LPWSTR);
    void DirectID(LPWSTR);
    void DirectID(LPWSTR, UCHAR);
    LPCWSTR DirectID() const;

    QUEUE_FORMAT(PVOID, const GUID&);
    void MachineID(const GUID&);
    const GUID& MachineID() const;

    void  ConnectorID(const GUID&);
    const GUID& ConnectorID() const;

    QUEUE_FORMAT(const MULTICAST_ID&);
    void MulticastID(const MULTICAST_ID&);
    const MULTICAST_ID& MulticastID() const;

    void DisposeString();
    bool IsSystemQueue() const;

#ifdef _WIN64
    //
    // initialize from a QUEUE_FORMAT_32 (32 bit ptrs)
    //
    void InitFromQueueFormat32(IN const struct QUEUE_FORMAT_32 *);
#endif //_WIN64    

private:

#endif // !__midl

    UCHAR m_qft;

    //
    //  m_SuffixAndFlags - Most significant 4 bits are flags, least significant 4 bits are suffix.
    //  (Used to be m_qst in MSMQ 1.0 - YoelA, 5/31/99).
    //
    UCHAR m_SuffixAndFlags;

    //
    // Note - do not use m_reserved if you need MSMQ 1.0 compatibility over RPC.
    // This is because MSMQ 1.0 does not put zero in m_reserved, so it can have any value.
    // (YoelA - 5/31/99)
    //
    USHORT m_reserved; 

#ifdef __midl
    [switch_is(m_qft)]
#endif // __midl

    union {
#ifdef __midl
        [case(QUEUE_FORMAT_TYPE_UNKNOWN)]
#endif
            ;
#ifdef __midl
        [case(QUEUE_FORMAT_TYPE_PUBLIC)]
#endif // __midl
        GUID m_gPublicID;

#ifdef __midl
        [case(QUEUE_FORMAT_TYPE_PRIVATE)]
#endif // __midl

        OBJECTID m_oPrivateID;

#ifdef __midl
        [case(QUEUE_FORMAT_TYPE_DIRECT)]
#endif // __midl

        LPWSTR m_pDirectID;

#ifdef __midl
        [case(QUEUE_FORMAT_TYPE_MACHINE)]
#endif // __midl

        GUID m_gMachineID;

#ifdef __midl
        [case(QUEUE_FORMAT_TYPE_CONNECTOR)]
#endif // __midl

        GUID m_gConnectorID;

#ifdef __midl
        [case(QUEUE_FORMAT_TYPE_DL)]
#endif // __midl

        //
        // We must use a struct to pack multiple fields since we're
        // inside a union.
        //
        DL_ID m_DlID;

#ifdef __midl
        [case(QUEUE_FORMAT_TYPE_MULTICAST)]
#endif // __midl

        MULTICAST_ID m_MulticastID;
    };
};

#ifndef __midl
const size_t xSizeOfQueueFormat32 = 24;
#ifndef _WIN64
C_ASSERT(sizeof(QUEUE_FORMAT) == xSizeOfQueueFormat32);
#endif
#endif

#ifdef _WIN64
#ifndef __midl
//---------------------------------------------------------
//
//  struct QUEUE_FORMAT_32
//  
//  Contains the data of queue format as it is in 32 bit apps
//  since it is part of AC driver which can accept an ioctl
//  from 32 bit rt that uses this struct
//
//---------------------------------------------------------
#pragma pack(push, 4)
struct QUEUE_FORMAT_32 {
    UCHAR m_qft;
    UCHAR m_SuffixAndFlags;
    USHORT m_reserved; 
    union {
        GUID m_gPublicID;
        OBJECTID m_oPrivateID;
        WCHAR * POINTER_32 m_pDirectID;
        GUID m_gMachineID;
        GUID m_gConnectorID;
        DL_ID_32 m_DlID32;
        MULTICAST_ID m_MulticastID;
    };
};

C_ASSERT(sizeof(QUEUE_FORMAT_32) == xSizeOfQueueFormat32);

#pragma pack(pop)
#endif //!__midl
#endif //_WIN64

#ifdef __midl
cpp_quote("#endif // _QUEUE_FORMAT_DEFINED")
cpp_quote("#endif // __cplusplus")
#endif // __midl

#endif // _QUEUE_FORMAT_DEFINED


#ifdef __cplusplus

inline bool QUEUE_FORMAT::Legal() const
{
    switch(Suffix())
    {
        case QUEUE_SUFFIX_TYPE_NONE:
            return (!IsSystemQueue());

        case QUEUE_SUFFIX_TYPE_JOURNAL:
            return ((m_qft != QUEUE_FORMAT_TYPE_CONNECTOR)
                    &&
                    (m_qft != QUEUE_FORMAT_TYPE_DL)
                    &&
                    (m_qft != QUEUE_FORMAT_TYPE_MULTICAST));

        case QUEUE_SUFFIX_TYPE_DEADLETTER:
        case QUEUE_SUFFIX_TYPE_DEADXACT:
            return (IsSystemQueue());

        case QUEUE_SUFFIX_TYPE_XACTONLY:
            return (m_qft == QUEUE_FORMAT_TYPE_CONNECTOR);
    }
    return false;
}


inline bool QUEUE_FORMAT::IsValid() const
{
    if(m_qft > QUEUE_FORMAT_TYPE_MULTICAST)
        return false;

    if(Suffix() > QUEUE_SUFFIX_TYPE_XACTONLY)
        return false;

    if(m_qft == QUEUE_FORMAT_TYPE_UNKNOWN)
        return false;

    if((m_qft == QUEUE_FORMAT_TYPE_DIRECT) && (DirectID() == NULL))
        return false;

    return Legal();
}


inline QUEUE_FORMAT_TYPE QUEUE_FORMAT::GetType() const
{
    return ((QUEUE_FORMAT_TYPE)m_qft);
}

inline QUEUE_SUFFIX_TYPE QUEUE_FORMAT::Suffix() const
{
    return ((QUEUE_SUFFIX_TYPE)(m_SuffixAndFlags & QUEUE_FORMAT_SUFFIX_MASK));
}

inline void QUEUE_FORMAT::Suffix(QUEUE_SUFFIX_TYPE qst)
{
    m_SuffixAndFlags &= ~QUEUE_FORMAT_SUFFIX_MASK;
    m_SuffixAndFlags |= static_cast<UCHAR>(qst);
}

inline void QUEUE_FORMAT::UnknownID(PVOID)
{
    m_qft = QUEUE_FORMAT_TYPE_UNKNOWN;
    m_SuffixAndFlags = QUEUE_SUFFIX_TYPE_NONE; // Flags = 0
}

inline QUEUE_FORMAT::QUEUE_FORMAT()
{
    UnknownID(0);
    m_pDirectID = NULL;

    //
    // a bunch of C_ASSERTS here to make sure alignment of struct members is what we
    // expect it to be.
    // it is here inside a class function just because struct members are private
    //
#ifdef _WIN64
    C_ASSERT(FIELD_OFFSET(QUEUE_FORMAT, m_qft)            == 0);
    C_ASSERT(FIELD_OFFSET(QUEUE_FORMAT, m_SuffixAndFlags) == 1);
    C_ASSERT(FIELD_OFFSET(QUEUE_FORMAT, m_reserved)       == 2);
    C_ASSERT(FIELD_OFFSET(QUEUE_FORMAT, m_gPublicID)      == 8);
    C_ASSERT(FIELD_OFFSET(QUEUE_FORMAT, m_oPrivateID)     == 8);
    C_ASSERT(FIELD_OFFSET(QUEUE_FORMAT, m_pDirectID)      == 8);
    C_ASSERT(FIELD_OFFSET(QUEUE_FORMAT, m_gConnectorID)   == 8);
    C_ASSERT(FIELD_OFFSET(QUEUE_FORMAT, m_DlID)           == 8);
    C_ASSERT(FIELD_OFFSET(QUEUE_FORMAT, m_MulticastID)    == 8);

    //
    // The C_ASSERTs below ensure that the 64 bit driver can accept
    // QUEUE_FORMAT comming from 32 bit application
    //
    C_ASSERT(FIELD_OFFSET(QUEUE_FORMAT_32, m_qft)            == 0);
    C_ASSERT(FIELD_OFFSET(QUEUE_FORMAT_32, m_SuffixAndFlags) == 1);
    C_ASSERT(FIELD_OFFSET(QUEUE_FORMAT_32, m_reserved)       == 2);
    C_ASSERT(FIELD_OFFSET(QUEUE_FORMAT_32, m_gPublicID)      == 4);
    C_ASSERT(FIELD_OFFSET(QUEUE_FORMAT_32, m_oPrivateID)     == 4);
    C_ASSERT(FIELD_OFFSET(QUEUE_FORMAT_32, m_pDirectID)      == 4);
    C_ASSERT(FIELD_OFFSET(QUEUE_FORMAT_32, m_gConnectorID)   == 4);
    C_ASSERT(FIELD_OFFSET(QUEUE_FORMAT_32, m_DlID32)         == 4);
    C_ASSERT(FIELD_OFFSET(QUEUE_FORMAT_32, m_MulticastID)    == 4);
#else //!_WIN64
    C_ASSERT(FIELD_OFFSET(QUEUE_FORMAT, m_qft)            == 0);
    C_ASSERT(FIELD_OFFSET(QUEUE_FORMAT, m_SuffixAndFlags) == 1);
    C_ASSERT(FIELD_OFFSET(QUEUE_FORMAT, m_reserved)       == 2);
    C_ASSERT(FIELD_OFFSET(QUEUE_FORMAT, m_gPublicID)      == 4);
    C_ASSERT(FIELD_OFFSET(QUEUE_FORMAT, m_oPrivateID)     == 4);
    C_ASSERT(FIELD_OFFSET(QUEUE_FORMAT, m_pDirectID)      == 4);
    C_ASSERT(FIELD_OFFSET(QUEUE_FORMAT, m_gConnectorID)   == 4);
    C_ASSERT(FIELD_OFFSET(QUEUE_FORMAT, m_DlID)           == 4);
    C_ASSERT(FIELD_OFFSET(QUEUE_FORMAT, m_MulticastID)    == 4);
#endif //_WIN64
}

inline void QUEUE_FORMAT::PublicID(const GUID& gPublicID)
{
    m_qft = QUEUE_FORMAT_TYPE_PUBLIC;
    m_SuffixAndFlags = QUEUE_SUFFIX_TYPE_NONE; // Flags = 0
    m_gPublicID = gPublicID;
}

inline QUEUE_FORMAT::QUEUE_FORMAT(const GUID& gPublicID)
{
    PublicID(gPublicID);
}

inline const GUID& QUEUE_FORMAT::PublicID() const
{
    ASSERT(GetType() == QUEUE_FORMAT_TYPE_PUBLIC);
    return m_gPublicID;
}

inline void QUEUE_FORMAT::DlID(const DL_ID& DlID)
{
    m_qft = QUEUE_FORMAT_TYPE_DL;
    m_SuffixAndFlags = QUEUE_SUFFIX_TYPE_NONE; // Flags = 0
    m_DlID = DlID;
}

inline QUEUE_FORMAT::QUEUE_FORMAT(const DL_ID& id)
{
    DlID(id);
}

inline const DL_ID& QUEUE_FORMAT::DlID() const
{
    ASSERT(GetType() == QUEUE_FORMAT_TYPE_DL);
    return m_DlID;
}

inline void QUEUE_FORMAT::PrivateID(const GUID& Lineage, ULONG Uniquifier)
{
    m_qft = QUEUE_FORMAT_TYPE_PRIVATE;
    m_SuffixAndFlags = QUEUE_SUFFIX_TYPE_NONE; // Flags = 0
    m_oPrivateID.Lineage = Lineage;
    m_oPrivateID.Uniquifier = Uniquifier;
    ASSERT(Uniquifier != 0);
}

inline QUEUE_FORMAT::QUEUE_FORMAT(const GUID& Lineage, ULONG Uniquifier)
{
    PrivateID(Lineage, Uniquifier);
}

inline void QUEUE_FORMAT::PrivateID(const OBJECTID& oPrivateID)
{
    PrivateID(oPrivateID.Lineage, oPrivateID.Uniquifier);
}

inline QUEUE_FORMAT::QUEUE_FORMAT(const OBJECTID& oPrivateID)
{
    PrivateID(oPrivateID);
}

inline const OBJECTID& QUEUE_FORMAT::PrivateID() const
{
    ASSERT(GetType() == QUEUE_FORMAT_TYPE_PRIVATE);
    return m_oPrivateID;
}

inline void QUEUE_FORMAT::DirectID(LPWSTR pDirectID, UCHAR flags)
{
    ASSERT((flags & QUEUE_FORMAT_SUFFIX_MASK) == 0);
    ASSERT(("Invalid direct format name", pDirectID != NULL));

    m_qft = QUEUE_FORMAT_TYPE_DIRECT;
    m_SuffixAndFlags = static_cast<UCHAR>(((UCHAR)QUEUE_SUFFIX_TYPE_NONE) | flags);
    m_pDirectID = pDirectID;
}

inline void QUEUE_FORMAT::DirectID(LPWSTR pDirectID)
{
    DirectID(pDirectID, 0);
}

inline QUEUE_FORMAT::QUEUE_FORMAT(LPWSTR pDirectID)
{
    DirectID(pDirectID);
}

inline LPCWSTR QUEUE_FORMAT::DirectID() const
{
    ASSERT(GetType() == QUEUE_FORMAT_TYPE_DIRECT);
    return m_pDirectID;
}

inline void QUEUE_FORMAT::MachineID(const GUID& gMachineID)
{
    m_qft = QUEUE_FORMAT_TYPE_MACHINE;
    m_SuffixAndFlags = QUEUE_SUFFIX_TYPE_DEADLETTER; // Flags = 0
    m_gMachineID = gMachineID;
}

inline QUEUE_FORMAT::QUEUE_FORMAT(PVOID, const GUID& gMachineID)
{
    MachineID(gMachineID);
}

inline const GUID& QUEUE_FORMAT::MachineID() const
{
    ASSERT(GetType() == QUEUE_FORMAT_TYPE_MACHINE);
    return m_gMachineID;
}

inline void QUEUE_FORMAT::ConnectorID(const GUID& gConnectorID)
{
    m_qft = QUEUE_FORMAT_TYPE_CONNECTOR;
    m_SuffixAndFlags = QUEUE_SUFFIX_TYPE_NONE; // Flags = 0
    m_gConnectorID = gConnectorID;
}

inline const GUID& QUEUE_FORMAT::ConnectorID() const
{
    ASSERT(GetType() == QUEUE_FORMAT_TYPE_CONNECTOR);
    return m_gConnectorID;
}

inline void QUEUE_FORMAT::MulticastID(const MULTICAST_ID& MulticastID)
{
    m_qft = QUEUE_FORMAT_TYPE_MULTICAST;
    m_SuffixAndFlags = QUEUE_SUFFIX_TYPE_NONE; // Flags = 0
    m_MulticastID = MulticastID;
}

inline QUEUE_FORMAT::QUEUE_FORMAT(const MULTICAST_ID& id)
{
    MulticastID(id);
}

inline const MULTICAST_ID& QUEUE_FORMAT::MulticastID() const
{
    ASSERT(GetType() == QUEUE_FORMAT_TYPE_MULTICAST);
    return m_MulticastID;
}


inline void QUEUE_FORMAT::DisposeString()
{
    switch (GetType())
    {
        case QUEUE_FORMAT_TYPE_DIRECT:
            delete [] m_pDirectID;
            m_pDirectID = NULL;
            break;

        case QUEUE_FORMAT_TYPE_DL:
            delete [] m_DlID.m_pwzDomain;
            m_DlID.m_pwzDomain = NULL;
            break;

        default:
            NULL;
            break;
    }
}

inline bool QUEUE_FORMAT::IsSystemQueue() const
{
    return ((GetType() == QUEUE_FORMAT_TYPE_MACHINE) || ((m_SuffixAndFlags & QUEUE_FORMAT_FLAG_SYSTEM) != 0));
}

#ifdef _WIN64
inline void QUEUE_FORMAT::InitFromQueueFormat32(const struct QUEUE_FORMAT_32 * pqft32)
//
// initialize from a QUEUE_FORMAT_32 (32 bit ptrs)
//
{
    m_qft = pqft32->m_qft; 
    m_SuffixAndFlags = pqft32->m_SuffixAndFlags;
    m_reserved = pqft32->m_reserved;

    switch (pqft32->m_qft)
    {
    case QUEUE_FORMAT_TYPE_UNKNOWN:
       //
       // Like in an UnknownID call
       //
       ASSERT(pqft32->m_pDirectID == NULL);
       m_pDirectID = pqft32->m_pDirectID;
       break;

    case QUEUE_FORMAT_TYPE_PUBLIC:
       m_gPublicID = pqft32->m_gPublicID;
       break;

    case QUEUE_FORMAT_TYPE_DL:
       m_DlID.m_DlGuid = pqft32->m_DlID32.m_DlGuid;
       m_DlID.m_pwzDomain = pqft32->m_DlID32.m_pwzDomain;
       break;

    case QUEUE_FORMAT_TYPE_PRIVATE:
       m_oPrivateID = pqft32->m_oPrivateID;
       break;

    case QUEUE_FORMAT_TYPE_DIRECT:
       m_pDirectID = pqft32->m_pDirectID;
       break;

    case QUEUE_FORMAT_TYPE_MACHINE:
       m_gMachineID = pqft32->m_gMachineID;
       break;

    case QUEUE_FORMAT_TYPE_CONNECTOR:
       m_gConnectorID = pqft32->m_gConnectorID;
       break;

    case QUEUE_FORMAT_TYPE_MULTICAST:
        m_MulticastID = pqft32->m_MulticastID;
        break;

    default:
       //
       // ASSERT(0) for warning level 4
       //
       ASSERT(pqft32->m_qft == QUEUE_FORMAT_TYPE_DIRECT);
       break;
    }    
}

#endif //_WIN64    


#endif // __cplusplus

#endif // __QFORMAT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\rtcert.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    rtcert.h

Abstract:

    Non public certificate-related functions that are exported from MQRT.DLL

--*/


#pragma once

#ifndef _RT_CERT_H_
#define _RT_CERT_H_

#include "mqcert.h"

#ifdef __cplusplus
extern "C"
{
#endif

HRESULT
APIENTRY
RTCreateInternalCertificate(
    OUT CMQSigCertificate **ppCert
    );

HRESULT
APIENTRY
RTDeleteInternalCert(
    IN CMQSigCertificate *pCert
    );

HRESULT
APIENTRY
RTOpenInternalCertStore(
    OUT CMQSigCertStore **pStore,
    IN LONG              *pnCerts,
    IN BOOL               fWriteAccess,
    IN BOOL               fMachine,
    IN HKEY               hKeyUser
    );

HRESULT
APIENTRY
RTGetInternalCert(
    OUT CMQSigCertificate **ppCert,
    OUT CMQSigCertStore   **ppStore,
    IN  BOOL              fGetForDelete,
    IN  BOOL              fMachine,
    IN  HKEY              hKeyUser
    );

 //
 // if fGetForDelete is TRUE then the certificates store is open with write
 // access. Otherwise the store is opened in read-only mode.
 //

HRESULT
APIENTRY
RTRegisterUserCert(
    IN CMQSigCertificate *pCert,
    IN BOOL               fMachine
    );

HRESULT
APIENTRY
RTGetUserCerts(
    CMQSigCertificate **ppCert,
    DWORD              *pnCerts,
    PSID                pSidIn
    );

HRESULT
APIENTRY
RTRemoveUserCert(
    IN CMQSigCertificate *pCert
    );

#ifdef __cplusplus
}
#endif

#endif // _RT_CERT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\rt.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    rt.h

Abstract:
    Message Queuing Header File

--*/

#ifndef __RT_H
#define __RT_H

#include <mqtypes.h>
#include <mqsymbls.h>
#include <mqprops.h>
#include <_mqdef.h>
#include <transact.h>

//  begin_mq_h

#ifdef __cplusplus
extern "C"
{
#endif

//********************************************************************
//  RECEIVE CALLBACK
//********************************************************************

typedef
VOID
(APIENTRY *PMQRECEIVECALLBACK)(
    HRESULT hrStatus,
    QUEUEHANDLE hSource,
    DWORD dwTimeout,
    DWORD dwAction,
    MQMSGPROPS* pMessageProps,
    LPOVERLAPPED lpOverlapped,
    HANDLE hCursor
    );


//********************************************************************
// MSMQ API
//********************************************************************

HRESULT
APIENTRY
MQCreateQueue(
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN OUT MQQUEUEPROPS* pQueueProps,
    OUT LPWSTR lpwcsFormatName,
    IN OUT LPDWORD lpdwFormatNameLength
    );

HRESULT
APIENTRY
MQDeleteQueue(
    IN LPCWSTR lpwcsFormatName
    );

HRESULT
APIENTRY
MQLocateBegin(
    IN LPCWSTR lpwcsContext,
    IN MQRESTRICTION* pRestriction,
    IN MQCOLUMNSET* pColumns,
    IN MQSORTSET* pSort,
    OUT PHANDLE phEnum
    );

HRESULT
APIENTRY
MQLocateNext(
    IN HANDLE hEnum,
    IN OUT DWORD* pcProps,
    OUT MQPROPVARIANT aPropVar[]
    );

HRESULT
APIENTRY
MQLocateEnd(
    IN HANDLE hEnum
    );

HRESULT
APIENTRY
MQOpenQueue(
    IN LPCWSTR lpwcsFormatName,
    IN DWORD dwAccess,
    IN DWORD dwShareMode,
    OUT QUEUEHANDLE* phQueue
    );

HRESULT
APIENTRY
MQSendMessage(
    IN QUEUEHANDLE hDestinationQueue,
    IN MQMSGPROPS* pMessageProps,
    IN ITransaction *pTransaction
    );

HRESULT
APIENTRY
MQReceiveMessage(
    IN QUEUEHANDLE hSource,
    IN DWORD dwTimeout,
    IN DWORD dwAction,
    IN OUT MQMSGPROPS* pMessageProps,
    IN OUT LPOVERLAPPED lpOverlapped,
    IN PMQRECEIVECALLBACK fnReceiveCallback,
    IN HANDLE hCursor,
    IN ITransaction* pTransaction
    );

HRESULT
APIENTRY
MQReceiveMessageByLookupId(
    IN QUEUEHANDLE hSource,
    IN ULONGLONG ullLookupId,
    IN DWORD dwLookupAction,
    IN OUT MQMSGPROPS* pMessageProps,
    IN OUT LPOVERLAPPED lpOverlapped,
    IN PMQRECEIVECALLBACK fnReceiveCallback,
    IN ITransaction *pTransaction
    );

HRESULT
APIENTRY
MQCreateCursor(
    IN QUEUEHANDLE hQueue,
    OUT PHANDLE phCursor
    );

HRESULT
APIENTRY
MQCloseCursor(
    IN HANDLE hCursor
    );

HRESULT
APIENTRY
MQCloseQueue(
    IN QUEUEHANDLE hQueue
    );

HRESULT
APIENTRY
MQSetQueueProperties(
    IN LPCWSTR lpwcsFormatName,
    IN MQQUEUEPROPS* pQueueProps
    );

HRESULT
APIENTRY
MQGetQueueProperties(
    IN LPCWSTR lpwcsFormatName,
    OUT MQQUEUEPROPS* pQueueProps
    );

HRESULT
APIENTRY
MQGetQueueSecurity(
    IN LPCWSTR lpwcsFormatName,
    IN SECURITY_INFORMATION RequestedInformation,
    OUT PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN DWORD nLength,
    OUT LPDWORD lpnLengthNeeded
    );

HRESULT
APIENTRY
MQSetQueueSecurity(
    IN LPCWSTR lpwcsFormatName,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    );

HRESULT
APIENTRY
MQPathNameToFormatName(
    IN LPCWSTR lpwcsPathName,
    OUT LPWSTR lpwcsFormatName,
    IN OUT LPDWORD lpdwFormatNameLength
    );

HRESULT
APIENTRY
MQHandleToFormatName(
    IN QUEUEHANDLE hQueue,
    OUT LPWSTR lpwcsFormatName,
    IN OUT LPDWORD lpdwFormatNameLength
    );

HRESULT
APIENTRY
MQInstanceToFormatName(
    IN GUID* pGuid,
    OUT LPWSTR lpwcsFormatName,
    IN OUT LPDWORD lpdwFormatNameLength
    );

HRESULT
APIENTRY
MQADsPathToFormatName(
    IN LPCWSTR lpwcsADsPath,
    OUT LPWSTR lpwcsFormatName,
    IN OUT LPDWORD lpdwFormatNameLength
    );

VOID
APIENTRY
MQFreeMemory(
    IN PVOID pvMemory
    );

// end_mq_h

PVOID
APIENTRY
MQAllocateMemory(
    IN  DWORD size
    );

//  begin_mq_h

HRESULT
APIENTRY
MQGetMachineProperties(
    IN LPCWSTR lpwcsMachineName,
    IN const GUID* pguidMachineId,
    IN OUT MQQMPROPS* pQMProps
    );

HRESULT
APIENTRY
MQGetSecurityContext(
    IN PVOID lpCertBuffer,
    IN DWORD dwCertBufferLength,
    OUT HANDLE* phSecurityContext
    );

HRESULT
APIENTRY
MQGetSecurityContextEx(
    IN PVOID lpCertBuffer,
    IN DWORD dwCertBufferLength,
    OUT HANDLE* phSecurityContext
    );

VOID
APIENTRY
MQFreeSecurityContext(
    IN HANDLE hSecurityContext
    );

HRESULT
APIENTRY
MQRegisterCertificate(
    IN DWORD dwFlags,
    IN PVOID lpCertBuffer,
    IN DWORD dwCertBufferLength
    );

HRESULT
APIENTRY
MQBeginTransaction(
    OUT ITransaction **ppTransaction
    );

HRESULT
APIENTRY
MQGetOverlappedResult(
    IN LPOVERLAPPED lpOverlapped
    );

HRESULT
APIENTRY
MQGetPrivateComputerInformation(
    IN LPCWSTR lpwcsComputerName,
    IN OUT MQPRIVATEPROPS* pPrivateProps
    );

HRESULT
APIENTRY
MQPurgeQueue(
    IN QUEUEHANDLE hQueue
    );

HRESULT
APIENTRY
MQMgmtGetInfo(
    IN LPCWSTR pComputerName,
    IN LPCWSTR pObjectName,
    IN OUT MQMGMTPROPS* pMgmtProps
    );

HRESULT
APIENTRY
MQMgmtAction(
    IN LPCWSTR pComputerName,
    IN LPCWSTR pObjectName,
    IN LPCWSTR pAction
    );

#ifdef __cplusplus
}
#endif
// end_mq_h

#endif // __RT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\testlog.h ===
//////////////////////////////////////
//Testlog.h
//
//
//
//////////////////////////////////////
#ifndef _TESTLOG
#define _TESTLOG

#ifdef _DEBUG
extern void TA2StringAddr(IN const TA_ADDRESS *pa, OUT LPTSTR pString);

typedef void (APIENTRY * DbgPrintLogForTest_ROUTINE)(TCHAR *pszBuf, ...);

extern DbgPrintLogForTest_ROUTINE g_pfDbgLogForTest;

#define DbgPrintLogForTest(data)		\
	if (g_pfDbgLogForTest) {			\
		g_pfDbgLogForTest data;			\
	}

#define DBG_CONVERT_STRARR_TO_STRING(nNum,arSrcStr,szDestStr)	\
	if (g_pfDbgLogForTest) {									\
		wcscpy (szDestStr, arSrcStr[0]);						\
		for (DWORD i=1; i<nNum; i++) {							\
			wcscat (szDestStr, TEXT(";"));						\
			wcscat (szDestStr, arSrcStr[i]);					\
		}														\
	}

#define DBG_CONVERT_ARRMACHINE_TO_STRING(nNum,arMachine,szDestStr)	\
	if (g_pfDbgLogForTest) {									    \
		wcscpy (szDestStr, arMachine[0].GetPath());			        \
		for (DWORD i=1; i<nNum; i++) {							    \
			wcscat (szDestStr, TEXT(";"));						    \
			wcscat (szDestStr, arMachine[i].GetPath());				\
		}														    \
	}

#define DBG_GET_ADDRESS_FROM_SESSION(hr, ppSession, szStr)			\
	if (g_pfDbgLogForTest) {										\
		if (SUCCEEDED(hr)) {										\
			if (*ppSession) {										\
				wcscpy(szStr, ((CSockTransport*)*ppSession)->GetStrAddr());	\
			}														\
			else {													\
				wcscpy (szStr, TEXT("Session is null"));			\
			}														\
		}															\
		else {														\
			wcscpy (szStr, TEXT("No session"));						\
		}															\
	}

#define MAX_NAME_LENGTH	256
#else
#define DbgPrintLogForTest(data)
#define DBG_CONVERT_STRARR_TO_STRING(nNum,arSrcStr,szDestStr)
#define DBG_CONVERT_ADDRARR_TO_STRING(nNum,arSrcAddr,szDestStr)	
#define DBG_GET_ADDRESS_FROM_SESSION(hr, ppSession, szStr)		
#endif //_DEBUG

#endif //_TESTLOG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\seccom.h ===
/************************************************************************
*                                                                       *
*   winerror.h --  error code definitions for the Win32 API functions   *
*                                                                       *
*   Copyright (c) 1991-1996, Microsoft Corp. All rights reserved.       *
*                                                                       *
************************************************************************/

#ifndef _SECURECOM_ERROR_
#define _SECURECOM_ERROR_


//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//

//
// MessageId: DIGSIG_E_ENCODE
//
// MessageText:
//
//  Error due to problem in ASN.1 encoding process.
//
#define DIGSIG_E_ENCODE                  _HRESULT_TYPEDEF_(0x800B0005L)

//
// MessageId: DIGSIG_E_DECODE
//
// MessageText:
//
//  Error due to problem in ASN.1 decoding process.
//
#define DIGSIG_E_DECODE                  _HRESULT_TYPEDEF_(0x800B0006L)

//
// MessageId: DIGSIG_E_EXTENSIBILITY
//
// MessageText:
//
//  Reading / writing Extensions where Attributes are appropriate, and visa versa.
//
#define DIGSIG_E_EXTENSIBILITY           _HRESULT_TYPEDEF_(0x800B0007L)

//
// MessageId: DIGSIG_E_CRYPTO
//
// MessageText:
//
//  Unspecified cryptographic failure.
//
#define DIGSIG_E_CRYPTO                  _HRESULT_TYPEDEF_(0x800B0008L)

//
// MessageId: PERSIST_E_SIZEDEFINITE
//
// MessageText:
//
//  The size of the data could not be determined.
//
#define PERSIST_E_SIZEDEFINITE           _HRESULT_TYPEDEF_(0x800B0009L)

//
// MessageId: PERSIST_E_SIZEINDEFINITE
//
// MessageText:
//
//  The size of the indefinite-sized data could not be determined.
//
#define PERSIST_E_SIZEINDEFINITE         _HRESULT_TYPEDEF_(0x800B000AL)

//
// MessageId: PERSIST_E_NOTSELFSIZING
//
// MessageText:
//
//  This object does not read and write self-sizing data.
//
#define PERSIST_E_NOTSELFSIZING          _HRESULT_TYPEDEF_(0x800B000BL)

//
// MessageId: TRUST_E_NOSIGNATURE
//
// MessageText:
//
//  No signature was present in the subject.
//
#define TRUST_E_NOSIGNATURE              _HRESULT_TYPEDEF_(0x800B0100L)

//
// MessageId: CERT_E_EXPIRED
//
// MessageText:
//
//  A required certificate is not within its validity period.
//
#define CERT_E_EXPIRED                   _HRESULT_TYPEDEF_(0x800B0101L)

//
// MessageId: CERT_E_VALIDIYPERIODNESTING
//
// MessageText:
//
//  The validity periods of the certification chain do not nest correctly.
//
#define CERT_E_VALIDIYPERIODNESTING      _HRESULT_TYPEDEF_(0x800B0102L)

//
// MessageId: CERT_E_ROLE
//
// MessageText:
//
//  A certificate that can only be used as an end-entity is being used as a CA or visa versa.
//
#define CERT_E_ROLE                      _HRESULT_TYPEDEF_(0x800B0103L)

//
// MessageId: CERT_E_PATHLENCONST
//
// MessageText:
//
//  A path length constraint in the certification chain has been violated.
//
#define CERT_E_PATHLENCONST              _HRESULT_TYPEDEF_(0x800B0104L)

//
// MessageId: CERT_E_CRITICAL
//
// MessageText:
//
//  An extension of unknown type that is labeled 'critical' is present in a certificate.
//
#define CERT_E_CRITICAL                  _HRESULT_TYPEDEF_(0x800B0105L)

//
// MessageId: CERT_E_PURPOSE
//
// MessageText:
//
//  A certificate is being used for a purpose other than that for which it is permitted.
//
#define CERT_E_PURPOSE                   _HRESULT_TYPEDEF_(0x800B0106L)

//
// MessageId: CERT_E_ISSUERCHAINING
//
// MessageText:
//
//  A parent of a given certificate in fact did not issue that child certificate.
//
#define CERT_E_ISSUERCHAINING            _HRESULT_TYPEDEF_(0x800B0107L)

//
// MessageId: CERT_E_MALFORMED
//
// MessageText:
//
//  A certificate is missing or has an empty value for an important field, such as a subject or issuer name.
//
#define CERT_E_MALFORMED                 _HRESULT_TYPEDEF_(0x800B0108L)

//
// MessageId: CERT_E_UNTRUSTEDROOT
//
// MessageText:
//
//  A certification chain processed correctly, but terminated in a root certificate which isn't trusted by the trust provider.
//
#define CERT_E_UNTRUSTEDROOT             _HRESULT_TYPEDEF_(0x800B0109L)

//
// MessageId: CERT_E_CHAINING
//
// MessageText:
//
//  A chain of certs didn't chain as they should in a certain application of chaining.
//
#define CERT_E_CHAINING                  _HRESULT_TYPEDEF_(0x800B010AL)

#endif // _SECURECOM__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\rtdep.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    rt.h

Abstract:
    Message Queuing Header File

Note: [ConradC]
    We have implemented delayload failure handling code for MQRTDEP.DLL and the stub code is currently resides in lib\dld\lib\rtdep.cpp. If you add more export functions to mqrtdep.dll, you also need to create the corresponding stub code and update the map.
    

--*/

#ifndef __RTDEP_H
#define __RTDEP_H

#include <mqtypes.h>
#include <mqsymbls.h>
#include <mqprops.h>
#include <_mqdef.h>
#include <transact.h>

#ifdef __cplusplus
extern "C"
{
#endif

//********************************************************************
//  RECEIVE CALLBACK
//********************************************************************

typedef
VOID
(APIENTRY *PMQRECEIVECALLBACK)(
    HRESULT hrStatus,
    QUEUEHANDLE hSource,
    DWORD dwTimeout,
    DWORD dwAction,
    MQMSGPROPS* pMessageProps,
    LPOVERLAPPED lpOverlapped,
    HANDLE hCursor
    );


//********************************************************************
// MSMQ API
//********************************************************************

HRESULT
APIENTRY
DepCreateQueue(
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN OUT MQQUEUEPROPS* pQueueProps,
    OUT LPWSTR lpwcsFormatName,
    IN OUT LPDWORD lpdwFormatNameLength
    );

HRESULT
APIENTRY
DepDeleteQueue(
    IN LPCWSTR lpwcsFormatName
    );

HRESULT
APIENTRY
DepLocateBegin(
    IN LPCWSTR lpwcsContext,
    IN MQRESTRICTION* pRestriction,
    IN MQCOLUMNSET* pColumns,
    IN MQSORTSET* pSort,
    OUT PHANDLE phEnum
    );

HRESULT
APIENTRY
DepLocateNext(
    IN HANDLE hEnum,
    IN OUT DWORD* pcProps,
    OUT MQPROPVARIANT aPropVar[]
    );

HRESULT
APIENTRY
DepLocateEnd(
    IN HANDLE hEnum
    );

HRESULT
APIENTRY
DepOpenQueue(
    IN LPCWSTR lpwcsFormatName,
    IN DWORD dwAccess,
    IN DWORD dwShareMode,
    OUT QUEUEHANDLE* phQueue
    );

HRESULT
APIENTRY
DepSendMessage(
    IN QUEUEHANDLE hDestinationQueue,
    IN MQMSGPROPS* pMessageProps,
    IN ITransaction *pTransaction
    );

HRESULT
APIENTRY
DepReceiveMessage(
    IN QUEUEHANDLE hSource,
    IN DWORD dwTimeout,
    IN DWORD dwAction,
    IN OUT MQMSGPROPS* pMessageProps,
    IN OUT LPOVERLAPPED lpOverlapped,
    IN PMQRECEIVECALLBACK fnReceiveCallback,
    IN HANDLE hCursor,
    IN ITransaction* pTransaction
    );

HRESULT
APIENTRY
DepCreateCursor(
    IN QUEUEHANDLE hQueue,
    OUT PHANDLE phCursor
    );

HRESULT
APIENTRY
DepCloseCursor(
    IN HANDLE hCursor
    );

HRESULT
APIENTRY
DepCloseQueue(
    IN HANDLE hQueue
    );

HRESULT
APIENTRY
DepSetQueueProperties(
    IN LPCWSTR lpwcsFormatName,
    IN MQQUEUEPROPS* pQueueProps
    );

HRESULT
APIENTRY
DepGetQueueProperties(
    IN LPCWSTR lpwcsFormatName,
    OUT MQQUEUEPROPS* pQueueProps
    );

HRESULT
APIENTRY
DepGetQueueSecurity(
    IN LPCWSTR lpwcsFormatName,
    IN SECURITY_INFORMATION RequestedInformation,
    OUT PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN DWORD nLength,
    OUT LPDWORD lpnLengthNeeded
    );

HRESULT
APIENTRY
DepSetQueueSecurity(
    IN LPCWSTR lpwcsFormatName,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    );

HRESULT
APIENTRY
DepPathNameToFormatName(
    IN LPCWSTR lpwcsPathName,
    OUT LPWSTR lpwcsFormatName,
    IN OUT LPDWORD lpdwFormatNameLength
    );

HRESULT
APIENTRY
DepHandleToFormatName(
    IN QUEUEHANDLE hQueue,
    OUT LPWSTR lpwcsFormatName,
    IN OUT LPDWORD lpdwFormatNameLength
    );

HRESULT
APIENTRY
DepInstanceToFormatName(
    IN GUID* pGuid,
    OUT LPWSTR lpwcsFormatName,
    IN OUT LPDWORD lpdwFormatNameLength
    );

void
APIENTRY
DepFreeMemory(
    IN PVOID pvMemory
    );

HRESULT
APIENTRY
DepGetMachineProperties(
    IN LPCWSTR lpwcsMachineName,
    IN const GUID* pguidMachineId,
    IN OUT MQQMPROPS* pQMProps
    );

HRESULT
APIENTRY
DepGetSecurityContext(
    IN PVOID lpCertBuffer,
    IN DWORD dwCertBufferLength,
    OUT HANDLE* hSecurityContext
    );

HRESULT 
APIENTRY
DepGetSecurityContextEx( 
	LPVOID  lpCertBuffer,
    DWORD   dwCertBufferLength,
    HANDLE *hSecurityContext 
	);

void
APIENTRY
DepFreeSecurityContext(
    IN HANDLE hSecurityContext
    );

HRESULT
APIENTRY
DepRegisterCertificate(
    IN DWORD   dwFlags,
    IN PVOID   lpCertBuffer,
    IN DWORD   dwCertBufferLength
    );

HRESULT
APIENTRY
DepBeginTransaction(
    OUT ITransaction **ppTransaction
    );

HRESULT
APIENTRY
DepGetOverlappedResult(
    IN LPOVERLAPPED lpOverlapped
    );

HRESULT
APIENTRY
DepGetPrivateComputerInformation(
    IN LPCWSTR lpwcsComputerName,
    IN OUT MQPRIVATEPROPS* pPrivateProps
    );


HRESULT
APIENTRY
DepPurgeQueue(
    IN HANDLE hQueue
    );

HRESULT
APIENTRY
DepMgmtGetInfo(
    IN LPCWSTR pMachineName,
    IN LPCWSTR pObjectName,
    IN OUT MQMGMTPROPS* pMgmtProps
    );

HRESULT
APIENTRY
DepMgmtAction(
    IN LPCWSTR pMachineName,
    IN LPCWSTR pObjectName,
    IN LPCWSTR pAction
    );

#ifdef __cplusplus
}
#endif

#endif // __RTDEP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\version.h ===
#define rmj         5				 	
#define rmm         1					
#define rup       1033				
#define szVerName ""					
#define szVerUser ""
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\qmpkt.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    qmpkt.h

Abstract:

    Handle packet in QM side

Author:

    Uri Habusha  (urih)


--*/

#ifndef __QM_PACKET__
#define __QM_PACKET__

#include <time.h>

#include <qformat.h>
#include <qmrt.h>
#include <ph.h>
#include <phintr.h>
#include <phinfo.h>
#include <mqtime.h>

//
// CQmPacket Class
//
class CQmPacket{
    public:
        CQmPacket(
			CBaseHeader *pPkt,
			CPacket *pDriverPkt,
			bool ValidityCheck = false
			);

        inline CBaseHeader *GetPointerToPacket(void) const;
        inline UCHAR *GetPointerToUserHeader(void) const;
        inline UCHAR *GetPointerToSecurHeader(void) const;
		inline UCHAR* GetPointerToPropertySection(void) const;
		inline UCHAR* GetPointerToDebugSection(void) const;
		
        inline CPacket *GetPointerToDriverPacket(void) const;

        inline ULONG  GetSize(void) const;

        inline USHORT  GetVersion(void) const;
        inline BOOL    VersionIsValid(void) const;
        inline BOOL    SignatureIsValid(void) const;
        inline USHORT  GetType(void) const;

        inline BOOL   IsSessionIncluded(void) const;
        inline void   IncludeSession(BOOL);

        inline BOOL   IsDbgIncluded(void) const;

        inline USHORT  GetPriority(void) const;

        inline BOOL   IsImmediateAck(void) const;

        inline USHORT GetTrace(void) const;

        inline BOOL   IsSegmented(void);

        inline const GUID *GetSrcQMGuid(void) const;

        inline const TA_ADDRESS *GetSrcQMAddress(void);

        inline const GUID *GetDstQMGuid(void);

        inline void GetMessageId(OBJECTID*) const;

        inline ULONG GetDeliveryMode(void) const;

        inline ULONG GetAuditingMode(void) const;

        inline BOOL GetCancelFollowUp(void) const;

        inline BOOL IsPropertyInc(void) const;

        inline BOOL IsSecurInc(void) const;

        inline BOOL IsBodyInc(void) const;

        inline void SetConnectorQM(const GUID* pConnector);
        inline const GUID* GetConnectorQM(void) const;
        inline BOOL  ConnectorQMIncluded(void) const;

        inline BOOL IsFirstInXact(void) const;
        inline BOOL IsLastInXact(void) const;

        inline ULONG GetHopCount(void) const;
        inline void  IncHopCount(void);

        inline BOOL GetDestinationQueue(QUEUE_FORMAT* pqdQueue, BOOL = FALSE) const;

        inline BOOL GetTestQueue(QUEUE_FORMAT* pqdQueue);

        inline BOOL GetAdminQueue(QUEUE_FORMAT* pqdQueue) const;

        inline BOOL GetResponseQueue(QUEUE_FORMAT* pqdQueue) const;

        inline bool  GetDestinationMqf(QUEUE_FORMAT * pMqf, ULONG nMqf) const;
        inline ULONG GetNumOfDestinationMqfElements(VOID) const;

        inline bool  GetAdminMqf(QUEUE_FORMAT * pMqf, ULONG nMqf) const;
        inline ULONG GetNumOfAdminMqfElements(VOID) const;

        inline bool  GetResponseMqf(QUEUE_FORMAT * pMqf, ULONG nMqf) const;
        inline ULONG GetNumOfResponseMqfElements(VOID) const;

        inline ULONG GetSentTime(void) const;

        inline USHORT GetClass(void) const;

        inline UCHAR GetAckType(void) const;

        inline void GetCorrelation(PUCHAR pCorrelationID) const;
        inline const UCHAR *GetCorrelation(void) const;

        inline ULONG GetApplicationTag(void) const;

        inline ULONG GetBodySize(void) const;
        inline void SetBodySize(ULONG ulBodySize);
        inline ULONG GetAllocBodySize(void) const;
        inline ULONG GetBodyType(void) const;

        inline const WCHAR* GetTitlePtr(void) const;
        inline ULONG GetTitleLength(void) const;

        inline const UCHAR* GetMsgExtensionPtr(void) const;
        inline ULONG GetMsgExtensionSize(void) const;

        inline void SetPrivLevel(ULONG);
        inline ULONG GetPrivLevel(void) const;
        inline ULONG GetPrivBaseLevel(void) const;

        inline ULONG GetHashAlg(void) const;

        inline ULONG GetEncryptAlg(void) const;

        inline void SetAuthenticated(BOOL);
        inline BOOL IsAuthenticated(void) const;

		inline void SetLevelOfAuthentication(UCHAR);
		inline UCHAR GetLevelOfAuthentication(void) const;

        inline void SetEncrypted(BOOL);
        inline BOOL IsEncrypted(void) const;

        inline USHORT GetSenderIDType(void) const;
        inline void SetSenderIDType(USHORT);

        inline const UCHAR* GetSenderID(USHORT* pwSize) const;

        inline const UCHAR* GetSenderCert(ULONG* pulSize) const;
        inline BOOL SenderCertExist(void) const;

        inline const UCHAR* GetEncryptedSymmetricKey(USHORT* pwSize) const;
        inline void SetEncryptedSymmetricKey(const UCHAR *pPacket, USHORT wSize);

		inline USHORT GetSignatureSize(void) const;
        inline const UCHAR* GetSignature(USHORT* pwSize) const;

        inline void GetProvInfo(BOOL *bDefPRov, LPCWSTR *wszProvName, ULONG *pulProvType) const;
        inline const struct _SecuritySubSectionEx *
                     GetSubSectionEx( enum enumSecInfoType eType ) const ;

        inline const UCHAR* GetPacketBody(ULONG* pulSize) const;

        void CreateAck(USHORT usClass);

        inline DWORD  GetRelativeTimeToQueue(void) const;
        inline DWORD  GetRelativeTimeToLive(void) const;
		inline DWORD  GetAbsoluteTimeToLive(void) const;
		inline DWORD  GetAbsoluteTimeToQueue(void) const;

        inline void    SetAcknowldgeNo(WORD  dwPacketAckNo);
        inline void    SetStoreAcknowldgeNo(DWORD_PTR dwPacketStoreAckNo);
        inline WORD    GetAcknowladgeNo(void) const;
        inline DWORD_PTR   GetStoreAcknowledgeNo(void) const;

        inline BOOL IsRecoverable();    // TRUE if packet is recoverable

        inline BOOL  GetReportQueue(OUT QUEUE_FORMAT* pReportQueue) const;

        HRESULT GetDestSymmKey(OUT HCRYPTKEY *phSymmKey,
                               OUT BYTE  **ppEncSymmKey,
                               OUT DWORD *pdwEncSymmKeyLen,
                               OUT PVOID *ppQMCryptInfo);
        HRESULT EncryptExpressPkt(IN HCRYPTKEY hKey,
                                  IN BYTE *pbSymmKey,
                                  IN DWORD dwSymmKeyLen);
        HRESULT Decrypt(void);

        inline BOOL     IsOrdered(void) const;
        inline BOOL     ConnectorTypeIsIncluded(void) const;
        inline const GUID* GetConnectorType(void) const ;

        inline void     SetSeqID(LONGLONG liSeqID);
        inline LONGLONG GetSeqID(void) const;

        inline void    SetSeqN(ULONG ulSeqN);
        inline ULONG   GetSeqN(void) const;

        inline void    SetPrevSeqN(ULONG ulPrevSeqN);
        inline ULONG   GetPrevSeqN(void) const;

        //
        //  BUGBUG: you should not really have Save in qmpkt. erezh
        //
        HRESULT Save(void);  // saves the changes in header

		inline ULONG GetSignatureMqfSize(void) const;
		inline const UCHAR* GetPointerToSignatureMqf(ULONG* pSize) const;

        inline bool  IsSrmpIncluded(VOID) const;
		inline const UCHAR* GetPointerToCompoundMessage(VOID) const;
		inline ULONG GetCompoundMessageSizeInBytes(VOID) const;

        inline bool      IsEodIncluded(VOID) const;
        inline ULONG     GetEodStreamIdSizeInBytes(VOID) const;
        inline VOID      GetEodStreamId(UCHAR * pBuffer, ULONG cbBufferSize) const;
        inline const UCHAR* GetPointerToEodStreamId(VOID) const;
        inline ULONG     GetEodOrderQueueSizeInBytes(VOID) const;
        inline const UCHAR* GetPointerToEodOrderQueue(VOID) const;

        inline bool      IsEodAckIncluded(VOID) const;
        inline LONGLONG  GetEodAckSeqId(VOID) const;
        inline LONGLONG  GetEodAckSeqNum(VOID) const;
        inline ULONG     GetEodAckStreamIdSizeInBytes(VOID) const;
        inline VOID      GetEodAckStreamId(UCHAR * pBuffer, ULONG cbBufferSize) const;
        inline const UCHAR* GetPointerToEodAckStreamId(VOID) const;

		inline bool IsSoapIncluded(VOID) const;
		inline const WCHAR* GetPointerToSoapBody(VOID) const;
		inline ULONG GetSoapBodyLengthInWCHARs(VOID) const;
		inline const WCHAR* GetPointerToSoapHeader(VOID) const;
		inline ULONG GetSoapHeaderLengthInWCHARs(VOID) const;

    public:
        LIST_ENTRY m_link;

    private:
        WORD   m_dwPacketAckNo;
        DWORD_PTR  m_dwPacketStoreAckNo;


	private:
		template <class SECTION_PTR> SECTION_PTR section_cast(void* pSection) const
		{
			return m_pBasicHeader->section_cast<SECTION_PTR>(pSection);
		}
		void PacketIsValid() const;


    private:
        CPacket*            m_pDriverPacket;

    private:
        CBaseHeader *               m_pBasicHeader;
        CUserHeader *               m_pcUserMsg;
        CXactHeader *               m_pXactSection;
        CSecurityHeader *           m_pSecuritySection;
        CPropertyHeader *           m_pcMsgProperty;
        CDebugSection *             m_pDbgPkt;
        CBaseMqfHeader *            m_pDestinationMqfHeader;
        CBaseMqfHeader *            m_pAdminMqfHeader;
        CBaseMqfHeader *            m_pResponseMqfHeader;
		CMqfSignatureHeader *       m_pMqfSignatureHeader;
        CSrmpEnvelopeHeader  *      m_pSrmpEnvelopeHeader;
        CCompoundMessageHeader *    m_pCompoundMessageHeader;
        CEodHeader *                m_pEodHeader;
        CEodAckHeader *             m_pEodAckHeader;
		CSoapSection *              m_pSoapHeaderSection;
		CSoapSection *              m_pSoapBodySection;
        CSessionSection *           m_pSessPkt;
};

/*======================================================================

 Function:     CQmPacket::GetPointerToPacket

 Description:  returns pointer to packet

 =======================================================================*/
inline CBaseHeader *
CQmPacket::GetPointerToPacket(void) const
{
    return( m_pBasicHeader);
}

/*======================================================================

 Function:     CQmPacket::GetPointerToDriverPacket

 Description:  returns pointer to packet

 =======================================================================*/
inline CPacket *
CQmPacket::GetPointerToDriverPacket(void) const
{
    return( m_pDriverPacket);
}


/*======================================================================

 Function:     CQmPacket::GetPointerToUserHeader

 Description:  returns pointer to user header section

 =======================================================================*/
inline UCHAR *
CQmPacket::GetPointerToUserHeader(void) const
{
    return (UCHAR*) m_pcUserMsg;
}

/*======================================================================

 Function:     CQmPacket::GetPointerToSecurHeader

 Description:  returns pointer to security section

 =======================================================================*/
inline UCHAR *
CQmPacket::GetPointerToSecurHeader(void) const
{
    return (UCHAR*) m_pSecuritySection;
}

inline 
UCHAR* 
CQmPacket::GetPointerToPropertySection(void) const
{
	return reinterpret_cast<UCHAR*>(m_pcMsgProperty); 
}

inline 
UCHAR* 
CQmPacket::GetPointerToDebugSection(void) const
{
    return reinterpret_cast<UCHAR*>(m_pDbgPkt);
}


/*======================================================================

 Function:     CQmPacket::GetSize

 Description:  returns the packet size

 =======================================================================*/
inline ULONG
CQmPacket::GetSize(void) const
{
    return(m_pBasicHeader->GetPacketSize());
}

/*======================================================================

 Function:     CQmPacket::GetVersion

 Description:  returns the packet version field

 =======================================================================*/
inline USHORT
CQmPacket::GetVersion(void) const
{
    return(m_pBasicHeader->GetVersion());
}

/*======================================================================

 Function:     CQmPacket::VersionIsValid

 Description:  returns the packet type

 =======================================================================*/
inline BOOL
CQmPacket::VersionIsValid(void) const
{
    return(m_pBasicHeader->VersionIsValid());
}

/*======================================================================

 Function:     CQmPacket::SignatureIsValid

 Description:  return TRUE if Falcon packet signature is ok, False otherwise

 =======================================================================*/
inline BOOL CQmPacket::SignatureIsValid(void) const
{
    return(m_pBasicHeader->SignatureIsValid());
}

/*======================================================================

 Function:     CQmPacket::GetType

 Description:  returns the packet type

 =======================================================================*/
inline USHORT
CQmPacket::GetType(void) const
{
    return(m_pBasicHeader->GetType());
}

/*======================================================================

 Function:    CQmPacket::IncludeSession

 Description:

 =======================================================================*/
inline void
CQmPacket::IncludeSession(BOOL f)
{
    m_pBasicHeader->IncludeSession(f);
}

/*======================================================================

 Function:    CQmPacket::IsSessionIncluded

 Description: returns TRUE if session section included, FALSE otherwise

 =======================================================================*/
inline BOOL
CQmPacket::IsSessionIncluded(void) const
{
    return(m_pBasicHeader->SessionIsIncluded());
}

/*======================================================================

 Function:     CQmPacket::IsDbgIncluded

 Description:  returns TRUE if debug section included, FALSE otherwise

 =======================================================================*/
inline BOOL
CQmPacket::IsDbgIncluded(void) const
{
    return(m_pBasicHeader->DebugIsIncluded());
}

/*======================================================================

 Function:     CQmPacket::GetPriority

 Description:  returns the packet priority

 =======================================================================*/
inline USHORT
CQmPacket::GetPriority(void) const
{
    return(m_pBasicHeader->GetPriority());
}

/*======================================================================

 Function:     CQmPacket::IsImmediateAck

 Description:  Return TRUE if the ACK immediately bit is set, FALSE otherwise

 =======================================================================*/
inline BOOL
CQmPacket::IsImmediateAck(void) const
{
    return(m_pBasicHeader->AckIsImmediate());
}


/*======================================================================

 Function:    CQmPacket::IsTrace

 Description: returns TRUE if the trace bit is set, FALSE otherwise

 =======================================================================*/
inline USHORT
CQmPacket::GetTrace(void) const
{
    return(m_pBasicHeader->GetTraced());
}

/*======================================================================

 Function:     CQmPacket::IsSegmented

 Description:  returns TRUE if the segmented bit is set, FALSE otherwise

 =======================================================================*/
inline BOOL
CQmPacket::IsSegmented(void)
{
    return(m_pBasicHeader->IsFragmented());
}


/*======================================================================

 Function:     CUserMsgHeader::GetSrcQMGuid

 Description:  returns the source QM guid

 =======================================================================*/
inline const GUID *
CQmPacket::GetSrcQMGuid(void) const
{
    return(m_pcUserMsg->GetSourceQM());
}

/*======================================================================

 Function:     CUserMsgHeader::GetSrcQMGuid

 Description:  returns the source QM guid

 =======================================================================*/
inline const TA_ADDRESS *
CQmPacket::GetSrcQMAddress(void)
{
    return(m_pcUserMsg->GetAddressSourceQM());
}

/*======================================================================

 Function:    CQmPacket::GetDstQMGuid

 Description:

 =======================================================================*/
inline const GUID *
CQmPacket::GetDstQMGuid(void)
{
    return(m_pcUserMsg->GetDestQM());
}

/*======================================================================

 Function:    CQmPacket::GetId

 Description: Return the Message ID field

 =======================================================================*/
inline void
CQmPacket::GetMessageId(OBJECTID * pMessageId) const
{
    m_pcUserMsg->GetMessageID(pMessageId);
}

/*======================================================================

 Function:     CQmPacket::getDeliveryMode

 Description:  return the message delivery mode

 =======================================================================*/
inline ULONG
CQmPacket::GetDeliveryMode(void) const
{
    return(m_pcUserMsg->GetDelivery());
}

/*======================================================================

 Function:      CQmPacket::GetAuditingMode

 Description:   return message auditing mode

 =======================================================================*/
inline ULONG
CQmPacket::GetAuditingMode(void) const
{
    return(m_pcUserMsg->GetAuditing());
}

/*======================================================================

 Function:      CQmPacket::GetCancelFollowUp

 Description:   return message Cancel Follow Up mode

 =======================================================================*/
inline BOOL
CQmPacket::GetCancelFollowUp(void) const
{
    if (!m_pXactSection)
    {
        return FALSE;
    }
    else
    {
        return(m_pXactSection->GetCancelFollowUp());
    }
}

/*======================================================================

 Function:    CQmPacket::IsPropertyInc

 Description: Returns TRUE if Message property section included, FALSE otherwise

 =======================================================================*/
inline BOOL
CQmPacket::IsPropertyInc(VOID) const
{
    return(m_pcUserMsg->PropertyIsIncluded());
}


/*======================================================================

 Function:    CQmPacket::IsSecurInc

 Description:

 =======================================================================*/
inline BOOL
CQmPacket::IsSecurInc(void) const
{
    return(m_pcUserMsg->SecurityIsIncluded());
}

/*======================================================================

 Function:    CQmPacket::IsBodyInc

 Description: return TRUE if message body included, FALSE otherwise

 =======================================================================*/
inline BOOL
CQmPacket::IsBodyInc(void) const
{
	if (IsSrmpIncluded())
    {
        return (m_pCompoundMessageHeader->GetBodySizeInBytes() != 0);
    }

    return(m_pcMsgProperty->GetBodySize() != 0);
}

/*======================================================================

  Function:     CQmPacket::GetConnectorQM

  Description:  Returns the ID of the destination Connector QM

========================================================================*/
inline const GUID*
CQmPacket::GetConnectorQM(void) const
{
    return (ConnectorQMIncluded() ? m_pXactSection->GetConnectorQM() : NULL);
}


inline BOOL CQmPacket::IsFirstInXact(void) const
{
    return (m_pXactSection ? m_pXactSection->GetFirstInXact() : FALSE);
}


inline BOOL CQmPacket::IsLastInXact(void) const
{
    return (m_pXactSection ? m_pXactSection->GetLastInXact() : FALSE);
}


/*======================================================================

  Function:     CQmPacket::SetConnectorQM

  Description:  Set the Connector Qm on the packet

========================================================================*/
inline void
CQmPacket::SetConnectorQM(const GUID* pConnector)
{
    ASSERT(ConnectorQMIncluded());

    m_pXactSection->SetConnectorQM(pConnector);
}

/*======================================================================

  Function:     CQmPacket::ConnectorQMIncluded

  Description:  returns TRUE if the message contains destination Connector QM ID.
                (the message is transacted message and it send to foreign queue)

========================================================================*/
inline BOOL
CQmPacket::ConnectorQMIncluded(void) const
{
    return (m_pXactSection ? m_pXactSection->ConnectorQMIncluded() : FALSE);
}

/*======================================================================

 Function:    CQmPacket::IncHopCount

 Description: Increment hop count

 =======================================================================*/
inline void CQmPacket::IncHopCount(void)
{
    m_pcUserMsg->IncHopCount();
}

/*======================================================================

 Function:    CQmPacket::GetHopCount

 Description: returns the message hop count

 =======================================================================*/
inline ULONG
CQmPacket::GetHopCount(void) const
{
    return(m_pcUserMsg->GetHopCount());
}


/*======================================================================

 Function:    CQmPacket::GetDestinationQueue

 Description: returns the destination queue

 =======================================================================*/
inline BOOL
CQmPacket::GetDestinationQueue(QUEUE_FORMAT* pqdQueue,
                               BOOL fGetConnectorQM /*=FALSE*/) const
{
    const GUID* pConnectorGuid;

    pConnectorGuid = (fGetConnectorQM && ConnectorQMIncluded()) ? GetConnectorQM() : NULL;

    if (pConnectorGuid && (*pConnectorGuid != GUID_NULL))
    {
        pqdQueue->MachineID(*pConnectorGuid);
        return TRUE;
    }
    else
    {
        return(m_pcUserMsg->GetDestinationQueue(pqdQueue));
    }
}

/*======================================================================

 Function:    CQmPacket::GetAdminQueue

 Description: returns the Admin queue

 =======================================================================*/
inline BOOL
CQmPacket::GetAdminQueue(QUEUE_FORMAT* pqdQueue) const
{
    return(m_pcUserMsg->GetAdminQueue(pqdQueue));
}


/*======================================================================

 Function:    CQmPacket::GetResponseQueue

 Description: returns the Response queue

 =======================================================================*/
inline BOOL
CQmPacket::GetResponseQueue(QUEUE_FORMAT* pqdQueue) const
{
    return(m_pcUserMsg->GetResponseQueue(pqdQueue));
}


/*======================================================================

 Function:    CQmPacket::GetDestinationMqf

 Description: returns the Destination MQF in an array of queue formats.

 =======================================================================*/
inline bool CQmPacket::GetDestinationMqf(QUEUE_FORMAT * pMqf, ULONG nMqf) const
{
    if (m_pDestinationMqfHeader == NULL)
    {
        //
        // Destination MQF header may not be included in the packet
        //
        return false;
    }

    m_pDestinationMqfHeader->GetMqf(pMqf, nMqf);
    return true;
}


/*======================================================================

 Function:    CQmPacket::GetNumOfDestinationMqfElements

 Description: returns the number of queue format elements in the
              Destination MQF.

 =======================================================================*/
inline ULONG CQmPacket::GetNumOfDestinationMqfElements(VOID) const
{
    if (m_pDestinationMqfHeader == NULL)
    {
        //
        // Destination MQF header may not be included in the packet
        //
        return 0;
    }

    return (m_pDestinationMqfHeader->GetNumOfElements());
}


/*======================================================================

 Function:    CQmPacket::GetAdminMqf

 Description: returns the Admin MQF in an array of queue formats.

 =======================================================================*/
inline bool CQmPacket::GetAdminMqf(QUEUE_FORMAT * pMqf, ULONG nMqf) const
{
    if (m_pAdminMqfHeader == NULL)
    {
        //
        // Admin MQF header may not be included in the packet
        //
        return false;
    }

    m_pAdminMqfHeader->GetMqf(pMqf, nMqf);
    return true;
}


/*======================================================================

 Function:    CQmPacket::GetNumOfAdminMqfElements

 Description: returns the number of queue format elements in the
              Admin MQF.

 =======================================================================*/
inline ULONG CQmPacket::GetNumOfAdminMqfElements(VOID) const
{
    if (m_pAdminMqfHeader == NULL)
    {
        //
        // Admin MQF header may not be included in the packet
        //
        return 0;
    }

    return (m_pAdminMqfHeader->GetNumOfElements());
}


/*======================================================================

 Function:    CQmPacket::GetResponseMqf

 Description: returns the Response MQF in an array of queue formats.

 =======================================================================*/
inline bool CQmPacket::GetResponseMqf(QUEUE_FORMAT * pMqf, ULONG nMqf) const
{
    if (m_pResponseMqfHeader == NULL)
    {
        //
        // Response MQF header may not be included in the packet
        //
        return false;
    }

    m_pResponseMqfHeader->GetMqf(pMqf, nMqf);
    return true;
}


/*======================================================================

 Function:    CQmPacket::GetNumOfResponseMqfElements

 Description: returns the number of queue format elements in the
              Response MQF.

 =======================================================================*/
inline ULONG CQmPacket::GetNumOfResponseMqfElements(VOID) const
{
    if (m_pResponseMqfHeader == NULL)
    {
        //
        // Response MQF header may not be included in the packet
        //
        return 0;
    }

    return (m_pResponseMqfHeader->GetNumOfElements());
}


/*======================================================================

 Function:    CQmPacket::GetSentTime

 Description: returns packet sent time

 =======================================================================*/
inline ULONG CQmPacket::GetSentTime(void) const
{
    return m_pcUserMsg->GetSentTime();
}


/*======================================================================

 Function:     CQmPacket::GetClass

 Description:  Returns message class

 =======================================================================*/
inline USHORT
CQmPacket::GetClass(void) const
{
    return(m_pcMsgProperty->GetClass());
}

/*===========================================================

  Routine Name:  CQmPacket::GetAckType

  Description:   Returns The Ack Type

=============================================================*/
inline UCHAR
CQmPacket::GetAckType(void) const
{
    return(m_pcMsgProperty->GetAckType());
}

/*======================================================================

 Function:    CQmPacket::GetCorrelation

 Description: Returns Message correlation

 =======================================================================*/
inline const UCHAR *
CQmPacket::GetCorrelation(void) const
{
    return m_pcMsgProperty->GetCorrelationID();
}

/*======================================================================

 Function:    CQmPacket::GetCorrelation

 Description: Returns Message correlation

 =======================================================================*/
inline void
CQmPacket::GetCorrelation(PUCHAR pCorrelationID) const
{
    m_pcMsgProperty->GetCorrelationID(pCorrelationID);
}

/*======================================================================

 Function:    CQmPacket::GetAppsData

 Description: Returns Applecation specific data

 =======================================================================*/
inline ULONG
CQmPacket::GetApplicationTag(void) const
{
    return(m_pcMsgProperty->GetApplicationTag());
}

/*======================================================================

 Function:    CQmPacket::GetBodySize

 Description: Get Message body size

 =======================================================================*/
inline ULONG
CQmPacket::GetBodySize(void) const
{
	if (IsSrmpIncluded())
    {
        return (m_pCompoundMessageHeader->GetBodySizeInBytes());
    }

    return(m_pcMsgProperty->GetBodySize());
}

/*======================================================================

 Function:    CQmPacket::SetBodySize

 Description: Set Message body size

 =======================================================================*/
inline void
CQmPacket::SetBodySize(ULONG ulBodySize)
{

	ASSERT(!IsSrmpIncluded());


    m_pcMsgProperty->SetBodySize(ulBodySize);
}

/*======================================================================

 Function:    CQmPacket::GetTitle

 Description: Get Message title

 =======================================================================*/
inline const WCHAR*
CQmPacket::GetTitlePtr(void) const
{
    return(m_pcMsgProperty->GetTitlePtr());
}


/*======================================================================

 Function:    CQmPacket::GetTitleSize

 Description: Get Message title size

 =======================================================================*/
inline ULONG
CQmPacket::GetTitleLength(void) const
{
    return(m_pcMsgProperty->GetTitleLength());
}

/*======================================================================

 Function:    CQmPacket::GetMsgExtensionPtr

 Description: Get pointer to Message Extension property

 =======================================================================*/
inline const UCHAR*
CQmPacket::GetMsgExtensionPtr(void) const
{
    return(m_pcMsgProperty->GetMsgExtensionPtr());
}


/*======================================================================

 Function:    CQmPacket::GetMsgExtensionSize

 Description: Get Message Extension size

 =======================================================================*/
inline ULONG
CQmPacket::GetMsgExtensionSize(void) const
{
    return(m_pcMsgProperty->GetMsgExtensionSize());
}

/*======================================================================

 Function:    CPropertyHeader::SetPrivLevel

 Description: Set the privacy level of the message in the message packet.

 =======================================================================*/
inline void
CQmPacket::SetPrivLevel(ULONG ulPrivLevel)
{
    m_pcMsgProperty->SetPrivLevel(ulPrivLevel);
}

/*======================================================================

 Function:    CPropertyHeader::GetPrivLevel

 Description: Get the privacy level of the message in the message packet.

 =======================================================================*/
inline ULONG
CQmPacket::GetPrivLevel(void) const
{
    return(m_pcMsgProperty->GetPrivLevel());
}

/*======================================================================

 Function:    CPropertyHeader::GetPrivBaseLevel

 Description: Get the privacy level of the message in the message packet.

 =======================================================================*/
inline ULONG
CQmPacket::GetPrivBaseLevel(void) const
{
    return(m_pcMsgProperty->GetPrivBaseLevel()) ;
}

/*======================================================================

 Function:    CPropertyHeader::GetHashAlg

 Description: Get the hash algorithm of the message in the message packet.

 =======================================================================*/
inline ULONG
CQmPacket::GetHashAlg(void) const
{
    return(m_pcMsgProperty->GetHashAlg());
}

/*======================================================================

 Function:    CPropertyHeader::GetEncryptAlg

 Description: Get the encryption algorithm of the message in the message packet.

 =======================================================================*/
inline ULONG
CQmPacket::GetEncryptAlg(void) const
{
    return(m_pcMsgProperty->GetEncryptAlg());
}

/*=============================================================

 Routine Name:  CQmPacket::SetEncrypted

 Description:   Set Encrypted message bit

===============================================================*/
inline void CQmPacket::SetEncrypted(BOOL f)
{
    ASSERT(m_pSecuritySection);
    m_pSecuritySection->SetEncrypted(f);
}

/*=============================================================

 Routine Name:   CQmPacket::IsEncrypted

 Description:    Returns TRUE if the msg is Encrypted, False otherwise

===============================================================*/
inline BOOL CQmPacket::IsEncrypted(void) const
{
    return(m_pSecuritySection ? m_pSecuritySection->IsEncrypted() :
        FALSE);
}

/*=============================================================

 Routine Name:   CQmPacket::IsOrdered

 Description:    Returns TRUE if the msg is Ordered, False otherwise

===============================================================*/
inline BOOL CQmPacket::IsOrdered(void) const
{
    return m_pcUserMsg->IsOrdered();
}

/*=============================================================

 Routine Name:   CQmPacket::ConnectorTypeIsIncluded

 Description:    Returns TRUE if the msg came from Connector

===============================================================*/
inline BOOL CQmPacket::ConnectorTypeIsIncluded(void) const
{
    return m_pcUserMsg->ConnectorTypeIsIncluded();
}

/*=============================================================

 Routine Name:   CQmPacket::GetConnectorType(void) const

 Description:    Get the guid of the connector type.

===============================================================*/
inline const GUID* CQmPacket::GetConnectorType(void) const
{
    return m_pcUserMsg->GetConnectorType();
}

/*=============================================================

 Routine Name:  CQmPacket::SetAuthenticated

 Description:   Set the authenticated bit

===============================================================*/
inline void CQmPacket::SetAuthenticated(BOOL f)
{
    if (m_pSecuritySection)
    {
        m_pSecuritySection->SetAuthenticated(f);
    }
}

/*=============================================================

 Routine Name:   CQmPacket::IsAuthenticated

 Description:    Returns TRUE if the msg is authenticated, False otherwise

===============================================================*/
inline BOOL
CQmPacket::IsAuthenticated(void) const
{
    return(m_pSecuritySection ? m_pSecuritySection->IsAuthenticated() :
        FALSE);
}

/*=============================================================

 Routine Name:  CQmPacket::SetLevelOfAuthentication

 Description:   Set the Level Of Authentication

===============================================================*/
inline void CQmPacket::SetLevelOfAuthentication(UCHAR Level)
{
    if (m_pSecuritySection)
    {
        m_pSecuritySection->SetLevelOfAuthentication(Level);
    }
}

/*=============================================================

 Routine Name:   CQmPacket::GetLevelOfAuthentication

 Description:    Return the Level Of Authentication

===============================================================*/
inline UCHAR
CQmPacket::GetLevelOfAuthentication(void) const
{
    return((UCHAR)(m_pSecuritySection ? m_pSecuritySection->GetLevelOfAuthentication() : 
								MQMSG_AUTHENTICATION_NOT_REQUESTED));
}




/*=============================================================

 Routine Name:  CQmPacket::GetSenderIDType

 Description:

===============================================================*/
inline USHORT
CQmPacket::GetSenderIDType(void) const
{
    return((USHORT)(m_pSecuritySection ? m_pSecuritySection->GetSenderIDType() :
        MQMSG_SENDERID_TYPE_NONE));
}



/*=============================================================

 Routine Name:  CQmPacket::SetSenderIDType

 Description:

===============================================================*/
inline void CQmPacket::SetSenderIDType(USHORT uSenderIDType)
{
    ASSERT(m_pSecuritySection);
    m_pSecuritySection->SetSenderIDType(uSenderIDType);
}

/*=============================================================

 Routine Name:  CQmPacket::GetSenderID

 Description:

 Arguments:

 Return Value:

===============================================================*/
inline const UCHAR*
CQmPacket::GetSenderID(USHORT* pwSize) const
{
    if (GetSenderIDType() == MQMSG_SENDERID_TYPE_NONE)
    {
        *pwSize = 0;
        return NULL;
    }

    return(m_pSecuritySection->GetSenderID(pwSize));
}

/*=============================================================

 Routine Name:  CQmPacket::GetSenderCert

 Description:

 Arguments:

 Return Value:

===============================================================*/
inline const UCHAR*
CQmPacket::GetSenderCert(ULONG* pulSize) const
{
    if (!m_pSecuritySection)
    {
        *pulSize = 0;
        return(NULL);
    }

    return(m_pSecuritySection->GetSenderCert(pulSize));
}

/*=============================================================

 Routine Name:  CQmPacket::SenderCertExist

 Description:

 Arguments:

 Return Value:	Returns TRUE if Sender Certificate exist

===============================================================*/
inline BOOL
CQmPacket::SenderCertExist(void) const
{
    if (!m_pSecuritySection)
        return(false);

    return(m_pSecuritySection->SenderCertExist());
}

/*=============================================================

 Routine Name:

 Description:

 Arguments:

 Return Value:

===============================================================*/
inline const UCHAR*
CQmPacket::GetEncryptedSymmetricKey(USHORT* pwSize) const
{
    if (!m_pSecuritySection) {
        *pwSize = 0;
        return NULL;
    }

    return(m_pSecuritySection->GetEncryptedSymmetricKey(pwSize));
}

/*=============================================================

 Routine Name:

 Description:

 Arguments:

 Return Value:

===============================================================*/
inline void
CQmPacket::SetEncryptedSymmetricKey(const UCHAR *pbKey, USHORT wSize)
{
    ASSERT(m_pSecuritySection);
    m_pSecuritySection->SetEncryptedSymmetricKey(pbKey, wSize);
}

/*=============================================================

 Routine Name:  CQmPacket::GetSignatureSize

 Description:

 Arguments:

 Return Value:

===============================================================*/
inline USHORT
CQmPacket::GetSignatureSize(void) const
{
    if (!m_pSecuritySection) 
	{
        return 0;
    }

    return(m_pSecuritySection->GetSignatureSize());
}

/*=============================================================

 Routine Name:  CQmPacket::GetSignature

 Description:

 Arguments:

 Return Value:

===============================================================*/
inline const UCHAR*
CQmPacket::GetSignature(USHORT* pwSize) const
{
    if (!m_pSecuritySection) {
        *pwSize = 0;
        return NULL;
    }

    return(m_pSecuritySection->GetSignature(pwSize));
}

/*=============================================================

 Routine Name:  CQmPacket::GetProvInfo

 Description:

 Arguments:

 Return Value:

===============================================================*/
inline void
CQmPacket::GetProvInfo(
    BOOL *pbDefProv,
    LPCWSTR *wszProvName,
    ULONG *pulProvType) const
{
    if (m_pSecuritySection)
    {
        m_pSecuritySection->GetProvInfo(
                                    pbDefProv,
                                    wszProvName,
                                    pulProvType);
    }
    else
    {
        *pbDefProv = TRUE;
    }
}

/*=============================================================

 Routine Name:  CQmPacket::GetSubSectionEx()

===============================================================*/

inline
const struct _SecuritySubSectionEx *
CQmPacket::GetSubSectionEx( enum enumSecInfoType eType ) const
{
    const struct _SecuritySubSectionEx * pSecEx = NULL ;

    if (m_pSecuritySection)
    {
        pSecEx = m_pSecuritySection->GetSubSectionEx( eType ) ;
    }

    return pSecEx ;
}

/*=============================================================

 Routine Name:  CQmPacket::GetPacketBody

 Description:

 Arguments:

 Return Value:

===============================================================*/
inline const UCHAR*
CQmPacket::GetPacketBody(ULONG* pulSize) const
{
    *pulSize = GetBodySize();

	if (IsSrmpIncluded())
    {
        return (m_pCompoundMessageHeader->GetPointerToBody());
    }

    return  m_pcMsgProperty->GetBodyPtr();
}


/*=============================================================

 Routine Name:  CQmPacket::GetAllocBodySize

 Description:

 Arguments:

 Return Value:

===============================================================*/
inline ULONG
CQmPacket::GetAllocBodySize(void) const
{
    if(IsSrmpIncluded())
	return 0;

    return m_pcMsgProperty->GetAllocBodySize();
}

/*=============================================================

 Routine Name:  CQmPacket::GetBodyType

 Description:

 Arguments:

 Return Value:

===============================================================*/
inline ULONG
CQmPacket::GetBodyType(void) const
{
    return m_pcMsgProperty->GetBodyType();
}

/*=============================================================

 Routine Name:  CQmPacket::GetAbsoluteTimeToQueue

 Description:

 Arguments:

 Return Value:

===============================================================*/
inline DWORD  CQmPacket::GetAbsoluteTimeToQueue(void) const
{
    return  m_pBasicHeader->GetAbsoluteTimeToQueue();
}



/*=============================================================

 Routine Name:  CQmPacket::GetAbsoluteTimeToLive

 Description:

 Arguments:

 Return Value:

===============================================================*/

inline DWORD CQmPacket::GetAbsoluteTimeToLive(void) const
{
    DWORD dwTimeout = m_pcUserMsg->GetTimeToLiveDelta();
    if(dwTimeout == INFINITE)
		return 	INFINITE;
    
    return   dwTimeout + m_pBasicHeader->GetAbsoluteTimeToQueue();
}





/*=============================================================

 Routine Name:  CQmPacket::GetRelativeTimeToQueue

 Description:

 Arguments:

 Return Value:

===============================================================*/

inline DWORD CQmPacket::GetRelativeTimeToQueue(void) const
{
    DWORD dwTimeout = m_pBasicHeader->GetAbsoluteTimeToQueue();
    if(dwTimeout != INFINITE)
    {
        DWORD dwCurrentTime = MqSysTime();
        if(dwTimeout > dwCurrentTime)
        {
            dwTimeout -= dwCurrentTime;
        }
        else
        {
            //
            //  Underflow, timeout has expired already.
            //
            dwTimeout = 0;
        }
    }

    return dwTimeout;
}

/*=============================================================

 Routine Name:  CQmPacket::GetRelativeTimeToLive

 Description:

 Arguments:

 Return Value:

===============================================================*/

inline DWORD CQmPacket::GetRelativeTimeToLive(void) const
{
    DWORD dwTimeout = m_pcUserMsg->GetTimeToLiveDelta();
    if(dwTimeout != INFINITE)
    {
        dwTimeout += m_pBasicHeader->GetAbsoluteTimeToQueue();

        DWORD dwCurrentTime = MqSysTime();
        if(dwTimeout > dwCurrentTime)
        {
            dwTimeout -= dwCurrentTime;
        }
        else
        {
            //
            //  Underflow, timeout has expired already.
            //
            dwTimeout = 0;
        }
    }

    return dwTimeout;
}


/*=============================================================

 Routine Name:  CQmPacket::SetAcknowldgeNo

 Description:   Set the send ACK number.

===============================================================*/
inline void
CQmPacket::SetAcknowldgeNo(WORD  dwPacketAckNo)
{
    m_dwPacketAckNo = dwPacketAckNo;
}

/*=============================================================

 Routine Name:  CQmPacket::SetStoreAcknowldgeNo

 Description:   Set the packet store ACK number

===============================================================*/
inline void
CQmPacket::SetStoreAcknowldgeNo(DWORD_PTR dwPacketStoreAckNo)
{
    m_dwPacketStoreAckNo = dwPacketStoreAckNo;
}

/*=============================================================

 Routine Name:  CQmPacket::GetAcknowladgeNo

 Description:   return the packet send hop-ACK number

===============================================================*/
inline WORD
CQmPacket::GetAcknowladgeNo(void) const
{
    return(m_dwPacketAckNo);
}

/*=============================================================

 Routine Name:  CQmPacket::GetStoreAcknowledgeNo

 Description:  Return the Packet store hop-ACK number

===============================================================*/
inline DWORD_PTR
CQmPacket::GetStoreAcknowledgeNo(void) const
{
    return(m_dwPacketStoreAckNo);
}

/*=============================================================

 Routine Name:  CQmPacket::IsRecoverable

 Description:   Return TRUE is packet is recoverable and
                should be stored on disk.

===============================================================*/
inline BOOL
CQmPacket::IsRecoverable()
{
    return (GetDeliveryMode() == MQMSG_DELIVERY_RECOVERABLE) ;
}

/*=============================================================

 Routine Name:  CQmPacket::GetReportQueue

 Description:   Return the report queue that associate to the packet

===============================================================*/
inline BOOL
CQmPacket::GetReportQueue(OUT QUEUE_FORMAT* pReportQueue) const
{
    if (m_pDbgPkt == NULL)
        return FALSE;

    return (m_pDbgPkt->GetReportQueue(pReportQueue));
}

/*======================================================================

 Function:    CQmPacket::SetSeqID

 Description: Sets the Sequence ID

 =======================================================================*/
inline void CQmPacket::SetSeqID(LONGLONG liSeqID)
{
    ASSERT(m_pXactSection);
    m_pXactSection->SetSeqID(liSeqID);
}

/*======================================================================

 Function:    CQmPacket::GetSeqID

 Description: Gets the Sequence ID

 =======================================================================*/
inline LONGLONG CQmPacket::GetSeqID(void) const

{
    return (m_pXactSection ? m_pXactSection->GetSeqID() : 0);
}

/*======================================================================

 Function:    CQmPacket::SetSeqN

 Description: Sets the Sequence Number

 =======================================================================*/
inline void CQmPacket::SetSeqN(ULONG ulSeqN)
{
    ASSERT(m_pXactSection);
    m_pXactSection->SetSeqN(ulSeqN);
}

/*======================================================================

 Function:    CQmPacket::GetSeqN

 Description: Gets the Sequence Number

 =======================================================================*/
inline ULONG CQmPacket::GetSeqN(void) const
{
    return (m_pXactSection ? m_pXactSection->GetSeqN() : 0);
}

/*======================================================================

 Function:    CQmPacket::SetPrevSeqN

 Description: Sets the Previous Sequence Number

 =======================================================================*/
inline void CQmPacket::SetPrevSeqN(ULONG ulPrevSeqN)
{
    ASSERT(m_pXactSection);
    m_pXactSection->SetPrevSeqN(ulPrevSeqN);
}

/*======================================================================

 Function:    CQmPacket::GetPrevSeqN

 Description: Gets the Previous Sequence Number

 =======================================================================*/
inline ULONG CQmPacket::GetPrevSeqN(void) const
{
    return (m_pXactSection ? m_pXactSection->GetPrevSeqN() : 0);
}

/*======================================================================

 Function:    CQmPacket::IsSrmpIncluded

 Description: Checks if SRMP section is included in the packet

 =======================================================================*/
inline bool CQmPacket::IsSrmpIncluded(VOID) const  
{
    return (m_pcUserMsg->SrmpIsIncluded());
}

/*======================================================================

 Function:    CQmPacket::GetCompoundMessageSizeInBytes

 Description: Returns the size of the CompoundMessage property

 =======================================================================*/
inline ULONG CQmPacket::GetCompoundMessageSizeInBytes(VOID) const
{
	ASSERT(IsSrmpIncluded());
	return m_pCompoundMessageHeader->GetDataSizeInBytes();	
}


/*======================================================================

 Function:    CQmPacket::GetPointerToCompoundMessage

 Description: Get pointer to CompoundMessage 

 =======================================================================*/
inline const UCHAR* CQmPacket::GetPointerToCompoundMessage(VOID) const
{
	ASSERT(IsSrmpIncluded());
	return m_pCompoundMessageHeader->GetPointerToData();
}


/*======================================================================

 Function:    CQmPacket::IsEodIncluded

 Description: Checks if EOD section is included in the packet

 =======================================================================*/
inline bool CQmPacket::IsEodIncluded(VOID) const  
{
    return (m_pcUserMsg->EodIsIncluded());
}


/*======================================================================

 Function:    CQmPacket::GetEodStreamIdSizeInBytes

 Description: Returns the Eod stream ID size

 =======================================================================*/
inline ULONG CQmPacket::GetEodStreamIdSizeInBytes(VOID) const
{
    ASSERT(IsEodIncluded());

    return m_pEodHeader->GetStreamIdSizeInBytes();
}


/*======================================================================

 Function:    CQmPacket::GetEodStreamId

 Description: Returns the Eod stream ID

 =======================================================================*/
inline VOID CQmPacket::GetEodStreamId(UCHAR * pBuffer, ULONG cbBufferSize) const
{
    ASSERT(IsEodIncluded());

    m_pEodHeader->GetStreamId(pBuffer, cbBufferSize);
}


/*======================================================================

 Function:    CQmPacket::GetPointerToEodStreamId

 Description: Returns a pointer to the Eod stream ID

 =======================================================================*/
inline const UCHAR* CQmPacket::GetPointerToEodStreamId(VOID) const
{
    ASSERT(IsEodIncluded());

    return m_pEodHeader->GetPointerToStreamId();
}


/*======================================================================

 Function:    CQmPacket::GetEodOrderQueueSizeInBytes

 Description: Returns the EOD order queue size

 =======================================================================*/
inline ULONG CQmPacket::GetEodOrderQueueSizeInBytes(VOID) const
{
    ASSERT(IsEodIncluded());

    return m_pEodHeader->GetOrderQueueSizeInBytes();
}


/*======================================================================

 Function:    CQmPacket::GetPointerToEodOrderQueue

 Description: Returns a pointer to the EOD order queue

 =======================================================================*/
inline const UCHAR* CQmPacket::GetPointerToEodOrderQueue(VOID) const
{
    ASSERT(IsEodIncluded());

    return m_pEodHeader->GetPointerToOrderQueue();
}


/*======================================================================

 Function:    CQmPacket::IsEodAckIncluded

 Description: Checks if EodAck section is included in the packet

 =======================================================================*/
inline bool CQmPacket::IsEodAckIncluded(VOID) const  
{
    return (m_pcUserMsg->EodAckIsIncluded());
}


/*======================================================================

 Function:    CQmPacket::GetEodAckSeqId

 Description: Returns the EodAck seq ID

 =======================================================================*/
inline LONGLONG CQmPacket::GetEodAckSeqId(VOID) const
{
    ASSERT(IsEodAckIncluded());

    return m_pEodAckHeader->GetSeqId();
}


/*======================================================================

 Function:    CQmPacket::GetEodAckSeqNum

 Description: Returns the EodAck seq num

 =======================================================================*/
inline LONGLONG CQmPacket::GetEodAckSeqNum(VOID) const
{
    ASSERT(IsEodAckIncluded());

    return m_pEodAckHeader->GetSeqNum();
}


/*======================================================================

 Function:    CQmPacket::GetEodAckStreamIdSizeInBytes

 Description: Returns the EodAck stream ID size

 =======================================================================*/
inline ULONG CQmPacket::GetEodAckStreamIdSizeInBytes(VOID) const
{
    ASSERT(IsEodAckIncluded());

    return m_pEodAckHeader->GetStreamIdSizeInBytes();
}


/*======================================================================

 Function:    CQmPacket::GetEodAckStreamId

 Description: Returns the EodAck stream ID

 =======================================================================*/
inline VOID CQmPacket::GetEodAckStreamId(UCHAR * pBuffer, ULONG cbBufferSize) const
{
    ASSERT(IsEodAckIncluded());

    return m_pEodAckHeader->GetStreamId(pBuffer, cbBufferSize);
}


/*======================================================================

 Function:    CQmPacket::GetPointerToEodAckStreamId

 Description: Returns a pointer to the EodAck stream ID

 =======================================================================*/
inline const UCHAR* CQmPacket::GetPointerToEodAckStreamId(VOID) const
{
    ASSERT(IsEodAckIncluded());

    return m_pEodAckHeader->GetPointerToStreamId();
}


/*======================================================================

 Function:    CQmPacket::GetSignatureMqfSize

 Description: Returns the size of the signature MQF in bytes

 =======================================================================*/
inline ULONG CQmPacket::GetSignatureMqfSize(void) const
{
	//
	// The MQF headers are optional and may not be included in the packet
	//
	if (m_pMqfSignatureHeader == NULL)
	{
		return 0;
	}

	return m_pMqfSignatureHeader->GetSignatureSizeInBytes();
}


/*======================================================================

 Function:    CQmPacket::GetPointerToSignatureMqf

 Description: Get pointer to signatureMqf

 =======================================================================*/
inline const UCHAR* CQmPacket::GetPointerToSignatureMqf(ULONG* pSize) const
{
    ASSERT(("Must call GetSignatureMqfSize first!", m_pMqfSignatureHeader != NULL));

	return m_pMqfSignatureHeader->GetPointerToSignature(pSize);
}

/*======================================================================

 Function:    CQmPacket::IsSoapIncluded

 Description: Checks if SOAP section is included in the packet

 =======================================================================*/
inline bool CQmPacket::IsSoapIncluded(VOID) const  
{
    return (m_pcUserMsg->SoapIsIncluded());
}

/*======================================================================

 Function:    CQmPacket::GetSoapHeaderLengthInWchars

 Description: Returns the length of the SOAP Header property including NULL terminator

 =======================================================================*/
inline ULONG CQmPacket::GetSoapHeaderLengthInWCHARs(VOID) const
{
	ASSERT(IsSoapIncluded());
	return m_pSoapHeaderSection->GetDataLengthInWCHARs();	
}

/*======================================================================

 Function:    CQmPacket::GetPointerToSoapHeader

 Description: Get pointer to SOAP Header data

 =======================================================================*/
inline const WCHAR* CQmPacket::GetPointerToSoapHeader(VOID) const
{
	ASSERT(IsSoapIncluded());
	return m_pSoapHeaderSection->GetPointerToData();
}

/*======================================================================

 Function:    CQmPacket::GetSoapBodyLengthInWchars

 Description: Returns the length of the SOAP Body property including NULL terminator

 =======================================================================*/
inline ULONG CQmPacket::GetSoapBodyLengthInWCHARs(VOID) const
{
	ASSERT(IsSoapIncluded());
	return m_pSoapBodySection->GetDataLengthInWCHARs();	
}

/*======================================================================

 Function:    CQmPacket::GetPointerToSoapBody

 Description: Get pointer to SOAP Body data

 =======================================================================*/
inline const WCHAR* CQmPacket::GetPointerToSoapBody(VOID) const
{
	ASSERT(IsSoapIncluded());
	return m_pSoapBodySection->GetPointerToData();
}


#endif //__QM_PACKET__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\uniansi.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    uniansi.h

Abstract:

    Unicode/Ansi conversion macros

Author:

    Doron Juster  (DoronJ)  20-Aug-97

--*/
#ifndef __FALCON_UNIANSI_H
#define __FALCON_UNIANSI_H

#define ConvertToMultiByteString(wcsSrc, mbsDest, umbSize)   \
    WideCharToMultiByte( CP_ACP,                             \
                         0,                                  \
                         wcsSrc,                             \
                         -1,                                 \
                         mbsDest,                            \
                         umbSize,                            \
                         NULL,                               \
                         NULL ) ;

#define ConvertToWideCharString(mbsSrc, wcsDest, uwcSize)    \
    MultiByteToWideChar( CP_ACP,                             \
                         0,                                  \
                         mbsSrc,                             \
                         -1,                                 \
                         wcsDest,                            \
                         uwcSize ) ;

#define CompareSubStringsNoCaseGeneral(str1, str2, len, CompareFunc) \
    (CompareFunc(                                            \
        LOCALE_SYSTEM_DEFAULT,                               \
        NORM_IGNORECASE,                                     \
        str1,                                                \
        len,                                                 \
        str2,                                                \
        len) - 2)

#define CompareSubStringsNoCase(str1, str2, len)             \
        CompareSubStringsNoCaseGeneral(str1, str2, len, CompareString)             

#define CompareSubStringsNoCaseAnsi(str1, str2, len)         \
        CompareSubStringsNoCaseGeneral(str1, str2, len, CompareStringA)     

#define CompareSubStringsNoCaseUnicode(str1, str2, len)         \
        CompareSubStringsNoCaseGeneral(str1, str2, len, CompareStringW)             

#define CompareStringsNoCase(str1, str2) CompareSubStringsNoCase(str1, str2, -1)

#define CompareStringsNoCaseAnsi(str1, str2) CompareSubStringsNoCaseAnsi(str1, str2, -1)

#define CompareStringsNoCaseUnicode(str1, str2) CompareSubStringsNoCaseUnicode(str1, str2, -1)

#define MAX_BYTES_PER_CHAR 2
#endif // __FALCON_UNIANSI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\seqnum.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:
    seqnum.h

Abstract:

Author:
    Ronit Hartmann (ronith)

--*/

#ifndef __SEQNUM_H
#define __SEQNUM_H


const _SEQNUM MQIS_SMALLEST_SEQNUM =   { 0, 0, 0, 0, 0, 0, 0, 0};
const _SEQNUM MQIS_INFINITE_LSN   =  { (unsigned char)0xff, (unsigned char)0xff, (unsigned char)0xff, (unsigned char)0xff, (unsigned char)0xff, (unsigned char)0xff, (unsigned char)0xff, (unsigned char)0xff};



//-----------------------------
//
//  Sequence number class
//
class CSeqNum 
{
public:
    CSeqNum();
    CSeqNum( _SEQNUM * pSN);
    CSeqNum( const CSeqNum & sn);
	~CSeqNum() {};
    void Increment();
    void Decrement();
    DWORD Serialize( unsigned char * pBuf) const; 
    DWORD SetValue( const unsigned char * pBuf);
    static const DWORD GetSerializeSize();
    operator <=( const CSeqNum & sn) const;
    operator <( const CSeqNum & sn) const;
    operator >( const CSeqNum & sn) const;
    operator ==( const CSeqNum & sn) const;
    operator >=( const CSeqNum & sn) const;
    operator !=( const CSeqNum & sn) const;
    CSeqNum & operator = ( const CSeqNum & sn);
    const unsigned char * GetPtr() const;
    void GetValue(BLOB * pblob) const;
    void GetValueForPrint( OUT WCHAR * pBuffer) const;
    BOOL IsSmallestValue() const;
    BOOL IsSmallerByMoreThanOne( const CSeqNum & sn) const;
	BOOL NotGreaterByMoreThanFrom(DWORD diff, const CSeqNum &other) const;
    BOOL IsInfiniteLsn() const;
    void SetSmallestValue();
    void SetInfiniteLSN();
	BOOL IsMultipleOf(IN DWORD dwFrequency) const;
	void operator -= (DWORD dwSub);
	void operator += (DWORD dwAdd);
	
private:

	DWORD GetHighDWORD() const;
	DWORD GetLowDWORD() const;
	DWORD GetDWORD(IN int offset) const;
	void SetHighDWORD(IN DWORD dw);
	void SetLowDWORD(IN DWORD dw);
	void SetDWORD(IN int offset, IN DWORD dw);

    _SEQNUM    m_SeqNum;

};

inline CSeqNum::CSeqNum():m_SeqNum( MQIS_SMALLEST_SEQNUM)
{
}

inline CSeqNum::CSeqNum( _SEQNUM * pSN): m_SeqNum(*pSN)
{ 
}

inline CSeqNum::CSeqNum( const CSeqNum & sn)
{
    m_SeqNum = sn.m_SeqNum;
}

inline DWORD CSeqNum::Serialize( unsigned char * pBuf) const
{
    memcpy( pBuf, &m_SeqNum, sizeof(_SEQNUM));
    return( sizeof(_SEQNUM));
}

inline DWORD CSeqNum::SetValue( const unsigned char * pBuf)
{
    memcpy( &m_SeqNum, pBuf, sizeof(_SEQNUM));
    return( sizeof(_SEQNUM));
}

inline const DWORD CSeqNum::GetSerializeSize()
{
    return(sizeof(_SEQNUM));
}

inline BOOL CSeqNum::IsSmallestValue() const
{
    return ( !memcmp( &m_SeqNum,&MQIS_SMALLEST_SEQNUM,sizeof(_SEQNUM)));
}

inline void CSeqNum::Increment()
{
    long i;

    for ( i = 7 ; i >= 0 ; i--)
    {
        m_SeqNum.c[i]++;
        if (m_SeqNum.c[i] != 0) // no wrap around
        {
            break;
        }
    }
}
inline void CSeqNum::Decrement()
{
    long i;
    BOOL fToContinue;
    for ( i = 7; i >=0 ; i--)
    {
        fToContinue = ( m_SeqNum.c[i] == 0);  //  decrement the next digit also
        m_SeqNum.c[i]--;

        if ( !fToContinue)
        {
            break;
        }
    }
}

inline  CSeqNum::operator !=( const CSeqNum & sn) const
{
    return( memcmp( &m_SeqNum,&sn.m_SeqNum,sizeof(_SEQNUM)));
}
inline  CSeqNum::operator ==( const CSeqNum & sn) const
{
    return( !memcmp( &m_SeqNum,&sn.m_SeqNum,sizeof(_SEQNUM)));
}
inline  CSeqNum::operator <=( const CSeqNum & sn) const
{
    for ( DWORD i = 0 ; i < 8 ; i++)
    {
        if (m_SeqNum.c[i] < sn.m_SeqNum.c[i])
        {
            return(TRUE);
        }
        if (m_SeqNum.c[i] > sn.m_SeqNum.c[i])
        {
            return(FALSE);
        }
    }
    return(TRUE);
}
inline  CSeqNum::operator >=( const CSeqNum & sn) const
{
    for ( DWORD i = 0 ; i < 8 ; i++)
    {
        if (m_SeqNum.c[i] > sn.m_SeqNum.c[i])
        {
            return(TRUE);
        }
        if (m_SeqNum.c[i] < sn.m_SeqNum.c[i])
        {
            return(FALSE);
        }
    }
    return(TRUE);
}
inline  CSeqNum::operator <( const CSeqNum & sn) const
{
    for ( DWORD i = 0 ; i < 8 ; i++)
    {
        if (m_SeqNum.c[i] < sn.m_SeqNum.c[i])
        {
            return(TRUE);
        }
        if (m_SeqNum.c[i] > sn.m_SeqNum.c[i])
        {
            return(FALSE);
        }
    }
    return(FALSE);
}
inline  CSeqNum::operator >( const CSeqNum & sn) const
{
    for ( DWORD i = 0 ; i < 8 ; i++)
    {
        if (m_SeqNum.c[i] > sn.m_SeqNum.c[i])
        {
            return(TRUE);
        }
        if (m_SeqNum.c[i] < sn.m_SeqNum.c[i])
        {
            return(FALSE);
        }
    }
    return(FALSE);
}
inline void CSeqNum::SetSmallestValue()
{
    m_SeqNum = MQIS_SMALLEST_SEQNUM;
}
inline const unsigned char *  CSeqNum::GetPtr() const
{
    return( m_SeqNum.c);
}

inline BOOL CSeqNum::IsInfiniteLsn() const
{
     return( !memcmp(&m_SeqNum,&MQIS_INFINITE_LSN, sizeof(_SEQNUM)));
}

inline void CSeqNum::SetInfiniteLSN()
{
    m_SeqNum = MQIS_INFINITE_LSN;
}
inline void CSeqNum::GetValue(BLOB * pblob) const
{
    pblob->cbSize = sizeof(_SEQNUM);
    pblob->pBlobData = (unsigned char *)&m_SeqNum.c[0];
}  
inline void CSeqNum::GetValueForPrint(OUT WCHAR * pBuffer) const 
{
	swprintf(pBuffer,L"%02x%02x%02x%02x%02x%02x%02x%02x",m_SeqNum.c[0],m_SeqNum.c[1],m_SeqNum.c[2],m_SeqNum.c[3],m_SeqNum.c[4],m_SeqNum.c[5],m_SeqNum.c[6],m_SeqNum.c[7]);
}
inline BOOL CSeqNum::IsSmallerByMoreThanOne( const CSeqNum & sn) const
{
    
    CSeqNum tmp( (_SEQNUM *)&m_SeqNum);
    tmp.Increment();
    return( tmp < sn);


}

inline	BOOL CSeqNum::NotGreaterByMoreThanFrom(DWORD diff, const CSeqNum &other) const
{
    CSeqNum tmpThis( (_SEQNUM *)&m_SeqNum);
	tmpThis -= diff;
	return(tmpThis < other);
}

inline CSeqNum & CSeqNum::operator = ( const CSeqNum & sn)
{
    m_SeqNum = sn.m_SeqNum;
    return(*this);
}

inline DWORD CSeqNum::GetHighDWORD() const
{
	return GetDWORD(0);
}

inline DWORD CSeqNum::GetLowDWORD() const
{
	return GetDWORD(4);
}

inline void CSeqNum::SetHighDWORD(IN DWORD dw)
{
	SetDWORD(0,dw);
}

inline void CSeqNum::SetLowDWORD(IN DWORD dw)
{
	SetDWORD(4,dw);
}

inline DWORD CSeqNum::GetDWORD(IN int offset) const
{
	unsigned char ac[4];
	int i,j;
	ASSERT(offset == 0 || offset == 4);
	for (i=0, j=offset+3; i< 4; i++,j--)
		ac[i] = m_SeqNum.c[j];
	return(*(DWORD *) ac);
}

inline void CSeqNum::SetDWORD(IN int offset, IN DWORD dw)
{
	ASSERT(offset == 0 || offset == 4);

	unsigned char * pc = (unsigned char *) &dw;
	int i,j;
	for (i=0,j=offset+3; i< 4; i++,j--)
		m_SeqNum.c[j] = pc[i];
}

inline BOOL CSeqNum::IsMultipleOf(IN DWORD dwFrequency) const
{
	return ((GetLowDWORD() % dwFrequency) == 0);
}

inline void CSeqNum::operator -= (DWORD dwSub)
{
	DWORD dwLow  = GetLowDWORD();

	if (dwSub <= dwLow)
	{
		dwLow -= dwSub;
	}
	else
	{
		DWORD dwHigh = GetHighDWORD();
		if (dwHigh > 0)
		{
			dwHigh--;
			dwLow -= dwSub;
		}
		else
		{
			dwHigh = dwLow = 0;
		}
		SetHighDWORD(dwHigh);
	}
	SetLowDWORD(dwLow);
}

inline void CSeqNum::operator += (DWORD dwAdd)
{
	DWORD dwLow  = GetLowDWORD();

	BOOL over = (dwLow + dwAdd < dwLow);

	dwLow += dwAdd;

	if (over)
	{
		DWORD dwHigh = GetHighDWORD();
		dwHigh++;

		if (dwHigh==0)
		{
			dwHigh=dwLow=0xffffffff;
		}

		SetHighDWORD(dwHigh);
	}

	SetLowDWORD(dwLow);
}

   
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\xactdefs.h ===
// We don't want include transaction files here; so redefining what we need
// BUGBUG: not too good - better to use the same definitions
#ifndef __transact_h__
#ifndef __xactdefs_h__
#define __xactdefs_h__
typedef struct  BOID
    {
    unsigned char rgb[ 16 ];
    }   BOID;

typedef BOID XACTUOW;
#endif
#endif

//class CTransaction;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\_guid.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    _guid.h

Abstract:

    Definition of a guid class 

Author:

    Ronit Hartmann (ronith) ??-???-??

--*/
#ifndef __GUID_H
#define __GUID_H
#include <fntoken.h>

//---------------------------------------------------------
//
//  Helper for GUID mappes,     CMap<GUID, const GUID&, ...>
//
//  This is the *only* instance to use. don't define your own.
//  we has as manny as 4 different flavors. erezh
//
inline UINT AFXAPI HashKey(const GUID& rGuid)
{
    //
    //  Data1 is the most changing member of a uuid.
    //  this is the fastest and the safest of all other
    //  method of hassing a guid.
    //
    return rGuid.Data1;
}


//---------------------------------------------------------
//
//  Helper for GUID mappes,     CMap<GUID*, GUID*, ...>
//
//  This is the *only* instance to use. don't define your own.
//  we has as manny as 4 different flavors. erezh
//
inline UINT AFXAPI HashKey(GUID* pGuid)
{
    //
    //  Data1 is the most changing member of a uuid.
    //  this is the fastest and the safest of all other
    //  method of hassing a guid.
    //
    return pGuid->Data1;
}


//---------------------------------------------------------
//
//  Helper for GUID mappes,     CMap<GUID*, GUID*, ...>
//
inline BOOL AFXAPI CompareElements(GUID* const* key1, GUID* const* key2)
{
    return (**key1 == **key2);
}

//---------------------------------------------------------
//
//  Convert guid into a pre-allocatd buffer
//
typedef WCHAR GUID_STRING[GUID_STR_LENGTH + 1];

inline
void
MQpGuidToString(
    const GUID* pGuid,
    GUID_STRING& wcsGuid
    )
{
    _snwprintf(
        wcsGuid,
        GUID_STR_LENGTH + 1,
        GUID_FORMAT,             // "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
        GUID_ELEMENTS(pGuid)
        );

}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\verstamp.h ===
// verstamp.h  -  project-wide macros for version info
#include "version.h"  // slm version.h
#include <winver.h>  // Windows Version Info defines

//... macros to convert slm version components to build #
// minor # padding
#if 	(rmm < 10)
#define rmmpad "0"
#else
#define rmmpad
#endif

#if 	(rup == 0)
#define VERSION_STR1(a,b,c) 		#a "." rmmpad #b
#else	/* !(rup == 0) */
#define VERSION_STR1(a,b,c) 		#a "." rmmpad #b "." ruppad #c
// build # padding
#if 	(rup < 10)
#define ruppad "000"
#elif	(rup < 100)
#define ruppad "00"
#elif	(rup < 1000)
#define ruppad "0"
#else
#define ruppad
#endif

#endif	/* !(rup == 0) */

#define VERSION_STR2(a,b,c) 		VERSION_STR1(a,b,c)
#define VER_PRODUCTVERSION_STR		VERSION_STR2(rmj,rmm,rup)
#define VER_PRODUCTVERSION			rmj,rmm,0,rup
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\_mqbegin.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    _mqbegin.h

Abstract:

    Head of Falcon SDK file mq.h

Author:

    Erez Haba (erezh) 24-Jan-96

--*/

// begin_mq_h
/*++

Copyright (c) 1996-2001, Microsoft Corporation

Module Name:

    mq.h

Abstract:

    Master include file for Message Queuing applications

--*/

#ifndef __MQ_H__
#define __MQ_H__

#if defined (_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif


#ifndef __ITransaction_FWD_DEFINED__
#define __ITransaction_FWD_DEFINED__
typedef interface ITransaction ITransaction;
#endif  // __ITransaction_FWD_DEFINED__

// end_mq_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\_mqdef.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    _mqdef.h

Abstract:

    TEMPORARY DEFINITION FILE

Author:

    Erez Haba (erezh) 17-Jan-96

--*/

#ifndef __TEMP_MQDEF_H
#define __TEMP_MQDEF_H

// begin_mq_h

#define MQ_MAX_Q_NAME_LEN      124   // Maximal WCHAR length of a queue name.
#define MQ_MAX_Q_LABEL_LEN     124
#define MQ_MAX_MSG_LABEL_LEN   250

typedef HANDLE QUEUEHANDLE;

typedef PROPID MSGPROPID;
typedef struct tagMQMSGPROPS
{
    DWORD           cProp;
    MSGPROPID*      aPropID;
    MQPROPVARIANT*  aPropVar;
    HRESULT*        aStatus;
} MQMSGPROPS;


typedef PROPID QUEUEPROPID;
typedef struct tagMQQUEUEPROPS
{
    DWORD           cProp;
    QUEUEPROPID*    aPropID;
    MQPROPVARIANT*  aPropVar;
    HRESULT*        aStatus;
} MQQUEUEPROPS;


typedef PROPID QMPROPID;
typedef struct tagMQQMPROPS
{
    DWORD           cProp;
    QMPROPID*       aPropID;
    MQPROPVARIANT*  aPropVar;
    HRESULT*        aStatus;
} MQQMPROPS;


typedef struct tagMQPRIVATEPROPS
{
    DWORD           cProp;
    QMPROPID*       aPropID;
    MQPROPVARIANT*  aPropVar;
    HRESULT*        aStatus;
} MQPRIVATEPROPS;


typedef PROPID MGMTPROPID;
typedef struct tagMQMGMTPROPS
{
    DWORD cProp;
    MGMTPROPID* aPropID;
    MQPROPVARIANT* aPropVar;
    HRESULT* aStatus;
} MQMGMTPROPS;

typedef struct tagSEQUENCE_INFO
{
    LONGLONG SeqID;
    ULONG SeqNo; 
    ULONG PrevNo;
} SEQUENCE_INFO;

    

// end_mq_h

#include <_mqreg.h>
#include <_ta.h>

#endif // __TEMP_MQDEF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\_mqini.h ===
/*++

Copyright (c) 1995-96  Microsoft Corporation

Module Name:

    _mqini.h

Abstract:

    Definitions of parameters that can be read from ini file.
    Definitions of default values.
    General definitions shared among setup and QM (YoelA, 10-Feb-97)

Author:

    Doron Juster  (DoronJ)   14-May-96  Created

--*/

#ifndef __TEMP_MQINI_H
#define __TEMP_MQINI_H

#define MSMQ_PROGRESS_REPORT_TIME_DEFAULT 900000
#define MSMQ_PROGRESS_REPORT_TIME_REGNAME TEXT("ProgressReportTime")

//---------------------------------------------------------
//  Definition for client configuration
//---------------------------------------------------------

// Registry name for remote QM machine name
#define RPC_REMOTE_QM_REGNAME     TEXT("RemoteQMMachine")

//---------------------------------------------------------
//  Definition of RPC end points
//---------------------------------------------------------

//
// If this registry does not exist (default) or it's 0 then use dynamic
// endpoints. Otherwise, use predefined ones, from registry.
// This is for MQIS interfaces.
//
#define RPC_DEFAULT_PREDEFINE_DS_EP     0
#define RPC_PREDEFINE_DS_EP_REGNAME     TEXT("UseDSPredefinedEP")
//
// as above, but for RT-QM and QM-QM interfaces.
//
#define RPC_DEFAULT_PREDEFINE_QM_EP     0
#define RPC_PREDEFINE_QM_EP_REGNAME   TEXT("UseQMPredefinedEP")

//Default local  RPC End Point between RT and QM
#define RPC_LOCAL_EP             TEXT("QMsvc")
#define RPC_LOCAL_EP_REGNAME     TEXT("RpcLocalEp")

#define RPC_LOCAL_EP2            TEXT("QMsvc2")
#define RPC_LOCAL_EP_REGNAME2    TEXT("RpcLocalEp2")

// default for RPC IP port (for QM remote read and dependent clients)
#define FALCON_DEFAULT_QM_RPC_IP_PORT   TEXT("2799")
#define FALCON_QM_RPC_IP_PORT_REGNAME   TEXT("MsmqQMRpcIpPort")

#define FALCON_DEFAULT_QM_RPC_IP_PORT2  TEXT("2801")
#define FALCON_QM_RPC_IP_PORT_REGNAME2  TEXT("MsmqQMRpcIpPort2")

// default for IPX port for RPC (for QM remote read)
#define FALCON_DEFAULT_QM_RPC_IPX_PORT  TEXT("2799")
#define FALCON_QM_RPC_IPX_PORT_REGNAME  TEXT("MsmqQMRpcIpxPort")

#define FALCON_DEFAULT_QM_RPC_IPX_PORT2 TEXT("2801")
#define FALCON_QM_RPC_IPX_PORT_REGNAME2 TEXT("MsmqQMRpcIpxPort2")

// Default local  RPC End Point between RT and MQDSSRV
#define DEFAULT_RPC_DS_LOCAL_EP     TEXT("DSLocal")
#define RPC_DS_LOCAL_EP_REGNAME     TEXT("DSRpcLocalEp")

//  Default local RPC End Point between MQAD and QM
#define DEFAULT_NOTIFY_EP           TEXT("QMNotify")

// default for RPC IP port (for DS)
#define FALCON_DEFAULT_DS_RPC_IP_PORT   TEXT("2879")
#define FALCON_DS_RPC_IP_PORT_REGNAME   TEXT("MsmqDSRpcIpPort")

// default for IPX port for RPC (for DS)
#define FALCON_DEFAULT_DS_RPC_IPX_PORT  TEXT("2879")
#define FALCON_DS_RPC_IPX_PORT_REGNAME  TEXT("MsmqDSRpcIpxPort")

//---------------------------------------------------------
//  Definition of winsock ports
//---------------------------------------------------------

// default IP port for Falcon sessions.
#define FALCON_DEFAULT_IP_PORT   1801
#define FALCON_IP_PORT_REGNAME   TEXT("MsmqIpPort")

// default IP port for ping.
#define FALCON_DEFAULT_PING_IP_PORT   3527
#define FALCON_PING_IP_PORT_REGNAME   TEXT("MsmqIpPingPort")


// Default for ack timeout
#define MSMQ_DEFAULT_ACKTIMEOUT  5000
#define MSMQ_ACKTIMEOUT_REGNAME  TEXT("AckTimeout")

// Default for Storage ack timeout
#define MSMQ_DEFAULT_STORE_ACKTIMEOUT  500
#define MSMQ_STORE_ACKTIMEOUT_REGNAME  TEXT("StoreAckTimeout")

// Default for Idle acknowledge delay (in milisecond)
#define MSMQ_DEFAULT_IDLE_ACK_DELAY 500
#define MSMQ_IDLE_ACK_DELAY_REGNAME  TEXT("IdleAckDelay")

// Default size for remove duplicate tabel
#define MSMQ_DEFAULT_REMOVE_DUPLICATE_SIZE 10000
#define MSMQ_REMOVE_DUPLICATE_SIZE_REGNAME  TEXT("RemoveDuplicateSize")

// Default interval for remove duplicate tabel cleanup
#define MSMQ_DEFAULT_REMOVE_DUPLICATE_CLEANUP (30 * 60 * 1000)
#define MSMQ_REMOVE_DUPLICATE_CLEANUP_REGNAME  TEXT("RemoveDuplicateCleanup")


// Default for Max Unacked Packet
#ifdef _DEBUG
#define MSMQ_DEFAULT_WINDOW_SIZE_PACKET  32
#else
#define MSMQ_DEFAULT_WINDOW_SIZE_PACKET  64
#endif
#define MSMQ_MAX_WINDOW_SIZE_REGNAME  TEXT("MaxUnackedPacket")

// Default for Cleanup interval
#define MSMQ_DEFAULT_SERVER_CLEANUP    120000
#define MSMQ_DEFAULT_CLIENT_CLEANUP    300000

// QoS session should be cleaned up less frequently than
// regular sessions, because it takes more time to
// establish a QoS session.
// By default, QoS sessions cleanup time is twice as large as
// the regular cleanup time
#define MSMQ_DEFAULT_QOS_CLEANUP_MULTIPLIER 2

#define MSMQ_CLEANUP_INTERVAL_REGNAME  TEXT("CleanupInterval")
#define MSMQ_QOS_CLEANUP_INTERVAL_MULTIPLIER_REGNAME  TEXT("QosCleanupIntervalMultiplier")

#define MSMQ_DEFAULT_MESSAGE_CLEANUP    (6 * 60 * 60 * 1000)
#define MSMQ_MESSAGE_CLEANUP_INTERVAL_REGNAME  TEXT("MessageCleanupInterval")

//
// Default time interval for refreshing the DS servers list
//
// Default time interval for refreshing the DS current site servers list and Longlive time (in hours - 7 days)
#define MSMQ_DEFAULT_DS_SITE_LIST_REFRESH  (7 * 24)
#define MSMQ_DS_SITE_LIST_REFRESH_REGNAME  TEXT("DSSiteListRefresh")

// Default time interval for refreshing the DS enterprise data -  sites / servers list
// (in hours - 28 days)
#define MSMQ_DEFAULT_DS_ENTERPRISE_LIST_REFRESH  (28 * 24)
#define MSMQ_DS_ENTERPRISE_LIST_REFRESH_REGNAME  TEXT("DSEnterpriseListRefresh")

// Default time interval for refreshing the DS lists, in case the previous call failed
// (in Minutes - 1 hour)
#define MSMQ_DEFAULT_DSLIST_REFRESH_ERROR_RETRY_INTERVAL  60
#define MSMQ_DSLIST_REFRESH_ERROR_RETRY_INTERVAL          TEXT("DSListRefreshErrorRetryInterval")

//
// Next Site and enterprise refresh times
// This values are quad word and set by the QM (should not be set manually)
// However, deleting these values from the registry will cause Site / Enterprise
// refresh on the next QM startup (YoelA - 23-Oct-2000)
//
#define MSMQ_DS_NEXT_SITE_LIST_REFRESH_TIME_REGNAME        TEXT("DSNextSiteListRefreshTime")
#define MSMQ_DS_NEXT_ENTERPRISE_LIST_REFRESH_TIME_REGNAME  TEXT("DSNextEnterpriseListRefreshTime")

// Default time interval for updating the DS (5 minutes)
#define MSMQ_DEFAULT_DSUPDATE_INTERVAL  (5 * 60 * 1000)
#define MSMQ_DSUPDATE_INTERVAL_REGNAME  TEXT("DSUpdateInterval")

// Default time interval for updating the sites information in the DS (12 hours)
#define MSMQ_DEFAULT_SITES_UPDATE_INTERVAL  (12 * 60 * 60 * 1000)
#define MSMQ_SITES_UPDATE_INTERVAL_REGNAME  TEXT("SitesUpdateInterval")

// Minimum interval between successive ADS searches to find DS servers (in seconds) (30 minutes)
#define MSMQ_DEFAULT_DSCLI_ADSSEARCH_INTERVAL  (60 * 30)
#define MSMQ_DSCLI_ADSSEARCH_INTERVAL_REGNAME  TEXT("DSCliSearchAdsForServersIntervalSecs")

// Minimum interval between successive ADS searches to refresh IPSITE mapping (in seconds) (60 minutes)
#define MSMQ_DEFAULT_IPSITE_ADSSEARCH_INTERVAL  (60 * 60)
#define MSMQ_IPSITE_ADSSEARCH_INTERVAL_REGNAME  TEXT("DSAdsRefreshIPSitesIntervalSecs")

// For generating write requests
// Minimum interval between successive ADS searches to refresh NT4SITES mapping (in seconds) (6 hours)
#define MSMQ_DEFAULT_NT4SITES_ADSSEARCH_INTERVAL  (60 * 60 * 6)
#define MSMQ_NT4SITES_ADSSEARCH_INTERVAL_REGNAME  TEXT("DSAdsRefreshNT4SitesIntervalSecs")

// Default driver and service name
#define MSMQ_DEFAULT_DRIVER      TEXT("MQAC")
#define MSMQ_DRIVER_REGNAME      TEXT("DriverName")
#define QM_DEFAULT_SERVICE_NAME  TEXT("MSMQ")

// Name of storage folders
#define MSMQ_STORE_RELIABLE_PATH_REGNAME        TEXT("StoreReliablePath")
#define MSMQ_STORE_PERSISTENT_PATH_REGNAME      TEXT("StorePersistentPath")
#define MSMQ_STORE_JOURNAL_PATH_REGNAME         TEXT("StoreJournalPath")
#define MSMQ_STORE_LOG_PATH_REGNAME             TEXT("StoreLogPath")


//name of the queue mapping folder
#define MSMQ_MAPPING_PATH_REGNAME   TEXT("QueuesAliasPath")


// Deafult size of memory mapped file
#define MSMQ_MESSAGE_SIZE_LIMIT_REGNAME         TEXT("MaxMessageSize")
#define MSMQ_DEFAULT_MESSAGE_SIZE_LIMIT         (4 * 1024 * 1024)

// Next message ID to be used (low order 32 bit)
#define MSMQ_MESSAGE_ID_LOW_32_REGNAME                 TEXT("MessageID")

// Next message ID to be used (high order 32 bit)
#define MSMQ_MESSAGE_ID_HIGH_32_REGNAME                TEXT("MessageIdHigh32")

// Current SeqID value at the last restore time
#define MSMQ_LAST_SEQID_REGNAME                 TEXT("SeqIDAtLastRestore")

// Next SeqID to be used
#define MSMQ_SEQ_ID_REGNAME                 TEXT("SeqID")

//
// Name of DS servers.
//
// MQISServer is the list of MQIS servers in present site. This list is not
//      present when machine is in workgroup mode.
// CurrentMQISServer is an online MQIS server found by the msmq service.
//
// LkgMQISServer is the LastKnownGood list. this is used to fix 4723.
//
#define MSMQ_DEFAULT_DS_SERVER         TEXT("\\\\")
#define MSMQ_DS_SERVER_REGVALUE        TEXT("MQISServer")
#define MSMQ_DS_SERVER_REGNAME         TEXT("MachineCache\\MQISServer")
#define MSMQ_DS_CURRENT_SERVER_REGNAME \
                                   TEXT("MachineCache\\CurrentMQISServer")
#define MAX_REG_DSSERVER_LEN  1500
#define DS_SERVER_SEPERATOR_SIGN    ','

// Static DS server option
#define MSMQ_STATIC_DS_SERVER_REGNAME TEXT("MachineCache\\StaticMQISServer")

//
// When automatic search for msmq server on domain controller fail, or return
// no result, then this registry entry is read. If available, then this is
// the result of the "automatic" search. See ds\getmqds\getmqds.cpp.
//
#define MSMQ_FORCED_DS_SERVER_REGNAME TEXT("MachineCache\\ForcedDSServer")

// DS server per thread
#define MSMQ_THREAD_DS_SERVER_REGNAME TEXT("MachineCache\\PerThreadDSServer")
#define MSMQ_DEFAULT_THREAD_DS_SERVER   0

// Name of MQ service
#define MSMQ_MQS_REGNAME                TEXT("MachineCache\\MQS")
#define MSMQ_MQS_ROUTING_REGNAME        TEXT("MachineCache\\MQS_Routing")
#define MSMQ_MQS_DSSERVER_REGNAME       TEXT("MachineCache\\MQS_DsServer")
#define MSMQ_MQS_DEPCLINTS_REGNAME      TEXT("MachineCache\\MQS_DepClients")

// Name of MQIS write message timeout
#define MSMQ_MQIS_WRITETIMEOUT_REGNAME  TEXT("WriteMsgTimeout")

// Name of QM id
#define MSMQ_QMID_REGVALUE  TEXT("QMId")
#define MSMQ_QMID_REGNAME   TEXT("MachineCache\\QMId")

// Dependent client Supporting Server QM id
#define MSMQ_SUPPORT_SERVER_QMID_REGVALUE	TEXT("ServerQMId")
#define MSMQ_SUPPORT_SERVER_QMID_REGNAME	TEXT("MachineCache\\ServerQMId")

// Name of DS Security Cache
#define MSMQ_DS_SECURITY_CACHE_REGNAME TEXT("DsSecurityCache")

// Name of site id
#define MSMQ_SITEID_REGNAME     TEXT("MachineCache\\SiteId")
#define MSMQ_SITENAME_REGNAME   TEXT("MachineCache\\SiteName")

// Name of enterprise id
#define MSMQ_ENTERPRISEID_REGNAME   TEXT("MachineCache\\EnterpriseId")

// Name of MQIS master id
#define MSMQ_MQIS_MASTERID_REGNAME  TEXT("MachineCache\\MasterId")

// Name of key for servers cache.
#define MSMQ_SERVERS_CACHE_REGNAME  TEXT("ServersCache")

// machine quota
#define MSMQ_MACHINE_QUOTA_REGNAME TEXT("MachineCache\\MachineQuota")

// Machine journal quota
#define MSMQ_MACHINE_JOURNAL_QUOTA_REGNAME TEXT("MachineCache\\MachineJournalQuota")

// Default for transaction crash point
#define FALCON_DEFAULT_CRASH_POINT    0
#define FALCON_CRASH_POINT_REGNAME    TEXT("XactCrashPoint")

// Default for transaction crash latency
#define FALCON_DEFAULT_CRASH_LATENCY  0
#define FALCON_CRASH_LATENCY_REGNAME  TEXT("XactCrashLatency")

// Name & Default for transaction Commit/Abort internal retry
#define FALCON_DEFAULT_XACT_RETRY_INTERVAL   300
#define FALCON_XACT_RETRY_REGNAME             TEXT("XactAbortCommitRetryInterval")

// Name & Default for transaction v1 Compatibility Mode
#define FALCON_DEFAULT_XACT_V1_COMPATIBLE   0
#define FALCON_XACT_V1_COMPATIBLE_REGNAME   TEXT("XactDeadLetterAlways")

// Name for the delay of local receive expiration for transacted messages
#define FALCON_XACT_DELAY_LOCAL_EXPIRE_REGNAME  TEXT("XactDelayReceiveNack")

// Default for sequential acks resend time
#define FALCON_DEFAULT_SEQ_ACK_RESEND_TIME  60
#define FALCON_SEQ_ACK_RESEND_REGNAME  TEXT("SeqAckResendTime")

// Default for ordered resend times: 1-3, 4-6, 7-9, all further
#define FALCON_DEFAULT_ORDERED_RESEND13_TIME  30
#define FALCON_ORDERED_RESEND13_REGNAME  TEXT("SeqResend13Time")

#define FALCON_DEFAULT_ORDERED_RESEND46_TIME  (5 * 60)
#define FALCON_ORDERED_RESEND46_REGNAME  TEXT("SeqResend46Time")

#define FALCON_DEFAULT_ORDERED_RESEND79_TIME  (30 * 60)
#define FALCON_ORDERED_RESEND79_REGNAME  TEXT("SeqResend79Time")

#define FALCON_DEFAULT_ORDERED_RESEND10_TIME  (6 * 60 * 60)
#define FALCON_ORDERED_RESEND10_REGNAME  TEXT("SeqResend10Time")

// Debugging lever: all resend times the same
#define FALCON_DBG_RESEND_REGNAME       TEXT("XactResendTime")

// Max delay for sending ordering ack
#define FALCON_MAX_SEQ_ACK_DELAY                10
#define FALCON_MAX_SEQ_ACK_DELAY_REGNAME  TEXT("SeqMaxAckDelay")

// Interval(minutes) for QM to check for inactive sequences and delete them
#define FALCON_DEFAULT_INSEQS_CHECK_INTERVAL    60 * 24
#define FALCON_INSEQS_CHECK_REGNAME             TEXT("InSeqCheckInterval")

// Interval(days) for QM to clean away inactive sequences
#define FALCON_DEFAULT_INSEQS_CLEANUP_INTERVAL  90
#define FALCON_INSEQS_CLEANUP_REGNAME           TEXT("InSeqCleanupInterval")

// Interval(msec) for log manager to check if the flush/chkpoint is needed
#define FALCON_DEFAULT_LOGMGR_TIMERINTERVAL     10
#define FALCON_LOGMGR_TIMERINTERVAL_REGNAME     TEXT("LogMgrTimerInterval")

// Max interval (msec) for log manager flushes (if there was no other reason to do it before)
#define FALCON_DEFAULT_LOGMGR_FLUSHINTERVAL     50
#define FALCON_LOGMGR_FLUSHINTERVAL_REGNAME     TEXT("LogMgrFlushInterval")

// Max interval (msec) for log manager internal checkpoints (if there was no other reason to do it before)
#define FALCON_DEFAULT_LOGMGR_CHKPTINTERVAL     10000
#define FALCON_LOGMGR_CHKPTINTERVAL_REGNAME     TEXT("LogMgrChkptInterval")

// Log manager buffers number
#define FALCON_DEFAULT_LOGMGR_BUFFERS           400
#define FALCON_LOGMGR_BUFFERS_REGNAME           TEXT("LogMgrBuffers")

// Log manager file size
#define FALCON_DEFAULT_LOGMGR_SIZE              0x600000
#define FALCON_LOGMGR_SIZE_REGNAME              TEXT("LogMgrFileSize")

// Log manager sleep time if not enough append asynch threads
#define FALCON_DEFAULT_LOGMGR_SLEEP_ASYNCH      500
#define FALCON_LOGMGR_SLEEP_ASYNCH_REGNAME      TEXT("LogMgrSleepAsynch")

// Log manager append asynch repeat limit
#define FALCON_DEFAULT_LOGMGR_REPEAT_ASYNCH     100
#define FALCON_LOGMGR_REPEAT_ASYNCH_REGNAME     TEXT("LogMgrRepeatAsynchLimit")

// Falcon interval (msec) for probing log manager flush
#define FALCON_DEFAULT_LOGMGR_PROBE_INTERVAL    100
#define FALCON_LOGMGR_PROBE_INTERVAL_REGNAME    TEXT("LogMgrProbeInterval")

// Resource manager checkpoints period (msec)
#define FALCON_DEFAULT_RM_FLUSH_INTERVAL        1800000
#define FALCON_RM_FLUSH_INTERVAL_REGNAME        TEXT("RMFlushInterval")

// Resource manager client name
#define FALCON_DEFAULT_RM_CLIENT_NAME           TEXT("Falcon")
#define FALCON_RM_CLIENT_NAME_REGNAME           TEXT("RMClientName")

// RT stub RM name
#define FALCON_DEFAULT_STUB_RM_NAME             TEXT("StubRM")
#define FALCON_RM_STUB_NAME_REGNAME             TEXT("RMStubName")

// Transactions persistant file location
#define FALCON_DEFAULT_XACTFILE_PATH            TEXT("MQTrans")
#define FALCON_XACTFILE_PATH_REGNAME            TEXT("StoreXactLogPath")
#define FALCON_XACTFILE_REFER_NAME              TEXT("Transactions")

// Incoming sequences persistant file location
#define FALCON_DEFAULT_INSEQFILE_PATH           TEXT("MQInSeqs")
#define FALCON_INSEQFILE_PATH_REGNAME           TEXT("StoreInSeqLogPath")
#define FALCON_INSEQFILE_REFER_NAME             TEXT("Incoming Sequences")

// Outgoming sequences persistant file location
#define FALCON_DEFAULT_OUTSEQFILE_PATH          TEXT("MQOutSeqs")
#define FALCON_OUTSEQFILE_PATH_REGNAME          TEXT("StoreOutSeqLogPath")
#define FALCON_OUTSEQFILE_REFER_NAME            TEXT("Outgoing Sequences")

// Logger file
#define FALCON_DEFAULT_LOGMGR_PATH              TEXT("QMLog")
#define FALCON_LOGMGR_PATH_REGNAME              TEXT("StoreMqLogPath")

// Logger data are created
#define FALCON_LOGDATA_CREATED_REGNAME          TEXT("LogDataCreated")

// Default for TIME_TO_REACH_QUEUE (90 days, in seconds).
#define MSMQ_LONG_LIVE_REGNAME        TEXT("MachineCache\\LongLiveTime")
#define MSMQ_DEFAULT_LONG_LIVE       (90 * 24 * 60 * 60)

// Expiration time of entries in the base crypto key cache.
#define CRYPT_KEY_CACHE_DEFAULT_EXPIRATION_TIME (60000 * 10) // 10 minutes.
#define CRYPT_KEY_CACHE_EXPIRATION_TIME_REG_NAME TEXT("CryptKeyExpirationTime")

// Expiration time of entries in the enhanced crypto key cache.
#define CRYPT_KEY_ENH_CACHE_DEFAULT_EXPIRATION_TIME		(60000 * 60 * 12) // 12 hours.
#define CRYPT_KEY_ENH_CACHE_EXPIRATION_TIME_REG_NAME	TEXT("CryptKeyEnhExpirationTime")

// Cache size for send crypto keys.
#define CRYPT_SEND_KEY_CACHE_DEFAULT_SIZE       53
#define CRYPT_SEND_KEY_CACHE_REG_NAME           TEXT("CryptSendKeyCacheSize")

// Cache size for receive crypto keys.
#define CRYPT_RECEIVE_KEY_CACHE_DEFAULT_SIZE    127
#define CRYPT_RECEIVE_KEY_CACHE_REG_NAME        TEXT("CryptReceiveKeyCacheSize")

// Certificate info cache.
#define CERT_INFO_CACHE_DEFAULT_EXPIRATION_TIME      (60000 * 20) // 20 minutes.
#define CERT_INFO_CACHE_EXPIRATION_TIME_REG_NAME     TEXT("CertInfoCacheExpirationTime")
#define CERT_INFO_CACHE_DEFAULT_SIZE            53
#define CERT_INFO_CACHE_SIZE_REG_NAME           TEXT("CertInfoCacheSize")

// QM public key cache.
#define QM_PB_KEY_CACHE_DEFAULT_EXPIRATION_TIME      (60000 * 45) // 45 minutes.
#define QM_PB_KEY_CACHE_EXPIRATION_TIME_REG_NAME     TEXT("QmPbKeyCacheExpirationTime")
#define QM_PB_KEY_CACHE_DEFAULT_SIZE            53
#define QM_PB_KEY_CACHE_SIZE_REG_NAME           TEXT("QmPbKeyCacheSize")

// User authz context info cache.
#define USER_CACHE_DEFAULT_EXPIRATION_TIME      (60000 * 30) // 30 minutes.
#define USER_CACHE_EXPIRATION_TIME_REG_NAME     TEXT("UserCacheExpirationTime")
#define USER_CACHE_SIZE_DEFAULT_SIZE            253
#define USER_CACHE_SIZE_REG_NAME                TEXT("UserCacheSize")

//---------------------------------------------------------
// Definition for private system queues
//---------------------------------------------------------

#define MSMQ_MAX_PRIV_SYSQUEUE_REGNAME   TEXT("MaxSysQueue")
#define MSMQ_PRIV_SYSQUEUE_PRIO_REGNAME  TEXT("SysQueuePriority")
//
// the default for private system queue priority is defined in
// mqprops.h:
// #define DEFAULT_SYS_Q_BASEPRIORITY  0x7fff
//

//---------------------------------------------------------
//  Wolfpack support
//---------------------------------------------------------

// cluster name
#define FALCON_CLUSTER_NAME_REGNAME  TEXT("ClusterName")


//
// see session.cpp for code and usage
// This registry is to revert the session behavior for
// the cluster node to not binding specifically to an IP for
// outgoing connection
//
#define MSMQ_DEFAULT_CLUSTER_NOT_BIND_ALL_IP   0
#define MSMQ_CLUSTER_BIND_ALL_IP	            TEXT("ClusterBindAllIP")



//---------------------------------------------------------
//  Definition for threads pool used in remote read.
//---------------------------------------------------------

// Maximum number of threads.
#define FALCON_DEFUALT_MAX_RRTHREADS_WKS     24
#define FALCON_DEFUALT_MAX_RRTHREADS_SRV     96
#define FALCON_MAX_RRTHREADS_REGNAME         TEXT("MaxRRThreads")

// Minimum number of threads to be kept alive, even if idle.
#define FALCON_DEFUALT_MIN_RRTHREADS_WKS     4
#define FALCON_DEFUALT_MIN_RRTHREADS_SRV     16
#define FALCON_MIN_RRTHREADS_REGNAME         TEXT("MinRRThreads")

// time to live while idel. in milliseconds.
#define FALCON_DEFAULT_RRTHREAD_TTL_WKS      (2 * 60 * 1000)
#define FALCON_DEFAULT_RRTHREAD_TTL_SRV      (5 * 60 * 1000)
#define FALCON_RRTHREAD_TTL_REGNAME          TEXT("RRThreadIdleTTL")

//---------------------------------------------------------
//  Definition for licensing
//---------------------------------------------------------

// maximum number of connections per server (limitted server on NTS).
#define DEFAULT_FALCON_SERVER_MAX_CLIENTS  25

// number of allowed sessions for clients.
#define DEFAULT_FALCON_MAX_SESSIONS_WKS    10

//----------------------------------------------------------
//  Definition for RPC cancel
//----------------------------------------------------------

#define FALCON_DEFAULT_RPC_CANCEL_TIMEOUT       ( 5 )	// 5 minutes
#define FALCON_RPC_CANCEL_TIMEOUT_REGNAME       TEXT("RpcCancelTimeout")

//----------------------------------------------------------
//  General definitions shared among setup and QM
//----------------------------------------------------------

// Registry name for MSMQ root folder
#define MSMQ_ROOT_PATH                  TEXT("MsmqRootPath")

#define MQ_SETUP_CN GUID_NULL

// Registry name for sysprep environment (NT disk image duplication)
#define MSMQ_SYSPREP_REGNAME            TEXT("Sysprep")

// Registry name for workgroup environment
#define MSMQ_WORKGROUP_REGNAME          TEXT("Workgroup")

// Registry name for allowing NT4 users to connect to DC
#define MSMQ_ALLOW_NT4_USERS_REGNAME	TEXT("AllowNt4Users")

// Registry name for disabling weaken security
#define MSMQ_DISABLE_WEAKEN_SECURITY_REGNAME	TEXT("DisableWeakenSecurity")

// Registry for converting packet sequential id to msmq 3.0 (whistler) format
#define MSMQ_SEQUENTIAL_ID_MSMQ3_FORMAT_REGNAME  TEXT("PacketSequentialIdMsmq3Format")

// Registry for installation status
#define MSMQ_SETUP_STATUS_REGNAME       TEXT("SetupStatus")
#define MSMQ_SETUP_DONE                 0
#define MSMQ_SETUP_FRESH_INSTALL        1
#define MSMQ_SETUP_UPGRADE_FROM_NT      2
#define MSMQ_SETUP_UPGRADE_FROM_WIN9X   3

#define MSMQ_CURRENT_BUILD_REGNAME      TEXT("CurrentBuild")
#define MSMQ_PREVIOUS_BUILD_REGNAME     TEXT("PreviousBuild")

//
// The following registry values are used by setup to cache values that
// are later used by the msmq service when it create the msmqConfiguration
// object.
//
// Registry name for creating msmqConfiguration object
#define MSMQ_CREATE_CONFIG_OBJ_REGNAME  TEXT("setup\\CreateMsmqObj")

// Registry name for OS type.
#define MSMQ_OS_TYPE_REGNAME            TEXT("setup\\OSType")

// Registry name for SID of user that run setup
#define MSMQ_SETUP_USER_SID_REGNAME      TEXT("setup\\UserSid")
//
// if setup from local user, then following REG_DWORD registry
// has the value 1.
//
#define MSMQ_SETUP_USER_LOCAL_REGNAME    TEXT("setup\\LocalUser")

//
// This dword indicate whether or not upgrade of BSC was complete. This
// upgrade is done by the msmq service. When starting, this dword is set
// to 1. When completing, it's set to 0. So if machine crash in middle of
// upgrade, we can resume after boot.
//
#define MSMQ_BSC_NOT_YET_UPGRADED_REGNAME  TEXT("setup\\BscNotYetUpgraded")
#define MSMQ_SETUP_BSC_ALREADY_UPGRADED    0
#define MSMQ_SETUP_BSC_NOT_YET_UPGRADED    1

//
// Hresult of creating the msmq configuration object.
// This key should contain only one value, because the setup UI wait until
// this value is modified.
//
#define MSMQ_CONFIG_OBJ_RESULT_KEYNAME   TEXT("setupResult")
#define MSMQ_CONFIG_OBJ_RESULT_REGNAME   TEXT("setupResult\\MsmqObjResult")


//----------------------------------------------------------
//  General directory definitions shared among setup and QM
//----------------------------------------------------------
#define  DIR_MSMQ                TEXT("\\msmq")             // Root dir for MSMQ
#define  DIR_MSMQ_STORAGE        TEXT("\\storage")		    // Under MSMQ root
#define  DIR_MSMQ_LQS            TEXT("\\storage\\lqs")     // Under MSMQ root
#define  DIR_MSMQ_MAPPING        TEXT("\\mapping")          // Under MSMQ root
#define  DIR_MSMQ_WEB            TEXT("\\web")

//----------------------------------------------------
//  Registry values used for join/leave domain
//----------------------------------------------------

// Registry name for machine's domain. Used for join/leave domain.
#define MSMQ_MACHINE_DOMAIN_REGNAME     TEXT("setup\\MachineDomain")

// Registry name for machine's distinguished name (in active directory).
// Used for join/leave domain.
#define MSMQ_MACHINE_DN_REGNAME         TEXT("setup\\MachineDN")

// Registry name for always remaining in workgroup.
#define MSMQ_SETUP_KEY              TEXT("setup\\")
#define ALWAYS_WITHOUT_DS_NAME      TEXT("AlwaysWithoutDS")
#define MSMQ_ALWAYS_WORKGROUP_REGNAME  \
      (MSMQ_SETUP_KEY ALWAYS_WITHOUT_DS_NAME)

#define DEFAULT_MSMQ_ALWAYS_WORKGROUP     0

// Registry name for join status. This is used to implement "transaction"
// semantic in the code that automatically join msmq to a domain.
#define MSMQ_JOIN_STATUS_REGNAME        TEXT("setup\\JoinStatus")
#define MSMQ_JOIN_STATUS_START_JOINING          1
#define MSMQ_JOIN_STATUS_JOINED_SUCCESSFULLY    2
#define MSMQ_JOIN_STATUS_FAIL_TO_JOIN           3
#define MSMQ_JOIN_STATUS_UNKNOWN                4

//------------------------------------------------------------------
// Registry name for Ds Environment
//------------------------------------------------------------------
#define MSMQ_DS_ENVIRONMENT_REGNAME				TEXT("DsEnvironment")
#define MSMQ_DS_ENVIRONMENT_UNKNOWN             0
#define MSMQ_DS_ENVIRONMENT_MQIS				1
#define MSMQ_DS_ENVIRONMENT_PURE_AD				2

//------------------------------------------------------------------
// Registry name for enabling local user (force the use of dscli)
//------------------------------------------------------------------
#define MSMQ_ENABLE_LOCAL_USER_REGNAME			TEXT("EnableLocalUser")

//------------------------------------------------------------------
// Registry name for disabling downlevel notification support
//------------------------------------------------------------------
#define MSMQ_DOWNLEVEL_REGNAME				TEXT("DisableDownlevelNotifications")
#define DEFAULT_DOWNLEVEL                   0


//---------------------------------------------------------
//  General definition for controling QM operation
//---------------------------------------------------------
#define FALCON_WAIT_TIMEOUT_REGNAME     TEXT("WaitTime")
#define FALCON_USING_PING_REGNAME       TEXT("UsePing")
#define FALCON_QM_THREAD_NO_REGNAME     TEXT("QMThreadNo")
#define FALCON_CONNECTED_NETWORK        TEXT("Connection State")
#define MSMQ_DEFERRED_INIT_REGNAME      TEXT("DeferredInit")
#define MSMQ_TCP_NODELAY_REGNAME        TEXT("TCPNoDelay")
#define MSMQ_DELIVERY_RETRY_TIMEOUT_SCALE_REGNAME     TEXT("DeliveryRetryTimeOutScale")
#define DEFAULT_MSMQ_DELIVERY_RETRY_TIMEOUT_SCALE     1




//---------------------------------------------------------
//  Registry used for QoS
//---------------------------------------------------------
#define MSMQ_USING_QOS_REGNAME             TEXT("UseQoS")
#define DEFAULT_MSMQ_QOS_SESSION_APP_NAME  "Microsoft Message Queuing"
#define MSMQ_QOS_SESSIONAPP_REGNAME        TEXT("QosSessAppName")

#define DEFAULT_MSMQ_QOS_POLICY_LOCATOR    "GUID=http://www.microsoft.com/App=MSMQ/VER=2.000/SAPP=Express"
#define MSMQ_QOS_POLICYLOCATOR_REGNAME     TEXT("QosSessPolicyLoc")


//
// QFE for Ford.
// Allocate more bytes when creating packet in driver, so packet is same
// when copied to connector. see session.cpp. Default- 0.
//
#define MSMQ_ALLOCATE_MORE_REGNAME      TEXT("AllocateMore")

//---------------------------------------------------------
//  Registry used for transaciton mode (default commit, default abort)
//---------------------------------------------------------
#define MSMQ_TRANSACTION_MODE_REGNAME   TEXT("TransactionMode")
#define MSMQ_FORCE_NOT_TRANSACTION_MODE_SWITCH_REGNAME TEXT("ForceNoTransactionModeSwitch")
#define MSMQ_ACTIVE_NODE_ID_REGNAME		TEXT("ActiveNodeId")

//---------------------------------------------------------
//
//  Registry used for server authentication.
//
//---------------------------------------------------------

// Use server authentication when communicating via RPC
// with the parent server (BSC->PSC, PSC->PEC)
#define DEFAULT_SRVAUTH_WITH_PARENT           1
#define SRVAUTH_WITH_PARENT_REG_NAME      TEXT("UseServerAuthWithParentDs")

//
// Crypto Store where server certificate is placed.
//
#define SRVAUTHN_STORE_NAME_REGNAME    TEXT("security\\ServerCertStore")
//
// Digest (16 bytes) of server certificate.
//
#define SRVAUTHN_CERT_DIGEST_REGNAME   TEXT("security\\ServerCertDigest")

//
// This bit is set by setup, if user select the "secure comm" check box,
// meaning that he always, and unconditionally, want to have server
// authentication.
//
#define MSMQ_SECURE_DS_COMMUNICATION_REGNAME    \
                                    TEXT("Security\\SecureDSCommunication")
#define MSMQ_DEFAULT_SECURE_DS_COMMUNICATION    0

//---------------------------------------------------------
//
//  Registry used for message authentication.
//
//---------------------------------------------------------

//
// DWORD.
// When 1, only messages with enhanced authentication are accepted.
// Messages with only msmq1.0 signature are rejected.
//
#define  DEFAULT_USE_ONLY_ENH_MSG_AUTHN  0
#define  USE_ONLY_ENH_MSG_AUTHN_REGNAME  TEXT("security\\RcvOnlyEnhMsgAuthn")

//
// DWORD.
// When 2, MQSend compute only the msmq1.0 signature, unless MSMQ20 was
// specified by caller.
// When 4, MQSend compute only the win2k signature, unless MSMQ10 was
// specified by caller.
// when 1, compute both signatures, unless caller specify what he wants.
// These values match those for PROPID_M_AUTH_LEVEL in mqprops.h
//
#define  DEFAULT_SEND_MSG_AUTHN   2
#define  SEND_MSG_AUTHN_REGNAME   TEXT("security\\SendMsgAuthn")

//---------------------------------------------------------
//
//  Registry used for client certificates.
//
//---------------------------------------------------------

//
// Enable (or disable) auto registration of internal certificate.
// Enabled by default.
//
#define AUTO_REGISTER_INTCERT_REGNAME  TEXT("security\\AutoRegisterIntCert")
#define DEFAULT_AUTO_REGISTER_INTCERT  1

//
// used for mqrt to tell what error was encountered while trying to
// register a certificate at logon.
//
#define AUTO_REGISTER_ERROR_REGNAME  TEXT("AutoRegisterError")

//
// Time to wait until domain controller MSMQ server is up and running.
// this value is number of 15 seconds internal.
// default 40 mean 10 minutes (40 * 15 seconds).
//
#define AUTO_REGISTER_WAIT_DC_REGNAME  \
                                TEXT("security\\AutoIntCertWaitIntervals")
#define DEFAULT_AUTO_REGISTER_WAIT_DC  40

//
// Value under HKCU that is set to 1 after auto registration succeed.
//
#define CERTIFICATE_REGISTERD_REGNAME  TEXT("CertificateRegistered")

//
// Value under HKCU that is set to 1 when the certificate exist on the local store
// but not registered in the DS
//
#define CERTIFICATE_SHOULD_REGISTERD_IN_DS_REGNAME  TEXT("ShouldRegisterCertInDs")

//
// Name and value of registry under the "Run" key
//
#define RUN_INT_CERT_REGNAME           TEXT("MsmqIntCert")
#define DEFAULT_RUN_INT_CERT           TEXT("regsvr32 /s mqrt.dll")

//+--------------------------------------------
//
//  Registry used for caching machine account
//
//+--------------------------------------------

//
// sid of machine account.
//
#define MACHINE_ACCOUNT_REGNAME   TEXT("security\\MachineAccount")

//+--------------------------------------------
//
//  Registry used for authz flags
//
//+--------------------------------------------

//
// authz flags.
//
#define MSMQ_AUTHZ_FLAGS_REGNAME   TEXT("security\\AuthzFlags")

#define MSMQ_AUTHZ_FLAGS_REGKEY   TEXT("security")
#define MSMQ_AUTHZ_FLAGS_REGVALUE   TEXT("AuthzFlags")

//+-----------------------------------------------------------------------
//
//  Registry used for marking lqs files Security descriptor was updated
//
//+-----------------------------------------------------------------------

#define MSMQ_LQS_UPDATED_SD_REGNAME   TEXT("security\\LqsUpdatedSD")

//+--------------------------------------------
//
//  Registry used for encryption
//
//+--------------------------------------------

//
// Regname for name of Crypto container.
//
#define MSMQ_CRYPTO40_DEFAULT_CONTAINER         TEXT("MSMQ")
#define MSMQ_CRYPTO40_CONTAINER_REG_NAME    \
                                     TEXT("security\\Crypto40Container")

#define MSMQ_CRYPTO128_DEFAULT_CONTAINER        TEXT("MSMQ_128")
#define MSMQ_CRYPTO128_CONTAINER_REG_NAME   \
                                     TEXT("security\\Crypto128Container")

//
// Because of a bug in beta3 and rc1 crypto api, control panel can not
// renew crypto key. To workaround, on first boot, first time the service
// acquire the crypto provider, it sets again the container security.
//
#define MSMQ_ENH_CONTAINER_FIX_REGNAME   TEXT("security\\EnhContainerFixed")
#define MSMQ_BASE_CONTAINER_FIX_REGNAME  TEXT("security\\BaseContainerFixed")

//
// Regname for name of Crypto container, to be used by the mqforgn tool.
//
#define MSMQ_FORGN_BASE_DEFAULT_CONTAINER      TEXT("MSMQ_FOREIGN_BASE")
#define MSMQ_FORGN_BASE_KEY_REGNAME            TEXT("security\\")
#define MSMQ_FORGN_BASE_VALUE_REGNAME          TEXT("ForeignBaseContainer")
#define MSMQ_FORGN_BASE_CONTAINER_REGNAME   \
             (MSMQ_FORGN_BASE_KEY_REGNAME  MSMQ_FORGN_BASE_VALUE_REGNAME)

#define MSMQ_FORGN_ENH_DEFAULT_CONTAINER      TEXT("MSMQ_FOREIGN_ENH")
#define MSMQ_FORGN_ENH_KEY_REGNAME            TEXT("security\\")
#define MSMQ_FORGN_ENH_VALUE_REGNAME          TEXT("ForeignEnhContainer")
#define MSMQ_FORGN_ENH_CONTAINER_REGNAME   \
                (MSMQ_FORGN_ENH_KEY_REGNAME  MSMQ_FORGN_ENH_VALUE_REGNAME)

//
// Windows bug 633909.
// RC2 effective enhanced key len changed from 40 bits to 128 bits.
//
// The following registry let user revert to 40 bits key, to enable backward
// compatibility. default- 0. non-zero value force using 40 bits keys.
//
#define MSMQ_RC2_SNDEFFECTIVE_40_REGNAME  TEXT("security\\SendEnhRC2With40")
//
// The following registry force rejection of messages encrypted with RC2
// if enhanced provider is used but effective length is 40.
// By default (value 0), all RC2 encryption are accepted. To enforce strong
// security, set this one to 1. Then messages from win2k or xp that use
// effective length of 40 will be rejected.
//
#define MSMQ_REJECT_RC2_IFENHLEN_40_REGNAME     \
                                 TEXT("security\\RejectEnhRC2IfLen40")

//---------------------------------------------------------
//
//  Registry used by the NT5 replication service.
//
//---------------------------------------------------------

// Interval to next replication cycle, if present one failed. in Seconds.
#define RP_DEFAULT_FAIL_REPL_INTERVAL   (120)
#define RP_FAIL_REPL_INTERVAL_REGNAME   TEXT("Migration\\FailReplInterval")

// Interval to next hello, in seconds
#define RP_DEFAULT_HELLO_INTERVAL   (20 * 60)
#define RP_HELLO_INTERVAL_REGNAME   TEXT("Migration\\HelloInterval")

#define RP_DEFAULT_TIMES_HELLO      (1)
#define RP_TIMES_HELLO_FOR_REPLICATION_INTERVAL_REGNAME   \
                                    TEXT("Migration\\TimesHelloForReplicationInterval")

// Buffer between current and allowed purge SN
#define RP_DEFAULT_PURGE_BUFFER   (PURGE_BUFFER_SN)
#define RP_PURGE_BUFFER_REGNAME   TEXT("Migration\\PurgeBuffer")

// Frequency to send PSC Ack
#define RP_DEFAULT_PSC_ACK_FREQUENCY   (PSC_ACK_FREQUENCY_SN)
#define RP_PSC_ACK_FREQUENCY_REGNAME   TEXT("Migration\\PSCAckFrequencySN")

// Timeout of replication messages. in second.
#define RP_DEFAULT_REPL_MSG_TIMEOUT        (20 * 60)
#define RP_REPL_MSG_TIMEOUT_REGNAME        TEXT("Migration\\ReplMsgTimeout")

// My site id in NT4.
#define MSMQ_NT4_MASTERID_REGNAME  TEXT("Migration\\MasterIdOnNt4")

// Number of threads for answering replication/sync messages from NT4 servers.
#define RP_DEFAULT_REPL_NUM_THREADS        8
#define RP_REPL_NUM_THREADS_REGNAME        TEXT("Migration\\ReplThreads")

// DS query: Number of returned objects per ldap page
#define RP_DEFAULT_OBJECT_PER_LDAPPAGE	   1000	
#define RP_OBJECT_PER_LDAPPAGE_REGNAME	   TEXT("Migration\\ObjectPerLdapPage")

// If "ON_DEMAND" is 1, then replication is done on demand when
// "REPLICATE_NOW" is 1. The service read the "_NOW" flag each second.
#define RP_REPL_ON_DEMAND_REGNAME        TEXT("Migration\\ReplOnDemand")
#define RP_REPLICATE_NOW_REGNAME         TEXT("Migration\\ReplicateNow")

//
// Value of MQS before upgrade. Relevant only on ex-PEC
//
#define MSMQ_PREMIG_MQS_REGNAME          TEXT("PreMigMQS")

//+----------------------------------------
//
// Registry key for debugging.
//
//+----------------------------------------

//
// DWORD. If set to 1, then Rt will mark the provider used for authentication
// as non default and will send the provider name.
//
#define USE_NON_DEFAULT_AUTHN_PROV_REGNAME  TEXT("debug\\UseNonDefAuthnProv")
//
// DWORD. Number of security subsections to insert before the real one.
//
#define PREFIX_SUB_SECTIONS_REGNAME         TEXT("debug\\PrefixSubSections")
//
// DWORD. Number of security subsections to insert after the real one.
//
#define POSTFIX_SUB_SECTIONS_REGNAME        TEXT("debug\\PostfixSubSections")

//+----------------------------------------
//
//  Registry value for local admin api
//
//+----------------------------------------

//
// If this reg value is 1, then query operations of local admin api
// are restricted to administrators only. Bug 7520.
// Defualt is unrestricted, for backward compatibility.
//
#define  MSMQ_DEFAULT_RESTRICT_ADMIN_API    0
#define  MSMQ_RESTRICT_ADMIN_API_TO_LA      1
#define  MSMQ_RESTRICT_ADMIN_API_REGNAME    TEXT("RestrictAdminApi")

#endif  // __TEMP_MQINI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\_mqend.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    _mqend.h

Abstract:

    Tail of Falcon SDK file mq.h

Author:

    Erez Haba (erezh) 24-Jan-96

--*/

// begin_mq_h

#endif // __MQ_H__

// end_mq_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\_mqres.h ===
//
// _mqres.h
//
// Resource related function in MQUTIL.DLL
//
#ifndef _MQRES_H
#define _MQRES_H

HMODULE MQGetResourceHandle();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\_mqlog.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    _mqlog.h

Abstract:

    Definitions for logging of problems.
    In all bits (release, checked, debug).

Author:

    Doron Juster  (DoronJ)   06-July-99  Created

--*/

#ifndef __TEMP_MQLOG_H
#define __TEMP_MQLOG_H

//+-------------------------------------------------------------------------
//
// This DWORD registry value indicate what types of logging are enabled.
// It's OR of the values listed below. This value is read once at boot.
// If LOG_REFRESH is turned on then components bits are read from registry
// on every call to the log routine.
//
#define LOG_LOGGING_TYPE_REGNAME    TEXT("Debug\\LoggingTypes")
//
// Possible values for  LOG_LOGGING_TYPES_REGNAME:
//
#define MSMQ_LOG_ERROR           0x00000001
#define MSMQ_LOG_WARNING         0x00000002
#define MSMQ_LOG_TRACE           0x00000004
#define MSMQ_LOG_EVERYTHING      0x40000000
#define MSMQ_LOG_REFRESH         0x80000000

//+--------------------------------------------------------------
//
//  Define the logging components:
//
enum enumLogComponents
{
    e_LogDS = 0,
    e_LogQM,
    e_LogRT,
    e_LogDbg,
    e_cLogComponents
} ;

//
// Define registry names for each component:
//
const WCHAR * const  x_wszLogComponentsRegName[ e_cLogComponents ] =
{
    L"Debug\\DSLogging",
    L"Debug\\QMLogging",
    L"Debug\\RTLogging",
    L"Debug\\DbgErrs"
} ;

//
// Possible values for DSlogging
// LOG_DS_CREATE_ON_GC- trace creation on GC. These are operation that
//   create objects with predefined guid. They need the "add guid" permission
//   and need to be done on GC.
// LOG_DS_CROSS_DOMAIN- trace problems which are expected to happen in
//   cross-domains scenarios.
// LOG_DS_QUERY - trace main DS ADSI operations (query, open, created)
//
#define LOG_DS_CREATE_ON_GC    0x00000001
#define LOG_DS_FIND_SITE       0x00000002
#define LOG_DS_CROSS_DOMAIN    0x00000004
#define LOG_DS_ERRORS          0x00000008
#define LOG_DS_QUERY           0x00000010

// 
// Common values of RTLogging and QMLogging - both  QM and RT use DS
//
#define LOG_DS_CONNECT         0x00000004

//
// Possible values for QMlogging
//
#define LOG_QM_INIT            0x00000001
#define LOG_QM_TOPOLOGY        0x00000002
#define LOG_QM_ERRORS          0x00000008

//
// Possible values for RTlogging
//
#define LOG_RT_ERRORS          0x00000008

#endif  // __TEMP_MQLOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\_mqreg.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    _mqreg.h

Abstract:

    Registry location.

Author:

    Doron Juster  (DoronJ)  26-Jul-97

--*/

#ifndef __MQREG_H_
#define __MQREG_H_

#define FALCON_REG_POS       HKEY_LOCAL_MACHINE
#define FALCON_USER_REG_POS  HKEY_CURRENT_USER

// The name of the service in the services registry.
#define MQQM_SERVICE_NAME       TEXT("MSMQ")

// Name of registry section.
#define MSMQ_DEFAULT_REGISTRY    TEXT("MSMQ")
#define MSMQ_REGISTRY_REGNAME    TEXT("RegistrySection")

#define FALCON_REG_KEY_ROOT  TEXT("SOFTWARE\\Microsoft\\")
#define FALCON_REG_KEY_PARAM TEXT("\\Parameters")
#define FALCON_REG_KEY_MACHINE_CACHE TEXT("\\MachineCache")

#define CLUSTERED_QMS_KEY    TEXT("\\Clustered QMs\\")

#define FALCON_REG_KEY  \
      (FALCON_REG_KEY_ROOT MSMQ_DEFAULT_REGISTRY FALCON_REG_KEY_PARAM)

#define FALCON_MACHINE_CACHE_REG_KEY  \
     (FALCON_REG_KEY_ROOT MSMQ_DEFAULT_REGISTRY FALCON_REG_KEY_PARAM FALCON_REG_KEY_MACHINE_CACHE)

#define FALCON_CLUSTERED_QMS_REG_KEY \
      (FALCON_REG_KEY_ROOT MSMQ_DEFAULT_REGISTRY CLUSTERED_QMS_KEY)

#define FALCON_REG_MSMQ_KEY   (FALCON_REG_KEY_ROOT MSMQ_DEFAULT_REGISTRY)

#define FALCON_USER_REG_MSMQ_KEY  (FALCON_REG_KEY_ROOT MSMQ_DEFAULT_REGISTRY)

#endif // __MQREG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\_mqsecer.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name: _mqsecer.h

Abstract:
    Error codes for security stuff.

Author:
    Doron Juster (DoronJ)  17-May-1998

Revision History:

--*/

#ifndef __MQSECER_H_
#define __MQSECER_H_

#include <mqsymbls.h>

#define MQSec_E_CANT_ACQUIRE_CTX    (MQSec_E_BASE + 0x0064)  // Can't AcquireContext.
#define MQSec_E_CERT_NOT_VALID_YET  (MQSec_E_BASE + 0x0065)  // cert not valid yet.
#define MQSec_E_CAN_NOT_DELETE      (MQSec_E_BASE + 0x0066)  // Can not delete cert from store.
#define MQSec_E_GET_REG             (MQSec_E_BASE + 0x0067)  // Can not read registry.
#define MQSec_E_CANT_LOAD_MQUTIL    (MQSec_E_BASE + 0x0068)  // Can not load the mqutil dll.
#define MQSec_E_NULL_SD             (MQSec_E_BASE + 0x0069)  // SD is null.
#define MQSec_E_UNSUPPORT_RDNNAME   (MQSec_E_BASE + 0x006a)  // Unsupported RDN name.
#define MQSec_E_UNSUPPORT_NAMETYPE  (MQSec_E_BASE + 0x006b)  // Unsupported name type (in RDN).
#define MQSec_E_CAN_NOT_GET_KEY     (MQSec_E_BASE + 0x006c)  // Can not get public key.
#define MQSec_E_DCD_RDNNAME_SECOND  (MQSec_E_BASE + 0x006d)  // Second call to decode failed
#define MQSec_E_CERT_NOT_FOUND      (MQSec_E_BASE + 0x006e)  // cert not found in store.
#define MQSec_E_PUTKEY_GET_USER     (MQSec_E_BASE + 0x006f)  // Failed to get user key

#endif //  __MQSECER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\_mqrpc.h ===
/*++

Copyright (c) 1995-96  Microsoft Corporation

Module Name:

    _mqrpc.h

Abstract:

   prototypes of RPC related utility functions.
   called from RT and QM.

--*/

#ifndef __MQRPC_H__
#define __MQRPC_H__

#ifdef _MQUTIL
#define MQUTIL_EXPORT  DLL_EXPORT
#else
#define MQUTIL_EXPORT  DLL_IMPORT
#endif

//
//  Default protocol and options
//
#define RPC_LOCAL_PROTOCOLA  "ncalrpc"
#define RPC_LOCAL_PROTOCOL   TEXT(RPC_LOCAL_PROTOCOLA)
#define RPC_LOCAL_OPTION     TEXT("Security=Impersonation Dynamic True")

#define  RPC_IPX_NAME     TEXT("ncacn_spx")
#define  RPC_TCPIP_NAME   TEXT("ncacn_ip_tcp")

typedef enum _tagMQRPC_AUTHENTICATION_LEVEL
{
   //
   // maximum authentication (PKT_INTEGRITY), only between two NT, running
   // under domain user account
   //
   MQRPC_SEC_LEVEL_MAX,

   //
   // Use minimum authentication level, for compatibility with MQIS1.0 SP3
   // servers. SP4 servers do accept non authenticated calls.
   //
   MQRPC_SEC_LEVEL_MIN,

   //
   // no authentication.
   //
   MQRPC_SEC_LEVEL_NONE

} MQRPC_AUTHENTICATION_LEVEL ;

//
// Define types of rpc ports.
//
typedef enum _PORTTYPE {
        IP_HANDSHAKE,
        IP_READ,
        IPX_HANDSHAKE,
        IPX_READ
} PORTTYPE ;

//
// Use this authentication "flag" for remote read. We don't use the
// RPC negotiate protocol, as it can't run against nt4 machine listening
// on NTLM. (actually, it can, but this is not trivial or straight forward).
// So we'll implement our own negotiation.
// We'll first try Kerberos. If client can't obtain principal name of
// server, then we'll switch to ntlm.
//
//  Value of this flag should be different than any RPC_C_AUTHN_* flag.
//
#define  MSMQ_AUTHN_NEGOTIATE   101

//
//  type of machine, return with port number
//
#define  PORTTYPE_WIN95  0x80000000

//
//  Prototype of functions
//

typedef DWORD
(* GetPort_ROUTINE) ( IN handle_t  Handle,
                      IN DWORD     dwPortType ) ;
//
// #3117, for NT5 Beta2
// Jul/16/1998 RaananH, added kerberos support
//
HRESULT
MQUTIL_EXPORT
mqrpcBindQMService(
            IN  LPWSTR       lpwzMachineName,
            IN  DWORD        dwProtocol,
            IN  LPWSTR       lpszPort,
            IN  OUT MQRPC_AUTHENTICATION_LEVEL *peAuthnLevel,
            OUT BOOL*           pProtocolNotSupported,
            OUT handle_t*       lphBind,
            IN  DWORD           dwPortType,    /* = ((DWORD) -1)      */
            IN  GetPort_ROUTINE pfnGetPort,    /* = NULL              */
            OUT BOOL*           pfWin95,       /* = NULL              */
            IN  ULONG           ulAuthnSvc ) ; /* = RPC_C_AUTHN_WINNT */

HRESULT
MQUTIL_EXPORT
mqrpcUnbindQMService(
            IN handle_t*    lphBind,
            IN TBYTE      **lpwBindString) ;

BOOL
MQUTIL_EXPORT
mqrpcIsLocalCall( IN handle_t hBind ) ;


VOID
MQUTIL_EXPORT
APIENTRY
ComposeLocalEndPoint(
    LPCWSTR pwzEndPoint,
    LPWSTR * ppwzBuffer
    );

RPC_STATUS APIENTRY
 mqrpcSetLocalRpcMutualAuth( handle_t *phBind ) ;

#endif // __MQRPC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\_registr.h ===
/*++

Copyright (c) 1995-96  Microsoft Corporation

Module Name:

    _registr.h

Abstract:


--*/

#ifndef __REGISTER_H__
#define __REGISTER_H__

#include "_mqini.h"

#ifdef _MQUTIL
#define MQUTIL_EXPORT  DLL_EXPORT
#else
#define MQUTIL_EXPORT  DLL_IMPORT
#endif

LPCWSTR
MQUTIL_EXPORT
APIENTRY
GetFalconSectionName(
    VOID
    );

DWORD
MQUTIL_EXPORT
APIENTRY
GetFalconServiceName(
    LPWSTR pwzServiceNameBuff,
    DWORD dwServiceNameBuffLen
    );


typedef VOID (APIENTRY *SetFalconServiceName_ROUTINE) (LPCWSTR);

VOID
MQUTIL_EXPORT
APIENTRY
SetFalconServiceName(
    LPCWSTR pwzServiceName
    );


LONG
MQUTIL_EXPORT
GetFalconKey(LPCWSTR  pszKeyName,
             HKEY *phKey);


typedef LONG (APIENTRY *GetFalconKeyValue_ROUTINE) (
                    LPCWSTR  pszValueName,
                    PDWORD   pdwType,
                    PVOID    pData,
                    PDWORD   pdwSize,
                    LPCWSTR  pszDefValue = NULL ) ;
LONG
MQUTIL_EXPORT
APIENTRY
GetFalconKeyValue(  LPCWSTR  pszValueName,
                    PDWORD   pdwType,
                    PVOID    pData,
                    PDWORD   pdwSize,
                    LPCWSTR  pszDefValue = NULL ) ;


typedef LONG (APIENTRY *SetFalconKeyValue_ROUTINE) (LPCWSTR, PDWORD, const VOID*, PDWORD);

LONG
MQUTIL_EXPORT
APIENTRY
SetFalconKeyValue(LPCWSTR  pszValueName,
                  PDWORD   pdwType,
                  const VOID * pData,
                  PDWORD   pdwSize);


LONG
MQUTIL_EXPORT
DeleteFalconKeyValue(
                  LPCWSTR pszValueName ) ;

#define MAX_DEV_NAME_LEN 30
HRESULT
MQUTIL_EXPORT
MQUGetAcName(
    LPWSTR szAcName);

//
//  Macros for reading registry/ini file
//
#define MAX_REG_DEFAULT_LEN  260

#define READ_REG_STRING(string, ValueName, default)            \
	WCHAR  string[ MAX_REG_DEFAULT_LEN ] = default;            \
   {                                                           \
     DWORD  dwSize = MAX_REG_DEFAULT_LEN * sizeof(WCHAR)  ;    \
     DWORD  dwType = REG_SZ ;                                  \
                                                               \
     ASSERT(wcslen(default) < MAX_REG_DEFAULT_LEN) ;           \
                                                               \
     LONG res = GetFalconKeyValue( ValueName,                  \
                                   &dwType,                    \
                                   string,                     \
                                   &dwSize,                    \
                                   default ) ;                 \
	 if(res == ERROR_MORE_DATA)									\
	{															\
		wcscpy(string, default);								\
	}															\
     ASSERT(res == ERROR_SUCCESS || res == ERROR_MORE_DATA) ;   \
     ASSERT(dwType == REG_SZ) ;                                \
   }

#define READ_REG_DWORD(outvalue, ValueName, default)           \
   {                                                           \
     DWORD  dwSize = sizeof(DWORD) ;                           \
     DWORD  dwType = REG_DWORD ;                               \
                                                               \
     LONG res = GetFalconKeyValue( ValueName,                  \
                                   &dwType,                    \
                                   &outvalue,                  \
                                   &dwSize,                    \
                                   (LPCTSTR) default ) ;       \
     ((void)res);                                              \
     ASSERT(res == ERROR_SUCCESS) ;                            \
     ASSERT(dwType == REG_DWORD) ;                             \
   }


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\_stdafx.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    _stdafx.h

Abstract:

    Global Falcon project header file, for components that uses MFC libraries.

Author:

    Erez Haba (erezh) 25-Nov-96

Note:

    DO NOT INCLUDE THIS FILE DIRECTLY IN YOUR SOURCE CODE,
    INCLUDE IT ONLY IN YOUR COMPONENT stdh.h FILE.

--*/
#ifndef __FALCON_STDAFX_H
#define __FALCON_STDAFX_H

#ifndef UNICODE
#define UNICODE
#endif

#ifndef _UNICODE
#define _UNICODE
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#undef ASSERT
#define MAXDWORD    0xffffffff  
typedef TUCHAR TBYTE , *PTBYTE ;

#undef _DEBUG
#include <afxwin.h>
#include <afxext.h>
#include <afxole.h>
#include <afxtempl.h>

#undef ASSERT
#undef VERIFY

#ifdef DBG
#define _DEBUG
#define new DEBUG_NEW
#endif

#include <tr.h>

#define DLL_EXPORT  __declspec(dllexport)
#define DLL_IMPORT  __declspec(dllimport)


#include <crtwin.h>
#include <mqtempl.h>
#include <mqreport.h>
#include <mqwin64a.h>

//
//  DO NOT ADD 
//

#endif // __FALCON_STDAFX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\_rstrct.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    _rstrct.h

Abstract:
    C++ wrappers for restrictions.

--*/

#ifndef __RSTRCT_H
#define __RSTRCT_H

#ifdef _MQUTIL      
#define MQUTIL_EXPORT  DLL_EXPORT
#else           
#define MQUTIL_EXPORT  DLL_IMPORT
#endif

#include "_propvar.h"


//+-------------------------------------------------------------------------
//
//  Class:      CColumns
//
//  Purpose:    C++ wrapper for MQCOLUMNSET
//
//  History:    
//
//--------------------------------------------------------------------------

class MQUTIL_EXPORT CColumns
{
public:

    //
    // Constructors
    //

    CColumns( unsigned size = 0 );

    //
    // Copy constructors/assignment
    //

    CColumns( CColumns const & src );
    CColumns & operator=( CColumns const & src );

    //
    // Destructor
    //

    ~CColumns();

    //
    // C/C++ conversion
    //

    inline MQCOLUMNSET * CastToStruct();

    //
    // Member variable access
    //

    void Add( PROPID const& Property );
    void Remove( unsigned pos );
    inline PROPID const & Get( unsigned pos ) const;

    inline unsigned Count() const;


private:

    unsigned        m_cCol;
    PROPID		  * m_aCol;
    unsigned        m_size;
};

//+-------------------------------------------------------------------------
//
//  Structure:  SortKey
//
//  Purpose:    wraper for SORTKEY class
//
//--------------------------------------------------------------------------
class MQUTIL_EXPORT CSortKey
{
public:

    //
    // Constructors
    //

    inline CSortKey();
    inline CSortKey( PROPID const & ps, ULONG dwOrder );
    inline ~CSortKey() {};

    //
    // assignment
    //

    CSortKey & operator=( CSortKey const & src );

    //
    // Member variable access
    //

    inline void SetProperty( PROPID const & ps );
    inline PROPID const & GetProperty() const;
    inline ULONG GetOrder() const;
	inline void SetOrder( ULONG const & dwOrder);

private:

    PROPID		        m_property;
    ULONG               m_dwOrder;
};


//+-------------------------------------------------------------------------
//
//  Class:      CSort
//
//  Purpose:    C++ wrapper for SORTSET
//
//  History:    22-Jun-93 KyleP     Created
//
//--------------------------------------------------------------------------
class MQUTIL_EXPORT CSort
{
public:

    //
    // Constructors
    //

    CSort( unsigned size = 0 );

    //
    // Copy constructors/assignment
    //

    CSort( CSort const & src );
    CSort & operator=( CSort const & src );

    //
    // Destructor
    //

    ~CSort();

    //
    // C/C++ conversion
    //

    inline MQSORTSET * CastToStruct();

    //
    // Member variable access
    //

    void Add( CSortKey const &sk );
    void Add( PROPID const & Property, ULONG dwOrder );
    void Remove( unsigned pos );
    inline CSortKey const & Get( unsigned pos ) const;

    inline unsigned Count() const;

private:

    unsigned        m_csk;		// largest position filled
    CSortKey *      m_ask;
    unsigned        m_size;
};

//+-------------------------------------------------------------------------
//
//  Class:      CPropertyRestriction
//
//  Purpose:    Property <relop> constant restriction
//
//--------------------------------------------------------------------------
class CPropertyRestriction 
{
public:

    //
    // Constructors
    //

    CPropertyRestriction();

    CPropertyRestriction( ULONG relop,
                          PROPID const & Property,
                          CMQVariant const & prval );
	// 
	// Assignment
	//
    CPropertyRestriction & operator=( CPropertyRestriction const & src );

    //
    // Destructors
    //

    ~CPropertyRestriction();

    //
    // Member variable access
    //

    inline void SetRelation( ULONG relop );
    inline ULONG Relation();

    inline void SetProperty( PROPID const & Property );
    inline PROPID const & GetProperty() const;
    
    inline void SetValue( ULONG ulValue );
    inline void SetValue( LONG lValue );
    inline void SetValue( SHORT sValue );
	inline void SetValue( UCHAR ucValue );
	inline void SetValue( const CMQVariant &prval );


    
    void SetValue ( CACLSID * caclsValue);
    void SetValue ( CALPWSTR  * calpwstrValue);
    void SetValue( BLOB & bValue );
    void SetValue( TCHAR * pwcsValue );
    void SetValue( GUID * pguidValue);
    void SetValue( CAPROPVARIANT * cavarValue);

    inline CMQVariant const & Value();

private:

    void            m_CleanValue();

    ULONG           m_relop;       // Relation
    PROPID		    m_Property;    // Property Name
    CMQVariant      m_prval;       // Constant value
};


//+-------------------------------------------------------------------------
//
//  Class:      CRestriction
//
//  Purpose:    Boolean AND of propertrt restrictions
//
//
//--------------------------------------------------------------------------
class MQUTIL_EXPORT CRestriction 
{
public:

    //
    // Constructors
    //

    CRestriction(  unsigned cInitAllocated = 2 );

    //
    // Copy constructors/assignment
    //

    CRestriction( const CRestriction& Rst );

	CRestriction & operator=( CRestriction const & Rst );

    //
    // Destructor
    //

    ~CRestriction();

	//
    // C/C++ conversion
    //

    inline MQRESTRICTION * CastToStruct();



    //
    // Node manipulation
    //

    void AddChild( CPropertyRestriction const & presChild );
    CPropertyRestriction const & RemoveChild( unsigned pos );

    //
    // Member variable access
    //

    inline void SetChild( CPropertyRestriction const & presChild, unsigned pos );
    inline CPropertyRestriction const & GetChild( unsigned pos ) const;

	void AddRestriction( ULONG ulValue, PROPID property, ULONG relop, unsigned pos);
	void AddRestriction( LONG lValue, PROPID property, ULONG relop, unsigned pos);
	void AddRestriction( SHORT sValue, PROPID property, ULONG relop, unsigned pos);
	void AddRestriction( UCHAR ucValue, PROPID property, ULONG relop, unsigned pos);
	void AddRestriction(const CMQVariant & prval, PROPID property, ULONG relop, unsigned pos);
	void AddRestriction( CACLSID * caclsValus, PROPID property, ULONG relop, unsigned pos);
	void AddRestriction( LPTSTR pwszVal, PROPID property, ULONG relop, unsigned pos);
	void AddRestriction( CALPWSTR * calpwstr, PROPID property, ULONG relop, unsigned pos);
	void AddRestriction( GUID * pguidValue, PROPID property, ULONG relop, unsigned pos);
    void AddRestriction( BLOB  & blobValue, PROPID property, ULONG relop, unsigned pos);

    inline unsigned Count() const;

private:

    void Grow();

protected:

    ULONG           m_cNode;
    CPropertyRestriction *m_paNode;

    //
    // Members mapped to C structure end here.  The following will
    // be reserved in the C structure to maintain to C <--> C++
    // facade.
    //

    ULONG m_cNodeAllocated;
};


//--------------------------------------------------------------------------
//
// Inline methods for CColumns
//
//--------------------------------------------------------------------------
inline PROPID const & CColumns::Get( unsigned pos ) const
{
    if ( pos < m_cCol )
        return( m_aCol[pos] );
    else
        return( *(PROPID *)0 );
}


inline unsigned CColumns::Count() const
{
    return( m_cCol );
}

inline MQCOLUMNSET * CColumns::CastToStruct()
{
    return( (MQCOLUMNSET *)this );
}
//--------------------------------------------------------------------------
//
// Inline methods for CSortKey
//
//--------------------------------------------------------------------------
inline CSortKey::CSortKey()
{
}

inline CSortKey::CSortKey( PROPID const & ps, ULONG dwOrder )
        : m_property( ps ),
          m_dwOrder( dwOrder )
{
}

inline CSortKey & CSortKey::operator=( CSortKey const & src )
{
	m_property = src.m_property;
	m_dwOrder = src.m_dwOrder;
	return (*this);
}
inline void CSortKey::SetProperty( PROPID const & ps )
{
    m_property = ps;
}


inline PROPID const & CSortKey::GetProperty() const
{
    return( m_property );
}

inline ULONG CSortKey::GetOrder() const
{
    return( m_dwOrder );
}

inline void CSortKey::SetOrder( ULONG const & dwOrder)
{
	m_dwOrder = dwOrder;
}

//--------------------------------------------------------------------------
//
// Inline methods of CSort
//
//--------------------------------------------------------------------------
inline MQSORTSET * CSort::CastToStruct()
{
    return( (MQSORTSET *)this );
}

inline CSortKey const & CSort::Get( unsigned pos ) const
{
    if ( pos < m_csk )
    {
        return( m_ask[pos] );
    }
    else
    {
        return( *(CSortKey *)0 );
    }
}

inline unsigned
CSort::Count() const
{
    return( m_csk );
}


//--------------------------------------------------------------------------
//
// Inline methods of CRestriction
//
//--------------------------------------------------------------------------
inline unsigned CRestriction::Count() const
{
    return( m_cNode );
}


inline void CRestriction::SetChild( CPropertyRestriction const & presChild,
                                        unsigned pos )
{
    if ( pos < m_cNode )
    
		m_paNode[pos] = presChild;
}       

inline CPropertyRestriction const & CRestriction::GetChild( unsigned pos ) const
{
    if ( pos < m_cNode )
        return( m_paNode[pos] );
    else
        return( *(CPropertyRestriction *)0 );
}

inline MQRESTRICTION * CRestriction::CastToStruct()
{
    return( (m_cNode == 0) ? NULL : (MQRESTRICTION *)this );
}

//--------------------------------------------------------------------------
//
// Inline methods of CPropertyRestriction
//
//--------------------------------------------------------------------------
inline void CPropertyRestriction::SetRelation( ULONG relop )
{
    m_relop = relop;
}

inline ULONG CPropertyRestriction::Relation()
{
    return( m_relop );
}

inline void CPropertyRestriction::SetProperty( PROPID const & Property )
{
    m_Property = Property;
}


inline void CPropertyRestriction::SetValue( UCHAR ucValue )
{
    m_prval = ucValue;
}

inline void CPropertyRestriction::SetValue( SHORT sValue )

{
    m_prval = sValue;
}
inline void CPropertyRestriction::SetValue( ULONG ulValue )
{
    m_prval.SetI4( ulValue );
}

inline void CPropertyRestriction::SetValue( LONG lValue )
{
    m_prval = lValue;
}


inline void CPropertyRestriction::SetValue( const CMQVariant &prval )
{
    m_prval = prval;
}

inline CMQVariant const & CPropertyRestriction::Value()
{
    return( m_prval );
}  

#endif // __RSTRCT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\_secutil.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:
    _secutil.h

    Header file for the various security related functions and cleses.

Author:

    Boaz Feldbaum (BoazF) 26-Mar-1996.

--*/

#ifndef _SECUTILS_H_
#define _SECUTILS_H_

#ifndef MQUTIL_EXPORT
#define MQUTIL_EXPORT  DLL_IMPORT
#endif

#include <mqcrypt.h>
#include <qformat.h>

extern MQUTIL_EXPORT CHCryptProv g_hProvVer;
extern MQUTIL_EXPORT PSID g_pWorldSid;

// See if object initialization failed. This macro is called at the beginning
// of each method of CSecureableObject.
#define VERIFY_INIT_OK()    \
    if (FAILED(m_hr)) {     \
        return(m_hr);       \
    }


MQUTIL_EXPORT
HRESULT
InitServerSecurity(
    VOID
    );


MQUTIL_EXPORT
HRESULT
HashProperties(
    HCRYPTHASH  hHash,
    DWORD       cp,
    PROPID      *aPropId,
    PROPVARIANT *aPropVar
    );

void MQUInitGlobalScurityVars() ;


MQUTIL_EXPORT
HRESULT
GetThreadUserSid(
    LPBYTE *pUserSid,
    DWORD *pdwUserSidLen
    );

MQUTIL_EXPORT
HRESULT
HashMessageProperties(
    HCRYPTHASH hHash,
    const BYTE *pbCorrelationId,
    DWORD dwCorrelationIdSize,
    DWORD dwAppSpecific,
    const BYTE *pbBody,
    DWORD dwBodySize,
    const WCHAR *pwcLabel,
    DWORD dwLabelSize,
    const QUEUE_FORMAT *pRespQueueFormat,
    const QUEUE_FORMAT *pAdminQueueFormat
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\_stdh.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:
    _stdh.h

Abstract:
    Global Falcon project header file

Author:
    Erez Haba (erezh) 16-Jan-96

Note:
    DO NOT INCLUDE THIS FILE DIRECTLY IN YOUR SOURCE CODE,
    INCLUDE IT ONLY IN YOUR COMPONENT stdh.h FILE.

--*/
#ifndef __FALCON_STDH_H
#define __FALCON_STDH_H

#define STATIC 

#include <mqenv.h>
#include <mfc\afx.h>
#include <mfc\afxtempl.h>

#define DLL_EXPORT  __declspec(dllexport)
#define DLL_IMPORT  __declspec(dllimport)


//
// Make a BUGBUG messages appear in compiler output
//
// Usage: #pragma BUGBUG("This line appears in the compiler output")
//
#define MAKELINE0(a, b) a "(" #b ") : BUGBUG: "
#define MAKELINE(a, b)  MAKELINE0(a, b) 
#define BUGBUG(a)       message(MAKELINE(__FILE__,__LINE__) a)



#include <crtwin.h>
#include <mqmacro.h>
#include <mqtempl.h>
#include <mqreport.h>
#include <mqwin64.h>
#include <mqstl.h>
//
//  DO NOT ADD 
//

#endif // __FALCON_STDH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\_propvar.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    _propvar.h

Abstract:

    CMQVariant class

--*/

#ifndef __PROPVAR_H
#define __PROPVAR_H

//---------------------------------------------------------
//
//  class CMQVariant
//
//---------------------------------------------------------
class CMQVariant : private tagMQPROPVARIANT {
public:
    //
    // Simple types
    //
    CMQVariant();
    CMQVariant(unsigned char ch);
    CMQVariant(short i);
    CMQVariant(long l);

    CMQVariant& operator=(CMQVariant const &var);
    CMQVariant& operator=(short i);
    CMQVariant& operator=(long l);
    CMQVariant& operator=(unsigned char uc);

    //
    // Types with indirection
    //
    CMQVariant(BLOB const& b);
    CMQVariant(TCHAR const *pwsz);
    CMQVariant(CLSID const *pcid);

    CMQVariant& operator=(BLOB const& b);
    CMQVariant& operator=(TCHAR const *pwsz);
    CMQVariant& operator=(CLSID const *pcid);

    //
    // Counted array types.
    //

    CMQVariant(CACLSID const* pcauuid);
    CMQVariant(CALPWSTR const* pcalpwstr);
    CMQVariant(CAPROPVARIANT const* pcaprovar);

    CMQVariant& operator=(CACLSID const *pcauuid);
    CMQVariant& operator=(CALPWSTR const *pcalpwstr);
    CMQVariant& operator=(CAPROPVARIANT const *pcapropvar);

    //
    // To/From C style STGVARIANT and copy constructor
    //

    CMQVariant(CMQVariant const &var);
    CMQVariant(MQPROPVARIANT const &var);

    MQPROPVARIANT * CastToStruct();

    ~CMQVariant();

    //
    // Set/Get, all types including arrays.
    //

    void SetEMPTY();
    void SetNULL();
    void SetUI1(unsigned char uc);
    void SetI2(short i);
    void SetI4(long l);
    void SetLPTSTR(TCHAR const *psz);
    void SetBLOB(BLOB const& b);
    void SetCLSID(CLSID const *pc);
    void SetCACLSID(CACLSID const *pc);
    void SetCALPWSTR(CALPWSTR const *pc);
    void SetCAPROPVARIANT(CAPROPVARIANT const *pc);
    void SetPROPVARIANT(MQPROPVARIANT const* p);

    CLSID* GetCLSID(void);
    const CACLSID *GetCACLSID(void);
    LPWSTR GetLPWSTR(void);
    LPTSTR GetLPTSTR(void);
    const CALPWSTR * GetCALPWSTR(void);

private:
    void FreeVariant();

    void _setUI1(unsigned char);
    void _setI2(short);
    void _setI4(long);
    void _setLPTSTR(TCHAR const*);
    void _setBLOB(BLOB const&);
    void _setCLSID(CLSID const&);
    void _setCACLSID(CACLSID const&);
    void _setCALPWSTR(CALPWSTR const&);
    void _setPROPVARIANT(MQPROPVARIANT const&);
    void _setCAPROPVARIANT(CAPROPVARIANT const&);

private:
    static LPWSTR DupString(LPCWSTR);
    static CALPWSTR DupStringArray(CALPWSTR const&);
    static CAPROPVARIANT DupVariantArray(CAPROPVARIANT const&);
};

//---------------------------------------------------------
//
//  IMPLEMENTATION
//
//---------------------------------------------------------

//---------------------------------------------------------
//
//  class CMQVariant
//
//  NOTE: Always set vt after allocating memory, so if
//      no memory available the variant is not changed, and
//      can be destructed correctly.
//---------------------------------------------------------
inline LPWSTR CMQVariant::DupString(LPCWSTR src)
{
    if(src == 0)
        return 0;

    LPWSTR dst = new WCHAR[wcslen(src)+1];

    wcscpy(dst,src);
    return dst;
}


inline CALPWSTR CMQVariant::DupStringArray(CALPWSTR const& src)
{
    ULONG cElems = src.cElems;
    CALPWSTR dst = {0, 0};
    if(cElems != 0)
    {
        dst.pElems = new LPWSTR[cElems];
    }

    try
    {
        for( ; cElems; cElems--)
        {
            dst.pElems[dst.cElems] = DupString(src.pElems[dst.cElems]);
            dst.cElems++;
        }
    }
    catch(...)
    {
        //
        //  Deallocate all allocated strings
        //  N.B.: we don't catch bad_alloc here since it is compiled with the explorer too.
        //
        while(dst.cElems != 0)
        {
            delete[] dst.pElems[--dst.cElems];
        }

        delete[] dst.pElems;
        dst.pElems = 0;

        //
        //  Rethrow the *same* exception.
        //
        throw;
    }

    return dst;
}


inline CAPROPVARIANT CMQVariant::DupVariantArray(CAPROPVARIANT const& src)
{
    ULONG cElems = src.cElems;
    CAPROPVARIANT dst = {0, 0};
    if(cElems != 0)
    {
        dst.pElems = new PROPVARIANT[cElems];
    }

    try
    {
        for( ; cElems; cElems--)
        {
#ifdef _DEBUG
#undef new
#endif

            new (&dst.pElems[dst.cElems]) CMQVariant(src.pElems[dst.cElems]);

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

            dst.cElems++;
        }
    }
    catch(...)
    {
        //
        //  Deallocate all allocated variants
        //  N.B.: we don't catch bad_alloc here since it is compiled with the explorer too.
        //
        while(dst.cElems != 0)
        {
            static_cast<CMQVariant&>(dst.pElems[--dst.cElems]).~CMQVariant();
        }

        delete[] dst.pElems;
        dst.pElems = 0;

        //
        //  Rethrow the *same* exception.
        //
        throw;
    }

    return dst;
}


inline CMQVariant::~CMQVariant()
{
    FreeVariant();
}

inline MQPROPVARIANT* CMQVariant::CastToStruct(void)    
{
    return this;
}

inline void CMQVariant::_setUI1(unsigned char ch)
{
    bVal = ch;
    vt = VT_UI1;
}

inline void CMQVariant::_setI2(short i)
{
    iVal = i;
    vt = VT_I2;
}

inline void CMQVariant::_setI4(long l)
{
    lVal = l;
    vt = VT_I4;
}

inline void CMQVariant::_setLPTSTR(TCHAR const* pwsz)
{
    pwszVal = DupString(pwsz);
    vt = VT_LPWSTR;
}

inline void CMQVariant::_setBLOB(BLOB const& b)
{
    ULONG cbSize = b.cbSize;
    blob.pBlobData = new BYTE[cbSize];
    memcpy(blob.pBlobData, b.pBlobData, cbSize);
    blob.cbSize = cbSize;
    vt = VT_BLOB;
}

inline void CMQVariant::_setCLSID(CLSID const& g)
{
    puuid = new GUID;
    memcpy(puuid, &g, sizeof(GUID));
    vt = VT_CLSID;
}

inline void CMQVariant::_setCACLSID(CACLSID const& x)
{
    ULONG cElems = x.cElems;
    cauuid.pElems = new GUID[cElems];
    memcpy(cauuid.pElems, x.pElems, sizeof(GUID) * cElems);
    cauuid.cElems = cElems;
    vt = VT_VECTOR | VT_CLSID;
}

inline void CMQVariant::_setCALPWSTR(CALPWSTR const& x)
{
    calpwstr = DupStringArray(x);
    vt = VT_VECTOR | VT_LPWSTR;
}

inline void CMQVariant::_setPROPVARIANT(MQPROPVARIANT const& v)
{
    switch (v.vt)
    {
        case VT_UI1:
            _setUI1(v.bVal);
            break;
        case VT_UI2:
        case VT_I2:
            _setI2(v.iVal);
            break;
        case VT_UI4:
        case VT_I4:
            _setI4(v.lVal);
            break;
        case VT_CLSID:
            _setCLSID(*v.puuid);
            break;
        case VT_LPWSTR:
            _setLPTSTR(v.pwszVal);
            break;
        case VT_BLOB:
            _setBLOB(v.blob);
            break;
        case (VT_VECTOR | VT_CLSID):
            _setCACLSID(v.cauuid);
            break;
        case (VT_VECTOR | VT_LPWSTR):
            _setCALPWSTR(v.calpwstr);
            break;
        case (VT_VECTOR | VT_VARIANT):
            _setCAPROPVARIANT(v.capropvar);
            break;
        default:
            break;
    }
    vt = v.vt;

}

inline void CMQVariant::_setCAPROPVARIANT(CAPROPVARIANT const& x)
{
    capropvar = DupVariantArray(x);
    vt = VT_VECTOR | VT_VARIANT;
}


inline CMQVariant::CMQVariant()                         { vt = VT_EMPTY; }
inline CMQVariant::CMQVariant(unsigned char ch)         { _setUI1(ch); }
inline CMQVariant::CMQVariant(short i)                  { _setI2(i); }
inline CMQVariant::CMQVariant(long l)                   { _setI4(l); }
inline CMQVariant::CMQVariant(BLOB const& b)            { _setBLOB(b); }
inline CMQVariant::CMQVariant(LPCWSTR p)                { _setLPTSTR(p); }
inline CMQVariant::CMQVariant(CLSID const* pg)          { _setCLSID(*pg); }
inline CMQVariant::CMQVariant(CACLSID const* p)         { _setCACLSID(*p); }
inline CMQVariant::CMQVariant(CALPWSTR const* p)        { _setCALPWSTR(*p); }
inline CMQVariant::CMQVariant(CAPROPVARIANT const* p) { _setCAPROPVARIANT(*p); }
inline CMQVariant::CMQVariant(MQPROPVARIANT const &v)   { _setPROPVARIANT(v); }
inline CMQVariant::CMQVariant(CMQVariant const &v)      { _setPROPVARIANT(v); }

inline void CMQVariant::SetEMPTY()                      { FreeVariant(); vt = VT_EMPTY; }
inline void CMQVariant::SetNULL()                       { FreeVariant(); vt = VT_NULL; }
inline void CMQVariant::SetUI1(unsigned char ch)        { FreeVariant(); _setUI1(ch); }
inline void CMQVariant::SetI2(short i)                  { FreeVariant(); _setI2(i); }
inline void CMQVariant::SetI4(long l)                   { FreeVariant(); _setI4(l); }
inline void CMQVariant::SetBLOB(BLOB const& b)          { FreeVariant(); _setBLOB(b); }
inline void CMQVariant::SetLPTSTR(TCHAR const* p)       { FreeVariant(); _setLPTSTR(p); }
inline void CMQVariant::SetCLSID(CLSID const* pg)       { FreeVariant(); _setCLSID(*pg); }
inline void CMQVariant::SetCACLSID(CACLSID const* p)    { FreeVariant(); _setCACLSID(*p); }
inline void CMQVariant::SetCALPWSTR(CALPWSTR const* p)  { FreeVariant(); _setCALPWSTR(*p); }
inline void CMQVariant::SetCAPROPVARIANT(CAPROPVARIANT const* p)  { FreeVariant(); _setCAPROPVARIANT(*p); }
inline void CMQVariant::SetPROPVARIANT(MQPROPVARIANT const* p)      { FreeVariant(); _setPROPVARIANT(*p); }

inline CMQVariant& CMQVariant::operator=(unsigned char ch)  { SetUI1(ch); return(*this); }
inline CMQVariant& CMQVariant::operator=(short i)           { SetI2(i); return(*this); }
inline CMQVariant& CMQVariant::operator=(long l)            { SetI4(l); return(*this); }
inline CMQVariant& CMQVariant::operator=(BLOB const& b)     { SetBLOB(b); return(*this); }
inline CMQVariant& CMQVariant::operator=(TCHAR const *p)    { SetLPTSTR(p); return(*this); }
inline CMQVariant& CMQVariant::operator=(CLSID const *p)    { SetCLSID(p); return(*this); }
inline CMQVariant& CMQVariant::operator=(CACLSID const* p)  { SetCACLSID(p); return(*this); }
inline CMQVariant& CMQVariant::operator=(CALPWSTR const* p) { SetCALPWSTR(p); return(*this); }
inline CMQVariant& CMQVariant::operator=(CAPROPVARIANT const* p) {SetCAPROPVARIANT(p); return(*this); }
inline CMQVariant& CMQVariant::operator=(CMQVariant const& v){ SetPROPVARIANT(&v); return(*this); }

inline CLSID* CMQVariant::GetCLSID(void)
{
    return(puuid);
}

inline const CACLSID *CMQVariant::GetCACLSID(void)
{
    return(&cauuid);
}

inline LPWSTR CMQVariant::GetLPWSTR(void)
{
    return(pwszVal);
}

inline LPTSTR CMQVariant::GetLPTSTR(void)
{
    return(pwszVal);
}

inline const CALPWSTR * CMQVariant::GetCALPWSTR(void)
{
    return(&calpwstr);
}

inline void MQFreeVariant(MQPROPVARIANT& var)
{
    ULONG i;

    switch (var.vt)
    {
        case VT_CLSID:
            delete[] var.puuid;
            break;
        case VT_LPWSTR:
            delete[] var.pwszVal;
            break;
        case VT_BLOB:
            delete[] var.blob.pBlobData;
            break;
        case (VT_VECTOR | VT_CLSID):
            delete[] var.cauuid.pElems;
            break;
        case (VT_VECTOR | VT_LPWSTR):
            for(i = 0; i < var.calpwstr.cElems; i++)
            {
                delete[] var.calpwstr.pElems[i];
            }
            delete [] var.calpwstr.pElems;
            break;
        case (VT_VECTOR | VT_VARIANT):
            for(i = 0; i < var.capropvar.cElems; i++)
            {
                MQFreeVariant(var.capropvar.pElems[i]);
            }
            delete[] var.capropvar.pElems;
            break;
        default:
            break;
    }

    var.vt = VT_EMPTY;
}

inline void CMQVariant::FreeVariant()
{
	MQFreeVariant(*this);
}

#endif // __PROPVAR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\_ta.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    ta.h

Abstract:

    Definition of the address type

Author:

    Erez Haba (erezh) 17-Jan-96

--*/

#ifndef __TA_H
#define __TA_H
//
// AddressType values
//
#define IP_ADDRESS_TYPE         1
#define IP_RAS_ADDRESS_TYPE     2

#define IPX_ADDRESS_TYPE        3
#define IPX_RAS_ADDRESS_TYPE    4

#define FOREIGN_ADDRESS_TYPE    5


#define IP_ADDRESS_LEN           4
#define IPX_ADDRESS_LEN         10
#define FOREIGN_ADDRESS_LEN     16

#define TA_ADDRESS_SIZE         4  // To be changed if following struct is changing
typedef struct  _TA_ADDRESS
{
    USHORT AddressLength;
    USHORT AddressType;
    UCHAR Address[ 1 ];
} TA_ADDRESS;


C_ASSERT(TA_ADDRESS_SIZE == FIELD_OFFSET(TA_ADDRESS, Address));

#endif // _TA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\libpch.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:
    libpch.h

Abstract:
    MSMQ Static Libraries master include file

Author:
    Erez Haba (erezh) 20-Dec-98

--*/

#pragma once

#ifndef _MSMQ_LIBPCH_H_
#define _MSMQ_LIBPCH_H_


#include <mqenv.h>
#include <mqmacro.h>
#include <mqstl.h>

#include <tr.h>
#include <cs.h>
#include <autoptr.h>
#include <autohandle.h>
#include <ref.h>


#endif // _MSMQ_LIBPCH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mqmakefile.inc ===
############################################################################
#
#   Copyright (C) 2000, Microsoft Corporation.
#
#   All rights reserved.
#
#   This file contains default definitions for building the MSMQ static
#   libraries under the NT build environment. It should be included into 
#   the sources file of any library and unit test with a line of the form
#
#   !include $(FROOT)\src\lib\inc\mqmakefile.inc
#
############################################################################

#
# Include master source file
#
!include $(FROOT)\src\inc\msmq.inc

#
# Set warning level
#
MSC_WARNING_LEVEL=/W4

#
# Set include path
#
INCLUDES=$(MSMQ_LIBINC_PATH);$(FROOT)\src\lib

#
# Precompiled directives. Sharing a common precompiled header for all
# libraries and tests.
#
PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=$(FROOT)\src\lib\inc\libpch.h
PRECOMPILED_OBJ=$(MSMQ_LIB_PATH)\libpch.obj
PRECOMPILED_TARGET=$(MSMQ_LIB_PATH)\libpch.pch
PRECOMPILED_OPTION=/Yulibpch.h /Fp$(PRECOMPILED_TARGET)

#
# Browser file directives. Sharing a common browser file for all libraries
# and unit tests.
#
BROWSERFILE=$(MSMQ_LIB_PATH)\lib.bsc
OTHER_SBR_FILES=$(FROOT)\src\lib\Ts\lib\$(O)\pch_hdr.sbr
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\mfc\afx.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFX_H__
#define __AFX_H__

#ifndef __cplusplus
	#error MFC requires C++ compilation (use a .cpp suffix)
#endif

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, on)
#endif

#include <mfc\afxver_.h>        // Target version control

/////////////////////////////////////////////////////////////////////////////
// Classes declared in this file
//   in addition to standard primitive data types and various helper macros

class CObject;                        // the root of all objects classes

// Non CObject classes
class CString;                        // growable string type

/////////////////////////////////////////////////////////////////////////////
// Other includes from standard "C" runtimes

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

/////////////////////////////////////////////////////////////////////////////
// Basic types

// abstract iteration position
struct __POSITION { int unused; };
typedef __POSITION* POSITION;

#define CPlex CPlexNew
struct CPlex;

struct _AFX_DOUBLE  { BYTE doubleBits[sizeof(double)]; };
struct _AFX_FLOAT   { BYTE floatBits[sizeof(float)]; };

// Standard constants
#undef FALSE
#undef TRUE
#undef NULL

#define FALSE   0
#define TRUE    1
#define NULL    0

/////////////////////////////////////////////////////////////////////////////
// Diagnostic support


#ifdef _DEBUG

inline BOOL AFXAPI AfxIsValidAddress(const void* lp, UINT nBytes, BOOL bReadWrite)
{
	// simple version using Win-32 APIs for pointer validation.
	return (lp != NULL && !IsBadReadPtr(lp, nBytes) &&
		(!bReadWrite || !IsBadWritePtr((LPVOID)lp, nBytes)));
}

void AFX_CDECL AfxTrace(LPCTSTR lpszFormat, ...);
// Note: file names are still ANSI strings (filenames rarely need UNICODE)
void AFXAPI AfxAssertValidObject(const CObject* pOb,
				LPCSTR lpszFileName, int nLine);
void AFXAPI AfxDump(const CObject* pOb); // Dump an object from CodeView

#define TRACE              ::AfxTrace
#define THIS_FILE          __FILE__

#define ASSERT_VALID(pOb)  ((pOb)->AssertValid())

// The following trace macros are provided for backward compatiblity
//  (they also take a fixed number of parameters which provides
//   some amount of extra error checking)
#define TRACE0(sz)              ::AfxTrace(_T("%s"), _T(sz))
#define TRACE1(sz, p1)          ::AfxTrace(_T(sz), p1)
#define TRACE2(sz, p1, p2)      ::AfxTrace(_T(sz), p1, p2)
#define TRACE3(sz, p1, p2, p3)  ::AfxTrace(_T(sz), p1, p2, p3)

// These AFX_DUMP macros also provided for backward compatibility
#define AFX_DUMP0(dc, sz)   dc << _T(sz)
#define AFX_DUMP1(dc, sz, p1) dc << _T(sz) << p1

#else   // _DEBUG

#define ASSERT_VALID(pOb)  ((void)0)
#define DEBUG_ONLY(f)      ((void)0)
inline void AFX_CDECL AfxTrace(LPCTSTR, ...) { }
#define TRACE              1 ? (void)0 : ::AfxTrace
#define TRACE0(sz)
#define TRACE1(sz, p1)
#define TRACE2(sz, p1, p2)
#define TRACE3(sz, p1, p2, p3)

#endif // !_DEBUG

#define ASSERT_POINTER(p, type) \
	ASSERT(((p) != NULL) && AfxIsValidAddress((p), sizeof(type), FALSE))

#define ASSERT_NULL_OR_POINTER(p, type) \
	ASSERT(((p) == NULL) || AfxIsValidAddress((p), sizeof(type), FALSE))

#ifdef _DEBUG
#define UNUSED(x)
#else
#define UNUSED(x) x
#endif
#define UNUSED_ALWAYS(x) x

/////////////////////////////////////////////////////////////////////////////
// Other implementation helpers

#define BEFORE_START_POSITION ((POSITION)-1L)

/////////////////////////////////////////////////////////////////////////////
// explicit initialization for general purpose classes

BOOL AFXAPI AfxInitialize(BOOL bDLL = FALSE, DWORD dwVersion = _MFC_VER);

#undef AFX_DATA
#define AFX_DATA AFX_CORE_DATA

/////////////////////////////////////////////////////////////////////////////
// Strings

#ifndef _OLEAUTO_H_
#ifdef OLE2ANSI
	typedef LPSTR BSTR;
#else
	typedef LPWSTR BSTR;// must (semantically) match typedef in oleauto.h
#endif
#endif

struct CStringData
{
	long nRefs;     // reference count
	int nDataLength;
	int nAllocLength;
	// TCHAR data[nAllocLength]

	TCHAR* data()
		{ return (TCHAR*)(this+1); }
};

class CString
{
public:
// Constructors
	CString();
	CString(const CString& stringSrc);
	CString(TCHAR ch, int nRepeat = 1);
	CString(LPCSTR lpsz);
	CString(LPCWSTR lpsz);
	CString(LPCTSTR lpch, int nLength);
	CString(const unsigned char* psz);

// Attributes & Operations
	// as an array of characters
	int GetLength() const;
	BOOL IsEmpty() const;
	void Empty();                       // free up the data

	TCHAR GetAt(int nIndex) const;      // 0 based
	TCHAR operator[](int nIndex) const; // same as GetAt
	void SetAt(int nIndex, TCHAR ch);
	operator LPCTSTR() const;           // as a C string

	// overloaded assignment
	const CString& operator=(const CString& stringSrc);
	const CString& operator=(TCHAR ch);
#ifdef _UNICODE
	const CString& operator=(char ch);
#endif
	const CString& operator=(LPCSTR lpsz);
	const CString& operator=(LPCWSTR lpsz);
	const CString& operator=(const unsigned char* psz);

	// string concatenation
	const CString& operator+=(const CString& string);
	const CString& operator+=(TCHAR ch);
#ifdef _UNICODE
	const CString& operator+=(char ch);
#endif
	const CString& operator+=(LPCTSTR lpsz);

	friend CString AFXAPI operator+(const CString& string1,
			const CString& string2);
	friend CString AFXAPI operator+(const CString& string, TCHAR ch);
	friend CString AFXAPI operator+(TCHAR ch, const CString& string);
#ifdef _UNICODE
	friend CString AFXAPI operator+(const CString& string, char ch);
	friend CString AFXAPI operator+(char ch, const CString& string);
#endif
	friend CString AFXAPI operator+(const CString& string, LPCTSTR lpsz);
	friend CString AFXAPI operator+(LPCTSTR lpsz, const CString& string);

	// string comparison
	int Compare(LPCTSTR lpsz) const;         // straight character
	int CompareNoCase(LPCTSTR lpsz) const;   // ignore case
	int Collate(LPCTSTR lpsz) const;         // NLS aware

	// simple sub-string extraction
	CString Mid(int nFirst, int nCount) const;
	CString Mid(int nFirst) const;
	CString Left(int nCount) const;
	CString Right(int nCount) const;

	CString SpanIncluding(LPCTSTR lpszCharSet) const;
	CString SpanExcluding(LPCTSTR lpszCharSet) const;

	// upper/lower/reverse conversion
	void MakeUpper();
	void MakeLower();
	void MakeReverse();

	// trimming whitespace (either side)
	void TrimRight();
	void TrimLeft();

	// searching (return starting index, or -1 if not found)
	// look for a single character match
	int Find(TCHAR ch) const;               // like "C" strchr
	int ReverseFind(TCHAR ch) const;
	int FindOneOf(LPCTSTR lpszCharSet) const;

	// look for a specific sub-string
	int Find(LPCTSTR lpszSub) const;        // like "C" strstr

	// simple formatting
	void AFX_CDECL Format(LPCTSTR lpszFormat, ...);
	void AFX_CDECL Format(UINT nFormatID, ...);

#ifndef _MAC
	// formatting for localization (uses FormatMessage API)
	void AFX_CDECL FormatMessage(LPCTSTR lpszFormat, ...);
	void AFX_CDECL FormatMessage(UINT nFormatID, ...);
#endif

	// Windows support
	BOOL LoadString(UINT nID);          // load from string resource
										// 255 chars max
#ifndef _UNICODE
	// ANSI <-> OEM support (convert string in place)
	void AnsiToOem();
	void OemToAnsi();
#endif

#ifndef _AFX_NO_BSTR_SUPPORT
	// OLE BSTR support (use for OLE automation)
	BSTR AllocSysString() const;
	BSTR SetSysString(BSTR* pbstr) const;
#endif

	// Access to string implementation buffer as "C" character array
	LPTSTR GetBuffer(int nMinBufLength);
	void ReleaseBuffer(int nNewLength = -1);
	LPTSTR GetBufferSetLength(int nNewLength);
	void FreeExtra();

	// Use LockBuffer/UnlockBuffer to turn refcounting off
	LPTSTR LockBuffer();
	void UnlockBuffer();

// Implementation
public:
	~CString();
	int GetAllocLength() const;

protected:
	LPTSTR m_pchData;   // pointer to ref counted string data

	// implementation helpers
	CStringData* GetData() const;
	void Init();
	void AllocCopy(CString& dest, int nCopyLen, int nCopyIndex, int nExtraLen) const;
	void AllocBuffer(int nLen);
	void AssignCopy(int nSrcLen, LPCTSTR lpszSrcData);
	void ConcatCopy(int nSrc1Len, LPCTSTR lpszSrc1Data, int nSrc2Len, LPCTSTR lpszSrc2Data);
	void ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData);
	void FormatV(LPCTSTR lpszFormat, va_list argList);
	void CopyBeforeWrite();
	void AllocBeforeWrite(int nLen);
	void Release();
	static void PASCAL Release(CStringData* pData);
	static int PASCAL SafeStrlen(LPCTSTR lpsz);
};

// Compare helpers
BOOL AFXAPI operator==(const CString& s1, const CString& s2);
BOOL AFXAPI operator==(const CString& s1, LPCTSTR s2);
BOOL AFXAPI operator==(LPCTSTR s1, const CString& s2);
BOOL AFXAPI operator!=(const CString& s1, const CString& s2);
BOOL AFXAPI operator!=(const CString& s1, LPCTSTR s2);
BOOL AFXAPI operator!=(LPCTSTR s1, const CString& s2);
BOOL AFXAPI operator<(const CString& s1, const CString& s2);
BOOL AFXAPI operator<(const CString& s1, LPCTSTR s2);
BOOL AFXAPI operator<(LPCTSTR s1, const CString& s2);
BOOL AFXAPI operator>(const CString& s1, const CString& s2);
BOOL AFXAPI operator>(const CString& s1, LPCTSTR s2);
BOOL AFXAPI operator>(LPCTSTR s1, const CString& s2);
BOOL AFXAPI operator<=(const CString& s1, const CString& s2);
BOOL AFXAPI operator<=(const CString& s1, LPCTSTR s2);
BOOL AFXAPI operator<=(LPCTSTR s1, const CString& s2);
BOOL AFXAPI operator>=(const CString& s1, const CString& s2);
BOOL AFXAPI operator>=(const CString& s1, LPCTSTR s2);
BOOL AFXAPI operator>=(LPCTSTR s1, const CString& s2);

// conversion helpers
int AFX_CDECL _wcstombsz(char* mbstr, const wchar_t* wcstr, size_t count);
int AFX_CDECL _mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count);

// Globals
extern AFX_DATA TCHAR afxChNil;
const CString& AFXAPI AfxGetEmptyString();
#define afxEmptyString AfxGetEmptyString()

/////////////////////////////////////////////////////////////////////////////
// class CObject is the root of all compliant objects

class CObject
{
public:
    virtual ~CObject() {}

#ifdef _DEBUG
	virtual void AssertValid() const {}
#endif
};

/////////////////////////////////////////////////////////////////////////////
// other helpers

// zero fill everything after the vtbl pointer
#define AFX_ZERO_INIT_OBJECT(base_class) \
	memset(((base_class*)this)+1, 0, sizeof(*this) - sizeof(class base_class));

/////////////////////////////////////////////////////////////////////////////
// Diagnostic memory management routines

// Low level sanity checks for memory blocks
BOOL AFXAPI AfxIsValidAddress(const void* lp,
			UINT nBytes, BOOL bReadWrite = TRUE);
inline BOOL AFXAPI AfxIsValidString(LPCWSTR lpsz, int nLength)
{
	if (lpsz == NULL)
		return FALSE;
	return !::IsBadReadPtr(lpsz, nLength);
}

#if defined(_DEBUG) && !defined(_AFX_NO_DEBUG_CRT)

// Memory tracking allocation
#define DEBUG_NEW new(__FILE__, __LINE__)

void* AFXAPI AfxAllocMemoryDebug(size_t nSize, BOOL bIsObject,
	LPCSTR lpszFileName, int nLine);
void AFXAPI AfxFreeMemoryDebug(void* pbData, BOOL bIsObject);

// Dump any memory leaks since program started
BOOL AFXAPI AfxDumpMemoryLeaks();

// Return TRUE if valid memory block of nBytes
BOOL AFXAPI AfxIsMemoryBlock(const void* p, UINT nBytes,
	LONG* plRequestNumber = NULL);

// Return TRUE if memory is sane or print out what is wrong
BOOL AFXAPI AfxCheckMemory();

#define afxMemDF _crtDbgFlag

enum AfxMemDF // memory debug/diagnostic flags
{
	allocMemDF          = 0x01,         // turn on debugging allocator
	delayFreeMemDF      = 0x02,         // delay freeing memory
	checkAlwaysMemDF    = 0x04          // AfxCheckMemory on every alloc/free
};

#ifdef _UNICODE
#define AfxOutputDebugString(lpsz) \
	do \
	{ \
		int _convert; _convert = 0; \
		_RPT0(_CRT_WARN, W2CA(lpsz)); \
	} while (0)
#else
#define AfxOutputDebugString(lpsz) _RPT0(_CRT_WARN, lpsz)
#endif

// turn on/off tracking for a short while
BOOL AFXAPI AfxEnableMemoryTracking(BOOL bTrack);

// Advanced initialization: for overriding default diagnostics
BOOL AFXAPI AfxDiagnosticInit(void);

// A failure hook returns whether to permit allocation
typedef BOOL (AFXAPI* AFX_ALLOC_HOOK)(size_t nSize, BOOL bObject, LONG lRequestNumber);

// Set new hook, return old (never NULL)
AFX_ALLOC_HOOK AFXAPI AfxSetAllocHook(AFX_ALLOC_HOOK pfnAllocHook);

// Debugger hook on specified allocation request - Obsolete
void AFXAPI AfxSetAllocStop(LONG lRequestNumber);

#else

// non-_DEBUG_ALLOC version that assume everything is OK
#define DEBUG_NEW new
#define AfxCheckMemory() TRUE
#define AfxIsMemoryBlock(p, nBytes) TRUE
#define AfxEnableMemoryTracking(bTrack) FALSE
#define AfxOutputDebugString(lpsz) ::OutputDebugString(lpsz)

// diagnostic initialization
#ifndef _DEBUG
#define AfxDiagnosticInit() TRUE
#else
BOOL AFXAPI AfxDiagnosticInit(void);
#endif

#endif // _DEBUG

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif


/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#define _AFX_INLINE inline
#include <mfc\afx.inl>

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, off)
#endif

#endif // __AFX_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\mfc\afxplex_.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXPLEX_H__
#define __AFXPLEX_H__

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef AFX_COLL_SEG
#pragma code_seg(AFX_COLL_SEG)
#endif

struct CPlex     // warning variable length structure
{
	CPlex* pNext;
#if (_AFX_PACKING >= 8)
	DWORD dwReserved[1];    // align on 8 byte boundary
#endif
	// BYTE data[maxNum*elementSize];

	void* data() { return this+1; }

	static CPlex* PASCAL Create(CPlex*& head, UINT nMax, UINT cbElement);
			// like 'calloc' but no zero fill
			// may throw memory exceptions

	void FreeDataChain();       // free this one and links
};

inline CPlex* PASCAL CPlex::Create(CPlex*& pHead, UINT nMax, UINT cbElement)
{
	ASSERT(nMax > 0 && cbElement > 0);
	CPlex* p = (CPlex*) new BYTE[sizeof(CPlex) + nMax * cbElement];
			// may throw exception
	p->pNext = pHead;
	pHead = p;  // change head (adds in reverse order for simplicity)
	return p;
}

inline void CPlex::FreeDataChain()     // free this one and links
{
	CPlex* p = this;
	while (p != NULL)
	{
		BYTE* bytes = (BYTE*) p;
		CPlex* pNext = p->pNext;
		delete[] bytes;
		p = pNext;
	}
}

#ifdef AFX_COLL_SEG
#pragma code_seg()
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#endif //__AFXPLEX_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\cm\lib\cm.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:
    cm.cpp

Abstract:
    This module contains configuration Manager stub.

Author:
    Uri Habusha (urih) 12-Jan-98

Enviroment:
    Platform-independent

--*/

#include <libpch.h>
#include <TimeTypes.h>
#include "Cm.h"
#include "Cmp.h"

#include "cm.tmh"

static HKEY s_hCmRootKey = NULL;

void CmpSetDefaultRootKey(HKEY hKey)
{
	s_hCmRootKey = hKey;
}

inline
void
ThrowMissingValue(
    const RegEntry& re
    )
{
    if(re.m_Flags == RegEntry::MustExist)
    {
        throw bad_alloc();
    }
}


inline 
HKEY
GetRootKey(
	const RegEntry& re
	)
{
	//
	// If the key handle is specified, the function use it
	// otherwise the root key that was defined on initilization 
	// is used
	//
	return ((re.m_Key != NULL) ? re.m_Key : s_hCmRootKey);
}


inline
void
ExpandRegistryValue(
	LPWSTR pBuffer,
	DWORD bufferSize
	)
{
	LPWSTR ptemp = static_cast<LPWSTR>(_alloca(bufferSize * sizeof(WCHAR)));
	wcscpy(ptemp, pBuffer);

	DWORD s = ExpandEnvironmentStrings(ptemp, pBuffer, bufferSize); 

	DBG_USED(s);

	ASSERT(s != 0);
	ASSERT(bufferSize >= s);
	
	return;
}


static
void
QueryValueInternal(
    const RegEntry& re,
    DWORD RegType,
    VOID* pBuffer,
    DWORD BufferSize
    )
{
    CRegHandle hKey = CmOpenKey(re, KEY_QUERY_VALUE);
    if (hKey == NULL)
    {
        return;
    }

    DWORD Type = RegType;
    DWORD Size = BufferSize;
    int rc = RegQueryValueEx (
                hKey,
                re.m_ValueName, 
                0,
                &Type, 
                static_cast<BYTE*>(pBuffer),
                &Size
                );

	if (rc != ERROR_SUCCESS)
    {
        ThrowMissingValue(re);
		return;
    }

	if ((Type == REG_EXPAND_SZ)	&& (RegType == REG_SZ))
	{
		//
		// The size is in bytes but it should be multiple of WCHAR size
		//
		ASSERT((BufferSize % sizeof(WCHAR)) == 0);

		//
		// Calculate the buffer size in WCHAR. ExpandRegistryValue expects to 
		// get the size in WCHAR
		//
		DWORD bufSizeInWchar = BufferSize / 2;

		ExpandRegistryValue(static_cast<LPWSTR>(pBuffer), bufSizeInWchar);
		return;
	}

    //
    // The registery value was featched, but its type or size isn't compatible
    //
    ASSERT((Type == RegType) && (BufferSize == Size));

}


static
DWORD
QueryExapndStringSize(
    const RegEntry& re,
    DWORD Size
    )
/*++
    Routine Description:
        The routine retreive the size of the expanded registry value.

    Arguments:
        None

    returned value:
        The size of expanded string

 --*/
{
	//
	// Alocate new buffer for reading the value
	//
    LPWSTR pRetValue = static_cast<LPWSTR>(_alloca(Size));

	//
	// featch the information from the registery
	//
	QueryValueInternal(re, REG_EXPAND_SZ, pRetValue, Size);

	DWORD expandedSize = ExpandEnvironmentStrings(pRetValue, NULL, 0);

	if (expandedSize == 0)
	{
        ThrowMissingValue(re);
        return 0;
	}

	return (DWORD)(max((expandedSize * sizeof(WCHAR)), Size));
}


static 
DWORD
QueryValueSize(
    const RegEntry& re,
    DWORD Type
    )
/*++
    Routine Description:
        The routine retreive the Register value size.

    Arguments:
        None

    returned value:
        TRUE if the intialization completes successfully. FALSE, otherwise

 --*/
{
    CRegHandle hKey = CmOpenKey(re, KEY_QUERY_VALUE);
    if (hKey == NULL)
    {
        return 0;
    }

    DWORD Size;
    int rc = RegQueryValueEx(
                hKey,
                re.m_ValueName, 
                0,
                &Type, 
                NULL,
                &Size
                );

    if (rc != ERROR_SUCCESS)
    {
        ThrowMissingValue(re);
        return 0;
    }

	if (Type == REG_EXPAND_SZ)
	{
		Size = QueryExapndStringSize(re, Size);
	}

    return Size;
}


static 
void
SetValueInternal(
    const RegEntry& re,
    DWORD RegType,
    const VOID* pBuffer,
    DWORD Size
    )
{
    //
    // Open the specified key. If the key doesn't exist in the registry, the function creates it.
    //
    CRegHandle hKey = CmCreateKey(re, KEY_SET_VALUE);

    int rc = RegSetValueEx(
                hKey,
                re.m_ValueName, 
                0,
                RegType, 
                static_cast<const BYTE*>(pBuffer),
                Size
                );

    if (rc != ERROR_SUCCESS)
    {
        ThrowMissingValue(re);
    }
}


void 
CmQueryValue(
    const RegEntry& re,
    DWORD* pValue
    )
{
    CmpAssertValid();
    
	*pValue = re.m_DefaultValue;
    QueryValueInternal(re, REG_DWORD, pValue, sizeof(DWORD));
}


void
CmQueryValue(
    const RegEntry& re,
    GUID* pValue
    )
{
    CmpAssertValid();

	*pValue = GUID_NULL;
    QueryValueInternal(re, REG_BINARY, pValue, sizeof(GUID));
}


void
CmQueryValue(
    const RegEntry& re,
    CTimeDuration* pValue
    )
{
    CmpAssertValid();

    DWORD timeout = re.m_DefaultValue;
    QueryValueInternal(re, REG_DWORD, &timeout, sizeof(DWORD));

    //
    // The time is stored in millisec units in registery. Convert it to 
    // CTimeDuration tick units (100 ns).
    //
    *pValue = CTimeDuration(timeout * CTimeDuration::OneMilliSecond().Ticks());
}


void
CmQueryValue(
    const RegEntry& re,
    BYTE** pValue,
    DWORD* pSize
    )
{
    CmpAssertValid();

    *pSize = 0;
	*pValue = NULL;

    //
    // Get the data size
    //
    DWORD Size = QueryValueSize(re, REG_BINARY);
    if (Size != 0)
    {
		//
		// Alocate new buffer for reading the value
		//
		AP<BYTE> pRetValue = new BYTE[Size];

		//
		// featch the information from the registery
		//
		QueryValueInternal(re, REG_BINARY, pRetValue, Size);

		*pSize = Size;
		*pValue = pRetValue.detach();
	}
}
                       

void 
CmQueryValue(
    const RegEntry& re, 
    WCHAR** pValue
    )
{
    CmpAssertValid();

	*pValue = NULL;

    //
    // Get the data size
    //
    DWORD Size = QueryValueSize(re, REG_SZ);

	//
	// The size returnes in bytes but it should be multiple of WCHAR size
	//
	ASSERT((Size % sizeof(WCHAR)) == 0);

    if (Size != 0)
    {
		//
		// Alocate new buffer for reading the value
		//
		AP<WCHAR> pRetValue = new WCHAR[Size / 2];

		//
		// featch the information from the registery
		//
		QueryValueInternal(re, REG_SZ, pRetValue, Size);
		*pValue = pRetValue.detach();
	}
}


void 
CmSetValue(
    const RegEntry& re,                       
    DWORD Value
    )
{
    CmpAssertValid();

    SetValueInternal(re, REG_DWORD, &Value, sizeof(DWORD));
}


void 
CmSetValue(
    const RegEntry& re,                       
    const CTimeDuration& Value
    )
{
    CmpAssertValid();

    //
    // Store the time in registry in millisec units
    //
    DWORD timeout = static_cast<DWORD>(Value.InMilliSeconds());

    SetValueInternal(re, REG_DWORD, &timeout, sizeof(DWORD));
}


bool
CmEnumValue(
	HKEY hKey,
	DWORD index,
	LPWSTR* ppValueName
	)
/*++

Routine Description:
	Return value name of a given key in a given index

Arguments:
    IN - hKey - An open key handle or any of the registery predefined handle values

	IN - DWORD index - index of the value name - to enumerate - on first call should be  0 - 
		then increament on each call.

	OUT - LPWSTR* ppValueName - receive the value name when the function returns.

Returned value:
	True if the function succeeded  in returning the value name - otherwise false.
	In case of unexpected errors - the function throw std::bad_alloc

Note:
	For some reason - the function RegEnumValue - does not return the actual length of the 
	value name. You just have to try to increament the buffer untill it fits			

 --*/
{
    CmpAssertValid();
    
	ASSERT(ppValueName);
	
	//
	// First try to fit the name value into 16 wide chars
	//
	DWORD len = 16;
	for(;;)
	{
		AP<WCHAR> pValueName = new WCHAR[len];
		LONG hr = RegEnumValue(	
						hKey,
						index,
						pValueName,
						&len,
						NULL,
						NULL,
						NULL,
						NULL
						);

		if(hr == ERROR_SUCCESS)
		{
			*ppValueName = pValueName.detach();
			return true;
		}

		if(hr == ERROR_NO_MORE_ITEMS)
		{
			return false;
		}

		if(hr != ERROR_MORE_DATA)
		{
			throw bad_alloc();
		}
	
		//
		// buffer is to small - try dobule size
		//
		len = len * 2;	
	}
	return true; 
}


void
CmSetValue(
    const RegEntry& re,                       
    const GUID* pGuid
    )
{
    CmpAssertValid();
    
    SetValueInternal(re, REG_BINARY, pGuid, sizeof(GUID));
}


void
CmSetValue(
    const RegEntry& re,                       
    const BYTE* pByte,
    DWORD Size
    )
{
    CmpAssertValid();
    
    SetValueInternal(re, REG_BINARY, pByte, Size);

}


void 
CmSetValue(
    const RegEntry& re, 
    const WCHAR* pString
    )
{
    CmpAssertValid();
    
	DWORD size = (wcslen(pString) + 1) * sizeof(WCHAR);
    SetValueInternal(re, REG_SZ, pString, size);
}


void CmDeleteValue(const RegEntry& re)
{
    CmpAssertValid();

    CRegHandle hKey = CmOpenKey(re, KEY_SET_VALUE);

    if (hKey == NULL)
        return;

    int rc = RegDeleteValue(hKey, re.m_ValueName);
    if (rc == ERROR_FILE_NOT_FOUND)
    {
        //
        // The value doesn't exist. Handle like delete succeeded
        //
        return;
    }

    if (rc != ERROR_SUCCESS)
    {
        ThrowMissingValue(re);
    }
}


HKEY
CmCreateKey(
    const RegEntry& re,
	REGSAM securityAccess
    )
{
    CmpAssertValid();

    //
    // RegCreateKeyEx doesn't accept NULL subkey. To behave like RegOpenKey
    // pass an empty string instead of the NULL pointer
    //
    LPCWSTR subKey = (re.m_SubKey == NULL) ? L"" : re.m_SubKey;

	HKEY hKey;
	DWORD Disposition;
	int rc = RegCreateKeyEx(
				GetRootKey(re),
                subKey,
				0,
				NULL,
				REG_OPTION_NON_VOLATILE,
				securityAccess,
				NULL,
				&hKey,
				&Disposition
				);

    if (rc != ERROR_SUCCESS)
    {
        ThrowMissingValue(re);
        return NULL;
    }

    return hKey;
}


void CmDeleteKey(const RegEntry& re)
{
    ASSERT(re.m_SubKey != NULL);

	int rc = RegDeleteKey(GetRootKey(re), re.m_SubKey);

    if (rc == ERROR_FILE_NOT_FOUND)
    {
        //
        // The key doesn't exist. Handle like delete succeeded
        //
        return;
    }

    if (rc != ERROR_SUCCESS)
    {
        ThrowMissingValue(re);
    }
}


HKEY
CmOpenKey(
    const RegEntry& re,
	REGSAM securityAccess
    )
{
	CmpAssertValid();

    HKEY hKey;
    int rc = RegOpenKeyEx(
                    GetRootKey(re),
                    re.m_SubKey,
                    0,
                    securityAccess,
                    &hKey
                    );

    if (rc != ERROR_SUCCESS)
    {
        ThrowMissingValue(re);
        return NULL;
    }

    return hKey;
}


void CmCloseKey(HKEY hKey)
{
    CmpAssertValid();

	RegCloseKey(hKey);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\mfc\afxver_.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// afxver_.h - target version/configuration control

/////////////////////////////////////////////////////////////////////////////
// Master version numbers

#define _AFX     1      // Microsoft Application Framework Classes
#define _MFC_VER 0x0410 // Microsoft Foundation Classes version 4.10

/////////////////////////////////////////////////////////////////////////////
// Default swap tuning for AFX library

#ifndef _68K_
	#define _TEXTSEG(name)  ".text$" #name
#else
	#define _TEXTSEG(name)  #name, "swappable"
#endif

// Most segments are tuned via function order list (DLL version)
#ifndef _AFX_FUNCTION_ORDER
#define AFX_CORE1_SEG   _TEXTSEG(AFX_CORE1) // core functionality
#define AFX_CORE2_SEG   _TEXTSEG(AFX_CORE2) // more core functionality
#define AFX_CORE3_SEG   _TEXTSEG(AFX_CORE3) // more core functionality
#define AFX_CORE4_SEG   _TEXTSEG(AFX_CORE4) // more core functionality
#define AFX_AUX_SEG     _TEXTSEG(AFX_AUX)   // auxilliary functionality
#define AFX_COLL_SEG    _TEXTSEG(AFX_COL1)  // collections
#define AFX_COLL2_SEG   _TEXTSEG(AFX_COL2)  // more collections
#define AFX_OLE_SEG     _TEXTSEG(AFX_OLE1)  // OLE support
#define AFX_OLE2_SEG    _TEXTSEG(AFX_OLE2)  // more OLE support
#define AFX_OLE3_SEG    _TEXTSEG(AFX_OLE3)  // and more OLE support
#define AFX_OLE4_SEG    _TEXTSEG(AFX_OLE4)  // and more OLE support
#define AFX_OLE5_SEG    _TEXTSEG(AFX_OLE5)  // and even more OLE support
#define AFX_OLERA_SEG	_TEXTSEG(AFX_OLERA) // (reserved for future use)
#define AFX_PRINT_SEG   _TEXTSEG(AFX_PRNT)  // Printing functionality
#define AFX_DBG1_SEG    _TEXTSEG(AFX_DBG1)  // inlines go here in _DEBUG
#define AFX_DBG2_SEG    _TEXTSEG(AFX_DBG2)  // inlines go here in _DEBUG
#define AFX_VDEL_SEG    _TEXTSEG(AFX_VDEL)  // vector deleting destructors
#define AFX_TERM_SEG    _TEXTSEG(AFX_TERM)  // cleanup routines
#define AFX_MAPI_SEG    _TEXTSEG(AFX_MAPI)  // simple MAPI support
#define AFX_SOCK_SEG    _TEXTSEG(AFX_SOCK)  // windows sockets support
#else
#define AFX_CORE1_SEG                       // core functionality
#define AFX_CORE2_SEG                       // more core functionality
#define AFX_CORE3_SEG                       // more core functionality
#define AFX_CORE4_SEG                       // more core functionality
#define AFX_AUX_SEG                         // auxilliary functionality
#define AFX_COLL_SEG                        // collections
#define AFX_COLL2_SEG                       // more collections
#define AFX_OLE_SEG                         // OLE support
#define AFX_OLE2_SEG                        // more OLE support
#define AFX_OLE3_SEG                        // and more OLE support
#define AFX_OLE4_SEG                        // and more OLE support
#define AFX_OLE5_SEG                        // and even more OLE support
#define AFX_OLERA_SEG						// (reserved for future use)
#define AFX_PRINT_SEG                       // Printing functionality
#define AFX_DBG1_SEG                        // inlines go here in _DEBUG
#define AFX_DBG2_SEG                        // inlines go here in _DEBUG
#define AFX_VDEL_SEG                        // vector deleting destructors
#define AFX_TERM_SEG                        // cleanup routines
#define AFX_MAPI_SEG                        // simple MAPI support
#define AFX_SOCK_SEG                        // windows sockets support
#endif

// AFX_INIT_SEG is hand tuned even in DLL version
#define AFX_INIT_SEG    _TEXTSEG(AFX_INIT)  // initialization

/////////////////////////////////////////////////////////////////////////////
// turn off reference tracking for certain often used symbols

#ifndef _AFX_PORTABLE
#pragma component(browser, off, references, "ASSERT")
#pragma component(browser, off, references, "BOOL")
#pragma component(browser, off, references, "BYTE")
#pragma component(browser, off, references, "DECLSPEC_IMPORT")
#pragma component(browser, off, references, "DWORD")
#pragma component(browser, off, references, "FALSE")
#pragma component(browser, off, references, "FAR")
#pragma component(browser, off, references, "LPSTR")
#pragma component(browser, off, references, "NULL")
#pragma component(browser, off, references, "PASCAL")
#pragma component(browser, off, references, "THIS_FILE")
#pragma component(browser, off, references, "TRUE")
#pragma component(browser, off, references, "UINT")
#pragma component(browser, off, references, "WINAPI")
#pragma component(browser, off, references, "WORD")
#endif  //!_AFX_PORTABLE

/////////////////////////////////////////////////////////////////////////////
// For target version (one of)
//   _CUSTOM   : for custom configurations (causes afxv_cfg.h to be included)
//
// Additional build options:
//  _DEBUG              debug versions (full diagnostics)
//  _AFXDLL             use shared MFC DLL
//  _AFXEXT             extension DLL version, implies _AFXDLL
//  _USRDLL             create regular DLL (_AFXDLL is valid too)
//

#define _AFX_NO_NESTED_DERIVATION

/////////////////////////////////////////////////////////////////////////////
// Special configurations

// _AFXEXT implies _AFXDLL
#if defined(_AFXEXT) && !defined(_AFXDLL)
	#define _AFXDLL
#endif

#if defined(_AFXDLL) && !defined(_DLL)
	#error Please use the /MD switch for _AFXDLL builds
#endif

#ifndef _MAC
#if defined(_AFXDLL) && !defined(_MT)
	#error Please use the /MD switch (multithreaded DLL C-runtime)
#endif
#endif

/////////////////////////////////////////////////////////////////////////////
// special include files

#if defined(_X86_) || defined(_MAC)
	#define _AFX_MINREBUILD
#endif

// setup default packing value
#ifndef _AFX_PACKING
    #ifdef _WIN64
        #define _AFX_PACKING    8
    #else
	    #define _AFX_PACKING    4   // default packs structs at 4 bytes
    #endif //_WIN64
#endif

#ifdef _AFXDLL
#else
	#define _AFX_NO_OCX_SUPPORT
#endif

// Define this virtual key for use by status bar
#ifndef VK_KANA
#define VK_KANA             0x15
#endif

/////////////////////////////////////////////////////////////////////////////
// Standard preprocessor symbols if not already defined
/////////////////////////////////////////////////////////////////////////////

// SIZE_T_MAX is used by the collection classes
#ifndef SIZE_T_MAX
	#define SIZE_T_MAX  UINT_MAX
#endif

// PASCAL is used for static member functions
#ifndef PASCAL
	#define PASCAL
#endif

// CDECL and EXPORT are defined in case WINDOWS.H doesn't
#ifndef CDECL
	#define CDECL __cdecl
#endif

#ifndef EXPORT
	#define EXPORT
#endif

// UNALIGNED is used for unaligned data access (in CArchive mostly)
#ifndef UNALIGNED
	#define UNALIGNED
#endif

// AFXAPI is used on global public functions
#ifndef AFXAPI
	#define AFXAPI __stdcall
#endif

// AFXOLEAPI is used for some special OLE functions
#ifndef AFXOLEAPI
	#define AFXOLEAPI __stdcall
#endif

// AFX_CDECL is used for rare functions taking variable arguments
#ifndef AFX_CDECL
	#define AFX_CDECL __cdecl
#endif

// AFX_EXPORT is used for functions which need to be exported
#ifndef AFX_EXPORT
	#define AFX_EXPORT EXPORT
#endif

// The following macros are used to enable export/import

// for data
#ifndef AFX_DATA_EXPORT
	#define AFX_DATA_EXPORT __declspec(dllexport)
#endif
#ifndef AFX_DATA_IMPORT
	#define AFX_DATA_IMPORT __declspec(dllimport)
#endif

// for classes
#ifndef AFX_CLASS_EXPORT
	#define AFX_CLASS_EXPORT __declspec(dllexport)
#endif
#ifndef AFX_CLASS_IMPORT
	#define AFX_CLASS_IMPORT __declspec(dllimport)
#endif

// for global APIs
#ifndef AFX_API_EXPORT
	#define AFX_API_EXPORT __declspec(dllexport)
#endif
#ifndef AFX_API_IMPORT
	#define AFX_API_IMPORT __declspec(dllimport)
#endif

// The following macros are used on data declarations/definitions
//  (they are redefined for extension DLLs and the shared MFC DLL)
#define AFX_DATA
#define AFX_DATADEF

// used when building the "core" MFC40.DLL
#ifndef AFX_CORE_DATA
	#define AFX_CORE_DATA
	#define AFX_CORE_DATADEF
#endif

// used when building the MFC/OLE support MFCO40.DLL
#ifndef AFX_OLE_DATA
	#define AFX_OLE_DATA
	#define AFX_OLE_DATADEF
#endif

// used when building the MFC/DB support MFCD40.DLL
#ifndef AFX_DB_DATA
	#define AFX_DB_DATA
	#define AFX_DB_DATADEF
#endif

// used when building the MFC/NET support MFCN40.DLL
#ifndef AFX_NET_DATA
	#define AFX_NET_DATA
	#define AFX_NET_DATADEF
#endif

// used when building extension DLLs
#ifndef AFX_EXT_DATA
	#define AFX_EXT_DATA
	#define AFX_EXT_DATADEF
	#define AFX_EXT_CLASS
	#define AFX_EXT_API
#endif

// BASED_XXXX macros are provided for backward compatibility
#ifndef BASED_CODE
	#define BASED_CODE
#endif

#ifndef BASED_DEBUG
	#define BASED_DEBUG
#endif

#ifndef BASED_STACK
	#define BASED_STACK
#endif

// setup default code segment
#ifdef AFX_DEF_SEG
	#pragma code_seg(AFX_DEF_SEG)
#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\mfc\afxtempl.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXTEMPL_H__
#define __AFXTEMPL_H__

#ifndef __AFXPLEX_H__
	#include <mfc\afxplex_.h>
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _DEBUG
static char _szAfxTempl[] = "afxtempl.h";
#undef THIS_FILE
#define THIS_FILE _szAfxTempl
#endif

#ifndef ALL_WARNINGS
#pragma warning(disable: 4114)
#endif

/////////////////////////////////////////////////////////////////////////////
// global helpers (can be overridden)

#ifdef new
#undef new
#define _REDEF_NEW
#endif

#ifndef _INC_NEW
	#include <new.h>
#endif

template<class TYPE>
inline void AFXAPI ConstructElements(TYPE* pElements, int nCount)
{
	ASSERT(nCount == 0 ||
		AfxIsValidAddress(pElements, nCount * sizeof(TYPE)));

	// first do bit-wise zero initialization
	memset((void*)pElements, 0, nCount * sizeof(TYPE));

	// then call the constructor(s)
	for (; nCount--; pElements++)
		::new((void*)pElements) TYPE;
}

template<class TYPE>
inline void AFXAPI DestructElements(TYPE* pElements, int nCount)
{
	ASSERT(nCount == 0 ||
		AfxIsValidAddress(pElements, nCount * sizeof(TYPE)));

	// call the destructor(s)
	for (; nCount--; pElements++)
		pElements->~TYPE();
}

template<class TYPE>
inline void AFXAPI CopyElements(TYPE* pDest, const TYPE* pSrc, int nCount)
{
	ASSERT(nCount == 0 ||
		AfxIsValidAddress(pDest, nCount * sizeof(TYPE)));
	ASSERT(nCount == 0 ||
		AfxIsValidAddress(pSrc, nCount * sizeof(TYPE), FALSE));

	// default is element-copy using assignment
	while (nCount--)
		*pDest++ = *pSrc++;
}

template<class TYPE, class ARG_TYPE>
BOOL AFXAPI CompareElements(const TYPE* pElement1, const ARG_TYPE* pElement2)
{
	ASSERT(AfxIsValidAddress(pElement1, sizeof(TYPE), FALSE));
	ASSERT(AfxIsValidAddress(pElement2, sizeof(ARG_TYPE), FALSE));

	return *pElement1 == *pElement2;
}

template<class ARG_KEY>
inline UINT AFXAPI HashKey(ARG_KEY key)
{
	// default identity hash - works for most primitive values
#ifdef _WIN64
#pragma warning(push)
#pragma warning(disable : 4311) //'type cast' : pointer truncation from 'const unsigned short *__ptr64 ' to 'unsigned long'
#endif //_WIN64
	return ((UINT)(ULONG_PTR)key) >> 4;
#ifdef _WIN64
#pragma warning(pop) 
#endif //_WIN64
}

// special versions for CString
void AFXAPI ConstructElements(CString* pElements, int nCount);
void AFXAPI DestructElements(CString* pElements, int nCount);
void AFXAPI CopyElements(CString* pDest, const CString* pSrc, int nCount);
UINT AFXAPI HashKey(LPCTSTR key);

#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// CArray<TYPE, ARG_TYPE>

template<class TYPE, class ARG_TYPE>
class CArray : public CObject
{
public:
// Construction
	CArray();

// Attributes
	int GetSize() const;
	int GetUpperBound() const;
	void SetSize(int nNewSize, int nGrowBy = -1);

// Operations
	// Clean up
	void FreeExtra();
	void RemoveAll();

	// Accessing elements
	TYPE GetAt(int nIndex) const;
	void SetAt(int nIndex, ARG_TYPE newElement);
	TYPE& ElementAt(int nIndex);

	// Direct Access to the element data (may return NULL)
	const TYPE* GetData() const;
	TYPE* GetData();

	// Potentially growing the array
	void SetAtGrow(int nIndex, ARG_TYPE newElement);
	int Add(ARG_TYPE newElement);
	int Append(const CArray& src);
	void Copy(const CArray& src);

	// overloaded operator helpers
	TYPE operator[](int nIndex) const;
	TYPE& operator[](int nIndex);

	// Operations that move elements around
	void InsertAt(int nIndex, ARG_TYPE newElement, int nCount = 1);
	void RemoveAt(int nIndex, int nCount = 1);
	void InsertAt(int nStartIndex, CArray* pNewArray);

// Implementation
protected:
	TYPE* m_pData;   // the actual array of data
	int m_nSize;     // # of elements (upperBound - 1)
	int m_nMaxSize;  // max allocated
	int m_nGrowBy;   // grow amount

public:
	~CArray();
#ifdef _DEBUG
	void AssertValid() const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CArray<TYPE, ARG_TYPE> inline functions

template<class TYPE, class ARG_TYPE>
inline int CArray<TYPE, ARG_TYPE>::GetSize() const
	{ return m_nSize; }
template<class TYPE, class ARG_TYPE>
inline int CArray<TYPE, ARG_TYPE>::GetUpperBound() const
	{ return m_nSize-1; }
template<class TYPE, class ARG_TYPE>
inline void CArray<TYPE, ARG_TYPE>::RemoveAll()
	{ SetSize(0, -1); }
template<class TYPE, class ARG_TYPE>
inline TYPE CArray<TYPE, ARG_TYPE>::GetAt(int nIndex) const
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_pData[nIndex]; }
template<class TYPE, class ARG_TYPE>
inline void CArray<TYPE, ARG_TYPE>::SetAt(int nIndex, ARG_TYPE newElement)
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		m_pData[nIndex] = newElement; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CArray<TYPE, ARG_TYPE>::ElementAt(int nIndex)
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_pData[nIndex]; }
template<class TYPE, class ARG_TYPE>
inline const TYPE* CArray<TYPE, ARG_TYPE>::GetData() const
	{ return (const TYPE*)m_pData; }
template<class TYPE, class ARG_TYPE>
inline TYPE* CArray<TYPE, ARG_TYPE>::GetData()
	{ return (TYPE*)m_pData; }
template<class TYPE, class ARG_TYPE>
inline int CArray<TYPE, ARG_TYPE>::Add(ARG_TYPE newElement)
	{ int nIndex = m_nSize;
		SetAtGrow(nIndex, newElement);
		return nIndex; }
template<class TYPE, class ARG_TYPE>
inline TYPE CArray<TYPE, ARG_TYPE>::operator[](int nIndex) const
	{ return GetAt(nIndex); }
template<class TYPE, class ARG_TYPE>
inline TYPE& CArray<TYPE, ARG_TYPE>::operator[](int nIndex)
	{ return ElementAt(nIndex); }

/////////////////////////////////////////////////////////////////////////////
// CArray<TYPE, ARG_TYPE> out-of-line functions

template<class TYPE, class ARG_TYPE>
CArray<TYPE, ARG_TYPE>::CArray()
{
	m_pData = NULL;
	m_nSize = m_nMaxSize = m_nGrowBy = 0;
}

template<class TYPE, class ARG_TYPE>
CArray<TYPE, ARG_TYPE>::~CArray()
{
	ASSERT_VALID(this);

	if (m_pData != NULL)
	{
		DestructElements<TYPE>(m_pData, m_nSize);
		delete[] (BYTE*)m_pData;
	}
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::SetSize(int nNewSize, int nGrowBy)
{
	ASSERT_VALID(this);
	ASSERT(nNewSize >= 0);

	if (nGrowBy != -1)
		m_nGrowBy = nGrowBy;  // set new size

	if (nNewSize == 0)
	{
		// shrink to nothing
		if (m_pData != NULL)
		{
			DestructElements<TYPE>(m_pData, m_nSize);
			delete[] (BYTE*)m_pData;
			m_pData = NULL;
		}
		m_nSize = m_nMaxSize = 0;
	}
	else if (m_pData == NULL)
	{
		// create one with exact size
#ifdef SIZE_T_MAX
		ASSERT(nNewSize <= SIZE_T_MAX/sizeof(TYPE));    // no overflow
#endif
		m_pData = (TYPE*) new BYTE[nNewSize * sizeof(TYPE)];
		ConstructElements<TYPE>(m_pData, nNewSize);
		m_nSize = m_nMaxSize = nNewSize;
	}
	else if (nNewSize <= m_nMaxSize)
	{
		// it fits
		if (nNewSize > m_nSize)
		{
			// initialize the new elements
			ConstructElements<TYPE>(&m_pData[m_nSize], nNewSize-m_nSize);
		}
		else if (m_nSize > nNewSize)
		{
			// destroy the old elements
			DestructElements<TYPE>(&m_pData[nNewSize], m_nSize-nNewSize);
		}
		m_nSize = nNewSize;
	}
	else
	{
		// otherwise, grow array
		int nGrowBy = m_nGrowBy;
		if (nGrowBy == 0)
		{
			// heuristically determine growth when nGrowBy == 0
			//  (this avoids heap fragmentation in many situations)
			nGrowBy = m_nSize / 8;
			nGrowBy = (nGrowBy < 4) ? 4 : ((nGrowBy > 1024) ? 1024 : nGrowBy);
		}
		int nNewMax;
		if (nNewSize < m_nMaxSize + nGrowBy)
			nNewMax = m_nMaxSize + nGrowBy;  // granularity
		else
			nNewMax = nNewSize;  // no slush

		ASSERT(nNewMax >= m_nMaxSize);  // no wrap around
#ifdef SIZE_T_MAX
		ASSERT(nNewMax <= SIZE_T_MAX/sizeof(TYPE)); // no overflow
#endif
		TYPE* pNewData = (TYPE*) new BYTE[nNewMax * sizeof(TYPE)];

		// copy new data from old
		memcpy(pNewData, m_pData, m_nSize * sizeof(TYPE));

		// construct remaining elements
		ASSERT(nNewSize > m_nSize);
		ConstructElements<TYPE>(&pNewData[m_nSize], nNewSize-m_nSize);

		// get rid of old stuff (note: no destructors called)
		delete[] (BYTE*)m_pData;
		m_pData = pNewData;
		m_nSize = nNewSize;
		m_nMaxSize = nNewMax;
	}
}

template<class TYPE, class ARG_TYPE>
int CArray<TYPE, ARG_TYPE>::Append(const CArray& src)
{
	ASSERT_VALID(this);
	ASSERT(this != &src);   // cannot append to itself

	int nOldSize = m_nSize;
	SetSize(m_nSize + src.m_nSize);
	CopyElements<TYPE>(m_pData + nOldSize, src.m_pData, src.m_nSize);
	return nOldSize;
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::Copy(const CArray& src)
{
	ASSERT_VALID(this);
	ASSERT(this != &src);   // cannot append to itself

	SetSize(src.m_nSize);
	CopyElements<TYPE>(m_pData, src.m_pData, src.m_nSize);
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::FreeExtra()
{
	ASSERT_VALID(this);

	if (m_nSize != m_nMaxSize)
	{
		// shrink to desired size
#ifdef SIZE_T_MAX
		ASSERT(m_nSize <= SIZE_T_MAX/sizeof(TYPE)); // no overflow
#endif
		TYPE* pNewData = NULL;
		if (m_nSize != 0)
		{
			pNewData = (TYPE*) new BYTE[m_nSize * sizeof(TYPE)];
			// copy new data from old
			memcpy(pNewData, m_pData, m_nSize * sizeof(TYPE));
		}

		// get rid of old stuff (note: no destructors called)
		delete[] (BYTE*)m_pData;
		m_pData = pNewData;
		m_nMaxSize = m_nSize;
	}
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::SetAtGrow(int nIndex, ARG_TYPE newElement)
{
	ASSERT_VALID(this);
	ASSERT(nIndex >= 0);

	if (nIndex >= m_nSize)
		SetSize(nIndex+1, -1);
	m_pData[nIndex] = newElement;
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::InsertAt(int nIndex, ARG_TYPE newElement, int nCount /*=1*/)
{
	ASSERT_VALID(this);
	ASSERT(nIndex >= 0);    // will expand to meet need
	ASSERT(nCount > 0);     // zero or negative size not allowed

	if (nIndex >= m_nSize)
	{
		// adding after the end of the array
		SetSize(nIndex + nCount, -1);   // grow so nIndex is valid
	}
	else
	{
		// inserting in the middle of the array
		int nOldSize = m_nSize;
		SetSize(m_nSize + nCount, -1);  // grow it to new size
		// destroy intial data before copying over it
		DestructElements<TYPE>(&m_pData[nOldSize], nCount);
		// shift old data up to fill gap
		memmove(&m_pData[nIndex+nCount], &m_pData[nIndex],
			(nOldSize-nIndex) * sizeof(TYPE));

		// re-init slots we copied from
		ConstructElements<TYPE>(&m_pData[nIndex], nCount);
	}

	// insert new value in the gap
	ASSERT(nIndex + nCount <= m_nSize);
	while (nCount--)
		m_pData[nIndex++] = newElement;
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::RemoveAt(int nIndex, int nCount)
{
	ASSERT_VALID(this);
	ASSERT(nIndex >= 0);
	ASSERT(nCount >= 0);
	ASSERT(nIndex + nCount <= m_nSize);

	// just remove a range
	int nMoveCount = m_nSize - (nIndex + nCount);
	DestructElements<TYPE>(&m_pData[nIndex], nCount);
	if (nMoveCount)
		memcpy(&m_pData[nIndex], &m_pData[nIndex + nCount],
			nMoveCount * sizeof(TYPE));
	m_nSize -= nCount;
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::InsertAt(int nStartIndex, CArray* pNewArray)
{
	ASSERT_VALID(this);
	ASSERT(pNewArray != NULL);
	ASSERT_VALID(pNewArray);
	ASSERT(nStartIndex >= 0);

	if (pNewArray->GetSize() > 0)
	{
		InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize());
		for (int i = 0; i < pNewArray->GetSize(); i++)
			SetAt(nStartIndex + i, pNewArray->GetAt(i));
	}
}

#ifdef _DEBUG
template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::AssertValid() const
{
	CObject::AssertValid();

	if (m_pData == NULL)
	{
		ASSERT(m_nSize == 0);
		ASSERT(m_nMaxSize == 0);
	}
	else
	{
		ASSERT(m_nSize >= 0);
		ASSERT(m_nMaxSize >= 0);
		ASSERT(m_nSize <= m_nMaxSize);
		ASSERT(AfxIsValidAddress(m_pData, m_nMaxSize * sizeof(TYPE)));
	}
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CList<TYPE, ARG_TYPE>

template<class TYPE, class ARG_TYPE>
class CList : public CObject
{
protected:
	struct CNode
	{
		CNode* pNext;
		CNode* pPrev;
		TYPE data;
	};
public:
// Construction
	CList(int nBlockSize = 10);

// Attributes (head and tail)
	// count of elements
	int GetCount() const;
	BOOL IsEmpty() const;

	// peek at head or tail
	TYPE& GetHead();
	TYPE GetHead() const;
	TYPE& GetTail();
	TYPE GetTail() const;

// Operations
	// get head or tail (and remove it) - don't call on empty list !
	TYPE RemoveHead();
	TYPE RemoveTail();

	// add before head or after tail
	POSITION AddHead(ARG_TYPE newElement);
	POSITION AddTail(ARG_TYPE newElement);

	// add another list of elements before head or after tail
	void AddHead(CList* pNewList);
	void AddTail(CList* pNewList);

	// remove all elements
	void RemoveAll();

	// iteration
	POSITION GetHeadPosition() const;
	POSITION GetTailPosition() const;
	TYPE& GetNext(POSITION& rPosition); // return *Position++
	TYPE GetNext(POSITION& rPosition) const; // return *Position++
	TYPE& GetPrev(POSITION& rPosition); // return *Position--
	TYPE GetPrev(POSITION& rPosition) const; // return *Position--

	// getting/modifying an element at a given position
	TYPE& GetAt(POSITION position);
	TYPE GetAt(POSITION position) const;
	void SetAt(POSITION pos, ARG_TYPE newElement);
	void RemoveAt(POSITION position);

	// inserting before or after a given position
	POSITION InsertBefore(POSITION position, ARG_TYPE newElement);
	POSITION InsertAfter(POSITION position, ARG_TYPE newElement);

	// helper functions (note: O(n) speed)
	POSITION Find(ARG_TYPE searchValue, POSITION startAfter = NULL) const;
		// defaults to starting at the HEAD, return NULL if not found
	POSITION FindIndex(int nIndex) const;
		// get the 'nIndex'th element (may return NULL)

// Implementation
protected:
	CNode* m_pNodeHead;
	CNode* m_pNodeTail;
	int m_nCount;
	CNode* m_pNodeFree;
	struct CPlex* m_pBlocks;
	int m_nBlockSize;

	CNode* NewNode(CNode*, CNode*);
	void FreeNode(CNode*);

public:
	~CList();
#ifdef _DEBUG
	void AssertValid() const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CList<TYPE, ARG_TYPE> inline functions

template<class TYPE, class ARG_TYPE>
inline int CList<TYPE, ARG_TYPE>::GetCount() const
	{ return m_nCount; }
template<class TYPE, class ARG_TYPE>
inline BOOL CList<TYPE, ARG_TYPE>::IsEmpty() const
	{ return m_nCount == 0; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetHead()
	{ ASSERT(m_pNodeHead != NULL);
		return m_pNodeHead->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetHead() const
	{ ASSERT(m_pNodeHead != NULL);
		return m_pNodeHead->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetTail()
	{ ASSERT(m_pNodeTail != NULL);
		return m_pNodeTail->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetTail() const
	{ ASSERT(m_pNodeTail != NULL);
		return m_pNodeTail->data; }
template<class TYPE, class ARG_TYPE>
inline POSITION CList<TYPE, ARG_TYPE>::GetHeadPosition() const
	{ return (POSITION) m_pNodeHead; }
template<class TYPE, class ARG_TYPE>
inline POSITION CList<TYPE, ARG_TYPE>::GetTailPosition() const
	{ return (POSITION) m_pNodeTail; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetNext(POSITION& rPosition) // return *Position++
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		rPosition = (POSITION) pNode->pNext;
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetNext(POSITION& rPosition) const // return *Position++
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		rPosition = (POSITION) pNode->pNext;
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetPrev(POSITION& rPosition) // return *Position--
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		rPosition = (POSITION) pNode->pPrev;
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetPrev(POSITION& rPosition) const // return *Position--
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		rPosition = (POSITION) pNode->pPrev;
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CList<TYPE, ARG_TYPE>::GetAt(POSITION position)
	{ CNode* pNode = (CNode*) position;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CList<TYPE, ARG_TYPE>::GetAt(POSITION position) const
	{ CNode* pNode = (CNode*) position;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline void CList<TYPE, ARG_TYPE>::SetAt(POSITION pos, ARG_TYPE newElement)
	{ CNode* pNode = (CNode*) pos;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		pNode->data = newElement; }

template<class TYPE, class ARG_TYPE>
CList<TYPE, ARG_TYPE>::CList(int nBlockSize)
{
	ASSERT(nBlockSize > 0);

	m_nCount = 0;
	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
	m_pBlocks = NULL;
	m_nBlockSize = nBlockSize;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::RemoveAll()
{
	ASSERT_VALID(this);

	// destroy elements
	CNode* pNode;
	for (pNode = m_pNodeHead; pNode != NULL; pNode = pNode->pNext)
		DestructElements<TYPE>(&pNode->data, 1);

	m_nCount = 0;
	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
	m_pBlocks->FreeDataChain();
	m_pBlocks = NULL;
}

template<class TYPE, class ARG_TYPE>
CList<TYPE, ARG_TYPE>::~CList()
{
	RemoveAll();
	ASSERT(m_nCount == 0);
}

/////////////////////////////////////////////////////////////////////////////
// Node helpers
//
// Implementation note: CNode's are stored in CPlex blocks and
//  chained together. Free blocks are maintained in a singly linked list
//  using the 'pNext' member of CNode with 'm_pNodeFree' as the head.
//  Used blocks are maintained in a doubly linked list using both 'pNext'
//  and 'pPrev' as links and 'm_pNodeHead' and 'm_pNodeTail'
//   as the head/tail.
//
// We never free a CPlex block unless the List is destroyed or RemoveAll()
//  is used - so the total number of CPlex blocks may grow large depending
//  on the maximum past size of the list.
//

template<class TYPE, class ARG_TYPE>
CList<TYPE, ARG_TYPE>::CNode*
CList<TYPE, ARG_TYPE>::NewNode(CList::CNode* pPrev, CList::CNode* pNext)
{
	if (m_pNodeFree == NULL)
	{
		// add another block
		CPlex* pNewBlock = CPlex::Create(m_pBlocks, m_nBlockSize,
				 sizeof(CNode));

		// chain them into free list
		CNode* pNode = (CNode*) pNewBlock->data();
		// free in reverse order to make it easier to debug
		pNode += m_nBlockSize - 1;
		for (int i = m_nBlockSize-1; i >= 0; i--, pNode--)
		{
			pNode->pNext = m_pNodeFree;
			m_pNodeFree = pNode;
		}
	}
	ASSERT(m_pNodeFree != NULL);  // we must have something

	CList::CNode* pNode = m_pNodeFree;
	m_pNodeFree = m_pNodeFree->pNext;
	pNode->pPrev = pPrev;
	pNode->pNext = pNext;
	m_nCount++;
	ASSERT(m_nCount > 0);  // make sure we don't overflow

	ConstructElements<TYPE>(&pNode->data, 1);
	return pNode;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::FreeNode(CList::CNode* pNode)
{
	DestructElements<TYPE>(&pNode->data, 1);
	pNode->pNext = m_pNodeFree;
	m_pNodeFree = pNode;
	m_nCount--;
	ASSERT(m_nCount >= 0);  // make sure we don't underflow

	// if no more elements, cleanup completely
	if (m_nCount == 0)
		RemoveAll();
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::AddHead(ARG_TYPE newElement)
{
	ASSERT_VALID(this);

	CNode* pNewNode = NewNode(NULL, m_pNodeHead);
	pNewNode->data = newElement;
	if (m_pNodeHead != NULL)
		m_pNodeHead->pPrev = pNewNode;
	else
		m_pNodeTail = pNewNode;
	m_pNodeHead = pNewNode;
	return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::AddTail(ARG_TYPE newElement)
{
	ASSERT_VALID(this);

	CNode* pNewNode = NewNode(m_pNodeTail, NULL);
	pNewNode->data = newElement;
	if (m_pNodeTail != NULL)
		m_pNodeTail->pNext = pNewNode;
	else
		m_pNodeHead = pNewNode;
	m_pNodeTail = pNewNode;
	return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::AddHead(CList* pNewList)
{
	ASSERT_VALID(this);

	ASSERT(pNewList != NULL);
	ASSERT_VALID(pNewList);

	// add a list of same elements to head (maintain order)
	POSITION pos = pNewList->GetTailPosition();
	while (pos != NULL)
		AddHead(pNewList->GetPrev(pos));
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::AddTail(CList* pNewList)
{
	ASSERT_VALID(this);
	ASSERT(pNewList != NULL);
	ASSERT_VALID(pNewList);

	// add a list of same elements
	POSITION pos = pNewList->GetHeadPosition();
	while (pos != NULL)
		AddTail(pNewList->GetNext(pos));
}

template<class TYPE, class ARG_TYPE>
TYPE CList<TYPE, ARG_TYPE>::RemoveHead()
{
	ASSERT_VALID(this);
	ASSERT(m_pNodeHead != NULL);  // don't call on empty list !!!
	ASSERT(AfxIsValidAddress(m_pNodeHead, sizeof(CNode)));

	CNode* pOldNode = m_pNodeHead;
	TYPE returnValue = pOldNode->data;

	m_pNodeHead = pOldNode->pNext;
	if (m_pNodeHead != NULL)
		m_pNodeHead->pPrev = NULL;
	else
		m_pNodeTail = NULL;
	FreeNode(pOldNode);
	return returnValue;
}

template<class TYPE, class ARG_TYPE>
TYPE CList<TYPE, ARG_TYPE>::RemoveTail()
{
	ASSERT_VALID(this);
	ASSERT(m_pNodeTail != NULL);  // don't call on empty list !!!
	ASSERT(AfxIsValidAddress(m_pNodeTail, sizeof(CNode)));

	CNode* pOldNode = m_pNodeTail;
	TYPE returnValue = pOldNode->data;

	m_pNodeTail = pOldNode->pPrev;
	if (m_pNodeTail != NULL)
		m_pNodeTail->pNext = NULL;
	else
		m_pNodeHead = NULL;
	FreeNode(pOldNode);
	return returnValue;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::InsertBefore(POSITION position, ARG_TYPE newElement)
{
	ASSERT_VALID(this);

	if (position == NULL)
		return AddHead(newElement); // insert before nothing -> head of the list

	// Insert it before position
	CNode* pOldNode = (CNode*) position;
	CNode* pNewNode = NewNode(pOldNode->pPrev, pOldNode);
	pNewNode->data = newElement;

	if (pOldNode->pPrev != NULL)
	{
		ASSERT(AfxIsValidAddress(pOldNode->pPrev, sizeof(CNode)));
		pOldNode->pPrev->pNext = pNewNode;
	}
	else
	{
		ASSERT(pOldNode == m_pNodeHead);
		m_pNodeHead = pNewNode;
	}
	pOldNode->pPrev = pNewNode;
	return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::InsertAfter(POSITION position, ARG_TYPE newElement)
{
	ASSERT_VALID(this);

	if (position == NULL)
		return AddTail(newElement); // insert after nothing -> tail of the list

	// Insert it before position
	CNode* pOldNode = (CNode*) position;
	ASSERT(AfxIsValidAddress(pOldNode, sizeof(CNode)));
	CNode* pNewNode = NewNode(pOldNode, pOldNode->pNext);
	pNewNode->data = newElement;

	if (pOldNode->pNext != NULL)
	{
		ASSERT(AfxIsValidAddress(pOldNode->pNext, sizeof(CNode)));
		pOldNode->pNext->pPrev = pNewNode;
	}
	else
	{
		ASSERT(pOldNode == m_pNodeTail);
		m_pNodeTail = pNewNode;
	}
	pOldNode->pNext = pNewNode;
	return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::RemoveAt(POSITION position)
{
	ASSERT_VALID(this);

	CNode* pOldNode = (CNode*) position;
	ASSERT(AfxIsValidAddress(pOldNode, sizeof(CNode)));

	// remove pOldNode from list
	if (pOldNode == m_pNodeHead)
	{
		m_pNodeHead = pOldNode->pNext;
	}
	else
	{
		ASSERT(AfxIsValidAddress(pOldNode->pPrev, sizeof(CNode)));
		pOldNode->pPrev->pNext = pOldNode->pNext;
	}
	if (pOldNode == m_pNodeTail)
	{
		m_pNodeTail = pOldNode->pPrev;
	}
	else
	{
		ASSERT(AfxIsValidAddress(pOldNode->pNext, sizeof(CNode)));
		pOldNode->pNext->pPrev = pOldNode->pPrev;
	}
	FreeNode(pOldNode);
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::FindIndex(int nIndex) const
{
	ASSERT_VALID(this);
	ASSERT(nIndex >= 0);

	if (nIndex >= m_nCount)
		return NULL;  // went too far

	CNode* pNode = m_pNodeHead;
	while (nIndex--)
	{
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		pNode = pNode->pNext;
	}
	return (POSITION) pNode;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::Find(ARG_TYPE searchValue, POSITION startAfter) const
{
	ASSERT_VALID(this);

	CNode* pNode = (CNode*) startAfter;
	if (pNode == NULL)
	{
		pNode = m_pNodeHead;  // start at head
	}
	else
	{
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		pNode = pNode->pNext;  // start after the one specified
	}

	for (; pNode != NULL; pNode = pNode->pNext)
		if (CompareElements<TYPE>(&pNode->data, &searchValue))
			return (POSITION)pNode;
	return NULL;
}

#ifdef _DEBUG
template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::AssertValid() const
{
	CObject::AssertValid();

	if (m_nCount == 0)
	{
		// empty list
		ASSERT(m_pNodeHead == NULL);
		ASSERT(m_pNodeTail == NULL);
	}
	else
	{
		// non-empty list
		ASSERT(AfxIsValidAddress(m_pNodeHead, sizeof(CNode)));
		ASSERT(AfxIsValidAddress(m_pNodeTail, sizeof(CNode)));
	}
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
class CMap : public CObject
{
protected:
	// Association
	struct CAssoc
	{
		CAssoc* pNext;
		UINT nHashValue;  // needed for efficient iteration
		KEY key;
		VALUE value;
	};
public:
// Construction
	CMap(int nBlockSize = 10);

// Attributes
	// number of elements
	int GetCount() const;
	BOOL IsEmpty() const;

	// Lookup
	BOOL Lookup(ARG_KEY key, VALUE& rValue) const;

// Operations
	// Lookup and add if not there
	VALUE& operator[](ARG_KEY key);

	// add a new (key, value) pair
	void SetAt(ARG_KEY key, ARG_VALUE newValue);

	// removing existing (key, ?) pair
	BOOL RemoveKey(ARG_KEY key);
	void RemoveAll();

	// iterating all (key, value) pairs
	POSITION GetStartPosition() const;
	void GetNextAssoc(POSITION& rNextPosition, KEY& rKey, VALUE& rValue) const;

	// advanced features for derived classes
	UINT GetHashTableSize() const;
	void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

// Implementation
protected:
	CAssoc** m_pHashTable;
	UINT m_nHashTableSize;
	int m_nCount;
	CAssoc* m_pFreeList;
	struct CPlex* m_pBlocks;
	int m_nBlockSize;

	CAssoc* NewAssoc();
	void FreeAssoc(CAssoc*);
	CAssoc* GetAssocAt(ARG_KEY, UINT&) const;

public:
	~CMap();
#ifdef _DEBUG
	void AssertValid() const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CMap<KEY, ARG_KEY, VALUE, ARG_VALUE> inline functions

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline int CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetCount() const
	{ return m_nCount; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline BOOL CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::IsEmpty() const
	{ return m_nCount == 0; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::SetAt(ARG_KEY key, ARG_VALUE newValue)
	{ (*this)[key] = newValue; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline POSITION CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetStartPosition() const
	{ return (m_nCount == 0) ? NULL : BEFORE_START_POSITION; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline UINT CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetHashTableSize() const
	{ return m_nHashTableSize; }

/////////////////////////////////////////////////////////////////////////////
// CMap<KEY, ARG_KEY, VALUE, ARG_VALUE> out-of-line functions

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CMap(int nBlockSize)
{
	ASSERT(nBlockSize > 0);

	m_pHashTable = NULL;
	m_nHashTableSize = 17;  // default size
	m_nCount = 0;
	m_pFreeList = NULL;
	m_pBlocks = NULL;
	m_nBlockSize = nBlockSize;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::InitHashTable(
	UINT nHashSize, BOOL bAllocNow)
//
// Used to force allocation of a hash table or to override the default
//   hash table size of (which is fairly small)
{
	ASSERT_VALID(this);
	ASSERT(m_nCount == 0);
	ASSERT(nHashSize > 0);

	if (m_pHashTable != NULL)
	{
		// free hash table
		delete[] m_pHashTable;
		m_pHashTable = NULL;
	}

	if (bAllocNow)
	{
		m_pHashTable = new CAssoc* [nHashSize];
		memset(m_pHashTable, 0, sizeof(CAssoc*) * nHashSize);
	}
	m_nHashTableSize = nHashSize;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::RemoveAll()
{
	ASSERT_VALID(this);

	if (m_pHashTable != NULL)
	{
		// destroy elements (values and keys)
		for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++)
		{
			CAssoc* pAssoc;
			for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL;
			  pAssoc = pAssoc->pNext)
			{
				DestructElements<VALUE>(&pAssoc->value, 1);
				DestructElements<KEY>(&pAssoc->key, 1);
			}
		}
	}

	// free hash table
	delete[] m_pHashTable;
	m_pHashTable = NULL;

	m_nCount = 0;
	m_pFreeList = NULL;
	m_pBlocks->FreeDataChain();
	m_pBlocks = NULL;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::~CMap()
{
	RemoveAll();
	ASSERT(m_nCount == 0);
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CAssoc*
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::NewAssoc()
{
	if (m_pFreeList == NULL)
	{
		// add another block
		CPlex* newBlock = CPlex::Create(m_pBlocks, m_nBlockSize, sizeof(CMap::CAssoc));
		// chain them into free list
		CMap::CAssoc* pAssoc = (CMap::CAssoc*) newBlock->data();
		// free in reverse order to make it easier to debug
		pAssoc += m_nBlockSize - 1;
		for (int i = m_nBlockSize-1; i >= 0; i--, pAssoc--)
		{
			pAssoc->pNext = m_pFreeList;
			m_pFreeList = pAssoc;
		}
	}
	ASSERT(m_pFreeList != NULL);  // we must have something

	CMap::CAssoc* pAssoc = m_pFreeList;
	m_pFreeList = m_pFreeList->pNext;
	m_nCount++;
	ASSERT(m_nCount > 0);  // make sure we don't overflow
	ConstructElements<KEY>(&pAssoc->key, 1);
	ConstructElements<VALUE>(&pAssoc->value, 1);   // special construct values
	return pAssoc;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::FreeAssoc(CMap::CAssoc* pAssoc)
{
	DestructElements<VALUE>(&pAssoc->value, 1);
	DestructElements<KEY>(&pAssoc->key, 1);
	pAssoc->pNext = m_pFreeList;
	m_pFreeList = pAssoc;
	m_nCount--;
	ASSERT(m_nCount >= 0);  // make sure we don't underflow

	// if no more elements, cleanup completely
	if (m_nCount == 0)
		RemoveAll();
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CAssoc*
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetAssocAt(ARG_KEY key, UINT& nHash) const
// find association (or return NULL)
{
	nHash = HashKey<ARG_KEY>(key) % m_nHashTableSize;

	if (m_pHashTable == NULL)
		return NULL;

	// see if it exists
	CAssoc* pAssoc;
	for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL; pAssoc = pAssoc->pNext)
	{
		if (CompareElements(&pAssoc->key, &key))
			return pAssoc;
	}
	return NULL;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::Lookup(ARG_KEY key, VALUE& rValue) const
{
	ASSERT_VALID(this);

	UINT nHash;
	CAssoc* pAssoc = GetAssocAt(key, nHash);
	if (pAssoc == NULL)
		return FALSE;  // not in map

	rValue = pAssoc->value;
	return TRUE;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
VALUE& CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::operator[](ARG_KEY key)
{
	ASSERT_VALID(this);

	UINT nHash;
	CAssoc* pAssoc;
	if ((pAssoc = GetAssocAt(key, nHash)) == NULL)
	{
		if (m_pHashTable == NULL)
			InitHashTable(m_nHashTableSize);

		// it doesn't exist, add a new Association
		pAssoc = NewAssoc();
		pAssoc->nHashValue = nHash;
		pAssoc->key = key;
		// 'pAssoc->value' is a constructed object, nothing more

		// put into hash table
		pAssoc->pNext = m_pHashTable[nHash];
		m_pHashTable[nHash] = pAssoc;
	}
	return pAssoc->value;  // return new reference
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::RemoveKey(ARG_KEY key)
// remove key - return TRUE if removed
{
	ASSERT_VALID(this);

	if (m_pHashTable == NULL)
		return FALSE;  // nothing in the table

	CAssoc** ppAssocPrev;
	ppAssocPrev = &m_pHashTable[HashKey<ARG_KEY>(key) % m_nHashTableSize];

	CAssoc* pAssoc;
	for (pAssoc = *ppAssocPrev; pAssoc != NULL; pAssoc = pAssoc->pNext)
	{
		if (CompareElements(&pAssoc->key, &key))
		{
			// remove it
			*ppAssocPrev = pAssoc->pNext;  // remove from list
			FreeAssoc(pAssoc);
			return TRUE;
		}
		ppAssocPrev = &pAssoc->pNext;
	}
	return FALSE;  // not found
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetNextAssoc(POSITION& rNextPosition,
	KEY& rKey, VALUE& rValue) const
{
	ASSERT_VALID(this);
	ASSERT(m_pHashTable != NULL);  // never call on empty map

	CAssoc* pAssocRet = (CAssoc*)rNextPosition;
	ASSERT(pAssocRet != NULL);

	if (pAssocRet == (CAssoc*) BEFORE_START_POSITION)
	{
		// find the first association
		for (UINT nBucket = 0; nBucket < m_nHashTableSize; nBucket++)
			if ((pAssocRet = m_pHashTable[nBucket]) != NULL)
				break;
		ASSERT(pAssocRet != NULL);  // must find something
	}

	// find next association
	ASSERT(AfxIsValidAddress(pAssocRet, sizeof(CAssoc)));
	CAssoc* pAssocNext;
	if ((pAssocNext = pAssocRet->pNext) == NULL)
	{
		// go to next bucket
		for (UINT nBucket = pAssocRet->nHashValue + 1;
		  nBucket < m_nHashTableSize; nBucket++)
			if ((pAssocNext = m_pHashTable[nBucket]) != NULL)
				break;
	}

	rNextPosition = (POSITION) pAssocNext;

	// fill in return data
	rKey = pAssocRet->key;
	rValue = pAssocRet->value;
}

#ifdef _DEBUG
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::AssertValid() const
{
	CObject::AssertValid();

	ASSERT(m_nHashTableSize > 0);
	ASSERT(m_nCount == 0 || m_pHashTable != NULL);
		// non-empty map should have hash table
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CTypedPtrArray<BASE_CLASS, TYPE>

template<class BASE_CLASS, class TYPE>
class CTypedPtrArray : public BASE_CLASS
{
public:
	// Accessing elements
	TYPE GetAt(int nIndex) const
		{ return (TYPE)BASE_CLASS::GetAt(nIndex); }
	TYPE& ElementAt(int nIndex)
		{ return (TYPE&)BASE_CLASS::ElementAt(nIndex); }

	// overloaded operator helpers
	TYPE operator[](int nIndex) const
		{ return (TYPE)BASE_CLASS::operator[](nIndex); }
	TYPE& operator[](int nIndex)
		{ return (TYPE&)BASE_CLASS::operator[](nIndex); }
};

/////////////////////////////////////////////////////////////////////////////
// CTypedPtrList<BASE_CLASS, TYPE>

template<class BASE_CLASS, class TYPE>
class CTypedPtrList : public BASE_CLASS
{
public:
	// peek at head or tail
	TYPE& GetHead()
		{ return (TYPE&)BASE_CLASS::GetHead(); }
	TYPE GetHead() const
		{ return (TYPE)BASE_CLASS::GetHead(); }
	TYPE& GetTail()
		{ return (TYPE&)BASE_CLASS::GetTail(); }
	TYPE GetTail() const
		{ return (TYPE)BASE_CLASS::GetTail(); }

	// get head or tail (and remove it) - don't call on empty list!
	TYPE RemoveHead()
		{ return (TYPE)BASE_CLASS::RemoveHead(); }
	TYPE RemoveTail()
		{ return (TYPE)BASE_CLASS::RemoveTail(); }

	// iteration
	TYPE& GetNext(POSITION& rPosition)
		{ return (TYPE&)BASE_CLASS::GetNext(rPosition); }
	TYPE GetNext(POSITION& rPosition) const
		{ return (TYPE)BASE_CLASS::GetNext(rPosition); }
	TYPE& GetPrev(POSITION& rPosition)
		{ return (TYPE&)BASE_CLASS::GetPrev(rPosition); }
	TYPE GetPrev(POSITION& rPosition) const
		{ return (TYPE)BASE_CLASS::GetPrev(rPosition); }

	// getting/modifying an element at a given position
	TYPE& GetAt(POSITION position)
		{ return (TYPE&)BASE_CLASS::GetAt(position); }
	TYPE GetAt(POSITION position) const
		{ return (TYPE)BASE_CLASS::GetAt(position); }
};

/////////////////////////////////////////////////////////////////////////////
// CTypedPtrMap<BASE_CLASS, KEY, VALUE>

template<class BASE_CLASS, class KEY, class VALUE>
class CTypedPtrMap : public BASE_CLASS
{
public:
	// Lookup
	BOOL Lookup(BASE_CLASS::BASE_ARG_KEY key, VALUE& rValue) const
		{ return BASE_CLASS::Lookup(key, (BASE_CLASS::BASE_VALUE&)rValue); }

	// Lookup and add if not there
	VALUE& operator[](BASE_CLASS::BASE_ARG_KEY key)
		{ return (VALUE&)BASE_CLASS::operator[](key); }

	// iteration
	void GetNextAssoc(POSITION& rPosition, KEY& rKey, VALUE& rValue) const
		{ BASE_CLASS::GetNextAssoc(rPosition, (BASE_CLASS::BASE_KEY&)rKey,
			(BASE_CLASS::BASE_VALUE&)rValue); }
};

/////////////////////////////////////////////////////////////////////////////

#undef THIS_FILE
#define THIS_FILE __FILE__

#undef new
#ifdef _REDEF_NEW
#define new DEBUG_NEW
#undef _REDEF_NEW
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif
#ifndef _AFX_FULLTYPEINFO
#pragma component(mintypeinfo, off)
#endif

#endif //__AFXTEMPL_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\inc\mfc\afx.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFX.H

#ifdef _AFX_INLINE

// CString
_AFX_INLINE CStringData* CString::GetData() const
	{ ASSERT(m_pchData != NULL); return ((CStringData*)m_pchData)-1; }
_AFX_INLINE void CString::Init()
	{ m_pchData = afxEmptyString.m_pchData; }
_AFX_INLINE CString::CString(const unsigned char* lpsz)
	{ Init(); *this = (LPCSTR)lpsz; }
_AFX_INLINE const CString& CString::operator=(const unsigned char* lpsz)
	{ *this = (LPCSTR)lpsz; return *this; }
#ifdef _UNICODE
_AFX_INLINE const CString& CString::operator+=(char ch)
	{ *this += (TCHAR)ch; return *this; }
_AFX_INLINE const CString& CString::operator=(char ch)
	{ *this = (TCHAR)ch; return *this; }
_AFX_INLINE CString AFXAPI operator+(const CString& string, char ch)
	{ return string + (TCHAR)ch; }
_AFX_INLINE CString AFXAPI operator+(char ch, const CString& string)
	{ return (TCHAR)ch + string; }
#endif

_AFX_INLINE int CString::GetLength() const
	{ return GetData()->nDataLength; }
_AFX_INLINE int CString::GetAllocLength() const
	{ return GetData()->nAllocLength; }
_AFX_INLINE BOOL CString::IsEmpty() const
	{ return GetData()->nDataLength == 0; }
_AFX_INLINE CString::operator LPCTSTR() const
	{ return m_pchData; }
_AFX_INLINE int PASCAL CString::SafeStrlen(LPCTSTR lpsz)
	{ return (lpsz == NULL) ? 0 : lstrlen(lpsz); }

// CString support (windows specific)
_AFX_INLINE int CString::Compare(LPCTSTR lpsz) const
	{ return _tcscmp(m_pchData, lpsz); }    // MBCS/Unicode aware
_AFX_INLINE int CString::CompareNoCase(LPCTSTR lpsz) const
	{ return _tcsicmp(m_pchData, lpsz); }   // MBCS/Unicode aware
// CString::Collate is often slower than Compare but is MBSC/Unicode
//  aware as well as locale-sensitive with respect to sort order.
_AFX_INLINE int CString::Collate(LPCTSTR lpsz) const
	{ return _tcscoll(m_pchData, lpsz); }   // locale sensitive

_AFX_INLINE TCHAR CString::GetAt(int nIndex) const
{
	ASSERT(nIndex >= 0);
	ASSERT(nIndex < GetData()->nDataLength);
	return m_pchData[nIndex];
}
_AFX_INLINE TCHAR CString::operator[](int nIndex) const
{
	// same as GetAt
	ASSERT(nIndex >= 0);
	ASSERT(nIndex < GetData()->nDataLength);
	return m_pchData[nIndex];
}
_AFX_INLINE BOOL AFXAPI operator==(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) == 0; }
_AFX_INLINE BOOL AFXAPI operator==(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) == 0; }
_AFX_INLINE BOOL AFXAPI operator==(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) == 0; }
_AFX_INLINE BOOL AFXAPI operator!=(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) != 0; }
_AFX_INLINE BOOL AFXAPI operator!=(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) != 0; }
_AFX_INLINE BOOL AFXAPI operator!=(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) != 0; }
_AFX_INLINE BOOL AFXAPI operator<(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) < 0; }
_AFX_INLINE BOOL AFXAPI operator<(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) < 0; }
_AFX_INLINE BOOL AFXAPI operator<(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) > 0; }
_AFX_INLINE BOOL AFXAPI operator>(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) > 0; }
_AFX_INLINE BOOL AFXAPI operator>(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) > 0; }
_AFX_INLINE BOOL AFXAPI operator>(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) < 0; }
_AFX_INLINE BOOL AFXAPI operator<=(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) <= 0; }
_AFX_INLINE BOOL AFXAPI operator<=(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) <= 0; }
_AFX_INLINE BOOL AFXAPI operator<=(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) >= 0; }
_AFX_INLINE BOOL AFXAPI operator>=(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) >= 0; }
_AFX_INLINE BOOL AFXAPI operator>=(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) >= 0; }
_AFX_INLINE BOOL AFXAPI operator>=(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) <= 0; }

/////////////////////////////////////////////////////////////////////////////

#endif //_AFX_INLINE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\cm\lib\cmp.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Cmp.h

Abstract:
    Configuration Manager private functions.

Author:
    Uri Habusha (urih) 18-Jul-99

--*/

#pragma once

const TraceIdEntry Cm = L"Configuration Manager";

#ifdef _DEBUG

void CmpAssertValid(void);
void CmpSetInitialized(void);
BOOL CmpIsInitialized(void);
void CmpRegisterComponent(void);

#else // _DEBUG

#define CmpAssertValid() ((void)0)
#define CmpSetInitialized() ((void)0)
#define CmpIsInitialized() TRUE
#define CmpRegisterComponent() ((void)0)

#endif // _DEBUG

void CmpSetDefaultRootKey(HKEY hKey);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\cm\lib\cminit.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    CmInit.cpp

Abstract:
    Configuration Manager initialization

Author:
    Uri Habusha (urih) 18-Jul-99

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include "Cm.h"
#include "Cmp.h"

#include "cminit.tmh"

VOID
CmInitialize(
	HKEY hKey,
	LPCWSTR KeyPath
	)
/*++

Routine Description:
    Intialize the configuration manger. Open the specified registery key as a
	default key for subsequent calls. The key handle is stored for further use

Arguments:
    hKey - An open key handle or any of the registery predefined handle values

	KeyPath - The name of the default subkey to open

Returned value:
	None.

Note:
	If the function can't opened the registery key an exception is raised.

 --*/
{
    ASSERT(!CmpIsInitialized());

    CmpSetInitialized();

	ASSERT(hKey != NULL);
	ASSERT(KeyPath != NULL);

    //
    // The root key must exist otherwise an exception will be thrown
    //
	RegEntry Root(KeyPath, 0, 0, RegEntry::MustExist, hKey);
	HKEY hRootKey = CmOpenKey(Root, KEY_ALL_ACCESS);
    ASSERT(hRootKey != NULL);

	CmpSetDefaultRootKey(hRootKey);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\cry\lib\crydebug.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    CryDebug.cpp

Abstract:
    Cryptograph debugging

Author:
    Ilan Herbst (ilanh) 06-Mar-00

Environment:
    Platform-independent, _DEBUG only

--*/

#include <libpch.h>
#include "Cry.h"
#include "Cryp.h"

#include "crydebug.tmh"

#ifdef _DEBUG

//---------------------------------------------------------
//
// Validate Cryptograph state
//
void CrypAssertValid(void)
{
    //
    // CryInitalize() has *not* been called. You should initialize the
    // Cryptograph library before using any of its funcionality.
    //
    ASSERT(CrypIsInitialized());

    //
    // TODO:Add more Cryptograph validation code.
    //
}


//---------------------------------------------------------
//
// Initialization Control
//
static LONG s_fInitialized = FALSE;

void CrypSetInitialized(void)
{
    LONG fCryAlreadyInitialized = InterlockedExchange(&s_fInitialized, TRUE);

    //
    // The Cryptograph library has *already* been initialized. You should
    // not initialize it more than once. This assertion would be violated
    // if two or more threads initalize it concurently.
    //
    ASSERT(!fCryAlreadyInitialized);
}


BOOL CrypIsInitialized(void)
{
    return s_fInitialized;
}


//---------------------------------------------------------
//
// Tracing and Debug registration
//
const TraceIdEntry xTraceTable[] = {

    Cry,

    //
    // TODO: Add Cryptograph sub-component trace ID's to be used with TrXXXX.
    // For example, CryInit, as used in:
    // TrERROR(CryInit, "Error description", parameters)
    //
};

/*
const DebugEntry xDebugTable[] = {

    {
        "CryDumpState(queue path name)",
        "Dump Cryptograph State to debugger",
        DumpState
    ),

    //
    // TODO: Add Cryptograph debug & control functions to be invoked using
    // mqctrl.exe utility.
    //
};
*/

void CrypRegisterComponent(void)
{
    TrRegisterComponent(xTraceTable, TABLE_SIZE(xTraceTable));
    //DfRegisterComponent(xDebugTable, TABLE_SIZE(xDebugTable));
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\cry\lib\cry.cpp ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:
    Cry.cpp

Abstract:
    crypt functions

Author:
    Ilan Herbst (ilanh) 28-Feb-00

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include <wincrypt.h>
#include "Cry.h"
#include "Cryp.h"

#include "cry.tmh"

HCRYPTPROV 
CryAcquireCsp(
	LPCTSTR CspProvider
	)
/*++

Routine Description:
	Aquire Crypto Service Provider (csp) 

Arguments:
    hCsp - (out) handle to csp

Returned Value:
	None.

--*/
{
	//
	// Acquire CSP
	//
	HCRYPTPROV hCsp;
	BOOL fSuccess = CryptAcquireContext(
						&hCsp, 
						NULL, 
						CspProvider, // MS_ENHANCED_PROV, //MS_DEF_PROV, 
						PROV_RSA_FULL, 
						0
						); 

	if(fSuccess)
		return(hCsp);

	//
	// The provider does not exist try to create one
	//
	if(GetLastError() == NTE_BAD_KEYSET)
	{
		//
		// Create new key container
		//
		fSuccess = CryptAcquireContext(
						&hCsp, 
						NULL, 
						CspProvider, // MS_ENHANCED_PROV, //MS_DEF_PROV, 
						PROV_RSA_FULL, 
						CRYPT_NEWKEYSET
						); 

		if(fSuccess)
			return(hCsp);
	}

    DWORD gle = GetLastError();

#ifdef _DEBUG

	if(wcscmp(CspProvider, MS_ENHANCED_PROV) == 0)
	{
		//
		// High Encryption Pack might not installed on the machine
		//
		TrERROR(Cry, "Unable to use Windows 2000 High Encryption Pack. Error=%x", gle);
	}

#endif // _DEBUG

	TrERROR(Cry, "Unable to open Csp '%ls' Error=%x", CspProvider, gle);
	throw bad_CryptoProvider(gle);
}


HCRYPTKEY 
CrypGenKey(
	HCRYPTPROV hCsp, 
	ALG_ID AlgId
	)
/*++

Routine Description:
	generate a new key (seesion key, public/private key pair, exchange key) 

Arguments:
    hCsp - handle to the crypto provider.
	AlgId - key type to create according to the key usage
			AT_SIGNATURE
			AT_KEYEXCHANGE
			CALG_RC2
			.....

Returned Value:
	handle to key that is created

--*/
{
    //
    // Create exportable key. 
    //
	HCRYPTKEY hKey;
    BOOL fSuccess = CryptGenKey(
						hCsp, 
						AlgId, 
						CRYPT_EXPORTABLE, 
						&hKey
						);
	if(fSuccess)
		return(hKey);

    DWORD gle = GetLastError();
	TrERROR(Cry, "CryptGenKey failed Error=%x", gle);
	throw bad_CryptoApi(gle);
}


HCRYPTKEY 
CryGenSessionKey(
	HCRYPTPROV hCsp
	)
/*++

Routine Description:
	generate session key from the crypto service provider (csp) 

Arguments:
    hCsp - handle to the crypto provider.

Returned Value:
    handle to the session key 

--*/
{
	return(CrypGenKey(hCsp, CALG_RC2));
}


HCRYPTKEY 
CryGetPublicKey(
	DWORD PrivateKeySpec,
	HCRYPTPROV hCsp
	)
/*++

Routine Description:
	get public key from the crypto service provider (csp) 

Arguments:
	PrivateKeySpec - Identifies the private key to use from the provider. 
					 It can be AT_KEYEXCHANGE or AT_SIGNATURE.
    hCsp - handle to the crypto provider.

Returned Value:
    handle to the public key 

--*/
{

	//
	// Get user public key from the csp 
	//
	HCRYPTKEY hKey;

	BOOL fSuccess = CryptGetUserKey(   
						hCsp,    
						PrivateKeySpec, // AT_SIGNATURE,    
						&hKey
						);

	if(fSuccess)
		return(hKey);

	//
	// No such key in the container try to create one 
	//
    DWORD gle = GetLastError();
	if((gle == NTE_BAD_KEY) || (gle == NTE_NO_KEY))
	{
		TrTRACE(Cry, "Creating new key, PrivateKeySpec = %x", PrivateKeySpec);
		return(CrypGenKey(hCsp, PrivateKeySpec /* AT_SIGNATURE */));
	}
		
	TrERROR(Cry, "CryptGetUserKey and GenKey failed Error=%x", gle);
	throw bad_CryptoApi(gle);
}


HCRYPTHASH 
CryCreateHash(
	HCRYPTPROV hCsp, 
	ALG_ID AlgId
	)
/*++

Routine Description:
	Create initialized hash object 

Arguments:
    hCsp - handle to the crypto provider.
	AlgId - (in) hash algorithm

Returned Value:
	the initialized hash object

--*/
{
	//
	// Create the hash object.
	//
	HCRYPTHASH hHash;
	BOOL fSuccess = CryptCreateHash(
						hCsp, 
						AlgId, 
						0, 
						0, 
						&hHash
						); 
	
	if(fSuccess)
		return(hHash);

    DWORD gle = GetLastError();
	TrERROR(Cry, "CryptCreateHash failed Error=%x", gle);
	throw bad_CryptoApi(gle);
}


void 
CryHashData(
	const BYTE *Buffer, 
	DWORD BufferLen, 
	HCRYPTHASH hHash
	)
/*++

Routine Description:
	Perform data digest on a buffer and put the result in hash object.

Arguments:
    Buffer - Input data to be hashed/digest.
	BufferLen - Length of the input data.
	hHash - Hash object to put the result of the digested data.

Returned Value:
	None.

--*/
{
	//
	// Compute the cryptographic hash of the buffer.
	//
	BOOL fSuccess = CryptHashData(
						hHash, 
						Buffer, 
						BufferLen, 
						0
						); 

	if(fSuccess)
		return;

    DWORD gle = GetLastError();
	TrERROR(Cry, "CryptHashData failed Error=%x", gle);
	throw bad_CryptoApi(gle);
}


BYTE* 
CryGetHashData(
	const HCRYPTHASH hHash,
	DWORD *HashValLen
	)
/*++

Routine Description:
	Get the Hash value from a Hash object.
	after getting this value we can not use this Hash object again

Arguments:
	hHash - Hash object to put the result of the digested data.
	HashValLen - Length of the hash value.

Returned Value:
	Hash value of the Hash object.

--*/
{
	//
	// Get HashVal length
	//
	BOOL fSuccess = CryptGetHashParam(
						hHash, 
						HP_HASHVAL, 
						NULL, 
						HashValLen, 
						0
						); 

	if(!fSuccess)
	{
        DWORD gle = GetLastError();
		TrERROR(Cry, "CryptGetHashParam failed Error=%x", gle);
		throw bad_CryptoApi(gle);
	}

	AP<BYTE> HashVal = new BYTE[*HashValLen];

	//
	// Get HashVal
	//
	fSuccess = CryptGetHashParam(
				   hHash, 
				   HP_HASHVAL, 
				   HashVal, 
				   HashValLen, 
				   0
				   ); 

	if(fSuccess)
		return(HashVal.detach());

    DWORD gle = GetLastError();
	TrERROR(Cry, "CryptGetHashParam failed Error=%x", gle);
	throw bad_CryptoApi(gle);
}


BYTE* 
CryCalcHash(
	HCRYPTPROV hCsp,
	const BYTE* Buffer, 
	DWORD BufferLen, 
	ALG_ID AlgId,
	DWORD *HashLen
	)
/*++

Routine Description:
	Calc Hash buffer 
	this function return the HashData Buffer that was allocated in GetHashData function
	the caller is responsible to free this buffer


Arguments:
    hCsp - handle to the crypto provider.
    Buffer - data buffer to be signed
	BufferLen - Length of data buffer
	AlgId - (in) hash algorithm
	HashLen - (out) Hash Value length

Returned Value:
    Hash Value

--*/
{
	//
	// Data digest
	//
	CHashHandle hHash(CryCreateHash(hCsp, AlgId));

	CryHashData(
		Buffer, 
		BufferLen, 
		hHash
		);

	//
	// Get Hash Value
	//
	AP<BYTE> HashVal = CryGetHashData(
						   hHash,
						   HashLen
						   ); 

	return(HashVal.detach());
}


DWORD 
CrypSignatureLength(
	const HCRYPTHASH hHash,
	DWORD PrivateKeySpec
	)
/*++

Routine Description:
	Determinate the signature length 

Arguments:
    hHash - Hash object to be singned
	PrivateKeySpec - (in) Identifies the private key to use from the provider. 
					 It can be AT_KEYEXCHANGE or AT_SIGNATURE.

Returned Value:
	Signature length

--*/
{
	//
	// Determine the size of the signature
	//
	DWORD SignLen= 0;
	BOOL fSuccess = CryptSignHash(
						hHash, 
						PrivateKeySpec, // AT_KEYEXCHANGE, // AT_SIGNATURE, 
						NULL, 
						0, 
						NULL, 
						&SignLen
						); 

	if(fSuccess)
		return(SignLen);

    DWORD gle = GetLastError();
	TrERROR(Cry, "CryptSignHash failed Error=%x", gle);
	throw bad_CryptoApi(gle);
}


void 
CrypSignHashData(
	BYTE* SignBuffer, 
	DWORD *SignBufferLen, 
	const HCRYPTHASH hHash,
	DWORD PrivateKeySpec
	)
/*++

Routine Description:
	Signed the hash data with the private key 

Arguments:
    SignBuffer - (out) the signature buffer of the digested message
	SignBufferLen - (out) length of the SignBuffer
	hHash - (in) Hash object containing the digest data to be signed.
	PrivateKeySpec - (in) Identifies the private key to use from the provider. 
					 It can be AT_KEYEXCHANGE or AT_SIGNATURE.

Returned Value:
	None.

--*/
{

	//
	// Sign the hash object.
	//
	BOOL fSuccess = CryptSignHash(
						hHash, 
						PrivateKeySpec, // AT_KEYEXCHANGE, // AT_SIGNATURE, 
						NULL, 
						0, 
						SignBuffer, 
						SignBufferLen
						); 
	if(fSuccess)
		return;

    DWORD gle = GetLastError();
	TrERROR(Cry, "CryptSignHash failed Error=%x", gle);
	throw bad_CryptoApi(gle);
}


BYTE* 
CryCreateSignature(
	const HCRYPTHASH hHash,
	DWORD PrivateKeySpec,
	DWORD* pSignLen
	)
/*++

Routine Description:
	Create the signature on a given hash object. 
	This function allocate and return the Signature Buffer
	the caller is responsible to free this buffer

Arguments:
	hHash - Hash object to put the result of the digested data.
	PrivateKeySpec - (in) Identifies the private key to use from the provider. 
					 It can be AT_KEYEXCHANGE or AT_SIGNATURE.
	pSignLen - (out) SignBuffer length

Returned Value:
    Signature buffer

--*/
{
	//
	// Sign digested data 
	//
	*pSignLen = CrypSignatureLength(hHash, PrivateKeySpec);
    AP<BYTE> SignBuffer = new BYTE[*pSignLen];
	CrypSignHashData(
		SignBuffer, 
		pSignLen, 
		hHash,
		PrivateKeySpec
		);

	return(SignBuffer.detach());
}


BYTE* 
CryCreateSignature(
	HCRYPTPROV hCsp,
	const BYTE* Buffer, 
	DWORD BufferLen, 
	ALG_ID AlgId,
	DWORD PrivateKeySpec,
	DWORD* pSignLen
	)
/*++

Routine Description:
	Create the signature on a given buffer - digest, sign. 
	This function allocate and return the Signature Buffer
	the caller is responsible to free this buffer

Arguments:
    hCsp - handle to the crypto provider.
    Buffer - data buffer to be signed
	BufferLen - Length of data buffer
	AlgId - (in) hash algorithm
	PrivateKeySpec - (in) Identifies the private key to use from the provider. 
					 It can be AT_KEYEXCHANGE or AT_SIGNATURE.
	pSignLen - (out) SignBuffer length

Returned Value:
    Signature buffer

--*/
{
	//
	// Data digest
	//
	CHashHandle hHash(CryCreateHash(hCsp, AlgId));

	CryHashData(
		Buffer, 
		BufferLen, 
		hHash
		);

	return CryCreateSignature(
				hHash,
				PrivateKeySpec,
				pSignLen
				);
}


bool 
CryValidateSignature(
	HCRYPTPROV hCsp,
	const BYTE* SignBuffer, 
	DWORD SignBufferLen, 
	const BYTE* Buffer,
	DWORD BufferLen,
	ALG_ID AlgId,
	HCRYPTKEY hKey
	)
/*++

Routine Description:
	Validate signature according to the signature buffer and the original
	data buffer that was signed.

Arguments:
    hCsp - handle to the crypto provider.
	SignBuffer - Signature Buffer.
	SignBufferLen - Length of SignBuffer.
	Buffer - Original Buffer that was signed.
	BufferLen - Length of Buffer.
	AlgId - (in) hash algorithm
	hKey - Key for unlocking the signature (signer public key)

Returned Value:
	True if Signature validation was succesful
	False if failure in validate the signature.

--*/
{
	//
	// Data digest on original buffer
	//
	CHashHandle hHash(CryCreateHash(hCsp, AlgId));

	CryHashData(
		Buffer, 
		BufferLen, 
		hHash
		);

	BOOL fSuccess = CryptVerifySignature(
						hHash, 
						SignBuffer, 
						SignBufferLen, 
						hKey,
						NULL, 
						0
						); 

	return(fSuccess != 0);
}



LPSTR 
CryEncrypt(
	const LPSTR& Msg, 
	DWORD& MsgLength, 
	HCRYPTKEY hKey
	)
/*++

Routine Description:
    Encrypt a meesage using a key.

Arguments:
	Msg - Message to be encrytped.
	MsgLength - (in/out) Message Length, will return the Encrypted message length.
	hKey - Key for encryption.

Returned Value:
    Encrypted data.

--*/
{
	DWORD EncryptLen = CrypEncryptLength(MsgLength, hKey);

    AP<char> EncryptMsg = new char[EncryptLen];
    strcpy(EncryptMsg, Msg);

    //
    // Encrypt data.
    //
    BOOL fSuccess = CryptEncrypt(
						hKey, 
						0, 
						TRUE, 
						0, 
						(BYTE*)(*&EncryptMsg), 
						&MsgLength, 
						EncryptLen
						);


	if(fSuccess)
		return(EncryptMsg.detach());

    DWORD gle = GetLastError();
	TrERROR(Cry, "CryptEncrypt failed Error=%x", gle);
	throw bad_CryptoApi(gle);
}


DWORD 
CrypEncryptLength(
	DWORD MsgLength, 
	HCRYPTKEY hKey
	)
/*++

Routine Description:
    Determinate encryption length

Arguments:
	MsgLength - Message Length.
	hKey - Key for encryption.

Returned Value:
    Encryption length.

--*/
{
    DWORD EncryptLength = MsgLength;

    //
    // Determinate EncryptLength - size of the encrypted data
    //
    BOOL fSuccess = CryptEncrypt(
						hKey, 
						0, 
						TRUE, 
						0, 
						0, 
						&EncryptLength, 
						0
						);
	if(fSuccess)
	    return(EncryptLength);

    DWORD gle = GetLastError();
	TrERROR(Cry, "CryptEncrypt failed Error=%x", gle);
	throw bad_CryptoApi(gle);
}


void 
CryDecrypt(
	LPSTR& EncrptMsg, 
	DWORD& MsgLength, 
	HCRYPTKEY hKey
	)
/*++

Routine Description:
    Decrypt a meesage using a key (default session key)

Arguments:
	EncrptMsg - Encrypted Buffer
	MsgLength - Encrypted Buffer length.
	hKey - key to use in decryption

Returned Value:
    None.

--*/
{
	//
	// Save pointer to string
	//
    BOOL fSuccess = CryptDecrypt(
						hKey, 
						0, 
						TRUE, 
						0, 
						(BYTE*)EncrptMsg, 
						&MsgLength
						);

	if(fSuccess)
		return;

    DWORD gle = GetLastError();
	TrERROR(Cry, "CryptDecrypt failed Error=%x", gle);
	throw bad_CryptoApi(gle);
}


#if 0
void 
CryExportKey(
	HCRYPTKEY hKey, 
	HCRYPTKEY hExKey, 
	DWORD BlobType, 
	DWORD& BlobLen, 
	BYTE* KeyBlob
	)
/*++

Routine Description:
    Export Key

Arguments:

Returned Value:
    None.

--*/
{
	//
	// Determine the size of the key blob and allocate memory.
	//
    BOOL fSuccess = CryptExportKey(
						hKey, 
						hExKey, 
						BlobType, 
						0, 
						NULL, 
						&BlobLen
						); 
	if(!fSuccess)
	{
        DWORD gle = GetLastError();
		TrERROR(Cry, "CryptExportKey failed Error=%x", gle);
		throw bad_CryptoApi(gle);
	}	

	KeyBlob = new BYTE[BlobLen];

	//
	// Export the key into a simple key blob.
	//
	fSuccess = CryptExportKey(
				   hKey, 
				   hExKey, 
				   BlobType, 
				   0, 
				   KeyBlob, 
				   &BlobLen
				   );
	if(fSuccess)
		return;

    DWORD gle = GetLastError();
	TrERROR(Cry, "CryptExportKey failed Error=%x", gle);
	throw bad_CryptoApi(gle);
}


void 
CryImportKey(
	HCRYPTPROV hCsp,
	HCRYPTKEY& hKey, 
	HCRYPTKEY hExKey, 
	DWORD BlobLen, 
	const BYTE* KeyBlob
	)
/*++

Routine Description:
    Import Key

Arguments:

Returned Value:
    None.

--*/
{
	//
	// Import the key
	//
	BOOL fSuccess = CryptImportKey(
						hCsp,
						KeyBlob,     
						BlobLen,   
						hExKey,
						CRYPT_EXPORTABLE,  
						&hKey
						);
	if(fSuccess)
		return;

    DWORD gle = GetLastError();
	TrERROR(Cry, "CryptImportKey failed Error=%x", gle);
	throw bad_CryptoApi(gle);
}


void 
CryImportKey(
	HCRYPTPROV hCsp,
	const BYTE* KeyBlob, 
	DWORD BlobLen
	)
/*++

Routine Description:
	import the key to the csp 

Arguments:
    hCsp - handle to the crypto provider.
    KeyBlob - Key blob.
	BlobLen - Length of the key blob.

Returned Value:
	None.

--*/
{
	//
	// Get import key to csp
	//
	BOOL fSuccess = CryptImportKey(
						hCsp,
						KeyBlob,
						BlobLen,
						0,
						0,
						&m_hRecieverKey
						);
	if(fSuccess)
		return;

    DWORD gle = GetLastError();
	TrERROR(Cry, "CryptImportKey failed Error=%x", gle);
	throw bad_CryptoApi(gle);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\cm\test\cmtest.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    CmTest.cpp

Abstract:
    Configuration Manager library test

Author:
    Uri Habusha (urih) 18-Jul-99

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include <TimeTypes.h>
#include "Cm.h"

#include "CmTest.tmh"

const TraceIdEntry CmTest = L"Configuration Manager Test";

const WCHAR REGSTR_PATH_CMTEST_ROOT[] = L"SOFTWARE\\Microsoft\\CMTEST";
const WCHAR REGSTR_PATH_CMTEST_PARAM[] = L"PARAMETERS";

void PrintError(char* msg, DWORD line)
{
    TrERROR(CmTest, "Failed in line %d ( %hs)", line, msg);

    RegEntry regKey1(REGSTR_PATH_CMTEST_ROOT, NULL, 0, RegEntry::MustExist, HKEY_LOCAL_MACHINE);
	CmDeleteKey(regKey1);

    RegEntry regKey2(REGSTR_PATH_CMTEST_ROOT, NULL, 0, RegEntry::MustExist, HKEY_CURRENT_USER);
	CmDeleteKey(regKey2);

    exit(-1);
}


void EnumrateValuesTest(void)
{
	LPCWSTR pRootEnumKey=L"ENUMTEST";

	//
	// Delete and create the root key
	//
	RegEntry reg(pRootEnumKey, NULL);
	CmDeleteKey(reg);
	CmCreateKey(reg,KEY_ALL_ACCESS);


	LPCWSTR pEnumArray[]={L"1234567",L"2666",L"3777",L"4666",L"5777",L"6777",L"7",L"8",L"9"};

	//
    // Set values for the test for the test
    //
    for(int i=0; i<sizeof(pEnumArray)/sizeof(LPWSTR);i++)
	{
		RegEntry reg(pRootEnumKey, pEnumArray[i]);
		CmSetValue(reg,pEnumArray[i]);
	}

	//
	// enumerate the values
	//
	CRegHandle hKey = CmOpenKey(reg, KEY_ALL_ACCESS);
	for(DWORD i=0;i<sizeof(pEnumArray)/sizeof(LPWSTR);i++)
	{
		AP<WCHAR> pEnumResult;
		bool fSuccess = CmEnumValue(hKey,i,&pEnumResult);		
		ASSERT(fSuccess);
		UNREFERENCED_PARAMETER(fSuccess);

		if(wcscmp(pEnumResult,pEnumResult)!= 0)
		{
			PrintError("Wrong enumeration value \n", __LINE__);
		}
	}

	//
	// cleanup- delete the key
	//
	CmDeleteKey(reg);
}


void TestQueryExpandValue(void)
{
	const WCHAR xValueName[] = L"TestExpandSz";
	const WCHAR xValue[] = L"%lib%;%path%";
    //
    // open registery keys for the test
    //
    RegEntry reg(REGSTR_PATH_CMTEST_ROOT, L"", 0, RegEntry::MustExist, HKEY_CURRENT_USER);
	HKEY hKey = CmCreateKey(reg, KEY_ALL_ACCESS);

    int rc = RegSetValueEx(
                hKey,
                xValueName, 
                0,
                REG_EXPAND_SZ, 
                reinterpret_cast<const BYTE*>(xValue),
                STRLEN(xValue)*sizeof(WCHAR)
                );

    if (rc != ERROR_SUCCESS)
    {
	    TrERROR(CmTest, "Failed to create expand string value. Error=%d", rc);
		return;
    }

    RegEntry regTest(REGSTR_PATH_CMTEST_ROOT, xValueName, 0, RegEntry::MustExist, HKEY_CURRENT_USER);
    
	P<WCHAR> pRetValue;
	CmQueryValue(regTest, &pRetValue);

	WCHAR checkValue[512];
	ExpandEnvironmentStrings(xValue, checkValue, TABLE_SIZE(checkValue));

	if (wcscmp(pRetValue, checkValue) != 0)
	{
       PrintError( "Failed to retrieve REG_EXPAND_VALUE", __LINE__);
	}

	//
	// Cleanup
	//
	CmCloseKey(hKey);
 	CmDeleteKey(reg);
}


void TestAbsouloteKey(void)
{
    //
    // open registery keys for the test
    //
    RegEntry reg(REGSTR_PATH_CMTEST_ROOT, L"", 0, RegEntry::MustExist, HKEY_CURRENT_USER);
	HKEY hKey = CmOpenKey(reg, KEY_ALL_ACCESS);

    //
    // Create registery keys for the test
    //
    RegEntry regTest(REGSTR_PATH_CMTEST_PARAM, L"try", 1345, RegEntry::Optional, hKey);

	//
	// the value doesn't exist check that the default value is returened
	//
	DWORD RetValue;
    CmQueryValue(regTest, &RetValue);
    if (RetValue != 1345)
    {
       PrintError( "invalid CmQueryValue", __LINE__);
    }

    // 
    // Set a new value to registery and check that we 
    // get it back. 
    //
    CmSetValue(regTest, 12345);
    CmQueryValue(regTest, &RetValue);
    if (RetValue != 12345)
    {
       PrintError( "invalid CmQueryValue", __LINE__);
    }

	CmDeleteKey(regTest);

    RegEntry regTestKey(REGSTR_PATH_CMTEST_ROOT, L"", 0, RegEntry::MustExist, HKEY_CURRENT_USER);
	CmDeleteKey(regTestKey);

	CmCloseKey(hKey);
}


BOOL CmTestCreateRegisteryKey(HKEY RootKey)
{
	CRegHandle hKey = NULL;
	DWORD Disposition;
	int rc = RegCreateKeyEx(
				RootKey,
				REGSTR_PATH_CMTEST_ROOT,
				0,
				NULL,
				REG_OPTION_NON_VOLATILE,
				KEY_NOTIFY,
				NULL,
				&hKey,
				&Disposition
				);

    if (rc != ERROR_SUCCESS)
    {
        return FALSE;
    }
	
	return TRUE;
}


void CmTestCreateRegisterSubKeys(HKEY hRoot = NULL)
{
	RegEntry reg(REGSTR_PATH_CMTEST_PARAM, L"", 0, RegEntry::MustExist, hRoot);

	CmCreateKey(reg, KEY_ALL_ACCESS);
}


void CmTestInitialization(void)
{
	if (!CmTestCreateRegisteryKey(HKEY_LOCAL_MACHINE))
    {
	    printf("Cm Test Failed in line %d (Failed to create subkey) \n", __LINE__);
		exit(-1);
    }

	if (!CmTestCreateRegisteryKey(HKEY_CURRENT_USER))
    {
	    printf("Cm Test Failed in line %d (Failed to create subkey) \n", __LINE__);
		exit(-1);
    }

	//
	// Initialize configuration manager
	//
	CmInitialize(HKEY_LOCAL_MACHINE, REGSTR_PATH_CMTEST_ROOT);

	//
	// Initialize Tracing
	//
	TrInitialize();

	CmTestCreateRegisterSubKeys();

	CRegHandle hKey;
	int rc = RegOpenKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_CMTEST_ROOT, 0, KEY_ALL_ACCESS,&hKey);
	if (rc != ERROR_SUCCESS)
	{
		PrintError("Failed to open register key", __LINE__);
	}
	CmTestCreateRegisterSubKeys(hKey);
}


extern "C" int __cdecl _tmain(int /*argc*/, LPCTSTR /*argv*/[])
{
    WPP_INIT_TRACING(L"Microsoft\\MSMQ");

	CmTestInitialization();

	EnumrateValuesTest();


    DWORD RetValue;
    {
        //
        // Create RegEntry on the stack. Test the constructor and destructor
        // functions
        //
        RegEntry RegTest(NULL, L"try", 1345, RegEntry::Optional);

		//
		// the value doesn't exist check that the default value is returened
		//
        CmQueryValue(RegTest, &RetValue);
        if (RetValue != 1345)
        {
           PrintError( "invalid CmQueryValue", __LINE__);
        }

        // 
        // Set a new value to registery and check that we 
        // get it back. 
        //
        CmSetValue(RegTest, 12345);
        CmQueryValue(RegTest, &RetValue);
        if (RetValue != 12345)
        {
           PrintError( "invalid CmQueryValue", __LINE__);
        }

        //
        // Set a new value
        //
        RegEntry RegTest1(NULL, L"try");
        CmSetValue(RegTest1, 54321);

        CmQueryValue(RegTest, &RetValue);
        if (RetValue != 54321)
        {
            PrintError("invalid CmQueryValue", __LINE__);
        }

    }
    //
    // Check that the value is realy store in registery. We use a new 
    // Regentry to featch the information from Registery
    //
    RegEntry RegTest(NULL, L"try");
    CmQueryValue(RegTest, &RetValue);
    if (RetValue != 54321)
    {
        PrintError( "invalid CmQueryValue", __LINE__);
    }

    //
    // Remove the entry from registery
    //
    CmDeleteValue(RegTest);

    //
    // Check returning of the default value when the registery isn't exist
    //
    {
        RegEntry* pRegTest = new RegEntry(REGSTR_PATH_CMTEST_PARAM, L"defaultTry", 98765 , RegEntry::Optional);
        CmQueryValue(*pRegTest, &RetValue);
        if (RetValue != 98765)
        {
            PrintError( "invalid CmQueryValue", __LINE__);
        }
        delete pRegTest;
    }

    //
    // Check that exception is raised when the value isn't exist in registery
    // but it mark as must exist in RegEntry
    //
    RetValue = 0;
    RegEntry* pRegTest = new RegEntry(REGSTR_PATH_CMTEST_PARAM, L"defaultTry", 0, RegEntry::MustExist);
    try
    {
        CmQueryValue(*pRegTest, &RetValue);
        PrintError( "We don't expected to reach here", __LINE__);
    }
    catch(const exception&)
    {
        NULL;
    }

    if (RetValue != 0)
    {
        PrintError( "invalid CmQueryValue", __LINE__);
    }

    //
    //set value to reg vale
    //
    CmSetValue(*pRegTest, 987);
    CmQueryValue(*pRegTest, &RetValue);
    if (RetValue != 987)
    {
        PrintError("invalid CmQueryValue", __LINE__);
    }

    CmDeleteValue(*pRegTest);

    //
    // Check that CmDelete mark the RegEntry as Non cached. As a result
    // Cm try to featch the value from registery and failed. Since the 
    // registery mark as must exist, an exception is raised
    //
    try
    {
        CmQueryValue(*pRegTest, &RetValue);
        PrintError( "We don't expected to reach here", __LINE__);
    }
    catch(const exception&)
    {
        NULL;
    }

    delete pRegTest;

    //
    // Check Set and Get of guid
    //
    GUID Guid;
    RPC_STATUS rc;
    rc = UuidCreate(&Guid);
    if (rc != RPC_S_OK)
    {
        PrintError( "Failed to create a GUID.", __LINE__);
    }

    //
    // Try to read non existing GUID value. Must return a null GUID
    //
    RegEntry RegTest1(REGSTR_PATH_CMTEST_PARAM, L"tryGuid");
    GUID RetGuid;
    CmQueryValue(RegTest1, &RetGuid);
    if (memcmp(&RetGuid, &GUID_NULL, sizeof(GUID)))
    {
        PrintError("invalid Guid value", __LINE__);
    }

    //
    // Test seting of GUID value
    //
    CmSetValue(RegTest1, &Guid);

    // 
    // Check that the GUID value is stored in registery and that the
    // new read GUID value is equivalent to the set value
    //
    RegEntry* pRegTest2 = new RegEntry(REGSTR_PATH_CMTEST_PARAM, L"tryGuid");
    CmQueryValue(*pRegTest2, &RetGuid);
    if (memcmp(&RetGuid, &Guid, sizeof(GUID)))
    {
        PrintError("invalid Guid value", __LINE__);
    }
    CmQueryValue(*pRegTest2, &RetGuid);
    if (memcmp(&RetGuid, &Guid, sizeof(GUID)))
    {
        PrintError("invalid Guid value", __LINE__);
    }
    delete pRegTest2;
    CmDeleteValue(RegTest1);


    RegEntry RegTest3(REGSTR_PATH_CMTEST_PARAM, L"tryGuid", 0, RegEntry::MustExist);
    try
    {
        CmQueryValue(RegTest3, &RetGuid);
        PrintError( "We don't expecte to reach here", __LINE__);
    }
    catch(const exception&)
    {
        NULL;
    }

    //
    // Check Set/Get for String
    //
    WCHAR Str[] = L"abcd edfgr";
    RegEntry RegTest4(REGSTR_PATH_CMTEST_PARAM, L"tryStr");
    WCHAR* pRetStr;
    //
    // Check that reading non existing string return size NULL
    //
    CmQueryValue(RegTest4, &pRetStr);
    if (pRetStr != NULL)
    {
        PrintError("invalid Return Size", __LINE__);
    }

    //
    // Test setting of string
    //
    CmSetValue(RegTest4, Str);

    //
    // Geting of existing string. Check that the return string
    // Is equivalent to the set string 
    //
    RegEntry* RegTest5 = new RegEntry(REGSTR_PATH_CMTEST_PARAM, L"tryStr");
    CmQueryValue(*RegTest5, &pRetStr);
    if (wcscmp(pRetStr, Str))
    {
        PrintError("invalid String value", __LINE__);
    }

	delete [] pRetStr;
    delete RegTest5;

    // Delete the string from registery
    //
    CmDeleteValue(RegTest4);


    //
    // Check that reading non existing value that set as must exist cause
    // an exception
    //
    RegEntry RegTest6(REGSTR_PATH_CMTEST_PARAM, L"tryGuid", 0, RegEntry::MustExist);
    try
    {
        CmQueryValue(RegTest6, &RetGuid);
        PrintError("We Don't expect to reach here", __LINE__);
    }
    catch(const exception&)
    {
        NULL;
    }

    CmDeleteValue(RegTest6);
    
    //
    // Check Set/Get for Bytes
    //
    UCHAR byteBuffer[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    DWORD BufferSize = TABLE_SIZE(byteBuffer);
    DWORD Size;
    
    RegEntry RegTest7(REGSTR_PATH_CMTEST_PARAM, L"tryByte");
    BYTE* pRetByte;
    //
    // Check that reading of non existing Byte return size 0
    //
    CmQueryValue(RegTest7, &pRetByte, &Size);
    if ((Size != 0)	|| (pRetByte != NULL))
    {
        PrintError("invalid Return Size", __LINE__);
    }

    //
    // Test setting of Byte
    //
    CmSetValue(RegTest7, byteBuffer, BufferSize);

    //
    // Geting of existing string. Check that the return string
    // Is equivalent to the set string 
    //
    RegEntry* RegTest9 = new RegEntry(REGSTR_PATH_CMTEST_PARAM, L"tryByte");
    CmQueryValue(*RegTest9, &pRetByte, &Size);
    if ((Size != BufferSize) || 
        memcmp(pRetByte, byteBuffer, BufferSize) )
    {
        PrintError("invalid String value", __LINE__);
    }

	delete [] pRetByte;
    delete RegTest9;

    //
    // Delete the string from registery
    //
    CmDeleteValue(RegTest7);

    //
    // Check that reading of non existing value that set as must exist cause
    // an exception
    //
    RegEntry RegTest10(REGSTR_PATH_CMTEST_PARAM, L"tryGuid", 0, RegEntry::MustExist);
    try
    {
        CmQueryValue(RegTest10, &RetGuid);
        PrintError( "We don't expect to reach here", __LINE__);
    }
    catch(const exception&)
    {
        NULL;
    }

    //
    //  try to get the machine ID. Delete it and try to read it. We 
    // expect to get an exception
    //
    RegEntry RegTest11(REGSTR_PATH_CMTEST_PARAM, L"MachineID", 0, RegEntry::MustExist);
    CmDeleteValue(RegTest11);

    try
    {
		GUID MachineId;
		CmQueryValue(RegTest11, &MachineId);

        PrintError("We don't Expect to reach here", __LINE__);
    }
    catch(const exception&)
    {
        NULL;
    }

    rc = UuidCreate(&Guid);
    if (rc != RPC_S_OK)
    {
        PrintError( "Failed to create a GUID.", __LINE__);
    }

    //
    // Test setting of machine ID
    //
    CmSetValue(RegTest11, &Guid);
    GUID tempGuid;
	GUID prevGuid;
	CmQueryValue(RegTest11, &tempGuid);
	prevGuid = tempGuid;

    rc = UuidCreate(&Guid);
    if (rc != RPC_S_OK)
    {
        PrintError( "Failed to create a GUID.", __LINE__);
    }

    //
    // set a new machine ID. e want to check that we get the cahched value
    //
    RegEntry RegTest12(REGSTR_PATH_CMTEST_PARAM, L"MachineID", 0, RegEntry::MustExist);
    CmSetValue(RegTest12, &Guid);

    GUID newGuid;
	CmQueryValue(RegTest11, &tempGuid);
	newGuid = tempGuid;

    if (memcmp(&prevGuid, &newGuid, sizeof(GUID)) == 0)
    {
        PrintError("Illegal Machine ID", __LINE__);
    }

    //
    // set value of un-existing key
    //
    RegEntry RegTest13(L"temp Subkey", L"try", 0, RegEntry::Optional); 
    CmSetValue(RegTest13, 1);
    CmDeleteKey(RegTest13);

    //
    // delete unexisting value
    //
    RegEntry RegTest14(REGSTR_PATH_CMTEST_PARAM, L"try", 0, RegEntry::MustExist);
    CmDeleteValue(RegTest14);

    //
    // test time  duration setting/querying 
    //
    RegEntry RegTest15(REGSTR_PATH_CMTEST_PARAM, L"timeout", 123456);
    CmSetValue(RegTest15, CTimeDuration(123456i64));

    CTimeDuration queryValue;
    CmQueryValue(RegTest15, &queryValue);
    if (!(queryValue == 120000))
    {
        PrintError("Failed to setting/querying timeout value", __LINE__);
    }

    RegEntry regTestSubKey(REGSTR_PATH_CMTEST_PARAM, L"", 0, RegEntry::MustExist);
	CmDeleteKey(regTestSubKey);

    RegEntry regTestKey(REGSTR_PATH_CMTEST_ROOT, L"", 0, RegEntry::MustExist, HKEY_LOCAL_MACHINE);
	CmDeleteKey(regTestKey);


	TestAbsouloteKey();

	TestQueryExpandValue();

    TrTRACE(CmTest, "pass successfully");

    WPP_CLEANUP();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\cm\lib\cmdebug.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    CmDebug.cpp

Abstract:
    Configuration Manager debugging

Author:
    Uri Habusha (urih) 28-Apr-99

Environment:
    Platform-independent, _DEBUG only

--*/

#include <libpch.h>
#include "Cmp.h"

#include "cmdebug.tmh"

#ifdef _DEBUG


//---------------------------------------------------------
//
// Validate Configuration Manager state
//
void CmpAssertValid(void)
{
    //
    // CmInitalize() has *not* been called. You should initialize the
    // Configuration Manager library before using any of its funcionality.
    //
    ASSERT(CmpIsInitialized());
}


//---------------------------------------------------------
//
// Initialization Control
//
static LONG s_fInitialized = FALSE;

void CmpSetInitialized(void)
{
    LONG fCmAlreadyInitialized = InterlockedExchange(&s_fInitialized, TRUE);

    //
    // The Configuration Manager library has *already* been initialized. You should
    // not initialize it more than once. This assertion would be violated
    // if two or more threads initalize it concurently.
    //
    ASSERT(!fCmAlreadyInitialized);
}


BOOL CmpIsInitialized(void)
{
    return s_fInitialized;
}


//---------------------------------------------------------
//
// Tracing and Debug registration
//
const TraceIdEntry xTraceTable[] = {

    Cm,

    //
    // TODO: Add Configuration Manager sub-component trace ID's to be used with TrXXXX.
    // For example, CmInit, as used in:
    // TrERROR(CmInit, "Error description", parameters)
    //
};

/*
const DebugEntry xDebugTable[] = {

    {
        "CmDumpState(queue path name)",
        "Dump Configuration Manager State to debugger",
        DumpState
    ),

    //
    // TODO: Add Configuration Manager debug & control functions to be invoked using
    // mqctrl.exe utility.
    //
};
*/

void CmpRegisterComponent(void)
{
    TrRegisterComponent(xTraceTable, TABLE_SIZE(xTraceTable));
    //DfRegisterComponent(xDebugTable, TABLE_SIZE(xDebugTable));
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\cry\lib\cryinit.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    CryInit.cpp

Abstract:
    Cryptograph initialization

Author:
    Ilan Herbst (ilanh) 06-Mar-00

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include "Cry.h"
#include "Cryp.h"

#include "cryinit.tmh"

VOID
CryInitialize(
    VOID
    )
/*++

Routine Description:
    Initializes Cryptograph library

Arguments:
    None.

Returned Value:
    None.

--*/
{
    //
    // Validate that the Cryptograph library was not initalized yet.
    // You should call its initalization only once.
    //
    ASSERT(!CrypIsInitialized());
    CrypRegisterComponent();

    //
    // TODO: Write Cryptograph initalization code here
    //

    CrypSetInitialized();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\cry\lib\cryp.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Cryp.h

Abstract:
    Cryptograph private functions.

Author:
    Ilan Herbst (ilanh) 06-Mar-00

--*/

#pragma once

const TraceIdEntry Cry = L"Cryptograph";

#ifdef _DEBUG

void CrypAssertValid(void);
void CrypSetInitialized(void);
BOOL CrypIsInitialized(void);
void CrypRegisterComponent(void);

#else // _DEBUG

#define CrypAssertValid() ((void)0)
#define CrypSetInitialized() ((void)0)
#define CrypIsInitialized() TRUE
#define CrypRegisterComponent() ((void)0)

#endif // _DEBUG


HCRYPTKEY 
CrypGenKey(
	HCRYPTPROV hCsp, 
	ALG_ID AlgId
	);


DWORD 
CrypSignatureLength(
	const HCRYPTHASH hHash,
	DWORD PrivateKeySpec
	);


void 
CrypSignHashData(
	BYTE* SignBuffer, 
	DWORD *SignBufferLen, 
	const HCRYPTHASH hHash,
	DWORD PrivateKeySpec
	);


DWORD 
CrypEncryptLength(
	DWORD MsgLength, 
	HCRYPTKEY hKey
	);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\cry\test\crytest.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    CryTest.cpp

Abstract:
    Cryptograph library test

Author:
    Ilan Herbst (ilanh) 06-Mar-00

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include <xstr.h>
#include "Cry.h"

#include "CryTest.tmh"

const TraceIdEntry CryTest = L"Crypto Test";

//
// Usage
//
const char xOptionSymbol1 = '-';
const char xOptionSymbol2 = '/';

const char xUsageText[] =
	"usage: \n\n"
	"    /h     dumps this usage text.\n"
	"    /s     AT_SIGNATURE Private Key \n"
	"    /x     AT_KEYEXCHANGE Private Key \n";

inline
void 
DumpUsageText( 
	void 
	)
{
	printf( "%s\n" , xUsageText );
}


DWORD g_PrivateKeySpec = AT_SIGNATURE;
BOOL g_fErrorneous = false;


void SetActivation( int argc, LPCTSTR argv[] )
/*++
Routine Description:
    translates command line arguments.

Arguments:
    main's command line arguments.

Returned Value:

proper command line syntax:
	"usage: \n\n"
	"    /h     dumps this usage text.\n"
	"    /s     AT_SIGNATURE Private Key \n"
	"    /x     AT_KEYEXCHANGE Private Key \n"
--*/
{
	
	if(argc == 1)
	{
		printf("Test AT_SIGNATURE Private Key\n");
		return;
	}

	for(int index = 1; index < argc; index++)
	{
		if((argv[index][0] != xOptionSymbol1) && (argv[index][0] != xOptionSymbol2))	
		{
			TrERROR(CryTest, "invalid option switch %lc, option switch should be - or /", argv[index][0]);
			g_fErrorneous = true;
			continue;
		}

		//
		// consider argument as option and switch upon its second (sometimes also third) character.
		//
		switch(argv[index][1])
		{
			case 's':
			case 'S':
				g_PrivateKeySpec = AT_SIGNATURE;
				printf("Test AT_SIGNATURE Private Key\n");
				break;

			case 'x':
			case 'X':	
				g_PrivateKeySpec = AT_KEYEXCHANGE;
				printf("Test AT_KEYEXCHANGE Private Key\n");
				break;

			case 'H':	
			case 'h':
			case '?':
				g_fErrorneous = true;
				break;

			default:
				TrERROR(CryTest, "invalid command line argument %ls", argv[index]);
				g_fErrorneous = true;
				return;
		};
	}

	return;
}


bool
CompareBuffers(
	const BYTE* pBuf1, 
	DWORD Buf1Size, 
	const BYTE* pBuf2, 
	DWORD Buf2Size
	)
/*++

Routine Description:
    Compare 2 buffers values

Arguments:
    pBuf1 - pointer to first buffer
	Buf1Size - first buffer size
	pBuf2 - pointer to second buffer
	Buf2Size - second buffer size

Returned Value:
    true if the buffers match, false if not

--*/
{
	//
	// Buffers must have same size 
	//
	if(Buf1Size != Buf2Size)
		return(false);

	return (memcmp(pBuf1, pBuf2, Buf2Size) == 0);
}


void TestCrypto(DWORD PrivateKeySpec, HCRYPTPROV hCsp)
/*++

Routine Description:
	Test various operations with CCrypto class

Arguments:
	PrivateKeySpec - Private Key type AT_SIGNATURE or AT_KEYEXCHANGE
	Crypto - crypto class for cryptograph operation

Returned Value:
	None.

--*/
{
	//
    // Testing Encrypt, Decrypt using Session key
    //
	AP<char> Buffer = newstr("Hello World");
	DWORD BufferLen = strlen(Buffer);

	printf("Original data: %.*s\n", BufferLen, reinterpret_cast<char*>(Buffer.get()));

	//
	// Generate Sessin key
	//
	CCryptKeyHandle hSessionKey(CryGenSessionKey(hCsp));

#if 0
	//
	// Test Encrypt with session key
	//
	AP<char> EncryptMsg = CryEncrypt(Buffer, BufferLen, hSessionKey);

	//
	// Test Decrypt with session key
	// default key is session key (third parameter)
	//
	CryDecrypt(*&EncryptMsg, BufferLen, hSessionKey);

	printf("data after Encrypt, Decrypt: %.*s\n", BufferLen, reinterpret_cast<char*>(EncryptMsg.get()));
#endif

#if 0
	//
	// Encrypt using public key
	//
	BufferLen = strlen(Buffer);
	AP<char>PublicEncryptMsg = CryEncrypt(Buffer, BufferLen, hSignKey);

	//
	// Decrypt using Private Key
	//
	CryDecrypt(*&PublicEncryptMsg, BufferLen, hSignKey);


	printf("data after Encrypt, Decrypt: %s, data length: %d\n", PublicEncryptMsg, BufferLen);
#endif
	

#if 0
	//
	// Test Export/Import keys
	//
	DWORD BlobLen;
	BYTE* KeyBlob;
	CryExportKey(
		hCsp,
		hSessionKey, 
		hSignKey, 
		SIMPLEBLOB, 
		BlobLen, 
		KeyBlob
		);

    HCRYPTKEY hImportSessionKey;

	CryImportKey(
		hCsp,
		hImportSessionKey, 
		hSignKey, 
		BlobLen, 
		KeyBlob
		);

	//
	// Test Encrypt/Decrypt using session key for encryption and imported session key for decryption
	//
	printf("Original data: %s, data length: %d\n", Buffer, BufferLen);

	//
	// encrypt with default key - session key (third parameter)
	//
	AP<char> EncryptMsg2 = CryEncrypt(Buffer, BufferLen, hSessionKey);

	//
	// decrypt with imported session key
	//
	CryDecrypt(*&EncryptMsg2, BufferLen, hImportSessionKey);

	printf("data after Encrypt, Decrypt (import sesskey): %s, data length: %d\n", EncryptMsg2, BufferLen);

#endif

	//
	// Test signature operation
	//

	//
	// Sign data - CryCreateSignature on input buffer
	//
	DWORD SignLen;
	AP<BYTE> SignBuffer = CryCreateSignature(
							  hCsp,
							  reinterpret_cast<const BYTE*>(Buffer.get()), 
							  BufferLen,
							  CALG_SHA1,
							  PrivateKeySpec,
							  &SignLen
							  );

	printf("sign data: \n%.*s\n", SignLen, reinterpret_cast<char*>(SignBuffer.get()));

	//
	// Validate signature
	//
	bool fValidSign = CryValidateSignature(
						  hCsp,
						  SignBuffer, 
						  SignLen, 
						  reinterpret_cast<const BYTE*>(Buffer.get()), 
						  BufferLen,
						  CALG_SHA1,
						  CryGetPublicKey(PrivateKeySpec, hCsp)
						  );

	printf("ValidSign = %d\n", fValidSign);
	ASSERT(fValidSign);

	//
	// Sign data - CryCreateSignature with input hash
	//

	//
	// Create Signature, create hash, calc hash, create signature on the given hash
	//
	CHashHandle hHash1 = CryCreateHash(
							hCsp, 
							CALG_SHA1
							);

	CryHashData(
		reinterpret_cast<const BYTE*>(Buffer.get()), 
		BufferLen,
		hHash1
		);

	AP<BYTE> SignBuff = CryCreateSignature(
								hHash1,
								PrivateKeySpec,
								&SignLen
								);

	printf("sign data: \n%.*s", SignLen, reinterpret_cast<char*>(SignBuff.get()));

	//
	// Validate signature
	//
	fValidSign = CryValidateSignature(
					  hCsp,
					  SignBuff, 
					  SignLen, 
					  reinterpret_cast<const BYTE*>(Buffer.get()), 
					  BufferLen,
					  CALG_SHA1,
					  CryGetPublicKey(PrivateKeySpec, hCsp)
					  );

	printf("ValidSign = %d\n", fValidSign);
	ASSERT(fValidSign);

	//
	// Test Hash operations
	//
	const LPCSTR xData = 
	"        <ReferenceObject1 ID=\"Ref1Id\">\r\n"
	"            <Ref1Data>\r\n"
	"                This Is Reference Number 1\r\n" 
	"                msmq3 Reference test\r\n" 
	"            </Ref1Data>\r\n"
	"        </ReferenceObject1>\r\n";

	const LPCSTR xData1 = 
	"        <ReferenceObject1 ID=\"Ref1Id\">\r\n"
	"            <Ref1Data>\r\n";

	const LPCSTR xData2 = 
	"                This Is Reference Number 1\r\n" 
	"                msmq3 Reference test\r\n" 
	"            </Ref1Data>\r\n"
	"        </ReferenceObject1>\r\n";

	DWORD HashLen;
	AP<BYTE> HashBuffer = CryCalcHash(
							  hCsp,
							  reinterpret_cast<const BYTE*>(xData), 
							  strlen(xData),
							  CALG_SHA1,
							  &HashLen
							  );

	printf("HashBuffer (def prov) \n%.*s\n", HashLen, reinterpret_cast<char*>(HashBuffer.get()));

	CHashHandle hHash(CryCreateHash(hCsp, CALG_SHA1));

	CryHashData(
		reinterpret_cast<const BYTE*>(xData1), 
		strlen(xData1),
		hHash
		);

	CryHashData(
		reinterpret_cast<const BYTE*>(xData2), 
		strlen(xData2),
		hHash
		);

	DWORD HashLen1;
	AP<BYTE> HashVal = CryGetHashData(
						   hHash,
						   &HashLen1
						   ); 

	printf("HashBuffer (parts)\n%.*s\n", HashLen1, reinterpret_cast<char*>(HashVal.get()));

	//
	// Compare the 2 hash values - should be exactly the same
	//
	if(!CompareBuffers(HashVal, HashLen1, HashBuffer, HashLen))
	{
		TrERROR(CryTest, "HashBuffers on full data and on parts of the data must be the same");
		throw bad_CryptoApi(ERROR);
	}


	CCspHandle hCsp1(CryAcquireCsp(MS_DEF_PROV));
	try
	{
		CCspHandle hCsp2(CryAcquireCsp(MS_ENHANCED_PROV));

		DWORD HashLen1;
		AP<BYTE> HashBuffer1 = CryCalcHash(
								   hCsp2,
								   reinterpret_cast<const BYTE*>(xData), 
								   strlen(xData),
								   CALG_SHA1,
								   &HashLen1
								   );

		printf("HashBuffer1 (enhanced prov) \n%.*s\n", HashLen1, reinterpret_cast<char*>(HashBuffer1.get()));

		//
		// Sign data using enhanced provider
		//
		AP<BYTE>SignBuffer1 = CryCreateSignature(
								  hCsp2,
								  reinterpret_cast<const BYTE*>(xData), 
								  strlen(xData),
								  CALG_SHA1,
								  PrivateKeySpec,
								  &SignLen
								  );

		printf("sign data: \n%.*s\n", SignLen, reinterpret_cast<char*>(SignBuffer1.get()));

		//
		// Validate signature using enhanched provider
		//
		fValidSign = CryValidateSignature(
						 hCsp2,
						 SignBuffer1, 
						 SignLen, 
						 reinterpret_cast<const BYTE*>(xData), 
						 strlen(xData),
						 CALG_SHA1,
						 CryGetPublicKey(PrivateKeySpec, hCsp2)
						 );

		printf("ValidSign enhanced (create by enhanced) = %d\n", fValidSign);

		//
		// Validate signature using default provider
		//
		fValidSign = CryValidateSignature(
						 hCsp1,
						 SignBuffer1, 
						 SignLen, 
						 reinterpret_cast<const BYTE*>(xData), 
						 strlen(xData),
						 CALG_SHA1,
						 CryGetPublicKey(PrivateKeySpec, hCsp2)
						 );

		printf("ValidSign default (create by enhanced) = %d\n", fValidSign);

		//
		// Sign data using default provider
		//
		AP<BYTE>SignBuffer2 = CryCreateSignature(
								  hCsp1,
								  reinterpret_cast<const BYTE*>(xData), 
								  strlen(xData),
								  CALG_SHA1,
								  PrivateKeySpec,
								  &SignLen
								  );

		printf("sign data: \n%.*s\n", SignLen, reinterpret_cast<char*>(SignBuffer2.get()));

		//
		// Validate signature using enhanced provider
		//
		fValidSign = CryValidateSignature(
						 hCsp2,
						 SignBuffer2, 
						 SignLen, 
						 reinterpret_cast<const BYTE*>(xData), 
						 strlen(xData),
						 CALG_SHA1,
						 CryGetPublicKey(PrivateKeySpec, hCsp1)
						 );

		printf("ValidSign enhanced (create by default) = %d\n", fValidSign);

		//
		// Validate signature using default provider
		//
		fValidSign = CryValidateSignature(
						 hCsp1,
						 SignBuffer2, 
						 SignLen, 
						 reinterpret_cast<const BYTE*>(xData), 
						 strlen(xData),
						 CALG_SHA1,
						 CryGetPublicKey(PrivateKeySpec, hCsp1)
						 );

		printf("ValidSign default (create by default) = %d\n", fValidSign);
	}
	catch (const bad_CryptoProvider&)
	{
		printf("skip the enhanced provider tests\n");
		return;
	}

}


extern "C" int __cdecl _tmain(int argc, LPCTSTR argv[])
/*++

Routine Description:
    Test Cryptograph library

Arguments:
    Parameters.

Returned Value:
    None.

--*/
{
    WPP_INIT_TRACING(L"Microsoft\\MSMQ");

	TrInitialize();
	TrRegisterComponent(&CryTest, 1);

	SetActivation(argc, argv);

	if(g_fErrorneous)
	{
		DumpUsageText();
		return 3;
	}

    CryInitialize();

	try
	{
		CCspHandle hCsp(CryAcquireCsp(MS_DEF_PROV));
//		CCspHandle hCsp(CryAcquireCsp(MS_ENHANCED_PROV));


		CCryptKeyHandle hPbKey = CryGetPublicKey(g_PrivateKeySpec, hCsp);

		TestCrypto(g_PrivateKeySpec, hCsp);
	}
	catch (const bad_CryptoProvider& badCspEx)
	{
		TrERROR(CryTest, "bad Crypto Service Provider Excption ErrorCode = %x", badCspEx.error());
		return(-1);
	}
	catch (const bad_CryptoApi& badCryEx)
	{
		TrERROR(CryTest, "bad Crypto Class Api Excption ErrorCode = %x", badCryEx.error());
		return(-1);
	}

    WPP_CLEANUP();
	return 0;
}



/*
static void Usage()
{
	printf("Usage: CryTest [*switches*]\n");
	printf("\t*-s*\t*Switch description*\n");
	printf("\n");
	printf("Example, CryTest -switch\n");
	printf("\t*example description*\n");
	exit(-1);
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\dld\lib\dload.cpp ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       D L O A D . C
//
//  Contents:   Delay Load Failure Hook
//
//  Author:     conradc   24 April 2001
//
//----------------------------------------------------------------------------

#include <libpch.h>
#include "tr.h"
#include "dldp.h"

#include "dload.tmh"




const TraceIdEntry Dload = L"dlddload";




//+---------------------------------------------------------------------------
//
//
FARPROC
WINAPI
DldpDelayLoadFailureHandler (LPCSTR pszDllName,
                           LPCSTR pszProcName)
{
FARPROC ReturnValue = NULL;

    ASSERT (pszDllName);
    ASSERT (pszProcName);  


    // Trace some potentially useful information about why we were called.
    //
    if (!IS_INTRESOURCE(pszProcName))
    {
        TrERROR(Dload, 
                "DldLIBDelayloadFailureHook: Dll=%hs, ProcName=%hs", 
                 pszDllName, 
                 pszProcName);
        
    }
    else
    {
        TrERROR(Dload, 
                "DldpDelayLoadFailureHandler: Dll=%s, Ordinal=%u\n",
                pszDllName,
                (DWORD)((DWORD_PTR)pszProcName));

        
    }


    ReturnValue = DldpLookupHandler(pszDllName, pszProcName);

    if (ReturnValue)
    {
        TrERROR(Dload, 
                "Returning handler function at address 0x%x",
                (int)((LONG_PTR)ReturnValue));


    }
    else
    {
        if (!IS_INTRESOURCE(pszProcName))
        {
            TrERROR(Dload,
                    "No delayload handler found for Dll=%hs, ProcName=%hs\n Please add one in private\\dload.",
                     pszDllName, 
                     pszProcName);

            
        }
        else
        {
            TrERROR(Dload, 
                    "No delayload handler found for Dll=%hs, Ordinal=%u\n Please add one in private\\dload.",
                    pszDllName,
                    (DWORD)((DWORD_PTR)pszProcName));
        }
    }


    return ReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\dld\lib\dldp.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Dldp.h

Abstract:
    MSMQ DelayLoad failure handler private functions.

Author:
    Conrad Chang (conradc) 12-Apr-01

--*/

#pragma once

#ifndef _MSMQ_dldp_H_
#define _MSMQ_dldp_H_
#include <delayimp.h>

const TraceIdEntry Dld = L"MSMQ DelayLoad failure handler";

#ifdef _DEBUG

void DldpAssertValid(void);
void DldpSetInitialized(void);
BOOL DldpIsInitialized(void);
void DldpRegisterComponent(void);


#else // _DEBUG

#define DldpAssertValid() ((void)0)
#define DldpSetInitialized() ((void)0)
#define DldpIsInitialized() TRUE
#define DldpRegisterComponent() ((void)0)

#endif // _DEBUG

//
// External function prototypes
//
extern FARPROC  WINAPI  DldpDelayLoadFailureHook(UINT unReason, PDelayLoadInfo pDelayInfo);
extern FARPROC          DldpLookupHandler (LPCSTR pszDllName, LPCSTR pszProcName);
extern FARPROC  WINAPI  DldpDelayLoadFailureHandler (LPCSTR pszDllName, LPCSTR pszProcName);

const char szNotExistProcedure[] = "ThisProcedureMustNotExist_ConradC";

#endif // _MSMQ_dldp_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\dld\lib\dldinit.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    DldInit.cpp

Abstract:
    MSMQ DelayLoad failure handler initialization

Author:
    Conrad Chang (conradc) 12-Apr-01

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include "Dldp.h"
#include "Dld.h"


#include "dldInit.tmh"




VOID
WINAPI
DldpAssertDelayLoadFailureMapsAreNotSorted(VOID)
{
//
// Leave the function existing in free builds for binary compat on mixed checked/free,
// since the checked in .lib is only free.
#ifdef _DEBUG 
UINT    iDll, iProcName, iOrdinal;
INT     nRet;
WCHAR   wszBuffer[1024];

const DLOAD_DLL_ENTRY*      pDll;
const DLOAD_PROCNAME_MAP*   pProcNameMap;
const DLOAD_ORDINAL_MAP*    pOrdinalMap;

    for (iDll = 0;
         iDll < g_DllMap.NumberOfEntries;
         iDll++)
    {
        if (iDll >= 1)
        {
            nRet = strcmp(g_DllMap.pDllEntry[iDll].pszDll,
                          g_DllMap.pDllEntry[iDll-1].pszDll);

            //
            // If the DLL name is out of order, write the message to the debugger
            // and ASSERT
            //
            if(nRet <= 0)
            {
                wsprintf(wszBuffer, L"dload: rows %u and %u are out of order in dload!g_DllMap",
                        iDll-1, iDll);
                OutputDebugString(wszBuffer);
                ASSERT(FALSE);
                       
            }
        }

        pDll = g_DllMap.pDllEntry + iDll;
        pProcNameMap = pDll->pProcNameMap;
        pOrdinalMap  = pDll->pOrdinalMap;

        if (pProcNameMap)
        {
            ASSERT(pProcNameMap->NumberOfEntries);

            for (iProcName = 0;
                 iProcName < pProcNameMap->NumberOfEntries;
                 iProcName++)
            {
                if (iProcName >= 1)
                {
                    nRet = strcmp(pProcNameMap->pProcNameEntry[iProcName].pszProcName,
                                  pProcNameMap->pProcNameEntry[iProcName-1].pszProcName);


                    if (nRet <= 0)
                    {
                        wsprintf(wszBuffer, 
                                L"dload: rows %u and %u of pProcNameMap are out of order in dload!g_DllMap for pszDll=%hs",
                                iProcName-1, iProcName, pDll->pszDll);
                        OutputDebugString(wszBuffer);
                        ASSERT(FALSE);
                               
                    }
                }
            }
        }

        if (pOrdinalMap)
        {
            ASSERT(pOrdinalMap->NumberOfEntries);

            for (iOrdinal = 0;
                 iOrdinal < pOrdinalMap->NumberOfEntries;
                 iOrdinal++)
            {
                if (iOrdinal >= 1)
                {
                    if (pOrdinalMap->pOrdinalEntry[iOrdinal].dwOrdinal <=
                        pOrdinalMap->pOrdinalEntry[iOrdinal-1].dwOrdinal)
                    {
                        wsprintf(wszBuffer, 
                                L"dload: rows %u and %u of pOrdinalMap are out of order in dload!g_DllMap for pszDll=%s",
                                iOrdinal-1, iOrdinal, pDll->pszDll);

                        OutputDebugString(wszBuffer);
                        ASSERT(FALSE);

                    }
                }
            }
        }
    }
#endif
}













VOID
DldInitialize( )
/*++

Routine Description:
    Initializes MSMQ DelayLoad failure handler library

Arguments:
    None.

Returned Value:
    None.

--*/
{

    //
    // Validate that the MSMQ DelayLoad failure handler library was not initalized yet.
    // You should call its initalization only once.
    //
    ASSERT(!DldpIsInitialized());
    DldpRegisterComponent();

    //
    // In debug build, verify the maps are sorted
    // If the maps are not sorted, throw an assert
    //
    DldpAssertDelayLoadFailureMapsAreNotSorted();      

    //
    // we assume DELAYLOAD_VERSION >= 0x0200
    // so define __pfnDliFailureHook2 should be enough
    //    
    __pfnDliFailureHook2 = DldpDelayLoadFailureHook;

    DldpSetInitialized();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\dld\lib\dlddebug.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    dldDebug.cpp

Abstract:
    MSMQ DelayLoad failure handler debugging

Author:
    Conrad Chang (conradc) 12-Apr-01

Environment:
    Platform-independent, _DEBUG only

--*/

#include <libpch.h>
#include "Dldp.h"
#include "Dld.h"


#include "DldDebug.tmh"

#ifdef _DEBUG


//---------------------------------------------------------
//
// Validate MSMQ DelayLoad failure handler state
//
void DldpAssertValid(void)
{
    //
    // DldInitalize() has *not* been called. You should initialize the
    // MSMQ DelayLoad failure handler library before using any of its funcionality.
    //
    ASSERT(DldpIsInitialized());

    //
    // TODO:Add more MSMQ DelayLoad failure handler validation code.
    //
}


//---------------------------------------------------------
//
// Initialization Control
//
static LONG s_fInitialized = FALSE;

void DldpSetInitialized(void)
{
    LONG fDldAlreadyInitialized = InterlockedExchange(&s_fInitialized, TRUE);

    //
    // The MSMQ DelayLoad failure handler library has *already* been initialized. You should
    // not initialize it more than once. This assertion would be violated
    // if two or more threads initalize it concurently.
    //
    ASSERT(!fDldAlreadyInitialized);
}


BOOL DldpIsInitialized(void)
{
    return s_fInitialized;
}


//---------------------------------------------------------
//
// Tracing and Debug registration
//
const TraceIdEntry xTraceTable[] = {

    Dld,

    //
    // TODO: Add MSMQ DelayLoad failure handler sub-component trace ID's to be used with TrXXXX.
    // For example, dldInit, as used in:
    // TrERROR(dldInit, "Error description", parameters)
    //
};


void DldpRegisterComponent(void)
{
    TrRegisterComponent(xTraceTable, TABLE_SIZE(xTraceTable));
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\dld\lib\lookup.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       L O O K U P . C P P
//
//  Contents:   Routines to find a handler for a DLL procedure.
//
//  Author:     conradc    24 April 2001
//
//  Borrowed from Original Source:  %SDXROOT%\MergedComponents\dload\dload.c
//
//----------------------------------------------------------------------------

#include <libpch.h>
#include "dld.h"
#include "dldp.h"

#include "lookup.tmh"

extern "C" 
{
     FARPROC DelayLoadFailureHook(LPCSTR ,LPCSTR);
}


const TraceIdEntry Lookup = L"dldlookup";






const DLOAD_DLL_ENTRY*FindDll(LPCSTR pszDll)
{
const   DLOAD_DLL_ENTRY* pDll = NULL;
CHAR    pszDllLowerCased [MAX_PATH + 1];
INT     nResult;

    //
    // These must be signed integers for the following binary search
    // to work correctly when iMiddle == 0 and nResult < 0.
    //
    INT iLow;
    INT iMiddle;
    INT iHigh;

    ASSERT(pszDll);
    ASSERT(strlen (pszDll) <= MAX_PATH);

    strcpy (pszDllLowerCased, pszDll);
    _strlwr (pszDllLowerCased);

    iLow = 0;
    iHigh = g_DllMap.NumberOfEntries - 1;
    while (iHigh >= iLow)
    {
        iMiddle = (iLow + iHigh) / 2;
        nResult = strcmp (pszDllLowerCased, g_DllMap.pDllEntry[iMiddle].pszDll);

        if (nResult < 0)
        {
            iHigh = iMiddle - 1;
        }
        else if (nResult > 0)
        {
            iLow = iMiddle + 1;
        }
        else
        {
            pDll = &g_DllMap.pDllEntry[iMiddle];
            break;
        }
    }
    return pDll;
}

FARPROC
DldpLookupHandlerByName (LPCSTR   pszProcName,
                     const DLOAD_PROCNAME_MAP*   pMap)
{
FARPROC pfnHandler = NULL;
INT     nResult;

    //
    // These must be signed integers for the following binary search
    // to work correctly when iMiddle == 0 and nResult < 0.
    //
    INT iLow;
    INT iMiddle;
    INT iHigh;

    ASSERT(pszProcName);
    ASSERT(pMap);

    iLow = 0;
    iHigh = pMap->NumberOfEntries - 1;
    while (iHigh >= iLow)
    {
        iMiddle = (iLow + iHigh) / 2;
        nResult = strcmp (pszProcName,
                          pMap->pProcNameEntry[iMiddle].pszProcName);

        if (nResult < 0)
        {
            iHigh = iMiddle - 1;
        }
        else if (nResult > 0)
        {
            iLow = iMiddle + 1;
        }
        else
        {
            pfnHandler = pMap->pProcNameEntry[iMiddle].pfnProc;
            break;
        }
    }

    return pfnHandler;
}

FARPROC
DldpLookupHandlerByOrdinal (DWORD                       dwOrdinal,
                            const DLOAD_ORDINAL_MAP*    pMap)
{
FARPROC pfnHandler = NULL;
DWORD   dwOrdinalProbe;

    //
    // These must be signed integers for the following binary search
    // to work correctly when iMiddle == 0 and dwOrdinal < dwOrdinalProbe.
    //
    INT iLow;
    INT iMiddle;
    INT iHigh;

    iLow = 0;
    iHigh = pMap->NumberOfEntries - 1;
    while (iHigh >= iLow)
    {
        iMiddle = (iLow + iHigh) / 2;
        dwOrdinalProbe = pMap->pOrdinalEntry[iMiddle].dwOrdinal;

        if (dwOrdinal < dwOrdinalProbe)
        {
            iHigh = iMiddle - 1;
        }
        else if (dwOrdinal > dwOrdinalProbe)
        {
            iLow = iMiddle + 1;
        }
        else
        {
            ASSERT (dwOrdinal == dwOrdinalProbe);
            pfnHandler = pMap->pOrdinalEntry[iMiddle].pfnProc;
            break;
        }
    }

    return pfnHandler;
}

FARPROC
DldpLookupHandler(LPCSTR pszDllName,
                  LPCSTR pszProcName)
{
FARPROC                 pfnHandler = NULL;
const DLOAD_DLL_ENTRY*  pDll;

    ASSERT (pszDllName);
    ASSERT (pszProcName);

    //
    // Find the DLL record if we have one.
    //
    pDll = FindDll (pszDllName);
    if (pDll)
    {
        //
        // Now find the handler whether it be by name or ordinal.
        //
        if (!IS_INTRESOURCE(pszProcName) &&
            pDll->pProcNameMap)
        {
            pfnHandler = DldpLookupHandlerByName (pszProcName,
                                                  pDll->pProcNameMap);
        }
        else if (pDll->pOrdinalMap)
        {
            pfnHandler = DldpLookupHandlerByOrdinal (PtrToUlong(pszProcName),
                                                     pDll->pOrdinalMap);
        }
    }
    else
    {
/*
        //
        // If we can't find the DLL, forward the call the kernel32.dll
        // and have it handle the call
        // 
        typedef FARPROC (WINAPI *KERNEL32DLOADPROC)(LPCSTR ,LPCSTR);
        HMODULE hMod = GetModuleHandle(L"kernel32.dll");
        if(hMod)
        {
        KERNEL32DLOADPROC pKernel32DLoadHandler = (KERNEL32DLOADPROC)GetProcAddress(hMod,
		     							      			                            "DelayLoadFailureHook");

            if(pKernel32DLoadHandler)
            {
                pfnHandler = pKernel32DLoadHandler(pszDllName, pszProcName);
                TrERROR(Lookup, 
                        "MQDelayLoadHandler redirect the unload DLL to kernel32 DelayLoadFailureHook: Dll=%hs", 
                         pszDllName);
            }
        }
*/
    //
    // Function declaration for a function that we will use from kernl32p.lib
    //
    

        
        pfnHandler = DelayLoadFailureHook(pszDllName, pszProcName);

        TrTRACE(Lookup,
                "Unable to provide failure handling for module '%hs', redirects to kernel32 DelayLoadFailureHook and return function pointer = 0x%x", 
                pszDllName, (int)((LONG_PTR)pfnHandler));
    }

    return pfnHandler;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\dld\lib\mqdload.cpp ===
#include <libpch.h>
#include "dldp.h"








// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// NOTE: 
//
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


FARPROC  WINAPI  DldpDelayLoadFailureHook(UINT           unReason,
					                      PDelayLoadInfo pDelayInfo)
{
FARPROC ReturnValue = NULL;
static  HMODULE hModule=NULL;

    //
    // For a failed LoadLibrary, we will return the HINSTANCE of this DLL.
    // This will cause the loader to try a GetProcAddress on our DLL for the
    // function.  This will subsequently fail and then we will be called
    // for dliFailGetProc below.
    //
    if (dliFailLoadLib == unReason)
    {
        //
        // Obtain the module handle if we don't have it yet
        //
        if(!hModule)
        {
            hModule = GetModuleHandle(NULL);
        }

        ReturnValue = (FARPROC)hModule;

        if (!pDelayInfo->dlp.fImportByName)
        {
            //
            // HACKHACK (reinerf)
            //
            // For ORDINAL delayload failures we cannot just return our base addr and be done with everything.
            // The problem is that the linker stub code will turn around and call GetProcAddress() some random
            // ordinal in our module which probably exists and definately NOT (pDelayInfo->szDll)!(pDelayInfo->dlp.dwOrdinal)
            //
            // So to get around this problem we will stash the ordinal# in the pDelayInfo->pfnCur field and slam the
            // procedure name to "ThisProcedureMustNotExistInMQRT"
            //
            // This will cause the GetProcAddress to fail, at which time our failure hook should be called again and we can then
            // undo the hack below and return the proper function address.
            //
            pDelayInfo->pfnCur = (FARPROC)(DWORD_PTR)pDelayInfo->dlp.dwOrdinal;
            pDelayInfo->dlp.fImportByName = TRUE;
            pDelayInfo->dlp.szProcName = szNotExistProcedure;
        }
    }
    else if (dliFailGetProc == unReason)
    {
        //
        // The loader is asking us to return a pointer to a procedure.
        // Lookup the handler for this DLL/procedure and, if found, return it.
        // If we don't find it, we'll assert with a message about the missing
        // handler.
        //
        FARPROC pfnHandler;

        //
        // HACKHACH (reinerf) -- see above comments...
        //
        if (pDelayInfo->dlp.fImportByName && lstrcmpA(pDelayInfo->dlp.szProcName, szNotExistProcedure) == 0)
        {
            pDelayInfo->dlp.dwOrdinal = (DWORD)(DWORD_PTR)pDelayInfo->pfnCur;
            pDelayInfo->pfnCur = NULL;
            pDelayInfo->dlp.fImportByName = FALSE;
        }

        // Try to find an error handler for the DLL/procedure.
        pfnHandler = DldpDelayLoadFailureHandler(pDelayInfo->szDll, pDelayInfo->dlp.szProcName);

        if (pfnHandler)
        {
            //
            // Do this on behalf of the handler now that it is about to
            // be called.
            //
            SetLastError (ERROR_MOD_NOT_FOUND);
        }

        ReturnValue = pfnHandler;
    }

    return ReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\dld\test\dldtest\dldtest.h ===
HRESULT
APIENTRY
DepGetUserCerts(CMQSigCertificate **,
                             DWORD              *,
                             PSID                );


HRESULT APIENTRY
DepGetSecurityContextEx(LPVOID  ,
                                     DWORD   ,
                                     HANDLE *);


HRESULT
APIENTRY
DepOpenInternalCertStore(OUT CMQSigCertStore **,
                                      IN  LONG            *,
                                      IN  BOOL            ,
                                      IN  BOOL            ,
                                      IN  HKEY            );

HRESULT
APIENTRY
DepGetInternalCert(OUT CMQSigCertificate **,
                                OUT CMQSigCertStore   **,
                                IN  BOOL              ,
                                IN  BOOL              ,
                                IN  HKEY              );

HRESULT  DepCreateInternalCertificate(OUT CMQSigCertificate **);


HRESULT  DepDeleteInternalCert(IN CMQSigCertificate *);


HRESULT
APIENTRY
DepRegisterUserCert(IN CMQSigCertificate *,
                                 IN BOOL               );


HRESULT
APIENTRY
DepRemoveUserCert(IN CMQSigCertificate *);


HRESULT
APIENTRY
DepMgmtAction(IN LPCWSTR ,
                           IN LPCWSTR ,
                           IN LPCWSTR );

HRESULT APIENTRY
DepGetSecurityContextEx(LPVOID  ,
                                     DWORD   ,
                                     HANDLE *);

HRESULT
APIENTRY
DepMgmtGetInfo(IN LPCWSTR ,
                            IN LPCWSTR ,
                            IN OUT MQMGMTPROPS* );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\dld\test\dldtest\dllmap.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       P R O C M A P . C
//
//  Contents:   Procedure maps for dload.c
//
//  Notes:
//
//  Author:     conradc   12 April 2001
//              Originated from %sdxroot%\MergedComponents\dload\dllmap.c
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "windows.h"
#include "dld.h"



//
// All of the dll's that dld.lib supports delay-load failure handlers for
// (both by procedure and by ordinal) need both a DECLARE_XXXXXX_MAP below and
// a DLDENTRYX entry in the g_DllEntries list.
//

// alphabetical order (hint hint)

DECLARE_PROCNAME_MAP(mqrtdep)




const DLOAD_DLL_ENTRY g_DllEntries [] =
{
    // must be in alphabetical increasing order 
    DLDENTRYP(mqrtdep)
};


const DLOAD_DLL_MAP g_DllMap =
{
    celems(g_DllEntries),
    g_DllEntries
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\dld\lib\rtdep.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    rtdep.cpp

Abstract:

    The following code implement Delay Load Failure Hook for mqrtdep.dll in lib/dld/lib.
    When LoadLibrary or GetProcAddress failure, it will call one of the following stub functions as if it
    is the function intented, and returns our error code, i.e. MQ_ERROR_DELAYLOAD_MQRTDEP and 
    set the lasterror accordingly.  

To Use:
    In your sources file, right after you specify the modules you
    are delayloading 
     
     do:
        DLOAD_ERROR_HANDLER=MQDelayLoadFailureHook
        link with $(MSMQ_LIB_PATH)\dld.lib \ 

        



DelayLoad Reference:
    code sample: %SDXROOT%\MergedComponents\dload\dload.c
    Contact: Reiner Fink (reinerf)

Author:

    Conrad Chang (conradc) 12-April-2001


Revision History:
  

--*/

#include <libpch.h>
#include "mqsymbls.h"
#include <qformat.h>
#include <transact.h>
#include <qmrt.h>
#include <mqlog.h>
#include <rt.h>
#include "mqcert.h"
#include "dld.h"


#include "rtdep.tmh"

static WCHAR *sFN=L"lib\\dld\\rtdep";

const TraceIdEntry RTDep = L"rtdep";




////////////////////////////////////////////////////////////////////////
//
//  Stub functions below implements all the MQRTDEP.DLL export functions.
//
////////////////////////////////////////////////////////////////////////

HRESULT
APIENTRY
DepCreateQueue(IN PSECURITY_DESCRIPTOR ,
               IN OUT MQQUEUEPROPS* ,
               OUT LPWSTR ,
               IN OUT LPDWORD )
{
    TrERROR(RTDep,
            "Fail to locate the procedure entry point DepCreateQueue in MQRTDEP.DLL");
    return LogHR(MQ_ERROR_DELAYLOAD_FAILURE, sFN, 1000);
}


HRESULT
APIENTRY
DepDeleteQueue(IN LPCWSTR )
{
    TrERROR(RTDep,
            "Fail to locate the procedure entry point DepDeleteQueue in MQRTDEP.DLL");
    return LogHR(MQ_ERROR_DELAYLOAD_FAILURE, sFN, 1001);
}

HRESULT
APIENTRY
DepLocateBegin(IN LPCWSTR ,
               IN MQRESTRICTION* ,
               IN MQCOLUMNSET* ,
               IN MQSORTSET* ,
               OUT PHANDLE )
{
    TrERROR(RTDep,
            "Fail to locate the procedure entry point DepLocateBegin in MQRTDEP.DLL");
    return LogHR(MQ_ERROR_DELAYLOAD_FAILURE, sFN, 1002);
}

HRESULT
APIENTRY
DepLocateNext(IN HANDLE ,
              IN OUT DWORD* ,
              OUT MQPROPVARIANT *)
{
    TrERROR(RTDep,
            "Fail to locate the procedure entry point DepLocateNext in MQRTDEP.DLL");
    return LogHR(MQ_ERROR_DELAYLOAD_FAILURE, sFN, 1003);
}

HRESULT
APIENTRY
DepLocateEnd(IN HANDLE )
{
   TrERROR(RTDep,
           "Fail to locate the procedure entry point DepLocateEnd in MQRTDEP.DLL");
   return LogHR(MQ_ERROR_DELAYLOAD_FAILURE, sFN, 1004);
}

HRESULT
APIENTRY
DepOpenQueue(IN LPCWSTR ,
             IN DWORD ,
             IN DWORD ,
             OUT QUEUEHANDLE* )
{
   TrERROR(RTDep,
           "Fail to locate the procedure entry point DepOpenQueue in MQRTDEP.DLL");
   return LogHR(MQ_ERROR_DELAYLOAD_FAILURE, sFN, 1004);
}

HRESULT
APIENTRY
DepSendMessage(IN QUEUEHANDLE ,
               IN MQMSGPROPS* ,
               IN ITransaction *)
{
    TrERROR(RTDep,
           "Fail to locate the procedure entry point DepSendMessage in MQRTDEP.DLL");
    return LogHR(MQ_ERROR_DELAYLOAD_FAILURE, sFN, 1004);
}

HRESULT
APIENTRY
DepReceiveMessage(IN QUEUEHANDLE ,
                  IN DWORD ,
                  IN DWORD ,
                  IN OUT MQMSGPROPS* ,
                  IN OUT LPOVERLAPPED ,
                  IN PMQRECEIVECALLBACK ,
                  IN HANDLE ,
                  IN ITransaction* )
{
    TrERROR(RTDep,
           "Fail to locate the procedure entry point DepReceiveMessage in MQRTDEP.DLL");
    return LogHR(MQ_ERROR_DELAYLOAD_FAILURE, sFN, 1004);
}

HRESULT
APIENTRY
DepCreateCursor(IN QUEUEHANDLE ,
                OUT PHANDLE )
{
    TrERROR(RTDep,
           "Fail to locate the procedure entry point DepCreateCursor in MQRTDEP.DLL");
    return LogHR(MQ_ERROR_DELAYLOAD_FAILURE, sFN, 1004);
}

HRESULT
APIENTRY
DepCloseCursor(IN HANDLE )
{
    TrERROR(RTDep,
           "Fail to locate the procedure entry point DepCloseCursor in MQRTDEP.DLL");
    return LogHR(MQ_ERROR_DELAYLOAD_FAILURE, sFN, 1004);
}

HRESULT
APIENTRY
DepCloseQueue(IN HANDLE )
{
    TrERROR(RTDep,
           "Fail to locate the procedure entry point DepCloseQueue in MQRTDEP.DLL");
    return LogHR(MQ_ERROR_DELAYLOAD_FAILURE, sFN, 1004);
}

HRESULT
APIENTRY
DepSetQueueProperties(IN LPCWSTR ,
                      IN MQQUEUEPROPS* )
{
    TrERROR(RTDep,
           "Fail to locate the procedure entry point DepSetQueueProperties in MQRTDEP.DLL");
    return LogHR(MQ_ERROR_DELAYLOAD_FAILURE, sFN, 1004);
}

HRESULT
APIENTRY
DepGetQueueProperties(IN LPCWSTR ,
                      OUT MQQUEUEPROPS* )
{
    TrERROR(RTDep,
           "Fail to locate the procedure entry point DepGetQueueProperties in MQRTDEP.DLL");
    return LogHR(MQ_ERROR_DELAYLOAD_FAILURE, sFN, 1004);
}

HRESULT
APIENTRY
DepGetQueueSecurity(IN LPCWSTR ,
                    IN SECURITY_INFORMATION ,
                    OUT PSECURITY_DESCRIPTOR ,
                    IN DWORD ,
                    OUT LPDWORD )
{
    TrERROR(RTDep,
           "Fail to locate the procedure entry point DepGetQueueSecurity in MQRTDEP.DLL");
    return LogHR(MQ_ERROR_DELAYLOAD_FAILURE, sFN, 1004);
}

HRESULT
APIENTRY
DepSetQueueSecurity(IN LPCWSTR ,
                    IN SECURITY_INFORMATION ,
                    IN PSECURITY_DESCRIPTOR )
{
    TrERROR(RTDep,
           "Fail to locate the procedure entry point DepSetQueueSecurity in MQRTDEP.DLL");
    return LogHR(MQ_ERROR_DELAYLOAD_FAILURE, sFN, 1004);
}

HRESULT
APIENTRY
DepPathNameToFormatName(IN LPCWSTR ,
                        OUT LPWSTR ,
                        IN OUT LPDWORD )
{
    TrERROR(RTDep,
           "Fail to locate the procedure entry point DepPathNameToFormatName in MQRTDEP.DLL");
    return LogHR(MQ_ERROR_DELAYLOAD_FAILURE, sFN, 1004);
}

HRESULT
APIENTRY
DepHandleToFormatName(IN QUEUEHANDLE ,
                      OUT LPWSTR ,
                      IN OUT LPDWORD )
{
    TrERROR(RTDep,
           "Fail to locate the procedure entry point DepHandleToFormatName in MQRTDEP.DLL");
    return LogHR(MQ_ERROR_DELAYLOAD_FAILURE, sFN, 1004);
}

HRESULT
APIENTRY
DepInstanceToFormatName(IN GUID* ,
                        OUT LPWSTR ,
                        IN OUT LPDWORD )
{
    TrERROR(RTDep,
           "Fail to locate the procedure entry point DepInstanceToFormatName in MQRTDEP.DLL");
    return LogHR(MQ_ERROR_DELAYLOAD_FAILURE, sFN, 1004);
}

void
APIENTRY
DepFreeMemory(IN PVOID )
{
    TrERROR(RTDep,
           "Fail to locate the procedure entry point DepFreeMemory in MQRTDEP.DLL");
    LogHR(MQ_ERROR_DELAYLOAD_FAILURE, sFN, 1004);
    return;
}

HRESULT
APIENTRY
DepGetMachineProperties(IN LPCWSTR ,
                        IN const GUID* ,
                        IN OUT MQQMPROPS* )
{
    TrERROR(RTDep,
           "Fail to locate the procedure entry point DepGetMachineProperties in MQRTDEP.DLL");
    return LogHR(MQ_ERROR_DELAYLOAD_FAILURE, sFN, 1004);
}




HRESULT
APIENTRY
DepGetSecurityContext(IN PVOID ,
                      IN DWORD ,
                      OUT HANDLE* )
{
    TrERROR(RTDep,
           "Fail to locate the procedure entry point DepGetSecurityContext in MQRTDEP.DLL");
    return LogHR(MQ_ERROR_DELAYLOAD_FAILURE, sFN, 1004);
}

void
APIENTRY
DepFreeSecurityContext(IN HANDLE )
{
    TrERROR(RTDep,
           "Fail to locate the procedure entry point DepFreeSecurityContext in MQRTDEP.DLL");
    LogHR(MQ_ERROR_DELAYLOAD_FAILURE, sFN, 1004);
    return;
}

HRESULT
APIENTRY
DepRegisterCertificate(IN DWORD   ,
                       IN PVOID   ,
                       IN DWORD   )
{
    TrERROR(RTDep,
           "Fail to locate the procedure entry point DepRegisterCertificate in MQRTDEP.DLL");
    return LogHR(MQ_ERROR_DELAYLOAD_FAILURE, sFN, 1004);
}

HRESULT
APIENTRY
DepBeginTransaction(OUT ITransaction **)
{
    TrERROR(RTDep,
           "Fail to locate the procedure entry point DepBeginTransaction in MQRTDEP.DLL");
    return LogHR(MQ_ERROR_DELAYLOAD_FAILURE, sFN, 1004);
}

HRESULT
APIENTRY
DepGetOverlappedResult(IN LPOVERLAPPED )
{
    TrERROR(RTDep,
           "Fail to locate the procedure entry point DepGetOverlappedResult in MQRTDEP.DLL");
    return LogHR(MQ_ERROR_DELAYLOAD_FAILURE, sFN, 1004);
}

HRESULT
APIENTRY
DepGetPrivateComputerInformation(IN LPCWSTR ,
                                 IN OUT MQPRIVATEPROPS* )
{
    TrERROR(RTDep,
           "Fail to locate the procedure entry point DepGetPrivateComputerInformation in MQRTDEP.DLL");
    return LogHR(MQ_ERROR_DELAYLOAD_FAILURE, sFN, 1004);
}


HRESULT
APIENTRY
DepPurgeQueue(IN HANDLE )
{
    TrERROR(RTDep,
           "Fail to locate the procedure entry point DepPurgeQueue in MQRTDEP.DLL");
    return LogHR(MQ_ERROR_DELAYLOAD_FAILURE, sFN, 1004);
}


HRESULT
APIENTRY
DepMgmtGetInfo(IN LPCWSTR ,
               IN LPCWSTR ,
               IN OUT MQMGMTPROPS* )
{
    TrERROR(RTDep,
           "Fail to locate the procedure entry point DepMgmtGetInfo in MQRTDEP.DLL");
    return LogHR(MQ_ERROR_DELAYLOAD_FAILURE, sFN, 1004);
}


//
// The following functions are exported by MQRTDEP.DLL but not used by MQRT.DLL
//
HRESULT
APIENTRY
DepGetUserCerts(CMQSigCertificate **,
                DWORD              *,
                PSID                ) 
{
    TrERROR(RTDep,
           "Fail to locate the procedure entry point DepGetUserCerts in MQRTDEP.DLL");
    return LogHR(MQ_ERROR_DELAYLOAD_FAILURE, sFN, 1004);
}


HRESULT APIENTRY
DepGetSecurityContextEx(LPVOID  ,
                        DWORD   ,
                        HANDLE *)
{
    TrERROR(RTDep,
           "Fail to locate the procedure entry point DepGetSecurityContextEx in MQRTDEP.DLL");
    return LogHR(MQ_ERROR_DELAYLOAD_FAILURE, sFN, 1004);
}


HRESULT
APIENTRY
DepOpenInternalCertStore(OUT CMQSigCertStore **,
                         IN  LONG            *,
                         IN  BOOL            ,
                         IN  BOOL            ,
                         IN  HKEY            )
{
    TrERROR(RTDep,
           "Fail to locate the procedure entry point DepOpenInternalCertStore in MQRTDEP.DLL");
    return LogHR(MQ_ERROR_DELAYLOAD_FAILURE, sFN, 1004);
}

HRESULT
APIENTRY
DepGetInternalCert(OUT CMQSigCertificate **,
                   OUT CMQSigCertStore   **,
                   IN  BOOL              ,
                   IN  BOOL              ,
                   IN  HKEY              )
{
    TrERROR(RTDep,
           "Fail to locate the procedure entry point DepGetInternalCert in MQRTDEP.DLL");
    return LogHR(MQ_ERROR_DELAYLOAD_FAILURE, sFN, 1004);
}

HRESULT DepCreateInternalCertificate(OUT CMQSigCertificate **)
{
    TrERROR(RTDep,
           "Fail to locate the procedure entry point DepCreateInternalCertificate in MQRTDEP.DLL");
    return LogHR(MQ_ERROR_DELAYLOAD_FAILURE, sFN, 1004);
}

HRESULT  DepDeleteInternalCert(IN CMQSigCertificate *)
{
    TrERROR(RTDep,
           "Fail to locate the procedure entry point DepDeleteInternalCert in MQRTDEP.DLL");
    return LogHR(MQ_ERROR_DELAYLOAD_FAILURE, sFN, 1004);
}


HRESULT
APIENTRY
DepRegisterUserCert(IN CMQSigCertificate *,
                    IN BOOL               )
{
    TrERROR(RTDep,
           "Fail to locate the procedure entry point DepRegisterUserCert in MQRTDEP.DLL");
    return LogHR(MQ_ERROR_DELAYLOAD_FAILURE, sFN, 1004);
}

HRESULT
APIENTRY
DepRemoveUserCert(IN CMQSigCertificate *) 
{
    TrERROR(RTDep,
           "Fail to locate the procedure entry point DepRemoveUserCert in MQRTDEP.DLL");
    return LogHR(MQ_ERROR_DELAYLOAD_FAILURE, sFN, 1004);
}


HRESULT
APIENTRY
DepMgmtAction(IN LPCWSTR ,
              IN LPCWSTR ,
              IN LPCWSTR )
{
    TrERROR(RTDep,
           "Fail to locate the procedure entry point DepMgmtAction in MQRTDEP.DLL");
    return LogHR(MQ_ERROR_DELAYLOAD_FAILURE, sFN, 1004);
}






//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(mqrtdep)
{
    DLPENTRY(DepBeginTransaction)
    DLPENTRY(DepCloseCursor)
    DLPENTRY(DepCloseQueue)
    DLPENTRY(DepCreateCursor)
    DLPENTRY(DepCreateInternalCertificate)
    DLPENTRY(DepCreateQueue)
    DLPENTRY(DepDeleteInternalCert)
    DLPENTRY(DepDeleteQueue)
    DLPENTRY(DepFreeMemory)
    DLPENTRY(DepFreeSecurityContext)
    DLPENTRY(DepGetInternalCert)
    DLPENTRY(DepGetMachineProperties)
    DLPENTRY(DepGetOverlappedResult)
    DLPENTRY(DepGetPrivateComputerInformation)
    DLPENTRY(DepGetQueueProperties)
    DLPENTRY(DepGetQueueSecurity)
    DLPENTRY(DepGetSecurityContext)
    DLPENTRY(DepGetSecurityContextEx)
    DLPENTRY(DepGetUserCerts)
    DLPENTRY(DepHandleToFormatName)
    DLPENTRY(DepInstanceToFormatName)
    DLPENTRY(DepLocateBegin)
    DLPENTRY(DepLocateEnd)
    DLPENTRY(DepLocateNext)
    DLPENTRY(DepMgmtAction)
    DLPENTRY(DepMgmtGetInfo)
    DLPENTRY(DepOpenInternalCertStore)
    DLPENTRY(DepOpenQueue)
    DLPENTRY(DepPathNameToFormatName)
    DLPENTRY(DepPurgeQueue)
    DLPENTRY(DepReceiveMessage)
    DLPENTRY(DepRegisterCertificate)    
    DLPENTRY(DepRegisterUserCert)
    DLPENTRY(DepRemoveUserCert)
    DLPENTRY(DepSendMessage)
    DLPENTRY(DepSetQueueProperties)
    DLPENTRY(DepSetQueueSecurity)
};



DEFINE_PROCNAME_MAP(mqrtdep)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\dld\test\dldtest\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	mqcreate.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\dld\test\testdll\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	testdll.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\dld\test\dldtest\dldtest.cpp ===
// Depcreate.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include "windows.h"
#include <wchar.h>
#include "tr.h"
#include <transact.h>
#include <qmrt.h>
#include <mqlog.h>
#include "mqcert.h"
#include "rtdep.h"
#include "cm.h"

#include "dld.h"
#include "dldtest.h"
#include "..\testdll\testdll.h"










int _cdecl main(int , char* [])
{
HRESULT hr;

    CmInitialize(HKEY_LOCAL_MACHINE, L"");
    TrInitialize();
    DldInitialize();
    

    hr = DepCreateQueue(NULL, NULL, NULL, NULL);
    printf("return code from DepCreateQueue call = 0x%x\n", hr);

    hr = DepDeleteQueue(NULL);
    printf("return code from DepDeleteQuue call = 0x%x\n", hr);
    
    hr = DepLocateBegin(NULL, NULL, NULL, NULL, 0);
    printf("return code from DepLocateBegin call = 0x%x\n", hr);


    hr = DepLocateNext(NULL, NULL, NULL);
    printf("return code from DepLocateNext call = 0x%x\n", hr);
    
    hr = DepLocateEnd(NULL);
    printf("return code from DepLocateEnd call = 0x%x\n", hr);

    hr = DepOpenQueue(NULL, 0, 0, NULL);
    printf("return code from DepOpenQueue call = 0x%x\n", hr);
    
    hr = DepSendMessage(NULL, NULL, NULL);
    printf("return code from DepSendMessage call = 0x%x\n", hr);    

    hr = DepReceiveMessage(NULL, 0, 0,NULL, NULL, NULL, NULL, NULL);
    printf("return code from DepReceiveMessage call = 0x%x\n", hr);        

    hr = DepCreateCursor(NULL ,NULL);
    printf("return code from DepCreateCursor call = 0x%x\n", hr);    
    
    hr = DepCloseCursor( NULL );
    printf("return code from DepCloseCursor call = 0x%x\n", hr);    
    
    hr = DepCloseQueue(NULL);
    printf("return code from DepCloseQueue call = 0x%x\n", hr);    
    
    hr = DepSetQueueProperties(NULL , NULL );
    printf("return code from DepSetQueueProperties call = 0x%x\n", hr);    
    

    hr = DepGetQueueProperties(NULL, NULL );
    printf("return code from DepGetQueueProperties call = 0x%x\n", hr);    
    


    hr = DepGetQueueSecurity(NULL, NULL, NULL, 0, NULL );
    printf("return code from DepGetQueueSecurity call = 0x%x\n", hr);    


    hr = DepSetQueueSecurity(NULL , NULL, NULL);
    printf("return code from DepSetQueueSecurity call = 0x%x\n", hr);        


    hr = DepPathNameToFormatName(NULL, NULL, NULL );
    printf("return code from DepPathNameToFormatName call = 0x%x\n", hr);    

 
    hr = DepHandleToFormatName(NULL, NULL, NULL);
    printf("return code from DepHandleToFormatName call = 0x%x\n", hr);        


    hr = DepInstanceToFormatName(NULL, NULL, NULL );
    printf("return code from DepInstanceToFormatName call = 0x%x\n", hr);    

    
    DepFreeMemory(NULL);
    printf("return code from DepFreeMemory call = 0x%x\n", hr);    


    hr = DepGetMachineProperties(NULL, NULL, NULL );
    printf("return code from DepGetMachineProperties call = 0x%x\n", hr);    


    hr = DepGetSecurityContext(NULL, 0, NULL );
    printf("return code from DepGetSecurityContext call = 0x%x\n", hr);        


    DepFreeSecurityContext(NULL );
    printf("return code from DepFreeSecurityContext call = 0x%x\n", hr);    


    hr = DepRegisterCertificate(0, NULL, 0   );
    printf("return code from DepRegisterCertificate call = 0x%x\n", hr);    


    hr = DepBeginTransaction(NULL);
    printf("return code from DepBeginTransaction call = 0x%x\n", hr);       


    hr = DepGetOverlappedResult(NULL );
    printf("return code from DepGetOverlappedResult call = 0x%x\n", hr);        


    hr = DepGetPrivateComputerInformation(NULL, NULL );
    printf("return code from DepGetPrivateComputerInformation call = 0x%x\n", hr);        


    hr = DepPurgeQueue(NULL );
    printf("return code from DepPurgeQueue call = 0x%x\n", hr);    



    hr = DepMgmtGetInfo((unsigned short *)1, (unsigned short *)1, (MQMGMTPROPS *)1 );
    printf("return code from DepMgmtGetInfo call = 0x%x\n", hr);    


//
// The following functions are exported by DepRTDEP.DLL but not used by DepRT.DLL
//



    hr = DepGetUserCerts(NULL, NULL, NULL); 
    printf("return code from DepGetUserCerts call = 0x%x\n", hr);    

 
    hr = DepGetSecurityContextEx(NULL, 0, NULL);
    printf("return code from DepGetSecurityContextEx call = 0x%x\n", hr);    

    hr = DepOpenInternalCertStore(NULL, NULL, FALSE, FALSE, NULL);
    printf("return code from DepOpenInternalCertStore call = 0x%x\n", hr);    

    hr = DepGetInternalCert(NULL, NULL, FALSE, FALSE, NULL);
    printf("return code from DepGetInternalCert call = 0x%x\n", hr);    


    hr = DepRegisterUserCert(NULL, FALSE);
    printf("return code from DepRegisterUserCert call = 0x%x\n", hr);    


    hr = DepRemoveUserCert(NULL); 
    printf("return code from DepRemoveUserCert call = 0x%x\n", hr);    


    hr = DepMgmtAction((const unsigned short *)1, (const unsigned short *)1, (const unsigned short *)1 );
    printf("return code from DepMgmtAction call = 0x%x\n", hr);    


    hr = DepGetUserCerts(NULL, NULL, NULL);
    printf("return code from DepGetUserCerts call = 0x%x\n", hr);    


    // Check for the second delay load DLL
    TCHAR *pData = NULL;

    pData = TestDLLInit();
    if(pData)
    {
        printf("TestDLLInit returns = %ls", pData);
    }

    


	return 0;
}



  
  


void LogMsgHR(HRESULT, LPWSTR, USHORT)
{
    //
    // Temporary. Null implementation for this callback so that we can link
    // with ad.lib. (ShaiK, 15-Jun-2000)
    //
    NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\dld\test\dldtest\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__BFCA535A_8CC8_4DCF_AFF0_6C870729FBCC__INCLUDED_)
#define AFX_STDAFX_H__BFCA535A_8CC8_4DCF_AFF0_6C870729FBCC__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <stdio.h>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__BFCA535A_8CC8_4DCF_AFF0_6C870729FBCC__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\dld\test\testdll\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__99A44321_FEAB_40AA_9427_55BFAD7496EF__INCLUDED_)
#define AFX_STDAFX_H__99A44321_FEAB_40AA_9427_55BFAD7496EF__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


// Insert your headers here
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <windows.h>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__99A44321_FEAB_40AA_9427_55BFAD7496EF__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\dld\test\testdll\testdll.h ===
#ifndef _TESTDLL_
#define _TESTDLL_

TCHAR * WINAPI TestDLLInit();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\dld\test\testdll\testdll.cpp ===
// testdll.cpp : Defines the entry point for the DLL application.
//

#include "stdafx.h"

BOOL APIENTRY DllMain( HANDLE , 
                       DWORD , 
                       LPVOID 
					 )
{
    return TRUE;
}

TCHAR   szData[]=L"TestDLL";

TCHAR *WINAPI TestDLLInit()
{
    return szData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\empty_project\lib\epinit.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    EpInit.cpp

Abstract:
    Empty Project initialization

Author:
    Erez Haba (erezh) 13-Aug-65

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include "Ep.h"
#include "Epp.h"

#include "EpInit.tmh"

VOID
EpInitialize(
    *Parameters*
    )
/*++

Routine Description:
    Initializes Empty Project library

Arguments:
    None.

Returned Value:
    None.

--*/
{
    //
    // Validate that the Empty Project library was not initalized yet.
    // You should call its initalization only once.
    //
    ASSERT(!EppIsInitialized());

    //
    // TODO: Write Empty Project initalization code here
    //

    EppSetInitialized();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\empty_project\lib\ep.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Ep.h

Abstract:
    Empty Project public interface

Author:
    Erez Haba (erezh) 13-Aug-65

--*/

#pragma once

#ifndef _MSMQ_Ep_H_
#define _MSMQ_Ep_H_


VOID
EpInitialize(
    *Parameters*
    );



#endif // _MSMQ_Ep_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\empty_project\lib\epdebug.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    EpDebug.cpp

Abstract:
    Empty Project debugging

Author:
    Erez Haba (erezh) 13-Aug-65

Environment:
    Platform-independent, _DEBUG only

--*/

#include <libpch.h>
#include "Ep.h"
#include "Epp.h"

#include "EpDebug.tmh"

#ifdef _DEBUG


//---------------------------------------------------------
//
// Validate Empty Project state
//
void EppAssertValid(void)
{
    //
    // EpInitalize() has *not* been called. You should initialize the
    // Empty Project library before using any of its funcionality.
    //
    ASSERT(EppIsInitialized());

    //
    // TODO:Add more Empty Project validation code.
    //
}


//---------------------------------------------------------
//
// Initialization Control
//
static LONG s_fInitialized = FALSE;

void EppSetInitialized(void)
{
    LONG fEpAlreadyInitialized = InterlockedExchange(&s_fInitialized, TRUE);

    //
    // The Empty Project library has *already* been initialized. You should
    // not initialize it more than once. This assertion would be violated
    // if two or more threads initalize it concurently.
    //
    ASSERT(!fEpAlreadyInitialized);
}


BOOL EppIsInitialized(void)
{
    return s_fInitialized;
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\empty_project\lib\epp.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Epp.h

Abstract:
    Empty Project private functions.

Author:
    Erez Haba (erezh) 13-Aug-65

--*/

#pragma once

#ifndef _MSMQ_Epp_H_
#define _MSMQ_Epp_H_


const TraceIdEntry Ep = L"Empty Project";

#ifdef _DEBUG

void EppAssertValid(void);
void EppSetInitialized(void);
BOOL EppIsInitialized(void);

#else // _DEBUG

#define EppAssertValid() ((void)0)
#define EppSetInitialized() ((void)0)
#define EppIsInitialized() TRUE

#endif // _DEBUG


#endif // _MSMQ_Epp_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\empty_project\test\eptest.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    EpTest.cpp

Abstract:
    Empty Project library test

Author:
    Erez Haba (erezh) 13-Aug-65

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include "Ep.h"


static void Usage()
{
    printf("Usage: EpTest [*switches*]\n");
    printf("\t*-s*\t*Switch description*\n");
    printf("\n");
    printf("Example, EpTest -switch\n");
    printf("\t*example description*\n");
    exit(-1);

} // Usage


extern "C" int __cdecl _tmain(int /*argc*/, LPCTSTR /*argv*/[])
/*++

Routine Description:
    Test Empty Project library

Arguments:
    Parameters.

Returned Value:
    None.

--*/
{
    WPP_INIT_TRACING(L"Microsoft\\MSMQ");

    EpInitialize(*Parameters*);

    //
    // TODO: Write Empty Project test code here
    //

    WPP_CLEANUP();
    return 0;

} // _tmain
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\ev\lib\ev.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Ev.cpp

Abstract:
    Event Report implementation

Author:
    Uri Habusha (urih) 04-May-99

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include "Ev.h"
#include "Evp.h"

#include "ev.tmh"

static HANDLE s_hEventSource = NULL;

VOID
EvpSetEventSource(
	HANDLE hEventSource
	)
{
    ASSERT(s_hEventSource == NULL);
    ASSERT(hEventSource != NULL);
	s_hEventSource = hEventSource;
}


#ifdef _DEBUG

static HINSTANCE s_hLibrary = NULL;

void
EvpSetMessageLibrary(
	HINSTANCE  hLibrary
	)
{
    ASSERT(s_hLibrary == NULL);
    ASSERT(hLibrary != NULL);
	s_hLibrary = hLibrary;
}


static 
void
TraceReportEvent(
    DWORD EventId,
    va_list va
    )
/*++

Routine Description:
   The Routine printd the event-log message into tracing window

Arguments:
    EventId  - Message id
    pArglist - pointer to argument list for values for 
               formatted message

Returned Value:
    None.

--*/
{
    ASSERT(s_hLibrary != NULL);

    WCHAR msg[1024];

    DWORD ret = FormatMessage( 
                    FORMAT_MESSAGE_FROM_HMODULE,
                    s_hLibrary,
                    EventId,
                    0,
                    msg,
                    TABLE_SIZE(msg),
                    &va
                    );
    if (ret == 0)
    {
        TrWARNING(Ev, "Can't Format Event Log message. Error %d", GetLastError());
        return;
    }

    TrTRACE(Ev, "(%x) %ls", EventId, msg);
}

#else

#define  TraceReportEvent(EventId, pArglist)  ((void) 0)

#endif


static WORD GetEventType(DWORD id)
/*++

Routine Description:
   The Routine returns the event type of the event-log entry that should be written. 
   The type is taken from the severity bits of the message Id.

Arguments:
    id  - Message id

Returned Value:
    None.

--*/
{
    //
    // looking at the severity bits (bits 31-30) and determining
    // the type of event-log entry to display
    //
    switch (id >> 30)
    {
        case STATUS_SEVERITY_ERROR: 
            return EVENTLOG_ERROR_TYPE;

        case STATUS_SEVERITY_WARNING: 
            return EVENTLOG_WARNING_TYPE;

        case STATUS_SEVERITY_INFORMATIONAL: 
            return EVENTLOG_INFORMATION_TYPE;

        default: 
            ASSERT(0);
    }

    return EVENTLOG_INFORMATION_TYPE;
}


static 
void
ReportInternal(
    DWORD EventId,
    DWORD RawDataSize,
    PVOID RawData,
    WORD NoOfStrings,
    va_list va
    )
/*++

Routine Description:
    The routine writes to the Event-log of the Windows-NT system.

Arguments:
    EventId - identity of the message that is to be displayed in the event-log
    RawDataSize - number of memory bytes to be displayed in the event-log (could be 0)
    RawData - address of memory to be displayed
    NoOfStrings - No Of input strings in arglist
    va - argument list of the input for formatted string

ReturnedValue:
    None.

 --*/
{
    ASSERT((NoOfStrings == 0) || (va != NULL));

    LPCWSTR EventStrings[32] = { 0 };     
    ASSERT(TABLE_SIZE(EventStrings) > NoOfStrings);


    va_list vaSave = va;
	DBG_USED(vaSave);
    for (int i = 0; i < NoOfStrings; ++i)
    {
        EventStrings[i] = va_arg(va, LPWSTR);
        //ASSERT(_CrtIsValidPointer(EventStrings[i], 1, TRUE));
    }

    BOOL f = ReportEvent(
                s_hEventSource,
                GetEventType(EventId),
                0,
                EventId,
                NULL,
                NoOfStrings,
                RawDataSize,
                EventStrings,
                RawData
                );
    if (!f)
    {
        TrERROR(Ev, "Can't Report Event: %d. Error %d", EventId, GetLastError());
    }

    TraceReportEvent(EventId, vaSave);
}


VOID
EvReport(
    DWORD EventId,
    DWORD RawDataSize,
    PVOID RawData,
    WORD NoOfStrings
    ... 
    ) 
{
    EvpAssertValid();
    
    //     
    // Look at the strings, if they were provided     
    //     
    va_list va;
    va_start(va, NoOfStrings);
   
    ReportInternal(EventId, RawDataSize, RawData, NoOfStrings, va);

    va_end(va);

}


VOID
EvReport(
    DWORD EventId,
    WORD NoOfStrings
    ... 
    ) 
{
    EvpAssertValid();
    
    //     
    // Look at the strings, if they were provided     
    //     
    va_list va;
    va_start(va, NoOfStrings);
   
    ReportInternal(EventId, 0, NULL, NoOfStrings, va);

    va_end(va);
}


VOID
EvReport(
    DWORD EventId
    ) 
{
    EvpAssertValid();
    
    ReportInternal(EventId, 0, NULL, 0, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\ev\lib\evgf.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Evgf.cpp

Abstract:
    Get Event report file name

Author:
    Uri Habusha (urih) 04-May-99

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include "Ev.h"
#include "Cm.h"
#include "Evp.h"

#include "evgf.tmh"

//
// This code should be in the EvDebug.cpp, however since the Ev Test overwrite
// this function (in order to remove dependency on cm.lib) we need to put it in
// seperate file.
//

LPWSTR EvpGetEventMessageFileName(LPCWSTR AppName)
/*++

Routine Description:
	This routine fetches the event message filename from the registery.

	The routine access the registery to read the event library and load
	it. If the registery key doen't exist an exception is raised.

Parameters:
	AppName - application name

Return Value:
	A heap allocated buffer that holds the event message file name

Note:
	The caller should free the buffer using delete[]

--*/
{
	const WCHAR xEventFileValue[] = L"EventMessageFile";
	const WCHAR xEventSourcePath[] = L"SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\";  

    WCHAR RegPath[MAX_PATH];

    ASSERT(TABLE_SIZE(RegPath) > (wcslen(AppName) + wcslen(xEventSourcePath)));
    wsprintf(RegPath, L"%s%s", xEventSourcePath, AppName);


    RegEntry RegModuleName(
				RegPath,
				xEventFileValue,
				0,
                RegEntry::MustExist,
                HKEY_LOCAL_MACHINE
                );

    //
    // Go fetch the event message filename string
    //
	LPWSTR RegValue;
    CmQueryValue(RegModuleName, &RegValue);

	return RegValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\ev\lib\evp.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Evp.h

Abstract:
    Event Report private functions.

Author:
    Uri Habusha (urih) 17-Sep-00

--*/

#pragma once

#ifndef _MSMQ_Evp_H_
#define _MSMQ_Evp_H_


const TraceIdEntry Ev = L"Event Report";

#ifdef _DEBUG

void EvpAssertValid(void);
void EvpSetInitialized(void);
BOOL EvpIsInitialized(void);
void EvpRegisterComponent(void);

#else // _DEBUG

#define EvpAssertValid() ((void)0)
#define EvpSetInitialized() ((void)0)
#define EvpIsInitialized() TRUE
#define EvpRegisterComponent() ((void)0)

#endif // _DEBUG


#ifdef _DEBUG

LPWSTR EvpGetEventMessageFileName(LPCWSTR AppName);
void EvpLoadEventReportLibrary(LPCWSTR AppName);
void EvpSetMessageLibrary(HINSTANCE hLibrary);

#else // _DEBUG

#define EvpLoadEventReportLibrary(AppName) ((void) 0)

#endif // _DEBUG


VOID
EvpSetEventSource(
	HANDLE hEventSource
	);


#endif // _MSMQ_Evp_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\ev\lib\evinit.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    EvInit.cpp

Abstract:
    Event Report initialization

Author:
    Uri Habusha (urih) 17-Sep-00

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include "Ev.h"
#include "Evp.h"

#include "evinit.tmh"

VOID
EvInitialize(
    LPCWSTR ApplicationName
    )
/*++

Routine Description:
    Initializes Event Report library

Arguments:
    None.

Returned Value:
    None.

--*/
{
    //
    // Validate that the Event Report library was not initalized yet.
    // You should call its initalization only once.
    //
    ASSERT(!EvpIsInitialized());
    EvpRegisterComponent();

    //
    // Get a registered handle to an event log
    // 
    HANDLE hEventSource = RegisterEventSource(NULL, ApplicationName);
    if (hEventSource == NULL)
    {
        TrERROR(Ev, "Can't initialize Event source. Error %d", GetLastError());
        throw bad_alloc();
    }

	EvpSetEventSource(hEventSource);

    //
    // get an handle to report event module
    //
    EvpLoadEventReportLibrary(ApplicationName);

    EvpSetInitialized();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\ev\lib\evsetup.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    EvSetup.cpp

Abstract:
    Event Log registry setup

Author:
    Tatiana Shubin 14-Jan-00

Environment:
    Platform-independent, _DEBUG only

--*/

#include <libpch.h>
#include "Ev.h"
#include "Cm.h"
#include "Evp.h"

#include "evsetup.tmh"

const WCHAR REGKEY_EVENT[] = L"SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\";

VOID 
EvSetup(
    LPCWSTR ApplicationName,
    LPCWSTR ReportModuleName
    )
{  
    //
    // Create registry key for application event
    //
    WCHAR wszRegKey[MAX_PATH];
    wsprintf(wszRegKey, L"%s%s", REGKEY_EVENT, ApplicationName);

    RegEntry regEvent(wszRegKey, L"", 0, RegEntry::Optional, HKEY_LOCAL_MACHINE);
    HKEY hEvent = CmCreateKey(regEvent, NULL);

    RegEntry regEventMsgFile(L"", L"EventMessageFile", 0, RegEntry::MustExist, hEvent);
    CmSetValue(regEventMsgFile, ReportModuleName);


    DWORD dwTypes = EVENTLOG_ERROR_TYPE   |
				  EVENTLOG_WARNING_TYPE |
				  EVENTLOG_INFORMATION_TYPE;

    RegEntry regEventTypesSupported(L"", L"TypesSupported", 0, RegEntry::MustExist, hEvent);
    CmSetValue(regEventTypesSupported, dwTypes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\ev\lib\evdebug.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    EvDebug.cpp

Abstract:
    Event Report debugging

Author:
    Uri Habusha (urih) 17-Sep-00

Environment:
    Platform-independent, _DEBUG only

--*/

#include <libpch.h>
#include "Ev.h"
#include "Evp.h"

#include "evdebug.tmh"

#ifdef _DEBUG


//---------------------------------------------------------
//
// Validate Event Report state
//
void EvpAssertValid(void)
{
    //
    // EvInitalize() has *not* been called. You should initialize the
    // Event Report library before using any of its funcionality.
    //
    ASSERT(EvpIsInitialized());

    //
    // TODO:Add more Event Report validation code.
    //
}


//---------------------------------------------------------
//
// Initialization Control
//
static LONG s_fInitialized = FALSE;

void EvpSetInitialized(void)
{
    LONG fEvAlreadyInitialized = InterlockedExchange(&s_fInitialized, TRUE);

    //
    // The Event Report library has *already* been initialized. You should
    // not initialize it more than once. This assertion would be violated
    // if two or more threads initalize it concurently.
    //
    ASSERT(!fEvAlreadyInitialized);
}


BOOL EvpIsInitialized(void)
{
    return s_fInitialized;
}


//---------------------------------------------------------
//
// Tracing and Debug registration
//
const TraceIdEntry xTraceTable[] = {

    Ev,

    //
    // TODO: Add Event Report sub-component trace ID's to be used with TrXXXX.
    // For example, EvInit, as used in:
    // TrERROR(EvInit, "Error description", parameters)
    //
};

/*
const DebugEntry xDebugTable[] = {

    {
        "EvDumpState(queue path name)",
        "Dump Event Report State to debugger",
        DumpState
    ),

    //
    // TODO: Add Event Report debug & control functions to be invoked using
    // mqctrl.exe utility.
    //
};
*/

void EvpRegisterComponent(void)
{
    TrRegisterComponent(xTraceTable, TABLE_SIZE(xTraceTable));
    //DfRegisterComponent(xDebugTable, TABLE_SIZE(xDebugTable));
}


void EvpLoadEventReportLibrary(LPCWSTR AppName)
/*++
Routine Description:
  This routine print event in Trace window/File. The routine is 
  compiled only in debug mode.
  The routine access the registery to read the event library and load
  it. If the registery key doen't exist an exception is raised.

Parameters:
  AppName - application name

Return Value:
  None

--*/
{
    //
    // Featch the name of Event Report string library from registery
    //
    AP<WCHAR> LibraryName = EvpGetEventMessageFileName(AppName);

    //
    // get an handle to Event Report string library 
    //
    HINSTANCE hLibrary = LoadLibrary(LibraryName);
    if (hLibrary == NULL) 
    {
        TrERROR(Ev, "Can't load Event report library %ls. Error %d\n", LibraryName.get(), GetLastError());
		throw bad_alloc();
    }

	EvpSetMessageLibrary(hLibrary);
}    

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\ev\test\evtest.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    EvTest.cpp

Abstract:
    Event Report library test

Author:
    Uri Habusha (urih) 04-May-99

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include "Cm.h"
#include "Ev.h"
#include "EvTest.h"

#include "EvTest.tmh"

const TraceIdEntry EvTest = L"Event Report Test";

HANDLE hEventLog = NULL;
LPCWSTR MessageFile = NULL;

const IID GUID_NULL = {0};

const WCHAR x_EventSourceName[] = L"EventTest";
const WCHAR x_EventSourcePath[] = L"SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\EventTest";  

static 
void
CheckReportEventInternal(
    DWORD RecordNo,
    DWORD EventId,
    DWORD RawDataSize,
    PVOID RawData,
    WORD NoOfStrings,
    va_list* parglist
    )
{
    char EventRecordBuff[1024];
    DWORD nBytesRead;
    DWORD nBytesRequired;

    BOOL fSucc = ReadEventLog(
                        hEventLog, 
                        EVENTLOG_SEEK_READ | EVENTLOG_FORWARDS_READ,
                        RecordNo,
                        EventRecordBuff,
                        TABLE_SIZE(EventRecordBuff),     
                        &nBytesRead,
                        &nBytesRequired
                        );

    if (!fSucc)
    {
        TrERROR(EvTest, "Read Event Log Failed. Error %d \n", GetLastError());
        throw bad_alloc();
    }

    EVENTLOGRECORD*  pEventRecord = reinterpret_cast<EVENTLOGRECORD*>(EventRecordBuff);
    if (EventId != pEventRecord->EventID) 
    {
        TrERROR(EvTest, "Test Failed. Read Event Id %x, Expected %x\n", pEventRecord->EventID, EventId);
        throw bad_alloc();
    }

    char* p = reinterpret_cast<char*>(&(pEventRecord->DataOffset));
    LPWSTR SourceName = reinterpret_cast<LPWSTR>(p + sizeof(DWORD));
    if (wcscmp(SourceName, x_EventSourceName) != 0)
    {
        TrERROR(EvTest, "Test Failed. Source Name %ls, Expected MSMQ\n", SourceName);
        throw bad_alloc();
    }

    if (NoOfStrings != pEventRecord->NumStrings)
    {
        TrERROR(EvTest, "Test Failed. Number of strings %x, Expected %x\n", pEventRecord->NumStrings, NoOfStrings);
        throw bad_alloc();
    }
    
    LPWSTR strings = reinterpret_cast<LPWSTR>(EventRecordBuff + pEventRecord->StringOffset);
    for (DWORD i = 0; i < NoOfStrings; ++i)
    {
        LPWSTR arg = va_arg(*parglist, LPWSTR);
        if (wcscmp(strings, arg) != 0)
        {
            TrERROR(EvTest, "Test Failed. Argument mismatch  Read %ls, Expected %lc\n", arg, strings[i]);
            throw bad_alloc();
        }
        strings += (wcslen(arg) + 1);
    }

    if (RawDataSize != pEventRecord->DataLength)
    {
        TrERROR(EvTest, "Test Failed. Read Data size %x, Expected %x\n", pEventRecord->DataLength, RawDataSize);
        throw bad_alloc();
    }

    if ((RawDataSize != 0) && 
        (memcmp(RawData, EventRecordBuff+pEventRecord->DataOffset, RawDataSize) != 0))
    {
        TrERROR(EvTest, "Test Failed. Report data mismatch");
        throw bad_alloc();
    }

}



void CheckReportEvent(
    DWORD RecordNo,
    DWORD EventId,
    DWORD RawDataSize,
    PVOID RawData,
    WORD NoOfStrings
    ... 
    ) 
{
    //     
    // Look at the strings, if they were provided     
    //     
    va_list arglist;
    va_start(arglist, NoOfStrings);
   
    CheckReportEventInternal(RecordNo, EventId, RawDataSize, RawData, NoOfStrings, &arglist);

    va_end(arglist);
}

void CheckReportEvent(
    DWORD RecordNo,
    DWORD EventId,
    WORD NoOfStrings
    ... 
    ) 
{
    //     
    // Look at the strings, if they were provided     
    //     
    va_list arglist;
    va_start(arglist, NoOfStrings);
   
    CheckReportEventInternal(RecordNo, EventId, 0, NULL, NoOfStrings, &arglist);

    va_end(arglist);
}


void CheckReportEvent(
    DWORD RecordNo,
    DWORD EventId
    ) 
{
    CheckReportEventInternal(RecordNo, EventId, 0, NULL, 0, NULL);
}

void DeleteTestRegMessageFile()
{
    int rc = RegDeleteKey(HKEY_LOCAL_MACHINE, x_EventSourcePath);
    if (rc != ERROR_SUCCESS)
    {
        TrERROR(EvTest, "Can't delete  registery key %ls. Error %d",x_EventSourcePath, GetLastError());
    }
}

LPWSTR EvpGetEventMessageFileName(LPCWSTR AppName)
{
	ASSERT(wcscmp(AppName, L"EventTest") == 0);
	DBG_USED(AppName);

	LPWSTR retValue = new WCHAR[wcslen(MessageFile) +1];
	wcscpy(retValue, MessageFile);

	return retValue;
}


extern "C" int  __cdecl _tmain(int /*argc*/, LPCTSTR argv[])
/*++

Routine Description:
    Test Event Report library

Arguments:
    Parameters.

Returned Value:
    None.

--*/
{
    WPP_INIT_TRACING(L"Microsoft\\MSMQ");

    int TestReturnValue = 0;
	MessageFile = argv[0];

    TrInitialize();
    CmInitialize(HKEY_LOCAL_MACHINE, L"");

    TrTRACE(EvTest, "running Event Report test ...");
    try
    {        
        EvSetup(L"EventTest", argv[0]);
    
        EvInitialize(L"EventTest");

        hEventLog = OpenEventLog(NULL, L"Application");
        if (hEventLog == NULL)
        {
            TrERROR(Ev Test, "OpenEventLog Failed. Error %d", GetLastError());
            throw bad_alloc();
        }

        DWORD OldestRecord;
        if(! GetNumberOfEventLogRecords(hEventLog, &OldestRecord))
        {
            TrERROR(Ev Test, "GetNumberOfEventLogRecords Failed. Error %d", GetLastError());
            throw bad_alloc();
        }

        WCHAR dumpbuf[] = L"The Event Report Test Pass successfully";
        DWORD size = sizeof(dumpbuf);

        EvReport(TEST_MSG_WITHOUT_PARAMETERS);
        CheckReportEvent(++OldestRecord, TEST_MSG_WITHOUT_PARAMETERS);
    
        EvReport(TEST_MSG_WITH_1_PARAMETERS, 1, L"param 1");
        CheckReportEvent(++OldestRecord, TEST_MSG_WITH_1_PARAMETERS, 1, L"param 1");
    
        EvReport(TEST_INF_MSG_WITH_2_PARAMETERS, 2, L"param 1", L"param 2");
        CheckReportEvent(++OldestRecord, TEST_INF_MSG_WITH_2_PARAMETERS, 2, L"param 1", L"param 2");
        
        EvReport(TEST_ERROR_MSG_WITH_3_PARAMETERS, 3, L"param 1", L"Param 2", L"Param 3");
        CheckReportEvent(++OldestRecord, TEST_ERROR_MSG_WITH_3_PARAMETERS, 3, L"param 1", L"Param 2", L"Param 3");
    
        EvReport(TEST_WARNING_MSG_WITH_4_PARAMETERS, 4, L"param 1", L"Param 2", L"Param 3", L"Param 4");
        CheckReportEvent(++OldestRecord, TEST_WARNING_MSG_WITH_4_PARAMETERS, 4, L"param 1", L"Param 2", L"Param 3", L"Param 4");
    
        EvReport(TEST_MSG_WITH_1_PARAMETERS_AND_DUMP, size, dumpbuf, 1, L"param 1");
        CheckReportEvent(++OldestRecord, TEST_MSG_WITH_1_PARAMETERS_AND_DUMP, size, dumpbuf, 1, L"param 1");
   
        EvReport(TEST_MSG_WITHOUT_PARAMETERS, size, dumpbuf, 0);
        CheckReportEvent(++OldestRecord, TEST_MSG_WITHOUT_PARAMETERS, size, dumpbuf, 0);
    }
    catch(const exception&)
    {
        TestReturnValue = -1;
    }

    DeleteTestRegMessageFile();
    if (hEventLog)
    {
        CloseEventLog(hEventLog);
    }

    if (TestReturnValue == 0)
    {
        TrTRACE(EvTest, "Event Test Pass Successfully\n");
    }

    WPP_CLEANUP();
    return TestReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\ex\lib\exov.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:
    expioc.cpp

Abstract:
    Executive Overlapped Implementation

Author:
    Erez Haba (erezh) 03-Jan-99

Enviroment:
    Platform-Winnt

--*/

#include <libpch.h>
#include "Ex.h"
#include "Exp.h"

#include "exov.tmh"

//---------------------------------------------------------
//
// EXOVERLAPPED Implementation
//
//---------------------------------------------------------
VOID EXOVERLAPPED::CompleteRequest()
/*++

Routine Description:
  Invoke the overlapped completion routine.
    
Arguments:
  None.
     
Returned Value:
  None.
      
--*/
{
    if(SUCCEEDED(GetStatus()))
    {
        m_pfnSuccess(this);
    }
    else
    {
        m_pfnFailure(this);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\ex\lib\exp.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Exp.h

Abstract:
    Executive private functions.

Author:
    Erez Haba (erezh) 03-Jan-99

--*/

#pragma once

#ifndef _MSMQ_Exp_H_
#define _MSMQ_Exp_H_

const TraceIdEntry Ex = L"Executive";
const TraceIdEntry Sc = L"Scheduler";
const TraceIdEntry Rwl = L"Read/Write lock";

#ifdef _DEBUG

void ExpAssertValid(void);
void ExpSetInitialized(void);
BOOL ExpIsInitialized(void);
void ExpRegisterComponent(void);

#else // _DEBUG

#define ExpAssertValid() ((void)0)
#define ExpSetInitialized() ((void)0)
#define ExpIsInitialized() TRUE
#define ExpRegisterComponent() ((void)0)

#endif // _DEBUG


DWORD
WINAPI
ExpWorkingThread(
    LPVOID Param
    );

VOID
ExpInitScheduler(
    VOID
    );

VOID
ExpInitCompletionPort(
    VOID
    );

#endif // _MSMQ_Exp_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\ex\lib\exdebug.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    ExDebug.cpp

Abstract:
    Executive debugging

Author:
    Erez Haba (erezh) 03-Jan-99

Environment:
    Platform-independent, _DEBUG only

--*/

#include <libpch.h>
#include "Exp.h"

#include "exdebug.tmh"

#ifdef _DEBUG


//---------------------------------------------------------
//
// Validate componenet state
//
void ExpAssertValid(void)
{
    //
    // ExInitalize() has *not* been called. You should initialize this
    // componenet before using any of its funcionality.
    //
    ASSERT(ExpIsInitialized());
}


//---------------------------------------------------------
//
// Initialization Control
//
static LONG s_fInitialized = FALSE;

void ExpSetInitialized(void)
{
    LONG fExAlreadyInitialized = InterlockedExchange(&s_fInitialized, TRUE);

    //
    // The Executive has *already* been initialized. You should not
    // initialize it more than once. This assertion would be violated
    // if two or more threads initalize it concurently.
    //
    ASSERT(!fExAlreadyInitialized);
}


BOOL ExpIsInitialized(void)
{
    return s_fInitialized;
}



//---------------------------------------------------------
//
// Tracing and Debug registration
//
const TraceIdEntry xTraceTable[] = {

    Ex,
    Sc,

    //
    // TODO: Add sub-component trace ID's to be used with TrXXXX. For example,
    // ExInit, as used in: TrERROR(ExInit, "Error description", parameters)
    //
};

/*
const DebugEntry xDebugTable[] = {

    {
        "ExDumpState(queue path name)",
        "Dump Empty Project State to debugger",
        DumpState
    ),

    //
    // TODO: Add component debug & control functions to be invoked using
    // mqctrl.exe utility.
    //
};
*/

void ExpRegisterComponent(void)
{
    TrRegisterComponent(xTraceTable, TABLE_SIZE(xTraceTable));
    //DfRegisterComponent(xDebugTable, TABLE_SIZE(xDebugTable));
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\ex\lib\exinit.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    ExInit.cpp

Abstract:
    Executive initialization

Author:
    Erez Haba (erezh) 03-Jan-99

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include "Ex.h"
#include "Exp.h"

#include "ExInit.tmh"

static void StartWorkerThreads(DWORD ThreadCount)
{
    TrTRACE(Ex, "Creating %d worker threads", ThreadCount);

    for ( ; ThreadCount--; )
    {
        DWORD ThreadID;
        HANDLE hThread;

        hThread = CreateThread(
                    NULL,           // Security attributes
                    0,
                    ExpWorkingThread,
                    NULL,           // Thread paramenter
                    0,
                    &ThreadID
                    );
        
        if (hThread == NULL) 
        {
            TrERROR(Ex, "Failed to create worker thread. Error=%d",GetLastError());
            throw bad_alloc();
        }
        
        CloseHandle(hThread);

        TrTRACE(Ex, "Created worker thread. id=%x", ThreadID);
    }
}


void
ExInitialize(
    DWORD ThreadCount
    )
/*++

Routine Description:
    Initializes Exceutive, Create a worker thred pool to service the completion port.

Arguments:
    ThreadCount - Number of threads in the worker threads pool

Returned Value:
    None.

--*/
{
    //
    // Validate that this component was not initalized yet. You should call
    // component initalization only once.
    //
    ASSERT(!ExpIsInitialized());
    ExpRegisterComponent();

    ExpInitCompletionPort();
    StartWorkerThreads(ThreadCount);
    ExpInitScheduler();

    ExpSetInitialized();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\ex\lib\exio.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:
    exio.cpp

Abstract:
    Executive completion port implementation

Author:
    Erez Haba (erezh) 03-Jan-99

Enviroment:
    Platform-Winnt

--*/

#include <libpch.h>
#include "Ex.h"
#include "Exp.h"

#include "exio.tmh"

//
// The Handle to the Io Completion Port
//
static HANDLE s_hPort = NULL;

static HANDLE CreatePort(HANDLE Handle)
{
    HANDLE hPort;
    hPort = CreateIoCompletionPort(
                Handle,
                s_hPort,
                0,
                0
                );

    if(hPort == NULL)
	{
		TrERROR(Ex, "Failed to attach handle=0x%p to port=0x%p. Error=%d", Handle, s_hPort, GetLastError());
        throw bad_alloc();
	}

	return hPort;
}


VOID
ExpInitCompletionPort(
	VOID
	)
/*++

Routine Description:
  Create a new (the only one) Exceutive completion port

Arguments:
  None.

Returned Value:
  None

--*/
{
	ASSERT(s_hPort == NULL);
    s_hPort = CreatePort(INVALID_HANDLE_VALUE);
}


VOID
ExAttachHandle(
    HANDLE Handle
    )
/*++

Routine Description:
  Associates a Handle with the Executive complition port.

Arguments:
  Handle - A handle to associate with the completion port

Returned Value:
  None

--*/
{
    ExpAssertValid();

	ASSERT(Handle != INVALID_HANDLE_VALUE);
    ASSERT(s_hPort != NULL);

    HANDLE hPort = CreatePort(Handle);
	DBG_USED(hPort);

    ASSERT(s_hPort == hPort);
}

 
VOID
ExPostRequest(
    EXOVERLAPPED* pov
    )
/*++

Routine Description:
  Post an Executive overlapped request to the completion port

Arguments:
  pov - An Executive overlapped structure

Returned Value:
  None

--*/
{
    ExpAssertValid();
    ASSERT(s_hPort != NULL);

    BOOL fSucc;
    fSucc = PostQueuedCompletionStatus(
                s_hPort,
                0,
                0,
                pov
                );

    if (!fSucc)
	{
		TrERROR(Ex, "Failed to post overlapped=0x%p to to port=0x%p. Error=%d", pov, s_hPort, GetLastError());
        throw bad_alloc();
	}
}

 
//
// ISSUE-2000/7/24-erezh bad compiler pragma
// This is a bug in the compiler, waiting for a fix
//
#pragma warning(disable: 4716)

DWORD
WINAPI
ExpWorkingThread(
    LPVOID 
    )
/*++

Routine Description:
  The Executive Worker Thread Routine. It handles all completion port postings.
    
  The Worker Thread waits for completion notifications, as soon as one arrives
  it is dequeued from the port and the completion routine is invoked.
    
Arguments:
  None.

Returned Value:
  None.

--*/
{
    for(;;)
    {
        try
        {
            //
            // Wait for a completion notification
            //
            ULONG_PTR Key;
            OVERLAPPED* pov;
            DWORD nNumberOfBytesTransferred;
            BOOL fSucc;

            fSucc = GetQueuedCompletionStatus(
                        s_hPort,
                        &nNumberOfBytesTransferred,
                        &Key,
                        &pov,
                        INFINITE
                        );

            if(pov == NULL)
            {
                ASSERT(!fSucc);
                continue;
            }

            EXOVERLAPPED* pexov = static_cast<EXOVERLAPPED*>(pov);
            pexov->CompleteRequest();

        }        
        catch(const exception& e)
        {
            TrERROR(Ex, "Exception: '%s'", e.what());
        }

    }
}

//
// ISSUE-2000/7/24-erezh bad compiler pragma
// This is a bug in the compiler, waiting for a fix
//
#pragma warning(default: 4716)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\ex\lib\rwlock.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    rwlock.cpp

Abstract:
    Implementation of read/write lock.

Owner:
    Uri Habusha (urih) 16-Jan-2000


History:    19-Nov-97   stevesw:    Stolen from MTS
            20-Nov-97   stevesw:    Cleaned up
            13-Jan-98   stevesw:    Added to ComSvcs
            23-Sep-98   dickd:      Don't call GetLastError when no error

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include <rwlock.h>
#include "Exp.h"

#include "rwlock.tmh"

//+--------------------------------------------------------------------------
//
//        Definitions of the bit fields in CReadWriteLock::m_dwFlag
//       The goal here is to avoid the shifts that bitfields involve
//
//                              -- WARNING --
//              
//               The code assumes that READER_MASK is in the
//                      low-order bits of the DWORD.
//
//           Also, the WRITERS_MASK has two bits so you can see
//                       an overflow when it happens
//
//           Finally, the use of the SafeCompareExchange routine
//      insures that every attempt to change the state of the object
//              either does what was intended, or is a no-op
//
//---------------------------------------------------------------------------

const ULONG READERS_MASK      = 0x000003FF; // # of reader threads
const ULONG READERS_INCR      = 0x00000001; // increment for # of readers

const ULONG WRITERS_MASK      = 0x00000C00; // # of writer threads
const ULONG WRITERS_INCR      = 0x00000400; // increment for # of writers

const ULONG READWAITERS_MASK  = 0x003FF000; // # of threads waiting to read
const ULONG READWAITERS_INCR  = 0x00001000; // increment for # of read waiters

const ULONG WRITEWAITERS_MASK = 0xFFC00000; // # of threads waiting to write
const ULONG WRITEWAITERS_INCR = 0x00400000; // increment for # of write waiters



CReadWriteLock::CReadWriteLock (
    unsigned long ulcSpinCount
    ) :
     m_dwFlag(0),
     m_hReadWaiterSemaphore(NULL),
     m_hWriteWaiterEvent(NULL)
/*++

Routine Description:
    constructs a exclusive/shared lock object

Arguments:
    ulcSpinCount - spin count, for machines on which it's relevant

Returned Value:
    None.

Algorithm:  
    The first trick here, with the static values, is to make sure
    you only go out to figure out whether or not you're on a
    multiprocessor machine once. You need to know because,
    there's no reason to do spin counts on a single-processor
    machine. Once you've checked, the answer you need is cached
    in maskMultiProcessor (which is used to zero out the spin
    count in a single-processor world, and pass it on in a
    multiprocessor one).

    Other than that, this just fills in the members with initial
    values. We don't create the semaphore and event here; there
    are helper routines which create/return them when they're
    needed. 

--*/
{

    static BOOL fInitialized = FALSE;
    static unsigned long maskMultiProcessor;

    if (!fInitialized) 
    {
        SYSTEM_INFO SysInfo;

        GetSystemInfo (&SysInfo);
        if (SysInfo.dwNumberOfProcessors > 1) 
        {
            maskMultiProcessor = 0xFFFFFFFF;
        }
        else 
        {
            maskMultiProcessor = 0;
        }

        fInitialized = TRUE;
    }

    m_ulcSpinCount = ulcSpinCount & maskMultiProcessor;
}


CReadWriteLock::~CReadWriteLock () 
/*++

Routine Description:
    Destructs a exclusive/shared lock object

Arguments:
    None.

Returned Value:
    None.

Algorithm:  
    What's done here is to check to make sure nobody's using
    the object (no readers, writers, or waiters). Once that's
    checked, we just close the handles of the synchronization
    objects we use here....
 
--*/
{
    //
    // Destroying CReadWriteLock object on which folks are still waiting
    //
    ASSERT(MmIsStaticAddress(this) || (m_dwFlag == 0));

    if (m_hReadWaiterSemaphore != NULL) 
    {
        CloseHandle (m_hReadWaiterSemaphore);
    }

    if (m_hWriteWaiterEvent != NULL) 
    {
        CloseHandle (m_hWriteWaiterEvent);
    }
}


/******************************************************************************
Function : CReadWriteLock::LockRead

Abstract: Obtain a shared lock
//  reader count is zero after acquiring read lock
//  writer count is nonzero after acquiring write lock
******************************************************************************/


void CReadWriteLock::LockRead (void) 
/*++

Routine Description:
    Grabs a read (shared) lock on an object

Arguments:
    None.

Returned Value:
    None.

Algorithm:  
    This loops, checking on a series of conditions at each
    iteration:

    - If there's only readers, and room for more, become one by 
    incrementing the reader count
    - It may be that we've hit the max # of readers. If so,
    sleep a bit.
    - Otherwise, there's writers or threads waiting for write
    access. If we can't add any more read waiters, sleep a bit.
    - If we've some spin looping to do, now is the time to do it.
    - We've finished spin looping, and there's room, so we can
    add ourselves as a read waiter. Do it, and then hang
    until the WriteUnlock() releases us all....

    On the way out, make sure there's no writers and at least one
    reader (us!) 

    The effect of this is, if there's only readers using the
    object, we go ahead and grab read access. If anyone is doing
    a write-wait, though, then we go into read-wait, making sure
    one writer will get it before us.

--*/
{
    TrTRACE(Rwl, "Read Lock (this=0x%p)", this);

    ULONG ulcLoopCount = 0;

    for (;;) 
    {
        ULONG dwFlag = m_dwFlag;

        if (dwFlag < READERS_MASK) 
        {
            if (dwFlag == (ULONG) InterlockedCompareExchange(
                                                (LONG*)&m_dwFlag,
                                                (dwFlag + READERS_INCR),
                                                dwFlag)) 
            {
                break;
            }

            continue;
        }

        if ((dwFlag & READERS_MASK) == READERS_MASK) 
        {
            Sleep(1000);
            continue;
        }

        if ((dwFlag & READWAITERS_MASK) == READWAITERS_MASK) 
        {
            Sleep(1000);
            continue;
        }

        if (ulcLoopCount++ < m_ulcSpinCount) 
        {
            continue;
        }

        //
        // Call GetReadWaiterSemaphore before changing state to assure semaphore
        // availability. Otherwise state can not be safely restored.
        //
        HANDLE h = GetReadWaiterSemaphore();

        if (dwFlag == (ULONG) InterlockedCompareExchange(
                                                (LONG*)&m_dwFlag,
                                                (dwFlag + READWAITERS_INCR),
                                                dwFlag)) 
        {
            DWORD rc = WaitForSingleObject(h, INFINITE);

            //
            // WaitForSingleObject must not failed. The number of READWAITERS
            // already incremnt and someone need to decrement it.
            //
            ASSERT(rc == WAIT_OBJECT_0);
            DBG_USED(rc);

            break;
        }
    }

    //
    // Problem with Reader info in CReadWriteLock::LockRead
    //
    ASSERT((m_dwFlag & READERS_MASK) != 0); 

    //
    // Problem with Writer info in CReadWriteLock::LockRead
    //
    ASSERT((m_dwFlag & WRITERS_MASK) == 0);
}


void CReadWriteLock::LockWrite (void) 
/*++

Routine Description:
    Grab a write (exclusive) lock on this object

Arguments:
    None.

Returned Value:
    None.

Algorithm:  
    What we do is loop, each time checking a series of conditions
    until one matches:

    - if nobody's using the object, grab the exclusive lock
    
    - if the maximum # of threads are already waiting for
      exclusive access, sleep a bit
    
    - if we've spin counting to do, count spins
    
    - otherwise, add ourselves as a write waiter, and hang on the
      write wait event (which will let one write waiter pass
      through each time an UnlockRead() lets readers pass)

    Once we've finished, we check to make sure that there are no
    reader and one writer using the object.

    The effect of this is, we grab write access if there's nobody
    using the object. If anyone is using it, we wait for it.

--*/
{
    TrTRACE(Rwl, "Write lock (this=0x%p)", this);

    ULONG ulcLoopCount = 0;

    for (;;) 
    {
        ULONG dwFlag = m_dwFlag;

        if (dwFlag == 0) 
        {
            if (dwFlag == (ULONG) InterlockedCompareExchange(
                                                    (LONG*)&m_dwFlag,
                                                    WRITERS_INCR,
                                                    dwFlag)) 
            {
                break;
            }
        }

        if ((dwFlag & WRITEWAITERS_MASK) == WRITEWAITERS_MASK) 
        {
            Sleep(1000);
            continue;
        }

        if (ulcLoopCount++ < m_ulcSpinCount) 
        {
            continue;
        }

        //
        // Call GetWriteWaiterEvent before changing state to assure event
        // availability. Otherwise state can not be safely restored.
        //
        HANDLE h = GetWriteWaiterEvent();

        if (dwFlag == (ULONG) InterlockedCompareExchange(
                                                (LONG*)&m_dwFlag,
                                                (dwFlag + WRITEWAITERS_INCR),
                                                dwFlag)) 
        {
            DWORD rc = WaitForSingleObject(h, INFINITE);

            //
            // WaitForSingleObject must not failed. The number of READWAITERS
            // already incremnt and someone need to decrement it.
            //
            ASSERT(rc == WAIT_OBJECT_0);
            DBG_USED(rc);

            break;
        }
    }

    //
    // Problem with Reader info in CReadWriteLock::LockWrite
    //
    ASSERT((m_dwFlag & READERS_MASK) == 0);

    //
    // Problem with Writer info in CReadWriteLock::LockWrite
    //
    ASSERT((m_dwFlag & WRITERS_MASK) == WRITERS_INCR);
}


void CReadWriteLock::UnlockRead (void) 
/*++

Routine Description:
    Releases a read (shared) lock on the object

Arguments:
    None.

Returned Value:
    None.

Algorithm:  
    Again, there's a loop checking a variety of conditions....

    - If it's just us reading, with no write-waiters, set the
      flags to 0
  
    - If there are other readers, just decrement the flag
    
    - If it's just me reading, but there are write-waiters,
      then remove me and the write-waiter, add them as a writer,
      and release (one of) them using the event.

    We check to make sure we're in the right state before doing
    this last, relatively complex operation (one reader; at least
    one write waiter). We let the hanging writer check to make
    sure, on the way out, that there's just one writer and no
    readers....

    The effect of all this is, if there's at least one thread
    waiting for a write, all the current readers will drain, and
    then the one writer will get access to the object. Otherwise
    we just let go....

--*/
{
    TrTRACE(Rwl, "Read unlock (this=0x%p)", this);

    //
    // Problem with Reader info in CReadWriteLock::UnlockRead
    //
    ASSERT((m_dwFlag & READERS_MASK) != 0); 

    //
    // Problem with Writer info in CReadWriteLock::UnlockRead
    //
    ASSERT((m_dwFlag & WRITERS_MASK) == 0);

    for (;;) 
    {
        ULONG dwFlag = m_dwFlag;

        if (dwFlag == READERS_INCR) 
        {
            if (dwFlag == (ULONG) InterlockedCompareExchange(
                                                    (LONG*) &m_dwFlag,
                                                    0,
                                                    dwFlag)) 
            {
                break;
            }

            continue;
        }

        if ((dwFlag & READERS_MASK) > READERS_INCR) 
        {
            if (dwFlag == (ULONG) InterlockedCompareExchange(
                                                    (LONG*) &m_dwFlag,
                                                    (dwFlag - READERS_INCR),
                                                    dwFlag)) 
            {
                break;
            }

            continue;
        }

        //
        // Problem with Reader info in CReadWriteLock::UnlockRead
        //
        ASSERT((dwFlag & READERS_MASK) == READERS_INCR);

        //
        // Problem with WriteWatier info in CReadWriteLock::UnlockRead
        //
        ASSERT((dwFlag & WRITEWAITERS_MASK) != 0);

        if (dwFlag == (ULONG) InterlockedCompareExchange (
                                                (LONG*) &m_dwFlag,
                                                (dwFlag -
                                                    READERS_INCR -
                                                    WRITEWAITERS_INCR +
                                                    WRITERS_INCR), 
                                                dwFlag)) 
        {
            //
            // The semaphore is guaranteed to be available here as there is
            // a write waiter that already signaled the event.
            //
            BOOL f = SetEvent(
                        GetWriteWaiterEvent()
                        );
            ASSERT(f);
            DBG_USED(f);

            break;
        }
    }
}


void CReadWriteLock::UnlockWrite (void) 
/*++

Routine Description:
    Lets go of exclusive (write) access

Arguments:
    None.

Returned Value:
    None.

Algorithm:  
    We're in a loop, waiting for one or another thing to happen

    - If it's just us writing, and nothing else is going on, we
      let go and scram.

    - If threads are waiting for read access, we fiddle with the
      dwFlag to release them all (by decrementing the writer
      count and read-waiter count, and incrementing the reader
      count, and then incrementing the semaphore enough so that
      all those read-waiters will be released). 

    - If there are only threads waiting for write access, let one
      of them through.... Don't have to fiddle with the write
      count, 'cause there will still be one.

    The upshot of all this is, we make sure that the next threads
    to get access after we let go will be readers, if there are
    any. The whole scene makes it go from one writer to many
    readers, back to one writer and then to many readers again.
    Sharing. Isn't that nice.

 
--*/
{
    TrTRACE(Rwl, "Write unlock (this=0x%p)", this);

    //
    // Problem with Reader info in CReadWriteLock::LockWrite
    //
    ASSERT((m_dwFlag & READERS_MASK) == 0);

    //
    // Problem with Writer info in CReadWriteLock::LockWrite
    //
    ASSERT((m_dwFlag & WRITERS_MASK) == WRITERS_INCR);

    for (;;) 
    {
        ULONG dwFlag = m_dwFlag;

        if (dwFlag == WRITERS_INCR) 
        {
            if (dwFlag == (ULONG) InterlockedCompareExchange(
                                                    (LONG*)&m_dwFlag,
                                                    0,
                                                    dwFlag)) 
            {
                break;
            }

            continue;
        }

        if ((dwFlag & READWAITERS_MASK) != 0) 
        {
            ULONG count = (dwFlag & READWAITERS_MASK) / READWAITERS_INCR;

            if (dwFlag == (ULONG) InterlockedCompareExchange(
                                                    (LONG*) &m_dwFlag,
                                                    (dwFlag - 
                                                        WRITERS_INCR - 
                                                        count * READWAITERS_INCR + 
                                                        count * READERS_INCR), 
                                                    dwFlag)) 
            {
                //
                // The semaphore is guaranteed to be available here as there are
                // read waiters that already signaled the semaphore.
                //
                BOOL f = ReleaseSemaphore (
                            GetReadWaiterSemaphore(),
                            count,
                            NULL
                            );
                ASSERT(f);
                DBG_USED(f);

                break;
            }

            continue;
        }

        //
        // Check for problem with WriteWatier info in CReadWriteLock::UnlockWrite
        //
        ASSERT((dwFlag & WRITEWAITERS_MASK) != 0);

        if (dwFlag == (ULONG) InterlockedCompareExchange ( 
                                                (LONG*) &m_dwFlag,
                                                (dwFlag - WRITEWAITERS_INCR),
                                                dwFlag)) 
        {
            //
            // The semaphore is guaranteed to be available here as there is
            // a write waiter that already signaled the event.
            //
            BOOL f = SetEvent(
                        GetWriteWaiterEvent()
                        );
            ASSERT(f);
            DBG_USED(f);

            break;
        }
    }
}


HANDLE CReadWriteLock::GetReadWaiterSemaphore(void) 
/*++

Routine Description:
    Private member function to get the read-waiting semaphore,
    creating it if necessary

Arguments:
    None.

Returned Value:
    semaphore handle (never NULL).

Algorithm:  
    This is a thread-safe, virtually lockless routine that
    creates a semaphore if there's not one there, safely tries to
    shove it into the shared member variable, and cleans up if
    someone snuck in there with a second semaphore from another
    thread. 
--*/
{
    if (m_hReadWaiterSemaphore == NULL) 
    {
        HANDLE h = CreateSemaphore (NULL, 0, MAXLONG, NULL);
        if (h == NULL) 
        {
            TrERROR(Rwl, "Failed to create semaphore. Error=%d", GetLastError());
            throw bad_alloc();
        }

        if (NULL != InterlockedCompareExchangePointer ((PVOID*) &m_hReadWaiterSemaphore, h, NULL)) 
        {
            CloseHandle (h);
        }
    }

    return m_hReadWaiterSemaphore;
}


HANDLE CReadWriteLock::GetWriteWaiterEvent(void) 
/*++

Routine Description:
    private member function to get the write-waiting barrier, 
    creating it if necessary

Arguments:
    None.

Returned Value:
    event handle (never NULL).

Algorithm:  
    This is a thread-safe, virtually lockless routine that
    creates an event if there's not one there, safely tries to
    shove it into the shared member variable, and cleans up if
    someone snuck in there with a second event from another
    thread.

--*/
{
    if (m_hWriteWaiterEvent == NULL) 
    {
        HANDLE h = CreateEvent (NULL, FALSE, FALSE, NULL);
        if (h == NULL) 
        {
            TrERROR(Rwl, "Failed to create event. Error=%d", GetLastError());
            throw bad_alloc();
        }
    
        if (NULL != InterlockedCompareExchangePointer((PVOID*) &m_hWriteWaiterEvent, h, NULL)) 
        {
            CloseHandle (h);
        }
    }

    return m_hWriteWaiterEvent;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\ex\test\asyncexecutionrequest.h ===
/*
Module Name:
    AsyncExecutionRequest.h

Abstract:
    Header file for class CTestAsyncExecutionRequest simulates async request
	for testing CReadWriteLockAsyncExcutor class.

Author:	 
    Gil Shafriri (gilsh), 2-July-2001

--*/

#pragma once

#ifndef _MSMQ_AsyncExecutionRequest_H_
#define _MSMQ_AsyncExecutionRequest_H_

#include <ex.h>
#include <rwlockexe.h>

class CAsyncCaller;

class CTestAsyncExecutionRequest : public  IAsyncExecutionRequest, public EXOVERLAPPED, public CReference
{

public:
	CTestAsyncExecutionRequest(CAsyncCaller& AsyncCaller);
	virtual void Run();
	virtual void Close();
	static void WINAPI OnOk(EXOVERLAPPED* povl);
	static void WINAPI OnFailed(EXOVERLAPPED* povl);

private:
	CAsyncCaller& m_AsyncCaller;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\ex\test\casynccaller.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    CAsyncCaller.cpp

Abstract:
    Implementation of class CAsyncCaller.cpp (CAsyncCaller.h).


Owner:
    Gil Shafriri(gilsh) 2-July-2001


Environment:
    Platform-independent,

--*/


#include <libpch.h>
#include "CAsyncCaller.h"
#include "AsyncExecutionRequest.h"



void CAsyncCaller::OnOk(CTestAsyncExecutionRequest* TestAsyncExecutionRequest)
{
	printf("CAsyncCaller::OnOk called  \n");
	CleanUp(TestAsyncExecutionRequest);
}


void CAsyncCaller::OnFailed(CTestAsyncExecutionRequest* TestAsyncExecutionRequest)
{
	printf("CAsyncCaller::OnFailed called  \n");
	CleanUp(TestAsyncExecutionRequest);	
}


void CAsyncCaller::CleanUp(CTestAsyncExecutionRequest* TestAsyncExecutionRequest)
{
	if(m_locktype == Read)
	{
		printf("unlock read  \n");
		m_ReadWriteLockAsyncExcutor.UnlockRead();
	}
	else
	{
		printf("unlock write  \n");
		m_ReadWriteLockAsyncExcutor.UnlockWrite();		
	}
	TestAsyncExecutionRequest->Release();	
}



void CAsyncCaller::Run(IAsyncExecutionRequest* AsyncExecutionRequest)
{
	if(m_locktype == Read)
	{
		printf("CAsyncCaller::Run under read lock  \n");
		m_ReadWriteLockAsyncExcutor.AsyncExecuteUnderReadLock(AsyncExecutionRequest);
		return;
	}

	printf("CAsyncCaller::Run under write lock  \n");
	m_ReadWriteLockAsyncExcutor.AsyncExecuteUnderWriteLock(AsyncExecutionRequest);
}


CAsyncCaller::CAsyncCaller(
					CReadWriteLockAsyncExcutor& ReadWriteLockAsyncExcutor,
					LockType locktype
					):
					m_ReadWriteLockAsyncExcutor(ReadWriteLockAsyncExcutor),
					m_locktype(locktype)
{
			
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\ex\test\asyncexecutionrequest.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    AsyncExecutionRequest.cpp

Abstract:
    Implementation of class CReadWriteLockAsyncExcutor (AsyncExecutionRequest.h).


Owner:
    Gil Shafriri(gilsh) 2-July-2001


Environment:
    Platform-independent,

--*/


#include <libpch.h>
#include "AsyncExecutionRequest.h"
#include "CAsyncCaller.h"


CTestAsyncExecutionRequest::CTestAsyncExecutionRequest(
					CAsyncCaller& AsyncCaller
					):
					EXOVERLAPPED(OnOk, OnFailed),
					m_AsyncCaller(AsyncCaller)
					{
					}	

void CTestAsyncExecutionRequest::Run()
{
	printf("CTestAsyncExecutionRequest run function called \n"); 
	if(rand() % 2 == 0)
		throw exception();

	ExPostRequest(this);
}



void	CTestAsyncExecutionRequest::Close()throw()
{
	printf("CTestAsyncExecutionRequest close function called \n");
	SetStatus(STATUS_UNSUCCESSFUL);
	ExPostRequest(this);
}



void WINAPI  CTestAsyncExecutionRequest::OnOk(EXOVERLAPPED* povl)
{
	printf("CTestAsyncExecutionRequest run function completed ok ovl=%x \n", povl); 
	CTestAsyncExecutionRequest* Me = static_cast<CTestAsyncExecutionRequest*>(povl); 
	Me->m_AsyncCaller.OnOk(Me);
}



void WINAPI CTestAsyncExecutionRequest::OnFailed(EXOVERLAPPED* povl)
{
	printf("CTestAsyncExecutionRequest run failed  ovl=%x \n", povl); 
	CTestAsyncExecutionRequest* Me = static_cast<CTestAsyncExecutionRequest*>(povl); 
	Me->m_AsyncCaller.OnFailed(Me);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\ex\test\casynccaller.h ===
/*
Module Name:
    CAsyncCaller.h

Abstract:
    Header file for class CAsyncCaller responsible for queueing async 
	requests under read or write lock using the class CAsyncLockExcutor.
	

Author:	 
    Gil Shafriri (gilsh), 2-July-2001

--*/

#pragma once

#ifndef _MSMQ_CAsyncCaller_H_
#define _MSMQ_CAsyncCaller_H_

class CReadWriteLockAsyncExcutor;
class IAsyncExecutionRequest;
class CTestAsyncExecutionRequest;

class CAsyncCaller
{
public:
	enum LockType{Read,Write};	

public:
	CAsyncCaller(CReadWriteLockAsyncExcutor& AsyncLockExcutor, LockType locktype);
	void OnOk(CTestAsyncExecutionRequest* TestAsyncExecutionRequest);
	void OnFailed(CTestAsyncExecutionRequest* TestAsyncExecutionRequest);
	void Run(IAsyncExecutionRequest* AsyncExecutionRequest);
	void CleanUp(CTestAsyncExecutionRequest* TestAsyncExecutionRequest);


private:
	CReadWriteLockAsyncExcutor& m_ReadWriteLockAsyncExcutor;
	LockType m_locktype;
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\ex\lib\scheduler.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:
    scheduler.cpp

Abstract:
    Scheduler Implementation
    The Scheduler enables to schedule a callback when timer occurs.

    The Scheduler maintains a linked list of all the events to be scheduled,
    ordered by the time of their schedule (in ticks).

    The Scheduler object does not assure that the timer events callbacks will be
    called exactly when scheduled. Only never before their schedule.

Author:
    Uri Habusha (urih)   18-Feb-98

Enviroment:
    Pltform-independent

--*/

#include <libpch.h>
#include "Ex.h"
#include "Exp.h"
#include <list.h>

#include "scheduler.tmh"

//---------------------------------------------------------
//
// CTimer Implementation
//
//---------------------------------------------------------
inline const CTimeInstant& CTimer::GetExpirationTime() const
{
    return m_ExpirationTime;
}

inline void CTimer::SetExpirationTime(const CTimeInstant& ExpirationTime)
{
    m_ExpirationTime = ExpirationTime;
}


//---------------------------------------------------------
//
// CScheduler
//
//---------------------------------------------------------
class CScheduler {
public:
    CScheduler();
    ~CScheduler();

    void SetTimer(CTimer* pTimer, const CTimeInstant& expirationTime);
    BOOL RenewTimer(CTimer* pTimer, const CTimeInstant& expirationTime);
    bool CancelTimer(CTimer* pTimer);

private:
    CTimeInstant Wakeup(const CTimeInstant& CurrentTime);

private:
    static DWORD WINAPI SchedulerThread(LPVOID);

private:
    mutable CCriticalSection m_cs;

    HANDLE m_hNewTimerEvent;
    List<CTimer> m_Timers;
    CTimeInstant m_WakeupTime;
};


CScheduler::CScheduler() :
    m_WakeupTime(CTimeInstant::MaxValue())
{
    //
    // m_hNewTimerEvent - use to indicate insert of new object to the schedule.
    // The object is inserted to head of the Scheduler such it must handle immediately
    //
    m_hNewTimerEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (m_hNewTimerEvent == NULL)
    {
        TrERROR(Sc, "Failed to create an event. Error=%d", GetLastError());
        throw bad_alloc();
    }

    //
    // Create a scheduling thread. This thread is responsible to handle scheduling
    // expiration
    //
    DWORD tid;
    HANDLE hThread;
    hThread = CreateThread(
                        NULL,
                        0,
                        SchedulerThread,
                        this,
                        0,
                        &tid
                        );
    if (hThread == NULL)
    {
        TrERROR(Sc, "Failed to create a thread. Error=%d", GetLastError());
        throw(bad_alloc());
    }

    CloseHandle(hThread);
}


CScheduler::~CScheduler()
{
    CloseHandle(m_hNewTimerEvent);
}


inline CTimeInstant CScheduler::Wakeup(const CTimeInstant& CurrentTime)
/*++

Routine description:
  It dispatches all timers that expired before CurrentTime. Their associated
  callback routine is invoked.

Arguments:
  None

Return Value:
  Next expiration time in 100ns (FILETIME format).

 --*/
{
    CS lock(m_cs);

    for(;;)
    {
        if(m_Timers.empty())
        {
            //
            // No more timers, wait for the longest time.
            //
            m_WakeupTime = CTimeInstant::MaxValue();
            return m_WakeupTime;
        }

        CTimer* pTimer = &m_Timers.front();

        //
        // Is that time expired?
        //
        if (pTimer->GetExpirationTime() > CurrentTime)
        {
            //
            // No, wait for that one to expire.
            //
            m_WakeupTime = pTimer->GetExpirationTime();
            return m_WakeupTime;
        }

        TrTRACE(Sc, "Timer 0x%p expired %dms ticks late", pTimer, (CurrentTime - pTimer->GetExpirationTime()).InMilliSeconds());

        //
        // Remove the expired timer from the list
        //
        m_Timers.pop_front();

        //
        // Set the Timer pointer to NULL. This is an indication that the
        // Timer isn't in the list any more. In case of timer cancel
        // the routine checks if the entry is in the list (check Flink)
        // before trying to remove it
        //
        pTimer->m_link.Flink = pTimer->m_link.Blink = NULL;

        //
        // Invoke the timer callback routine using the completion port thread pool
        //
        try
        {
            ExPostRequest(&pTimer->m_ov);
        }
        catch(const exception&)
        {
            TrERROR(Sc, "Failed to post a timer to the completion port. Error=%d", GetLastError());

            //
            // Scheduling of even failed (generally becuase lack of resources).
            // returns the event, and try to handle it 1 second later
            //
            m_Timers.push_front(*pTimer);

            m_WakeupTime = CurrentTime + CTimeDuration::OneSecond();
            return m_WakeupTime;
        }
    }
}


//
// ISSUE-2000/7/24-erezh bad compiler pragma
// This is a bug in the compiler, waiting for a fix
//
#pragma warning(disable: 4716)

DWORD
WINAPI CScheduler::SchedulerThread(
    LPVOID pParam
    )
/*++

Routine Description:
  Wakeup the timer when a timeout occures by calling Wakeup. A timer insertion
  would cause the waiting thread to go and re-arm for the next wakeup time.

Arguments:
  None

Return Value:
  None

Note:
  This routine never terminates.

 --*/
{
    CScheduler* pScheduler = static_cast<CScheduler*>(pParam);

    DWORD Timeout = _I32_MAX;

    for(;;)
    {
        TrTRACE(Sc, "Thread sleeping for %dms", Timeout);

        DWORD Result = WaitForSingleObject(pScheduler->m_hNewTimerEvent, Timeout);
		DBG_USED(Result);

        //
        // WAIT_OBJECT_0 Indicates that a new timer was set
        // WAIT_TIMEOUT  Indicates that a timer expired
        //
        ASSERT((Result == WAIT_OBJECT_0) || (Result == WAIT_TIMEOUT));

        CTimeInstant CurrentTime = ExGetCurrentTime();

        //
        // Fire all expired timers.
        //
        CTimeInstant ExpirationTime = pScheduler->Wakeup(CurrentTime);

        //
        // Adjust wakeup time to implementation using relative time, DWORD and milliseconds.
        //
        LONG WakeupTime = (ExpirationTime - CurrentTime).InMilliSeconds();
        ASSERT(WakeupTime >= 0);

        Timeout = WakeupTime;
    }
}

//
// ISSUE-2000/7/24-erezh bad compiler pragma
// This is a bug in the compiler, waiting for a fix
//
#pragma warning(default: 4716)


BOOL CScheduler::RenewTimer(CTimer* pTimer, const CTimeInstant& ExpirationTime)
{
    CS lock(m_cs);

	//
	// Check if the timer is in the list. If not, insert it.
	//
	if (!pTimer->InUse())
	{
		SetTimer( pTimer, ExpirationTime ) ;
        return TRUE ;
	}

    return FALSE ;
}

void CScheduler::SetTimer(CTimer* pTimer, const CTimeInstant& ExpirationTime)
{
    //
    // Insert the new entry to the Scheduler list. The routine
    // scans the list and look for the first iteam that its timeout
    // is later than the new one. The routine Insert the new iteam before
    // the previous one
    //
    CS lock(m_cs);

    //
    // The timer is already in the Scheduler
    //
    ASSERT(!pTimer->InUse());

    //
    // Set the Experation time.
    //
    pTimer->SetExpirationTime(ExpirationTime);

    List<CTimer>::iterator p = m_Timers.begin();

    while(p != m_Timers.end())
    {
        if(p->GetExpirationTime() > ExpirationTime)
        {
            break;
        }
        ++p;
    }

    m_Timers.insert(p, *pTimer);

    //
    // Check if the new element is to reschedule next wakeup.
    //
    if (m_WakeupTime > ExpirationTime)
    {
        //
        // The new timer Wakeup time is earlier than the current. Set the thread
        // event so SchedulerThread will update its Wait timeout.
        // Set m_WakeupTime to CurrentTime so new incomming events will not bother
        // to wake the scheduler thread again, until it processes the timers.
        //
        // Setting m_WakeupTime to 0 is also Okay.  erezh 28-Nov-98
        //
        TrTRACE(Sc, "Re-arming thread with Timer 0x%p. delta=%I64d", pTimer, (m_WakeupTime - ExpirationTime).Ticks());
        m_WakeupTime = CTimeInstant::MinValue();
        SetEvent(m_hNewTimerEvent);
    }
}


bool CScheduler::CancelTimer(CTimer* pTimer)
{
    //
    // Get the critical section at this point. Otherwise; time experation can't
    // occoured and to remove the timer from the scheduler. Than we try to remove it
    // and fails
    //
    CS lock(m_cs);

	//
	// Check if the timer is in the list. If no it already
	// removed from the list due timeout experation
	// or duplicate cancel operation
	//
	if (!pTimer->InUse())
	{
		return false;
	}

	//
	// The Timer in the list. Remove it and return TRUE
	// to the caller.
	//
	TrTRACE(Sc, "Removing timer 0x%p", pTimer);
	m_Timers.remove(*pTimer);

    //
    // Set the Timer pointer to NULL. This is an indication that the
    // Timer isn't in the list any more. In case of duplicate cancel
    // the routine checks if the entry is in the list (check Flink)
    // before trying to remove it
    //
    pTimer->m_link.Flink = pTimer->m_link.Blink = NULL;

    //PrintSchedulerList();

	return true;
}


static CScheduler*  s_pScheduler = NULL;


VOID
ExpInitScheduler(
    VOID
    )
{
    ASSERT(s_pScheduler == NULL);

    s_pScheduler = new CScheduler;
}


VOID
ExSetTimer(
    CTimer* pTimer,
    const CTimeDuration& Timeout
    )
{
    ExpAssertValid();
    ASSERT(s_pScheduler != NULL);

    TrTRACE(Sc, "Adding Timer 0x%p. timeout=%dms", pTimer, Timeout.InMilliSeconds());

    //
    // Calculate the Experation time in 100 ns
    //
    CTimeInstant ExpirationTime = ExGetCurrentTime() + Timeout;

    s_pScheduler->SetTimer(pTimer, ExpirationTime);
}


VOID
ExSetTimer(
    CTimer* pTimer,
    const CTimeInstant& ExpirationTime
    )
{
    ExpAssertValid();
    ASSERT(s_pScheduler != NULL);

    TrTRACE(Sc, "Adding Timer 0x%p. Expiration time %I64d", pTimer, ExpirationTime.Ticks());

    s_pScheduler->SetTimer(pTimer, ExpirationTime);
}


BOOL
ExRenewTimer(
    CTimer* pTimer,
    const CTimeDuration& Timeout
    )
{
    ExpAssertValid();
    ASSERT(s_pScheduler != NULL);

    TrTRACE(Sc, "Renew Timer 0x%p. timeout=%dms", pTimer, Timeout.InMilliSeconds());

    //
    // Calculate the Experation time in 100 ns
    //
    CTimeInstant ExpirationTime = ExGetCurrentTime() + Timeout;

    BOOL f = s_pScheduler->RenewTimer(pTimer, ExpirationTime);
    return f ;
}


BOOL
ExCancelTimer(
    CTimer* pTimer
    )
{
    ExpAssertValid();
    ASSERT(s_pScheduler != NULL);
    return s_pScheduler->CancelTimer(pTimer);
}


CTimeInstant
ExGetCurrentTime(
    VOID
    )
{
    //
    // Don't need to check if initalized. No use of global date
    //
    //ExpAssertValid();

    ULONGLONG CurrentTime;
    GetSystemTimeAsFileTime(reinterpret_cast<FILETIME*>(&CurrentTime));

    return CTimeInstant(CurrentTime);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\ex\lib\rwlockexe.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    rwlockexe.cpp

Abstract:
    Implementation of class CReadWriteLockAsyncExcutor (rwlockexe.h).


Owner:
    Gil Shafriri(gilsh) 26-June-2001


Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include <rwlockexe.h>

#include "rwlockexe.tmh"


///////////////////////////////////////////////////////////////
////////////////////////PUBLIC member functions ///////////////
///////////////////////////////////////////////////////////////

CReadWriteLockAsyncExcutor::CReadWriteLockAsyncExcutor(
													void
													):
													m_NumOfActiveReaders(0),
													m_NumOfActiveWritters(0),
													m_fClosed(false)
													{
													}

														


CReadWriteLockAsyncExcutor::~CReadWriteLockAsyncExcutor()
{
	ASSERT(m_WatingForExecutionQueue.empty());
	if(IsClosed())
		return;

	ASSERT(!IsReadLockOn());
	ASSERT(!IsWriteLockOn());
}


void CReadWriteLockAsyncExcutor::AsyncExecuteUnderReadLock(IAsyncExecutionRequest* pAsyncExecuteRequest)
/*++

Routine Description:
    Execute async request under read lock

Arguments:
    pAsyncExecute - async request.
	pov - Request overlapp 

Returned Value:
    None

Note:
	If the is active writer - the request is queued.
	It is the responsibilty of the caller to call UnlockRead() if the call did 
	threw  exception.
--*/ 
{
	CS cs(m_Lock);
	if(IsClosed())
	{
		pAsyncExecuteRequest->Close();
		return;
	}
	
	if(IsWriteLockOn())
	{
		m_WatingForExecutionQueue.push(CExecutionContext(pAsyncExecuteRequest,  Read));
		return;
	}
	ExecuteReader(pAsyncExecuteRequest);
}


void CReadWriteLockAsyncExcutor::AsyncExecuteUnderWriteLock(IAsyncExecutionRequest* pAsyncExecuteRequest)
/*++

Routine Description:
    Execute async request under write lock.

Arguments:
    pAsyncExecute - async request.
	pov - Request overlapp 

Returned Value:
    Note:
	If the is active writer or reader  - the request is queued.
	It is the responsibilty of the caller to call UnlockWrite() if the call did 
	threw  exception.

--*/
{
	CS cs(m_Lock);
	if(IsClosed())
	{
		pAsyncExecuteRequest->Close();
		return;
	}

	if(IsWriteLockOn() || IsReadLockOn())
	{
		m_WatingForExecutionQueue.push(CExecutionContext(pAsyncExecuteRequest, Write));
		return;
	}
	ExecuteWriter(pAsyncExecuteRequest);
}


void CReadWriteLockAsyncExcutor::UnlockRead(void)
/*++

Routine Description:
    Unlock read lock accuired by the call to AsyncExecuteUnderReadLock().
	

Arguments:
   

Returned Value:
   None.

Note:
	Must  be called  only after the request queued by AsyncExecuteUnderReadLock() completed.
	If this is the last reader it goes to execute wating requests.

--*/
{
	CS cs(m_Lock);

	if(IsClosed())
		return;

		
	ASSERT(IsReadLockOn());
	ASSERT(!IsWriteLockOn());

	--m_NumOfActiveReaders;
	if(!IsReadLockOn())
	{
		ExecuteWatingRequeuets();				
	}
}


void CReadWriteLockAsyncExcutor::UnlockWrite(void)
/*++

Routine Description:
    Unlock write lock accuired by the call to AsyncExecuteUnderReadLock() and execute wating requests.

Arguments:
   

Returned Value:
   None.

Note:
	Must  be called  only after the request queued by AsyncExecuteUnderWriteLock() completed.

--*/
{

	CS cs(m_Lock);

	if(IsClosed())
		return;

	ASSERT(IsWriteLockOn());
	ASSERT(!IsReadLockOn());
	--m_NumOfActiveWritters;
	ASSERT(!IsWriteLockOn());
	
	ExecuteWatingRequeuets();		
}


void CReadWriteLockAsyncExcutor::Close()
/*++

Routine Description:
    Cancell all waiting requests

Arguments:
    None.

Returned Value:
    None

Note:

	This function is called to force completion  of all wating requests.
	The function will force callback for all requests that has not yet executed by
	calling Close method on the IAsyncExecutionRequest interface. 
    
--*/
{
	CS cs(m_Lock);

	while(!m_WatingForExecutionQueue.empty())
	{
		const CExecutionContext ExecutionContext = m_WatingForExecutionQueue.front();		
		m_WatingForExecutionQueue.pop();
		ExecutionContext.m_AsyncExecution->Close();				
	}
	m_fClosed = true;
}


///////////////////////////////////////////////////////////////
//////////////////////// private member functions /////////////
///////////////////////////////////////////////////////////////


void CReadWriteLockAsyncExcutor::ExecuteReader(IAsyncExecutionRequest* pAsyncExecute)
/*++

Routine Description:
    Lock for read and excute request.

Arguments:
    pAsyncExecute - async request.
	

Returned Value:
    None

Note:
    
--*/
{
	ASSERT(!IsWriteLockOn());
	++m_NumOfActiveReaders;
	SafeExecute(pAsyncExecute);
}



void CReadWriteLockAsyncExcutor::ExecuteWriter(IAsyncExecutionRequest* pAsyncExecute)
/*++

Routine Description:
    Lock for WRITE and excute request.

Arguments:
    pAsyncExecute - async request.
	

Returned Value:
    None

Note:
--*/
{
	ASSERT(!IsReadLockOn());
	ASSERT(!IsWriteLockOn());
	++m_NumOfActiveWritters;
	SafeExecute(pAsyncExecute);
}


bool CReadWriteLockAsyncExcutor::IsWriteLockOn() const
{
	ASSERT(m_NumOfActiveWritters <= 1);
	return m_NumOfActiveWritters == 1;
}


bool CReadWriteLockAsyncExcutor::IsReadLockOn() const
{
	return m_NumOfActiveReaders > 0;
}


void CReadWriteLockAsyncExcutor::ExecuteWatingRequeuets()
/*++

Routine Description:
    Execurte wating request. 

Arguments:
   

Returned Value:
    None

Note:
	The function execute read requests from the wating queue untill it encounter  a write request.
	If there is no wating read request  - it execute one wating write request  (if exist)

--*/
{
	ASSERT(!IsWriteLockOn());
	ASSERT(!IsReadLockOn());

	while(!m_WatingForExecutionQueue.empty())
	{
		ASSERT(!IsClosed());

		//
		// If the request is reader request - execute it and continute the loop
		// to execute more readers
		//
		const CExecutionContext ExecutionContext = m_WatingForExecutionQueue.front();	
		if(ExecutionContext.m_locktype == Read)
		{
			m_WatingForExecutionQueue.pop();
			ExecuteReader(ExecutionContext.m_AsyncExecution);		
			continue;
		}
		
		//
		// If the request is writer request check there is no read lock -
		// execute it and exit the loop
		//
		if(!IsReadLockOn())
		{
			m_WatingForExecutionQueue.pop();
			ExecuteWriter(ExecutionContext.m_AsyncExecution);				
		}
		
		return;
	}
}



void CReadWriteLockAsyncExcutor::SafeExecute(IAsyncExecutionRequest* pAsyncExecute)throw()
{
	try
	{
		pAsyncExecute->Run();
	}
	catch(const exception&)
	{
		pAsyncExecute->Close();
	}
}




bool CReadWriteLockAsyncExcutor::IsClosed() const
{
	return m_fClosed == true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\ex\test\extest.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:
    ExTest.cpp

Abstract:
    Test the Executive manager.

Author:
    Uri Habusha (urih)  25-Feb-98

--*/

#include <libpch.h>
#include <Ex.h>
#include "AsyncExecutionRequest.h"
#include "CAsyncCaller.h"

#include "ExTest.tmh"

class CExTest;

const TraceIdEntry ExTest = L"TEST";
const TraceIdEntry xExTestComponent[] = {ExTest};

const DWORD MAX_TIMER = 3*64;

static CCriticalSection s_cs;

DWORD TimerNo = 0;
CExTest* TimerArray[MAX_TIMER];

DWORD NoOfCallBack = 0;
DWORD NoOfOKTimeout = 0;


class CExTest {
public:
    CExTest(
        CTimer::CALLBACK_ROUTINE pfnTimerCallbackRoutine,
        DWORD Timeout
        );

    ~CExTest();

    CTimer  m_Timer;
    HANDLE m_hEvent;
    DWORD m_ExperationTime;
    DWORD m_Index;
};

CExTest::CExTest(
    CTimer::CALLBACK_ROUTINE pfnTimerCallbackRoutine,
    DWORD Timeout
    ) :
    m_Timer(pfnTimerCallbackRoutine),
    m_ExperationTime(GetTickCount() + Timeout)
{
    m_hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (m_hEvent == NULL)
    {
        TrERROR(ExTest, "Failed to create event. error=%d", GetLastError());
        exit(-1);
    }
    
    {
        CS lock(s_cs);
        m_Index = TimerNo;
        TimerArray[TimerNo] = this;
        ++TimerNo;
    }
}

CExTest::~CExTest()
{
    Sleep(50);
    CS lock(s_cs);

    SetEvent(m_hEvent);
    TimerArray[m_Index] = NULL;
}

void
WINAPI
ScedulerCallBack(
    CTimer* pTimer
    )
{
    CExTest* p = CONTAINING_RECORD(pTimer, CExTest, m_Timer);

    ++NoOfCallBack;
    DWORD delay = (GetTickCount()-p->m_ExperationTime);
    if (20 >= delay)
    {
        ++NoOfOKTimeout;
    }

    TrTRACE(ExTest, "Timer 0x%p called-back %dms late", pTimer, GetTickCount() - p->m_ExperationTime);

    SetEvent(p->m_hEvent);
    delete p;
}


void
WINAPI
CancelScedulerCallBack(
    CTimer* pTimer
    )
{
    CExTest* p = CONTAINING_RECORD(pTimer, CExTest, m_Timer);

    TrTRACE(ExTest, "Timer 0x%p called-back %dms late", pTimer, GetTickCount() - p->m_ExperationTime);

    SetEvent(p->m_hEvent);
    if (ExCancelTimer(pTimer))
    {
        TrERROR(ExTest, "Succeeded to cancel expired Timer 0x%p", p);
        exit(-1);
    }
    delete p;
}

DWORD 
WINAPI 
TestScheduler(
    LPVOID
    )
{
    srand(1234);
    HANDLE EventArray[64];

    for(int i = 0; i < 64; ++i)
    {
        DWORD WaitTime= rand() % (10000);
        CExTest* p = new CExTest(ScedulerCallBack, WaitTime); 
        EventArray[i] = p->m_hEvent;

        TrTRACE(ExTest, "Set timer 0x%p with %dms timeout", p, WaitTime);
        ExSetTimer(&p->m_Timer, CTimeDuration(WaitTime * CTimeDuration::OneMilliSecond().Ticks()));
    }


    for(;;)
    {
        DWORD SleepTime = rand() % 100;
        DWORD rc = WaitForMultipleObjects(
                        64,
                        EventArray,
                        TRUE,
                        SleepTime
                        );

        if (rc == WAIT_FAILED)
        {
            TrERROR(ExTest, "Failed while waiting for a timer. Error=%d", GetLastError());
            ASSERT(0);
            continue;
        }


        if (rc == WAIT_TIMEOUT)
        {
            DWORD RandIndex = rand() % TimerNo;
            CS lock(s_cs);

            for(;; RandIndex++)
            {
                if (RandIndex == TimerNo)
                {
                    break;
                }
                
                if (TimerArray[RandIndex] != NULL)
                {
                    TrTRACE(ExTest, "Cancle timer 0x%p", TimerArray[RandIndex]);
                    BOOL fSucc = ExCancelTimer(&TimerArray[RandIndex]->m_Timer);
                    if (fSucc)
                    {
                        delete TimerArray[RandIndex];
                    }
                    else
                    {
                        TrTRACE(ExTest, "Failed to cancel timer 0x%p", TimerArray[RandIndex]);
                    }
                    break;
                }
            }
        }
        else
        {
            break;
        }
    }

    return 0;
}

void 
SchedulerUnitTest(
    VOID
    )
{

    srand(1234);
    HANDLE EventArray[64];
    DWORD rc;

    TimerNo = 0;

    //
    // Create a timer and cancel it before timeout expiration
    //
    CExTest* p1 = new CExTest(ScedulerCallBack, 50);
    
    TrTRACE(ExTest, "Set Timer 0x%p with 50ms timeout", p1);
    ExSetTimer(&(p1->m_Timer), CTimeDuration(50 * CTimeDuration::OneMilliSecond().Ticks()));
    if(!ExCancelTimer(&(p1->m_Timer)))
    {
        TrERROR(ExTest, "Failed to cancel timer 0x%p", p1);
        exit(-1);
    }
    TrTRACE(ExTest, "Timer 0x%p canceled", p1);

    rc = WaitForSingleObject(p1->m_hEvent, 150);
    if (rc != WAIT_TIMEOUT)
    {
        TrTRACE(ExTest, "Timer 0x%p called-back after cancel", p1);
        exit(-1);
    }
    CloseHandle(p1->m_hEvent);
	delete p1;


    //
    // Create a timer and check that the callback routine is called
    //
    CExTest*  p = new CExTest(ScedulerCallBack, 50);
    
    TrTRACE(ExTest, "Set Timer 0x%p with 50ms timeout", p);

    ExSetTimer(&(p->m_Timer), CTimeDuration(50 * CTimeDuration::OneMilliSecond().Ticks()));

    rc = WaitForSingleObject(p->m_hEvent, 1000);
    if (rc != WAIT_OBJECT_0)
    {
		CloseHandle(p->m_hEvent);

        TrTRACE(ExTest, "Scheduler failed to expire timer 0x%p after 50ms", p);
        exit(-1);
    }

    //
    // Create 10 scheduler event and checks that they complete in order
    //
    TimerNo = 0;
    for(DWORD i = 0; i < 10; ++i)
    {
        DWORD WaitTime= 100*i +50;
        CExTest* p = new CExTest(ScedulerCallBack, WaitTime); 
        EventArray[i] = p->m_hEvent;

        TrTRACE(ExTest, "Set Timer 0x%p with %dms timeout", p, WaitTime);
        ExSetTimer(&(p->m_Timer), CTimeDuration(WaitTime * CTimeDuration::OneMilliSecond().Ticks()));
    }

    for (i=0; i < 10; i++)
    {
        DWORD rc = WaitForMultipleObjects(
                        10-i,
                        &EventArray[i],
                        FALSE,
                        300
                        );
        if (rc != WAIT_OBJECT_0)
        {
            TrTRACE(ExTest, "Timer 0x%p failed to call-back after %dms", TimerArray[i], 50+i*10);
            exit(-1);
        }
        ResetEvent(EventArray[i]);
        TrTRACE(ExTest, "rc=%d, i=%d", rc, i);
        
    }

    //
    // Setup a Timer and try to cancel it after expiration time.
    // If the cancel success, the test failes and returns -1.
    //
    CExTest* p2 = new CExTest(CancelScedulerCallBack, 50);

    TrTRACE(ExTest, "Set Timer 0x%p with 50ms timeout", p2);
    ExSetTimer(&(p2->m_Timer), CTimeDuration(50 * CTimeDuration::OneMilliSecond().Ticks()));

    rc = WaitForSingleObject(p2->m_hEvent, 200);
    if (rc != WAIT_OBJECT_0)
    {
        TrTRACE(ExTest, "Timer 0x%p failed to call-back after 50ms", p2);
        exit(-1);
    }
    CloseHandle(p2->m_hEvent);
}


void 
SchedulerBlackBoxTest(
    void
    )
{
    HANDLE hThread[3];
 
    NoOfCallBack = 0;
    NoOfOKTimeout = 0;
    TimerNo = 0;
    
    for(int i = 0; i < 3; ++i)
    {
        DWORD tid;
        hThread[i] = CreateThread(
                            NULL, 
                            0, 
                            TestScheduler, 
                            NULL,
                            0,
                            &tid
                            );
        if (hThread[i] == NULL)
        {
            TrERROR(ExTest, "Failed to create test thread. Error=%d", GetLastError()); 
            exit(-1);
        }
    }
    
    WaitForMultipleObjects(3, hThread, TRUE, INFINITE);
}



void AsyncExecutionReadWriteLockTest()
{
	CReadWriteLockAsyncExcutor ReadWriteLockAsyncExcutor;

	CAsyncCaller::LockType locktype = (rand() % 5 == 0) ? CAsyncCaller::Write : CAsyncCaller::Read;

	CAsyncCaller  AsyncCaller(ReadWriteLockAsyncExcutor, locktype);
	int Loops = 500;

	for(int i = 0; i< Loops; ++i)
	{
		R<CTestAsyncExecutionRequest> TestAsyncExecutionRequest = new CTestAsyncExecutionRequest(AsyncCaller);
		R<CTestAsyncExecutionRequest> ref = TestAsyncExecutionRequest;
		
		AsyncCaller.Run(TestAsyncExecutionRequest.get());

		if(i == Loops - 10)
		{
			ReadWriteLockAsyncExcutor.Close();
		}

		Sleep(1);
		ref.detach();
	}

	
	Sleep(5000);

	
}


extern "C" int __cdecl _tmain(int /*argc*/, LPCTSTR /*argv*/[])
/*++

Routine Description:
    Test Executive

Arguments:
    Parameters.

Returned Value:
    None.

--*/
{
    WPP_INIT_TRACING(L"Microsoft\\MSMQ");

	TrInitialize();
 
    //
    // Initialize the Executive Manager
    //
    ExInitialize(5);

	Sleep(0);
    TrRegisterComponent(xExTestComponent, TABLE_SIZE(xExTestComponent));

    SchedulerUnitTest();
    SchedulerBlackBoxTest();
	AsyncExecutionReadWriteLockTest();

    TrTRACE(ExTest, "Executive test pass successfully");

    WPP_CLEANUP();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\fn\lib\fndebug.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    FnDebug.cpp

Abstract:
    Format Name Parsing debugging

Author:
    Nir Aides (niraides) 21-May-00

Environment:
    Platform-independent, _DEBUG only

--*/

#include <libpch.h>
#include "Fn.h"
#include "Fnp.h"

#include "fndebug.tmh"

#ifdef _DEBUG


//---------------------------------------------------------
//
// Validate Format Name Parsing state
//
void FnpAssertValid(void)
{
    //
    // FnInitalize() has *not* been called. You should initialize the
    // Format Name Parsing library before using any of its funcionality.
    //
    ASSERT(FnpIsInitialized());

    //
    // TODO:Add more Format Name Parsing validation code.
    //
}


//---------------------------------------------------------
//
// Initialization Control
//
static LONG s_fInitialized = FALSE;

void FnpSetInitialized(void)
{
    LONG fFnAlreadyInitialized = InterlockedExchange(&s_fInitialized, TRUE);

    //
    // The Format Name Parsing library has *already* been initialized. You should
    // not initialize it more than once. This assertion would be violated
    // if two or more threads initalize it concurently.
    //
    ASSERT(!fFnAlreadyInitialized);
}


BOOL FnpIsInitialized(void)
{
    return s_fInitialized;
}


//---------------------------------------------------------
//
// Tracing and Debug registration
//
const TraceIdEntry xTraceTable[] = {

    Fn,

    //
    // TODO: Add Format Name Parsing sub-component trace ID's to be used with TrXXXX.
    // For example, FnInit, as used in:
    // TrERROR(FnInit, "Error description", parameters)
    //
};

/*
const DebugEntry xDebugTable[] = {

    {
        "FnDumpState(queue path name)",
        "Dump Format Name Parsing State to debugger",
        DumpState
    ),

    //
    // TODO: Add Format Name Parsing debug & control functions to be invoked using
    // mqctrl.exe utility.
    //
};
*/

void FnpRegisterComponent(void)
{
    TrRegisterComponent(xTraceTable, TABLE_SIZE(xTraceTable));
    //DfRegisterComponent(xDebugTable, TABLE_SIZE(xDebugTable));
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\fn\lib\fninit.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    FnInit.cpp

Abstract:
    Format Name Parsing initialization

Author:
    Nir Aides (niraides) 21-May-00

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include "Fn.h"
#include "Fnp.h"

#include "fninit.tmh"

VOID
FnInitialize(
	VOID
	)
/*++

Routine Description:
    Initializes Format Name Parsing library

    Note: Do not add initialization code that access AD, since initialization
    is done at each QM startup.

Arguments:
    None.

Returned Value:
    None.

--*/
{
    //
    // Validate that the Format Name Parsing library was not initalized yet.
    // You should call its initalization only once.
    //
    ASSERT(!FnpIsInitialized());
    FnpRegisterComponent();

    //
    // TODO: Write Format Name Parsing initalization code here
    //

    FnpSetInitialized();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\fn\lib\fnp.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Fnp.h

Abstract:
    Format Name Parsing private functions.

Author:
    Nir Aides (niraides) 21-May-00

--*/

#pragma once

#ifndef _MSMQ_Fnp_H_
#define _MSMQ_Fnp_H_


const TraceIdEntry Fn = L"Format Name Parsing";

#ifdef _DEBUG

void FnpAssertValid(void);
void FnpSetInitialized(void);
BOOL FnpIsInitialized(void);
void FnpRegisterComponent(void);

#else // _DEBUG

#define FnpAssertValid() ((void)0)
#define FnpSetInitialized() ((void)0)
#define FnpIsInitialized() TRUE
#define FnpRegisterComponent() ((void)0)

#endif // _DEBUG


LPWSTR FnpCopyQueueFormat(QUEUE_FORMAT& qfTo, const QUEUE_FORMAT& qfFrom);


#endif // _MSMQ_Fnp_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\fn\lib\fngeneral.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:
    FnGenaral.h

Abstract:

Author:
    Nir Aides (niraides) 23-May-2000

--*/

#include <libpch.h>
#include "mqwin64a.h"
#include "qformat.h"
#include "Fnp.h"
#include "FnGeneral.h"

#include "fngeneral.tmh"

bool CFunc_CompareQueueFormat::operator()(const QUEUE_FORMAT& obj1, const QUEUE_FORMAT& obj2) const	
{
	if(obj1.GetType() !=  obj2.GetType())
		return obj1.GetType() < obj2.GetType();

	if(obj1.Suffix() !=  obj2.Suffix())
		return obj1.GetType() < obj2.GetType();

	if(!obj1.IsSystemQueue() &&  obj2.IsSystemQueue())
		return true;	
	
	switch(obj1.GetType())
	{
	case QUEUE_FORMAT_TYPE_UNKNOWN: 
		return true;

	case QUEUE_FORMAT_TYPE_PUBLIC:
		return FnpCompareGuid(obj1.PublicID(), obj2.PublicID());

	case QUEUE_FORMAT_TYPE_PRIVATE:
		if(obj1.PrivateID().Uniquifier != obj2.PrivateID().Uniquifier)
			return obj1.PrivateID().Uniquifier < obj2.PrivateID().Uniquifier;

		return FnpCompareGuid(obj1.PrivateID().Lineage, obj2.PrivateID().Lineage); 

	case QUEUE_FORMAT_TYPE_DIRECT:
		//
		// BUGBUG: Replace with dedicated function. niraides 24-May-00
		//
		return _wcsicmp(obj1.DirectID(), obj2.DirectID()) < 0;

	case QUEUE_FORMAT_TYPE_MULTICAST:
		if(obj1.MulticastID().m_address == obj2.MulticastID().m_address)
			return obj1.MulticastID().m_port < obj2.MulticastID().m_port;
		
		return obj1.MulticastID().m_address < obj2.MulticastID().m_address;

	case QUEUE_FORMAT_TYPE_MACHINE:
		return FnpCompareGuid(obj1.MachineID(), obj2.MachineID());

	case QUEUE_FORMAT_TYPE_CONNECTOR:
		return FnpCompareGuid(obj1.ConnectorID(), obj2.ConnectorID());

	case QUEUE_FORMAT_TYPE_DL:
		return FnpCompareGuid(obj1.DlID().m_DlGuid, obj2.DlID().m_DlGuid);

	default:
		break;
	}

	ASSERT(FALSE);
	return false;
}


LPWSTR 
FnpCopyQueueFormat(
    QUEUE_FORMAT& qfTo, 
    const QUEUE_FORMAT& qfFrom
    )
/*++

Routine Description:
    copy one queue format to another.

Arguments:
    qfTo - destination queue format
    qfForm - source queue format

Returned Value:
    pointer to allocated string

Note:
    The routine doesn't free previous allocation. This is the caller responsibility to call 
    disposeString method before calling the routine

--*/

{
    qfTo = qfFrom;

    //
    // Note that suffix is not relevant since that queues are
    // opened for send.
    //

    if (qfFrom.GetType() == QUEUE_FORMAT_TYPE_DIRECT)
    {
		ASSERT(qfFrom.DirectID() != NULL);

        LPWSTR pw = newwcs(qfFrom.DirectID());
        qfTo.DirectID(pw);
        return pw;
    }

    if (qfFrom.GetType() == QUEUE_FORMAT_TYPE_DL &&
        qfFrom.DlID().m_pwzDomain != NULL)
    {
        LPWSTR pw = newwcs(qfFrom.DlID().m_pwzDomain);

        DL_ID id;
        id.m_DlGuid    = qfFrom.DlID().m_DlGuid;
        id.m_pwzDomain = pw;

        qfTo.DlID(id);

        return pw;
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\fn\lib\fnformat.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    FnDebug.cpp

Abstract:
Implementation of class CFnQueueFormat and CFnMqf (fn.h)    

Author:
    Gil Shafriri (gilsh) 16-Aug-00

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include <Fn.h>
#include "fnp.h"

#include "fnformat.tmh"

void CFnQueueFormat::CreateFromFormatName(LPCWSTR pfn, bool fDuplicate)
/*++

Routine Description:
	create queue format object from given format name string
	
Arguments:
    IN - pfn - format name string to parse. 

	IN - fDuplicate - if true - copy existing string before parsing.
					  if false copy only if needed by parser and the caller
					  has to keep the input string valid  through the object liftime.
*/
{
	ASSERT(pfn != NULL);


	AP<WCHAR>  OriginalDupAutoDelete;
	pfn = fDuplicate ? (OriginalDupAutoDelete = newwcs(pfn)).get() : pfn;
	AP<WCHAR> ParsingResultAutoDelete;

	BOOL fSuccess = FnFormatNameToQueueFormat(pfn , this, &ParsingResultAutoDelete);
	if(!fSuccess)
		throw bad_format_name(pfn);

	SafeAssign(m_OriginalDupAutoDelete , OriginalDupAutoDelete);
	SafeAssign(m_ParsingResultAutoDelete , ParsingResultAutoDelete);
}

void CFnQueueFormat::CreateFromFormatName(const xwcs_t& fn)
/*++

Routine Description:
		create queue format object from given format name string buffer.
	
Arguments:
    IN - fn - format name buffer to parse. 

    Note - the function copy the buffer supplied 
 
*/
{
	AP<WCHAR>  OriginalDupAutoDelete( fn.ToStr() );
	CreateFromFormatName(OriginalDupAutoDelete.get() , false);
    SafeAssign(m_OriginalDupAutoDelete , OriginalDupAutoDelete);
}



void CFnQueueFormat::CreateFromUrl(LPCWSTR url, bool fDuplicate)
/*++

Routine Description:
		create queue format object from given url string.
	
Arguments:
    IN - url - url string to parse. 

	IN - fDuplicate - if true - copy existing string before parsing.
					  if false copy only if needed by parser and the caller
					  has to keep the input string valid  through the object liftime.
    
 
*/
{
	ASSERT(url != NULL);
	if(!FnIsHttpHttpsUrl(url))
	{
		TrERROR(Fn,"Got Invalid url %ls ",url);
		throw bad_format_name(url);
	}

	url = fDuplicate ? (m_OriginalDupAutoDelete = newwcs(url)).get() : url;
	DirectID(const_cast<LPWSTR>(url));     
}

void CFnQueueFormat::CreateFromUrl(const xwcs_t& url)
/*++

Routine Description:
		create queue format object from given url string buffer.
	
Arguments:
    IN - url - url string buffer to parse. 
*/
{
	AP<WCHAR>  OriginalDupAutoDelete( url.ToStr() );
	CreateFromUrl(OriginalDupAutoDelete.get() , false);
	SafeAssign(m_OriginalDupAutoDelete , OriginalDupAutoDelete);
}


void CFnQueueFormat::CreateFromQueueFormat(const QUEUE_FORMAT& qf)
{
    ASSERT(("Illegal input QUEUE_FORMAT", qf.Legal()));

    if (&qf == this)
        return;

    //
    // free previous allocated data
    //
    m_OriginalDupAutoDelete.free();

    //
    // copy Queue Format
    //
    m_OriginalDupAutoDelete = FnpCopyQueueFormat(*this, qf);

    //
    // Set suffix value
    //
    Suffix(qf.Suffix());
}



void CFnMqf::CreateFromMqf(const xwcs_t& fn)
/*++

Routine Description:
		create list of queue formats object from given mqf buffer.
	
Arguments:
    IN - fn - mqf buffer to create the queue formats list from.
--*/
{
	AP<WCHAR> fnstr = fn.ToStr();
	CreateFromMqf(fnstr);
	SafeAssign(m_fnstr, fnstr);
}


void CFnMqf::CreateFromMqf(const WCHAR* fnstr)
/*++

Routine Description:
		create list of queue formats object from given mqf string.
	
Arguments:
    IN - fn - mqf string to create the queue formats list from.
--*/
{
	bool fSuccess = FnMqfToQueueFormats(
				  fnstr,
				  m_AutoQueueFormats,
				  &m_nQueueFormats,
				  strsToFree
				  ) == TRUE;

	if(!fSuccess)
	{
		throw bad_format_name(L"");
	}

	m_QueueFormats = m_AutoQueueFormats.get();
}

static std::wostream& operator<<(std::wostream& os, const MULTICAST_ID& mid)
/*++

Routine Description:
		Serialize multicast address into stream (doted format)
	
Arguments:
    os - stream
	mid - multicast address

Returned Value:
    The stream reference
--*/
{
	const WCHAR xMSMQColon[] = L":";

	os <<	((mid.m_address & 0x000000FF) >> 0)  << L"." << 
		    ((mid.m_address & 0x0000FF00) >> 8)  << L"." << 
		    ((mid.m_address & 0x00FF0000) >> 16) << L"." << 
		    ((mid.m_address & 0xFF000000) >> 24) << 
            xMSMQColon << mid.m_port;

	return os;
}

static std::wostream& operator<<(std::wostream& os, const GUID& guid)
/*++

Routine Description:
		Serialize guild into stream.
	
Arguments:
    os - stream
	guid - guid to serialize

Returned Value:
    The stream reference

--*/
{
    WCHAR strGuid[GUID_STR_LENGTH + 1];

    const GUID* pGuid = &guid;
    swprintf(strGuid, GUID_FORMAT, GUID_ELEMENTS(pGuid));

    return (os << strGuid);
}



std::wostream& operator<<(std::wostream& os, const CFnSerializeQueueFormat& queue)
/*++

Routine Description:
		Serialize QUEUE_FORMAT into stream.
	
Arguments:
    os - stream
	queue - holds msmq QUEUE_FORMAT to serialize.

Returned Value:
    The stream reference

--*/
{
	switch(queue.m_qf.GetType())
	{
		case QUEUE_FORMAT_TYPE_DIRECT :
		    os <<FN_DIRECT_TOKEN<<FN_EQUAL_SIGN<<queue.m_qf.DirectID();
		    break;
            
        //
        // MSMQ:PUBLIC=guid\queue number
        //
        case QUEUE_FORMAT_TYPE_PUBLIC :
            os << FN_PUBLIC_TOKEN <<FN_EQUAL_SIGN<<queue.m_qf.PublicID();
            break;
            
        //
        // MSMQ:PRIVATE=guid\queue number
        //
        case QUEUE_FORMAT_TYPE_PRIVATE :
            os<< FN_PRIVATE_TOKEN
                << FN_EQUAL_SIGN
                << queue.m_qf.PrivateID().Lineage
                << FN_PRIVATE_SEPERATOR
                << std::hex<< queue.m_qf.PrivateID().Uniquifier << std::dec;
            break;

        //
        // MSMQ:MULTICAST=address:port
        //
        case QUEUE_FORMAT_TYPE_MULTICAST:
            os<< FN_MULTICAST_TOKEN
                << FN_EQUAL_SIGN
                << std::dec << queue.m_qf.MulticastID();
            break;

        default:
            ASSERT(("invalid format name found during message sirialization", 0));
	}
	return 	os;
}


std::wostream&
operator<<(
   std::wostream& os, 
   const CFnSerializeMqf& mqf
   )
/*++

Routine Description:
		Serialize array of QUEUE_FORMAT (mqf)  into stream.
	
Arguments:
    os - stream
	mqf - holds array of msmq QUEUE_FORMAT (mqf) to serialize.

Returned Value:
    The stream reference

--*/
{
	for(ULONG i = 0; i< mqf.m_count; i++)
	{
		os<<CFnSerializeQueueFormat(mqf.m_pqf[i]);

		if(i != mqf.m_count - 1 )
		{
			os.put(FN_MQF_SEPARATOR_C);
		}			
	}
	return os;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\fn\lib\fngeneral.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:
    FnGenaral.h

Abstract:

Author:
    Nir Aides (niraides) 23-May-2000

--*/



#pragma once



#ifndef _FNGENERAL_H_
#define _FNGENERAL_H_



const LPCWSTR xClassSchemaQueue = L"msMQQueue";
const LPCWSTR xClassSchemaGroup = L"group";
const LPCWSTR xClassSchemaAlias = L"msMQ-Custom-Recipient";

#define LDAP_PREFIX L"LDAP://"
#define GLOBAL_CATALOG_PREFIX L"GC://"

#define LDAP_GUID_FORMAT L"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x"

#define LDAP_PRINT_GUID_ELEMENTS(p)	\
	p[0],  p[1],  p[2],  p[3],	\
	p[4],  p[5],  p[6],  p[7],	\
	p[8],  p[9],  p[10], p[11],	\
	p[12], p[13], p[14], p[15]

#define LDAP_SCAN_GUID_ELEMENTS(p)	\
	p,		p + 1,	p + 2,	p + 3,	\
	p + 4,	p + 5,	p + 6,	p + 7,	\
	p + 8,	p + 9,	p + 10, p + 11,	\
	p + 12, p + 13, p + 14, p + 15



//
// BSTRWrapper and VARIANTWrapper are used to enable automatic resources 
// deallocation in the case of thrown exceptions.
//

class BSTRWrapper {
private:
    BSTR m_p;

public:
    BSTRWrapper(BSTR p = NULL) : m_p(p) {}
   ~BSTRWrapper()                       { if(m_p != NULL) SysFreeString(m_p); }

    operator BSTR() const     { return m_p; }
    BSTR* operator&()         { return &m_p;}
    BSTR detach()             { BSTR p = m_p; m_p = NULL; return p; }

private:
    BSTRWrapper(const BSTRWrapper&);
    BSTRWrapper& operator=(const BSTRWrapper&);
};



class VARIANTWrapper {
private:
    VARIANT m_p;

public:
    VARIANTWrapper() { VariantInit(&m_p); }
   ~VARIANTWrapper() 
	{ 
		HRESULT hr = VariantClear(&m_p);
		ASSERT(SUCCEEDED(hr));
		DBG_USED(hr);
	}

    operator const VARIANT&() const { return m_p; }
    operator VARIANT&()             { return m_p; }
    VARIANT* operator&()            { return &m_p;}

	const VARIANT& Ref() const { return m_p; }
	VARIANT& Ref() { return m_p; }

    VARIANTWrapper(const VARIANTWrapper& var)
	{
		VariantInit(&m_p);
		HRESULT hr = VariantCopy(&m_p, (VARIANT*)&var.m_p);
		if(FAILED(hr))
		{
            ASSERT(("Failure must be due to low memory", hr == E_OUTOFMEMORY));
			throw bad_alloc();
		} 
	}

private:
    VARIANTWrapper& operator=(const VARIANTWrapper&);
};



inline bool FnpCompareGuid(const GUID& obj1, const GUID& obj2)	
/*++
NOTE: 
	When this routine was written, it was needed, since the existance 
	of an implicit CTOR at QUEUE_FORMAT which takes a GUID object as argument,
	means that if ever an operator < () would be written to QUEUE_FORMAT,
	the expression obj1 < obj2, would invoke it, after an implicit type 
	conversion of obj1 and obj2 to the QUEUE_FORMAT type.

--*/
{
	C_ASSERT(sizeof(obj1) == 16);

	return (memcmp(&obj1, &obj2, sizeof(obj1)) < 0);
}



//
// A "function object" which is used to compare QUEUE_FORMAT objects
//
struct CFunc_CompareQueueFormat: std::binary_function<QUEUE_FORMAT, QUEUE_FORMAT, bool> 
{
	bool operator()(const QUEUE_FORMAT& obj1, const QUEUE_FORMAT& obj2) const;
};



#endif//_FNGENERAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\fn\lib\mqfexpander.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:
    DLExpander.cpp

Abstract:
    FnExpandMqf() - does a DFS on an array of QUEUE_FORMATS.
	It "flattens" the graph created by possible DL queue formats, 
	to a linear array of QUEUE_FORMATS which contains no duplicates 
	and no DLs.

NOTES:
	Functions interact directly with the Active directory,
	through the use of the following interfaces and functions:
	IADs, IADsGroup, GetADsObject().

	Binding is done through the Serverless notation mechanism,
	e.g. "LDAP://<GUID=00112233445566778899aabbccddeeff>
	instead of "LDAP://server-name/<GUID=00112233445566778899aabbccddeeff>

	NOTE: Active Directory does not seperate a GUID string with hyphens ('-')
	as is done in MSMQ!

Author:
    Nir Aides (niraides) 23-May-2000

--*/

#pragma warning( disable : 4786 )

#include <libpch.h>
#include <activeds.h>
#include <Oleauto.h>
#include "mqwin64a.h"
#include <qformat.h>
#include <fntoken.h>
#include <bufutl.h>
#include "Fn.h"
#include "fnp.h"
#include "FnGeneral.h"

#include "mqfexpander.tmh"

using namespace std;



typedef set<QUEUE_FORMAT, CFunc_CompareQueueFormat> QueueFormatSet;



static
VOID 
FnpExpandDL(
	IADsGroup* pGroup,			  //DL object
	set<wstring>& DLSet,		 //Set of processed DL objects
	QueueFormatSet& LeafMQFSet,	//Set of encountered QUEUE_FORMATs
	LPCWSTR DomainName
	);



static GUID FnpString2Guid(LPCWSTR GuidStr)
{
    GUID Guid = {0};
	UINT Data[16];

    DWORD nFields = swscanf(
						GuidStr,
						LDAP_GUID_FORMAT,
						LDAP_SCAN_GUID_ELEMENTS(Data)
						);    
    DBG_USED(nFields);
    ASSERT(("Bad Guid string format, in FnpString2Guid()", nFields == 16));
    
	for(size_t i = 0; i < 16; i++)
	{
		((BYTE*)&Guid)[i] = (BYTE)(Data[i]);
	}

	return Guid;
}



static R<IADsGroup> FnpGetDLInterface(IADs* pADObject)
{
	IADsGroup* pGroup;

	HRESULT hr = pADObject->QueryInterface(IID_IADsGroup, (void**)&pGroup);
	if(FAILED(hr))
	{
        TrERROR(Fn, "Failed IADs->QueryInterface, status 0x%x. Verify the object is an AD Group.", hr);
        throw bad_ds_result(hr);
	}

	return pGroup;
}


			
static R<IADs> FnpGCBindGuid(const GUID* pGuid)
{
	CStaticResizeBuffer<WCHAR, MAX_PATH> ADsPath;

	UtlSprintfAppend(
		ADsPath.get(),
		GLOBAL_CATALOG_PREFIX L"<GUID=" LDAP_GUID_FORMAT L">",
		LDAP_PRINT_GUID_ELEMENTS(((BYTE*)pGuid))
		);
		
	//
	// Attempt bind
	// 

	IADs* pADObject;
	
	HRESULT hr = ADsOpenObject( 
					ADsPath.begin(),
					NULL,
					NULL,
					ADS_SECURE_AUTHENTICATION,
					IID_IADs,
					(void**) &pADObject
					);

    if(FAILED(hr))
	{
        TrERROR(Fn, "Failed ADsOpenObject, status 0x%x. Binding to the specified object failed.", hr);
		throw bad_ds_result(hr);
	}

	return pADObject;
}

			
static R<IADs> FnpServerlessBindGuid(const GUID* pGuid)
{
	CStaticResizeBuffer<WCHAR, MAX_PATH> ADsPath;

	UtlSprintfAppend(
		ADsPath.get(),
		LDAP_PREFIX L"<GUID=" LDAP_GUID_FORMAT L">",
		LDAP_PRINT_GUID_ELEMENTS(((BYTE*)pGuid))
		);
		
	//
	// Attempt bind
	// 

	IADs* pADObject;
	
	HRESULT hr = ADsOpenObject( 
					ADsPath.begin(),
					NULL,
					NULL,
					ADS_SECURE_AUTHENTICATION,
					IID_IADs,
					(void**) &pADObject
					);

    if(FAILED(hr))
	{
        TrERROR(Fn, "Failed ADsOpenObject, status 0x%x. Binding to the specified object failed.", hr);
		throw bad_ds_result(hr);
	}

	return pADObject;
}

			
static R<IADs> FnpDomainBindGuid(const GUID* pGuid, LPCWSTR pDomainName)
{
	CStaticResizeBuffer<WCHAR, MAX_PATH> ADsPath;

	UtlSprintfAppend(
		ADsPath.get(),
		LDAP_PREFIX L"%ls/<GUID=" LDAP_GUID_FORMAT L">",
		pDomainName,
		LDAP_PRINT_GUID_ELEMENTS(((BYTE*)pGuid))
		);
		
	//
	// Attempt bind
	// 

	IADs* pADObject;
	
	HRESULT hr = ADsOpenObject( 
					ADsPath.begin(),
					NULL,
					NULL,
					ADS_SECURE_AUTHENTICATION,
					IID_IADs,
					(void**) &pADObject
					);

    if(FAILED(hr))
	{
        TrTRACE(Fn, "Failed ADsOpenObject with specified domain '%ls', status 0x%x. Will try Serverless binding", pDomainName, hr);
		throw bad_ds_result(hr);
	}

	return pADObject;
}


static R<IADs> FnpBindGuid(const GUID* pGuid, LPCWSTR* pDomainName)
{
	ASSERT(pDomainName != NULL);

	try
	{
		if(*pDomainName != NULL)
			return FnpDomainBindGuid(pGuid, *pDomainName);
	}
	catch(const exception&)
	{
		//
		// Failed to bind with domain name. Reset this domain name string.
		//
		*pDomainName = NULL;
	}

	try
	{
		return FnpServerlessBindGuid(pGuid);
	}
	catch(const exception&)
	{
		//
		// Failed to bind in the directory service. 
		// Try binding through the global catalog.
		//

		return FnpGCBindGuid(pGuid);
	}
}


VOID 
HandleQueueFormat(
	const QUEUE_FORMAT& QueueFormat,
	set<wstring>& DLSet,			 //Set of processed DL objects
	QueueFormatSet& LeafMQFSet		//Set of encountered QUEUE_FORMATs
	)
{
	if(QueueFormat.GetType() == QUEUE_FORMAT_TYPE_DL)
	{
		GUID DLGuid = QueueFormat.DlID().m_DlGuid;
		LPCWSTR DomainName = QueueFormat.DlID().m_pwzDomain;

		R<IADs> pADObject = FnpBindGuid(&DLGuid, &DomainName);
		R<IADsGroup> pGroup = FnpGetDLInterface(pADObject.get());

		FnpExpandDL(pGroup.get(), DLSet, LeafMQFSet, DomainName);

		return;
	}

	if(LeafMQFSet.find(QueueFormat) == LeafMQFSet.end())
	{
		QUEUE_FORMAT QueueFormatCopy;

		FnpCopyQueueFormat(QueueFormatCopy, QueueFormat);
		LeafMQFSet.insert(QueueFormatCopy);

		TrTRACE(Fn, "Object inserted to set. INSERTED");

		return;
	}

	TrTRACE(Fn, "duplicate object discarded. DUPLICATE");
}



static 
VOID
HandleQueueAlias(
	IADs* QueueAlias,			  //Queue alias interface 
	set<wstring>& DLSet,		 //Set of processed DL objects
	QueueFormatSet& LeafMQFSet	//Set of encountered QUEUE_FORMATs
	)
{
	VARIANTWrapper var;
	
	HRESULT hr;
	hr = QueueAlias->Get(L"msMQ-Recipient-FormatName", &var);
	if(FAILED(hr))
	{
		TrERROR(Fn, "Can't retrieve format name of queue alias. Status = %d", hr);
		throw bad_ds_result(hr);
	}

	TrTRACE(Fn, "Queue alias format name is %ls", var.Ref().bstrVal);

	AP<WCHAR> StringToFree;
	QUEUE_FORMAT QueueFormat;

	BOOL Result = FnFormatNameToQueueFormat(
					var.Ref().bstrVal,
					&QueueFormat,
					&StringToFree
					);

	if(!Result)
	{
		TrERROR(Fn, "Bad format name in queue alias. %ls", StringToFree.get());
		throw bad_format_name(L"");
	}

	HandleQueueFormat(
		QueueFormat,
		DLSet,
		LeafMQFSet
		);
}



static 
VOID
FnpProcessADs(
	IADs* pADObject,			  //Group interface (the DL object)
	set<wstring>& DLSet,		 //Set of processed DL objects
	QueueFormatSet& LeafMQFSet,	//Set of encountered QUEUE_FORMATs
	LPCWSTR DomainName
	)
/*++
Routine Description:
	Process Active Directory object.
	If it is a Group object, Recurse into it.
	If it is a queue, generate a public QUEUE_FORMAT, and try to insert it  
	to 'LeafMQFSet'.
	If it is neither, ignore it and return. 

Arguments:

Returned Value:
	throws exception objects on any failure
--*/
{
	BSTRWrapper ClassStr;

	HRESULT hr;
	hr = pADObject->get_Class(&ClassStr);
	if(FAILED(hr))
	{
        TrERROR(Fn, "Failed pADObject->get_Class, status 0x%x", hr);
        throw bad_ds_result(hr);
	}	

	TrTRACE(Fn, "Object Class Name is '%ls'", *&ClassStr);
	
	//
	// "switch" on the object type
	//
	if(_wcsicmp(ClassStr, xClassSchemaGroup) == 0)
	{
		R<IADsGroup> pGroup = FnpGetDLInterface(pADObject);

		FnpExpandDL(pGroup.get(), DLSet, LeafMQFSet, DomainName);
		return;
	}
	else if(_wcsicmp(ClassStr, xClassSchemaQueue) == 0)
	{
		BSTRWrapper GuidStr;

		HRESULT hr;
		hr = pADObject->get_GUID(&GuidStr);
		if(FAILED(hr))
		{
			TrERROR(Fn, "Failed pADObject->get_GUID, status 0x%x", hr);
			throw bad_ds_result(hr);
		}		

		GUID Guid = FnpString2Guid(GuidStr);
		QUEUE_FORMAT QueueFormat(Guid);

		bool fInserted = LeafMQFSet.insert(QueueFormat).second;

		TrTRACE(Fn, "Object is Queue Guid=%ls, %s", GuidStr, (fInserted ? "INSERTED" : "DUPLICATE"));

		return;
	}
	else if(_wcsicmp(ClassStr, xClassSchemaAlias) == 0)
	{
		HandleQueueAlias(
			pADObject,
			DLSet,
			LeafMQFSet
			);

		return;
	}

	TrWARNING(Fn, "Unsupported object '%ls' IGNORED", ClassStr);
}



static 
BOOL 
FnpInsert2DLSet(
	IADsGroup* pGroup,			  //DL object
	set<wstring>& DLSet			 //Set of processed DL objects
	)
{
	BSTRWrapper GuidStr;

	HRESULT hr = pGroup->get_GUID(&GuidStr);
	if(FAILED(hr))
	{
        TrERROR(Fn, "Failed pGroup->get_GUID, status 0x%x", hr);
        throw bad_ds_result(hr);
	}

	BOOL fInserted = DLSet.insert(wstring(GuidStr)).second;

	return fInserted;
}



static R<IADs> FnpServerlessBindDN(BSTR DistinugishedName)
{
	WCHAR ADsPath[MAX_PATH];

	_snwprintf(
		ADsPath,
		MAX_PATH,
		LDAP_PREFIX L"%ls",
		DistinugishedName
		);

	//
	// Attempt bind
	// 

	IADs* pADObject;
	
	HRESULT hr = ADsOpenObject( 
					ADsPath,
					NULL,
					NULL,
					ADS_SECURE_AUTHENTICATION,
					IID_IADs,
					(void**) &pADObject
					);

    if(FAILED(hr)) 
	{
        TrERROR(Fn, "Failed ADsOpenObject, status 0x%x. Binding to the specified object failed.", hr);
		throw bad_ds_result(hr);
	}

	return pADObject;
}



static R<IADs> FnpBindDN(BSTR DistinugishedName, LPCWSTR* pDomainName)
{
	ASSERT(pDomainName != NULL);

	if(*pDomainName == NULL)
		return FnpServerlessBindDN(DistinugishedName);

	WCHAR ADsPath[MAX_PATH];

	_snwprintf(
		ADsPath,
		MAX_PATH,
		LDAP_PREFIX L"%ls/%ls",
		*pDomainName,
		DistinugishedName
		);

	//
	// Attempt bind
	// 

	IADs* pADObject;
	
	HRESULT hr = ADsOpenObject( 
					ADsPath,
					NULL,
					NULL,
					ADS_SECURE_AUTHENTICATION,
					IID_IADs,
					(void**) &pADObject
					);

    if(FAILED(hr)) 
	{
        TrTRACE(Fn, "Failed ADsOpenObject with specified domain '%ls', status 0x%x. Will try Serverless binding", *pDomainName, hr);
		*pDomainName = NULL;
		return FnpServerlessBindDN(DistinugishedName);
	}

	return pADObject;
}



//
// AttrInfoWrapper is used to enable automatic release of ADS_ATTR_INFO structures.
//

class AttrInfoWrapper {
private:
    PADS_ATTR_INFO m_p;

public:
    AttrInfoWrapper(PADS_ATTR_INFO p = NULL) : m_p(p) {}
   ~AttrInfoWrapper()					{ if(m_p != NULL) FreeADsMem(m_p); }

    operator PADS_ATTR_INFO() const     { return m_p; }
    PADS_ATTR_INFO operator ->() const	{ return m_p; }
    PADS_ATTR_INFO* operator&()         { return &m_p;}
    PADS_ATTR_INFO detach()             { PADS_ATTR_INFO p = m_p; m_p = NULL; return p; }

private:
    AttrInfoWrapper(const AttrInfoWrapper&);
    AttrInfoWrapper& operator=(const AttrInfoWrapper&);
};



VOID 
FnpExpandDL(
	IADsGroup* pGroup,			  //DL object
	set<wstring>& DLSet,		 //Set of processed DL objects
	QueueFormatSet& LeafMQFSet,	//Set of encountered QUEUE_FORMATs
	LPCWSTR DomainName
	)
{
	//
	// if DL allready encountered return without further processing.
	//
	if(!FnpInsert2DLSet(pGroup, DLSet))
	{
		TrTRACE(Fn, "DL allready processed. IGNORED");
		return;
	}

	//
	// ------------------- Enumerate DL members ---------------------
	//

	R<IDirectoryObject> DirectoryObject;

	HRESULT hr = pGroup->QueryInterface(IID_IDirectoryObject, (void**)&DirectoryObject.ref());
	if(FAILED(hr))
	{
        TrERROR(Fn, "Failed pGroup->QueryInterface(), status 0x%x", hr);
        throw bad_ds_result(hr);
	}

	//
	// iterate 100 group members at a time.
	//
	const DWORD MembersBlockSize = 100;
	DWORD index = 0;

	while(true)
	{
		WCHAR	pwszRangeAttrib[256];                           
		LPWSTR	pAttrNames[] = {pwszRangeAttrib};                 
		DWORD	dwNumAttr = TABLE_SIZE(pAttrNames);   
		
		AttrInfoWrapper	pAttrInfo;                                
		DWORD			dwReturn;  

		swprintf(pwszRangeAttrib, L"member;Range=%d-%d", index, index + MembersBlockSize - 1);
 
		hr = DirectoryObject->GetObjectAttributes(
								pAttrNames, 
								dwNumAttr, 
								&pAttrInfo, 
								&dwReturn
								);

		//
		// Iterated all members
		//
		if(hr == S_ADS_NOMORE_ROWS)
			break;
		
		if(hr != S_OK)
		{
			TrERROR(Fn, "Failed DirectoryObject->GetObjectAttributes(), status 0x%x", hr);
			throw bad_ds_result(hr);
		}

		//
		// DL with no members.
		//
		if(dwReturn == 0)
			break;

		//
		// Asked for only one attribute.
		// 
		ASSERT(dwReturn == 1);

		//
		// member attribute returned should be of this type. It may be ADSTYPE_PROV_SPECIFIC if schema is not available.
		//
		ASSERT(pAttrInfo->dwADsType == ADSTYPE_DN_STRING);

		if(pAttrInfo->dwADsType != ADSTYPE_DN_STRING)
		{
			TrERROR(Fn, "Failed DirectoryObject->GetObjectAttributes(), member attribute returned is not of type ADSTYPE_DN_STRING. Probably schema access problems.");
			throw bad_ds_result(ERROR_DS_OPERATIONS_ERROR);
		}

		//
		// Iterate the multivalue attribute "member"
		//			
		for (DWORD dwVal = 0; dwVal < pAttrInfo->dwNumValues; dwVal++)
		{
			LPWSTR DistinguishedName = (pAttrInfo->pADsValues+dwVal)->CaseIgnoreString;
			R<IADs> pADObject = FnpBindDN(DistinguishedName, &DomainName);
			
			FnpProcessADs(pADObject.get(), DLSet, LeafMQFSet, DomainName);
		}

		//
		// Finished iterating all members. 
		// If the last character in pAttrInfo->pszAttrName is L'*' then there are no more members.
		//
		if(pAttrInfo->pszAttrName[wcslen(pAttrInfo->pszAttrName) - 1] == L'*')
			break;

		index += MembersBlockSize;
	}
	
	TrTRACE(Fn, "End of DL Iteration.");
}



VOID 
FnExpandMqf(
	ULONG nTopLevelMqf, 
	const QUEUE_FORMAT TopLevelMqf[], 
	ULONG* pnLeafMqf,
	QUEUE_FORMAT** ppLeafMqf
	)
/*++
Routine Description:
	Does a DFS on an array of QUEUE_FORMATS.
	It "flattens" the graph created by possible DL queue formats, 
	to a linear array of QUEUE_FORMATS which contains no duplicates 
	and no DLs.

Arguments:
	[in] TopLevelMqf - array of QUEUE_FORMAT (with possible DL queue formats)
	[out] ppLeafMqf - the "expanded" array of QUEUE_FORMAT. contains no DL 
		queue formats, and no duplicates.
	[out] pnLeafMqf - size of 'ppLeafMqf' array

Returned Value:
	throws exception objects on any failure

	IMPORTANT: Any strings pointed by queue formats in array ppLeafMqf[] are 
	newly allocated copies of strings in array TopLevelMqf[].

--*/
{
	//
	// Set of processed DL objects. all encountered Active Directory DL objects
	// are inserted. it is used to avoid circles in the DFS
	//
	set<wstring> DLSet;

	//
	// Set of encountered QUEUE_FORMATs. all encountered Queues are inserted.
	// It is used to avoid duplicate queues.
	//
	QueueFormatSet LeafMQFSet;

	try
	{
		for(DWORD i = 0; i < nTopLevelMqf; i++)
		{
			HandleQueueFormat(TopLevelMqf[i], DLSet, LeafMQFSet);
		}

		if(LeafMQFSet.size() == 0)
		{
			//
			// MQF can be expanded to an empty list if it contains references 
			// to empty DL objects.
			//
			*ppLeafMqf = NULL;
			*pnLeafMqf = 0;

			return;
		}

		//
		// BUGBUG: Scale: We may optimize here to allocate as minimum as possible
		// (i.e. only for DL= format name). (ShaiK, 30-May-2000).
		//
		AP<QUEUE_FORMAT> LeafMqf = new QUEUE_FORMAT[LeafMQFSet.size()];

		QueueFormatSet::const_iterator Itr = LeafMQFSet.begin();
		QueueFormatSet::const_iterator ItrEnd = LeafMQFSet.end();

		for(int j = 0; Itr != ItrEnd; j++, Itr++)
		{
			LeafMqf[j] = *Itr;
		}

		*ppLeafMqf = LeafMqf.detach();
		*pnLeafMqf = UINT64_TO_UINT(LeafMQFSet.size());
	}
	catch(const exception&)
	{
		QueueFormatSet::iterator Itr = LeafMQFSet.begin();
		QueueFormatSet::iterator ItrEnd = LeafMQFSet.end();

		for(; Itr != ItrEnd; Itr++)
		{
			Itr->DisposeString();
		}

		TrERROR(Fn, "Failed FnExpandMqf");
		throw;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\fn\test\fniads.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    FnIADs.h

Abstract:
    Format Name Parsing library test

Author:
    Nir Aides (niraides) 21-May-00

Environment:
    Platform-independent

--*/



struct CObjectData
{
	LPCWSTR odADsPath;
	LPCWSTR odDistinguishedName;
	LPCWSTR odClassName;
	LPCWSTR odGuid;
};



class CADInterface : 
	public IADsGroup, 
	public IDirectoryObject
{
public:
    using IADsGroup::Release;

    virtual VOID TestPut( 
        BSTR bstrName,
        VARIANT vProp) = 0;
};



R<CADInterface> 
CreateADObject(
		const CObjectData& obj
		);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\fn\test\mc.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    event.cpp

Abstract:
    Simulate Machine configuration

Author:
    Uri Habusha (urih) 04-May-99

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include <mqmacro.h>

#include "mc.tmh"

static WCHAR s_ComputerName[MAX_COMPUTERNAME_LENGTH + 1] = L"";
static DWORD s_ComputerNameLen = 0;


static
VOID 
ComputerNameInit()
{
    s_ComputerNameLen = TABLE_SIZE(s_ComputerName);
	BOOL fSucc = GetComputerName(s_ComputerName, (LPDWORD)&s_ComputerNameLen);
	
	ASSERT(fSucc);
    DBG_USED(fSucc);
	ASSERT(s_ComputerNameLen <= TABLE_SIZE(s_ComputerName));
}



LPCWSTR
McComputerName(
	VOID
	)
/*++

Routine Description:
    Returns the computer name

Arguments:
    None.

Returned Value:
    A pointer to the computer name string buffer.

--*/
{
	if(s_ComputerName[0] == L'\0')
	{
		ComputerNameInit();
	}

	return s_ComputerName;
}



DWORD
McComputerNameLen(
	VOID
	)
{
	if(s_ComputerNameLen == 0)
	{
		ComputerNameInit();
	}

	return s_ComputerNameLen;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\fn\lib\fnparse.cpp ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    fnparse.cpp

Abstract:

    Format Name parsing.
    Format Name String --> QUEUE_FORMAT conversion routines 

Authors:

    Erez Haba (erezh) 17-Jan-1997
	Nir Aides (niraides) 08-Aug-2000

Revision History:

--*/

#include <libpch.h>
#include "mqwin64a.h"
#include <qformat.h>
#include <fntoken.h>
#include <Fn.h>
#include <strutl.h>
#include <mc.h>
#include "Fnp.h"

#include "fnparse.tmh"

//=========================================================
//
//  Format Name String -> QUEUE_FORMAT conversion routines
//
//=========================================================

//---------------------------------------------------------
//
//  Skip white space characters, return next non ws char
//
//  N.B. if no white space is needed uncomment next line
//#define skip_ws(p) (p)
inline LPCWSTR skip_ws(LPCWSTR p)
{
    //
    //  Don't skip first non white space
    //
    while(iswspace(*p))
    {
        ++p;
    }

    return p;
}



//
// Skips white spaces backwards. returns pointer to leftmost whitespace 
// found.
//
inline LPCWSTR skip_ws_bwd(LPCWSTR p, LPCWSTR pStartOfBuffer)
{
	ASSERT(p != NULL && pStartOfBuffer != NULL && p >= pStartOfBuffer);

    while(p > pStartOfBuffer && iswspace(*(p - 1)))
    {
        p--;
    }

    return p;
}



inline void ValidateCharLegality(LPCWSTR p)
{
	//
	// Characters that are illegal as part of machine and queue name.
	// L'\x0d' is an escape sequence designating the character whose code is d in hex (carriage return)
	//

	if(*p == L'\x0d' || *p == L'\x0a' || *p == L'+' || *p == L'"' || *p == FN_DELIMITER_C)
	{
		TrERROR(Fn, "Queue name contains illegal characters '%ls'", p);
		throw bad_format_name(p);
	}
}



//---------------------------------------------------------
//
//  Skip white space characters, return next non ws char
//
inline LPCWSTR FindPathNameDelimiter(LPCWSTR p)
{
	LPCWSTR PathName = p;

	for(; *p != L'\0' && *p != FN_DELIMITER_C; p++)
	{
		ValidateCharLegality(p);
	}

	if(*p != FN_DELIMITER_C)
	{
		TrERROR(Fn, "Failed to find path delimiter in '%ls'", PathName);
		throw bad_format_name(PathName);
	}
	
	return p;
}



//---------------------------------------------------------
//
//  Parse Format Name Type prefix string.
//  Return next char to parse on success, 0 on failure.
//
static LPCWSTR ParsePrefixString(LPCWSTR p, QUEUE_FORMAT_TYPE& qft)
{
    const int unique = 1;
    //----------------0v-------------------------
    ASSERT(L'U' == FN_PUBLIC_TOKEN    [unique]);
    ASSERT(L'U' == FN_MULTICAST_TOKEN [unique]);
    ASSERT(L'R' == FN_PRIVATE_TOKEN   [unique]);
    ASSERT(L'O' == FN_CONNECTOR_TOKEN [unique]);
    ASSERT(L'A' == FN_MACHINE_TOKEN   [unique]);
    ASSERT(L'I' == FN_DIRECT_TOKEN    [unique]);
    ASSERT(L'L' == FN_DL_TOKEN    [unique]);
    //----------------0^-------------------------

    //
    //  accelarate token recognition by checking 2nd character
    //
    switch(towupper(p[unique]))
    {
        //  pUblic or mUlticast
        case L'U':
            qft = QUEUE_FORMAT_TYPE_PUBLIC;
            if(_wcsnicmp(p, FN_PUBLIC_TOKEN, FN_PUBLIC_TOKEN_LEN) == 0)
                return (p + FN_PUBLIC_TOKEN_LEN);

            qft = QUEUE_FORMAT_TYPE_MULTICAST;
            if(_wcsnicmp(p, FN_MULTICAST_TOKEN, FN_MULTICAST_TOKEN_LEN) == 0)
                return (p + FN_MULTICAST_TOKEN_LEN);

            break;

        //  pRivate
        case L'R':
            qft = QUEUE_FORMAT_TYPE_PRIVATE;
            if(_wcsnicmp(p, FN_PRIVATE_TOKEN, FN_PRIVATE_TOKEN_LEN) == 0)
                return (p + FN_PRIVATE_TOKEN_LEN);
            break;

        //  cOnnector
        case L'O':
            qft = QUEUE_FORMAT_TYPE_CONNECTOR;
            if(_wcsnicmp(p, FN_CONNECTOR_TOKEN, FN_CONNECTOR_TOKEN_LEN) == 0)
                return (p + FN_CONNECTOR_TOKEN_LEN);
            break;

        //  mAchine
        case L'A':
            qft = QUEUE_FORMAT_TYPE_MACHINE;
            if(_wcsnicmp(p, FN_MACHINE_TOKEN, FN_MACHINE_TOKEN_LEN) == 0)
                return (p + FN_MACHINE_TOKEN_LEN);
            break;

        //  dIrect
        case L'I':
            qft = QUEUE_FORMAT_TYPE_DIRECT;
            if(_wcsnicmp(p, FN_DIRECT_TOKEN, FN_DIRECT_TOKEN_LEN) == 0)
                return (p + FN_DIRECT_TOKEN_LEN);
            break;

        //  dL
        case L'L':
            qft = QUEUE_FORMAT_TYPE_DL;
            if(_wcsnicmp(p, FN_DL_TOKEN, FN_DL_TOKEN_LEN) == 0)
                return (p + FN_DL_TOKEN_LEN);
            break;

    }

	TrERROR(Fn, "Failed to find format name prefix in '%ls'.", p);
    throw bad_format_name(p);
}


//---------------------------------------------------------
//
//  Parse a guid string, into guid.
//  Return next char to parse on success, 0 on failure.
//
LPCWSTR FnParseGuidString(LPCWSTR p, GUID* pg)
{
    //
    //  N.B. scanf stores the results in an int, no matter what the field size
    //      is. Thus we store the result in tmp variabes.
    //
    int n;
    UINT w2, w3, d[8];
	unsigned long Data1;

    if(swscanf(
            p,
            GUID_FORMAT L"%n",
            &Data1,
            &w2, &w3,                       //  Data2, Data3
            &d[0], &d[1], &d[2], &d[3],     //  Data4[0..3]
            &d[4], &d[5], &d[6], &d[7],     //  Data4[4..7]
            &n                              //  number of characters scaned
            ) != 11)
    {
        //
        //  not all 11 fields where not found.
        //
		TrERROR(Fn, "Failed parsing of GUID string '%ls'.", p);
        throw bad_format_name(p);
    }

	pg->Data1 = Data1;
    pg->Data2 = (WORD)w2;
    pg->Data3 = (WORD)w3;
    for(int i = 0; i < 8; i++)
    {
        pg->Data4[i] = (BYTE)d[i];
    }

    return (p + n);
}


//---------------------------------------------------------
//
//  Parse private id uniquifier, into guid.
//  Return next char to parse on success, 0 on failure.
//
static LPCWSTR ParsePrivateIDString(LPCWSTR p, ULONG* pUniquifier)
{
    int n;
    if(swscanf(
            p,
            FN_PRIVATE_ID_FORMAT L"%n",
            pUniquifier,
            &n                              //  number of characters scaned
            ) != 1)
    {
        //
        //  private id field was not found.
        //
		TrERROR(Fn, "Failed parsing of private id '%ls'.", p);
        throw bad_format_name(p);
    }

	if(*pUniquifier == 0)
	{
		TrERROR(Fn, "Found zero private id in '%ls'.", p);
		throw bad_format_name(p);
	}

    return (p + n);
}

//---------------------------------------------------------
//
//  Parse queue name string, (private, public)
//  N.B. queue name must end with either format name suffix
//      delimiter aka ';' or with end of string '\0'
//  Return next char to parse on success, 0 on failure.
//
static LPCWSTR ParseQueueNameString(LPCWSTR p, QUEUE_PATH_TYPE* pqpt)
{
    if(_wcsnicmp(p, FN_SYSTEM_QUEUE_PATH_INDICATIOR, FN_SYSTEM_QUEUE_PATH_INDICATIOR_LENGTH) == 0)
    {
        p += FN_SYSTEM_QUEUE_PATH_INDICATIOR_LENGTH;
        *pqpt = SYSTEM_QUEUE_PATH_TYPE;
        return p;
    }

    if(_wcsnicmp(p, FN_PRIVATE_QUEUE_PATH_INDICATIOR, FN_PRIVATE_QUEUE_PATH_INDICATIOR_LENGTH) == 0)
    {
        *pqpt = PRIVATE_QUEUE_PATH_TYPE;
        p += FN_PRIVATE_QUEUE_PATH_INDICATIOR_LENGTH;
    }
    else
    {
        *pqpt = PUBLIC_QUEUE_PATH_TYPE;
    }

    //
    //  Zero length queue name is illegal
    //
    if(*p == L'\0')
	{
		TrERROR(Fn, "Found zero length queue name in '%ls'.", p);
		throw bad_format_name(p);
	}

    while(
        (*p != L'\0') &&
        (*p != FN_SUFFIX_DELIMITER_C) &&
        (*p != FN_MQF_SEPARATOR_C)
        )
    {
		ValidateCharLegality(p);
        ++p;
    }

    return p;
}


//---------------------------------------------------------
//
//  Parse machine name in a path name
//  N.B. machine name must end with a path name delimiter aka slash '\\'
//  Return next char to parse on success, 0 on failure.
//
static LPCWSTR ParseMachineNameString(LPCWSTR p)
{
    //
    //  Zero length machine name is illegal
    //  don't fall off the string (p++)
    //
    if(*p == FN_DELIMITER_C)
	{
		TrERROR(Fn, "Found zero length machine name in '%ls'.", p);
		throw bad_format_name(p);
	}

    p = FindPathNameDelimiter(p);

    return (p + 1);
}


//---------------------------------------------------------
//
//  Check if this is an expandable machine path. i.e., ".\\"
//
inline BOOL IsExpandableMachinePath(LPCWSTR p)
{
    return ((p[0] == FN_LOCAL_MACHINE_C) && (p[1] == FN_DELIMITER_C));
}

//---------------------------------------------------------
//
//  Optionally expand a path name with local machine name.
//  N.B. expansion is done if needed.
//  return pointer to new/old string
//
static LPCWSTR ExpandPathName(LPCWSTR pStart, ULONG_PTR offset, LPWSTR* ppStringToFree)
{
    LPCWSTR pSeparator = wcschr(pStart, FN_MQF_SEPARATOR_C);
    LPWSTR pCopy;
    ULONG_PTR cbCopySize;

    if((ppStringToFree == 0) || !IsExpandableMachinePath(&pStart[offset]))
    {
        if (pSeparator == 0)
            return pStart;

        //
        // We are part of MQF, but no expansion needed - copy the rest of the string till the separator
        //

        cbCopySize = pSeparator - pStart + 1;
        pCopy = new WCHAR[cbCopySize];
        memcpy(pCopy, pStart, (cbCopySize-1)*sizeof(WCHAR));
    }
    else
    {
        size_t len;
    
        if (pSeparator != 0)
        {
            len = pSeparator - pStart;
        }
        else
        {
            len = wcslen(pStart);
        }

        cbCopySize = len + McComputerNameLen() + 1 - 1;
        pCopy = new WCHAR[cbCopySize];

        //
        //  copy prefix, till offset '.'
        //
        memcpy(
            pCopy,
            pStart,
            offset * sizeof(WCHAR)
            );

        //
        //  copy computer name to offset
        //
        memcpy(
            pCopy + offset,
            McComputerName(),
            McComputerNameLen() * sizeof(WCHAR)
            );

        //
        //  copy rest of string not including dot '.'
        //
        memcpy(
            pCopy + offset + McComputerNameLen(),
            pStart + offset + 1,                        // skip dot
            (len - offset - 1) * sizeof(WCHAR)      // skip dot
            );
    }

    pCopy[cbCopySize - 1] = '\0';

    *ppStringToFree = pCopy;
    return pCopy;
}


//---------------------------------------------------------
//
//  Parse OS direct format string. (check validity of path
//  name and optionally expand it)
//  ppDirectFormat - expended direct format string. (in out)
//  ppStringToFree - return string to free if needed.
//  Return next char to parse on success, 0 on failure.
//
static
LPCWSTR
ParseDirectOSString(
    LPCWSTR p, 
    LPCWSTR* ppDirectFormat, 
    LPWSTR* ppStringToFree,
    QUEUE_PATH_TYPE* pqpt
    )
{
    LPCWSTR pMachineName = p;
    LPCWSTR pStringToCopy = *ppDirectFormat;

    p = ParseMachineNameString(p);

    p = ParseQueueNameString(p, pqpt);

    *ppDirectFormat = ExpandPathName(pStringToCopy, (pMachineName - pStringToCopy), ppStringToFree);

    return p;
}

//---------------------------------------------------------
//
//  Parse net (tcp) address part of direct format string.
//  Return next char to parse on success, 0 on failure.
//
static LPCWSTR ParseNetAddressString(LPCWSTR p)
{
    //
    //  Zero length address string is illegal
    //  don't fall off the string (p++)
    //
    if(*p == FN_DELIMITER_C)
	{
		TrERROR(Fn, "Found zero length net address string in '%ls'.", p);
		throw bad_format_name(p);
	}

    p = FindPathNameDelimiter(p);

    return (p + 1);
}

//---------------------------------------------------------
//
//  Parse HTTP / HTTPS direct format string.
//  Return next char to parse on success, 0 on failure.
//
LPCWSTR
ParseDirectHttpString(
    LPCWSTR p,
    LPCWSTR* ppDirectFormat, 
    LPWSTR* ppStringToFree
    )
{
	size_t MachineNameOffset = p - *ppDirectFormat;

	//
	// Check host name is available
	//
    if(wcschr(FN_HTTP_SEPERATORS, *p) != 0)
	{
		TrERROR(Fn, "Found zero length host name in '%ls'.", p);
		throw bad_format_name(p);
	}

	for(; *p != L'\0' && *p != FN_SUFFIX_DELIMITER_C && *p != FN_MQF_SEPARATOR_C; p++)
	{
		NULL;
	}

    *ppDirectFormat = ExpandPathName(*ppDirectFormat, MachineNameOffset, ppStringToFree);

    return p;
}

//---------------------------------------------------------
//
//  Parse net (tcp) direct format string. (check validity of queue name)
//  Return next char to parse on success, 0 on failure.
//
static 
LPCWSTR 
ParseDirectNetString(
	LPCWSTR p, 
    LPCWSTR* ppDirectFormat, 
    LPWSTR* ppStringToFree,
	QUEUE_PATH_TYPE* pqpt
	)
{
    p = ParseNetAddressString(p);

    p = ParseQueueNameString(p, pqpt);

    if(wcschr(p, FN_MQF_SEPARATOR_C) == NULL)
		return p;

	//
	// This is an MQF. a copy is needed to seperate our format name.
	//

	size_t Length = p - *ppDirectFormat;    
	*ppStringToFree = new WCHAR[Length + 1];

    memcpy(*ppStringToFree, *ppDirectFormat, Length * sizeof(WCHAR));
	(*ppStringToFree)[Length] = L'\0';
	*ppDirectFormat = *ppStringToFree;

	return p;
}



static void RemoveSuffixFromDirect(LPCWSTR* ppDirectFormat, LPWSTR* ppStringToFree)
{
    ASSERT(ppStringToFree != NULL);

    LPCWSTR pSuffixDelimiter = wcschr(*ppDirectFormat, FN_SUFFIX_DELIMITER_C);
    ASSERT(pSuffixDelimiter != NULL);

    INT_PTR len = pSuffixDelimiter - *ppDirectFormat;
    LPWSTR pCopy = new WCHAR[len + 1];
    wcsncpy(pCopy, *ppDirectFormat, len);
    pCopy[len] = '\0';

    if (*ppStringToFree != NULL)
	{
        delete [] *ppStringToFree;
	}
    *ppDirectFormat = *ppStringToFree = pCopy;
}



inline bool IsPreviousCharDigit(LPCWSTR p, int index)
{
	return ((index > 0) && iswdigit(p[index - 1]));
}



inline bool IsNextCharDigit(LPCWSTR p, int index, int StrLength)
{
	return ((index + 1 < StrLength) && iswdigit(p[index + 1]));
}



LPCWSTR 
FnParseMulticastString(
    LPCWSTR p, 
    MULTICAST_ID* pMulticastID
	)
/*++
Routine description:
	Parses a multicast address in the form of <ip address>:<port number>
	to a MULTICAST_ID structure.

Return value:
	pointer to end of multicast address. Parsing can continue from there.

	Throws bad format name on failure.
--*/
{
	ASSERT(("Bad parameter", pMulticastID != NULL));

	int n;

	ULONG Byte1;
	ULONG Byte2;
	ULONG Byte3;
	ULONG Byte4;

	MULTICAST_ID MulticastID;

	size_t Result = swscanf(
						p, 
						L"%u.%u.%u.%u:%u%n",
						&Byte1,
						&Byte2,
						&Byte3,
						&Byte4,
						&MulticastID.m_port, 
						&n
						);
	if(Result < 5)
	{
		TrERROR(Fn, "Bad MulticastAddress in '%ls'", p);
		throw bad_format_name(p);
	}

	for(int i = 0; i < n; i++)
	{
		//
		// Check numbers have no leading zeroes
		// A zero is a leading zero if the character before it is not a digit and the
		// character after it is a digit.
		//

		if(!IsPreviousCharDigit(p, i) && p[i] == L'0' && IsNextCharDigit(p, i , n))
		{
			TrERROR(Fn, "Bad MulticastAddress. Leading zeroes in '%ls'", p);
			throw bad_format_name(p);
		}

		//
		// Check no whitespaces in address
		//

		if(iswspace(p[i]))
		{
			TrERROR(Fn, "Bad MulticastAddress. Spaces found in '%ls'", p);
			throw bad_format_name(p);
		}
	}

	//
	// Does either one of the bytes exceed 255?
	//
	if((Byte1 | Byte2 | Byte3 | Byte4) > 255)
	{
		TrERROR(Fn, "Bad IP in Multicast Address. Non byte values in '%ls'", p);
		throw bad_format_name(p);
	}

	if((Byte1 & 0xf0) != 0xe0)
	{
		TrERROR(Fn, "Bad IP in Multicast Address. Not a class D IP address in '%ls'", p);
		throw bad_format_name(p);
	}

	MulticastID.m_address = 
		(Byte4 << 24) | 
		(Byte3 << 16) |
		(Byte2 << 8)  |
		(Byte1);			
	
    //
    // Check that the port is a USHORT
    //
    USHORT port = static_cast<USHORT>(MulticastID.m_port);
    if (port != MulticastID.m_port)
    {
		TrERROR(Fn, "Bad port number in Multicast Address in '%ls'", p);
		throw bad_format_name(p);
    }

	*pMulticastID = MulticastID;

	return p + n;
}



//---------------------------------------------------------
//
//  Parse direct format string.
//  return expended direct format string.
//  return string to free if needed.
//  Return next char to parse on success, 0 on failure.
//
static 
LPCWSTR 
ParseDirectString(
    LPCWSTR p, 
    LPCWSTR* ppExpandedDirectFormat, 
    LPWSTR* ppStringToFree,
    QUEUE_PATH_TYPE* pqpt
    )
{
    *ppExpandedDirectFormat = p;

    DirectQueueType dqt;
    p = FnParseDirectQueueType(p, &dqt);

    switch(dqt)
    {
        case dtOS:
            p = ParseDirectOSString(p, ppExpandedDirectFormat, ppStringToFree, pqpt);
            break;

        case dtTCP:
            p = ParseDirectNetString(p, ppExpandedDirectFormat, ppStringToFree, pqpt);
            break;

        case dtHTTP:
        case dtHTTPS:
            p = ParseDirectHttpString(p, ppExpandedDirectFormat, ppStringToFree);
            break;

        default:
            ASSERT(0);
    }

    p = skip_ws(p);

    //
    // Remove suffix (like ;Journal)
    //
    if(*p == FN_SUFFIX_DELIMITER_C)
    {
		if(dqt == dtHTTP || dqt == dtHTTPS)
		{
			TrERROR(Fn, "Unsuported suffix in DIRECT HTTP format name '%ls'", p);
			throw bad_format_name(p);
		}

        RemoveSuffixFromDirect(ppExpandedDirectFormat, ppStringToFree);
    }
    return p;
}

//---------------------------------------------------------
//
//  Parse DL format string.
//  return string to free if needed.
//  Return next char to parse on success, 0 on failure.
//
static 
LPCWSTR 
ParseDlString(
    LPCWSTR p,
    GUID* pguid,
    LPWSTR* ppDomainName,
    LPWSTR* ppStringToFree
    )
{
    p = FnParseGuidString(p, pguid);

    *ppDomainName = 0;
    //
    // Check if we have a domain that comes with the DL
    //
    if (*p != FN_AT_SIGN_C)
    {
        return p;
    }
    p++;

    LPCWSTR pSeparator = wcschr(p, FN_MQF_SEPARATOR_C);
    if (pSeparator == 0)
    {
        *ppDomainName = const_cast<LPWSTR>(p);
        return p + wcslen(p);
    }

	//
	// We are to copy the domain name without trailing white spaces.
	//
	LPCWSTR pEndOfDomainString = skip_ws_bwd(pSeparator, p);
    ULONG_PTR cbCopyLen = pEndOfDomainString - p;

	if(cbCopyLen == 0)
	{
		//
		// No none white space characters were found after the '@' sign
		//
		TrERROR(Fn, "Domain name expected at '%ls'", p);
        throw bad_format_name(p);
	}

    ASSERT(ppStringToFree != 0);
    ASSERT(*ppStringToFree == 0);
	
    LPWSTR pCopy = new WCHAR[cbCopyLen + 1];
    memcpy(pCopy, p, cbCopyLen * sizeof(WCHAR));
    pCopy[cbCopyLen] = L'\0';

    *ppDomainName = *ppStringToFree = pCopy;

    return pSeparator;
}
    
    



//---------------------------------------------------------
//
//  Parse format name suffix string.
//  Return next char to parse on success, 0 on failure.
//
static LPCWSTR ParseSuffixString(LPCWSTR p, QUEUE_SUFFIX_TYPE& qst)
{
    const int unique = 5;
    //---------------01234v----------------------
    ASSERT(L'N' == FN_JOURNAL_SUFFIX    [unique]);
    ASSERT(L'L' == FN_DEADLETTER_SUFFIX [unique]);
    ASSERT(L'X' == FN_DEADXACT_SUFFIX   [unique]);
    ASSERT(L'O' == FN_XACTONLY_SUFFIX   [unique]);
    //---------------01234^----------------------

    //
    //  we already know that first character is ";"
    //
    ASSERT(*p == FN_SUFFIX_DELIMITER_C);

    //
    //  accelarate token recognition by checking 6th character
    //
    switch(towupper(p[unique]))
    {
        // ;jourNal
        case L'N':
            qst = QUEUE_SUFFIX_TYPE_JOURNAL;
            if(_wcsnicmp(p, FN_JOURNAL_SUFFIX, FN_JOURNAL_SUFFIX_LEN) == 0)
                return (p + FN_JOURNAL_SUFFIX_LEN);
            break;

        // ;deadLetter
        case L'L':
            qst = QUEUE_SUFFIX_TYPE_DEADLETTER;
            if(_wcsnicmp(p, FN_DEADLETTER_SUFFIX, FN_DEADLETTER_SUFFIX_LEN) == 0)
                return (p + FN_DEADLETTER_SUFFIX_LEN);
            break;

        // ;deadXact
        case L'X':
            qst = QUEUE_SUFFIX_TYPE_DEADXACT;
            if(_wcsnicmp(p, FN_DEADXACT_SUFFIX, FN_DEADXACT_SUFFIX_LEN) == 0)
                return (p + FN_DEADXACT_SUFFIX_LEN);
            break;

        // ;xactOnly
        case L'O':
            qst = QUEUE_SUFFIX_TYPE_XACTONLY;
            if(_wcsnicmp(p, FN_XACTONLY_SUFFIX, FN_XACTONLY_SUFFIX_LEN) == 0)
                return (p + FN_XACTONLY_SUFFIX_LEN);
            break;
    }

	TrERROR(Fn, "Found Bad suffix in '%ls'", p);
    throw bad_format_name(p);
}


//---------------------------------------------------------
//
//  Function:
//      ParseOneFormatName
//
//  Description:
//      Parses one format name string (stand alone or part of MQF) and converts it to a QUEUE_FORMAT union.
//
//---------------------------------------------------------
LPCWSTR
ParseOneFormatName(
    LPCWSTR p,            // pointer to format name string
    QUEUE_FORMAT* pqf,      // pointer to QUEUE_FORMAT
    LPWSTR* ppStringToFree  // pointer to allocated string need to free at end of use
    )                       // if null, format name will not get expanded
{
    QUEUE_FORMAT_TYPE qft;

    p = ParsePrefixString(p, qft);

    p = skip_ws(p);

    if(*p++ != FN_EQUAL_SIGN_C)
	{
		TrERROR(Fn, "Excpecting equal sign after format name prefix in '%ls'.", p);
		throw bad_format_name(p);
	}

    p = skip_ws(p);

    GUID guid;

    switch(qft)
    {
        //
        //  "PUBLIC=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\0"
        //
        case QUEUE_FORMAT_TYPE_PUBLIC:
            p = FnParseGuidString(p, &guid);
            pqf->PublicID(guid);
            break;

        //
        //  "PRIVATE=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\\xxxxxxxx\0"
        //
        case QUEUE_FORMAT_TYPE_PRIVATE:
            p = FnParseGuidString(p, &guid);
            p = skip_ws(p);

            if(*p++ != FN_PRIVATE_SEPERATOR_C)
			{
				TrERROR(Fn, "Excpecting private seperator in '%ls'.", p);
				throw bad_format_name(p);
			}

            p = skip_ws(p);

            ULONG uniquifier;
            p = ParsePrivateIDString(p, &uniquifier);

            pqf->PrivateID(guid, uniquifier);
            break;

        //
        //  "DIRECT=OS:bla-bla\0"
        //
        case QUEUE_FORMAT_TYPE_DIRECT:
		{
            LPCWSTR pExpandedDirectFormat;
            QUEUE_PATH_TYPE qpt = ILLEGAL_QUEUE_PATH_TYPE;
            p = ParseDirectString(p, &pExpandedDirectFormat, ppStringToFree, &qpt);

            if (qpt == SYSTEM_QUEUE_PATH_TYPE)
            {
                pqf->DirectID(const_cast<LPWSTR>(pExpandedDirectFormat), QUEUE_FORMAT_FLAG_SYSTEM);
            }
            else
            {
                pqf->DirectID(const_cast<LPWSTR>(pExpandedDirectFormat));
            }
            break;
		}

        //
        // MULTICAST=aaa.bbb.ccc.ddd
        //
        case QUEUE_FORMAT_TYPE_MULTICAST:
			{
				MULTICAST_ID MulticastID;
				p = FnParseMulticastString(p, &MulticastID);
				pqf->MulticastID(MulticastID);
				break;
			}

        //
        //  "MACHINE=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\0"
        //
        case QUEUE_FORMAT_TYPE_MACHINE:
            p = FnParseGuidString(p, &guid);

            pqf->MachineID(guid);
            break;

        //
        //  "CONNECTOR=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\0"
        //
        case QUEUE_FORMAT_TYPE_CONNECTOR:
            p = FnParseGuidString(p, &guid);

            pqf->ConnectorID(guid);
            break;

        case QUEUE_FORMAT_TYPE_DL:
            {
                DL_ID dlid;
                dlid.m_pwzDomain = 0;

                p = ParseDlString(
                    p,
                    &dlid.m_DlGuid,
                    &dlid.m_pwzDomain,
                    ppStringToFree
                    );

                pqf->DlID(dlid);
            }
              
            break;

        default:
            ASSERT(0);
    }

    p = skip_ws(p);

    //
    //  We're at end of string, return now.
    //  N.B. Machine format name *must* have a suffix
    //
    if(*p == L'\0' || *p == FN_MQF_SEPARATOR_C)
    {
        if (qft == QUEUE_FORMAT_TYPE_MACHINE)
		{
			TrERROR(Fn, "Found Machine format without a suffix '%ls'.", p);
			throw bad_format_name(p);
		}
        return p;
    }

    if(*p != FN_SUFFIX_DELIMITER_C)
	{
		TrERROR(Fn, "Expecting suffix delimiter in '%ls'.", p);
		throw bad_format_name(p);
	}

    QUEUE_SUFFIX_TYPE qst;
	LPCWSTR Suffix = p;

    p = ParseSuffixString(p, qst);

    p = skip_ws(p);

    //
    //  Only white space padding is allowed.
    //
    if(*p != L'\0' && *p != FN_MQF_SEPARATOR_C)
	{
		TrERROR(Fn, "Unexpected characters at end of format name '%ls'.", p);
		throw bad_format_name(p);
	}

    pqf->Suffix(qst);

    if (!pqf->Legal())
	{
		TrERROR(Fn, "Ilegal suffix in format name %ls", Suffix);
		throw bad_format_name(p);
	}
    return p;
}





//---------------------------------------------------------
//
//  Function:
//      FnFormatNameToQueueFormat
//
//  Description:
//      Convert a format name string to a QUEUE_FORMAT union.
//
//---------------------------------------------------------
BOOL
FnFormatNameToQueueFormat(
    LPCWSTR pfn,            // pointer to format name string
    QUEUE_FORMAT* pqf,      // pointer to QUEUE_FORMAT
    LPWSTR* ppStringToFree  // pointer to allocated string need to free at end of use
    )                       // if null, format name will not get expanded
{
	ASSERT(ppStringToFree != NULL);

	try
	{
		AP<WCHAR> StringToFree;

		LPCWSTR p = ParseOneFormatName(pfn, pqf, &StringToFree);

		if (*p != L'\0')
		{
			TrERROR(Fn, "Expected end of format name in '%ls'.", p);
			throw bad_format_name(p);
		}

		if(ppStringToFree != NULL)
		{
			*ppStringToFree = StringToFree.detach();
		}

		return TRUE;
	}
	catch(const bad_format_name&)
	{
		return FALSE;
	}
}

//---------------------------------------------------------
//
//  Function:
//      FnMqfToQueueFormats
//
//  Description:
//      Convert a format name string to an array of QUEUE_FORMAT unions (supports MQF).
//
//---------------------------------------------------------
BOOL
FnMqfToQueueFormats(
    LPCWSTR pfn,            // pointer to format name string
    AP<QUEUE_FORMAT> &pmqf,    // returned pointer to allocated QUEUE_FORMAT pointers array
    DWORD   *pnQueues,      // Number of queues in MQF format
    CStringsToFree &strsToFree // Holding buffers of strings to be free
    )
{
	ASSERT(("Null out pointer supplied to function.", (pnQueues != NULL)));
	ASSERT(("Out argument is already in use.", pmqf.get() == NULL));
	
    *pnQueues = 0;

    AP<QUEUE_FORMAT> QueuesArray;
    DWORD nQueues = 0;
    DWORD nQueueFormatAllocated = 0;

    LPCWSTR p;
    for (p=pfn;; p++)
    {
        QUEUE_FORMAT qf;
        AP<WCHAR> StringToFree;

        try
		{
			p = ParseOneFormatName(p, &qf, &StringToFree);
		}
		catch(const bad_format_name&)
		{
			return FALSE;
		}

        strsToFree.Add(StringToFree.detach());

        if (nQueueFormatAllocated <= nQueues)
        {
            DWORD nOldAllocated = nQueueFormatAllocated;
            nQueueFormatAllocated = nQueueFormatAllocated*2 + 1;
            QUEUE_FORMAT* tempQueuesArray = new QUEUE_FORMAT[nQueueFormatAllocated];
            memcpy(tempQueuesArray, QueuesArray, nOldAllocated*sizeof(QUEUE_FORMAT));
            delete [] QueuesArray.detach();

            QueuesArray = tempQueuesArray;
        }

        QueuesArray[nQueues] = qf;
        nQueues++;

        if (*p == L'\0')
        {
            break;
        }

        ASSERT(*p == FN_MQF_SEPARATOR_C);
    }

    pmqf = QueuesArray.detach();
    *pnQueues = nQueues;

    return TRUE;
}


//---------------------------------------------------------
//
//  Function:
//      RTpGetQueuePathType
//
//  Description:
//      Validate, Expand and return type for Path Name.
//
//---------------------------------------------------------
QUEUE_PATH_TYPE
FnValidateAndExpandQueuePath(
    LPCWSTR pwcsPathName,
    LPCWSTR* ppwcsExpandedPathName,
    LPWSTR* ppStringToFree
    )
{
    ASSERT(ppStringToFree != 0);

    LPCWSTR pwcsPathNameNoSpaces = pwcsPathName;
    AP<WCHAR> pStringToFree;
    *ppStringToFree = 0;

    //
    // Remove leading white spaces
    //
    while (*pwcsPathNameNoSpaces != 0 && iswspace(*pwcsPathNameNoSpaces))
    {
        pwcsPathNameNoSpaces++;
    }

    //
    // Remove trailing white spaces
    //
    DWORD dwLen = wcslen(pwcsPathNameNoSpaces);
    if (iswspace(pwcsPathNameNoSpaces[dwLen-1]))
    {
        pStringToFree = new WCHAR[dwLen+1];
        wcscpy(pStringToFree, pwcsPathNameNoSpaces);
        for (DWORD i = dwLen; i-- > 0; )
        {
            if (iswspace(pStringToFree[i]))
            {
                pStringToFree[i] = 0;
            }
            else
            {
                break;
            }
        }
        pwcsPathNameNoSpaces = pStringToFree;
    }

    LPCWSTR p = pwcsPathNameNoSpaces;
	QUEUE_PATH_TYPE qpt;


	try
	{
	    p = ParseMachineNameString(p);
		p = ParseQueueNameString(p, &qpt);
	}
	catch(const bad_format_name&)
	{
		return ILLEGAL_QUEUE_PATH_TYPE;
	}

    //
    //  No characters are allowed at end of queue name.
    //
    if(*p != L'\0')
        return ILLEGAL_QUEUE_PATH_TYPE;

    *ppwcsExpandedPathName = ExpandPathName(pwcsPathNameNoSpaces, 0, ppStringToFree);

    //
    // if ExpandPathName does not return a string to free, we will
    // give the caller the string we allocated, so the caller will free it.
    // Otherwise, we will do nothing and "our" string will be auto-release.
    //
    if (*ppStringToFree == 0)
    {
        *ppStringToFree = pStringToFree.detach();
    }

    return (qpt);
}


//+-------------------------------------------
//
//  CStringsToFree implementation
//
//+-------------------------------------------
CStringsToFree::CStringsToFree() :
    m_nStringsToFree(0), 
    m_nStringsToFreeAllocated(0)
    {}

void 
CStringsToFree::Add(
    LPWSTR pStringToFree
    )
{
    if(pStringToFree == 0)
        return;

    if (m_nStringsToFree >= m_nStringsToFreeAllocated)
    {
        m_nStringsToFreeAllocated = m_nStringsToFreeAllocated*2 + 1;
        AP<WCHAR>* tempPstringsBuffer = new AP<WCHAR>[m_nStringsToFreeAllocated];
        for (size_t i=0; i<m_nStringsToFree; i++)
        {
            tempPstringsBuffer[i] = m_pStringsBuffer[i].detach();
        }

        delete [] m_pStringsBuffer.detach();

        m_pStringsBuffer = tempPstringsBuffer;
    }
    m_pStringsBuffer[m_nStringsToFree] = pStringToFree;   
    m_nStringsToFree++;
}


//---------------------------------------------------------
//
//  Function:
//      RTpIsHttp
//
//  Description:
//      Decide if this is an http format
//		check for "DIRECT=http://" or "DIRECT=https://" 
//		case insensitive of "DIRECT", "http" or "https" and white space insensitive
//
//---------------------------------------------------------
bool
FnIsHttpFormatName(
    LPCWSTR p            // pointer to format name string
    )
{
    QUEUE_FORMAT_TYPE qft;

	try
	{
		p = ParsePrefixString(p, qft);
	}
	catch(const bad_format_name&)
	{
		return false;
	}	

	//
	// DIRECT
	//
	if(qft != QUEUE_FORMAT_TYPE_DIRECT)
		return(false);

    p = skip_ws(p);

    if(*p++ != FN_EQUAL_SIGN_C)
        return(false);

    p = skip_ws(p);

	//
	// http
	//
	bool fIsHttp = (_wcsnicmp(
						p, 
						FN_DIRECT_HTTP_TOKEN, 
						FN_DIRECT_HTTP_TOKEN_LEN
						) == 0);

	if(fIsHttp)
		return(true);

	//
	// https
	//
	bool fIsHttps = (_wcsnicmp(
						p, 
						FN_DIRECT_HTTPS_TOKEN, 
						FN_DIRECT_HTTPS_TOKEN_LEN
						) == 0);


	return(fIsHttps);
}
   
VOID
FnExtractMachineNameFromPathName(
	LPCWSTR PathName, 
	AP<WCHAR>& MachineName
	)
/*++

  Routine Description:
	The routine extracts the machine name from the Path-Name

  Arguments:
	- Path name that should be extracted
	- Buffer to copy the machine name

  Arguments:
	None.

  NOTE:
	It is the user responsiblity to supply buffer big enough
 --*/
{
    LPWSTR FirstDelimiter = wcschr(PathName, FN_DELIMITER_C);

	if(FirstDelimiter == NULL)
	{
		TrERROR(Fn, "Pathname without delimiter '%ls'", PathName);
		throw bad_format_name(PathName);
	}
		
	size_t Length = FirstDelimiter - PathName;

	MachineName = new WCHAR[Length + 1];

    wcsncpy(MachineName.get(), PathName, Length);
    MachineName.get()[Length] = L'\0';
}

VOID
FnExtractMachineNameFromDirectPath(
	LPCWSTR PathName, 
	AP<WCHAR>& MachineName
	)
{
    LPWSTR FirstDelimiter = wcspbrk(PathName, FN_HTTP_SEPERATORS FN_HTTP_PORT_SEPERATOR);

	if(FirstDelimiter == NULL)
	{
		TrERROR(Fn, "Pathname without delimiter '%ls'", PathName);
		throw bad_format_name(PathName);
	}
		
	size_t Length = FirstDelimiter - PathName;

	MachineName = new WCHAR[Length + 1];

    wcsncpy(MachineName.get(), PathName, Length);
    MachineName.get()[Length] = L'\0';
}

//---------------------------------------------------------
//
//  Parse direct token type infix string.
//  Return next char to parse on success, 0 on failure.
//
LPCWSTR 
FnParseDirectQueueType(
	LPCWSTR p,
	DirectQueueType* dqt
	)
{
	ASSERT(("Bad parameters", p != NULL && dqt != NULL));

    const int unique = 0;
    //-----------------------v-------------------
    ASSERT(L'O' == FN_DIRECT_OS_TOKEN   [unique]);
    ASSERT(L'T' == FN_DIRECT_TCP_TOKEN  [unique]);
    ASSERT(L'H' == FN_DIRECT_HTTP_TOKEN [unique]);
    ASSERT(L'H' == FN_DIRECT_HTTPS_TOKEN[unique]); 
    //-----------------------^-------------------

    //
    //  accelarate token recognition by checking 1st character
    //
    switch(towupper(p[unique]))
    {
        // Os:
        case L'O':
            if(_wcsnicmp(p, FN_DIRECT_OS_TOKEN, FN_DIRECT_OS_TOKEN_LEN) == 0)
			{
				*dqt = dtOS;
                return p + FN_DIRECT_OS_TOKEN_LEN;
			}
            break;

        // Tcp:
        case L'T':
            if(_wcsnicmp(p, FN_DIRECT_TCP_TOKEN, FN_DIRECT_TCP_TOKEN_LEN) == 0)
			{
				*dqt = dtTCP;
                return p + FN_DIRECT_TCP_TOKEN_LEN;
			}
            break;

        // http:// or https://
        case L'H':
			if (!_wcsnicmp(p, FN_DIRECT_HTTPS_TOKEN, FN_DIRECT_HTTPS_TOKEN_LEN))
			{
				*dqt = dtHTTPS;
				return p + FN_DIRECT_HTTPS_TOKEN_LEN;
			}
			if (!_wcsnicmp(p, FN_DIRECT_HTTP_TOKEN, FN_DIRECT_HTTP_TOKEN_LEN))
			{
				*dqt = dtHTTP;
				return p + FN_DIRECT_HTTP_TOKEN_LEN;
			}
			break;

		default:
			break;
    }

	TrERROR(Fn, "Failed parsing direct token string in '%ls'.", p);
    throw bad_format_name(p);
}


static
BOOL
IsSeperator(
	WCHAR c
	)
{
	return (c == FN_DELIMITER_C || c == L'/');
}


VOID
FnDirectIDToLocalPathName(
	LPCWSTR DirectID, 
	LPCWSTR LocalMachineName, 
	AP<WCHAR>& PathName
	)
{
    DirectQueueType QueueType;
	LPCWSTR p = FnParseDirectQueueType(DirectID, &QueueType);

    if(QueueType == dtHTTP || QueueType == dtHTTPS)
    {
		p = wcspbrk(p, FN_HTTP_SEPERATORS);
		if(p == NULL)
		{
			TrERROR(Fn, "Failed to find url delimiter in '%ls'.", DirectID);
			throw bad_format_name(DirectID);
		}

		p++;
        //
        // skip '\msmq' prefix to queue name in http format name
        //
        if(_wcsnicmp(p, FN_MSMQ_HTTP_NAMESPACE_TOKEN, FN_MSMQ_HTTP_NAMESPACE_TOKEN_LEN) != 0
			|| !IsSeperator(p[FN_MSMQ_HTTP_NAMESPACE_TOKEN_LEN]))
		{
			TrERROR(Fn, "Missing '\\MSMQ\\' namespace token '%ls'.", DirectID);
			throw bad_format_name(DirectID);
		}

		//
		// This section converts the possilble slashes in ".../[private$/]..." that are legal 
		// in http format name to "...\[private$\]..." 
		//

		p += FN_MSMQ_HTTP_NAMESPACE_TOKEN_LEN + 1;

		size_t LocalMachineNameLen = wcslen(LocalMachineName);
		size_t Length = LocalMachineNameLen + 1 + wcslen(p);

		PathName = new WCHAR[Length + 1];

		wcscpy(PathName.get(), LocalMachineName);
		wcscat(PathName.get(), L"\\");
		wcscat(PathName.get(), p);

		const WCHAR PrivateKeyword[] = L"PRIVATE$/";
		ASSERT(STRLEN(PrivateKeyword) == FN_PRIVATE_QUEUE_PATH_INDICATIOR_LENGTH);

        if(_wcsnicmp(PathName.get() + LocalMachineNameLen + 1, PrivateKeyword, STRLEN(PrivateKeyword)) == 0)
		{
			wcsncpy(PathName.get() + LocalMachineNameLen + 1, FN_PRIVATE_QUEUE_PATH_INDICATIOR, FN_PRIVATE_QUEUE_PATH_INDICATIOR_LENGTH);
		}

		CharLower(PathName.get());

		return;
    }

	p = wcschr(p, FN_DELIMITER_C);
	if(p == NULL)
	{
		TrERROR(Fn, "Failed to find path delimiter in '%ls'.", DirectID);
		throw bad_format_name(DirectID);
	}

	size_t Length = wcslen(LocalMachineName) + wcslen(p);

	PathName = new WCHAR[Length + 1];

	wcscpy(PathName.get(), LocalMachineName);
	wcscat(PathName.get(), p);

	CharLower(PathName.get());
}

bool
FnIsPrivatePathName(
	LPCWSTR PathName
	)
{
	LPCWSTR p = wcschr(PathName, FN_DELIMITER_C);

	ASSERT(("Pathname without '\\' delimiter.", p != NULL));

    return _wcsnicmp(
				p + 1,
                FN_PRIVATE_QUEUE_PATH_INDICATIOR,
                FN_PRIVATE_QUEUE_PATH_INDICATIOR_LENGTH
				) == 0;
}

bool
FnIsHttpDirectID(
	LPCWSTR p
	)
{
	try
	{
		DirectQueueType QueueType;
		FnParseDirectQueueType(p, &QueueType);

		return (QueueType == dtHTTP || QueueType == dtHTTPS);
	}
	catch(const exception&)
	{
		return false;
	}
}

static
bool
FnpIsHttpsUrl(LPCWSTR url)
{
	return (_wcsnicmp(url, FN_DIRECT_HTTPS_TOKEN, STRLEN(FN_DIRECT_HTTPS_TOKEN) ) == 0);		
}


static
bool
FnpIsHttpsUrl(
	const xwcs_t& url
	)
{
	if(url.Length() <  STRLEN(FN_DIRECT_HTTPS_TOKEN))
		return false;

	return (_wcsnicmp(url.Buffer(), FN_DIRECT_HTTPS_TOKEN, STRLEN(FN_DIRECT_HTTPS_TOKEN) ) == 0);		
}


static
bool
FnpIsHttpUrl(
	LPCWSTR url
	)
{
	return (_wcsnicmp(url, FN_DIRECT_HTTP_TOKEN, STRLEN(FN_DIRECT_HTTP_TOKEN) ) == 0);		
}


static
bool
FnpIsHttpUrl(
	const xwcs_t& url
	)
{
	if(url.Length() <  STRLEN(FN_DIRECT_HTTP_TOKEN))
		return false;

	return (_wcsnicmp(url.Buffer(), FN_DIRECT_HTTP_TOKEN, STRLEN(FN_DIRECT_HTTP_TOKEN) ) == 0);		
}


//
// Is given url string is http or https url (starts with http:// or https://)
//
bool FnIsHttpHttpsUrl(
				LPCWSTR url
				)
{
	return FnpIsHttpUrl(url) || FnpIsHttpsUrl(url);	
}

//
// Is given url string buffer is http or https url (starts with "http://" or "https://")
//
bool 
FnIsHttpHttpsUrl
		(
	const xwcs_t& url
	)
{	
	return FnpIsHttpUrl(url) || FnpIsHttpsUrl(url);
}


//
// Is given url string is MSMQ url (starts with "MSMQ:")
//
bool 
FnIsMSMQUrl
		(
	LPCWSTR url
	)
{
	return (_wcsnicmp(url, FN_MSMQ_URI_PREFIX_TOKEN, FN_MSMQ_URI_PREFIX_TOKEN_LEN)) == 0;
}

//
// Is given url string buffer is MSMQ url (starts with "MSMQ:")
//
bool 
FnIsMSMQUrl
		(
	const xwcs_t& url
	)
{
	if(url.Length() <  FN_MSMQ_URI_PREFIX_TOKEN_LEN )
		return false;

	return _wcsnicmp(url.Buffer(), FN_MSMQ_URI_PREFIX_TOKEN, FN_MSMQ_URI_PREFIX_TOKEN_LEN ) == 0;
}


bool FnIsDirectHttpFormatName(const QUEUE_FORMAT* pQueueFormat)
/*++

Routine Description:
		check if given format name is direct http or direct https
	
Arguments:
    IN - pQueueFormat - format name to test

Return - true if the given format namr is http or https - false otherwise.
*/
{
	if(pQueueFormat->GetType() != QUEUE_FORMAT_TYPE_DIRECT)
	{
		return false;	
	}
 	return FnIsHttpDirectID(pQueueFormat->DirectID());
}



LPCWSTR  
FnFindResourcePath(
	LPCWSTR url
	)
/*++

Routine Description:
		Find  resource path in uri.
	
Arguments:
    IN - uri (absolute or relative)

Return - pointer to local resource path.
for example :
url = "http://host/msmq\q" - the function returns pointer to "host/msmq\"
url = /msmq\q - the function returns pointer to "/msmq\q".

*/
{	LPCWSTR ptr = url;
	if(FnpIsHttpUrl(ptr))
	{
		ptr += FN_DIRECT_HTTP_TOKEN_LEN;
	}
	else
	if(FnpIsHttpsUrl(ptr))
	{
		ptr += FN_DIRECT_HTTPS_TOKEN_LEN;
	}
	
	return ptr;
}


static bool IsSlashOrBackSlash(WCHAR c)
{
	return (c == FN_PRIVATE_SEPERATOR_C || c == FN_HTTP_SEPERATOR_C);
}


bool
FnAbsoluteMsmqUrlCanonization(
	LPWSTR url
	)throw()
/*++

Routine Description:
		Convert all '\' sperator in given msmq url to '/'
	
Arguments:
    IN - url - Absolute msmq url (http://host\msmq\private$\q )

    Example :
	http://host\msmq\private$\q  -> http://host/msmq/private$/q

Return value - true if the url transfered to canonical form - false if bad MSMQ url format. 

*/
{
	LPWSTR ptr = url;

	if(FnpIsHttpUrl(ptr))
	{
		ptr += FN_DIRECT_HTTP_TOKEN_LEN;
	}
	else
	if(FnpIsHttpsUrl(ptr))
	{
		ptr += FN_DIRECT_HTTPS_TOKEN_LEN;
	}

	//
	// if not http pr https - bad format
	//
	if(ptr ==  url)
		return false;
	

	//
	// search for MSMQ string
	//
	LPWSTR urlend =  url + wcslen(url);
	ptr = std::search(
		ptr,
		urlend,
		FN_MSMQ_HTTP_NAMESPACE_TOKEN,
		FN_MSMQ_HTTP_NAMESPACE_TOKEN + FN_MSMQ_HTTP_NAMESPACE_TOKEN_LEN	,
		UtlCharNocaseCmp<WCHAR>()
	 );


	//
	// No msmq string - bad format.
	//
	if(ptr == urlend)
		return false;
	

	//
	// Replace the '\' before "MSMQ"  string
	//
	if(!IsSlashOrBackSlash(*(ptr -1)))
		return false;

 	if( *(ptr -1) == FN_PRIVATE_SEPERATOR_C )
	{
		*(ptr - 1) =	FN_HTTP_SEPERATOR_C;	
	}

	//
	// Replace the '\' after "MSMQ"  string
	//
	ptr +=  FN_MSMQ_HTTP_NAMESPACE_TOKEN_LEN;
	if(!IsSlashOrBackSlash(*(ptr)))
		return false;
  
	if( *(ptr) == FN_PRIVATE_SEPERATOR_C )
	{
		*(ptr) = FN_HTTP_SEPERATOR_C;	
	}

	//
	//
	// check if private queue format ("private$" in the url)
	++ptr;
	bool fPrivate = UtlIsStartSec(
		ptr,
		urlend,
		FN_PRIVATE_$_TOKEN,
		FN_PRIVATE_$_TOKEN + FN_PRIVATE_$_TOKEN_LEN,
		UtlCharNocaseCmp<WCHAR>()
		);

	
	if(!fPrivate)
		return true;

	
	ptr += FN_PRIVATE_$_TOKEN_LEN;
  
	//
	// Replace the '\' after "private$"  string
	//
	if(!IsSlashOrBackSlash(*(ptr)))
		return false;

	if( *(ptr) == FN_PRIVATE_SEPERATOR_C )
	{
		*(ptr) = FN_HTTP_SEPERATOR_C;	
	}
	return true;
}


bool
FnIsValidQueueFormat(
	const QUEUE_FORMAT* pQueueFormat
	)
{
    ASSERT(FnpIsInitialized());

	if (!pQueueFormat->IsValid())
	{
		return false;
	}

	//
	// For non-direct format names no parsing is needed
	//
	if (pQueueFormat->GetType() != QUEUE_FORMAT_TYPE_DIRECT)
	{
		return true;
	}

	//
	// Validate direct format name 
	//
	try
	{
		AP<WCHAR> pStringToFree;
		LPCWSTR pExpandedDirectFormat;
		QUEUE_PATH_TYPE qpt = ILLEGAL_QUEUE_PATH_TYPE;

		ParseDirectString(pQueueFormat->DirectID(), &pExpandedDirectFormat, &pStringToFree, &qpt);
	}
	catch(const exception&)
	{
		return false;
	}

	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\fn\test\fntest.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    FnTest.cpp

Abstract:
    Format Name Parsing library test

Author:
    Nir Aides (niraides) 21-May-00

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include <activeds.h>
#include "mqwin64a.h"
#include "qformat.h"
#include "fntoken.h"
#include "FnGeneral.h"
#include "Fn.h"
#include "FnIADs.h"

#include "FnTest.tmh"

using namespace std;


const TraceIdEntry FnTest = L"Format Name Parsing Test";

#define LDAP_ADSPATH_PREFIX L"LDAP://"
#define CLASS_NAME_QUEUE L"msMQQueue"
#define CLASS_NAME_ALIAS L"msMQ-Custom-Recipient"
#define CLASS_NAME_GROUP L"group"



/*static void Usage()
{
    printf("Usage: FnTest [*switches*]\n");
    printf("\t*-s*\t*Switch description*\n");
    printf("\n");
    printf("Example, FnTest -switch\n");
    printf("\t*example description*\n");
    exit(-1);

} // Usage
*/



VARIANT String2Variant(LPCWSTR Str)
{
	BSTR bstr = SysAllocString(Str);

	if(bstr == NULL)
	{
		TrERROR(FnTest, "Failed string allocation");
		throw bad_alloc();
	}
 
	VARIANT var;
	VariantInit(&var);
	
	V_VT(&var) = VT_BSTR;
	V_BSTR(&var) = bstr;
		
	return var;
}



VARIANT Array2Variant(LPCWSTR Members[], long nMembers)
{
    SAFEARRAYBOUND rgsabound[1];
    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = nMembers;

	SAFEARRAY* sa = SafeArrayCreate( 
						VT_VARIANT,   //VARTYPE  vt,                     
						1,			 //unsigned int  cDims,             
						rgsabound	//SAFEARRRAYBOUND *  rgsabound  
						);

	if(sa == NULL)
	{
		TrERROR(FnTest, "Failed SafeArrayCreate()");
		throw bad_alloc();
	}
 
	long indice[1] = {0};
	long& idx = indice[0];

	for(; idx < nMembers; idx++)
	{
		VARIANTWrapper VarItem;
		
		BSTR bstr = SysAllocString(Members[idx]);

		if(bstr == NULL)
		{
			TrERROR(FnTest, "Failed SysAllocString(Members[idx])");
			throw bad_alloc();
		}
 
		V_VT(&VarItem) = VT_BSTR;
		V_BSTR(&VarItem) = bstr;
		
		HRESULT hr = SafeArrayPutElement(sa, indice, &VarItem);
		if(FAILED(hr))
		{
			TrERROR(FnTest, "Failed SafeArrayPutElement(sa, indice, &VarItem)");
			throw bad_alloc();
		}
	}

	VARIANT var;
	VariantInit(&var);
	
	V_VT(&var) = VT_ARRAY | VT_VARIANT;
	V_ARRAY(&var) = sa;

	return var;
}



GUID String2Guid(LPCWSTR GuidStr)
{
    GUID Guid = {0};
	UINT Data[16];

    DWORD nFields = swscanf(
						GuidStr,
						LDAP_GUID_FORMAT,
						LDAP_SCAN_GUID_ELEMENTS(Data)
						);    
	if(nFields != 16)
	{
		TrERROR(FnTest, "Bad Guid string format, in String2Guid()");
		throw exception();
    }

	for(size_t i = 0; i < 16; i++)
	{
		((BYTE*)&Guid)[i] = (BYTE)(Data[i]);
	}

 	return Guid;
}



VOID TestExpandMqf()
/*++

Routine Description:
	For this purpose we construct a tree of objects in a simulated Directory

                        DL0
                      / /\ \
                    /  |  |   \ 
                  /    |  |      \
                /     /    \        \
           Queue0   DL1   Queue2      DL2 
                  / /| \             /\ \ \	
               /   / |  \           |  |  \   \
            /     /  |   \          |  |    \     \
         /       /   |    \        /    \     \       \
	Computer Alias0 DL0 Queue1  Printer  DL3   Queue4  Alias0
                                       / /|\ \
                                     /  / | \   \ 
                                   /   /  |  \     \
                                 /    /   |   \       \
                            Queue1 User Alias1 Queue3  DL1
							
  
	This tree is actually a graph with circles, and contains unsupported objects.

	After the expansion, we should have an array with the 5 queues from Queue0
	to Queue4.

--*/
{
	//
	// CoInitialize() and CoUninitialize() are not needed for the test, 
	// but should be invoked when using the library
	//
    //	HRESULT hr;
	//	hr = CoInitialize(NULL);
    //	if(FAILED(hr)) 
	//	{
	//		TrERROR(FnTest, "Failed CoInitialize() with status %d", hr);
	//		throw exception();
	//	}
	
	//
	// --------------- Test queues definitions ----------------
	//

	CObjectData Queue[5] = {
		{
			LDAP_ADSPATH_PREFIX L"CN=Queue0",
			L"CN=Queue0",
			CLASS_NAME_QUEUE,
			L"00112233445566778899aabbccdd0000"
		},
		{
			LDAP_ADSPATH_PREFIX L"CN=Queue1",
			L"CN=Queue1",
			CLASS_NAME_QUEUE,
			L"00112233445566778899aabbccdd0001"
		},
		{
			LDAP_ADSPATH_PREFIX L"CN=Queue2",
			L"CN=Queue2",
			CLASS_NAME_QUEUE,
			L"00112233445566778899aabbccdd0002"
		},
		{
			LDAP_ADSPATH_PREFIX L"CN=Queue3",
			L"CN=Queue3",
			CLASS_NAME_QUEUE,
			L"00112233445566778899aabbccdd0003"
		},
		{
			LDAP_ADSPATH_PREFIX L"CN=Queue4",
			L"CN=Queue4",
			CLASS_NAME_QUEUE,
			L"00112233445566778899aabbccdd0004"
		}
	};

	CreateADObject(Queue[0]);
	CreateADObject(Queue[1]);
	CreateADObject(Queue[2]);
	CreateADObject(Queue[3]);
	CreateADObject(Queue[4]);

	//
	// --------------- Test Alias definitions -------------------
	//

	CObjectData Alias[2] = {
		{
			LDAP_ADSPATH_PREFIX L"CN=Alias0",
			L"CN=Alias0",
			CLASS_NAME_ALIAS,
			L"00112233445566778899aabbccdd0300"
		},
		{
			LDAP_ADSPATH_PREFIX L"CN=Alias1",
			L"CN=Alias1",
			CLASS_NAME_ALIAS,
			L"00112233445566778899aabbccdd0301"
		}
	};

	LPCWSTR AliasFormatName[] = {
		L"DIRECT=OS:host\\private$\\queue0", 
		L"DIRECT=OS:host\\private$\\queue1"
	};

	R<CADInterface> Alias0 = CreateADObject(Alias[0]);
	R<CADInterface> Alias1 = CreateADObject(Alias[1]);

	try
	{
		Alias0->TestPut(
			L"msMQ-Recipient-FormatName", 
			String2Variant(AliasFormatName[0])
			);
		Alias1->TestPut(
			L"msMQ-Recipient-FormatName", 
			String2Variant(AliasFormatName[1])
			);
	}
	catch(const exception&)
	{
		TrERROR(FnTest, "CADObject::TestPut() threw an exception()");
		throw;
	}

	//
	// --------------- Test DLs definitions -------------------
	//

	CObjectData DL[4] = {
		//
		// Note that first DL's ADsPath value is a Guid path (LDAP://<GUID=...>).
		// This is since it is the root DL, and as such is passed to FnExpandMqf()
		// in the TopLevelMqf array, as a QUEUE_FORMAT object.
		// 
		// Inside FnExpandMqf(), its GUID is extracted and form it the ADsPath
		// is constructed. thus, the ADsPath is based on a GUID.
		//
		{
			LDAP_ADSPATH_PREFIX L"<GUID=00112233445566778899aabbccdd0100>" ,
			L"<GUID=00112233445566778899aabbccdd0100>",
			CLASS_NAME_GROUP,
			L"00112233445566778899aabbccdd0100"
		},
		{
			LDAP_ADSPATH_PREFIX L"CN=DL1",
			L"CN=DL1",
			CLASS_NAME_GROUP,
			L"00112233445566778899aabbccdd0101"
		},
		{
			LDAP_ADSPATH_PREFIX L"CN=DL2",
			L"CN=DL2",
			CLASS_NAME_GROUP,
			L"00112233445566778899aabbccdd0102"
		},
		{
			LDAP_ADSPATH_PREFIX L"CN=DL3",
			L"CN=DL3",
			CLASS_NAME_GROUP,
			L"00112233445566778899aabbccdd0103"
		}
	};

	R<CADInterface> DLObject[4] = {
		CreateADObject(DL[0]),
		CreateADObject(DL[1]),
		CreateADObject(DL[2]),
		CreateADObject(DL[3])
	};

	//
	// ----------- Test unsupported objects definitions ----------
	//

	//
	// UO stands for Unsupported Objects
	//

	CObjectData Computer = 
	{
		LDAP_ADSPATH_PREFIX L"CN=Computer",
		L"CN=Computer",
		L"Computer",
		L"00112233445566778899aabbccdd0200"
	};

	CObjectData Printer = 
	{
			LDAP_ADSPATH_PREFIX L"CN=Printer",
			L"CN=Printer",
			L"Printer",
			L"00112233445566778899aabbccdd0201"
	};

	CObjectData User = 
	{
			LDAP_ADSPATH_PREFIX L"CN=User",
			L"CN=User",
			L"User",
			L"00112233445566778899aabbccdd0202"
	};

	CreateADObject(Computer);
	CreateADObject(Printer);
	CreateADObject(User);

	//
	// ---------------- Membership definitions -----------------
	//

	try
	{
		LPCWSTR Dl0Members[] = {
			Queue[0].odDistinguishedName,
			DL[1].odDistinguishedName,
			Queue[2].odDistinguishedName,
			DL[2].odDistinguishedName
		};

		DLObject[0]->TestPut(L"member", Array2Variant(Dl0Members, TABLE_SIZE(Dl0Members)));

		LPCWSTR Dl1Members[] = {
			Computer.odDistinguishedName,
			Alias[0].odDistinguishedName,
			DL[0].odDistinguishedName,
			Queue[1].odDistinguishedName
		};

		DLObject[1]->TestPut(L"member", Array2Variant(Dl1Members, TABLE_SIZE(Dl1Members)));

		LPCWSTR Dl2Members[] = {
			Printer.odDistinguishedName,
			DL[3].odDistinguishedName,
			Queue[4].odDistinguishedName,
			Alias[0].odDistinguishedName
		};

		DLObject[2]->TestPut(L"member", Array2Variant(Dl2Members, TABLE_SIZE(Dl2Members)));

		LPCWSTR Dl3Members[] = {
			Queue[1].odDistinguishedName,
			User.odDistinguishedName,
			Alias[1].odDistinguishedName,
			Queue[3].odDistinguishedName,
			DL[1].odDistinguishedName,
		};

		DLObject[3]->TestPut(L"member", Array2Variant(Dl3Members, TABLE_SIZE(Dl3Members)));
	}
	catch(const exception&)
	{
		TrERROR(FnTest, "CADObject::TestPut() threw an exception()");
		throw;
	}

	//
	// --------------- Call FnExpandMqf() ------------------
	//

	DL_ID dlid;
	dlid.m_pwzDomain = NULL;
	dlid.m_DlGuid = String2Guid(DL[0].odGuid);

	QUEUE_FORMAT TopLevelMqf[] = {
		QUEUE_FORMAT(dlid)
	};

	QUEUE_FORMAT* pLeafMqf;
	ULONG nLeafMqf;

	FnExpandMqf(TABLE_SIZE(TopLevelMqf), TopLevelMqf, &nLeafMqf, &pLeafMqf);

	if(nLeafMqf != 7)
	{
		TrERROR(FnTest, "Array Returned Does not contain 7 QueueFormats.");
		throw exception();
	}

	//
	// Check the array contains Queue[0]...Queue[4], in that order
	//

	for(int i = 0; i < 5; i++)
	{
		if(pLeafMqf[i].GetType() != QUEUE_FORMAT_TYPE_PUBLIC)
		{
			TrERROR(FnTest, "Queue Format is not public.");
			throw exception();
		}

		WCHAR GuidStr[MAX_PATH];
		GUID Guid = pLeafMqf[i].PublicID();

		_snwprintf(
			GuidStr,
			MAX_PATH,
			LDAP_GUID_FORMAT,
			LDAP_PRINT_GUID_ELEMENTS(((BYTE*)&Guid))
		);

		if(wcscmp(GuidStr, Queue[i].odGuid) != 0)
		{
			TrERROR(FnTest, "Not Guid of expected queue.");
			throw exception();
		}
	}

	//
	// Check the array contains Alias[0]...Alias[1], in that order
	//

	for(int j = 0; j < 2; i++, j++)
	{
		if(pLeafMqf[i].GetType() != QUEUE_FORMAT_TYPE_DIRECT)
		{
			TrERROR(FnTest, "Queue Format is not direct.");
			throw exception();
		}

		LPCWSTR DirectID = wcschr(AliasFormatName[j], L'=') + 1;

		if(wcscmp(DirectID, pLeafMqf[i].DirectID()) != 0)
		{
			TrERROR(FnTest, "Not DirectID of expected queue.");
			throw exception();
		}
	}
}



LPCWSTR GoodFormatNames[] = {
	L"PUBLIC=" L"00112233-4455-6677-8899-aabbccddeeff",
	L"PUBLIC=" L"00112233-4455-6677-8899-aabbccddeeff" L";JOURNAL",

	L"DL=" L"00112233-4455-6677-8899-aabbccddeeff" L"@" L"Domain", 

	L"PRIVATE=" L"00112233-4455-6677-8899-aabbccddeeff" L"\\" L"00000010",
	L"PRIVATE=" L"00112233-4455-6677-8899-aabbccddeeff" L"\\" L"00000010" L";JOURNAL",

	L"DIRECT=" L"TCP:10.20.30.40" L"\\" L"QueueName",
	L"DIRECT=" L"TCP:10.20.30.40" L"\\" L"PRIVATE$" L"\\" L"QueueName",
//	L"DIRECT=" L"TCP:10.20.30.40" L"\\" L"SYSTEM$" L";JOURNAL",
//	L"DIRECT=" L"TCP:10.20.30.40" L"\\" L"SYSTEM$" L";DEADLETTER",
//	L"DIRECT=" L"TCP:10.20.30.40" L"\\" L"SYSTEM$" L";DEADXACT",

	L"DIRECT=" L"OS:Machine.Domain" L"\\" L"QueueName",
	L"DIRECT=" L"OS:Machine.Domain" L"\\" L"PRIVATE$" L"\\" L"QueueName",
//	L"DIRECT=" L"OS:Machine.Domain" L"\\" L"SYSTEM$" L";JOURNAL",
//	L"DIRECT=" L"OS:Machine.Domain" L"\\" L"SYSTEM$" L";DEADLETTER",
//	L"DIRECT=" L"OS:Machine.Domain" L"\\" L"SYSTEM$" L";DEADXACT",

	L"DIRECT=" L"HTTP://Host" L"\\" L"QueueName",
	L"DIRECT=" L"HTTP://Host" L"\\" L"PRIVATE$" L"\\" L"QueueName",
//	L"DIRECT=" L"HTTP://Host" L"\\" L"SYSTEM$" L";JOURNAL",
//	L"DIRECT=" L"HTTP://Host" L"\\" L"SYSTEM$" L";DEADLETTER",
//	L"DIRECT=" L"HTTP://Host" L"\\" L"SYSTEM$" L";DEADXACT",

	L"DIRECT=" L"HTTPS://Host" L"\\" L"QueueName",
	L"DIRECT=" L"HTTPS://Host" L"\\" L"PRIVATE$" L"\\" L"QueueName",
//	L"DIRECT=" L"HTTPS://Host" L"\\" L"SYSTEM$" L";JOURNAL",
//	L"DIRECT=" L"HTTPS://Host" L"\\" L"SYSTEM$" L";DEADLETTER",
//	L"DIRECT=" L"HTTPS://Host" L"\\" L"SYSTEM$" L";DEADXACT",

	L"MACHINE=" L"00112233-4455-6677-8899-aabbccddeeff" L";JOURNAL",
	L"MACHINE=" L"00112233-4455-6677-8899-aabbccddeeff" L";DEADLETTER",
	L"MACHINE=" L"00112233-4455-6677-8899-aabbccddeeff" L";DEADXACT",

	L"CONNECTOR=" L"00112233-4455-6677-8899-aabbccddeeff",
	L"CONNECTOR=" L"00112233-4455-6677-8899-aabbccddeeff" L";XACTONLY",

	L"MULTICAST=224.224.222.123:1234",
	L"MULTICAST=224.10.20.30:8080",
	L"MULTICAST=224.10.0.30:8080"
};

LPCWSTR BadFormatNames[] = {
	//Bad Prefix
	L"PUBLIK=" L"00112233-4455-6677-8899-aabbccddeeff",

	//Bad PUBLIC GUID
	L"PUBLIC=" L"00112233+4455-6677-8899-aabbccddeeff",
	//Bad PUBLIC GUID
	L"PUBLIC=" L"00112233-4455-6677-8899-aabbccddeefff",
	//Bad PUBLIC suffix
	L"PUBLIC=" L"00112233-4455-6677-8899-aabbccddeeff" L";JURNAL",
	//Bad PUBLIC. Unexpected suffix
	L"PUBLIC=" L"00112233-4455-6677-8899-aabbccddeeff" L";DEADLETTER",

	//Bad DL separator
	L"DL=" L"00112233-4455-6677-8899-aabbccddeeff" L"#" L"Domain",
	
	//Bad PRIVATE GUID
	L"PRIVATE=" L"00112233-4455-6677-8899-aabbccddeeffg" L"\\" L"00000001",
	//Bad PRIVATE seperator
	L"PRIVATE=" L"00112233-4455-6677-8899-aabbccddeeff" L"," L"00000001",
	//Bad PRIVATE private id
	L"PRIVATE=" L"00112233-4455-6677-8899-aabbccddeeff" L"\\" L"000000001",

	//Bad DIRECT token
	L"DIRECT=" L"TCB:10.20.30.40" L"\\" L"QueueName",

	//Bad DIRECT tcp address
//	L"DIRECT=" L"TCP:10.20.30.40.50" L"\\" L"QueueName",
	//Bad DIRECT tcp address
//	L"DIRECT=" L"TCP:10,20.30.40" L"\\" L"QueueName",
	//Bad DIRECT tcp (Contains carriage return in machinename.)
	L"DIRECT=" L"TCP:10.20.30\x0d.40" L"\\" L"QueueName",
	//Bad DIRECT tcp queue name seperator
	L"DIRECT=" L"TCP:10.20.30.40" L";" L"QueueName",
	//Bad DIRECT tcp queue name
	L"DIRECT=" L"TCP:10.20.30.40" L"\\" L"Queue\x0dName",
	//Bad DIRECT tcp private specifier
	L"DIRECT=" L"TCP:10.20.30.40" L"\\" L"PRIVETE$" L"\\" L"QueueName",
	//Bad DIRECT tcp system specifier
//	L"DIRECT=" L"TCP:10.20.30.40" L"\\" L"SISTEM$" L";JOURNAL",
	//Bad DIRECT tcp suffix seperator
//	L"DIRECT=" L"TCP:10.20.30.40" L"\\" L"SYSTEM$" L":JOURNAL",
	//Bad DIRECT tcp suffix
//	L"DIRECT=" L"TCP:10.20.30.40" L"\\" L"SYSTEM$" L";JURNAL",
	//Bad DIRECT os address
	L"DIRECT=" L"OS:" L"\\" L"QueueName",
	//Bad DIRECT os address (Contains carriage return in machinename.)
	L"DIRECT=" L"OS:" L"Machi\x0dne1\\" L"QueueName",
	//Bad DIRECT os address
	L"DIRECT=" L"OS:" L"Machine\\" L"Queue\x0dName",
	//Bad DIRECT os address
//	L"DIRECT=" L"OS:Machine,Domain" L"\\" L"QueueName",

	//Bad MACHINE. Missing suffix
	L"MACHINE=" L"00112233-4455-6677-8899-aabbccddeeff",
	//Bad MACHINE GUID
	L"MACHINE=" L"00112233-4455-6677-8899-aabbccddeefff" L";JOURNAL",

	//Bad CONNECTOR GUID
	L"CONNECTOR=" L"00112233-4455-6677-8899-aabbccddeeffg",
	//Bad CONNECTOR. Unexpected suffix
//	L"CONNECTOR=" L"00112233-4455-6677-8899-aabbccddeeff" L";JOURNAL",

	//Bad MQF
//	L"PUBLIC=" L"00112233-4455-6677-8899-aabbccddeeff,",

	//Bad MULTICAST format name. Not class D ip address.
	L"MULTICAST=223.10.20.30:8080",

	//Bad MULTICAST format name. Bad ip address
	L"MULTICAST=224.10.20.301:8080",

	//Bad MULTICAST format name. Bad ip address
	L"MULTICAST=224.10.20:8080",

	//Bad MULTICAST format name. Missing port
	L"MULTICAST=224.10.20.30",

	//Bad MULTICAST format name. Bad port number
	L"MULTICAST=224.10.20.30:-8080",

	//Bad MULTICAST format name. Leading zeroes
	L"MULTICAST=224.10.20.030:8080",

	//Bad MULTICAST format name. white spaces
	L"MULTICAST=224.10.20. 30:8080",

	// Bad MULTICAST address
	L"MULTICAST=224.0xaa.0xbb.0xcc:8080"

};



VOID TestParsingRoutines()
{
	size_t cGoodFormatNames = TABLE_SIZE(GoodFormatNames);
	size_t cBadFormatNames = TABLE_SIZE(BadFormatNames);

	for(size_t i = 0; i < cGoodFormatNames; i++)
	{
		QUEUE_FORMAT QueueFormat;
		AP<WCHAR> StringToFree;

		TrTRACE(FnTest, "Parsing good format name '%ls'", GoodFormatNames[i]);

		BOOL Result = FnFormatNameToQueueFormat(
						GoodFormatNames[i], //LPCWSTR lpwcsFormatName,
						&QueueFormat, //QUEUE_FORMAT* pQueueFormat,
						&StringToFree //LPWSTR* ppStringToFree
						);
	
		if(!Result)
		{
			TrERROR(FnTest, "Failed Parsing of '%ls'", GoodFormatNames[i]);
			throw exception();
		}
	}

	for(size_t i = 0; i < cBadFormatNames; i++)
	{
		QUEUE_FORMAT QueueFormat;
		AP<WCHAR> StringToFree;

		TrERROR(FnTest, "Parsing bad format name '%ls'", BadFormatNames[i]);

		BOOL Result = FnFormatNameToQueueFormat(
						BadFormatNames[i], //LPCWSTR lpwcsFormatName,
						&QueueFormat, //QUEUE_FORMAT* pQueueFormat,
						&StringToFree //LPWSTR* ppStringToFree
						);
	
		if(Result)
		{
			TrERROR(FnTest, "Passed Parsing of '%ls'", BadFormatNames[i]);
			throw exception();
		}
	}

	wstring mqf;
	size_t j = 0;

	for(; j < cGoodFormatNames; j++)
	{
		mqf += wstring(GoodFormatNames[j]);

		if(j + 1 < cGoodFormatNames)
		{
			mqf += L',';
		}
	}
	
	TrTRACE(FnTest, "Parsing good MQF '%ls'", mqf.c_str());

	AP<QUEUE_FORMAT> pQueueFormat;
	DWORD nQueues;
	CStringsToFree StringsToFree;

	BOOL Result = FnMqfToQueueFormats(
					mqf.c_str(),
					pQueueFormat,
					&nQueues,
					StringsToFree
					);
	
	if(!Result || nQueues != j)
	{
		TrERROR(FnTest, "Failed Parsing of good mqf.");
		throw exception();
	}
}


const WCHAR xDirectQueueFormat1[] = L"msmq\\private$\\temp1";
const WCHAR xDirectQueueFormat2[] = L"msmq\\private$\\temp2";

void TestFnQueueFormat(void)
{
    CFnQueueFormat fnqf;
    GUID guid;

    //
    // Test public queue
    //
    UuidCreate(&guid);

    QUEUE_FORMAT publicQueue(guid);
    fnqf.CreateFromQueueFormat(publicQueue);

    if ((fnqf.PublicID() != publicQueue.PublicID()) ||
        (fnqf.Suffix() != publicQueue.Suffix()))
        throw exception();

    //
    // Test private queue
    //
    UuidCreate(&guid);
    QUEUE_FORMAT privateQueue(guid, rand());
    privateQueue.Suffix(QUEUE_SUFFIX_TYPE_JOURNAL);

    fnqf.CreateFromQueueFormat(privateQueue);

    if ((fnqf.PrivateID().Lineage != privateQueue.PrivateID().Lineage) ||
        (fnqf.PrivateID().Uniquifier != privateQueue.PrivateID().Uniquifier) ||
        (fnqf.Suffix() != privateQueue.Suffix()))
        throw exception();

    //
    // Test direct queue
    //
    QUEUE_FORMAT directQueue(const_cast<LPWSTR>(xDirectQueueFormat1));
    fnqf.CreateFromQueueFormat(directQueue);

    if ((wcscmp(fnqf.DirectID(), directQueue.DirectID()) != 0) ||
        (fnqf.Suffix() != directQueue.Suffix()))
        throw exception();

    QUEUE_FORMAT directQueue2(const_cast<LPWSTR>(xDirectQueueFormat2));
    fnqf.CreateFromQueueFormat(directQueue2);

    if ((wcscmp(fnqf.DirectID(), directQueue2.DirectID()) != 0) ||
        (fnqf.Suffix() != directQueue2.Suffix()))
        throw exception();

}

static void TestCFnMqf()
{
	std::vector<std::wstring> qf; 
	qf.push_back(L"direct=http://gilsh10\\msmq\\private$\\t");
	qf.push_back(L"direct=os:gilsh10\\private$\\t");
    qf.push_back(L"direct=http://gilsh10\\msmq\\t");

	std::wstring mqf;
	std::vector<std::wstring>::const_iterator it = qf.begin();
	while(it!= qf.end() )
	{
		mqf += *it;
		if(++it != qf.end())
		{
			mqf += FN_MQF_SEPARATOR_C;
		}
	}

	CFnMqf FnMqf(xwcs_t(mqf.begin(), mqf.size()) );
	if(FnMqf.GetCount() != 	qf.size())
	{
		 throw exception();
	}

	for(DWORD i = 0;i< FnMqf.GetCount(); ++i)
	{
		const QUEUE_FORMAT*  CreatetedQueueFormat = FnMqf.GetQueueFormats();
		UNREFERENCED_PARAMETER(CreatetedQueueFormat);
	}

}


static void TestMsmqUrlCanonization()
{
	WCHAR url1[] = L"http://host\\msmq\\q1";
	WCHAR url1canonic[] = L"http://host/msmq/q1";
	bool fSucess  = FnAbsoluteMsmqUrlCanonization(url1);

	if(!fSucess || _wcsicmp(url1, url1canonic)!= 0)
	{
		TrERROR(FnTest, "FnAbsoluteMsmqUrlCanonization has a bug!!");
		throw exception();
	}

	WCHAR url2[] = L"http://host\\msmq/private$\\q1";
	WCHAR url2canonic[] = L"http://host/msmq/private$/q1";

 	fSucess  = FnAbsoluteMsmqUrlCanonization(url2);

	if(!fSucess || _wcsicmp(url2, url2canonic)!= 0)
	{
		TrERROR(FnTest, "FnAbsoluteMsmqUrlCanonization has a bug!!");
		throw exception();
	}

	WCHAR url3[] = L"http://host/msmq/private$\\q1/aaa";
	WCHAR url3canonic[] = L"http://host/msmq/private$/q1/aaa";

 	fSucess  = FnAbsoluteMsmqUrlCanonization(url3);

	if(!fSucess || _wcsicmp(url3, url3canonic)!= 0)
	{
		TrERROR(FnTest, "FnAbsoluteMsmqUrlCanonization has a bug!!");
		throw exception();
	}
}



extern "C" int __cdecl _tmain(int /*argc*/, LPCTSTR /*argv*/[])
/*++

Routine Description:
    Test Format Name Parsing library

Arguments:
    Parameters.

Returned Value:
    None.

--*/
{
    WPP_INIT_TRACING(L"Microsoft\\MSMQ");

    TrInitialize();
    TrRegisterComponent(&FnTest, 1);

    FnInitialize();

	try
	{
		TestMsmqUrlCanonization();
		TestCFnMqf();
		TestExpandMqf();
		TrTRACE(FnTest, "TestExpandMqf() passed.");

		TestParsingRoutines();
		TrTRACE(FnTest, "TestParsingRoutines() passed.");

        TestFnQueueFormat();
        TrTRACE(FnTest, "TestFnQueueFormat() passed.");
	}
	catch(const exception&)
	{
		TrERROR(FnTest, "Test FAILED.");
		return 1;
	}

	TrTRACE(FnTest, "Test PASSED.");

    WPP_CLEANUP();
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\fn\test\fniads.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    FnIADs.cpp

Abstract:
    Format Name Parsing library test

Author:
    Nir Aides (niraides) 21-May-00

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include <activeds.h>
#include <Oleauto.h>
#include "mqwin64a.h"
#include "qformat.h"
#include "Fnp.h"
#include "FnGeneral.h"
#include "FnIADs.h"

#include "FnIADs.tmh"

using namespace std;


EXTERN_C const IID IID_IADsGroup = {
		0x5a5a5a5a,
			0x5a5a,
			0x5a5a,
		{0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x00}
	};

EXTERN_C const IID IID_IADs = {
		0x5a5a5a5a,
			0x5a5a,
			0x5a5a,
		{0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x01}
	};

EXTERN_C const IID IID_IEnumVARIANT = {
		0x5a5a5a5a,
			0x5a5a,
			0x5a5a,
		{0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x02}
	};

EXTERN_C const IID IID_IDirectoryObject = {
		0x5a5a5a5a,
			0x5a5a,
			0x5a5a,
		{0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x03}
	};



class CADObject: public CADInterface
{
public:
	//
	// IADsGroup interface methods
	//

	virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
        /* [retval][out] */ BSTR __RPC_FAR * /*retval*/) 
	{ 
		ASSERT(FALSE);
		return S_FALSE;
	}
    
    virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Description( 
        /* [in] */ BSTR /*bstrDescription*/) 
	{ 
		ASSERT(FALSE); 
		return S_FALSE;
	}
    
    virtual /* [id] */ HRESULT STDMETHODCALLTYPE Members( 
        /* [retval][out] */ IADsMembers __RPC_FAR *__RPC_FAR * /*ppMembers*/) 
	{ 
		ASSERT(FALSE); 
		return S_FALSE;
	}
    
    virtual /* [id] */ HRESULT STDMETHODCALLTYPE IsMember( 
        /* [in] */ BSTR /*bstrMember*/,
        /* [retval][out] */ VARIANT_BOOL __RPC_FAR * /*bMember*/) 
	{ 
		ASSERT(FALSE); 
		return S_FALSE;
	}
    
    virtual /* [id] */ HRESULT STDMETHODCALLTYPE Add( 
        /* [in] */ BSTR /*bstrNewItem*/) 
	{ 
		ASSERT(FALSE); 
		return S_FALSE;
	}
    
    virtual /* [id] */ HRESULT STDMETHODCALLTYPE Remove( 
        /* [in] */ BSTR /*bstrItemToBeRemoved*/) 
	{ 
		ASSERT(FALSE); 
		return S_FALSE;
	}

public:
	//
	// IDirectoryObject interface methods
	//

	virtual HRESULT STDMETHODCALLTYPE GetObjectInformation( 
		/* [out] */ PADS_OBJECT_INFO  * /*ppObjInfo*/ )
	{
		ASSERT(FALSE); 
		return S_FALSE;
	}

	virtual HRESULT STDMETHODCALLTYPE GetObjectAttributes( 
		/* [in] */ LPWSTR *pAttributeNames,
		/* [in] */ DWORD dwNumberAttributes,
		/* [out] */ PADS_ATTR_INFO *ppAttributeEntries,
		/* [out] */ DWORD *pdwNumAttributesReturned);

	virtual HRESULT STDMETHODCALLTYPE SetObjectAttributes( 
		/* [in] */ PADS_ATTR_INFO /*pAttributeEntries*/,
		/* [in] */ DWORD /*dwNumAttributes*/,
		/* [out] */ DWORD * /*pdwNumAttributesModified*/)
	{
		ASSERT(FALSE); 
		return S_FALSE;
	}

	virtual HRESULT STDMETHODCALLTYPE CreateDSObject( 
		/* [in] */ LPWSTR /*pszRDNName*/,
		/* [in] */ PADS_ATTR_INFO /*pAttributeEntries*/,
		/* [in] */ DWORD /*dwNumAttributes*/,
		/* [out] */ IDispatch ** /*ppObject*/)
	{
		ASSERT(FALSE); 
		return S_FALSE;
	}

	virtual HRESULT STDMETHODCALLTYPE DeleteDSObject( 
		/* [in] */ LPWSTR /*pszRDNName*/)
	{
		ASSERT(FALSE); 
		return S_FALSE;
	}
        
public:
	//
	// IADs interface methods
	//

    virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
        /* [retval][out] */ BSTR __RPC_FAR *retval)
	{
		*retval = SysAllocString(m_Name.c_str());
		return S_OK;
	}
    
    virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Class( 
        /* [retval][out] */ BSTR __RPC_FAR *retval)
	{
		*retval = SysAllocString(m_Class.c_str());
		return S_OK;
	}
    
    virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_GUID( 
        /* [retval][out] */ BSTR __RPC_FAR *retval)
	{
		*retval = SysAllocString(m_Guid.c_str());
		return S_OK;
	}
    
    virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ADsPath( 
        /* [retval][out] */ BSTR __RPC_FAR * /*retval*/) 
	{ 
		ASSERT(FALSE); 
		return S_FALSE;
	}
    
    virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Parent( 
        /* [retval][out] */ BSTR __RPC_FAR * /*retval*/) 
	{ 
		ASSERT(FALSE); 
		return S_FALSE;
	}
    
    virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Schema( 
        /* [retval][out] */ BSTR __RPC_FAR * /*retval*/) 
	{ 
		ASSERT(FALSE); 
		return S_FALSE;
	}
    
    virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetInfo( void) 
	{ 
		ASSERT(FALSE); 
		return S_FALSE;
	}
    
    virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetInfo( void) 
	{ 
		ASSERT(FALSE); 
		return S_FALSE;
	}
    
    virtual /* [id] */ HRESULT STDMETHODCALLTYPE Get( 
        /* [in] */ BSTR bstrName,
        /* [retval][out] */ VARIANT __RPC_FAR *pvProp);
    
    virtual /* [id] */ HRESULT STDMETHODCALLTYPE Put( 
        /* [in] */ BSTR /*bstrName*/,
        /* [in] */ VARIANT /*vProp*/) 
	{ 
		ASSERT(FALSE); 
		return S_FALSE;
	}
    
    virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetEx( 
        /* [in] */ BSTR /*bstrName*/,
        /* [retval][out] */ VARIANT __RPC_FAR * /*pvProp*/)
	{ 
		ASSERT(FALSE); 
		return S_FALSE;
	}
    
    virtual /* [id] */ HRESULT STDMETHODCALLTYPE PutEx( 
        /* [in] */ long /*lnControlCode*/,
        /* [in] */ BSTR /*bstrName*/,
        /* [in] */ VARIANT /*vProp*/)
	{ 
		ASSERT(FALSE); 
		return S_FALSE;
	}
    
    virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetInfoEx( 
        /* [in] */ VARIANT /*vProperties*/,
        /* [in] */ long /*lnReserved*/) 
	{ 
		ASSERT(FALSE); 
		return S_FALSE;
	}
    
public:
	//
	// IDispatch interface methods
	//

    virtual HRESULT STDMETHODCALLTYPE GetTypeInfoCount( 
        /* [out] */ UINT __RPC_FAR * /*pctinfo*/) 
	{ 
		ASSERT(FALSE); 
		return S_FALSE;
	}
    
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfo( 
        /* [in] */ UINT /*iTInfo*/,
        /* [in] */ LCID /*lcid*/,
        /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR * /*ppTInfo*/) 
	{ 
		ASSERT(FALSE); 
		return S_FALSE;
	}
    
    virtual HRESULT STDMETHODCALLTYPE GetIDsOfNames( 
        /* [in] */ REFIID /*riid*/,
        /* [size_is][in] */ LPOLESTR __RPC_FAR * /*rgszNames*/,
        /* [in] */ UINT /*cNames*/,
        /* [in] */ LCID /*lcid*/,
        /* [size_is][out] */ DISPID __RPC_FAR * /*rgDispId*/) 
	{ 
		ASSERT(FALSE); 
		return S_FALSE;
	}
    
    virtual /* [local] */ HRESULT STDMETHODCALLTYPE Invoke( 
        /* [in] */ DISPID /*dispIdMember*/,
        /* [in] */ REFIID /*riid*/,
        /* [in] */ LCID /*lcid*/,
        /* [in] */ WORD /*wFlags*/,
        /* [out][in] */ DISPPARAMS __RPC_FAR * /*pDispParams*/,
        /* [out] */ VARIANT __RPC_FAR * /*pVarResult*/,
        /* [out] */ EXCEPINFO __RPC_FAR * /*pExcepInfo*/,
        /* [out] */ UINT __RPC_FAR * /*puArgErr*/) 
	{ 
		ASSERT(FALSE); 
		return S_FALSE;
	}

public:
	//
	// IUnknown interface methods
	//

    virtual HRESULT STDMETHODCALLTYPE QueryInterface( 
        /* [in] */ REFIID /*riid*/,
        /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
    
    virtual ULONG STDMETHODCALLTYPE AddRef( void)
    {
        InterlockedIncrement(&m_ref);

		return 0;
    }
    
    virtual ULONG STDMETHODCALLTYPE Release( void) 
	{
        ASSERT(m_ref > 0);
        LONG ref = InterlockedDecrement(&m_ref);

        ASSERT(!(ref < 0));

        if(ref == 0)
        {
            delete this;
        }

		return 0;
	}

public:
	CADObject(
		LPCWSTR Name,
		LPCWSTR Class,
		LPCWSTR Guid
		): 
		m_ref(1)
	{
		m_Name = wstring(Name);
		m_Class = wstring(Class);
		m_Guid = wstring(Guid);
	}

    VOID TestPut( 
        BSTR bstrName,
        VARIANT vProp);

public: //protected:
    virtual ~CADObject()
    {
        ASSERT((m_ref == 0) || (m_ref == 1));
    }

private:
    mutable LONG m_ref;

private:
	wstring m_Name;
	wstring m_Class;
	wstring m_Guid;

	//
	// Map that stores attribute names and values
	//
	map<wstring, VARIANTWrapper> m_Attributes;
};



HRESULT STDMETHODCALLTYPE CADObject::QueryInterface( 
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject)
{
	if(riid == IID_IADsGroup)
	{
		*ppvObject = static_cast<IADsGroup*>(SafeAddRef(this));
		return S_OK;
	}

	if(riid == IID_IADs)
	{
		*ppvObject = static_cast<IADs*>(SafeAddRef(this));
		return S_OK;
	}

	if(riid == IID_IDirectoryObject)
	{
		*ppvObject = static_cast<IDirectoryObject*>(SafeAddRef(this));
		return S_OK;
	}

	return S_FALSE;
}

HRESULT STDMETHODCALLTYPE CADObject::Get( 
    /* [in] */ BSTR bstrName,
    /* [retval][out] */ VARIANT __RPC_FAR *pvProp)
{
	map<wstring, VARIANTWrapper>::iterator itr = m_Attributes.find(wstring(bstrName));

	ASSERT(itr != m_Attributes.end());

	if(itr == m_Attributes.end())
		return E_ADS_PROPERTY_NOT_FOUND;

	return VariantCopy(pvProp, &itr->second);
}



VOID CADObject::TestPut( 
        BSTR bstrName,
        VARIANT vProp)
{
	VARIANTWrapper& var = m_Attributes[wstring(bstrName)];

	if(FAILED(VariantCopy(&var, &vProp)))
	{
		throw bad_alloc();
	}
}


HRESULT STDMETHODCALLTYPE CADObject::GetObjectAttributes( 
	/* [in] */ LPWSTR *pAttributeNames,
	/* [in] */ DWORD dwNumberAttributes,
	/* [out] */ PADS_ATTR_INFO *ppAttributeEntries,
	/* [out] */ DWORD *pdwNumAttributesReturned)
{
	ASSERT(pAttributeNames != NULL && *pAttributeNames != NULL);
	ASSERT(dwNumberAttributes == 1);
	ASSERT(ppAttributeEntries != NULL);
	ASSERT(pdwNumAttributesReturned != NULL);

	int RangeLow;
	int RangeHigh;

	ASSERT(swscanf(*pAttributeNames, L"member;Range=%d-%d", &RangeLow, &RangeHigh) == 2); 
	
	*pdwNumAttributesReturned = 1;
	*ppAttributeEntries = new ADS_ATTR_INFO;

	(*ppAttributeEntries)->dwADsType = ADSTYPE_DN_STRING;
	(*ppAttributeEntries)->pADsValues = new _adsvalue[RangeHigh - RangeLow];
	//
	// Retrieve value of the multi valued 'member' attribute of the 'Group' object
	//
	// Value returns embeded in a VARIANT, as a SAFEARRAY of VARIANTS
	// which hold the BSTR (strings) of the Distinguished Names of 
	// the Group members.
	//
	map<wstring, VARIANTWrapper>::iterator itr = m_Attributes.find(wstring(L"member"));

	ASSERT(itr != m_Attributes.end());

	VARIANTWrapper& var = itr->second;

	//
	// Get the lower and upper bound of the SAFEARRAY
	//
	LONG lstart;
	LONG lend;
	SAFEARRAY* sa = V_ARRAY(&var);

	HRESULT hr = SafeArrayGetLBound(sa, 1, &lstart);
    ASSERT(("Failed SafeArrayGetLBound(sa, 1, &lstart)", SUCCEEDED(hr)));

	hr = SafeArrayGetUBound(sa, 1, &lend);
    ASSERT(("Failed SafeArrayGetUBound(sa, 1, &lend)", SUCCEEDED(hr)));

	ASSERT(RangeLow <= lend - lstart);

	long index = 0;

	for(; (index < RangeHigh - RangeLow) && (index <= lend - lstart); index++)
	{
		VARIANT* pVarItem;
		long i = index + lstart;
		
		hr = SafeArrayPtrOfIndex(sa, &i, (void**)&pVarItem);

		ASSERT(("Failed SafeArrayGetElement(sa, &i, &pVarItem)", SUCCEEDED(hr)));
		ASSERT(pVarItem->vt == VT_BSTR);

		BSTR DistinugishedName = V_BSTR(pVarItem);

		((*ppAttributeEntries)->pADsValues + i)->CaseIgnoreString = newwcs(DistinugishedName);
		((*ppAttributeEntries)->pADsValues + i)->dwType = ADSTYPE_CASE_IGNORE_STRING;
	}

	(*ppAttributeEntries)->dwNumValues = index;
	(*ppAttributeEntries)->pszAttrName = newwcs(*pAttributeNames);

	if(RangeHigh > lend - lstart)
	{
		wcscpy(wcschr((*ppAttributeEntries)->pszAttrName, L'-'), L"*");
	}

	return S_OK;
}



//
// Map stores AD objects with their ADsPath as key
//
map<wstring, R<CADObject> > g_ObjectMap;



extern "C" 
HRESULT 
WINAPI
ADsOpenObject(
    LPCWSTR lpszPathName,
    LPCWSTR /*lpszUserName*/,
    LPCWSTR /*lpszPassword*/,
    DWORD  /*dwReserved*/,
    REFIID /*riid*/,
    VOID * * ppObject
    )
{	
	map<wstring, R<CADObject> >::iterator itr = g_ObjectMap.find(wstring(lpszPathName));

	if(itr == g_ObjectMap.end())
		return E_ADS_UNKNOWN_OBJECT;

	*ppObject = static_cast<IADs*>(SafeAddRef(itr->second.get()));

	return S_OK;
}



extern "C"
BOOL 
WINAPI
FreeADsMem(
   LPVOID pMem
)
{
	PADS_ATTR_INFO pAttrInfo = static_cast<PADS_ATTR_INFO>(pMem);

	ASSERT(pAttrInfo->dwADsType == ADSTYPE_DN_STRING);

	for(unsigned long index = 0; index < pAttrInfo->dwNumValues; index++)
	{
		delete pAttrInfo->pADsValues[index].CaseIgnoreString;
	}

	delete pAttrInfo->pADsValues;
	delete pAttrInfo->pszAttrName;
	delete pAttrInfo;

	return true;
}



R<CADInterface>
CreateADObject(
	const CObjectData& obj
	)
{
	R<CADObject> pObj = new CADObject(
								obj.odDistinguishedName, 
								obj.odClassName, 
								obj.odGuid
								);
	
	g_ObjectMap[wstring(obj.odADsPath)] = pObj;
	
	return pObj;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\inc\automqfr.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:
    snapptr.h

Abstract:
    Useful templates for Auto pointer and auto Release

Author:
    Nela Karpel (nelak) 14-Jan-01

--*/

#pragma once

#ifndef _MSMQ_SNAPIN_AUTOPTR_H_
#define _MSMQ_SNAPIN_AUTOPTR_H_

#include <mqcacert.h>

//---------------------------------------------------------
//
//  template class SP
//
//---------------------------------------------------------
template<class T>
class CAutoMQFree {
private:
    T* m_p;

public:
    CAutoMQFree(T* p = 0) : m_p(p)    {}
   ~CAutoMQFree()                     { MQFreeMemory(m_p); }

    operator T*() const     { return m_p; }
    T* operator->() const   { return m_p; }
    T* get() const          { return m_p; }
    T* detach()             { T* p = m_p; m_p = 0; return p; }
    void free()             { MQFreeMemory(detach()); }


    T** operator&()
    {
        ASSERT(("Auto pointer in use, can't take it's address", m_p == 0));
        return &m_p;
    }


    CAutoMQFree& operator=(T* p)
    {
        ASSERT(("Auto pointer in use, can't assign it", m_p == 0));
        m_p = p;
        return *this;
    }

private:
    CAutoMQFree(const CAutoMQFree&);
	CAutoMQFree<T>& operator=(const CAutoMQFree<T>&);
};


//---------------------------------------------------------
//
//  template class SP
//
//---------------------------------------------------------
class CCaConfigPtr {
private:
    MQ_CA_CONFIG* m_p;

public:
    CCaConfigPtr(MQ_CA_CONFIG* p = 0) : m_p(p)	{}
   ~CCaConfigPtr()								{ MQFreeCaConfig(m_p); }

    operator MQ_CA_CONFIG*() const		{ return m_p; }
    MQ_CA_CONFIG* operator->() const	{ return m_p; }
    MQ_CA_CONFIG* get() const			{ return m_p; }
    MQ_CA_CONFIG* detach()				{ MQ_CA_CONFIG* p = m_p; m_p = 0; return p; }
    void free()							{ MQFreeCaConfig(detach()); }


    MQ_CA_CONFIG** operator&()
    {
        ASSERT(("Auto pointer in use, can't take it's address", m_p == 0));
        return &m_p;
    }


    CCaConfigPtr& operator=(MQ_CA_CONFIG* p)
    {
        ASSERT(("Auto pointer in use, can't assign it", m_p == 0));
        m_p = p;
        return *this;
    }

private:
    CCaConfigPtr(const CCaConfigPtr&);
	CCaConfigPtr& operator=(const CCaConfigPtr&);
};


#endif // _MSMQ_SNAPIN_AUTOPTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\inc\autoptr.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:
    autoptr.h

Abstract:
    Useful templates for Auto pointer and auto Release

Author:
    Erez Haba (erezh) 11-Mar-96

--*/

#pragma once

#ifndef _MSMQ_AUTOPTR_H_
#define _MSMQ_AUTOPTR_H_


//---------------------------------------------------------
//
//  template class P
//
//---------------------------------------------------------
template<class T>
class P {
private:
    T* m_p;

public:
    P(T* p = 0) : m_p(p)    {}
   ~P()                     { delete m_p; }

    operator T*() const     { return m_p; }
    T* operator->() const   { return m_p; }
    T* get() const          { return m_p; }
    T* detach()             { T* p = m_p; m_p = 0; return p; }
    void free()             { delete detach(); }


    T** operator&()
    {
        ASSERT(("Auto pointer in use, can't take it's address", m_p == 0));
        return &m_p;
    }


    P& operator=(T* p)
    {
        ASSERT(("Auto pointer in use, can't assign it", m_p == 0));
        m_p = p;
        return *this;
    }


    VOID*& ref_unsafe()
    {
        // unsafe ref to auto pointer, for special uses like
        // InterlockedCompareExchangePointer

        return *reinterpret_cast<VOID**>(&m_p);
    }


private:
    P(const P&);
	P<T>& operator=(const P<T>&);
};


//---------------------------------------------------------
//
//  template class AP
//
//---------------------------------------------------------
template<class T>
class AP {
private:
    T* m_p;

public:
    AP(T* p = 0) : m_p(p)   {}
   ~AP()                    { delete[] m_p; }

    operator T*() const     { return m_p; }
    T* operator->() const   { return m_p; }
    T* get() const          { return m_p; }
    T* detach()             { T* p = m_p; m_p = 0; return p; }
    void free()             { delete[] detach(); }

    
    T** operator&()
    {
        ASSERT(("Auto pointer in use, can't take it's address", m_p == 0));
        return &m_p;
    }


    AP& operator=(T* p)
    {
        ASSERT(("Auto pointer in use, can't assign", m_p == 0));
        m_p = p;
        return *this;
    }


    VOID*& ref_unsafe()
    {
        // unsafe ref to auto pointer, for special uses like
        // InterlockedCompareExchangePointer

        return *reinterpret_cast<VOID**>(&m_p);
    }

private:
    AP(const AP&);
	AP<T>& operator=(const AP<T>&);

};

//---------------------------------------------------------
//
//  template SafeAssign helper function.
//
//---------------------------------------------------------
template <class T> T&  SafeAssign(T& dest , T& src)
{
	if(dest.get() != src.get() )
	{
		dest.free();
		if(src.get() != NULL)
		{
			dest = 	src.detach();
		}
	}
	return dest;
}


template<class T> void SafeDestruct(T* p)
{
    if (p != NULL)
    {
        p->~T();
    }
}

//---------------------------------------------------------
//
//  template class D
//
//---------------------------------------------------------
template<class T>
class D {
private:
    T* m_p;

public:
    D(T* p = 0) : m_p(p)    {}
   ~D()                     { SafeDestruct<T>(m_p); }

    operator T*() const     { return m_p; }
    T* operator->() const   { return m_p; }
    T* get() const          { return m_p; }
    T* detach()             { T* p = m_p; m_p = 0; return p; }
    void free()             { SafeDestruct<T>(detach()); }

    
    T** operator&()
    {
        ASSERT(("Auto pointer in use, can't take it's address", m_p == 0));
        return &m_p;
    }


    D& operator=(T* p)
    {
        ASSERT(("Auto pointer in use, can't assign", m_p == 0));
        m_p = p;
        return *this;
    }

private:
    D(const D&);
};


//---------------------------------------------------------
//
//  template SafeAddRef/SafeRelease helper functions.
//
//---------------------------------------------------------
template<class T> T* SafeAddRef(T* p)
{
    if (p != NULL)
    {
        p->AddRef();
    }

    return p;
}


template<class T> void SafeRelease(T* p)
{
    if (p != NULL)
    {
        p->Release();
    }
}


//---------------------------------------------------------
//
//  template class R
//
//---------------------------------------------------------
template<class T>
class R {
private:
    T* m_p;

public:
    R(T* p = 0) : m_p(p)    {}
   ~R()                     { SafeRelease<T>(m_p); }

    //
    // Removed casting operator, this oprator leads to bugs that are
    // hard to detect. To get the object pointer use get() explicitly.
    // erezh 8-Feb-2000
    //
    //operator T*() const     { return m_p; }

    //
    // Removed pointer reference operator, this oprator prevents R usage in
    // STL containers. Use the ref() member instade. e.g., &p.ref()
    // erezh 17-May-2000
    //
    //T** operator&()       { return &m_p; }

    T* operator->() const   { return m_p; }
    T* get() const          { return m_p; }
    T* detach()             { T* p = m_p; m_p = 0; return p; }

    T*& ref()
    {
        ASSERT(("Auto release in use, can't take object reference", m_p == 0));
        return m_p;
    }


    void free()
    { 
        SafeRelease<T>(detach());
    }


    R& operator=(T* p)
    {
        SafeRelease<T>(m_p);
        m_p = p;

        return *this;
    }


    template <class O> R(const R<O>& r)
    {
        m_p = SafeAddRef<O>(r.get());       
    }


    template <class O> R& operator=(const R<O>& r)
    {
        SafeAddRef<O>(r.get());
        SafeRelease<T>(m_p);
        m_p = r.get();
        return *this;
    }


    R(const R& r)
    {
        m_p = SafeAddRef<T>(r.get());
    }


    R& operator=(const R& r)
    {
        SafeAddRef<T>(r.get());
        SafeRelease<T>(m_p);
        m_p = r.get();

        return *this;
    }
};


#endif // _MSMQ_AUTOPTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\inc\autohandle.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:
    autohandle.h

Abstract:
    Auto handle classes, free the handle resoruce when destructed.

Author:
    Erez Haba (erezh) 06-Jan-97

--*/

#pragma once

#ifndef _MSMQ_AUTOHANDLE_H_
#define _MSMQ_AUTOHANDLE_H_


//---------------------------------------------------------
//
//  class CHandle
//
//---------------------------------------------------------
class CHandle {
public:
    CHandle(HANDLE h = 0) : m_h(h)  {}
   ~CHandle()                       { if (m_h != 0) CloseHandle(m_h); }

    HANDLE* operator &()            { return &m_h; }
    operator HANDLE() const         { return m_h; }
    HANDLE detach()                 { HANDLE h = m_h; m_h = 0; return h; }

private:
    CHandle(const CHandle&);
    CHandle& operator=(const CHandle&);

private:
    HANDLE m_h;
};


//---------------------------------------------------------
//
//  class CFileHandle
//
//---------------------------------------------------------
class CFileHandle {
public:
    CFileHandle(HANDLE h = INVALID_HANDLE_VALUE) : m_h(h) {}
   ~CFileHandle()                   { if (m_h != INVALID_HANDLE_VALUE) CloseHandle(m_h); }

    HANDLE* operator &()            { return &m_h; }
    operator HANDLE() const         { return m_h; }
    HANDLE detach()                 { HANDLE h = m_h; m_h = INVALID_HANDLE_VALUE; return h; }

private:
    CFileHandle(const CFileHandle&);
    CFileHandle& operator=(const CFileHandle&);

private:
    HANDLE m_h;
};


//---------------------------------------------------------
//
//  class CSearchFileHandle
//
//---------------------------------------------------------
class CSearchFileHandle {
public:
    CSearchFileHandle(HANDLE h = INVALID_HANDLE_VALUE) : m_h(h) {}
   ~CSearchFileHandle()                   { if (m_h != INVALID_HANDLE_VALUE) FindClose(m_h); }

    HANDLE* operator &()            { return &m_h; }
    operator HANDLE() const         { return m_h; }
    HANDLE detach()                 { HANDLE h = m_h; m_h = INVALID_HANDLE_VALUE; return h; }

private:
    CSearchFileHandle(const CSearchFileHandle&);
    CSearchFileHandle& operator=(const CSearchFileHandle&);

private:
    HANDLE m_h;
};

//---------------------------------------------------------
//
//  class CDirChangeNotificationHandle
//
//---------------------------------------------------------
class CDirChangeNotificationHandle {
public:
   CDirChangeNotificationHandle(HANDLE h = INVALID_HANDLE_VALUE) : m_h(h) {}
   ~CDirChangeNotificationHandle() 
   { 
		if (m_h != INVALID_HANDLE_VALUE) FindCloseChangeNotification(m_h); 
   }

    HANDLE* operator &()            { return &m_h; }
    operator HANDLE() const         { return m_h; }
    HANDLE detach()                 { HANDLE h = m_h; m_h = INVALID_HANDLE_VALUE; return h; }

private:
    CDirChangeNotificationHandle(const CDirChangeNotificationHandle&);
    CDirChangeNotificationHandle& operator=(const CDirChangeNotificationHandle&);

private:
    HANDLE m_h;
};



//---------------------------------------------------------
//
//  class CSocketHandle
//
//---------------------------------------------------------
class CSocketHandle {
public:
    CSocketHandle(SOCKET h = INVALID_SOCKET) : m_h(h) {}
   ~CSocketHandle()                 { if (m_h != INVALID_SOCKET) closesocket(m_h); }

    SOCKET* operator &()            { return &m_h; }
    operator SOCKET() const         { return m_h; }
    SOCKET detach()                 { SOCKET h = m_h; m_h = INVALID_SOCKET; return h; }
    void free()
    {
		if (m_h != INVALID_SOCKET)
		{
			closesocket(detach());
		}		
    }
 
private:
    CSocketHandle(const CSocketHandle&);
    CSocketHandle& operator=(const CSocketHandle&);

private:
    SOCKET m_h;
};

//---------------------------------------------------------
//
//  class CRegHandle
//
//---------------------------------------------------------
class CRegHandle {
public:
    CRegHandle(HKEY h = 0) : m_h(h) {}
   ~CRegHandle()                    { if (m_h != 0) RegCloseKey(m_h); }

    HKEY* operator &()              { return &m_h; }
    operator HKEY() const           { return m_h; }
    HANDLE detach()                 { HANDLE h = m_h; m_h = 0; return h; }

private:
    CRegHandle(const CRegHandle&);
    CRegHandle& operator=(const CRegHandle&);

private:
    HKEY m_h;
};


//---------------------------------------------------------
//
//  class CLibHandle
//
//---------------------------------------------------------
class CLibHandle {
public:
    CLibHandle(HINSTANCE h = 0) : m_h(h) {}
   ~CLibHandle()                    { if (m_h != 0) FreeLibrary(m_h); }

    HINSTANCE* operator &()         { return &m_h; }
    operator HINSTANCE() const      { return m_h; }
    HANDLE detach()                 { HANDLE h = m_h; m_h = 0; return h; }

private:
    CLibHandle(const CLibHandle&);
    CLibHandle& operator=(const CLibHandle&);

private:
    HINSTANCE m_h;
};


//---------------------------------------------------------
//
//  class CBitmapHandle
//
//---------------------------------------------------------
class CBitmapHandle {
public:
    CBitmapHandle(HBITMAP h = 0) : m_h(h) {}
   ~CBitmapHandle()					{ if (m_h != 0) DeleteObject(m_h); }

    HBITMAP* operator &()			{ return &m_h; }
    operator HBITMAP() const		{ return m_h; }
    HBITMAP detach()					{ HBITMAP h = m_h; m_h = 0; return h; }

private:
    CBitmapHandle(const CBitmapHandle&);
    CBitmapHandle& operator=(const CBitmapHandle&);

private:
    HBITMAP m_h;
};

#endif // _MSMQ_AUTOHANDLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\inc\autosec.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:
    autosec.h

Abstract:
    Auto classes for all kind of security objects

Author:
    Gil Shafriri (gilsh) 06-Jan-97

--*/

#pragma once

#ifndef _MSMQ_AUTOSEC_H_
#define _MSMQ_AUTOSEC_H_


#define SECURITY_WIN32
#include <security.h>
#include <sspi.h>


//---------------------------------------------------------
//
//  class CCertificateContext
//
//---------------------------------------------------------
class CCertificateContext{
public:
    CCertificateContext(PCCERT_CONTEXT h = NULL) : m_h(h) {}
   ~CCertificateContext()                   { if (m_h != NULL) CertFreeCertificateContext(m_h); }

    PCCERT_CONTEXT* operator &()            { return &m_h; }
    operator PCCERT_CONTEXT() const         { return m_h; }
    PCCERT_CONTEXT  detach()                { PCCERT_CONTEXT  h = m_h; m_h = NULL; return h; }

private:
    CCertificateContext(const CCertificateContext&);
    CCertificateContext& operator=(const CCertificateContext&);

private:
    PCCERT_CONTEXT  m_h;
};


//---------------------------------------------------------
//
//  class CCertificateContext
//
//---------------------------------------------------------
class CCertOpenStore
{
public:
    CCertOpenStore(HCERTSTORE h = NULL,DWORD flags = 0) : m_h(h),m_flags(flags) {}
   ~CCertOpenStore()             { if (m_h != NULL) CertCloseStore(m_h,m_flags); }

    HCERTSTORE* operator &()         { return &m_h; }
    operator HCERTSTORE() const      { return m_h; }
    HCERTSTORE   detach()            { HCERTSTORE  h = m_h; m_h = NULL; return h; }

private:
    CCertOpenStore(const CCertOpenStore&);
    CCertOpenStore& operator=(const CCertOpenStore&);

private:
    HCERTSTORE  m_h;
	DWORD m_flags;
};


//---------------------------------------------------------
//
//  helper class CSSPISecurityContext
//
//---------------------------------------------------------
class CSSPISecurityContext
{
public:
    CSSPISecurityContext(const CtxtHandle& h ):m_h(h)
	{
	}

	
	CSSPISecurityContext()
	{
		m_h.dwUpper = 0xFFFFFFFF;
		m_h.dwLower = 0xFFFFFFFF;
	}

	CredHandle operator=(const CredHandle& h)
	{
		free();
		m_h = h;
        return h;
	}	

    ~CSSPISecurityContext()
    {
		if(IsValid())
		{
		   DeleteSecurityContext(&m_h);	 //lint !e534
		}
    }

	CredHandle* getptr(){return &m_h;}

	void free()
	{
		if(IsValid())
		{
		   DeleteSecurityContext(&m_h);
		}
	}
 
	bool IsValid()const
	{
		return (m_h.dwUpper != 0xFFFFFFFF) ||( m_h.dwLower != 0xFFFFFFFF);		
	}



private:
    CSSPISecurityContext(const CSSPISecurityContext&);
    CSSPISecurityContext& operator=(const CSSPISecurityContext&);

private:
    CredHandle  m_h;
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\inc\bufutl.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    bufutl.h

Abstract:
    Header file for some utilities that deals with buffers.
	implementation is in bufutl.cpp in the utl.lib

Author:
    Gil Shafriri (gilsh) 25-7-2000

--*/


#ifndef BUFUTL_H
#define BUFUTL_H

#include <buffer.h>

//
// Appending formatted string to resizable buffer
//
template <class BUFFER, class T>
size_t 
__cdecl 
UtlSprintfAppend(
	BUFFER* pResizeBuffer, 
	const T* format ,...
	);



//
// Appending  string to resizable buffer
//
template <class BUFFER, class T>
size_t 
UtlStrAppend(
	BUFFER* pResizeBuffer, 
	const T* str
	);








#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\inc\buffer.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    buffer.h

Abstract:
    Header for buffer classes that canact as  resizable array.
	Use it when ever you need buffer that needs resizing and also
	supplies low level access to it's memory.
	The implementation is based on std::vector. Unlike std::vector
	the size of the buffer is manualy reset by calling resize().
	This call will not invalidate any data in the buffer memory (like std::vector does)
	but just set a flag indicating the new size.
	A common use to it might be - reading data from the network. You reserver memory 
	calling reserve() , then read raw memory to the buffer, then increament 
	it size by calling resize().

Author:
    Gil Shafriri (gilsh) 25-7-2000

--*/


#ifndef BUFFER_H
#define BUFFER_H


//---------------------------------------------------------
//
//  CResizeBuffer class  -  resizable buffer class - the memory is heap allocated
//
//---------------------------------------------------------
template <class T>
class CResizeBuffer
{

typedef  std::vector<T>  BufferType;
typedef  BufferType::const_iterator const_iterator;
typedef  BufferType::iterator iterator;


public:
   	CResizeBuffer(
		size_t capacity
		):
		m_validlen(0),
		m_Buffer (capacity)	
		{
		}
	
	
	//
	// const start buffer position
	//
 	const_iterator begin() const
	{
		return m_Buffer.begin();
	}
   

	void append(const T& x)
	{
		size_t CurrentCapacity = capacity();
		if(CurrentCapacity == 	m_validlen)
		{
			reserve( (CurrentCapacity + 1)*2 );
		}
	  
		*(begin() + m_validlen ) = x;
		++m_validlen;
	}


	void append(const T* x, size_t len)
	{
		size_t CurrentCapacity = capacity();

		if(CurrentCapacity <  m_validlen +  len )
		{
			reserve( (CurrentCapacity + len)*2 );
		}

		//
		// Copy the data to the end of the buffer
		//
		std::copy(
			x,
			x + len,
			begin() +  m_validlen
			);

		m_validlen += len;
	}


    //
	// non const start buffer position
	// 
	iterator begin() 
	{
		return m_Buffer.begin();
	}

	
	//
	// const end buffer position
	//
 	const_iterator  end() const
	{
		return m_Buffer.begin() + size();
	}


	//
	// non const end buffer position
	//
 	iterator  end() 
	{
		return m_Buffer.begin() + size();
	}



	//
	// The buffer capacity (physical storage)
	//
	size_t capacity()const
	{
		return m_Buffer.size();
	} 

	//
	// Request to enlarge the buffer capacity - note we should resize() not reserve()
	// the internal vector because if realocation is needed the vector will copy
	// only size() elements.
	//
	void reserve(size_t newsize)
	{
		ASSERT(size() <= capacity());
		if(capacity() >=  newsize)
		{
			return;
		}
		m_Buffer.resize(newsize);
	}

	//
	// Set valid length value of the buffer
	// You can't set it to more then allocated (capacity())
	//
	void resize(size_t newsize)
	{
		ASSERT(size() <= capacity());
		ASSERT(newsize <= capacity());
		m_validlen = newsize;
	}

	//
	// free memory and resize to 0
	//
	void free()
	{
		//
		// This the only documented way to force deallocation of memory
		//
		BufferType().swap(m_Buffer);
		m_validlen = 0;
	}


	//
	// Get valid length of the buffer. 
	// 
	size_t size() const
	{
		return m_validlen;
	}

private:
	size_t  m_validlen; 
	std::vector<T>  m_Buffer;
};



//---------------------------------------------------------
//
//  CResizeBuffer class  -  resizable buffer class that starts  using pre allocated buffer.
//  during usage - it may switch to use dynamicly allocated buffer( if needed)
//
//---------------------------------------------------------
template <class T>
class CPreAllocatedResizeBuffer
{

typedef  std::vector<T>  BufferType;
typedef  BufferType::const_iterator const_iterator;
typedef  BufferType::iterator iterator;

public:
   	CPreAllocatedResizeBuffer(
		T* pStartBuffer, 
		size_t cbStartBuffer
		)
		:
		m_validlen(0),
		m_ResizeBuffer(0),
		m_pStartBuffer(pStartBuffer),
		m_cbStartBuffer(cbStartBuffer)
		{
		}
	
	
	//
	// const start buffer position
	//
 	const_iterator begin() const
	{
		return m_pStartBuffer ? m_pStartBuffer : m_ResizeBuffer.begin();	
	}
   



    //
	// non const start buffer position
	// 
	iterator begin() 
	{
		return m_pStartBuffer ? m_pStartBuffer : m_ResizeBuffer.begin();	
	}


	void append(const T& x)
	{
		if(m_pStartBuffer == NULL)
		{
			return m_ResizeBuffer.append(x);
		}

		if(m_cbStartBuffer == m_validlen)
		{
			reserve((m_cbStartBuffer +1)*2);
			return m_ResizeBuffer.append(x);
		}
		m_pStartBuffer[m_validlen++] = x;
	}

	
	void append(const T* x, size_t len)
	{
 		if(m_pStartBuffer == NULL)
		{
			return m_ResizeBuffer.append(x, len);
		}

		if(m_cbStartBuffer < m_validlen + len)
		{
			reserve((m_cbStartBuffer + len)*2);
			return m_ResizeBuffer.append(x, len);
		}

		std::copy(
			x,
			x + len,
			m_pStartBuffer +  m_validlen
		  );

		m_validlen += len;
	}


	
	//
	// const start buffer position
	//
 	const_iterator  end() const
	{
		return m_pStartBuffer ? m_pStartBuffer + m_validlen : m_ResizeBuffer.end();	
	}


	//
	// The buffer capacity (physical storage)
	//
	size_t capacity()const
	{
		return m_pStartBuffer ? m_cbStartBuffer : m_ResizeBuffer.capacity();
	} 

	//
	// Reserve memeory - if the requested reserver memory
	// could not fit into the start buffer - copy the start buffer
	// in to the dynamicly allocated buffer.
	//
	void reserve(size_t newsize)
	{
		if(m_pStartBuffer == NULL)
		{
			m_ResizeBuffer.reserve(newsize);
			return;
		}

		if(newsize <= capacity())
			return;
		
		//
		//copy the data from the pre allocated  buffer to dynamic buffer
		//from now on - we work only with dynamic data. 
		//
		m_ResizeBuffer.reserve(newsize);
		std::copy(
			m_pStartBuffer,
			m_pStartBuffer + m_validlen,
			m_ResizeBuffer.begin()
			);
		
		m_ResizeBuffer.resize(m_validlen);	
		m_pStartBuffer = NULL;			
	}


	//
	// Set valid length value of the buffer
	// You can't set it to more then  (capacity())
	//
	void resize(size_t newsize)
	{
		ASSERT(newsize <= capacity());
		if(m_pStartBuffer == NULL)
		{
			m_ResizeBuffer.resize(newsize);						
		}
		else
		{
			m_validlen = newsize;
		}
	}

	//
	// free memory and resize to 0
	//
	void free()
	{
		if(m_pStartBuffer != NULL)
		{
			m_validlen = 0;
			return;
		}
		m_ResizeBuffer.free();
	}


	//
	// Get valid length of the buffer. 
	// 
	size_t size() const
	{
		return m_pStartBuffer ? m_validlen : m_ResizeBuffer.size();	
	}


private:
	size_t  m_validlen; 
	CResizeBuffer<T> m_ResizeBuffer; 
	T* m_pStartBuffer;
	size_t m_cbStartBuffer;
};




//---------------------------------------------------------
//
//  CStaticResizeBuffer class  -  resizable buffer class that starts  with compile time buffer.
//  during usage - it may switch to use dynamicly allocated buffer( if needed).
//
//---------------------------------------------------------
template <class T, size_t N>
class CStaticResizeBuffer	: private CPreAllocatedResizeBuffer<T>
{
public:
	using CPreAllocatedResizeBuffer<T>::size;
	using CPreAllocatedResizeBuffer<T>::reserve;
	using CPreAllocatedResizeBuffer<T>::resize;
	using CPreAllocatedResizeBuffer<T>::capacity;
	using CPreAllocatedResizeBuffer<T>::begin;
	using CPreAllocatedResizeBuffer<T>::end;
	using CPreAllocatedResizeBuffer<T>::append;
	using CPreAllocatedResizeBuffer<T>::free;




public:
	CStaticResizeBuffer(
		void
		):
		CPreAllocatedResizeBuffer<T>(m_buffer, N)
		{
		}

	CPreAllocatedResizeBuffer<T>* get() 
	{
		return this;
	}
	
	const CPreAllocatedResizeBuffer<T>* get() const
	{
		return this;
	}

private:
	T m_buffer[N];
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\inc\cm.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Cm.h

Abstract:
    Configuration Manager public interface

Author:
    Uri Habusha (urih) 28-Apr-99

--*/

#pragma once

#ifndef _MSMQ_Cm_H_
#define _MSMQ_Cm_H_

class RegEntry 
{
public:
    //
    // BUGBUG: Do we need a seperate flag for read/write/delete?
    //
    //         E.g., same constant RegEntry is used for read and write
    //         operations. The user want Reads to be optional so is can
    //         fail silently, but Writes must always succeed, so if an
    //         error occurs it should throw an exception.
    //                                                   urih 06-Dec-99
    //
    enum RegFlag { Optional, MustExist };

public:
    RegEntry(
        LPCWSTR SubKey,
        LPCWSTR ValueName, 
        DWORD DefaultValue = 0,
        RegFlag Flags = Optional,
		HKEY Key = NULL
        );

public:
    RegFlag m_Flags;
    LPCWSTR m_SubKey;
    LPCWSTR m_ValueName;
	DWORD m_DefaultValue;
	HKEY m_Key;
};

inline
RegEntry::RegEntry(
        LPCWSTR SubKey,
        LPCWSTR ValueName, 
        DWORD DefaultValue, //  = 0,
        RegFlag Flags,  // = Optional,
		HKEY Key 
    ) :
    m_Key(Key),
	m_SubKey(SubKey),
    m_ValueName(ValueName),
	m_Flags(Flags),
	m_DefaultValue(DefaultValue)
{
}

class CTimeDuration;

void CmInitialize(HKEY hKey, LPCWSTR RootKeyPath);

//
// Fixed size
//
void CmQueryValue(const RegEntry& Entry, DWORD* pValue);
void CmQueryValue(const RegEntry& Entry, GUID* pValue);
void CmQueryValue(const RegEntry& Entry, CTimeDuration* pValue);


//
// Variable size, use "delete" to free
//
void CmQueryValue(const RegEntry& Entry, WCHAR** pValue);
void CmQueryValue(const RegEntry& Entry, BYTE** pValue, DWORD* pSize);


void CmSetValue(const RegEntry& Entry, DWORD Value);
void CmSetValue(const RegEntry& Entry, const CTimeDuration& Value);

void CmSetValue(const RegEntry& Entry, const GUID* pValue);
void CmSetValue(const RegEntry& Entry, const BYTE* pValue, DWORD Size);
void CmSetValue(const RegEntry& Entry, const WCHAR* pValue);

void CmDeleteValue(const RegEntry& Entry);
void CmDeleteKey(const RegEntry& Entry);

HKEY CmCreateKey(const RegEntry& Entry, REGSAM securityAccess);
HKEY CmOpenKey(const RegEntry& Entry, REGSAM securityAccess);
void CmCloseKey(HKEY hKey);

//
// Enum functions
//
bool CmEnumValue(HKEY hKey, DWORD Index, LPWSTR* ppValueName);

#endif // _MSMQ_Cm_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\inc\cry.h ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:
    Cry.h

Abstract:
    Cryptograph public interface

Author:
    Ilan Herbst (ilanh) 28-Feb-00

--*/

#pragma once

#ifndef _MSMQ_CRY_H_
#define _MSMQ_CRY_H_


#include <mqexception.h>


//-------------------------------------------------------------------
//
// Exception class bad_CryptoProvider
//
//-------------------------------------------------------------------
class bad_CryptoProvider : public bad_win32_error
{
    typedef bad_win32_error Inherited;

public:

    bad_CryptoProvider(ULONG error): Inherited(error) {}

}; // class bad_CryptoProvider


//-------------------------------------------------------------------
//
// Exception class bad_CryptoApi
//
//-------------------------------------------------------------------
class bad_CryptoApi : public bad_win32_error
{
    typedef bad_win32_error Inherited;

public:

    bad_CryptoApi(ULONG error): Inherited(error) {}

}; // class bad_CryptoApi


//---------------------------------------------------------
//
//  class CCryptKeyHandle
//
//---------------------------------------------------------
class CCryptKeyHandle {
public:
    CCryptKeyHandle(HCRYPTKEY h = 0) : m_h(h)  {}
   ~CCryptKeyHandle()               { if (m_h != 0) CryptDestroyKey(m_h); }

    HCRYPTKEY* operator &()         { return &m_h; }
    operator HCRYPTKEY() const      { return m_h; }
    HCRYPTKEY detach()              { HCRYPTKEY h = m_h; m_h = 0; return h; }

private:
    CCryptKeyHandle(const CCryptKeyHandle&);
    CCryptKeyHandle& operator=(const CCryptKeyHandle&);

private:
	HCRYPTKEY m_h;
};

//---------------------------------------------------------
//
//  class CCspHandle
//
//---------------------------------------------------------
class CCspHandle {
public:
    CCspHandle(HCRYPTPROV h = 0) : m_h(h)  {}
   ~CCspHandle()                    { if (m_h != 0) CryptReleaseContext(m_h,0); }

    HCRYPTPROV* operator &()        { return &m_h; }
    operator HCRYPTPROV() const     { return m_h; }
    HCRYPTPROV detach()             { HCRYPTPROV h = m_h; m_h = 0; return h; }

private:
    CCspHandle(const CCspHandle&);
    CCspHandle& operator=(const CCspHandle&);

private:
	HCRYPTPROV m_h;
};


//---------------------------------------------------------
//
//  class CHashHandle
//
//---------------------------------------------------------
class CHashHandle {
public:
    CHashHandle(HCRYPTHASH h = 0) : m_h(h)  {}
   ~CHashHandle()                    { if (m_h != 0) CryptDestroyHash(m_h); }

    HCRYPTHASH* operator &()        { return &m_h; }
    operator HCRYPTHASH() const     { return m_h; }
    HCRYPTHASH detach()             { HCRYPTHASH h = m_h; m_h = 0; return h; }

private:
    CHashHandle(const CHashHandle&);
    CHashHandle& operator=(const CHashHandle&);

private:
	HCRYPTHASH m_h;
};


VOID
CryInitialize(
    VOID
    );


HCRYPTPROV 
CryAcquireCsp(
	LPCTSTR CspProvider
	);


HCRYPTKEY 
CryGenSessionKey(
	HCRYPTPROV hCsp
	);


HCRYPTKEY 
CryGetPublicKey(
	DWORD PrivateKeySpec,
	HCRYPTPROV hCsp
	);


HCRYPTHASH 
CryCreateHash(
	HCRYPTPROV hCsp, 
	ALG_ID AlgId
	);


void 
CryHashData(
	const BYTE *Buffer, 
	DWORD BufferLen, 
	HCRYPTHASH hHash
	);


BYTE* 
CryGetHashData(
	const HCRYPTHASH hHash,
	DWORD *HashValLen
	);


BYTE* 
CryCalcHash(
	HCRYPTPROV hCsp,
	const BYTE* Buffer, 
	DWORD BufferLen, 
	ALG_ID AlgId,
	DWORD *HashLen
	);


BYTE* 
CryCreateSignature(
	HCRYPTPROV hCsp,
	const BYTE* Buffer, 
	DWORD BufferLen, 
	ALG_ID AlgId,
	DWORD PrivateKeySpec,
	DWORD *SignLen
	);


BYTE* 
CryCreateSignature(
	const HCRYPTHASH hHash,
	DWORD PrivateKeySpec,
	DWORD *SignLen
	);


bool 
CryValidateSignature(
	HCRYPTPROV hCsp,
	const BYTE* SignBuffer, 
	DWORD SignBufferLen, 
	const BYTE* Buffer,
	DWORD BufferLen,
	ALG_ID AlgId,
	HCRYPTKEY hKey
	);


LPSTR 
CryEncrypt(
	const LPSTR& Msg, 
	DWORD& MsgLength, 
	HCRYPTKEY hKey
	);


void 
CryDecrypt(
	LPSTR& EncrptMsg, 
	DWORD& MsgLength, 
	HCRYPTKEY hKey
	);


#endif // _MSMQ_CRY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\inc\dld.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    dldt.h

Abstract:
    Delay Load Handler public interface

Author:
    conradc (conradc) 24-Apr-01

--*/

#pragma once

#ifndef _MSMQ_dld_H_
#define _MSMQ_dld_H_


VOID  DldInitialize();

#pragma once

// Get the public delay load stub definitions.
//
#include <dloaddef.h>

// 'B' for both
// 'P' for procname only
// 'O' for ordinal only
//
#define DLDENTRYB(_dllbasename) \
    { #_dllbasename".dll", \
      &c_Pmap_##_dllbasename, \
      &c_Omap_##_dllbasename },

#define DLDENTRYB_DRV(_dllbasename) \
    { #_dllbasename".drv", \
      &c_Pmap_##_dllbasename, \
      &c_Omap_##_dllbasename },

#define DLDENTRYP(_dllbasename) \
    { #_dllbasename".dll", \
      &c_Pmap_##_dllbasename, \
      NULL },

#define DLDENTRYP_DRV(_dllbasename) \
    { #_dllbasename".drv", \
      &c_Pmap_##_dllbasename, \
      NULL },

#define DLDENTRYO(_dllbasename) \
    { #_dllbasename".dll", \
      NULL, \
      &c_Omap_##_dllbasename },



extern const DLOAD_DLL_MAP g_DllMap;

#endif // _MSMQ_dld_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\inc\cs.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    cs.h

Abstract:
    Critical Section Auto classes

Author:
    Erez Haba (erezh) 06-jan-97

--*/

#pragma once

#ifndef _MSMQ_CS_H_
#define _MSMQ_CS_H_

#include <new>

//---------------------------------------------------------
//
//  class CCriticalSection
//
//---------------------------------------------------------
class CCriticalSection {

    friend class CS;

public:

    static const DWORD xAllocateSpinCount = 0x80000000;

public:
    CCriticalSection()
    {
        InitializeCriticalSection(&m_cs);
    }

	//
	// Use xAllocateSpinCount as argument to construct a critical section with
	// allocated resources. i.e. it will not throw exceptions on Lock()
	//
	CCriticalSection(DWORD SpinCount)
	{
        __try
        {
            if(!InitializeCriticalSectionAndSpinCount(&m_cs, SpinCount))
            {
                ThrowBadAlloc();
            }
        }
        __except(GetExceptionCode() == STATUS_NO_MEMORY)
        {
            //
            // In low memory situations, EnterCriticalSection can raise
            // a STATUS_NO_MEMORY exception. We translate this exception
            // to a low memory exception.
            //
            ThrowBadAlloc();
        }
    }


    ~CCriticalSection()
    {
        DeleteCriticalSection(&m_cs);
    }
    
private:
    void Lock()
    {
        __try
        {
            EnterCriticalSection(&m_cs);
        }
        __except(GetExceptionCode() == STATUS_INVALID_HANDLE)
        {
            //
            // In low memory situations, EnterCriticalSection can raise
            // a STATUS_INVALID_HANDLE exception. We translate this exception
            // to a low memory exception.
            //
            ThrowBadAlloc();
        }
    }


    void Unlock()
    {
        LeaveCriticalSection(&m_cs);
    }


    static void ThrowBadAlloc()
    {
        //
        // Workaround to enable PREfast. This can not be thrown directly
        // from within an __except block.
        //
        throw std::bad_alloc();
    }

private:
    CRITICAL_SECTION m_cs;       
};


//---------------------------------------------------------
//
//  class CS
//
//---------------------------------------------------------
class CS {
public:
    CS(CCriticalSection& lock) : m_lock(&lock)
		{
			m_lock->Lock();
	}


    ~CS()
    {
			m_lock->Unlock();
		}

private:
    CCriticalSection* m_lock;
};



#endif // _MSMQ_CS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\inc\ev.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Ev.h

Abstract:
    Event Report public interface

Author:
    Uri Habusha (urih) 04-May-99

--*/

#pragma once

#ifndef _MSMQ_Ev_H_
#define _MSMQ_Ev_H_

VOID
EvInitialize(
    LPCWSTR ApplicationName
    );

VOID
__cdecl
EvReport(
    DWORD EventId,
    DWORD RawDataSize,
    PVOID RawData,
    WORD NoOfStrings,
    ... 
    );

VOID
__cdecl
EvReport(
    DWORD EventId,
    WORD NoOfStrings,
    ... 
    );

VOID
EvReport(
    DWORD EventId
    );

VOID 
EvSetup(
    LPCWSTR ApplicationName,
    LPCWSTR ReportModuleName
    );


#endif // _MSMQ_Ev_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\inc\doublekeymap.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:
    doublekeymap.h

Abstract:
    CDoubleKeyMap implements double key mapping template.  It enables searching a data 
    according each one of the keys.

    CDoubleKeyMap is defined as a combination of 2 maps that the value of each one of them 
    is a set of the opposite key type. Following diagram illustrates the internal 
    datastructure.


     MAP1                                           MAP2

     KEY      VALUE (set)                           KEY      VALUE (set)
    +-------+---------------------------+          +-------+---------------------------+
    |       |                           |          |       |                           |
    | K1_1  | K2_1, K2_2, K2_N          |          | K2_1  | K1_1, K1_3                |
    |       |                           |          |       |                           |
    +-------+---------------------------+          +-------+---------------------------+
    |       |                           |          |       |                           |
    | K1_2  | K2_3                      |          | K2_2  | K1_1                      |
    |       |                           |          |       |                           |
    +-------+---------------------------+          +-------+---------------------------+
    |       |                           |          |       |                           |
    | K1_3  | K2_1, K2_3                |          | K2_3  | K1_2, K1_3                          |
    |       |                           |          |       |                           |
    +-------+---------------------------+          +-------+---------------------------+
        o                                              o
        o                                              o
        o                                              o
    +-------+---------------------------+          +-------+---------------------------+
    |       |                           |          |       |                           |
    |       |                           |          | K2_N  |  K1_1                     |
    |       |                           |          |       |                           |
    +-------+---------------------------+          +-------+---------------------------+

    CDoubleKeyMap  implements the basic operation, Insert of 2 elements to the map, erase
    and find.

    CDoubleKeyMap isn't multithread sfae. It is the user reponsibility.

    In the future instead of inserting the data to the set we can insert iterator in the 
    opposite map.

Author:
    Uri Habusha (urih) 20-Oct-2000

--*/

#pragma once

#ifndef __DOUBLEKEYMAP_H__
#define __DOUBLEKEYMAP_H__

template<class Key1, class Key2, class Pred1 = std::less<Key1>, class Pred2 = std::less<Key2>, class A1 = std::allocator<Key1>, class A2 = std::allocator<Key2> >
class CDoubleKeyMap
{
public:
    typedef std::set< Key1, Pred1, A1 > KEY1SET;
    typedef std::set< Key2, Pred2, A2 > KEY2SET;

private:
    typedef std::map< Key1, KEY2SET ,Pred1 ,A1 > MAP_KEY1_TO_KEY2SET;	
    typedef std::map< Key2, KEY1SET ,Pred2 ,A2 > MAP_KEY2_TO_KEY1SET;	

public:
    explicit CDoubleKeyMap(
        const Pred1& pred1 = Pred1(), 
        const Pred2& pred2 = Pred2(), 
        const A1& a1 = A1(),
        const A2& a2 = A2()
        ):
        m_mapKey1ToKey2(pred1,a1),
        m_mapKey2ToKey1(pred2,a2)
	{
	}


	void insert(const Key1& k1, const Key2& k2)
    {
        InsertToFirstMap(k1, k2);
        try
        {
            InsertToSecondMap(k2, k1);
        }
        catch(const std::exception&)
        {
            //
            // cleanup previous data
            //
            RemoveFromFirstMap(k1, k2);
            throw;
        }
    }

	
	void erase(const Key1& k1, const Key2& k2)
    {
        RemoveFromFirstMap(k1, k2);
        RemoveFromSecondMap(k2, k1);
    }


    void erase_key1(const Key1& k1)
    {
        MAP_KEY1_TO_KEY2SET::iterator it = m_mapKey1ToKey2.find(k1);
    
        if (it == m_mapKey1ToKey2.end())
            return;
    
        KEY2SET& s2 = it->second;

        for(KEY2SET::iterator it1 = s2.begin(); it1 != s2.end(); ++it1)
        {
            RemoveFromSecondMap(*it1, k1);
        }

        m_mapKey1ToKey2.erase(it);
    }


    void erase_key2(const Key2& k2)
    {
        MAP_KEY2_TO_KEY1SET::iterator it = m_mapKey2ToKey1.find(k2);
    
        if (it == m_mapKey2ToKey1.end())
            return;
    
        KEY1SET& s1 = it->second;

        for(KEY1SET::iterator it1 = s1.begin(); it1 != s1.end(); ++it1)
        {
            RemoveFromFirstMap(*it1, k2);
        }

        m_mapKey2ToKey1.erase(it);
    }

	
    KEY2SET get_key2set(const Key1& k1) const
    {
        MAP_KEY1_TO_KEY2SET::const_iterator it = m_mapKey1ToKey2.find(k1);
    
        if (it == m_mapKey1ToKey2.end())
        {
            return KEY2SET();
        }
        return it->second;
    }

    
    KEY1SET get_key1set(const Key2& k2) const
    {
        MAP_KEY2_TO_KEY1SET::const_iterator it = m_mapKey2ToKey1.find(k2);
    
        if (it == m_mapKey2ToKey1.end())
        {
            return KEY1SET();
        }

        return it->second;
    }


    bool key1_empty(const Key1& key) const
    {
        return (m_mapKey1ToKey2.find(key) == m_mapKey1ToKey2.end());
    }


    bool key2_empty(const Key2& key) const
    {
        return (m_mapKey2ToKey1.find(key) == m_mapKey2ToKey1.end());
    }


private:
    static bool Insert(KEY1SET& s1, const Key1& v) 
    {
        return s1.insert(v).second;
    }


    static bool Insert(KEY2SET& s2, const Key2& v)
    {
        return s2.insert(v).second;
    }


    void InsertToFirstMap(const Key1& k1, const Key2& k2)
    {
        MAP_KEY1_TO_KEY2SET::iterator it1 = m_mapKey1ToKey2.find(k1);

        if (it1 != m_mapKey1ToKey2.end())
        {
            bool f = Insert(it1->second, k2);
            ASSERT(("Second key already associated to first key", f));
            DBG_USED(f);

            return;
        }

        KEY2SET val2;
        val2.insert(k2);

        m_mapKey1ToKey2.insert(MAP_KEY1_TO_KEY2SET::value_type(k1, val2));
    }


    void InsertToSecondMap(const Key2& k2, const Key1& k1)
    {
        MAP_KEY2_TO_KEY1SET::iterator it = m_mapKey2ToKey1.find(k2);

        if (it != m_mapKey2ToKey1.end())
        {
            bool f = Insert(it->second, k1);
            ASSERT(("First key already associated to second key", f));
            DBG_USED(f);

            return;
        }

        KEY1SET val1;
        val1.insert(k1);
    
        m_mapKey2ToKey1.insert(MAP_KEY2_TO_KEY1SET::value_type(k2, val1));
    }


    void RemoveFromFirstMap(const Key1& k1, const Key2& k2)
    {
        MAP_KEY1_TO_KEY2SET::iterator it = m_mapKey1ToKey2.find(k1);
        ASSERT (it != m_mapKey1ToKey2.end());

        (it->second).erase(k2);
        if ((it->second).empty())
        {
            m_mapKey1ToKey2.erase(it);
        }
    }


    void RemoveFromSecondMap(const Key2& k2, const Key1& k1)
    {
        MAP_KEY2_TO_KEY1SET::iterator it = m_mapKey2ToKey1.find(k2);
        ASSERT (it != m_mapKey2ToKey1.end());

        (it->second).erase(k1);
        if ((it->second).empty())
        {
            m_mapKey2ToKey1.erase(it);
        }
    }


private:
    MAP_KEY1_TO_KEY2SET m_mapKey1ToKey2;	
	MAP_KEY2_TO_KEY1SET m_mapKey2ToKey1;
};


#endif //   __DOUBLEKEYMAP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\inc\dloaddef.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    dloaddef.h

Abstract:

    This header defines the basic data types and macros needed to support
    building delay-load stubs to be linked into kernel32.
    See nt/base/dload where dload.lib is built.
    See nt/net/published/lib/dload where dloadnet.lib is built.
    Both are linked into kernel32 and provide the failure hooks which support
    delay loading (via /DELAYLOAD linker switch) various DLLs in the system.
   
Author:
    
    Shaun Cox (shaunco) 10-Mar-2000

Environment:

    User mode only.

Revision History:
    conradc   May 3, 2001 
	      Copy from nt\public\internal\base\inc\dloaddef.h because there is problem in 	      linking when using const with DLOAD_PROCNAME_MAP. 


--*/

#pragma once

#define celems(_x)          (sizeof(_x) / sizeof(_x[0]))


typedef struct _DLOAD_PROCNAME_ENTRY
{
    LPCSTR  pszProcName;
    FARPROC pfnProc;
} DLOAD_PROCNAME_ENTRY;

#define DLPENTRY(_fcn)  { #_fcn, (FARPROC)_fcn },

#define DEFINE_PROCNAME_ENTRIES(_dllbasename) \
    const DLOAD_PROCNAME_ENTRY c_PmapEntries_##_dllbasename [] =


typedef struct _DLOAD_PROCNAME_MAP
{
    UINT                        NumberOfEntries;
    const DLOAD_PROCNAME_ENTRY* pProcNameEntry;
} DLOAD_PROCNAME_MAP;

#define DECLARE_PROCNAME_MAP(_dllbasename) \
    extern  DLOAD_PROCNAME_MAP c_Pmap_##_dllbasename;

#define DEFINE_PROCNAME_MAP(_dllbasename) \
    DLOAD_PROCNAME_MAP c_Pmap_##_dllbasename = \
    { \
        celems(c_PmapEntries_##_dllbasename), \
        c_PmapEntries_##_dllbasename \
    };




typedef struct _DLOAD_ORDINAL_ENTRY
{
    DWORD   dwOrdinal;
    FARPROC pfnProc;
} DLOAD_ORDINAL_ENTRY;

#define DLOENTRY(_ord, _fcn)  { _ord, (FARPROC)_fcn },

#define DEFINE_ORDINAL_ENTRIES(_dllbasename) \
    const DLOAD_ORDINAL_ENTRY c_OmapEntries_##_dllbasename [] =


typedef struct _DLOAD_ORDINAL_MAP
{
    UINT                        NumberOfEntries;
    const DLOAD_ORDINAL_ENTRY*  pOrdinalEntry;
} DLOAD_ORDINAL_MAP;

#define DECLARE_ORDINAL_MAP(_dllbasename) \
    extern const DLOAD_ORDINAL_MAP c_Omap_##_dllbasename;

#define DEFINE_ORDINAL_MAP(_dllbasename) \
    const DLOAD_ORDINAL_MAP c_Omap_##_dllbasename = \
    { \
        celems(c_OmapEntries_##_dllbasename), \
        c_OmapEntries_##_dllbasename \
    };


typedef struct _DLOAD_DLL_ENTRY
{
    LPCSTR                      pszDll;
    const DLOAD_PROCNAME_MAP*   pProcNameMap;
    const DLOAD_ORDINAL_MAP*    pOrdinalMap;
} DLOAD_DLL_ENTRY;

typedef struct _DLOAD_DLL_MAP
{
    UINT                    NumberOfEntries;
    const DLOAD_DLL_ENTRY*  pDllEntry;
} DLOAD_DLL_MAP;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\inc\libpch.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    libpch.h

Abstract:

    Include the *real* libpch header.

Author:

    Shai Kariv    (shaik)   03-Jun-2000

Revision History:

--*/

#include "..\libpch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\inc\lim.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    lim.h

Abstract:
    Define numeric limits to types not defined in limit standard header.
	This header extend limit standard header.

Author:
    Gil Shafriri (gilsh)

--*/


#pragma once

#ifndef LIM_H
#define LIM_H

#include <limits>

namespace std
{

// CLASS numeric_limits<__int64>
class  numeric_limits<__int64> : public _Num_int_base 
{
public:
	typedef __int64 _Ty;
	static _Ty (__cdecl min)() _THROW0()
	{
		return (_I64_MIN); 
	}

	static _Ty (__cdecl max)() _THROW0()
	{
		return (_I64_MAX); 
	};

};
 


// CLASS numeric_limits<unsigned __int64>
class numeric_limits<unsigned __int64> : public _Num_int_base 
{
public:
	typedef unsigned __int64 _Ty;
	static _Ty (__cdecl min)() _THROW0()
	{
		return (0); 
	}

	static _Ty (__cdecl max)() _THROW0()
	{
		return (_UI64_MAX); 
	
	};
};

}// namesoace std

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\inc\ex.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Ex.h

Abstract:
    Exceutive public interface

Author:
    Erez Haba (erezh) 03-Jan-99

--*/

#pragma once

#ifndef _MSMQ_Ex_H_
#define _MSMQ_Ex_H_

#include <TimeTypes.h>

class EXOVERLAPPED;
class CTimer;


VOID
ExInitialize(
    DWORD ThreadCount
    );


VOID
ExAttachHandle(
    HANDLE Handle
    );


VOID
ExPostRequest(
    EXOVERLAPPED* pOverlapped
    );

VOID
ExSetTimer(
    CTimer* pTimer,
    const CTimeDuration& Timeout
    );

VOID
ExSetTimer(
    CTimer* pTimer,
    const CTimeInstant& ExpirationTime
    );

BOOL
ExRenewTimer(
    CTimer* pTimer,
    const CTimeDuration& Timeout
    );

BOOL
ExCancelTimer(
    CTimer* pTimer
    );

CTimeInstant
ExGetCurrentTime(
    VOID
    );


//---------------------------------------------------------
//
// Exceutive Overlapped
//
//---------------------------------------------------------
class EXOVERLAPPED : public OVERLAPPED {
public:

    typedef VOID (WINAPI *COMPLETION_ROUTINE)(EXOVERLAPPED* pov);

public:
    EXOVERLAPPED(
            COMPLETION_ROUTINE pfnSuccessRoutine,
            COMPLETION_ROUTINE pfnFailureRoutine
            );

    VOID SetStatus(HRESULT rc);
    HRESULT GetStatus() const;

    VOID CompleteRequest();
    VOID CompleteRequest(HRESULT rc);

private:
    COMPLETION_ROUTINE m_pfnSuccess;
    COMPLETION_ROUTINE m_pfnFailure;
};


inline
EXOVERLAPPED::EXOVERLAPPED(
    COMPLETION_ROUTINE pfnSuccessRoutine,
    COMPLETION_ROUTINE pfnFailureRoutine
    ) :
    m_pfnSuccess(pfnSuccessRoutine),
    m_pfnFailure(pfnFailureRoutine)
{
	ASSERT(("Illegal successroutine", (pfnSuccessRoutine != NULL)));
	ASSERT(("Illegal failure routine", (pfnFailureRoutine !=NULL)));

    memset(static_cast<OVERLAPPED*>(this), 0, sizeof(OVERLAPPED));
}


inline VOID EXOVERLAPPED::SetStatus(HRESULT rc)
{
    Internal = rc;
}


inline HRESULT EXOVERLAPPED::GetStatus() const
{
    return static_cast<HRESULT>(Internal);
}


inline VOID EXOVERLAPPED::CompleteRequest(HRESULT rc)
{
    SetStatus(rc);
    CompleteRequest();
}


//---------------------------------------------------------
//
// Exceutive Timer
//
//---------------------------------------------------------
class CTimer {
public:

    friend class CScheduler;
    typedef VOID (WINAPI *CALLBACK_ROUTINE)(CTimer* pTimer);

public:

    CTimer(CALLBACK_ROUTINE pfnCallback);
    ~CTimer();

    bool InUse() const;

private:
    const CTimeInstant& GetExpirationTime() const;
    void SetExpirationTime(const CTimeInstant& ExpirationTime);

private:
    CTimer(const CTimer&);
    CTimer& operator=(const CTimer&);

private:
    EXOVERLAPPED m_ov;
    CTimeInstant m_ExpirationTime;

public:
    LIST_ENTRY m_link;

};


inline
CTimer::CTimer(
    CALLBACK_ROUTINE pfnCallback
    ) :
    m_ov(reinterpret_cast<EXOVERLAPPED::COMPLETION_ROUTINE>(pfnCallback),
         reinterpret_cast<EXOVERLAPPED::COMPLETION_ROUTINE>(pfnCallback)),
    m_ExpirationTime(CTimeInstant::MinValue())
{
    m_link.Flink = NULL;
    m_link.Blink = NULL;


    //
    // Verify that the overlapped is the first CTimer member. This is required
    // since the Calback routine is casted to the overlapped completion routine
    //
    //
    C_ASSERT(FIELD_OFFSET(CTimer, m_ov) == 0);
}


inline CTimer::~CTimer()
{
    ASSERT(MmIsStaticAddress(this) || !InUse());
}


inline bool CTimer::InUse() const
{
    return (m_link.Flink != NULL);
}

#endif // _MSMQ_Ex_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\inc\fntoken.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:
    fntoken.h

Abstract:
    Format Name tokens

Author:
    Erez Haba (erezh) 17-Jan-1997

Revision History:

--*/

#ifndef __FNTOKEN_H
#define __FNTOKEN_H

#include <mqmacro.h>


#define GUID_ELEMENTS(p) \
    (p)->Data1, (p)->Data2, (p)->Data3,\
    (p)->Data4[0], (p)->Data4[1], (p)->Data4[2], (p)->Data4[3],\
    (p)->Data4[4], (p)->Data4[5], (p)->Data4[6], (p)->Data4[7]

//
//  GUID_STR_LENGTH is the buffer size required for string guid
//
#define GUID_FORMAT_A	"%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x"
#define GUID_FORMAT     L"%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x"
#define GUID_STR_LENGTH (8 + 1 + 4 + 1 + 4 + 1 + 4 + 1 + 12)



//
//  Format Name prefix tokens
//
#define FN_PUBLIC_TOKEN         L"PUBLIC"
#define FN_PUBLIC_TOKEN_LEN     STRLEN(FN_PUBLIC_TOKEN)

#define FN_DL_TOKEN             L"DL"
#define FN_DL_TOKEN_LEN         STRLEN(FN_DL_TOKEN)

#define FN_PRIVATE_TOKEN        L"PRIVATE"
#define FN_PRIVATE_TOKEN_LEN    STRLEN(FN_PRIVATE_TOKEN)

#define FN_PRIVATE_$_TOKEN        L"PRIVATE$"
#define FN_PRIVATE_$_TOKEN_LEN    STRLEN(FN_PRIVATE_$_TOKEN)



#define FN_DIRECT_TOKEN         L"DIRECT"
#define FN_DIRECT_TOKEN_LEN     STRLEN(FN_DIRECT_TOKEN)

#define FN_MACHINE_TOKEN        L"MACHINE"
#define FN_MACHINE_TOKEN_LEN    STRLEN(FN_MACHINE_TOKEN)

#define FN_CONNECTOR_TOKEN      L"CONNECTOR"
#define FN_CONNECTOR_TOKEN_LEN  STRLEN(FN_CONNECTOR_TOKEN)

#define FN_MULTICAST_TOKEN      L"MULTICAST"
#define FN_MULTICAST_TOKEN_LEN  STRLEN(FN_MULTICAST_TOKEN)




#define FN_PRIVATE_QUEUE_PATH_INDICATIOR L"PRIVATE$\\"
#define FN_PRIVATE_QUEUE_PATH_INDICATIOR_LENGTH \
    STRLEN(FN_PRIVATE_QUEUE_PATH_INDICATIOR)

#define FN_SYSTEM_QUEUE_PATH_INDICATIOR L"SYSTEM$"
#define FN_SYSTEM_QUEUE_PATH_INDICATIOR_LENGTH \
    STRLEN(FN_SYSTEM_QUEUE_PATH_INDICATIOR)

//
//  Format Name suffix tokens
//
#define FN_NONE_SUFFIX          L""
#define FN_NONE_SUFFIX_LEN      STRLEN(FN_NONE_SUFFIX)

#define FN_JOURNAL_SUFFIX       L";JOURNAL"
#define FN_JOURNAL_SUFFIX_LEN   STRLEN(FN_JOURNAL_SUFFIX)

#define FN_DEADLETTER_SUFFIX    L";DEADLETTER"
#define FN_DEADLETTER_SUFFIX_LEN STRLEN(FN_DEADLETTER_SUFFIX)

#define FN_DEADXACT_SUFFIX      L";DEADXACT"
#define FN_DEADXACT_SUFFIX_LEN  STRLEN(FN_DEADXACT_SUFFIX)

#define FN_XACTONLY_SUFFIX      L";XACTONLY"
#define FN_XACTONLY_SUFFIX_LEN  STRLEN(FN_XACTONLY_SUFFIX)


//
//  Format Name direct infix tokens
//
#define FN_DIRECT_OS_TOKEN      L"OS:"
#define FN_DIRECT_OS_TOKEN_LEN  STRLEN(FN_DIRECT_OS_TOKEN)

#define FN_DIRECT_TCP_TOKEN     L"TCP:"
#define FN_DIRECT_TCP_TOKEN_LEN STRLEN(FN_DIRECT_TCP_TOKEN)

#define FN_DIRECT_HTTP_TOKEN    L"HTTP://"
#define FN_DIRECT_HTTP_TOKEN_LEN STRLEN(FN_DIRECT_HTTP_TOKEN)

#define FN_DIRECT_HTTPS_TOKEN   L"HTTPS://"
#define FN_DIRECT_HTTPS_TOKEN_LEN STRLEN(FN_DIRECT_HTTPS_TOKEN)

//
// MSMQ: is used to prefix msmq format names in the srmp message.
//
const   WCHAR FN_MSMQ_URI_PREFIX_TOKEN[] = L"MSMQ:";
const   size_t FN_MSMQ_URI_PREFIX_TOKEN_LEN = STRLEN(FN_MSMQ_URI_PREFIX_TOKEN);




//
// This token represents the msmq namespace - comes in http format between the
// computer name and the queue name.
// Sample http direct format name - DIRECT=HTTP://mycomputer.mycompany.com\MSMQ\myqueue
//
#define FN_MSMQ_HTTP_NAMESPACE_TOKEN   L"MSMQ"
#define FN_MSMQ_HTTP_NAMESPACE_TOKEN_LEN STRLEN(FN_MSMQ_HTTP_NAMESPACE_TOKEN)

#define FN_PRIVATE_ID_FORMAT   L"%08x"
#define FN_SUFFIX_FORMAT       L"%s"
#define FN_DOMAIN_FORMAT       L"%s"


//
//  Format Names tokens
//
#define FN_EQUAL_SIGN   L"="
#define FN_EQUAL_SIGN_C L'='

#define FN_AT_SIGN      L"@"
#define FN_AT_SIGN_C    L'@'

#define FN_DELIMITER_C      L'\\'
#define FN_LOCAL_MACHINE_C  L'.'

#define FN_PRIVATE_SEPERATOR    L"\\"
#define FN_PRIVATE_SEPERATOR_C  L'\\'

#define FN_SUFFIX_DELIMITER_C   L';'

#define FN_HTTP_SEPERATORS   L"\\/"
#define FN_HTTP_SEPERATOR_C   L'/'
#define FN_HTTP_PORT_SEPERATOR L":"

#define FN_MQF_SEPARATOR     L","
#define FN_MQF_SEPARATOR_C   L','

#endif //  __FNTOKEN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\inc\mc.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Mc.h

Abstract:
    Machine Configuration public interface

Author:
    Erez Haba (erezh) 15-Aug-99

--*/

#pragma once

#ifndef _MSMQ_Mc_H_
#define _MSMQ_Mc_H_

VOID
McInitialize(
    VOID
    );

time_t
McGetStartupTime(
	VOID
	);

LPCWSTR
McComputerName(
	VOID
	);

DWORD
McComputerNameLen(
	VOID
	);

const GUID&
McGetMachineID(
    void
    );



#ifdef _DEBUG

VOID
McSetComputerName(
	LPCSTR ComputerName
	);

#else // _DEBUG

#define McSetComputerName(ComputerName) ((void)0)

#endif // _DEBUG

BOOL
McIsLocalComputerName(
	LPCSTR ComputerName
	);

#endif _MSMQ_Mc_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\inc\list.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:
    list.h

Abstract:
    List and List::iterator, implements an intrusive double linked list and
    iterator template

    List is defined as a circular doubble linked list. With actions to insert
    and remove entries.

       List
      +-----+   +-----+ +-----+ +-----+ +-----+ +-----+
     -|     |<--|     |-|     |-|     |-|     |-|     |
      | head|   | data| | data| | data| | data| | data|
      |     |-->|     |-|     |-|     |-|     |-|     |-
      +-----+   +-----+ +-----+ +-----+ +-----+ +-----+

                      Linked list diagram

    An iteration is defined for the list using the member type named
    iterator. To declater an interator variable, use full qualified
    name. e.g., List<T>::iterator. An iterator variable is analogous
    to type T pointer. Dereference '*' and arrow '->' operators are
    overloaded for this type so you can (allmost) freely use it as a
    T pointer.

      Example:

        for(List<T>::iterator p = list.begin(); p != list.end(); ++p)
        {
            p->doSomeThing();
        }

Author:
    Erez Haba (erezh) 13-Aug-95

--*/

#pragma once

#ifndef _MSMQ_LIST_H_
#define _MSMQ_LIST_H_

// --- helper class ---------------------------------------
//
// ListHelper
//
// This template class is used to woraround C12 (VC6.0) bug where the XList
// template parameter 'Offset' can not be directly assigned the value of
// 'FIELD_OFFSET(T, m_link)'. The compiler does hot handle correctly using
// this class without specifing the type, i.e., using this template class
// in another template, as inheritance or as an agrigate.    erezh 29-Mar-99
//
template<class T>
class ListHelper {
public:

	enum { Offset = FIELD_OFFSET(T, m_link) };
};


//---------------------------------------------------------
//
//  class List
//
//---------------------------------------------------------
template<class T, int Offset = ListHelper<T>::Offset>
class List {
private:
    LIST_ENTRY m_head;

public:
    class iterator;

public:
    List();
   ~List();

    iterator begin() const;
    iterator end() const;

    bool empty() const;

    T& front() const;
    T& back() const;
    void push_front(T& item);
    void push_back(T& item);
    void pop_front();
    void pop_back();

    iterator insert(iterator it, T& item);
    iterator erase(iterator it);
    void remove(T& item);

public:
    static LIST_ENTRY* item2entry(T&);
    static T& entry2item(LIST_ENTRY*);
	static void RemoveEntry(LIST_ENTRY*);
    static void InsertBefore(LIST_ENTRY* pNext, LIST_ENTRY*);
    static void InsertAfter(LIST_ENTRY* pPrev, LIST_ENTRY*);
   

private:
    List(const List&);
    List& operator=(const List&);

public:

    //
    // class List<T, Offset>::iterator
    //
    class iterator {
    private:
        LIST_ENTRY* m_current;

    public:
        explicit iterator(LIST_ENTRY* pEntry) :
            m_current(pEntry)
        {
        }


        iterator& operator++()
        {
            m_current = m_current->Flink;
            return *this;
        }


        iterator& operator--()
        {
            m_current = m_current->Blink;
            return *this;
        }


        T& operator*() const
        {
            return entry2item(m_current);
        }

        
        T* operator->() const
        {
            return (&**this);
        }


        bool operator==(const iterator& it) const
        {
            return (m_current == it.m_current);
        }


        bool operator!=(const iterator& it) const
        {
            return !(*this == it);
        }
    };
    //
    // end class iterator decleration
    //
};


//---------------------------------------------------------
//
//  IMPLEMENTATION
//
//---------------------------------------------------------
template<class T, int Offset>
inline List<T, Offset>::List()
{
    m_head.Flink = &m_head;
    m_head.Blink = &m_head;
}


template<class T, int Offset>
inline List<T, Offset>::~List()
{
    ASSERT(empty());
}


template<class T, int Offset>
inline LIST_ENTRY* List<T, Offset>::item2entry(T& item)
{
    return ((LIST_ENTRY*)(PVOID)((PCHAR)&item + Offset));
}


template<class T, int Offset>
inline T& List<T, Offset>::entry2item(LIST_ENTRY* pEntry)
{
    return *((T*)(PVOID)((PCHAR)pEntry - Offset));
}


template<class T, int Offset>
inline void List<T, Offset>::InsertBefore(LIST_ENTRY* pNext, LIST_ENTRY* pEntry)
{
	pEntry->Flink = pNext;
	pEntry->Blink = pNext->Blink;
	pNext->Blink->Flink = pEntry;
	pNext->Blink = pEntry;
}


template<class T, int Offset>
inline void List<T, Offset>::InsertAfter(LIST_ENTRY* pPrev, LIST_ENTRY* pEntry)
{
	pEntry->Blink = pPrev;
	pEntry->Flink = pPrev->Flink;
	pPrev->Flink->Blink = pEntry;
	pPrev->Flink = pEntry;
}


template<class T, int Offset>
inline void List<T, Offset>::RemoveEntry(LIST_ENTRY* pEntry)
{
    LIST_ENTRY* Blink = pEntry->Blink;
    LIST_ENTRY* Flink = pEntry->Flink;

    Blink->Flink = Flink;
    Flink->Blink = Blink;

#ifdef _DEBUG
    pEntry->Flink = pEntry->Blink = 0;
#endif
}


template<class T, int Offset>
inline List<T, Offset>::iterator List<T, Offset>::begin() const
{
    return iterator(m_head.Flink);
}


template<class T, int Offset>
inline List<T, Offset>::iterator List<T, Offset>::end() const
{
    return iterator(const_cast<LIST_ENTRY*>(&m_head));
}


template<class T, int Offset>
inline bool List<T, Offset>::empty() const
{
    return (m_head.Flink == &m_head);
}


template<class T, int Offset>
inline T& List<T, Offset>::front() const
{
    ASSERT(!empty());
    return entry2item(m_head.Flink);
}


template<class T, int Offset>
inline T& List<T, Offset>::back() const
{
    ASSERT(!empty());
    return entry2item(m_head.Blink);
}


template<class T, int Offset>
inline void List<T, Offset>::push_front(T& item)
{
    LIST_ENTRY* pEntry = item2entry(item);
    InsertAfter(&m_head, pEntry);
}                                


template<class T, int Offset>
inline void List<T, Offset>::push_back(T& item)
{
    LIST_ENTRY* pEntry = item2entry(item);
    InsertBefore(&m_head, pEntry);
}                                


template<class T, int Offset>
inline void List<T, Offset>::pop_front()
{
    ASSERT(!empty());
    RemoveEntry(m_head.Flink);
}                                


template<class T, int Offset>
inline void List<T, Offset>::pop_back()
{
    ASSERT(!empty());
    RemoveEntry(m_head.Blink);
}                                


template<class T, int Offset>
inline List<T, Offset>::iterator List<T, Offset>::insert(iterator it, T& item)
{
    LIST_ENTRY* pEntry = item2entry(item);
    LIST_ENTRY* pNext = item2entry(*it);
    InsertBefore(pNext, pEntry);
    return iterator(pEntry);
}


template<class T, int Offset>
inline List<T, Offset>::iterator List<T, Offset>::erase(iterator it)
{
    ASSERT(it != end());
    iterator next = it;
    ++next;
    remove(*it);
    return next;
}


template<class T, int Offset>
inline void List<T, Offset>::remove(T& item)
{
    ASSERT(&item != &*end());
    LIST_ENTRY* pEntry = item2entry(item);
    RemoveEntry(pEntry);
}

#endif // _MSMQ_LIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\inc\mmt.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:

    Mmt.h

Abstract:

    Multicast Message Transport public interface

Author:

    Shai Kariv  (shaik)  27-Aug-00

--*/

#pragma once

#ifndef _MSMQ_Mmt_H_
#define _MSMQ_Mmt_H_

#include <mqwin64a.h>
#include <qformat.h>


class IMessagePool;
class ISessionPerfmon;
class CTimeDuration;


//
// Multicast Transport base class
//
class __declspec(novtable) CMulticastTransport : public CReference 
{
public:
    enum ConnectionState
    {
        csNotConnected,
        csConnected,
        csShuttingDown,
        csShutdownCompleted
    };

public:

    CMulticastTransport(MULTICAST_ID id) :
        m_state(csNotConnected),
        m_MulticastId(id)
    {
    }

    
    virtual ~CMulticastTransport() = 0
    {
    }

    ConnectionState State() const
    {
        return m_state;
    }

    
    void State(ConnectionState state) 
    {
        m_state = state;
    }

    
    MULTICAST_ID MulticastId() const
    {
        return m_MulticastId;
    }

private:
    ConnectionState m_state;
    MULTICAST_ID m_MulticastId;

}; // class CMulticastTransport


VOID
MmtInitialize(
    VOID
    );

R<CMulticastTransport>
MmtCreateTransport(
    MULTICAST_ID id,
	IMessagePool * pMessageSource,
	ISessionPerfmon* pPerfmon,
    const CTimeDuration& retryTimeout,
    const CTimeDuration& cleanupTimeout
    );

VOID
AppNotifyMulticastTransportClosed(
    MULTICAST_ID id
    );


#endif // _MSMQ_Mmt_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\inc\mm.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Mm.h

Abstract:
    Memory public interface

Author:
    Erez Haba (erezh) 04-Aug-99

--*/

#pragma once

#ifndef _MSMQ_Mm_H_
#define _MSMQ_Mm_H_

//
// Exported allocation/deallocation functions
//
void* MmAllocate(size_t) throw(bad_alloc);
void* MmAllocate(size_t, const nothrow_t&) throw();
void* MmAllocate(size_t, const char*, int) throw(bad_alloc);
void* MmAllocate(size_t, const char*, int, const nothrow_t&) throw();

void MmDeallocate(void*) throw();


//
// new and delete operators (free/checked)
//
inline void* __cdecl operator new(size_t s) throw(bad_alloc)
{
    return MmAllocate(s);
}


inline void* __cdecl operator new(size_t s, const nothrow_t& nt) throw()
{
    return MmAllocate(s, nt);
}


inline void* __cdecl operator new(size_t s, const char* fn, int l) throw(bad_alloc)
{
    return MmAllocate(s, fn, l);
}


inline void* __cdecl operator new(size_t s, const char* fn, int l, const nothrow_t& nt) throw()
{
    return MmAllocate(s, fn, l, nt);
}


inline void __cdecl operator delete(void* p) throw()
{
    MmDeallocate(p);
}


#if  defined(_M_AMD64) || defined(_M_IA64)
inline void __cdecl operator delete(void* p, const nothrow_t&) throw()
{
    MmDeallocate(p);
}
#endif


inline void __cdecl operator delete(void* p, const char*, int) throw()
{
    MmDeallocate(p);
}


inline void __cdecl operator delete(void* p, const char*, int, const nothrow_t&) throw()
{
    MmDeallocate(p);
}


//
// Memory allocation failure control
//
const int xAllocationAlwaysSucceed = 100;
const int xAllocationAlwaysFail = 0;

#ifdef _DEBUG

VOID
MmSetAllocationSeed(
	DWORD AllocationSeed
	);
						
DWORD
MmAllocationProbability(
	DWORD AllocationProbability
	);

DWORD
MmAllocationValidation(
	DWORD AllocationFlags
	);

DWORD
MmAllocationBreak(
	DWORD AllocationNumber
	);

VOID
MmCheckpoint(
    VOID
    );

VOID
MmDumpUsage(
    VOID
    );


//
// This function is for debug use only, so don't
// define its release version
//
bool
MmIsStaticAddress(
    const void* Address
    );


//
// In checked builds we trace allocation positions
//
#define DEBUG_NEW new(__FILE__, __LINE__)
#define new_nothrow new(__FILE__, __LINE__, nothrow)

//
// Tune 'new' for allocation tracing
//
#define new DEBUG_NEW

#else // _DEBUG

#define MmSetAllocationSeed(x) ((DWORD)0)
#define MmAllocationProbability(x) ((void)0)
#define MmAllocationValidation(x) ((DWORD)0)
#define MmAllocationBreak ((DWORD)0)
#define MmCheckpoint() ((void) 0)
#define MmDumpUsage() ((void) 0)

#define DEBUG_NEW new
#define new_nothrow new(nothrow)

#endif // _DEBUG

#define PUSH_NEW push_macro("new")
#define POP_NEW pop_macro("new")

//
// String functionality
//
LPWSTR newwcs(LPCWSTR p);
LPSTR  newstr(LPCSTR p);
LPWSTR newwcscat(LPCWSTR s1, LPCWSTR s2);
LPSTR  newstrcat(LPCSTR s1,LPCSTR s2);



#endif // _MSMQ_Mm_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\inc\fn.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Fn.h

Abstract:
    Format Name Parsing public interface

Author:
    Nir Aides (niraides) 21-May-00

--*/



#pragma once



#ifndef _MSMQ_Fn_H_
#define _MSMQ_Fn_H_



#include "mqwin64.h"
#include <qformat.h>
#include <mqexception.h>
#include <fntoken.h>
#include <xstr.h>

class bad_format_name: public exception
{
public:
	bad_format_name(LPCWSTR p) : exception("bad format name"), m_p(p)
	{
	}

	LPCWSTR Location() const
	{
		return m_p;
	}

private:
	LPCWSTR m_p;
};


VOID 
FnInitialize(
	VOID
	);



//
// ------------------ MQF expansion routines ---------------------
//

VOID 
FnExpandMqf(
	ULONG nTopLevelMqf, 
	const QUEUE_FORMAT TopLevelMqf[], 
	ULONG* pnLeafMqf,
	QUEUE_FORMAT** ppLeafMqf
	);


class CMqfDisposer
{
public:

    CMqfDisposer(
        ULONG        nMqf,
        QUEUE_FORMAT mqf[]
        ) :
        m_nMqf(nMqf),
        m_mqf(mqf)
    {
    }

    ~CMqfDisposer()
    {
        for ( ; m_nMqf-- != 0; )
        {
            m_mqf[m_nMqf].DisposeString();
        }
    }

private:

    ULONG          m_nMqf;
    QUEUE_FORMAT * m_mqf;

}; // class CMqfDisposer



//
// CStringsToFree - holds an array of strings to free - from the parsing process
// 
class CStringsToFree
{
public:
    CStringsToFree();
    void Add(LPWSTR pStringToFree);

private:
    AP< AP<WCHAR> > m_pStringsBuffer;
    DWORD m_nStringsToFree;
    DWORD m_nStringsToFreeAllocated;
};



//
// --------------------- Format name parsing classes & routines -------------------
//



//---------------------------------------------------------
//
//  CFnQueueFormat - create   QUEUE_FORMAT from given format name or url
//---------------------------------------------------------
class CFnQueueFormat : public QUEUE_FORMAT
{
public:
	CFnQueueFormat(){}
	
public:
	void CreateFromFormatName(LPCWSTR pfn, bool fDuplicate = false);
	void CreateFromFormatName(const xwcs_t& fn);
	void CreateFromUrl(LPCWSTR pfn, bool fDuplicate = false);
	void CreateFromUrl(const xwcs_t& fn);
    void CreateFromQueueFormat(const QUEUE_FORMAT& qf);

private:
	CFnQueueFormat(const CFnQueueFormat&);
	CFnQueueFormat& operator=(CFnQueueFormat&);	

private:
	AP<WCHAR> m_OriginalDupAutoDelete;
	AP<WCHAR> m_ParsingResultAutoDelete;
};



//---------------------------------------------------------
//
//  CFnMqf - create   list of QUEUE_FORMAT from given mqf
//---------------------------------------------------------
class CFnMqf
{
public:
	CFnMqf(
		void
		):
		m_QueueFormats(NULL),
		m_nQueueFormats(0)					
		{
		}

	explicit CFnMqf(const xwcs_t& fn)
	{
		CreateFromMqf(fn);						
	}			

	explicit CFnMqf(const WCHAR* fn)
	{
		CreateFromMqf(fn);						
	}			

public:
	void  CreateFromMqf(const xwcs_t& fn);
	void  CreateFromMqf(const WCHAR* fnstr);
	void  CreateFromMqf(const QUEUE_FORMAT* QueueFormats, DWORD nQueueFormats)
	{
		ASSERT(!(QueueFormats != NULL && nQueueFormats == 0));
		ASSERT(!(QueueFormats == NULL && nQueueFormats != 0));
		m_QueueFormats =  QueueFormats;
		m_nQueueFormats = nQueueFormats;
	}


	const QUEUE_FORMAT* GetQueueFormats() const
	{
		return 	m_QueueFormats;
	}

	const DWORD GetCount()const
	{
		return 	m_nQueueFormats;
	}

private:
	CFnMqf& operator=(const CFnMqf&);
	CFnMqf(const CFnMqf&);

private:
	CStringsToFree strsToFree;
	const QUEUE_FORMAT* m_QueueFormats;
	AP<QUEUE_FORMAT> m_AutoQueueFormats;
	DWORD m_nQueueFormats;
	AP<WCHAR> m_fnstr;
};

struct CFnSerializeQueueFormat
{
	explicit CFnSerializeQueueFormat(
		const QUEUE_FORMAT&	qf
		):
		m_qf(qf)
		{
		}

	const QUEUE_FORMAT& m_qf;	
};


struct CFnSerializeMqf
{
	CFnSerializeMqf(
		QUEUE_FORMAT*  pqf, 
		ULONG count
		)
		:
		m_pqf(pqf),
		m_count(count)
		{
		}

	QUEUE_FORMAT* m_pqf;
	ULONG m_count;
};


std::wostream&
operator<<(
   std::wostream& os, 
   const CFnSerializeQueueFormat& qf
   );


std::wostream&
operator<<(
   std::wostream& os, 
   const CFnSerializeMqf& mqf
   );



enum QUEUE_PATH_TYPE{
    ILLEGAL_QUEUE_PATH_TYPE = 0,
    PRIVATE_QUEUE_PATH_TYPE,
    PUBLIC_QUEUE_PATH_TYPE,
    SYSTEM_QUEUE_PATH_TYPE
};  


QUEUE_PATH_TYPE
FnValidateAndExpandQueuePath(
    LPCWSTR pwcsPathName,
    LPCWSTR* ppwcsExpandedPathName,
    LPWSTR* ppStringToFree
    );

LPCWSTR 
FnParseGuidString(
	LPCWSTR p, 
	GUID* pg
	);

BOOL
FnFormatNameToQueueFormat(
    LPCWSTR lpwcsFormatName,
    QUEUE_FORMAT* pQueueFormat,
    LPWSTR* ppStringToFree
    );

BOOL
FnMqfToQueueFormats(
    LPCWSTR pfn,
    AP<QUEUE_FORMAT> &pmqf,
    DWORD   *pnQueues,
    CStringsToFree &strsToFree
    );



VOID
FnExtractMachineNameFromPathName(
	LPCWSTR PathName, 
	AP<WCHAR>& MachineName
	);

VOID
FnExtractMachineNameFromDirectPath(
	LPCWSTR PathName, 
	AP<WCHAR>& MachineName
	);

enum DirectQueueType
{
    dtTCP,
    dtOS,
    dtHTTP,
    dtHTTPS
};

LPCWSTR 
FnParseDirectQueueType(
	LPCWSTR DirectQueuePath,
	DirectQueueType* dqt
	);

LPCWSTR 
FnParseMulticastString(
    LPCWSTR p, 
    MULTICAST_ID* pMulticastID
	);

VOID
FnDirectIDToLocalPathName(
	LPCWSTR DirectID, 
	LPCWSTR LocalMachineName, 
	AP<WCHAR>& PathName
	);

bool
FnIsPrivatePathName(
	LPCWSTR PathName
	);

bool
FnIsHttpFormatName(
    LPCWSTR pfn            
    );

bool
FnIsHttpDirectID(
	LPCWSTR p
	);

bool 
FnIsHttpHttpsUrl(
	LPCWSTR url
	);


bool 
FnIsHttpHttpsUrl(
	const xwcs_t& url
	);


bool 
FnIsMSMQUrl(
	LPCWSTR url
	);

bool 
FnIsMSMQUrl(
	const xwcs_t& url
	);


LPCWSTR  
FnFindResourcePath(
	LPCWSTR url
	);



bool
FnAbsoluteMsmqUrlCanonization(
	LPWSTR url
	)throw();




bool 
FnIsDirectHttpFormatName(
	const QUEUE_FORMAT* pQueueFormat
	);


bool
FnIsValidQueueFormat(
	const QUEUE_FORMAT* pQueueFormat
	);


#endif // _MSMQ_Fn_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\inc\mpnames.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    mpnames.h

Abstract:
    mp names constants

Author:
    Ilan Herbst (ilanh) 29-Apr-01

--*/

#pragma once

#ifndef _MSMQ_MPNAMES_H_
#define _MSMQ_MPNAMES_H_

#include "fntoken.h"

#define MIME_ID_FMT_A		"%.*s" GUID_FORMAT_A

#define PREFIX_INTERNAL_REFERENCE_C     L'#'

const char xPrefixMimeAttachment[] = "cid:";
const WCHAR xPrefixMimeAttachmentW[] = L"cid:";
const DWORD xPrefixMimeAttachmentLen = STRLEN(xPrefixMimeAttachment);

const char xEnvelopeId[] = "envelope@";
const WCHAR xEnvelopeIdW[] = L"envelope@";
const DWORD xEnvelopeIdLen = STRLEN(xEnvelopeId);

const char xMimeBodyId[] = "body@";
const WCHAR xMimeBodyIdW[] = L"body@";
const DWORD xMimeBodyIdLen = STRLEN(xMimeBodyId);

const char xMimeSenderCertificateId[] = "certificate@";
const WCHAR xMimeSenderCertificateIdW[] = L"certificate@";
const DWORD xMimeSenderCertificateIdLen = STRLEN(xMimeSenderCertificateId);

const char xMimeExtensionId[] = "extension@";
const WCHAR xMimeExtensionIdW[] = L"extension@";
const DWORD xMimeExtensionIdLen = STRLEN(xMimeExtensionId);


#endif // _MSMQ_MPNAMES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\inc\mp.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Mp.h

Abstract:
    SRMP Serialization and Deserialization public interface

Author:
    Uri Habusha (urih) 28-May-00

--*/

#pragma once

#ifndef _MSMQ_Mp_H_
#define _MSMQ_Mp_H_

#include <xstr.h>
#include <strutl.h>
#include <buffer.h>
#include <mpnames.h>


//-------------------------------------------------------------------
//
// Exception class bad_message
//
//-------------------------------------------------------------------
class bad_srmp : public exception 
{
public:
    bad_srmp(LPCWSTR errorType) :
        exception("bad SRMP"),
        m_errorType(errorType)
    {
    }

    const WCHAR* ErrorType() const
    {
        return m_errorType;
    }

private:
    const WCHAR* m_errorType;
};


//-------------------------------------------------------------------
//
// Exception class bad_request
//
//-------------------------------------------------------------------
class bad_request : public exception 
{
public:
    bad_request(): exception("bad HTTP request"){}
};


class CAttachmentsArray;
//-------------------------------------------------------------------
//
// class CSrmpRequestBuffers - Translate  QM packet to SRMP network buffers.
//
//-------------------------------------------------------------------
class CQmPacket;
class CSrmpRequestBuffers : public CReference
{
	typedef std::basic_string<unsigned  char> utf8_str;

public:
	CSrmpRequestBuffers(const CQmPacket& pkt, LPCWSTR targethost, LPCWSTR uri);

public:
	size_t GetNumberOfBuffers() const;
	const WSABUF* GetSendBuffers() const;
	size_t GetSendDataLength() const;
	BYTE*  SerializeSendData() const;
	std::wstring GetEnvelop() const;
	const char* GetHttpHeader() const;
	BYTE*  SerializeHttpBody() const;
	size_t GetHttpBodyLength() const;


private:
	size_t GetHttpHeaderLength() const;
	void   SFDSerializeMessage();
	void   CreateSFDHeader(const xstr_t& OrgHeader);
	void   SourceSerializeMessage();
	void   CreateHttpRequestHeaders(const CAttachmentsArray& attachments);
	void   CreateMultipartHeaders(const CAttachmentsArray& attachments);
	void   SetBufferPointers();
	void   CreateSimpleHttpHeader();
	DWORD  GenerateEnvelopeAttachmentHeader(DWORD dataSize, DWORD boundaryId);
	DWORD  GenerateMultipartAttachmentHeader(DWORD dataSize,  const xstr_t& contentId, DWORD boundaryId);
	

private:
	typedef unsigned char utf8_char;
	const CQmPacket& m_pkt;
	CStaticResizeBuffer<utf8_char, 64>  m_targethost;
	CStaticResizeBuffer<utf8_char, 64>  m_uri;
	std::vector<WSABUF> m_buffers;
	CResizeBuffer<char>  m_HttpRequestData;	
	utf8_str m_envelope;	
};



//
// Forward decleration
//
struct QUEUE_FORMAT;
struct CBaseHeader;
class  CACPacketPtrs;
 


//
// Interface functions
//
VOID
MpInitialize(
    VOID
    );



CQmPacket*
MpDeserialize(
    const char* httpHeader,
    DWORD bodySize,
    const BYTE* body,
    const QUEUE_FORMAT* pqf,
	bool fLocal = false
    );




R<CSrmpRequestBuffers>
MpSerialize(
	const CQmPacket& pkt,
	LPCWSTR targethost,
	LPCWSTR uri
	);


//------------------------------------------------
//
// App override function
//
//------------------------------------------------
          
struct QUEUE_FORMAT;

void
AppAllocatePacket(
    const QUEUE_FORMAT& destQueue,
    UCHAR delivery,
    DWORD pktSize,
    CACPacketPtrs& pktPtrs
    );

void
AppFreePacket(
    CACPacketPtrs& pktPtrs
    );

PSID
AppGetCertSid(
	const BYTE*  pCertBlob,
	ULONG        ulCertSize,
	bool		 fDefaultProvider,
	LPCWSTR      pwszProvName,
	DWORD        dwProvType
	);


#endif // _MSMQ_Mp_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\inc\mqcast.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    mqcast.h

Abstract:
    Define usefull casting operations.

Author:
    Gil Shafriri (gilsh)

--*/

#pragma once

#ifndef MQCAST_H
#define MQCAST_H

#pragma push_macro("min")
#undef min

#pragma push_macro("max")
#undef max

#pragma warning(push)
#pragma warning(disable: 4296)	// '<' : expression is always false

//
// On cast from unsigned to signed, compiler error "signed/unsigned mismatch"
// on <= inequality. In template there is no way to know the type of 'from' or 
// 'to', therefore the warning is irrelevant.
//
#pragma warning(disable: 4018)

template <class TO,class FROM> TO numeric_cast (FROM from)
/*++

Routine Description:
    static cast numerics values verify that casting is done without sign loss or trancation.

Arguments:
    from - value to cast from/

Returned Value:
      casted value.

Usage :
    __int64 i64 = 1000;
    DWORD dw =  numeric_cast<DWORD>(i64);

--*/
{
    //
    // if from is negative - then TO type must be signed (std::numeric_limits<TO>::min() < 0) 
	// and is capable to hold the value without truncation.
	//
	ASSERT(
	  from >= 0 || 
	  (std::numeric_limits<TO>::min() < 0 &&   std::numeric_limits<TO>::min() <= from)  
	  );

     //
     //if from is non negative - make sure TO type is capable to hold the value without truncation.
     // 
     ASSERT(from < 0 ||	from <=  std::numeric_limits<TO>::max());

     return static_cast<const TO&>(from);
}

#pragma warning(pop)
#pragma pop_macro("max")
#pragma pop_macro("min")

#endif // MQCAST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\inc\mqenv.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    mqenv.h

Abstract:
    Master Windows, libraries and allocation include file 

Author:
    Erez Haba (erezh) 09-Mar-2000

--*/

#pragma once

#ifndef _MSMQ_MQENV_H_
#define _MSMQ_MQENV_H_


//
// Always use Unicode
//
#ifndef UNICODE
#define UNICODE
#endif

/////////////////////////////////////////////////////////////////////////////

#ifdef _WINDOWS_
	#error WINDOWS.H already included.
#endif

// STRICT is the only supported option (NOSTRICT is no longer supported)
#ifndef STRICT
#define STRICT 1
#endif

#ifndef WIN32
#define WIN32
#endif

#ifdef _UNICODE
#ifndef UNICODE
#define UNICODE             // UNICODE is used by Windows headers
#endif
#endif

#ifdef UNICODE
#ifndef _UNICODE
#define _UNICODE            // _UNICODE is used by C-runtime/MFC headers
#endif
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <winsock2.h>

#undef ASSERT
#define MAXDWORD    0xffffffff  
typedef TUCHAR TBYTE , *PTBYTE ;

/////////////////////////////////////////////////////////////////////////////
// Other includes from windows libraries

#include <tchar.h>


/////////////////////////////////////////////////////////////////////////////
// Other includes from standard "C" runtimes

#include <malloc.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <limits.h>
#include <stddef.h>
#include <stdarg.h>
#include <align.h>

#include <crtdbg.h>

/////////////////////////////////////////////////////////////////////////////
// Turn off warnings for /W4

#ifndef ALL_WARNINGS

#pragma warning(disable: 4097) // typedef-name 'id1' used as synonym for class-name 'id2'
#pragma warning(disable: 4127)  // conditional expression is constant
#pragma warning(disable: 4200)  // zero-sized array in struct/union
#pragma warning(disable: 4201)  // nameless struct/union
#pragma warning(disable: 4251)  // using non-exported class as member in exported class
#pragma warning(disable: 4275)  // An exported class was derived from a class that was not exported
#pragma warning(disable: 4284)  // return type for 'identifier::operator ->' is not a UDT or reference to a UDT.
#pragma warning(disable: 4290)  // C++ Exception Specification ignored
#pragma warning(disable: 4511)  // 'class' : copy constructor could not be generated
#pragma warning(disable: 4512)  // 'class' : assignment operator could not be generated
#pragma warning(disable: 4514)  // unreferenced inline/local function has been removed
#pragma warning(disable: 4601)  // #pragma push_macro : 'macro' is not currently defined as a macro
#pragma warning(disable: 4702)  // unreachable code (due to optimization)
#pragma warning(disable: 4710)  // 'function' : function not inlined
#pragma warning(disable: 4711)  // function 'function' selected for inline expansion
#pragma warning(disable: 4786)  // truncated to 'number' characters in the debug information

#endif //!ALL_WARNINGS


/////////////////////////////////////////////////////////////////////////////
// Other includes for tracing and assertion

#include <tr.h>

/////////////////////////////////////////////////////////////////////////////
// Other includes for memroy allocation support

#include <new>
using std::bad_alloc;
using std::nothrow_t;
using std::nothrow;

#include <utility>
using namespace std::rel_ops;

#include <mm.h>


/////////////////////////////////////////////////////////////////////////////
// Support Win64 string length usage

inline unsigned int mqstrlen(const char * s)
{
    size_t len = strlen(s);
    ASSERT(("String length must be 32 bit max", len <= UINT_MAX));
    return static_cast<unsigned int>(len);
}


inline unsigned int mqwcslen(const wchar_t * s)
{
    size_t len = wcslen(s);
    ASSERT(("String length must be 32 bit max", len <= UINT_MAX));
    return static_cast<unsigned int>(len);
}


#define strlen(x) mqstrlen(x)
#define wcslen(x) mqwcslen(x)

/////////////////////////////////////////////////////////////////////////////


#endif // _MSMQ_MQENV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\inc\mqexception.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    mqexception.h

Abstract:

    MSMQ exceptions.

Author:

    Shai Kariv  (shaik)  23-Jul-2000

--*/


#pragma once


#ifndef _MSMQ_EXCEPTION_H_
#define _MSMQ_EXCEPTION_H_



class bad_api : public exception
{
    //
    // Abstract base class for exceptions thrown internally in msmq code when
    // a call to an API returns with failure status.
    //

public:

    virtual ~bad_api(VOID) =0 {};

}; // class bad_api



class bad_hresult : public bad_api
{
    //
    // Base class for HRESULT failures
    //

public:

    explicit bad_hresult(HRESULT hr): m_hresult(hr) { ASSERT(FAILED(hr)); }

    virtual ~bad_hresult(VOID) {}

    virtual HRESULT error(VOID) const throw() { return m_hresult; }

private:

    HRESULT m_hresult;

}; // class bad_hresult



class bad_win32_error : public bad_api
{
    //
    // Base class for Win32 errors (DWORD)
    //

public:

    explicit bad_win32_error(DWORD error): m_error(error) { ASSERT(error != ERROR_SUCCESS); }

    virtual ~bad_win32_error(VOID) {}

    virtual DWORD error(VOID) const throw() { return m_error; }

private:

    DWORD m_error;

}; // class bad_win32_error



class bad_ds_result : public bad_hresult
{
    //
    // DS APIs failures
    //

    typedef bad_hresult Inherited;

public:

    explicit bad_ds_result(HRESULT hr): Inherited(hr) {}

}; // class bad_ds_result



#endif // _MSMQ_EXCEPTION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\inc\mqmacro.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:
    mqmacro.h

Abstract:
    Common MSMQ macros

Author:
    Erez Haba (erezh) 20-Dec-98

--*/

#pragma once

#ifndef _MSMQ_MQMACRO_H_
#define _MSMQ_MQMACRO_H_


//
// Make a BUGBUG messages appear in compiler output
//
// Usage: #pragma BUGBUG("This line appears in the compiler output")
//
#define MAKELINE0(a, b) a "(" #b ") : BUGBUG: "
#define MAKELINE(a, b)  MAKELINE0(a, b) 
#define BUGBUG(a)       message(MAKELINE(__FILE__,__LINE__) a)

//
//Verify that given object is  not a pointer
// 
// Example:
//
//   const char* Foo="123";
//   C_ASSERT_NON_PTR(Foo); // will not compile
//
//   const char Bar[]="123"
//   C_ASSERT_NON_PTR(Bar); // ok
//
class NonPtrChecker
{
public:      
	static char Check(const void*); 
private:
	template <class T> static void  Check(T**);
};
#define C_ASSERT_NON_PTR(x) (sizeof(NonPtrChecker::Check(&(x)))) 


//
// Number of elements in an array or table
//
// Usage:
//      int MyTable[] = {1, 2, 3, 4, 5};
//      int nElements = TABLE_SIZE(MyTable);
//
#define TABLE_SIZE(x) (C_ASSERT_NON_PTR(x)/C_ASSERT_NON_PTR(x)*(sizeof(x)/sizeof(*(x))))


//
// The length of a constant string
//
// Usage:
//      const WCHAR xString1[] = L"String1";
//
//      int len1 = STRLEN(xString1);
//      int len2 = STRLEN("String2");
//
#define STRLEN(x) (TABLE_SIZE(x) - 1)


//
// Declare parameters as used in debug builds
//
// Usage:
//      DBG_USED(Valid);
//      DBG_USED(argc);
//
#ifndef _DEBUG
#define DBG_USED(x) ((void)x)
#else
#define DBG_USED(x) NULL
#endif


#endif // _MSMQ_MQMACRO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\inc\msi.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    msi.h

Abstract:
    Message Pool interface

Author:
    Uri habusha (urih)
    Shai Kariv  (shaik)  06-Sep-00

--*/

#pragma once 

#ifndef __MSI_H__
#define __MSI_H__

#include "Tr.h"
#include "ref.h"


class CQmPacket;
class CACPacketPtrs;
class EXOVERLAPPED;

class __declspec(novtable) IMessagePool : public CReference
{
public:
    virtual ~IMessagePool() = 0
    {
    }


    virtual void Requeue(CQmPacket* pPacket) = 0;
    virtual void EndProcessing(CQmPacket* pPacket) = 0;
    virtual void LockMemoryAndDeleteStorage(CQmPacket* pPacket) = 0;
    virtual void GetFirstEntry(EXOVERLAPPED* pov, CACPacketPtrs& acPacketPtrs) = 0;
	virtual void CancelRequest(void) = 0;
	virtual void OnRetryableDeliveryError(){}
	virtual void OnAbortiveDeliveryError(USHORT /* DeliveryErrorClass */){};
};

#endif // __MSI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\inc\mqstl.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:
    mqstl.h

Abstract:
    MSMQ  include STL

Author:
    Uri Habusha (urih) 6-Jan-99

--*/

#pragma once

#ifndef _MSMQ_MQSTL_H_
#define _MSMQ_MQSTL_H_


#pragma PUSH_NEW
#undef new

//
// 'identifier' : identifier was truncated to 'number' characters in the debug information
//
#pragma warning(disable: 4786)

//
//  STL include files are using placment format of new
//
#pragma warning(push, 3)

//
// standard header files
//
#include <static_stl_str.h>
#include <map>
#include <set>
#include <list>
#include <queue>
#include <string>
#include <vector>
#include <sstream>
#include <iomanip>
#include <algorithm>
#include <functional>
#include <fstream>

//
// MSMQ files.
//
#include <lim.h>
#include <mqcast.h>

#pragma warning(pop)

#pragma POP_NEW


#endif // _MSMQ_MQSTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\inc\msm.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Msm.h

Abstract:
    Multicast Session Manager public interface

Author:
    Shai Kariv (shaik) 05-Sep-00

--*/

#pragma once

#ifndef _MSMQ_Msm_H_
#define _MSMQ_Msm_H_

#include <mqwin64a.h>
#include <qformat.h>


VOID
MsmInitialize(
    VOID
    );

VOID
MsmBind(
    const QUEUE_FORMAT& QueueFormat,
    MULTICAST_ID        MulticastId
    );

VOID
MsmUnbind(
    const QUEUE_FORMAT& QueueFormat
    )
    throw();

void
AppAcceptMulticastPacket(
    const char* httpHeader,
    DWORD bodySize,
    const BYTE* body,
    const QUEUE_FORMAT& destQueue
    );


class ISessionPerfmon;

R<ISessionPerfmon>
AppGetIncomingPgmSessionPerfmonCounters(
	LPCWSTR strMulticastId,
	LPCWSTR remoteAddr
	);

#endif // _MSMQ_Msm_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\inc\mt.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    mt.h

Abstract:
    Message Transport public interface

Author:
    Uri Habusha (urih) 11-Aug-99

--*/

#pragma once

#include "xstr.h"

//
// Forwarding decleration
//
class IMessagePool;
class ISessionPerfmon;
class CTimeDuration;
class CQmPacket;

//
// Transport base class
//
class __declspec(novtable) CTransport : public CReference 
{
public:
    enum ConnectionState
    {
        csNotConnected,
        csConnected,
        csShuttingDown,
        csShutdownCompleted
    };

public:

    CTransport(LPCWSTR queueUrl) :
        m_state(csNotConnected),
        m_queueUrl(newwcs(queueUrl))
    {
    }

    
    virtual ~CTransport() = 0
    {
    }

    virtual LPCWSTR ConnectedHost(void) const = 0;
    virtual LPCWSTR ConnectedUri(void) const = 0;
    virtual USHORT ConnectedPort(void) const = 0;

    ConnectionState State() const
    {
        return m_state;
    }

    
    void State(ConnectionState state) 
    {
        m_state = state;
    }

    
    LPCWSTR QueueUrl() const
    {
        return m_queueUrl;
    }

private:
    ConnectionState m_state;
    const AP<WCHAR> m_queueUrl;
};



VOID
MtInitialize(
    VOID
    );


R<CTransport>
MtCreateTransport(
    const xwcs_t& targetHost,
    const xwcs_t& nextHop,
    const xwcs_t& nextUri,
    USHORT port,
	USHORT nextHopPort,
    LPCWSTR queueUrl,
	IMessagePool* pMessageSource,
	ISessionPerfmon* pPerfmon,
	const CTimeDuration& responseTimeout,
    const CTimeDuration& cleanupTimeout,
	bool fSecure,
    DWORD SendWindowinBytes,
    DWORD SendWindowinPackets
    );


VOID
AppNotifyTransportClosed(
    LPCWSTR queueUrl
    );

bool 
AppCanDeliverPacket(
	CQmPacket* pPkt
	);

void 
AppPutPacketOnHold(
	CQmPacket* pPkt
	);

bool 
AppPostSend(
	CQmPacket* pPkt
	);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\inc\mtm.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:

    Mtm.h

Abstract:

    Multicast Transport Manager public interface

Author:

    Shai Kariv  (shaik)  27-Aug-00

--*/

#pragma once

#ifndef _MSMQ_Mtm_H_
#define _MSMQ_Mtm_H_

#include <mqwin64a.h>
#include <qformat.h>


class IMessagePool;
class ISessionPerfmon;
class CTimeDuration;
class CMulticastTransport;


VOID 
MtmCreateTransport(
    IMessagePool * pMessageSource,
	ISessionPerfmon* pPerfmon,
	MULTICAST_ID id
    );

VOID
MtmTransportClosed(
    MULTICAST_ID id
    );

VOID
MtmInitialize(
    VOID
    );
        
R<CMulticastTransport>
MtmGetTransport(
    MULTICAST_ID id
    );

R<CMulticastTransport>
MtmFindFirst(
	VOID
	);


R<CMulticastTransport>
MtmFindLast(
	VOID
	);


R<CMulticastTransport>
MtmFindNext(
	const CMulticastTransport& transport
	);


R<CMulticastTransport>
MtmFindPrev(
	const CMulticastTransport& transport
	);

#endif // _MSMQ_Mtm_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\inc\qal.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Qal.h

Abstract:
    header file for class CQueueAlias.
	The class manages queues aliases  in memory and load/store them
	from\in registry.It also give the class user way to enumerate queue\alias mapping 


Author:
    Gil Shafriri (gilsh) 06-Apr-00

--*/

#ifndef QAL_H
#define QAL_H

#include <stlcmp.h>

class bad_win32_error;
//
// Error reporting hooks implemented by the library user 
//
void AppNotifyQalWin32FileError(LPCWSTR pFileName, DWORD err)throw();
void AppNotifyQalDirectoryMonitoringWin32Error(LPCWSTR pMappingDir, DWORD err)throw();
void AppNotifyQalDuplicateMappingError(LPCWSTR pAliasFormatName, LPCWSTR pFormatName)throw();
void AppNotifyQalInvalidMappingFileError(LPCWSTR pMappingFileName)throw();
void AppNotifyQalXmlParserError(LPCWSTR pMappingFileName)throw();
bool AppNotifyQalMappingFound(LPWSTR pAliasFormatName, LPWSTR pFormatName)throw();




//---------------------------------------------------------
//
// Queue Alias
//
//---------------------------------------------------------
class CQueueAliasImp;

class CQueueAlias
{
		
public:
	class CEnum
	{
	public:
		~CEnum();
		CEnum(const CEnum&);
		CEnum& operator=(const CEnum&);
		bool Next(LPWSTR* ppFormatName,LPWSTR* ppAliasFormatName);	
		void Reset();

	private:
		CEnum(const CQueueAlias*);
		friend 	CQueueAlias;

	
	private:
		void ReplaceAlias(LPCWSTR pNewAlias);
		

	
	private:
		const CQueueAlias* m_QueueAlias;
		LPWSTR m_alias;
	};		
	friend CEnum;

	CQueueAlias(LPCWSTR pMappingDir);


public:
	~CQueueAlias();

	CEnum CreateEnumerator();
	

	bool 
	GetAlias(
		LPCWSTR  pFormatName,    
		LPWSTR*  ppAliasFormatName  
  		) const;


	bool
	GetQueue(
		LPCWSTR pAliasFormatName,  
		LPWSTR* ppFormatName
   		) const;

	bool
	Create(
		LPCWSTR  pFormatName,  
		LPCWSTR  pAliasFormatName                                             
		);

    bool Delete(LPCWSTR pFormatName);

	void Reload();

private:
	R<CQueueAliasImp> SafeGetImp()const;

	bool 
	GetNextMapping(
		LPCWSTR  pRefAliasFormatName,
		LPWSTR*  ppFormatName,
		LPWSTR*  ppAliasFormatName
		)const;

private:	
	CQueueAlias& operator=(const CQueueAlias&); 
	CQueueAlias(const CQueueAlias&);             

private:
	R<CQueueAliasImp> m_imp;
	mutable CCriticalSection m_cs;
};

void   QalInitialize(LPCWSTR pDir);
CQueueAlias& QalGetMapping(void);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\inc\ref.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    ref.h

Abstract:
    Abstruct object for refrence count and list entry.

Author:
    Erez Haba (erezh) 04-Aug-99

--*/

#pragma once

#ifndef _MSMQ_REF_H_
#define _MSMQ_REF_H_


//---------------------------------------------------------
//
//  Tracing identifier
//
//---------------------------------------------------------

const TraceIdEntry Reference = L"Reference";


//---------------------------------------------------------
//
//  class CReference
//
//---------------------------------------------------------

class __declspec(novtable) CReference {
public:

    CReference() :
        m_ref(1)
    {
    }


    void AddRef() const
    {
        LONG ref = InterlockedIncrement(&m_ref);

        //TrTRACE(Reference, "AddRef(0x%p)=%d", this, ref);
        UNREFERENCED_PARAMETER(ref);
    }


    void Release() const
    {
        ASSERT(m_ref > 0);
        LONG ref = InterlockedDecrement(&m_ref);

        //TrTRACE(Reference, "Release(0x%p)=%d", this, ref);
        ASSERT(!(ref < 0));

        if(ref == 0)
        {
            delete this;
        }
    }

    
    LONG GetRef(void) const
    {
        //
        // N.B. This memeber is for specialized use only. You can not rely on
        //      its return value but in specific scnarios. A returned value of
        //      1 is considered stable (as the caller holds the only reference
        //      to the object) as well as a return value that matchs exactly
        //      the number of references the caller logicly holds to the
        //      object. Use this function with caution.     erezh  16-Feb-2000
        //

        return m_ref; 
    }


protected:
    virtual ~CReference() = 0
    {
        //
        // Either this object is deleted through the last Release call, or an
        // exception was raised in this object constructor.
        //
        // PITFALL: This will not prevent deleting an object with a reference count
        // of one. But this object is trying to prevent this by defining its dtor
        // as a protected member. Neverthless derived object can override the dtor
        // protected access, allowing direct delete call. In any case deleting an
        // object with a reference count of 1 does seem harmelss as this is the
        // only reference to that object.   erezh 11-Oct-99
        // 
        //
        ASSERT((m_ref == 0) || (m_ref == 1));
    }

private:
    mutable LONG m_ref;
};


#endif // _MSMQ_REF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\inc\no.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    No.h

Abstract:
    Network Output public interface

Author:
    Uri Habusha (urih) 12-Aug-99

--*/

#pragma once

#ifndef __NO_H__
#define __NO_H__


class EXOVERLAPPED;

//-------------------------------------------------------------------
//
// Send Buffer
//
//-------------------------------------------------------------------


//
// Initilization routine. 
//
VOID
NoInitialize(
    VOID
    );

bool
NoGetHostByName(
    LPCWSTR host,
	std::vector<SOCKADDR_IN>* pAddr,
	bool fUseCache	= true
    );

SOCKET
NoCreateStreamConnection(
    VOID
    );

SOCKET
NoCreatePgmConnection(
    VOID
    );

VOID
NoConnect(
    SOCKET Socket,
    const SOCKADDR_IN& Addr,
    EXOVERLAPPED* pOverlapped
    );

VOID
NoCloseConnection(
    SOCKET Socket
	);

VOID
NoReceiveCompleteBuffer(
    SOCKET Socket,                                              
    VOID* pBuffer,                                     
    DWORD Size, 
    EXOVERLAPPED* pov
    );

VOID
NoReceivePartialBuffer(
    SOCKET Socket,                                              
    VOID* pBuffer,                                     
    DWORD Size, 
    EXOVERLAPPED* pov
    );

VOID
NoSend(
    SOCKET Socket,                                              
    const WSABUF* Buffers,                                     
    DWORD nBuffers, 
    EXOVERLAPPED* pov
    );

#endif // __NO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\inc\rwlock.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:
    rwlock.h

Abstract:
    This file contains a Multi-reader, one-writer synchronization object and
    useful templates for auto lock/unlock

Author:
    Uri Habusha (urih), 27-Dec-99

--*/

#pragma once

#ifndef _MSMQ_RWLOCK_H_
#define _MSMQ_RWLOCK_H_

/*++

  Class:      CReadWriteLock

  Purpose:    Shared/Exclusive access services

  Interface:  LockRead      - Grab shared access to resource
              LockWrite       - Grab exclusive access to resource
              UnlockRead      - Release shared access to resource
              UnlockWrite     - Release exclusive access to resource
                
    Notes:      This class guards a resource in such a way that it can have
                multiple readers XOR one writer at any one time. It's clever,
                and won't let writers be starved by a constant flow of
                readers. Another way of saying this is, it can guard a
                resource in a way that offers both shared and exclusive
                access to it.
                
                If any thread holds a lock of one sort on a CReadWriteLock,
                it had better not grab a second. That way could lay deadlock,
                matey! Har har har.....

--*/

class CReadWriteLock 
{
public:
    CReadWriteLock(unsigned long ulcSpinCount = 0);
    ~CReadWriteLock(void);

    void LockRead(void);
    void LockWrite(void);
    void UnlockRead(void);
    void UnlockWrite(void);

private:
    HANDLE GetReadWaiterSemaphore(void);
    HANDLE GetWriteWaiterEvent (void);

private:
    unsigned long m_ulcSpinCount;       // spin counter
    volatile unsigned long m_dwFlag;    // internal state, see implementation
    HANDLE m_hReadWaiterSemaphore;      // semaphore for awakening read waiters
    HANDLE m_hWriteWaiterEvent;         // event for awakening write waiters
};





//---------------------------------------------------------
//
//  class CSR
//
//---------------------------------------------------------
class CSR {
public:
    CSR(CReadWriteLock& lock) : m_lock(&lock)  { m_lock->LockRead(); }
	~CSR() {if(m_lock) m_lock->UnlockRead(); }
	CReadWriteLock* detach(){CReadWriteLock* lock = m_lock; m_lock = 0; return lock;}

private:
    CReadWriteLock* m_lock;
};


//---------------------------------------------------------
//
//  class CSW
//
//---------------------------------------------------------
class CSW
{

public:
    CSW(CReadWriteLock& lock) : m_lock(&lock)  { m_lock->LockWrite(); }
   ~CSW() {if(m_lock) m_lock->UnlockWrite(); }
   	CReadWriteLock* detach(){CReadWriteLock* lock = m_lock; m_lock = 0; return lock; }

private:
    CReadWriteLock* m_lock;
};


#endif // _MSMQ_RWLOCK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\inc\rd.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Rd.h

Abstract:
    Routing Decision public interface

Author:
    Uri Habusha (urih) 10-Apr-00

--*/

#pragma once

#ifndef __Rd_H_
#define __Rd_H_

#include "timetypes.h"

//-------------------------------------------------------------------
//
// Exception class bad_route
//
//-------------------------------------------------------------------
class bad_route : public exception 
{
public:
    bad_route(LPCWSTR errorType) :
        exception("bad routing configuration"),
        m_errorType(errorType)
    {
    }

    const WCHAR* ErrorType() const
    {
        return m_errorType;
    }

private:
    const WCHAR* m_errorType;
};


class CRouteMachine : public CReference
{
public:
    virtual ~CRouteMachine()
    {
    }

    virtual const GUID& GetId(void) const = 0;
    virtual LPCWSTR GetName(void) const = 0; 
    virtual bool IsForeign(void) const = 0;
    virtual const CACLSID& GetSiteIds(void) const = 0;

};


class CRouteTable
{
private:
    struct next_hop_less: public std::binary_function<R<const CRouteMachine>&, R<const CRouteMachine>&, bool> 
    {
        bool operator()(const R<const CRouteMachine>& k1, const R<const CRouteMachine>& k2) const
        {
            return (memcmp(&k1->GetId(), &k2->GetId(), sizeof(GUID)) < 0);
        }
    };

public:
    typedef std::set<R<const CRouteMachine>, next_hop_less> RoutingInfo;

public:
    virtual ~CRouteTable()
    {
    }


    RoutingInfo* GetNextHopFirstPriority(void) 
    { 
        return &m_nextHopTable[0]; 
    }


    RoutingInfo* GetNextHopSecondPriority(void) 
    { 
        return &m_nextHopTable[1]; 
    }


private:
    RoutingInfo m_nextHopTable[2];
};



VOID
RdInitialize(
    bool fRoutingServer,
    CTimeDuration rebuildInterval
    );


VOID
RdRefresh(
    VOID
    );

VOID
RdGetRoutingTable(
    const GUID& destMachineId,
    CRouteTable& RoutingTable                                                                                    
    );

void
RdGetConnector(
    const GUID& foreignMachineId,
    GUID& connectorId
    );


#endif // __Rd_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\inc\singelton.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    singelton.h

Abstract:
    Singleton template class


--*/

#pragma once

#ifndef _MSMQ_SINGELTON_H_
#define _MSMQ_SINGELTON_H_




template <class T>
class CSingelton
{
public:
	static T& get()
	{
		if(m_obj.get() != NULL)
			return *m_obj.get();
		
		P<T> newobj = new T();
		if(InterlockedCompareExchangePointer(&m_obj.ref_unsafe(), newobj.get(), NULL) == NULL)
		{
			newobj.detach();
		}

		return *m_obj.get();			
	}

	
private:
	static P<T> m_obj;
};
template <class T> P<T> CSingelton<T>::m_obj;






#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\inc\spi.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:
    spi.h

Abstract:
    Session Performance counters interface

Author:
    Uri habusha (urih), 10-Dec-2000

--*/

#pragma once 

#ifndef __SPI_H__
#define __SPI_H__

#include "Tr.h"
#include "ref.h"



class __declspec(novtable) ISessionPerfmon : public CReference
{
public:
    virtual ~ISessionPerfmon() = 0
    {
    }


    virtual void CreateInstance(LPCWSTR objName) = 0;

	virtual void UpdateBytesSent(DWORD bytesSent) = 0;
	virtual void UpdateMessagesSent(void) = 0;

	virtual void UpdateBytesReceived(DWORD bytesReceived) = 0;
	virtual void UpdateMessagesReceived(void) = 0;
};

#endif // __SPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\inc\st.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    st.h

Abstract:
    Socket Transport public interface

Author:
    Gil Shafriri (gilsh) 05-Jun-00

--*/

#pragma once

#ifndef _MSMQ_st_H_
#define _MSMQ_st_H_

template <class T> class basic_xstr_t;
typedef  basic_xstr_t<WCHAR> xwcs_t;

class  EXOVERLAPPED;


class IConnection :public CReference
{
public:
	virtual void ReceivePartialBuffer(VOID* pBuffer,DWORD Size, EXOVERLAPPED* pov) = 0;
	virtual void Send(const WSABUF* Buffers,DWORD nBuffers, EXOVERLAPPED* pov) = 0;
	virtual void Close() = 0;
	virtual ~IConnection(){}
};



class ISocketTransport
{
public:
	ISocketTransport(){};
	virtual ~ISocketTransport(){};

public:
 	virtual
	bool
	GetHostByName(
    LPCWSTR host,
	std::vector<SOCKADDR_IN>* pAddr,
	bool fUseCache	= true
    ) = 0 ;

 	virtual bool IsPipelineSupported(void) = 0;

    virtual void CreateConnection(const SOCKADDR_IN& Addr, EXOVERLAPPED* pOverlapped) = 0;
  
    virtual R<IConnection> GetConnection(void)  = 0;

private:
	ISocketTransport(const ISocketTransport&);	 
	ISocketTransport& operator=(const ISocketTransport&);
};

void StInitialize();

ISocketTransport* StCreateSimpleWinsockTransport();

ISocketTransport* StCreateSslWinsockTransport(const xwcs_t& ServerName, USHORT ServerPort,bool fProxy);

ISocketTransport* StCreatePgmWinsockTransport();


#endif // _MSMQ_st_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\inc\static_stl_str.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    static_stl_str.h

Abstract:
    Header file for making stl string and stream taken from the include headers
	and not from vc runtime dll. This is due to a bug in the vc runtime dll that Av on 
	allocation faliure (nothrow allocator). When the implementation is inlined from the header
	- user defined allocator that throw on faliure can be used.

Author:
    Gil Shafriri (gilsh) 25-3-2001

--*/


#ifndef STATIC_STL_STR_H
#define STATIC_STL_STR_H

#include <string>
#include <sstream>
#include <iosfwd>


namespace std
{
	//
	// Class allocator - does what std::allocator does but it not intansiated in the vc dll.
	//
	template <class T> class allocator_static : public std::allocator<T>
	{
	
	};

	//
	// basic_string_static - Does what std::basic_string does but uses allocator_static
	// as default allocator
	//
	template<class _E,	class _Tr = char_traits<_E>, class _A = allocator_static<_E> > 
	class basic_string_static : public basic_string<_E, _Tr, _A>
	{
	public:
		typedef basic_string<_E, _Tr, _A> base;
		typedef basic_string_static<_E, _Tr, _A> _Myt;

	public:
		explicit basic_string_static(const _A& _Al = _A()):basic_string<_E, _Tr, _A>(_Al){}
		basic_string_static(const _Myt& _X, size_type _P, size_type _M, const _A& _Al = _A()):base(_X, _P, _M,_Al){} 
		basic_string_static(const _E* _S, size_type _N,const _A& _Al = _A()):base(_S, _N, _Al){}  
		basic_string_static(const _E* _S, const _A& _Al = _A()):base(_S, _Al){}  
		basic_string_static(size_type _N, _E _C, const _A& _Al = _A()):base(_N,  _C, _Al){}
		basic_string_static(_It _F, _It _L, const _A& _Al = _A()):base(_F, _L, _Al){}
		basic_string_static(const base& _X):base(_X){}
	};


	//
	// basic_ostringstream_static - Does what std::basic_ostringstream does but uses allocator_static
	// as default allocator
	//
	template<class _E,	class _Tr = char_traits<_E>, class _A = allocator_static<_E> >
	class basic_ostringstream_static : public  basic_ostringstream<_E, _Tr, _A>
	{
	public:
		typedef basic_ostringstream<_E, _Tr, _A> base;
		typedef basic_string_static<_E, _Tr, _A> _Mystr;
		
	public:
		explicit basic_ostringstream_static(openmode _M = out):base(_M){}
		explicit basic_ostringstream_static(const _Mystr& _S, openmode _M = out):base(_S, _M){}
		basic_ostringstream_static(const base& _X):base(_X){}
	};


	//
	// basic_istringstream_static - Does what std::basic_istringstream does but uses allocator_static
	// as default allocator
	//
	template<class _E,	class _Tr = char_traits<_E>, class _A = allocator_static<_E> > 
	class basic_istringstream_static : public  basic_istringstream<_E, _Tr, _A>
	{
	public:
		typedef basic_string_static<_E, _Tr, _A> _Mystr;
		typedef basic_istringstream<_E, _Tr, _A> base;
	
	public:
		explicit basic_istringstream_static(openmode _M = in):base(_M){}
		explicit basic_istringstream_static(const _Mystr& _S, openmode _M = in):base(_S, _M){}
		basic_istringstream_static(const base& _X):base(_X){}
	};


	//
	// basic_stringbuf_static - Does what std::basic_stringbuf does but uses allocator_static
	// as default allocator
	//
	template<class _E,	class _Tr = char_traits<_E>, class _A = allocator_static<_E> > 
	class basic_stringbuf_static : public  basic_stringbuf<_E, _Tr, _A>
	{
	public:
		typedef basic_string_static<_E, _Tr, _A> _Mystr;
		typedef basic_stringbuf<_E, _Tr, _A> base;
	
	public:
		explicit basic_stringbuf_static(ios_base::openmode _W = ios_base::in | ios_base::out):base(_W){}
		explicit basic_stringbuf_static(const _Mystr& _S, ios_base::openmode _W = ios_base::in | ios_base::out):base(_S, _W){}
		basic_stringbuf_static(const base& _X):base(_X){}
	};

	
	//
	// basic_stringstream_static - Does what std::basic_stringstream does but uses allocator_static
	// as default allocator
	//
	template<class _E,	class _Tr = char_traits<_E>, class _A = allocator_static<_E> > 
	class basic_stringstream_static : public  basic_stringstream<_E, _Tr, _A>
	{
	public:
		typedef basic_string_static<_E, _Tr, _A> _Mystr;
		typedef basic_stringstream<_E, _Tr, _A> base;
	
	public:
		explicit basic_stringstream_static(openmode _M = in):base(_M){}
		explicit basic_stringstream_static(const _Mystr& _S, openmode _M = in):base(_S, _M){}
		basic_stringstream_static(const base& _X):base(_X){}
	};


	typedef basic_string<char, char_traits<char>, allocator_static<char> > string_static;
	typedef basic_string<wchar_t, char_traits<wchar_t>, allocator_static<wchar_t> > wstring_static;
	typedef basic_ostringstream<char, char_traits<char>, allocator_static<char> > ostringstream_static;
    typedef basic_ostringstream<wchar_t, char_traits<wchar_t>,allocator_static<wchar_t> > wostringstream_static;
	typedef basic_istringstream<char, char_traits<char>, allocator_static<char> > istringstream_static;
    typedef basic_istringstream<wchar_t, char_traits<wchar_t>,allocator_static<wchar_t> > wistringstream_static;
	typedef basic_stringstream<char, char_traits<char>, allocator_static<char> > stringstream_static;
    typedef basic_stringstream<wchar_t, char_traits<wchar_t>,allocator_static<wchar_t> > wstringstream_static;
};


//
// Rename symbols so only template that uses  allocator_static as default allocator could be used
//

#define string string_static
#define wstring wstring_static
#define ostringstream ostringstream_static
#define wostringstream wostringstream_static
#define stringstream stringstream_static
#define wstringstream wstringstream_static
#define istringstream istringstream_static
#define wostringstream wostringstream_static
#define basic_string basic_string_static
#define basic_stringbuf basic_stringbuf_static
#define basic_ostringstream  basic_ostringstream_static
#define basic_istringstream  basic_istringstream_static
#define basic_stringstream basic_stringstream_static


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\inc\svc.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Svc.h

Abstract:
    Service public interface

Author:
    Erez Haba (erezh) 01-Aug-99

--*/

#pragma once

#ifndef _MSMQ_Svc_H_
#define _MSMQ_Svc_H_


VOID
SvcInitialize(
    LPCWSTR DummyServiceName
    );

VOID
SvcEnableControls(
	DWORD Controls
	);

VOID
SvcDisableControls(
	DWORD Controls
	);

DWORD
SvcQueryControls(
	VOID
	);

VOID
SvcReportState(
	DWORD State
	);


DWORD
SvcQueryState(
	VOID
	);

VOID
SvcReportProgress(
	DWORD MilliSecondsToNextTick
	);


//
// Application override functions
//
VOID
AppRun(
	LPCWSTR ServiceName
	);

VOID
AppStop(
	VOID
	);

VOID
AppPause(
	VOID
	);

VOID
AppContinue(
	VOID
	);

VOID
AppShutdown(
	VOID
	);


#endif // _MSMQ_Svc_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\inc\rwlockexe.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:
    rwlockexe.h

Abstract: Header for class CReadWriteLockAsyncExcutor and  IAsyncExecutionRequest used to queue asyncrouns operations 
		  under read or write lock. Allows multiple excutions under read  lock and 
		  single excetion under write lock. The caller thread is not blocked because of 
		  locking but the execution is delayed untill the lock is freed. User of this class
		  should call AsyncExecuteUnderReadLock/AsyncExecuteUnderWriteLock and on completion
		  call UnlockRead/UnlockWrite accordingly.
    
Author:	 
    Gil Shafriri(gilsh), 26-June-2001

--*/

#pragma once

#ifndef _MSMQ_RWLOCKEXE_H_
#define _MSMQ_RWLOCKEXE_H_

//
// Async request interface - represet async command to run.
// should perform call back to the caller on completion.
//
class IAsyncExecutionRequest
{
public:
	virtual ~IAsyncExecutionRequest(){}

public:
	virtual void Run() = 0; // Run the task and callback asyncrounsly

private:
	virtual void Close() throw() = 0; // Force completion of the execution 
									  // called only by CReadWriteLockAsyncExcutor	

	friend class CReadWriteLockAsyncExcutor;
};



class CReadWriteLockAsyncExcutor
{
public:
	CReadWriteLockAsyncExcutor();
	~CReadWriteLockAsyncExcutor();

public:
	void AsyncExecuteUnderReadLock(IAsyncExecutionRequest*);
	void AsyncExecuteUnderWriteLock(IAsyncExecutionRequest* pAsyncExecute);
	void UnlockRead(void);
	void UnlockWrite(void);
	void Close() throw();
	

private:
	enum LockType{Read, Write};
	struct CExecutionContext
	{
		CExecutionContext(
			IAsyncExecutionRequest* pAsyncExecute, 
			LockType locktype
			):
			m_AsyncExecution(pAsyncExecute),
			m_locktype(locktype)
			{
			}

		IAsyncExecutionRequest* m_AsyncExecution;
		LockType m_locktype;
	};

private:
	bool IsWriteLockOn() const;
	bool IsReadLockOn() const;
	bool IsClosed() const;
	void ExecuteWatingRequeuets();
	void ExecuteReader(IAsyncExecutionRequest* pAsyncExecute);
	void ExecuteWriter(IAsyncExecutionRequest* pAsyncExecute);
	void SafeExecute(IAsyncExecutionRequest* pAsyncExecute);

	
private:
	int m_NumOfActiveReaders;
	int m_NumOfActiveWritters;
	typedef std::queue<CExecutionContext> CExQueue;
	CExQueue m_WatingForExecutionQueue;
	CCriticalSection m_Lock;
	bool m_fClosed;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\inc\stlcmp.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:
    stlcmp.h

Abstract:
	STL compare structre

Author:
    Uri Habusha (urih) 8-Mar-2000

--*/

#pragma once

#ifndef _MSMQ_StlCmp_H_
#define _MSMQ_StlCmp_H_

//
// less function, using to compare ASCII string in STL data strcture
//
struct CFunc_strcmp : public std::binary_function<LPCSTR, LPCSTR, bool>
{
    bool operator() (LPCSTR s1, LPCSTR s2) const
    {
        return (strcmp(s1, s2) < 0);
    }
};


struct CFunc_stricmp : public std::binary_function<LPCSTR, LPCSTR, bool>
{
    bool operator() (LPCSTR s1, LPCSTR s2) const
    {
        return (stricmp(s1, s2) < 0);
    }
};


//
// less function, using to compare UNICODE string in STL data strcture
//
struct CFunc_wcscmp : public std::binary_function<LPCWSTR, LPCWSTR, bool>
{
    bool operator() (LPCWSTR str1, LPCWSTR str2) const
    {
        return (wcscmp(str1, str2) < 0);
    }
};


struct CFunc_wcsicmp : public std::binary_function<LPCWSTR, LPCWSTR, bool>
{
    bool operator() (LPCWSTR str1, LPCWSTR str2) const
    {
        return (_wcsicmp(str1, str2) < 0);
    }
};

#endif // _MSMQ_StlCmp_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\inc\strutl.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    strutl.h

Abstract:
    Header file for string ulities

Author:
    Gil Shafriri (gilsh) 25-7-2000

--*/


#ifndef STRUTL_H
#define STRUTL_H


//
// Trivial chars binary predicator - the std::char_traits<C>::eq
// was significally slow.
//
template<class C>
class UtlCharCmp
{
public:
	bool operator()(const C& x1,const C& x2)const
	{
		return x1 == x2;
	}
};

//
// Case insensitive compare
//
template<class C>
class UtlCharNocaseCmp
{
public:
	bool operator()(const C& x1,const C& x2)const
	{
		return std::ctype<C>().tolower(x1) == std::ctype<C>().tolower(x2);
	}
};


//
// template specialization to get string len. 
//
template <class C>
class UtlCharLen;
template<> class UtlCharLen<char>
{
public:
	static size_t len(const char* str)
	{
		return strlen(str);
	}
};



template<> class UtlCharLen<WCHAR>
{
public:
	static size_t len(const WCHAR* str)
	{
		return wcslen(str);
	}
};


template <class C>
class UtlCharLen;
template<> class UtlCharLen<unsigned char>
{
public:
	static size_t len(const unsigned char* str)
	{
		return strlen(reinterpret_cast<const char*>(str));
	}
};



template <class T> T* UtlStrDup(const T* str)
{
	if(str == NULL)
		return NULL;

	size_t len =  UtlCharLen<T>::len(str) + 1;

	T* dup = new T[len];
	memcpy(dup , str, len * sizeof(T));

	return dup;
}

template <class T, class Pred> 
bool
UtlIsStartSec(
		 const T* beg1,
		 const T* end1,
		 const T* beg2,
		 const T* end2,
		 Pred pred
	 	 )

/*++

Routine Description:
	Check if the range [beg1, beg1 + end2 - beg2) is equal  to the range  [beg2, end2).
	(In other words is [beg2, end2) is at the start of  [beg1, end1)
 
Arguments:
    beg1 - start sequence 1
	end -  end sequence 1
	beg2 - start sequence 2
	end2 - end sequence 2
	pred - compare object

Returned value:
	true if the range [beg1, beg1 + end2 - beg2) is equal  to the range  [beg2, end2).

	otherwise false.

--*/
{
	if(end1 - beg1 < end2 - beg2)
		return false;

	return std::equal(  
				beg2,
				end2,
				beg1,
				pred
				); 

}


template <class T>
bool
UtlIsStartSec(
		 const T* beg1,
		 const T* end1,
		 const T* beg2,
		 const T* end2
		 )

/*++

Routine Description:
	Check if the range [beg1, beg1 + end2 - beg2) is equal  to the range  [beg2, end2).
	(In other words is [beg2, end2) is at the start of  [beg1, end1)
 
Arguments:
    beg1 - start sequence 1
	end -  end sequence 1
	beg2 - start sequence 2
	end2 - end sequence 2


Returned value:
	true if the range [beg1, beg1 + end2 - beg2) is equal  to the range  [beg2, end2).

	otherwise false.

--*/
{
	return UtlIsStartSec(beg1, end1, beg2, end2, UtlCharCmp<T>());  
}



template <class C>
inline
bool 
UtlStrIsMatch(
	const C* str, 
	const C* pattern
	)
/*++

Routine Description:
	regural expression string match with default predicator
 
Arguments:
    IN - str - string to match (null terminated)

	IN - pattern - pattern (null terminated)

   
Returned value:
	true if string match the pattern - false otherwise.

    look at UtlStrIsMatch(const C*,const C* ,const P&) for more information.

--*/
{
	return UtlStrIsMatch(str, pattern, UtlCharCmp<C>());
}



template <class C, class P>
inline
bool 
UtlStrIsMatch(
	const C* str, 
	const C* pattern,
	const P& Comp 
	)

/*++

Routine Description:
	regural expression string match with given predicator
 
Arguments:
    IN - str - string to match (null terminated)

	IN - pattern - pattern (null terminated)

    IN - Comp  - binary predicator to compare type C characters.
 

Returned value:
	true if string match the pattern -false otherwise

Note :
It does simple pattern match  includes only * and ^ special caracters in the pattern.
The caracter * match zero or more from any character. The caracter ^ switch to "literal"
mode. In this mode the caracter * has no special meaning.


Example :
str ="microsoft.com"
pattern = "mic*f*.com"
here the string match the pattern.

str ="mic*rosoft.com"
pattern = "mic^*f*.com"
here the string match the pattern.


--*/
{
	ASSERT(str != NULL);
	ASSERT(pattern != NULL);
	return UtlSecIsMatch(str, 
						str + UtlCharLen<C>::len(str), 
						pattern, 
						pattern + UtlCharLen<C>::len(pattern),
						Comp
						);
}


template <class C>
inline
bool 
UtlSecIsMatch(
	const C* sec, 
	const C* secEnd, 
	const C* pattern,
	const C* patternEnd
	)
/*++

Routine Description:
	regural expression on none null terminating sequences  with default predicator
 
Arguments:
    IN - sec - start sequence to match 

	IN - secEnd - end sequence to match 

	IN - pattern - start pattern 

	IN - pattern - end pattern 
      
Returned value:
	true if  sequence match the pattern - false otherwise

Note - behave like 	UtlStrIsMatch on none null terminating sequences.

*/
{
	return 	UtlSecIsMatch(sec, secEnd , pattern,  patternEnd, UtlCharCmp<C>());
}


template <class C, class P>
inline
bool 
UtlSecIsMatch(
	const C* sec, 
	const C* secEnd, 
	const C* pattern,
	const C* patternEnd,
	const P& Comp
	)
/*++

Routine Description:
	regural expression on none null terminating sequences  with given predicator
 
Arguments:
    IN - sec - start sequence to match 

	IN - secEnd - end sequence to match 

	IN - pattern - start pattern 

	IN - pattern - end pattern 

    IN - Comp  - binary predicator to compare type C characters.
 

Returned value:
	true if  sequence the pattern - false otherwise

Note - behave like 	UtlStrIsMatch on none null terminating sequences.

*/

{
	static const C xStar('*');
	static const C xLiteralMode('^');
 

	bool LiteralMode = false;
	//
	// Skip all caracters that are the same untill patern has '*'
	//
	while(pattern != patternEnd && ( !Comp(*pattern, xStar) || LiteralMode)  )
	{
	
		if( sec == secEnd)
			return false;			

		//
		// If we find '^' we swich to literal mode if we are not in literal mode
		//
		if( Comp(*pattern, xLiteralMode) && !LiteralMode)
		{
			LiteralMode = true;
			pattern++;
			continue;
		}

		//
		// if no '*'  in the patern or literal mode - there should be exact match.
		//
		if(!Comp( *sec, *pattern)) 
			return false;

	
		LiteralMode = false;
		
 		pattern++;
		sec++;
 	}

	//
	// If patern ended - the string must also end
	//
	if(pattern == patternEnd)
			return 	sec == secEnd;


	//
	// If '*' is last - we have match.
	//
	if(++pattern ==  patternEnd)
		return true;

	//
	// Call recursivly - and try to find match for any substring after (incuding)
	// the caracter that meets the '*' in the str
	//
	for(;;)
	{
		bool fMatch =  UtlSecIsMatch(sec, secEnd, pattern, patternEnd, Comp);

		if(fMatch)
			return true;

		if(sec == secEnd)
			return false;

  	   sec++;
	}
	return false;
}

template <class T> class basic_xstr_t;
//
// template for reference countable string
//
template <class T> class CRefcountStr_t : public CReference
{
public:
	CRefcountStr_t(const T* str);
	CRefcountStr_t(T* str, int);

	CRefcountStr_t(const basic_xstr_t<T>& xstr);

public:
	const T* getstr();

private:
	CRefcountStr_t(const CRefcountStr_t&)
	{
		ASSERT(0);
	}
	
	CRefcountStr_t& operator=(const CRefcountStr_t&)
	{
		ASSERT(0);
		return *this;
	}
private:
	AP<T> m_autostr; 
};
typedef  CRefcountStr_t<wchar_t> CWcsRef;
typedef  CRefcountStr_t<char>  CStrRef;

//
// string that can hold stl string or simple c string.
// no memory managent is done to the c string 
//
template <class T> class basic_string_ex 
{
public:

	basic_string_ex(
				void
				):
				m_pstr(NULL),
				m_len(0)					
	{
	}

	//
	// Constructor from stl string - full memory management (ref counting) by the
	// stl string
	//
	explicit basic_string_ex(
		const std::basic_string<T>& str
		):
		m_str(str),
		m_pstr(str.c_str()),
		m_len(str.length())
		{
		}

	//
	// Constructor from c string - no memory management is done.
	//
	basic_string_ex(
		const T* pstr,
		size_t len
		):
		m_pstr(pstr),
		m_len(len)
		{
			ASSERT(len != 0 || pstr != NULL);			
		}

public:
	const T* getstr() const
	{
		return m_pstr;
	}

	void free()
	{
		m_len = 0;
		m_pstr = 0;
		m_str = std::basic_string<T>();
	}

	size_t getlen()const 
	{
		return m_len;				
	}

private:
	std::basic_string<T> m_str;
	const T* m_pstr;
	size_t m_len;
};
typedef  basic_string_ex<wchar_t>  Cwstringex;
typedef  basic_string_ex<char> Cstringex;


//
// Class that parse strings seperated with delimiters.
// It let you iterate over the indeviduals strings 
// for example : input string = "abd---acdf---ttt---"
//               Delemiter = "---".
//  it will give you iterator to "abc" then to "acdf" and then to
//  "ttt" 
template <class T, class Pred = UtlCharCmp<T> > class CStringToken
{
public:
	class iterator : public std::iterator<std::input_iterator_tag,basic_xstr_t<T> >
	{
	public:
	   iterator(
		const T* begin,
		const T* end,
		const CStringToken* parser
		):
	    m_value(begin,  end -  begin),
		m_parser(parser)
		{
		}
	  
		const basic_xstr_t<T>& operator*() const
		{
			ASSERT(*this != m_parser->end());
			return m_value;
		}

		
		const basic_xstr_t<T>* operator->()
		{
			return &operator*();
		}

		
		const iterator& operator++()
		{
			ASSERT(*this != m_parser->end());
			*this = m_parser->FindNext(m_value.Buffer() + m_value.Length());
			return *this;
		}
		
		const iterator  operator++(int)
		{
			const iterator tmp(*this);
			++*this;
			return tmp;
		}
		
		bool operator==(const iterator& it) const
		{
			return m_value.Buffer() == it.m_value.Buffer();
		}

		bool operator!=(const iterator& it) const
		{
			return !(operator==(it));
		}
 
	private:
		basic_xstr_t<T> m_value;
		const CStringToken* m_parser;
	};

	CStringToken(
			const T* str,
			const T* delim,
			Pred pred = Pred()
			);


	CStringToken(
			const basic_xstr_t<T>&  str,
			const basic_xstr_t<T>&  delim,
			Pred pred = Pred()
			);


	CStringToken(
			const basic_xstr_t<T>&  str,
			const T* delim,
			Pred pred = Pred()
			);


	iterator begin() const;
	iterator end() const ;
	friend iterator;

private:
const iterator FindFirst() const;
const iterator FindNext(const T* begin)const;

private:
	const T*  m_startstr;
	const T*  m_delim;
	Pred  m_pred;
	const T* m_endstr;
	const T* m_enddelim;
};
typedef  CStringToken<wchar_t> CWcsToken;
typedef  CStringToken<char> CStrToken;





#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\inc\timeutl.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:
    timeutl.h

Abstract:
    Some time utilities

Author:
    Gil Shafriri (gilsh) 8-11-2000

--*/

#pragma once

#ifndef _MSMQ_TIMEUTL_H_
#define _MSMQ_TIMEUTL_H_

class CIso8601Time
{
public:
	CIso8601Time(
		time_t time
		):
		m_time(time)
		{
		}
	time_t m_time;
};

//
// Exception class indicationg that time string format is invalid
//
class bad_time_format : public std::exception
{

};

//
// Exception class indicationg that time integer is invalid (usally to large)
//
class bad_time_value : public std::exception
{

};



template <class T>
std::basic_ostream<T>& 
operator<<(
	std::basic_ostream<T>& o, 
	const CIso8601Time&
	);


template <class T> class basic_xstr_t;
typedef basic_xstr_t<WCHAR> xwcs_t;
void
UtlIso8601TimeToSystemTime(
    const xwcs_t& Iso860Time, 
    SYSTEMTIME* pSysTime
    );


time_t 
UtlSystemTimeToCrtTime(
	const SYSTEMTIME& SysTime
	);


time_t
UtlIso8601TimeDuration(
    const xwcs_t& TimeDurationStr
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\inc\tm.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Tm.h

Abstract:
    HTTP transport manager public interface

Author:
    Uri Habusha (urih) 03-May-00

--*/

#pragma once

#ifndef _MSMQ_Tm_H_
#define _MSMQ_Tm_H_


class IMessagePool;
class ISessionPerfmon;
class CTimeDuration;
class CTransport;


VOID 
TmCreateTransport(
    IMessagePool* pMessageSource,
	ISessionPerfmon* pPerfmon,
	LPCWSTR queueUrl
    );


VOID
TmTransportClosed(
    LPCWSTR queueUrl
    );

VOID
TmInitialize(
    VOID
    );
        

R<CTransport>
TmGetTransport(
    LPCWSTR url
    );


R<CTransport>
TmFindFirst(
	void
	);


R<CTransport>
TmFindLast(
	void
	);


R<CTransport>
TmFindNext(
	const CTransport& transport
	);


R<CTransport>
TmFindPrev(
	const CTransport& transport
	);

#endif // _MSMQ_Tm_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\inc\timetypes.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:
    TimeTypes.h

Abstract:
    Time instant and Time duration classes

Author:
    Uri Habusha (urih) 6-Dec-99

--*/

#pragma once

#ifndef _MSMQ_TIMETYPES_H_
#define _MSMQ_TIMETYPES_H_

//---------------------------------------------------------
//
// class CTimeDuration
//
//---------------------------------------------------------
class CTimeDuration
{
public:
    CTimeDuration(LONGLONG duration = 0) : m_duration(duration)
    {
    }


    LONGLONG Ticks(void) const
    { 
        return m_duration;
    }

    LONG InMilliSeconds(void) const;
    CTimeDuration& operator+=(const CTimeDuration& d);
    CTimeDuration operator-() const;

public:
    static CTimeDuration OneMicroSecond(void)
    { 
        return 10i64;
    }


    static CTimeDuration OneMilliSecond(void) 
    { 
        return (1000i64 * 10i64);
    }


    static CTimeDuration OneSecond(void) 
    { 
        return (1000i64 * 1000i64 * 10i64); 
    }


    static CTimeDuration MaxValue(void)
    {
        return _I64_MAX;
    }


    static CTimeDuration MinValue(void) 
    { 
        return _I64_MIN; 
    }

    static CTimeDuration FromMilliSeconds(DWORD MilliSeconds)
    {
        return OneMilliSecond().Ticks() * MilliSeconds;
    }

private:
    LONGLONG m_duration;
};


inline CTimeDuration CTimeDuration::operator-() const
{
    return -Ticks();
}


inline LONG CTimeDuration::InMilliSeconds(void) const
{
    LONGLONG t = Ticks() / OneMilliSecond().Ticks();
    if (t > _I32_MAX) 
        return _I32_MAX;

    if (t < _I32_MIN)
        return _I32_MIN;

    return static_cast<LONG>(t);
}

//---------------------------------------------------------
//
// class CTimeInstant
//
//---------------------------------------------------------
class CTimeInstant
{
public:
    CTimeInstant(ULONGLONG time) : m_time(time)
    {
    }


    ULONGLONG Ticks(void) const
    {
        return m_time;
    }


    CTimeInstant& operator+=(const CTimeDuration& d);

public:
    static CTimeInstant MaxValue(void)
    { 
        return _UI64_MAX; 
    }


    static CTimeInstant MinValue(void) 
    { 
        return 0x0i64; 
    }


private:
    ULONGLONG m_time;
};


//---------------------------------------------------------
//
// operators
//
//---------------------------------------------------------
inline bool operator<(const CTimeInstant& t1, const CTimeInstant& t2)
{ 
    return (t1.Ticks() < t2.Ticks());
}


inline bool operator==(const CTimeInstant& t1, const CTimeInstant& t2)
{ 
    return (t1.Ticks() == t2.Ticks());
}


inline bool operator<(const CTimeDuration& d1, const CTimeDuration& d2)
{ 
    return (d1.Ticks() < d2.Ticks());
}


inline bool operator==(const CTimeDuration& d1, const CTimeDuration& d2)
{ 
    return (d1.Ticks() == d2.Ticks());
}


inline CTimeDuration operator+(const CTimeDuration& d1, const CTimeDuration& d2)
{
    LONGLONG d = d1.Ticks() + d2.Ticks();

    if ((d1.Ticks() > 0) && (d2.Ticks() > 0))
    {
        if (d > 0)
            return d;

        return CTimeDuration::MaxValue();
    }
    
    if ((d1.Ticks() < 0) && (d2.Ticks() < 0))
    {
        if (d < 0)
            return d;


        return CTimeDuration::MinValue();
    }

    return d;
}


inline CTimeDuration operator-(const CTimeDuration& d1, const CTimeDuration& d2)
{
    return (d1 + -d2);
}


inline CTimeDuration operator-(const CTimeInstant& t1, const CTimeInstant& t2)
{
    LONGLONG d = t1.Ticks() - t2.Ticks();

    if (t1.Ticks() > t2.Ticks())
    {
        if (d >= 0)
            return d;

        return CTimeDuration::MaxValue();
    }

    if (d <= 0)
        return d;

    return CTimeDuration::MinValue();
}


inline CTimeInstant operator+(const CTimeInstant t, const CTimeDuration& d)
{
    ULONGLONG ticks = t.Ticks() + d.Ticks();

    if (d.Ticks() > 0)
    {
        if (ticks >= t.Ticks())
            return ticks;

        return CTimeInstant::MaxValue();
    }

    if (ticks <= t.Ticks())
        return ticks;

    return CTimeInstant::MinValue();
}


inline CTimeInstant operator-(const CTimeInstant t, const CTimeDuration& d)
{
    return (t + -d);
}


inline CTimeDuration& CTimeDuration::operator+=(const CTimeDuration& d)
{
    *this = *this + d;
    return *this;
}


inline CTimeInstant& CTimeInstant::operator+=(const CTimeDuration& d)
{
    *this = *this + d;
    return *this;
}


#endif // _MSMQ_TIMETYPES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\inc\xbuf.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:
    xbuf.h

Abstract:
    Length buffer definition and implementation

	xbuf_t is reprisented as length and a typed buffer pointer.

    Memory representation,
	 +---+---+    --+-----------------+---
	 |Len|Ptr|----->|buffer pointed to|...
	 +---+---+    --+-----------------+---
	  xbuf_t		 .... buffer ....

Author:
    Erez Haba (erezh) 23-Sep-99

--*/

#pragma once

//-------------------------------------------------------------------
//
// class xbuf_t
//
//-------------------------------------------------------------------
template<class T>
class xbuf_t {
public:

    xbuf_t() :
		m_buffer(0),
		m_length(0)
	{
    }


	xbuf_t(T* buffer, size_t length) :
		m_buffer(buffer),
		m_length((int)length)
	{
		ASSERT((length == 0) || (buffer != 0));
	}


	T* Buffer() const
	{
		return m_buffer;
	}


	int Length() const
	{
		return m_length;
	}


private:
	int m_length;
	T* m_buffer;
};


template<class T> inline bool operator==(const xbuf_t<T>& x1, const xbuf_t<T>& x2)
{
	if(x1.Length() != x2.Length())
		return false;

	return (memcmp(x1.Buffer(), x2.Buffer(), x1.Length() * sizeof(T)) == 0);
}


template<class T> inline bool operator<(const xbuf_t<T>& x1, const xbuf_t<T>& x2)
{
	int minlen min(x1.Length(), x2.Length());
	int rc = memcmp(x1.Buffer(), x2.Buffer(), minlen * sizeof(T));
	if(rc != 0)
		return rc <0;

    return 	x1.Length() <  x2.Length();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\inc\tr.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Tr.h

Abstract:
    Tracing public interface

Author:
    Uri Habusha (urih) 24-Jan-98

--*/

#pragma once

#ifndef _MSMQ_Tr_H_
#define _MSMQ_Tr_H_

typedef LPCWSTR TraceIdEntry;

#define TrInitialize() ((void) 0)
#define TrRegisterComponent(ComponentTraceId, NoOfId)  ((void)0)

extern bool g_fAssertBenign;

bool
TrAssert(
    const char* FileName,
    unsigned int Line,
    const char* Text
    );

#define MQASSERT(e)\
        (void) ((e) || \
                (!TrAssert(__FILE__, __LINE__, #e)) || \
                (__debugbreak(), 0))

#define MQASSERT_RELEASE(e)\
				if (!(e))\
				{\
					EXCEPTION_RECORD er = {0x80000003/*STATUS_BREAKPOINT*/, 0, 0, 0};\
				    CONTEXT ctx = {0};\
				    EXCEPTION_POINTERS ep = {&er, &ctx};\
				    UnhandledExceptionFilter(&ep);\
				}

#ifdef _DEBUG

#define ASSERT(f)          MQASSERT(f)
#define VERIFY(f)          ASSERT(f)

#define ASSERT_BENIGN(f)   do { if(g_fAssertBenign) ASSERT(f); } while(0)
#define ASSERT_RELEASE(f)  MQASSERT(f)

#else   // _DEBUG

#define ASSERT(f)          ((void)0)
#define VERIFY(f)          ((void)(f))

#define ASSERT_BENIGN(f)   ((void)0)
#define ASSERT_RELEASE(f)  MQASSERT_RELEASE(f)

#endif // !_DEBUG

#endif // _MSMQ_Tr_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\inc\xds.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Xds.h

Abstract:
    Xml Digital Signature public interface

Author:
    Ilan Herbst (ilanh) 06-Mar-00

--*/

#pragma once

#ifndef _MSMQ_XDS_H_
#define _MSMQ_XDS_H_


#include "Cry.h"
#include "xml.h"
#include "xbuf.h"
#include "mqstl.h"

typedef xbuf_t<const void> xdsvoid_t;

//-------------------------------------------------------------------
//
// Exception class bad_Signature
//
//-------------------------------------------------------------------
class bad_signature : public exception {
public:

    bad_signature() :
        exception("bad signature")
    {
    }

};


//-------------------------------------------------------------------
//
// Exception class bad_Signature
//
//-------------------------------------------------------------------
class bad_XmldsigElement : public exception {
public:

    bad_XmldsigElement() :
        exception("bad Xmldsig Element")
    {
    }

};

//-------------------------------------------------------------------
//
// Exception class bad_Reference
//
//-------------------------------------------------------------------
class bad_reference : public exception {
public:

    bad_reference() :
        exception("bad reference")
    {
    }

};


//-------------------------------------------------------------------
//
// Exception class bad_base64
//
//-------------------------------------------------------------------
class bad_base64 : public exception {
public:

    bad_base64() :
        exception("bad base64")
    {
    }

};


//-------------------------------------------------------------------
//
// class CXdsReference
//
//-------------------------------------------------------------------
class  CXdsReference{

public:

	enum HashAlgorithm { haSha1, haMd5, haNull };

public:

	CXdsReference()
	{
	}
};


//-------------------------------------------------------------------
//
// class CXdsReferenceInput
//
//-------------------------------------------------------------------
class CXdsReferenceInput : public CXdsReference{

public:
	

	CXdsReferenceInput(
		HashAlgorithm HashAlg,
		LPCSTR DigestValue,
		LPCSTR Uri,
		LPCSTR Type
		);


	CXdsReferenceInput(
		const xdsvoid_t& ReferenceData,
		HashAlgorithm HashAlg,
		LPCSTR Uri,
		LPCSTR Type,
		HCRYPTPROV hCsp
		);


	CXdsReferenceInput(
		ALG_ID AlgId,
		LPCSTR DigestValue,
		LPCSTR Uri,
		LPCSTR Type
		);


	CXdsReferenceInput(
		const xdsvoid_t& ReferenceData,
		ALG_ID AlgId,
		LPCSTR Uri,
		LPCSTR Type,
		HCRYPTPROV hCsp
		);


	friend std::ostream& operator<<(std::ostream& os, const CXdsReferenceInput& ReferenceInput); 


private:	
	xdsvoid_t m_ReferenceData;
	ALG_ID m_HashAlgId;
	AP<char> m_DigestValue;
	AP<char> m_Uri;
	LPCSTR m_DigestMethodName;
	AP<char> m_Type;
};
	

//-------------------------------------------------------------------
//
// class CXdsReferenceValidateInfo
//
//-------------------------------------------------------------------
class  CXdsReferenceValidateInfo : public CXdsReference{

public:

	CXdsReferenceValidateInfo(
		xwcs_t Uri,
		xwcs_t DigestMethodName,
		xwcs_t DigestValue
		);


	CXdsReferenceValidateInfo(
		xwcs_t Uri,
		xwcs_t DigestMethodName,
		xwcs_t DigestValue,
		const xdsvoid_t& ReferenceData
		);


	xwcs_t Uri() const
	{
		return(m_Uri);
	}

	
	ALG_ID HashAlgId() const
	{
		return(m_HashAlgId);
	}


	xwcs_t DigestValue() const
	{
		return(m_DigestValue);
	}


	xdsvoid_t ReferenceData() const
	{
		return(m_ReferenceData);
	}


	void SetReferenceData(const xdsvoid_t& ReferenceData)
	{
		ASSERT(ReferenceData.Buffer() != NULL);
		ASSERT(ReferenceData.Length() != 0);
		m_ReferenceData = ReferenceData;
	}


private:	
	xwcs_t m_Uri;
	ALG_ID m_HashAlgId;
	xwcs_t m_DigestValue;
	xdsvoid_t m_ReferenceData;
};


//
// Typedefs
//
typedef std::vector<CXdsReferenceInput*> ReferenceInputVectorType;
typedef std::vector<CXdsReferenceValidateInfo*> ReferenceValidateVectorType;


//----------------------------------------------------------------------------------
//
//  class CReferenceValidateVectorTypeHelper - Auto class for ReferenceValidateVectorType 
//
//----------------------------------------------------------------------------------
class CReferenceValidateVectorTypeHelper {
public:
    CReferenceValidateVectorTypeHelper(const ReferenceValidateVectorType& h) : m_h(h)  {}
   ~CReferenceValidateVectorTypeHelper()                    
	{ 
		//
		// Cleaning Vector, CXdsReferenceValidateInfo Items
		//
		for(ReferenceValidateVectorType::iterator ir = m_h.begin(); 
			ir != m_h.end();)
		{
			CXdsReferenceValidateInfo* pReferenceValidateInfo = *ir;
			ir = m_h.erase(ir);
			delete pReferenceValidateInfo;
		}
	}

    ReferenceValidateVectorType& operator *()          { return m_h; }
    ReferenceValidateVectorType* operator ->()         { return &m_h; }

private:
    CReferenceValidateVectorTypeHelper(const CReferenceValidateVectorTypeHelper&);
    CReferenceValidateVectorTypeHelper& operator=(const CReferenceValidateVectorTypeHelper&);

private:
	ReferenceValidateVectorType m_h;
};


//-------------------------------------------------------------------
//
// class CXdsSignedInfo
//
//-------------------------------------------------------------------
class  CXdsSignedInfo{

public:

	enum SignatureAlgorithm { saDsa };

public:


	CXdsSignedInfo(
		SignatureAlgorithm SignatureAlg,
		LPCSTR Id,
		std::vector<CXdsReferenceInput*>& ReferenceInputs
		);
		

	~CXdsSignedInfo()
	{
		//
		// Empty m_References list  and free ReferenceElement strings
		//
		for(ReferenceInputVectorType::iterator it = m_ReferenceInputs.begin(); 
			it != m_ReferenceInputs.end();)
		{
			CXdsReferenceInput* pReferenceInput = *it;
			it = m_ReferenceInputs.erase(it);
			delete pReferenceInput;
		}
	}


	friend std::ostream& operator<<(std::ostream& os, const CXdsSignedInfo& SignedInfo); 


	ALG_ID SignatureAlgId() const
	{
		return(m_SignatureAlgId);
	}

private:
	AP<char> m_Id;
	ALG_ID m_SignatureAlgId;
	LPCSTR m_SignatureMethodName;
	ReferenceInputVectorType m_ReferenceInputs;
};


//-------------------------------------------------------------------
//
// class CXdsSignature
//
//-------------------------------------------------------------------
class  CXdsSignature{

public:

	CXdsSignature(
		CXdsSignedInfo::SignatureAlgorithm SignatureAlg,
		LPCSTR SignedInfoId,
		std::vector<CXdsReferenceInput*>& ReferenceInputs,
		LPCSTR Id,
		HCRYPTPROV hCsp,
		LPCSTR KeyValue = NULL
		) :
		m_SignedInfo(SignatureAlg, SignedInfoId, ReferenceInputs),
		m_Id(newstr(Id)),
		m_SignatureValue(NULL),
		m_KeyValue(newstr(KeyValue)),
		m_hCsp(hCsp),
		m_PrivateKeySpec(AT_SIGNATURE)
	{
	}


	CXdsSignature(
		CXdsSignedInfo::SignatureAlgorithm SignatureAlg,
		LPCSTR SignedInfoId,
		std::vector<CXdsReferenceInput*>& ReferenceInputs,
		LPCSTR Id,
		LPCSTR SignatureValue,
		LPCSTR KeyValue = NULL
		) :
		m_SignedInfo(SignatureAlg, SignedInfoId, ReferenceInputs),
		m_Id(newstr(Id)),
		m_SignatureValue(newstr(SignatureValue)),
		m_KeyValue(newstr(KeyValue)),
		m_hCsp(NULL),
		m_PrivateKeySpec(AT_SIGNATURE)
	{
	}


	CXdsSignature(
		CXdsSignedInfo::SignatureAlgorithm SignatureAlg,
		LPCSTR SignedInfoId,
		std::vector<CXdsReferenceInput*>& ReferenceInputs,
		LPCSTR Id,
		HCRYPTPROV hCsp,
		DWORD PrivateKeySpec,
		LPCSTR KeyValue = NULL
		) :
		m_SignedInfo(SignatureAlg, SignedInfoId, ReferenceInputs),
		m_Id(newstr(Id)),
		m_SignatureValue(NULL),
		m_KeyValue(newstr(KeyValue)),
		m_hCsp(hCsp),
		m_PrivateKeySpec(PrivateKeySpec)
	{
	}


	CXdsSignature(
		CXdsSignedInfo::SignatureAlgorithm SignatureAlg,
		LPCSTR SignedInfoId,
		std::vector<CXdsReferenceInput*>& ReferenceInputs,
		LPCSTR Id,
		LPCSTR SignatureValue,
		DWORD PrivateKeySpec,
		LPCSTR KeyValue = NULL
		) :
		m_SignedInfo(SignatureAlg, SignedInfoId, ReferenceInputs),
		m_Id(newstr(Id)),
		m_SignatureValue(newstr(SignatureValue)),
		m_KeyValue(newstr(KeyValue)),
		m_hCsp(NULL),
		m_PrivateKeySpec(PrivateKeySpec)
	{
	}


	friend std::ostringstream& operator<<(std::ostringstream& oss, const CXdsSignature& Signature);


	ALG_ID SignatureAlgId() const
	{
		return(m_SignedInfo.SignatureAlgId());
	}

	
	LPSTR SignatureElement()
	{
		std::ostringstream oss("");
		oss << *this;
		std::string TempStr = oss.str();

		//
		// c_str() return a null terminated string (opposite to data())
		// Mp (message protocol) lib assume the signature element is null terminated
		//
		return(newstr(TempStr.c_str()));
	}

private:
	AP<char> m_Id;
	CXdsSignedInfo m_SignedInfo;
	AP<char> m_SignatureValue;
	AP<char> m_KeyValue;
	DWORD m_PrivateKeySpec;
	HCRYPTPROV m_hCsp;
};


//
// Api
//
VOID
XdsInitialize(
    VOID
    );


LPWSTR
Octet2Base64W(
	const BYTE* OctetBuffer, 
	DWORD OctetLen, 
	DWORD *Base64Len
	);


LPSTR
Octet2Base64(
	const BYTE* OctetBuffer, 
	DWORD OctetLen, 
	DWORD *Base64Len
	);


BYTE* 
Base642OctetW(
	LPCWSTR Base64Buffer, 
	DWORD Base64Len,
	DWORD *OctetLen 
	);



LPWSTR
XdsCalcDataDigestW(
	const void *Data,
	DWORD DataLen,
	ALG_ID AlgId,
	HCRYPTPROV hCsp
	);


LPSTR
XdsCalcDataDigest(
	const void *Data,
	DWORD DataLen,
	ALG_ID AlgId,
	HCRYPTPROV hCsp
	);


LPSTR
XdsGetDataDigest(
	HCRYPTHASH hHash
	);


LPSTR
XdsCalcSignature(
	LPCSTR Data,
	DWORD DataLen,
	ALG_ID AlgId,
	DWORD PrivateKeySpec,
	HCRYPTPROV hCsp
	);


ReferenceValidateVectorType
XdsGetReferenceValidateInfoVector(
	const XmlNode* SignatureNode
    );


void
XdsValidateReference(
	const CXdsReferenceValidateInfo& ReferenceValidateInfo,
	HCRYPTPROV hCsp
    );


std::vector<bool>
XdsValidateAllReference(
	const ReferenceValidateVectorType& ReferenceValidateInfoVector,
	HCRYPTPROV hCsp
    );


void
XdsValidateSignature(
	const XmlNode* SignatureNode,
	HCRYPTKEY hKey,
	HCRYPTPROV hCsp
    );


void
XdsCoreValidation(
	const XmlNode* SignatureNode,
	HCRYPTKEY hKey,
	const ReferenceValidateVectorType& ReferenceValidateInfoVector,
	HCRYPTPROV hCsp
    );

#endif // _MSMQ_XDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\inc\utf8.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:
    utf8.h

Abstract:
    Conversion routine from utf8 caracters format to unicode and via versa.

Author:
    Gil Shafriri (gilsh) 8-11-2000

--*/

#pragma once

#ifndef _MSMQ_UTF8_H_
#define _MSMQ_UTF8_H_

//
// exception class for utf8 conversion exception - thrown  only
// because of invalid input
//
class bad_utf8 : public std::exception
{
};

typedef unsigned char utf8_char;
typedef std::basic_string<unsigned char> utf8_str;


size_t 
UtlUtf8LenOfWcs(
		const wchar_t* pwc
		)
		throw();


size_t 
UtlUtf8LenOfWcs(
		const wchar_t* pwc,
		size_t cbWcs
		)
		throw();


size_t
UtlWcToUtf8(
	wchar_t wc ,
	utf8_char *pUtf8, 
	size_t cbUtf8
	);


//
//utf8 c string to unicode c string
//
void 
UtlUtf8ToWcs(
		const utf8_char *pUtf8,
		wchar_t* pWcs,
		size_t cbWcs,
		size_t* pActualLen = NULL
		);


//
// unicode c string to utf8 c string
//
void
UtlWcsToUtf8(
		const wchar_t* pwcs,
		utf8_char* pUtf8,
		size_t cbUtf8,
		size_t* pActualLen  = NULL
		);
//
// unicode buffer to utf8 c string
//
void
UtlWcsToUtf8(
		const wchar_t* pwcs, 
		size_t cbwcs,
		utf8_char* pUtf8,
		size_t cbUtf8,
		size_t* pActualLen = NULL
		);

//
// utf8 c string to unicode c string
//
wchar_t* 
UtlUtf8ToWcs(
		const utf8_char* pUtf8,
		size_t* pActualLen  = NULL
		);

//
// utf8 buffer to unicode string
//
wchar_t* 
UtlUtf8ToWcs(
		const utf8_char* pUtf8,
		size_t cbUtf8,
		size_t* pActualLen
		);


//
// unicode buffer to utf8 c string
//
utf8_char* 
UtlWcsToUtf8(
		const wchar_t* pwcs,
		size_t* pActualLen  = NULL
		);

//
// unicode stl string to utf8 stl string.
//
utf8_str 
UtlWcsToUtf8(
			const std::wstring& wcs
			);

//
// unicode buffer to utf8 stl string
//
utf8_str 
UtlWcsToUtf8(
		const wchar_t* pwcs,
		size_t cbWcs
		);



//
// utf8 stl string to  unicode stl string.
//
std::wstring 
UtlUtf8ToWcs(
		const utf8_str& utf8
		);

//
// utf8 buffer to unicode stl string
//
std::wstring 
UtlUtf8ToWcs(
		const utf8_char* pUtf8,
		size_t cbUtf8
		);






#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\inc\xmlencode.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Xml.h

Abstract:
    Xml classes for encoding decoding special xml caracters

Author:
    Gil Shafriri (gilsh) 15-Feb-2001

--*/

#pragma once

#ifndef _MSMQ_XMLENCODE_H_
#define _MSMQ_XMLENCODE_H_

#include <buffer.h>
#include <xstr.h>

//---------------------------------------------------------
//
// CXmlEncode - class for encoding xml characters  treating special caracters. 
//
//---------------------------------------------------------
class CXmlEncode
{
public:
	CXmlEncode(const xwcs_t& wcs);

private:
	const xwcs_t& m_wcs;
	friend std::wostream& operator<<(std::wostream& o, const CXmlEncode& XmlEncode);
};



//---------------------------------------------------------
//
// CXmlDecode - class for decoding emcoded xml caracters 
//
//---------------------------------------------------------
class CXmlDecode
{
public:
	CXmlDecode();

public:
	const xwcs_t get() const;
	void Decode(const xwcs_t& encoded);

private:
	const WCHAR* HandleReguralChar(const WCHAR* ptr);
	const WCHAR* HandleSpeciallChar(const WCHAR* ptr);

private:
	xwcs_t m_encoded;
	bool m_fConverted;
	CStaticResizeBuffer<WCHAR, 256> m_DecodedBuffer;
};


//---------------------------------------------------------
//
// bad_xml_encoding - exception class thrown 
// if  CXmlDecode detect bad encoding
//
//---------------------------------------------------------
class bad_xml_encoding	: public exception
{

	
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\inc\xstr.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:
    xstr.h

Abstract:
    Length String definition and implementation

	xstr_t is reprisented as length and a character pointer, based on xbuf_t.
	The text pointed to is not a null terminated string, but rather a text
	contained within a 	larger text buffer.

Author:
    Erez Haba (erezh) 7-Sep-99

--*/

#pragma once

#include <xbuf.h>
#include <mqcast.h>

#define LOG_XSTR(x) (x).Length(), (x).Buffer()
#define LOG_XWCS(x) (x).Length(), (x).Buffer()


//-------------------------------------------------------------------
//
// class xstr_t
//
//-------------------------------------------------------------------
template <class T>
class basic_xstr_t : public xbuf_t<const T> {
public:

    basic_xstr_t(void)
	{
    }


	basic_xstr_t(const T* buffer, size_t length) :
		xbuf_t<const T>(buffer, length)
	{
	}

	T* ToStr() const
	{
		T* pStr = new T[Length() + 1];	
		CopyTo(pStr);
		return pStr;
	}

	void CopyTo(T* buffer) const
	{
		memcpy(buffer, Buffer(), Length()*sizeof(T));
		buffer[Length()] = 0;
	}
};

typedef  basic_xstr_t<char>  xstr_t;
typedef  basic_xstr_t<WCHAR> xwcs_t;

inline bool operator==(const xstr_t& x1, const char* s2)
{
    //
    // Check that the strings are matching to the length of x1 and that s2 is
    // the same length.
    //
	return ((strncmp(x1.Buffer(), s2, x1.Length()) == 0) && (s2[x1.Length()] == '\0'));
}


inline bool operator!=(const xstr_t& x1, const char* s2)
{
	return !(x1 == s2);
}


inline bool operator==(const xwcs_t& x1, const WCHAR* s2)
{
    //
    // Check that the strings are matching to the length of x1 and that s2 is
    // the same length.
    //
	return ((wcsncmp(x1.Buffer(), s2, x1.Length()) == 0) && (s2[x1.Length()] == L'\0'));
}


inline bool operator!=(const xwcs_t& x1, const WCHAR* s2)
{
	return !(x1 == s2);
}


inline UNICODE_STRING XwcsToUnicodeString(const xwcs_t& x1)
{
	UNICODE_STRING str;
	str.Length = numeric_cast<USHORT>(x1.Length() * sizeof(WCHAR));
	str.MaximumLength = str.Length;
	str.Buffer = const_cast<PWSTR>(x1.Buffer());
	return str;
}


#define S_XSTR(x) xstr_t((x),STRLEN(x))
#define S_XWCS(x)  xwcs_t((x),STRLEN(x))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mm\lib\mem.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    mem.cpp

Abstract:
    Memory Allocator

Author:
    Erez Haba (erezh) 04-Aug-99

Environment:
    Platform-independent,

--*/

#include <libpch.h>

#include "mem.tmh"

const TraceIdEntry Mm = L"Memory";

#undef new

#ifdef _DEBUG

//
// Memory allocation probability
//
static int s_AllocationProbability = RAND_MAX;

DWORD
MmAllocationProbability(
	DWORD AllocationProbability
	)
{
	ASSERT(AllocationProbability <= 100);
	DWORD ap = s_AllocationProbability;
	s_AllocationProbability = (AllocationProbability * RAND_MAX) / 100;
	return ap;
}


VOID
MmSetAllocationSeed(
	DWORD AllocationSeed
	)
{
	srand(AllocationSeed);
}
						

static bool FailAllocation()
{
	return (rand() > s_AllocationProbability);
}


const unsigned char xNoMansLandFill = 0xFD;
const unsigned char xDeadLandFill = 0xDD;
const unsigned char xClearLandFill = 0xCD;

const int xSignature = 'zerE';

struct CBlockHeader {
    size_t m_size;
    const char* m_file;
    int m_line;
    int m_signature;
    unsigned char m_data[0];
};

inline void* Allocate(size_t s, const char* fn, int l)
{
	if(FailAllocation())
	{
        //
        // ISSUE-2000/04/09-erezh Tracing is commented out
        // Tracing is comment out as it requires linking with the Cm library.
        // Not all binaries are able to cope with this library.
        //
        // ISSUE-2000/10/22-erezh Wpp tracing does not recognizes the %I format.
        //
		//xxTrERROR(Mm, "Failing %Id bytes allocation at %s(%d)", s, fn, l);
		return 0;
	}

	CBlockHeader* pHeader = (CBlockHeader*)malloc(s + sizeof(CBlockHeader));
    if(pHeader == 0)
        return 0;

    pHeader->m_size = s;
    pHeader->m_file = fn;
    pHeader->m_line = l;
    pHeader->m_signature = xSignature;
    return memset(&pHeader->m_data, xClearLandFill, s);
}


inline void Deallocate(void* p)
{
    if(p == 0)
        return;

    CBlockHeader* pHeader = static_cast<CBlockHeader*>(p) - 1;

    ASSERT(pHeader->m_signature == xSignature);
    memset(pHeader, xDeadLandFill, pHeader->m_size + sizeof(CBlockHeader));
    free(pHeader);
}


#else // _DEBUG


inline void* Allocate(size_t s, const char*, int)
{
	return 	malloc(s);
}


inline void Deallocate(void* p)
{
    free(p);
}


#endif // _DEBUG


void* MmAllocate(size_t s) throw(bad_alloc)
{
    void* p = Allocate(s, __FILE__, __LINE__);

    if(p != 0)
		return p;

	throw bad_alloc();
}


void* MmAllocate(size_t s, const nothrow_t&) throw()
{
    return Allocate(s, __FILE__, __LINE__);
}


void* MmAllocate(size_t s, const char* fn, int l) throw(bad_alloc)
{
    void* p = Allocate(s, fn, l);

    if(p != 0)
		return p;

	throw bad_alloc();
}


void* MmAllocate(size_t s, const char* fn, int l, const nothrow_t&) throw()
{

    return Allocate(s, fn, l);
}


void MmDeallocate(void* p) throw()
{
    Deallocate(p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\inc\xml.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Xml.h

Abstract:
    Xml public interface

Author:
    Erez Haba (erezh) 15-Sep-99

--*/

#pragma once

#ifndef _MSMQ_XML_H_
#define _MSMQ_XML_H_



#include "xstr.h"
#include "List.h"

class XmlNode;


VOID
XmlInitialize(
    VOID
    );

VOID
XmlFreeTree(
	XmlNode* Tree
	);


const WCHAR*
XmlParseDocument(
	const xwcs_t& doc,
	XmlNode** ppTree
	);


const
XmlNode*
XmlFindNode(
	const XmlNode* Tree,
	const WCHAR* NodePath
	);


const
xwcs_t*
XmlGetNodeFirstValue(
	const XmlNode* Tree,
	const WCHAR* NodePath
	);


const
xwcs_t*
XmlGetAttributeValue(
	const XmlNode* Tree,
	const WCHAR* AttributeTag,
	const WCHAR* NodePath = NULL
	);


#ifdef _DEBUG

VOID
XmlDumpTree(
	const XmlNode* Tree
	);

#else // _DEBUG

#define XmlDumpTree(Tree) ((void)0);

#endif // _DEBUG



//-------------------------------------------------------------------
//
// class XmlNameSpace
//
//-------------------------------------------------------------------
class XmlNameSpace
{
public:	
	XmlNameSpace(const xwcs_t& prefix):m_prefix(prefix)
	{

	}

	XmlNameSpace(const xwcs_t& prefix,const xwcs_t& uri):m_prefix(prefix),m_uri(uri)
	{

	}

	xwcs_t m_prefix;
	xwcs_t m_uri;
};


//-------------------------------------------------------------------
//
// class XmlAttribute
//
//-------------------------------------------------------------------
class XmlAttribute {
public:
	XmlAttribute(const xwcs_t& prefix,const xwcs_t& tag, const xwcs_t& value) :
		m_tag(tag),
		m_value(value),
		m_namespace(prefix)
	{
	}
		
public:
	LIST_ENTRY m_link;
	xwcs_t m_tag;
	xwcs_t m_value;
	XmlNameSpace m_namespace;

private:
    XmlAttribute(const XmlAttribute&);
    XmlAttribute& operator=(const XmlAttribute&);
};


//-------------------------------------------------------------------
//
// class XmlValue
//
//-------------------------------------------------------------------
class XmlValue {
public:
	XmlValue(const xwcs_t& value) :
		m_value(value)
	{
	}

public:
	LIST_ENTRY m_link;
	xwcs_t m_value;

private:
    XmlValue(const XmlValue&);
    XmlValue& operator=(const XmlValue&);
};




//-------------------------------------------------------------------
//
// class XmlNode
//
//-------------------------------------------------------------------
class XmlNode {
public:
    XmlNode(const xwcs_t& prefix,const xwcs_t& tag) :
		m_tag(tag),m_namespace(prefix)

    {
		
    }


public:
	LIST_ENTRY m_link;
	List<XmlAttribute> m_attributes;
	List<XmlValue> m_values;
	List<XmlNode, 0> m_nodes;
	xwcs_t m_tag;
	xwcs_t m_element;  // all element include the start tag and end tag
	xwcs_t m_content;  // element content not include start tag and end tag
	XmlNameSpace m_namespace;


private:
    XmlNode(const XmlNode&);
    XmlNode& operator=(const XmlNode&);
};

//
// Ensure that m_link offset in XmlNode is zero.
// As we can not have List<XmlNode> used inside XmlNode definition, so
// we assume that the link offset is zero and use List<XmlNode, 0>
// instade.
//
C_ASSERT(FIELD_OFFSET(XmlNode, m_link) == 0);




//-------------------------------------------------------------------
//
// Exception class bad_document
//
//-------------------------------------------------------------------
class bad_document : public exception {
public:
    bad_document(const WCHAR* ParsingErrorLocation) :
        exception("bad document"),
        m_location(ParsingErrorLocation)
    {
    }

    const WCHAR* Location() const
    {
        return m_location;
    }

private:
    const WCHAR* m_location;
};


//---------------------------------------------------------
//
// XmlNode release helper
//
//---------------------------------------------------------
class CAutoXmlNode {
private:
    XmlNode* m_p;

public:
    CAutoXmlNode(XmlNode* p = 0) : m_p(p)    {}
   ~CAutoXmlNode()                { if(m_p !=0) XmlFreeTree(m_p); }

    operator XmlNode*() const     { return m_p; }
    XmlNode** operator&()         { return &m_p;}
    XmlNode* operator->() const   { return m_p; }
    XmlNode* detach()             { XmlNode* p = m_p; m_p = 0; return p; }

private:
    CAutoXmlNode(const CAutoXmlNode&);
    CAutoXmlNode& operator=(const CAutoXmlNode&);
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mm\lib\str.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    str.cpp

Abstract:
    Simple string and memory manipulations

Author:
    Erez Haba (erezh) 09-Aug-99

Environment:
    Platform-independent,

--*/

#include <libpch.h>

#include "str.tmh"

LPWSTR newwcs(LPCWSTR p)
{
    if(p == 0)
        return 0;

    LPWSTR dup = new WCHAR[wcslen(p) + 1];
    return wcscpy(dup, p);
}


LPSTR newstr(LPCSTR p)
{
    if(p == 0)
        return 0;

    LPSTR dup = new CHAR[strlen(p) + 1];
    return strcpy(dup, p);
}

LPWSTR newwcscat(LPCWSTR s1,LPCWSTR s2)
{
    if(s1 == 0 || s2 == 0)
        return 0;

    LPWSTR scat = new WCHAR[wcslen(s1) + wcslen(s2) +1];
    wcscpy(scat,s1);
	wcscat(scat,s2);

	return scat;
}


LPSTR newstrcat(LPCSTR s1,LPCSTR s2)
{
    if(s1 == 0 || s2 == 0)
	{
		return 0;
	}

    LPSTR scat = new CHAR[strlen(s1) +strlen(s2) +1];
    strcpy(scat,s1);
	strcat(scat,s2);

	return scat;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mm\lib\mmdebug.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    MmDebug.cpp

Abstract:
    Memory Manager debugging

Author:
    Erez Haba (erezh) 03-Apr-00

Environment:
    Platform-independent, _DEBUG only

--*/

#include <libpch.h>
#include "Mm.h"

#include "mmdebug.tmh"

#ifdef _DEBUG


static _CrtMemState s_memState ;
 
void MmCheckpoint(void)
{
    //_CrtMemCheckpoint(&s_memState);
}


void MmDumpUsage(void)
{
    //_CrtMemDumpAllObjectsSince(&s_memState);
}


DWORD
MmAllocationValidation(
	DWORD /*AllocationFlags*/
	)
{
	return 0;//_CrtSetDbgFlag(AllocationFlags);
}


DWORD
MmAllocationBreak(
	DWORD /*AllocationNumber*/
	)
{
	return 0;//_CrtSetBreakAlloc(AllocationNumber);
}


bool
MmIsStaticAddress(
    const void* Address
    )
{
    MEMORY_BASIC_INFORMATION Info;
    VirtualQuery(Address, &Info, sizeof(Info));

    return (Info.Type == MEM_IMAGE);
}


#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mm\test\mmtest.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    MmTest.cpp

Abstract:
    Memory library test

Author:
    Erez Haba (erezh) 04-Aug-99

Environment:
    Platform-independent,

--*/

#include <libpch.h>
#include "Mm.h"

#include "MmTest.tmh"

const TraceIdEntry MmTest = L"Memory Test";


extern "C" int __cdecl _tmain(int /*argc*/, LPCTSTR /*argv*/[])
/*++

Routine Description:
    Test Memory library

Arguments:
    Parameters.

Returned Value:
    None.

--*/
{
    WPP_INIT_TRACING(L"Microsoft\\MSMQ");

	TrInitialize();
	TrRegisterComponent(&MmTest, 1);

	MmAllocationValidation(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);

	void* p = new int[1000];

	//
	// Let memory aloocations succeed on 20% of the allocations
	//
	MmAllocationProbability(20);

	int AllocSuccess = 0;
	for(int i = 0; i < 1000; i++)
	{
		try
		{
			AP<WCHAR> q = newwcs(L"Erez");
			++AllocSuccess;
		}
		catch(const bad_alloc&)
		{
			NULL;
		}
	}

	for(int i = 0; i < 1000; i++)
	{
		try
		{
			AP<WCHAR> q = newwcscat(L"Foo&",L"Bar");
			AP<CHAR> q2 = newstrcat("Foo&","Bar");
			++AllocSuccess;
		}
		catch(const bad_alloc&)
		{
			NULL;
		}
	}



	delete[] p;

	printf("Allocation succeed for %d%%\n", (AllocSuccess * 100) / 1000);

    //
    // Check for static addresses
    //
    ASSERT(MmIsStaticAddress(MmTest));

	MmAllocationProbability(xAllocationAlwaysSucceed);
    void* q = new int[10];
    ASSERT(!MmIsStaticAddress(&q));
    ASSERT(!MmIsStaticAddress(q));
    delete[] q;

    WPP_CLEANUP();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mmt\lib\mmtconnect.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:

    MmtConnect.cpp

Abstract:

    Multicast Message Transport class - Connect implementation

Author:

    Shai Kariv  (shaik)  27-Aug-00

Environment:

    Platform-independent

--*/

#include <libpch.h>
#include <mqsymbls.h>
#include <mqwin64a.h>
#include <mqformat.h>
#include "Mtm.h"
#include "Mmt.h"
#include "Mmtp.h"
#include "MmtObj.h"

#include "mmtconnect.tmh"

VOID 
CMessageMulticastTransport::RequeuePacket(
    VOID
    )
/*++

Routine Description:

    The routine returns entry to the queue
  
Arguments:

    None.
  
Returned Value:

    None.

--*/
{
    CACPacketPtrs& acPtrs = m_RequestEntry.GetAcPacketPtrs();

    ASSERT(acPtrs.pDriverPacket != NULL);
    ASSERT(acPtrs.pPacket != NULL);

    CQmPacket Entry(acPtrs.pPacket, acPtrs.pDriverPacket);
    m_pMessageSource->Requeue(&Entry);

    acPtrs.pPacket = NULL;
    acPtrs.pDriverPacket = NULL;

} // CMessageMulticastTransport::RequeuePacket


VOID 
WINAPI 
CMessageMulticastTransport::GetPacketForConnectingSucceeded(
    EXOVERLAPPED* pov
    )
/*++

Routine Description:

    The routine is called when a new packet is received for sending on non
    connecting message transport. Getting the message is used as a trigger 
    for creating a connection
  
Arguments:

    pov - pointer to overlapped structure.
  
Returned Value:

    None.

--*/
{
    ASSERT(SUCCEEDED(pov->GetStatus()));

	CRequestOv* pRequest = static_cast<CRequestOv*>(pov);
    R<CMessageMulticastTransport> pMmt = CONTAINING_RECORD(pRequest, CMessageMulticastTransport, m_RequestEntry);

    WCHAR buffer[MAX_PATH];
    MQpMulticastIdToString(pMmt->MulticastId(), buffer);
    TrTRACE(Mmt, "Connecting to %ls. pMmt = %p", buffer, pMmt.get());

    //
    // Return the message to the queue before create the connection.
    //
    pMmt->RequeuePacket();
    try
    {
        if (! pMmt->TryToCancelCleanupTimer())
            return;

        pMmt->Connect();
    }
    catch(const exception&)
    {
        TrERROR(Mmt, "Failed to create connection to '%ls'. pMmt = %p", buffer, pMmt.get());
        
        pMmt->ScheduleRetry();
        throw;
    }
} // CMessageMulticastTransport::GetPacketForConnectingSucceeded


VOID 
WINAPI 
CMessageMulticastTransport::GetPacketForConnectingFailed(
    EXOVERLAPPED* pov
    )
/*++

Routine Description:

    The routine is called when we fail to get a a new packet from the queue.
    The message transport is in non connecting state, so we try to get the 
    message sometime later.
  
Arguments:

    pov - pointer to overlapped structure.
  
Returned Value:

    None.

--*/
{
    ASSERT(FAILED(pov->GetStatus()));

    //
    // Retrieve message transport
    //
	CRequestOv* pRequest = static_cast<CRequestOv*>(pov);
    R<CMessageMulticastTransport> pMmt = CONTAINING_RECORD(pRequest, CMessageMulticastTransport, m_RequestEntry);

    TrERROR(Mmt, "Failed to get a new entry for connecting. pMmt = 0x%p", pMmt.get());
    
    pMmt->Shutdown();

} // CMessageMulticastTransport::GetPacketForConnectingFailed


VOID 
WINAPI 
CMessageMulticastTransport::TimeToRetryConnection(
    CTimer * pTimer
    )
/*++

Routine Description:

    It is time to retry connecting to the destination. This function is called
    by the timer after failing to create a connection.

Arguments:

    pTimer - pointer to CTimer object embedded in the message transport object.
  
Returned Value:

    None.

--*/
{
    R<CMessageMulticastTransport> pMmt = CONTAINING_RECORD(pTimer, CMessageMulticastTransport, m_retryTimer);


    pMmt->StartCleanupTimer();

    //
    // Ask for new message from the queue. Getting a message from the queue
    // triggers the creation of the connection
    //
    // NOTE: If this function throws, the transport will be closed at *idle* time,
    //       which is okay as we are low on resources.
    //
    pMmt->GetNextEntry();

} // CMessageMulticastTransport::TimeToRetryConnection


void
CMessageMulticastTransport::InitPerfmonCounters(
	LPCWSTR strMulticastId
	)
{
    m_pPerfmon->CreateInstance(strMulticastId);
}


VOID 
CMessageMulticastTransport::ConnectionSucceeded(
    VOID
    )
/*++

Routine Description:

    The routine is called when create a connection completes successfully
  
Arguments:

    None.
  
Returned Value:

    None.

--*/
{
	m_pConnection = m_SocketTransport->GetConnection();
	ASSERT(m_pConnection.get() != NULL);
   
    WCHAR buffer[MAX_PATH];
    MQpMulticastIdToString(MulticastId(), buffer);
    TrTRACE(Mmt, "Connected to '%ls'",  buffer);

    
	//
    // Create Session permormance counter structure
    //
    InitPerfmonCounters(buffer);   

    //
    // Initialize the EXOVERLAPPED with send callback routines
    //
    #pragma PUSH_NEW
    #undef new

        new(&m_ov) EXOVERLAPPED(SendSucceeded, SendFailed);
        new(&m_RequestEntry)CRequestOv(GetPacketForSendingSucceeded, GetPacketForSendingFailed);

    #pragma POP_NEW

    
    StartCleanupTimer();

    //
    // Now, connection was established. The message Transport is ready to 
    // get a message for sending
    //
    GetNextEntry();

} // CMessageMulticastTransport::ConnectionSucceeded


VOID 
WINAPI 
CMessageMulticastTransport::ConnectionSucceeded(
    EXOVERLAPPED* pov
    )
{
    ASSERT(SUCCEEDED(pov->GetStatus()));

    R<CMessageMulticastTransport> pMmt = CONTAINING_RECORD(pov, CMessageMulticastTransport, m_ov);

    //
    // Connect has completed successfully, go and start delivering the messages.
    // If delivery failes here, the cleanup timer will eventually shutdown this
    // transport, so no explict shutdown is nesscessary.
    //
    // Do not schedule a retry here if this failes as this is the first send,
    // and any failure indicates a fatal error. (unlike after first delivery).
    //
    pMmt->ConnectionSucceeded();
}


VOID 
WINAPI
CMessageMulticastTransport::ConnectionFailed(
    EXOVERLAPPED* pov
    )
/*++

Routine Description:

    The routine is called when create a connection failed
  
Arguments:

    pov - Pointer to overlapped.
    
Returned Value:

    None.

--*/
{
    ASSERT(FAILED(pov->GetStatus()));

    R<CMessageMulticastTransport> pMmt = CONTAINING_RECORD(pov, CMessageMulticastTransport, m_ov);

    WCHAR buffer[MAX_PATH];
    MQpMulticastIdToString(pMmt->MulticastId(), buffer);
    TrERROR(Mmt, "Failed to connect to '%ls'. pMmt=%p", buffer, pMmt.get());
    pMmt->ScheduleRetry();
}


VOID 
CMessageMulticastTransport::Connect(
    VOID
    )
/*++

Routine Description:

    The routine creates a winsock connection. The operation is asynchronous 
    and on completion a call back routine is called
  
Arguments:

    None.
  
Returned Value:

    None.

Note:
    No Timers are running concurrently, so this function can not be interrupted
    by Shutdown. No need to protect m_socket etc.

--*/
{
    //
    // Start asynchronous connection
    //
    try
    {
        AddRef();
        SOCKADDR_IN Address;
        Address.sin_family = AF_INET;
        Address.sin_port = htons(static_cast<USHORT>(MulticastId().m_port));
        Address.sin_addr.s_addr = MulticastId().m_address;
        m_SocketTransport->CreateConnection(Address, &m_ov);
    }
    catch(const exception&)
    {
        WCHAR buffer[MAX_PATH];
        MQpMulticastIdToString(MulticastId(), buffer);
		TrERROR(Mmt, "Failed to connect to '%ls'", buffer);
        Release();
        throw;
    }
} // CMessageMulticastTransport::Connect


VOID 
CMessageMulticastTransport::Shutdown(
    VOID
    )
    throw()
{
    //
    // Protect m_socket, m_state 
    //
    CSW writeLock(m_pendingShutdown);

    if (State() == csShutdownCompleted) 
    {
        return;
    }

    if (m_pConnection.get() != NULL)
    {
        m_pConnection->Close();
	}


    //
    // Now Shutdown is in progress, cancel all timers
    //
    State(csShuttingDown);
    TryToCancelCleanupTimer();

    //
    // Cancle peding request from the queue
    //
    m_pMessageSource->CancelRequest();

    //
    // Remove the message transport from transport manager data structure, and create
    // a new transport to the target
    //
    AppNotifyMulticastTransportClosed(MulticastId());
   
    State(csShutdownCompleted);
	TrTRACE(Mmt,"Shutdown completed (RefCount = %d)",GetRef());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mmt\lib\mmtget.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:

    MmtGet.cpp

Abstract:

    Get message from queue in order to multicast it.

Author:

    Shai Kariv  (shaik)  27-Aug-00

Environment:

    Platform-independent

--*/

#include <libpch.h>
#include "Mmt.h"
#include "Mmtp.h"
#include "MmtObj.h"

#include "mmtget.tmh"

VOID CMessageMulticastTransport::GetNextEntry(VOID)
{
    //
    // Protect m_state and m_fPendingRequest. 
    // Insure that no one closes the connection while we are trying to issue get request.
    //
    CSR readLock(m_pendingShutdown);

    if ((State() == csShuttingDown) || (State() == csShutdownCompleted))
        throw exception();

    try
    { 
        AddRef();
        m_pMessageSource->GetFirstEntry(&m_RequestEntry, m_RequestEntry.GetAcPacketPtrs());
    }
    catch (const exception&)
    {    
        Release();
        throw;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mmt\lib\mmt.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:

    Mmt.cpp

Abstract:

    Multicast Message Transport implementation

Author:

    Shai Kariv  (shaik)  27-Aug-00

Environment:

    Platform-independent,

--*/

#include <libpch.h>
#include <st.h>
#include "Mmt.h"
#include "Mmtp.h"
#include "MmtObj.h"

#include "mmt.tmh"

R<CMulticastTransport>
MmtCreateTransport(
	MULTICAST_ID id,
	IMessagePool * pMessageSource,
	ISessionPerfmon* pPerfmon,
    const CTimeDuration& retryTimeout,
    const CTimeDuration& cleanupTimeout
    )
{
    MmtpAssertValid();

    ASSERT(pMessageSource != NULL);

	ISocketTransport* pWinsock; 
    pWinsock = StCreatePgmWinsockTransport();
	P<ISocketTransport> Winsock(pWinsock);

    CMessageMulticastTransport * pMmt;
    pMmt = new CMessageMulticastTransport(
                   id, 
                   pMessageSource, 
				   pPerfmon,
                   retryTimeout, 
                   cleanupTimeout,
                   Winsock
                   );
    return pMmt;

} // MmtCreateTransport
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mmt\lib\mmtobj.cpp ===
/*++

  
Copyright (c) 1995-97  Microsoft Corporation

Module Name:

    MmtObj.cpp

Abstract:

    CMessageMulticastTransport implementation.

Author:

    Shai Kariv  (shaik)  27-Aug-00

Environment:

    Platform-independent

--*/

#include <libpch.h>
#include <mqsymbls.h>
#include <mqwin64a.h>
#include <mqformat.h>
#include "Mmt.h"
#include "Mmtp.h"
#include "MmtObj.h"

#include "mmtobj.tmh"

bool CMessageMulticastTransport::TryToCancelCleanupTimer(VOID)
{
    if (!ExCancelTimer(&m_cleanupTimer))
        return false;

    Release();
    return true;
}

VOID CMessageMulticastTransport::StartCleanupTimer(VOID)
{
    ASSERT(!m_cleanupTimer.InUse());

    m_fUsed = false;
    
    AddRef();
    ExSetTimer(&m_cleanupTimer, m_cleanupTimeout);
}


VOID WINAPI CMessageMulticastTransport::TimeToCleanup(CTimer* pTimer)
{
    R<CMessageMulticastTransport> pMmt = CONTAINING_RECORD(pTimer, CMessageMulticastTransport, m_cleanupTimer);

    if (pMmt->m_fUsed)
    {
        pMmt->StartCleanupTimer();
        return;
    }

    TrERROR(Mmt, "Transport is idle, shutting down. pMmt=0x%p", pMmt.get());
    pMmt->Shutdown();
}


CMessageMulticastTransport::CMessageMulticastTransport(
    MULTICAST_ID id,
    IMessagePool * pMessageSource,
	ISessionPerfmon* pPerfmon,
    const CTimeDuration& retryTimeout,
    const CTimeDuration& cleanupTimeout,
	P<ISocketTransport>& SocketTransport
    ) :
    CMulticastTransport(id),
    m_pMessageSource(SafeAddRef(pMessageSource)),
	m_pPerfmon(SafeAddRef(pPerfmon)),
    m_RequestEntry(GetPacketForConnectingSucceeded, GetPacketForConnectingFailed),
    m_ov(ConnectionSucceeded, ConnectionFailed),
    m_retryTimeout(retryTimeout),
    m_retryTimer(TimeToRetryConnection),
    m_fUsed(false),
    m_cleanupTimer(TimeToCleanup),
    m_cleanupTimeout(cleanupTimeout),
	m_SocketTransport(SocketTransport.detach())
{
	ASSERT(("Invalid parameter", pMessageSource != NULL));
	ASSERT(("Invalid parameter", pPerfmon != NULL));

    WCHAR buffer[MAX_PATH];
    MQpMulticastIdToString(id, buffer);
	TrTRACE(
		Mmt, 
		"Create new multicast message transport. pMmt = 0x%p, multicast address = %ls", 
		this, 
		buffer
		);

    Connect();
}


CMessageMulticastTransport::~CMessageMulticastTransport()
{
	TrTRACE(Mmt,"CMessageMulticastTransport Destructor called");
    ASSERT(!m_retryTimer.InUse());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mmt\lib\mmtinit.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:

    MmtInit.cpp

Abstract:

    Multicast Message Transport initialization

Author:

    Shai Kariv  (shaik)  27-Aug-00

Environment:

    Platform-independent

--*/

#include <libpch.h>
#include "Mmt.h"
#include "Mmtp.h"

#include "mmtinit.tmh"

VOID
MmtInitialize(
    VOID
    )
/*++

Routine Description:

    Initializes Multicast Message Transport library

Arguments:

    None.

Returned Value:

    None.

--*/
{
    //
    // Validate that the Message Transport library was not initalized yet.
    // You should call its initalization only once.
    //
    ASSERT(!MmtpIsInitialized());
    MmtpRegisterComponent();

    MmtpSetInitialized();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mmt\lib\mmtp.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:

    Mmtp.h

Abstract:

    Multicast Message Transport private functions.

Author:

    Shai Kariv  (shaik)  27-Aug-00

--*/

#pragma once

#include <ex.h>


const TraceIdEntry Mmt = L"Multicast Message Transport";


const char xMultipartContentType[] = "multipart/related";
const char xEnvelopeContentType[] = "text/xml";
const char xApplicationContentType[] = "application/octet-stream";

#define BOUNDARY_LEADING_HYPHEN "--"
#define BOUNDARY_VALUE "MSMQ - SOAP boundary, %d "
typedef std::vector<WSABUF> HttpRequestBuffers;



#ifdef _DEBUG

VOID MmtpAssertValid(VOID);
VOID MmtpSetInitialized(VOID);
BOOL MmtpIsInitialized(VOID);
VOID MmtpRegisterComponent(VOID);

#else // _DEBUG

#define MmtpAssertValid() ((VOID)0)
#define MmtpSetInitialized() ((VOID)0)
#define MmtpIsInitialized() TRUE
#define MmtpRegisterComponent() ((VOID)0)

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mmt\lib\mmtobj.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:

    MmtObj.h

Abstract:

    CMessageMulticastTransport declaration.

Author:

    Shai Kariv  (shaik)  27-Aug-00

--*/

#pragma once

#ifndef __MmtObj_H__
#define __MmtObj_H__

#include "msi.h"
#include "spi.h"

#include <mqwin64a.h>
#include "acdef.h"
#include "qmpkt.h"

#include <ex.h>
#include <rwlock.h>
#include <st.h>
#include <buffer.h>
#include "Mp.h"
typedef std::basic_string<unsigned char> utf8_str;


class CMessageMulticastTransport : public CMulticastTransport
{
public:

    CMessageMulticastTransport(
        MULTICAST_ID id,
        IMessagePool * pMessageSource,
		ISessionPerfmon* pPerfmon,
        const CTimeDuration& retryTimeout,
        const CTimeDuration& cleanupTimeout,
		P<ISocketTransport>& SocketTransport
        );

    virtual ~CMessageMulticastTransport();
    
private:

    class CRequestOv : public EXOVERLAPPED
    {
    public:

        CRequestOv(        
            COMPLETION_ROUTINE pSuccess,
            COMPLETION_ROUTINE pFailure
        ):
            EXOVERLAPPED(pSuccess, pFailure)
        {
            m_pMsg.pPacket = NULL;
            m_pMsg.pDriverPacket = NULL;
        }


        CACPacketPtrs& GetAcPacketPtrs(VOID)
        {
            return m_pMsg;
        }


    private:

        CACPacketPtrs m_pMsg;
    };


    class COverlapped : public EXOVERLAPPED
    {
    public:
        COverlapped(        
            COMPLETION_ROUTINE pSuccess,
            COMPLETION_ROUTINE pFailure
        ):
        EXOVERLAPPED(pSuccess, pFailure),
	  	m_userData1(0),
	  	m_userData2(0)
		{
		}
	
	public:
		DWORD m_userData1;
        PVOID m_userData2;
	};

private:

    static VOID WINAPI ConnectionSucceeded(EXOVERLAPPED* pov);
    static VOID WINAPI ConnectionFailed(EXOVERLAPPED* pov);
    static VOID WINAPI GetPacketForConnectingSucceeded(EXOVERLAPPED* pov);
    static VOID WINAPI GetPacketForConnectingFailed(EXOVERLAPPED* pov);


    static VOID WINAPI SendSucceeded(EXOVERLAPPED* pov);
    static VOID WINAPI SendFailed(EXOVERLAPPED* pov);
    static VOID WINAPI GetPacketForSendingSucceeded(EXOVERLAPPED* pov);
    static VOID WINAPI GetPacketForSendingFailed(EXOVERLAPPED* pov);

    static VOID WINAPI TimeToRetryConnection(CTimer* pTimer);
    static VOID WINAPI TimeToCleanup(CTimer* pTimer);

private:
	static DWORD SendSize(const HttpRequestBuffers&  sendBufs);


private:
    //
    // Get packet for sending
    //
    VOID GetNextEntry(VOID);
    VOID RequeuePacket(VOID);
    
    //
    // Create connection
    //
    VOID ConnectionSucceeded(VOID);
    VOID Connect(VOID);
	void InitPerfmonCounters(LPCWSTR strMulticastId);

    VOID ScheduleRetry(VOID)
    {
        ASSERT(!m_retryTimer.InUse());

        AddRef();
        ExSetTimer(&m_retryTimer, m_retryTimeout);
    }

    //
    // Send packet
    //
    VOID SendSucceeded(DWORD cbSendSize, CQmPacket * pEntry);
    VOID DeliverPacket(CQmPacket* pPacket);
    CQmPacket* KeepProceesingPacket(VOID);


    //
    // Shut-Down
    //
    VOID Shutdown(VOID) throw();

    //
    // Cleanup
    //
    VOID StartCleanupTimer(VOID);
    bool TryToCancelCleanupTimer(VOID);
    VOID SendFailed(DWORD cbSendSize, CQmPacket * pEntry);

    VOID MarkTransportAsUsed(VOID)
    {
        m_fUsed = true;
    }

private:

    mutable CReadWriteLock m_pendingShutdown;

    R<IConnection> m_pConnection;
    R<IMessagePool> m_pMessageSource;

    CRequestOv m_RequestEntry;
    COverlapped m_ov;
    
    CTimer m_retryTimer;
    CTimeDuration m_retryTimeout;

    bool m_fUsed;
    CTimer m_cleanupTimer;
    CTimeDuration m_cleanupTimeout;
	P<ISocketTransport> m_SocketTransport; 
	R<CSrmpRequestBuffers> m_SrmpRequestBuffers;
	R<ISessionPerfmon> m_pPerfmon;
}; 


#endif // __MmtObj_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mmt\lib\mmtdebug.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:

    MmtDebug.cpp

Abstract:

    Multicast Message Transport debugging

Author:

    Shai Kariv  (shaik)  27-Aug-00

Environment:

    Platform-independent, _DEBUG only

--*/

#include <libpch.h>
#include "Mmt.h"
#include "Mmtp.h"

#include "mmtdebug.tmh"

#ifdef _DEBUG


//---------------------------------------------------------
//
// Validate Message Transport state
//
VOID MmtpAssertValid(VOID)
{
    //
    // MmtInitalize() has *not* been called. You should initialize the
    // Multicast Message Transport library before using any of its funcionality.
    //
    ASSERT(MmtpIsInitialized());
}


//---------------------------------------------------------
//
// Initialization Control
//
static LONG s_fInitialized = FALSE;

VOID MmtpSetInitialized(VOID)
{
    LONG fAlreadyInitialized = InterlockedExchange(&s_fInitialized, TRUE);

    //
    // The Multicast Message Transport library has *already* been initialized. You should
    // not initialize it more than once. This assertion would be violated
    // if two or more threads initalize it concurently.
    //
    ASSERT(!fAlreadyInitialized);
}


BOOL MmtpIsInitialized(VOID)
{
    return s_fInitialized;
}


//---------------------------------------------------------
//
// Tracing and Debug registration
//
const TraceIdEntry xTraceTable[] = {

    Mmt,

    //
    // Add Multicast Message Transport sub-component trace ID's to be used with TrXXXX.
    // For example, MmtInit, as used in:
    // TrERROR(MmtInit, "Error description", parameters)
    //
};


VOID MmtpRegisterComponent(VOID)
{
    TrRegisterComponent(xTraceTable, TABLE_SIZE(xTraceTable));
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mmt\lib\mmtsend.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:

    MmtSend.cpp

Abstract:

    Multicast Message Transport class - Send implementation

Author:

    Shai Kariv  (shaik)  27-Aug-00

Environment:

    Platform-independent

--*/

#include <libpch.h>
#include <mqsymbls.h>
#include <mqwin64a.h>
#include <mqformat.h>
#include "Mmt.h"
#include "Mmtp.h"
#include "MmtObj.h"

#include "mmtsend.tmh"

using namespace std;

VOID 
WINAPI 
CMessageMulticastTransport::GetPacketForSendingSucceeded(
    EXOVERLAPPED* pov
    )
{
    ASSERT(SUCCEEDED(pov->GetStatus()));

	CRequestOv* pRequest = static_cast<CRequestOv*>(pov);
    R<CMessageMulticastTransport> pMmt = CONTAINING_RECORD(pRequest, CMessageMulticastTransport, m_RequestEntry);
      
    TrTRACE(Mmt, "Got a message to multicast. pMmt = 0x%p", pMmt.get());

    try
    {
        CQmPacket* pPkt = pMmt->KeepProceesingPacket();
        pMmt->DeliverPacket(pPkt);

    }
    catch(const exception&)
    {
		TrERROR(Mmt, "Failed to deliver multicast message, shutting down. pMmt=0x%p", pMmt.get());
		pMmt->SendFailed(pMmt->m_ov.m_userData1, static_cast<CQmPacket*>(pMmt->m_ov.m_userData2));
        pMmt->Shutdown();
        throw;
    }
} // CMessageMulticastTransport::GetPacketForSendingSucceeded


VOID 
WINAPI 
CMessageMulticastTransport::GetPacketForSendingFailed(
    EXOVERLAPPED* pov
    )
/*++

Routine Description:

    The routine is called when getting entry request from a queue failed.
  
Arguments:

    pov - Pointer to overlapped.
  
Returned Value:

    None.

--*/
{
    ASSERT(FAILED(pov->GetStatus()));

	CRequestOv* pRequest = static_cast<CRequestOv*>(pov);
    R<CMessageMulticastTransport> pMmt = CONTAINING_RECORD(pRequest, CMessageMulticastTransport, m_RequestEntry);

    WCHAR buffer[MAX_PATH];
    MQpMulticastIdToString(pMmt->MulticastId(), buffer);
    TrERROR(Mmt, "Failed to get a new entry from queue %ls. Shutting down. pMmt = 0x%p", buffer, pMmt.get());

    pMmt->Shutdown();

} // CMessageMulticastTransport::GetPacketForSendingFailed


VOID 
CMessageMulticastTransport::SendFailed(
    DWORD /*cbSendSize*/,
    CQmPacket * pEntry
    )
/*++

Routine Description:

    The routine is called when send a message failed
  
Arguments:

    cbSendSize - Size in bytes of the sent packet
     
    pEntry     - Pointer to the sent packet
  
Returned Value:

    None.

--*/
{
	m_SrmpRequestBuffers.free();
   
    //
    // Packet is already deleted from disk. Free it from memory.
    //
    CACPacketPtrs& acPtrs = m_RequestEntry.GetAcPacketPtrs();

    ASSERT(acPtrs.pDriverPacket != NULL);
    ASSERT(acPtrs.pPacket != NULL);
    ASSERT(pEntry->GetPointerToPacket() == acPtrs.pPacket);
    ASSERT(pEntry->GetPointerToDriverPacket() == acPtrs.pDriverPacket);

    m_pMessageSource->EndProcessing(pEntry);
    delete pEntry;

    acPtrs.pPacket = NULL;
    acPtrs.pDriverPacket = NULL;

} // CMessageMulticastTransport::SendFailed

    
VOID 
WINAPI 
CMessageMulticastTransport::SendFailed(
    EXOVERLAPPED* pov
    )
/*++

Routine Description:

    The routine is called when send a message failed
  
Arguments:

    pov - Pointer to EXOVERLAPPED
    
Returned Value:

    None.

--*/
{
    HRESULT status = pov->GetStatus();
    ASSERT(FAILED(status));

	CRequestOv* pRequest = static_cast<CRequestOv*>(pov);
    R<CMessageMulticastTransport> pMmt = CONTAINING_RECORD(pRequest, CMessageMulticastTransport, m_ov);

    WCHAR buffer[MAX_PATH];
    MQpMulticastIdToString(pMmt->MulticastId(), buffer);
    TrERROR(Mmt, "Failed to send message to '%ls', status=0x%x, shutting down. pMmt=0x%p", buffer, status, pMmt.get());
    pMmt->SendFailed(pMmt->m_ov.m_userData1, static_cast<CQmPacket*>(pMmt->m_ov.m_userData2));
    pMmt->Shutdown();

} // CMessageMulticastTransport::SendFailed


VOID 
CMessageMulticastTransport::SendSucceeded(
    DWORD cbSendSize,
    CQmPacket * pEntry
    )
/*++

Routine Description:

    The routine is called when send a message succeeded
  
Arguments:

    cbSendSize - Size in bytes of the sent packet
     
    pEntry     - Pointer to the sent packet
  
Returned Value:

    None.

--*/
{
	
    WCHAR buffer[MAX_PATH];
    MQpMulticastIdToString(MulticastId(), buffer);
    TrTRACE(
		Mmt, 
		"Send message to '%ls' succeeded. pMmt=0x%p", 
		buffer,
		this
		);

	m_SrmpRequestBuffers.free();

   
    //
    // Packet is already deleted from disk. Free it from memory.
    //
    CACPacketPtrs& acPtrs = m_RequestEntry.GetAcPacketPtrs();

    ASSERT(acPtrs.pDriverPacket != NULL);
    ASSERT(acPtrs.pPacket != NULL);
    ASSERT(pEntry->GetPointerToPacket() == acPtrs.pPacket);
    ASSERT(pEntry->GetPointerToDriverPacket() == acPtrs.pDriverPacket);

    m_pMessageSource->EndProcessing(pEntry);
    delete pEntry;

    acPtrs.pPacket = NULL;
    acPtrs.pDriverPacket = NULL;

    MarkTransportAsUsed();

	//
	// Update performance counters
	//
	m_pPerfmon->UpdateBytesSent(cbSendSize);
	m_pPerfmon->UpdateMessagesSent();

    GetNextEntry();

} // CMessageMulticastTransport::SendSucceeded


VOID 
WINAPI 
CMessageMulticastTransport::SendSucceeded(
    EXOVERLAPPED* pov
    )
{
    ASSERT(SUCCEEDED(pov->GetStatus()));

    R<CMessageMulticastTransport> pMmt = CONTAINING_RECORD(pov, CMessageMulticastTransport, m_ov);
    
    //
    // Send has completed successfully, go and request the next message for delivery.
    // If the request failes, the cleanup timer will eventually shutdown this
    // transport, so no explict shutdown is nesscessary.
    //
    pMmt->SendSucceeded(pMmt->m_ov.m_userData1, static_cast<CQmPacket*>(pMmt->m_ov.m_userData2));

} // CMessageMulticastTransport::SendSucceeded


CQmPacket* 
CMessageMulticastTransport::KeepProceesingPacket(
    VOID
    )
{
    //
    // Get the entry from the send overlapped. 
    //
    CACPacketPtrs& acPkts = m_RequestEntry.GetAcPacketPtrs();
    CQmPacket* pEntry;

    try
    {
        pEntry = new CQmPacket(acPkts.pPacket, acPkts.pDriverPacket);
    }
    catch(const exception&)
    {
        RequeuePacket();
        throw;
    }

    return pEntry;

} 


DWORD CMessageMulticastTransport::SendSize(const HttpRequestBuffers&  sendBufs)
{
	DWORD cbSize = 0;

	for(HttpRequestBuffers::const_iterator it = sendBufs.begin(); it != sendBufs.end(); ++it)
	{
		cbSize += it->len;
	}

	return cbSize;
}


VOID 
CMessageMulticastTransport::DeliverPacket(
    CQmPacket* pEntry
    )
/*++

Routine Description:

    The routine delivers an entry to the destination. The delivery is asynchornous.
    On completion a call back routine is called.
  
Arguments:

    pEntry - Points to a queue entry (i.e. msmq packet).
  
Returned Value:

    None.

--*/
{
    //
    // Mark the transport as used
    //
    MarkTransportAsUsed();

	WCHAR buf[MAX_PATH];
    MQpMulticastIdToString(MulticastId(), buf);

    try
    {
	    m_SrmpRequestBuffers = MpSerialize(*pEntry, buf, buf);
	    ASSERT(m_SrmpRequestBuffers->GetNumberOfBuffers() != 0);
    }   
    catch (const exception&)
    {
        RequeuePacket();
        throw;
    }

    //
    // Increment object refernce count, to insure that the object will
    // not be destroyed before asynchronous send operation is completed
    //
    R<CMessageMulticastTransport> ar = SafeAddRef(this);

    //
    // Protect m_socket from shutdown
    //
    CSR readLock(m_pendingShutdown);

    //
    // Delete the packet from disk. Keep it in memory until send is complete.
    //                  
    m_pMessageSource->LockMemoryAndDeleteStorage(pEntry);
	ASSERT(m_SrmpRequestBuffers->GetNumberOfBuffers() != 0);

	m_ov.m_userData1 = numeric_cast<DWORD>(m_SrmpRequestBuffers->GetSendDataLength());
    m_ov.m_userData2 = pEntry;

    m_pConnection->Send(
						m_SrmpRequestBuffers->GetSendBuffers(), 
						numeric_cast<DWORD>(m_SrmpRequestBuffers->GetNumberOfBuffers()), 
						&m_ov
						);

    ar.detach();

    TrTRACE(Mmt, "Send message to '%ls'. pMmt=0x%p", buf, this);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mmt\test\group.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:

    group.cpp

Abstract:

    group stub for Mmt test

Author:

    Shai Kariv  (shaik)  27-Aug-00

Environment:

    Platform-independent,

--*/

#include <libpch.h>
#include <mqwin64a.h>
#include <qformat.h>
#include "Ex.h"
#include "MmtTestp.h"
#include "group.h" 
#include "phbase.h"
#include "phuser.h"
#include "phprop.h"

#include "group.tmh"

MULTICAST_ID s_MulticastId = {inet_addr("231.7.8.9"), 1801};
const QUEUE_FORMAT destQueue(s_MulticastId);
const GUID sourceQm = { 0 };
const GUID destQm = { 0 };

static ULONG s_msgId = 0;

//---------------------------------------------------------
//
//  class CACPacketPtrs
//
//---------------------------------------------------------
class CACPacketPtrs {
public:
   CBaseHeader * pPacket;
   CPacket *  pDriverPacket;
};



ULONG CGroup::CalcPacketSize(void)
{
    ULONG ulPacketSize;

    ulPacketSize  = CBaseHeader::CalcSectionSize();

    ulPacketSize += CUserHeader::CalcSectionSize(&sourceQm, &destQm, NULL, &destQueue, NULL, NULL);

    ulPacketSize += CPropertyHeader::CalcSectionSize(0, 0, 0);

    // what about CMqfHeader size (for destination format name)?

    return ulPacketSize;
}


char* CGroup::CreatePacket(void)
{
    ULONG ulPacketSize = CalcPacketSize();

    char* pPacket = new char[ulPacketSize];
    char* pSection = pPacket;

    // Initialize the EXOVERLAPPED with send callback routines
    //
    #pragma PUSH_NEW
    #undef new

        CBaseHeader* pBase = new(pSection) CBaseHeader(ulPacketSize);
        pSection = pBase->GetNextSection();

        CUserHeader* pUser = new(pSection) CUserHeader(
                                                &sourceQm, 
                                                &destQm,
                                                &destQueue,
                                                NULL,
                                                NULL,
                                                ++s_msgId
                                                );
        pSection = pUser->GetNextSection();

        new(pSection) CPropertyHeader();

    #pragma POP_NEW

    return pPacket;
}


void WINAPI CGroup::TimeToReturnPacket(CTimer* pTimer)
{
    R<CGroup> pGroup = CONTAINING_RECORD(pTimer, CGroup, m_getSleep);
    pGroup->TimeToReturnPacket();
}

void CGroup::TimeToReturnPacket(void)
{
    CS lock(m_cs);

    ASSERT(m_fGetScheduled);
    if(! m_request.empty())
    {
        CGroup::CRequest& request = m_request.front();
    
        EXOVERLAPPED* pov = request.m_pov;
        CACPacketPtrs* pAcPackts = request.m_pAcPackts;

        m_request.pop_front();

    
        char* pPkt = CreatePacket();

        pAcPackts->pPacket = reinterpret_cast<CBaseHeader*>(pPkt);
        pAcPackts->pDriverPacket = reinterpret_cast<CPacket*>(pPkt);

    
        pov->SetStatus(STATUS_SUCCESS);
        ExPostRequest(pov);
    }

    if (m_request.empty())
    {
        m_fGetScheduled = false;
        return;
    }

    R<CGroup> ref = SafeAddRef(this);
    CTimeDuration sleepInterval(rand()/1000);
    ExSetTimer(&m_getSleep, sleepInterval);
    ref.detach();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mmt\test\mmttestp.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:

    MmtTestp.h

Abstract:

    Multicast Message Transport test, private header.

Author:

    Shai Kariv  (shaik)  27-Aug-00

--*/

#pragma once

const TraceIdEntry MmtTest = L"Multicast Message Transport Test";

bool IsFailed(void);
void UpdateNoOfsentMessages(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mmt\lib\mmtserialize.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:

    MmtSerialize.cpp

Abstract:

    Multicast Message Transport class - Message serialization

Author:

    Shai Kariv  (shaik)  27-Aug-00

Environment:

    Platform-independent

--*/

#include <libpch.h>
#include <mqsymbls.h>
#include <mqwin64a.h>
#include <mqformat.h>
#include <Mmt.h>
#include <Mp.h>
#include <Mc.h>
#include <fntoken.h>
#include <bufutl.h>
#include <utf8.h>
#include "Mmtp.h"
#include "MmtObj.h"
#include "mqwin64a.h"

#include "mmtserialize.tmh"

using namespace std;

#define GUID_STR_FORMAT "%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x"

static
DWORD
GenerateEnvelopeAttachmentHeader(
	CResizeBuffer<char>* ResizeBuffer,
    DWORD dataSize,
    DWORD boundaryId
    )
{
    size_t n = UtlSprintfAppend(
				ResizeBuffer,
                BOUNDARY_LEADING_HYPHEN BOUNDARY_VALUE "\r\n"
             	"Content-Type: %s; charset=UTF-8\r\n"
                "Content-Length: %d\r\n"
                "\r\n",
                boundaryId,
                xEnvelopeContentType,
                dataSize
                );

    return numeric_cast<DWORD>(n);
}

static
DWORD
GenerateMultipartAttachmentHeader(
	CResizeBuffer<char>* ResizeBuffer,
    DWORD dataSize,
    const xstr_t& contentId,
    DWORD boundaryId
    )
{
    const GUID* pGuid = &McGetMachineID();
    size_t n = UtlSprintfAppend(
				ResizeBuffer,
                BOUNDARY_LEADING_HYPHEN BOUNDARY_VALUE "\r\n"
                "Content-Type: %s\r\n"
                "Content-Length: %d\r\n"
                "Content-Id: %.*s" GUID_STR_FORMAT "\r\n"
                "\r\n",
                boundaryId,
                xApplicationContentType,
                dataSize,
                contentId.Length(), contentId.Buffer(),
                GUID_ELEMENTS(pGuid)
                );

    return numeric_cast<DWORD>(n);
}



static 
void 
SetBufferPointers(
			HttpRequestBuffers* pRequestBuffers,
			const CResizeBuffer<char>& ResizeBuffer
			)
/*++

Routine Description:
    Set pointers in the sends buffers to the data.
	Only buffers that  has NULL data pointer needs to be set.
  
Arguments:
\    pRequestBuffers - array of buffers to send.
     ResizeBuffer - buffer with the data to send.
  
Returned Value:
   None

--*/
{
	ASSERT(pRequestBuffers->size() != 0);

	size_t pos = 0;
	for(DWORD i = 1; i<pRequestBuffers->size(); ++i)
	{
		ASSERT(pos <= ResizeBuffer.size());
		if((*pRequestBuffers)[i].buf == NULL)
		{
			(*pRequestBuffers)[i].buf =	const_cast<char*>(ResizeBuffer.begin() + pos);
			pos += (*pRequestBuffers)[i].len;
		}
	}
	ASSERT((*pRequestBuffers)[0].buf == NULL);
	(*pRequestBuffers)[0].buf = const_cast<char*>(ResizeBuffer.begin() + pos);
	pos += (*pRequestBuffers)[0].len;
	ASSERT(pos == ResizeBuffer.size());
}

void 
CMessageMulticastTransport::CreateMultipartHeaders(
    const CAttachmentsArray& attachments,
    HttpRequestBuffers* pRequestBuffers
    )
{
    DWORD boundaryId = rand();
	ASSERT(pRequestBuffers->size() == 0);

    DWORD totalSize = 0;
    DWORD envLen = numeric_cast<DWORD>(m_envelope.size());


	//
	// http header - is the first buffer to send. set with null values - we don't know yet it's size
	//
	WSABUF buffer;
	buffer.buf = NULL;
	buffer.len =  0;
	pRequestBuffers->push_back(buffer);


	//
	// On each data item we format into m_HttpRequestHeader we need to set NULL
	// in the coresponding sends buffer (wsabuf[bufIndex].buf) . This because the 
	// pointer to data is not known untill ends of formatting (because of possible memory realocation).
	// The NULL indicates that we should set this pointer to the real data
	// by the function 	SetBufferPointers , called at the end of formatting.
	//


    DWORD headerSize = GenerateEnvelopeAttachmentHeader(
							&m_HttpRequestHeader,
                            envLen,
                            boundaryId
                            );

	//
	// envelop header
	//
	buffer.buf = NULL;
	buffer.len =  headerSize;
	totalSize += buffer.len;
	pRequestBuffers->push_back(buffer);

   
	//
	// Envelop body
	//
    buffer.buf = (LPSTR)m_envelope.c_str();
    buffer.len = envLen;
    totalSize += buffer.len;
	pRequestBuffers->push_back(buffer);


	//
	// Attachments
	//
    for (DWORD i = 0; i < attachments.size(); ++i)
    {
        if (attachments[i].m_id.Length() == 0)
            break;

        headerSize = GenerateMultipartAttachmentHeader(
								&m_HttpRequestHeader,
                                attachments[i].m_data.Length(),
                                attachments[i].m_id,
                                boundaryId
                                );
		//
		// Attachment headers
		//
        buffer.buf = NULL;
        buffer.len = headerSize;
        totalSize +=  buffer.len;
		pRequestBuffers->push_back(buffer);
      

		//
		// Attachement  body
		//
        buffer.buf = (LPSTR)(attachments[i].m_data.Buffer());
        buffer.len = attachments[i].m_data.Length();
        totalSize +=  buffer.len;
		pRequestBuffers->push_back(buffer);
    
    }

    //
    // Add boundry seperator in the end of the request
    //
    size_t n = UtlSprintfAppend(
							&m_HttpRequestHeader,
							BOUNDARY_LEADING_HYPHEN BOUNDARY_VALUE "\r\n", 
							boundaryId
							);


    buffer.buf = NULL;
    buffer.len = numeric_cast<DWORD>(n);
    totalSize += buffer.len;
    pRequestBuffers->push_back(buffer);


    //
    // Create HTTP header
    //
	WCHAR mcbuf[MAX_PATH];
    MQpMulticastIdToString(MulticastId(), mcbuf);


    headerSize = numeric_cast<DWORD>(
						UtlSprintfAppend(
						&m_HttpRequestHeader,
                        "POST %ls HTTP/1.1\r\n"
                        "Host: %ls\r\n"
                        "Content-Type: %s; boundary=\"" BOUNDARY_VALUE "\"\r\n"
                        "Content-Length: %d\r\n"
                        "\r\n",
                        mcbuf,
                        mcbuf,
                        xMultipartContentType,
                        boundaryId,
                        totalSize
                        ));

    //
	// Fix the size of the http header
	//
    (*pRequestBuffers)[0].len = headerSize;

   	//
	//Now we need to fix set the send buffers to the formatted data.
	//Only at the end of the formatting we can do so - because the formatted buffers
	//can be realocated so pointer  are invalid untill the formating ends. 
	//
	SetBufferPointers(pRequestBuffers, m_HttpRequestHeader);

   	m_HttpRequestHeader.resize(0);
}


void
CMessageMulticastTransport::CreateSimpleHttpHeader(
    HttpRequestBuffers* pRequestBuffers
    )
{
	ASSERT(pRequestBuffers->size() == 0);
	DWORD envLen = numeric_cast<DWORD>(m_envelope.size());

    WCHAR mcbuf[MAX_PATH];
    MQpMulticastIdToString(MulticastId(), mcbuf);

    DWORD headerSize = numeric_cast<DWORD>(
							UtlSprintfAppend(
							&m_HttpRequestHeader,
                            "POST %ls HTTP/1.1\r\n"	 
                            "Host: %ls\r\n"
                            "Content-Type: %s\r\n"
                            "Content-Length: %d\r\n"
                            "\r\n",
                            mcbuf,
                            mcbuf,
                            xEnvelopeContentType,
                            envLen
                            ));
    
	WSABUF  buffer;
	buffer.buf = NULL;
	buffer.len = headerSize;
	pRequestBuffers->push_back(buffer);


	buffer.buf =  (LPSTR)m_envelope.c_str();
	buffer.len =  envLen;
	pRequestBuffers->push_back(buffer);

	SetBufferPointers(pRequestBuffers, m_HttpRequestHeader);

	m_HttpRequestHeader.resize(0);
}


void
CMessageMulticastTransport::CreateHttpRequestHeaders(
    const CAttachmentsArray& attachments,
    HttpRequestBuffers* pRequestBuffers
    )
{
    if (attachments.size() != 0)
    {
        //
        // Message refering to external payload. Create MIME header
        //
        CreateMultipartHeaders(attachments, pRequestBuffers);
		return;
    }

    //
    // Simple message, that doesn't contains external reference
    //
    CreateSimpleHttpHeader(pRequestBuffers);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mmt\test\group.h ===
#include "msi.h"

#include "mqwin64a.h"
#include "qmpkt.h"

class CGroup: public IMessagePool
{
private:
    class CRequest
    {
    public:
        CRequest(EXOVERLAPPED* pov, CACPacketPtrs& acPacketPtrs) :
            m_pov(pov),
            m_pAcPackts(&acPacketPtrs)
            {
            }
    public:
        EXOVERLAPPED* m_pov;
        CACPacketPtrs* m_pAcPackts;
    };

public:
    CGroup() :
        m_getSleep(TimeToReturnPacket),
        m_fGetScheduled(false)
    {
    }

    virtual ~CGroup()
    {
        ExCancelTimer(&m_getSleep);
    }

    void Requeue(CQmPacket* p)
    {
        delete [] reinterpret_cast<char*>(p->GetPointerToDriverPacket());
    }
    

    void EndProcessing(CQmPacket* p)
    {
        delete [] reinterpret_cast<char*>(p->GetPointerToDriverPacket());

        UpdateNoOfsentMessages();
    }


    void LockMemoryAndDeleteStorage(CQmPacket*)
    {
        NULL;
    }


    void GetFirstEntry(EXOVERLAPPED* pov, CACPacketPtrs& acPacketPtrs)
    {
        CS lock(m_cs);

        m_request.push_back(CRequest(pov, acPacketPtrs));
        if (!m_fGetScheduled)
        {
            SafeAddRef(this);

            CTimeDuration sleepInterval(rand()/1000);
            ExSetTimer(&m_getSleep, sleepInterval);
            m_fGetScheduled = true;
        }
    }

    void CancelRequest(void)
    {
        CS lock(m_cs);

        for(std::list<CRequest>::iterator it = m_request.begin(); it != m_request.end(); )
        {
            EXOVERLAPPED* pov = (*it).m_pov;
            pov->SetStatus(STATUS_CANCELLED);
            ExPostRequest(pov);
            
            it = m_request.erase(it);
        }
    }

private:
    static void WINAPI TimeToReturnPacket(CTimer* pTimer);
    
    static ULONG CalcPacketSize(void);
    static char* CreatePacket();

private:
    void TimeToReturnPacket();

private:
    CCriticalSection    m_cs;                   // Critical section

    std::list<CRequest> m_request;

    bool m_fGetScheduled;
    CTimer m_getSleep;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mmt\test\no.cpp ===
#include <libpch.h>
#include "No.h"
#include "Ex.h"
#include "MmtTestp.h"

#include "no.tmh"

using namespace std;

const char xShortOkResponse[] =		"HTTP/1.1 200 OK\r\n"
									"Content-Length: 0\r\n"
									"\r\n"
									;

const char xShortFailResponse[] =	"HTTP/1.1 500 Internal Server Error\r\n"
									"Connection: close\r\n"
									"Content-Length: 0\r\n"
									"\r\n"
									;

const char xLongOkResponse[] =		"HTTP/1.1 200 OK\r\n"
									"Header1: 0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi\r\n"
									"Header2: 0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi\r\n"
									"Content-Length: 400\r\n"
									"Header3: 0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi\r\n"
									"Header4: 0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi\r\n"
									"Header5: 0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi\r\n"
									"\r\n"
									"0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi"
									"0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi"
									"0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi"
									"0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi"
									;

const char xLongFailResponse[] =	"HTTP/1.1 500 Internal Server Error\r\n"
									"Connection: close\r\n"
									"Header1: 0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi\r\n"
									"Header2: 0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi\r\n"
									"Content-Length: 400\r\n"
									"Header3: 0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi\r\n"
									"Header4: 0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi\r\n"
									"Header5: 0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi\r\n"
									"\r\n"
									"0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi"
									"0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi"
									"0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi"
									"0abcdefghi1abcdefghi2abcdefghi3abcdefghi4abcdefghi5abcdefghi6abcdefghi7abcdefghi8abcdefghi9abcdefghi"
									;

const char xOkResponseNoContentLength[] =
                            		"HTTP/1.1 200 OK\r\n"
									"\r\n"
                                    ;

const char xInformativeResponseNoContentLength[] =
                            		"HTTP/1.1 100 Continue\r\n"
									"\r\n"
									;

const char xFailResponseNoContentLength[] =
                            		"HTTP/1.1 500 Internal Server Error\r\n"
									"\r\n"
									;

const LPCSTR xResponses[] = {
	xShortOkResponse,
	xShortFailResponse,
	xLongOkResponse,
	xLongFailResponse,
    xOkResponseNoContentLength,
    xInformativeResponseNoContentLength,
    xFailResponseNoContentLength,
  
  };

struct SockInfo
{
    SockInfo(void) : 
        pBuffer(NULL),
        nBytesToRead(0),
        ByteReads(0),
        pov(NULL)
    {
    }

    CCriticalSection m_csResponse;
    list<LPCSTR> response;
    DWORD ByteReads;

    VOID* pBuffer;                                     
    DWORD nBytesToRead; 
    EXOVERLAPPED* pov;
};

typedef map<SOCKET, SockInfo*> SOCKET2INFO;
SOCKET2INFO s_mapSockInfo;


//
VOID
NoInitialize(
    VOID
    )
{
    WSADATA wsd;
    if (WSAStartup(MAKEWORD(2,2), &wsd) != 0)
    {
        TrERROR(MmtTest, "WSAStartup failed!");
        throw exception();
    }
}


static SOCKET s_socket = 0;

SOCKET 
NoCreatePgmConnection(
    VOID
    )
{
    if (IsFailed())
    {
        throw exception();
    }

    s_mapSockInfo[++s_socket] = new SockInfo;

    TrTRACE(MmtTest, "Create Socket 0x%I64x", s_socket);

    return s_socket;
}


VOID 
NoConnect(
    SOCKET Socket,
    const SOCKADDR_IN&,
    EXOVERLAPPED* pov
    )
{
    SOCKET2INFO::iterator it = s_mapSockInfo.find(Socket);

    if (it == s_mapSockInfo.end() || IsFailed())
    {
        if ((rand() %2) == 0)
            throw exception();

        pov->SetStatus(STATUS_UNSUCCESSFUL);
        ExPostRequest(pov);
        return;
    }

    pov->SetStatus(STATUS_SUCCESS);
    ExPostRequest(pov);
}


VOID
NoCloseConnection(
    SOCKET Socket
    )
{
    SOCKET2INFO::iterator it = s_mapSockInfo.find(Socket);

    TrTRACE(MmtTest, "Close Socket 0x%I64x", Socket);

    if (it != s_mapSockInfo.end())
    {
        SockInfo* p = it->second;
        
        if (p->pov != NULL)
        {
            EXOVERLAPPED* pov = p->pov;

            p->pBuffer = NULL;
            p->pov = NULL;
            p->nBytesToRead = 0;

            pov->SetStatus(STATUS_UNSUCCESSFUL);
            ExPostRequest(pov);
        }

        s_mapSockInfo.erase(it);
        delete p;
    }
}


VOID
NoSend(
    SOCKET Socket,                                              
    const WSABUF*,
    DWORD, 
    EXOVERLAPPED* pov
    )
{ 
    SOCKET2INFO::iterator it = s_mapSockInfo.find(Socket);

    if (it == s_mapSockInfo.end() || IsFailed())
    {
        if ((rand() %2) == 0)
            throw exception();

        pov->SetStatus(STATUS_UNSUCCESSFUL);
        ExPostRequest(pov);
        return;
    }


    SockInfo* p = it->second;               
    {
        CS lock(p->m_csResponse);
        p->response.push_back(xResponses[rand() % TABLE_SIZE(xResponses)]);
    }

    pov->SetStatus(STATUS_SUCCESS);
    ExPostRequest(pov);

    if (p->pov != NULL)
    {
        //
        // pending reponse receive
        //
        EXOVERLAPPED* pov = p->pov;
        PVOID pBuffer = p->pBuffer;
        DWORD nBytesToRead = p->nBytesToRead;
        p->pBuffer = NULL;
        p->pov = NULL;
        p->nBytesToRead = 0;

        NoReceivePartialBuffer(Socket, pBuffer, nBytesToRead, pov);
    }
}




VOID
NoReceivePartialBuffer(
    SOCKET Socket,                                              
    VOID* pBuffer,                                     
    DWORD nBytesToRead, 
    EXOVERLAPPED* pov
    )
{
    TrTRACE(MmtTest, "NoReceivePartialBuffer: Socket=0x%I64x Buffer=0x%p BytesToRead=%d ov=0x%p", Socket, pBuffer, nBytesToRead, pov);
    SOCKET2INFO::iterator it = s_mapSockInfo.find(Socket);

    if (it == s_mapSockInfo.end() || IsFailed())
    {
        pov->InternalHigh = 0;

        if (rand()%4 == 0)
            throw exception();

        if (rand()%4 == 1)
        {
            pov->SetStatus(STATUS_SUCCESS);
        }
        else
        {
            pov->SetStatus(STATUS_UNSUCCESSFUL);
        }

        ExPostRequest(pov);
        
        return;
    }

    SockInfo* p = it->second;               

    {
        CS lock(p->m_csResponse);
        if (p->response.empty())
        {
            p->pBuffer = pBuffer;                                   
            p->nBytesToRead = nBytesToRead;
            p->pov = pov;
            return;
        }
    }

    p->pBuffer = NULL;                                   
    p->nBytesToRead = 0;
    p->pov = NULL;

    LPCSTR response;
    {
        CS lock(p->m_csResponse);
        response = p->response.front();
    }

    DWORD length = min(nBytesToRead, (strlen(response) - p->ByteReads));

    memcpy(pBuffer, (response + p->ByteReads), length);
    p->ByteReads += length;

    pov->InternalHigh = length;
    
    bool fReadAllResponse = false;
    if (p->ByteReads == strlen(response))
    {
        CS lock(p->m_csResponse);
        p->response.pop_front();
        p->ByteReads = 0;
        fReadAllResponse = true;
    }
     
    pov->SetStatus(STATUS_SUCCESS);
    ExPostRequest(pov);
}


bool
NoGetHostByName(
	LPCWSTR host,
	std::vector<SOCKADDR_IN>* pAddr,
	bool fUseCache
    )
{
	UNREFERENCED_PARAMETER(host);
	UNREFERENCED_PARAMETER(fUseCache);

	SOCKADDR_IN Addr;

	Addr.sin_family = AF_INET;
    Addr.sin_addr.S_un.S_addr = rand();
	pAddr->push_back(Addr);

	return true;	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mmt\test\mmttest.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:

    MtTest.cpp

Abstract:

    Multicast Message Transport library test

Author:

    Shai Kariv  (shaik)  27-Aug-00

Environment:

    Platform-independent,

--*/

#include <libpch.h>
#include <Ex.h>
#include <Mmt.h>
#include <Mp.h>
#include <No.h>
#include <spi.h>
#include <utf8.h>
#include "MmtTestp.h"
#include "group.h"

#include "MmtTest.tmh"

static const MULTICAST_ID s_id = {inet_addr("231.7.8.9"), 1801};

static DWORD s_FailedRate = 0;
static DWORD s_NoOfMessages = 1000;
static HANDLE s_hEvent;

static R<CMulticastTransport> s_pTrans(NULL);

void UpdateNoOfsentMessages(void)
{
    if (--s_NoOfMessages == 0)
        SetEvent(s_hEvent);
}


bool IsFailed(void)
{
    if (s_FailedRate == 0)
        return FALSE;

    return ((DWORD)(rand() % 100) < s_FailedRate);
}

   
static GUID s_machineId = {1234, 12, 12, 1, 1, 1, 1, 1, 1, 1, 1};

const GUID&
McGetMachineID(
    void
    )
{
    return s_machineId;
}

bool
IsEqualMulticastId(
    MULTICAST_ID id1,
    MULTICAST_ID id2
    )
{
    return (id1.m_address == id2.m_address && id1.m_port == id2.m_port);
}


class CSessionPerfmon : public ISessionPerfmon
{
public:
    CSessionPerfmon() : m_fInstanceCreated(false) 
    {
    }

    ~CSessionPerfmon()
    {
    }
    
	void CreateInstance(LPCWSTR)
	{
		m_fInstanceCreated = true;
	}

	void UpdateBytesSent(DWORD )
	{
		ASSERT(m_fInstanceCreated);
	}

	void UpdateMessagesSent(void)
	{
		ASSERT(m_fInstanceCreated);
	}

	void UpdateBytesReceived(DWORD )
	{
		ASSERT(m_fInstanceCreated);
	}

	void UpdateMessagesReceived(void)
    {
		ASSERT(m_fInstanceCreated);
    }

private:
	bool m_fInstanceCreated;
};


VOID
AppNotifyMulticastTransportClosed(
    MULTICAST_ID id
    )
{
    ASSERT(IsEqualMulticastId(id, s_id));
	DBG_USED(id);

    R<CGroup> pGroup = new CGroup();
	R<CSessionPerfmon> pPerfmon = new CSessionPerfmon;

    bool fFailed;

    do
    {
        fFailed = false;
        try
        {
            s_pTrans = MmtCreateTransport(
                                s_id,
                                pGroup.get(),
								pPerfmon.get(),
                                CTimeDuration(10 * CTimeDuration::OneMilliSecond().Ticks()),
                                CTimeDuration(100 * CTimeDuration::OneMilliSecond().Ticks())
                                );
        }
        catch(const exception&)
        {
            fFailed = true;
        }
    } while(fFailed);
                    
    pGroup.free();
}

R<CSrmpRequestBuffers>
MpSerialize(
    const CQmPacket& pkt,
	LPCWSTR targethost,
	LPCWSTR uri
	)
{
	return new CSrmpRequestBuffers(pkt, targethost, uri);	
}


CSrmpRequestBuffers::CSrmpRequestBuffers(
							const  CQmPacket& pkt,
							LPCWSTR host, 
							LPCWSTR 
							):
							m_pkt(pkt),
							m_HttpRequestData(512),
							m_envelope('a' ,200)
{
	size_t targethostLen;
	AP<utf8_char>  targethost = UtlWcsToUtf8(host, &targethostLen);
	m_targethost.append(targethost, targethostLen);
	m_targethost.append('\0');

	
	WSABUF buffer;
	buffer.buf = (LPSTR)m_envelope.c_str();
    buffer.len = numeric_cast<DWORD>(m_envelope.size());
    m_buffers.push_back(buffer);
}




size_t CSrmpRequestBuffers::GetNumberOfBuffers() const
{
	return m_buffers.size();
}


const WSABUF* CSrmpRequestBuffers::GetSendBuffers() const
{
	return m_buffers.begin();
}

size_t CSrmpRequestBuffers::GetSendDataLength() const
{
	size_t sum = 0;
	for(std::vector<WSABUF>::const_iterator it = m_buffers.begin(); it != m_buffers.end();++it)
	{
		sum += it->len;		
	}
	return sum;
}


BYTE*  CSrmpRequestBuffers::SerializeSendData() const
{
	size_t SendDataLength =  GetSendDataLength();
	AP<BYTE>  SendData = new BYTE[SendDataLength];
	BYTE* ptr = SendData.get(); 
	for(std::vector<WSABUF>::const_iterator it = m_buffers.begin(); it != m_buffers.end();++it)
	{
		memcpy(ptr, it->buf, it->len);
		ptr += it->len;
	}
	ASSERT(numeric_cast<size_t>((ptr -  SendData.get())) == SendDataLength);
	return 	SendData.detach();
}


CQmPacket::CQmPacket(
    CBaseHeader *pPkt, 
    CPacket *pDriverPkt
    ):
    m_pDriverPacket(pDriverPkt)
{
    PCHAR pSection;

    m_pBasicHeader = pPkt;

    pSection = m_pBasicHeader->GetNextSection();
    m_pcUserMsg = (CUserHeader*) pSection;

    ASSERT(m_pcUserMsg->PropertyIsIncluded());

    pSection = m_pcUserMsg->GetNextSection();
    m_pcMsgProperty = (CPropertyHeader*) pSection;

    m_pXactSection = NULL;
    m_pSecuritySection = NULL;
}


void Usage(void)
{
	printf("Usage: MmtTest -n <no of messages> [-f xxx] [-h]\n");
    printf("\tn - Number of messages\n");
	printf("\tf - Fail rate\n");
	printf("\th - Print this message\n");
	exit(-1);
}


extern "C" int __cdecl _tmain(int argc, LPCTSTR argv[])
/*++

Routine Description:

    Test Multicast Message Transport library

Arguments:

    Parameters.

Returned Value:

    None.

--*/
{
    WPP_INIT_TRACING(L"Microsoft\\MSMQ");

	TrInitialize();
	TrRegisterComponent(&MmtTest, 1);

    --argc;
    ++argv;

    s_FailedRate = 0;
    
    while (argc > 0)
	{
		if (argv[0][0] != L'-') 
			Usage();

		switch(argv[0][1])
		{
            case L'n':
            case L'N':
                s_NoOfMessages = _wtoi(argv[1]);
				argc -= 2;
				argv += 2;
                break;

            case L'f':
			case L'F':
		        s_FailedRate = _wtoi(argv[1]);
				argc -= 2;
				argv += 2;
				break;


            default:
				Usage();
		}
    }

    NoInitialize();
    ExInitialize(5);
    MmtInitialize();

    s_hEvent = CreateEvent(NULL, FALSE, FALSE, L"");

    R<CGroup> pGroup = new CGroup();
	R<CSessionPerfmon> pPerfmon = new CSessionPerfmon;

    bool fFailed = false;

    do
    {
        try
        {
            s_pTrans = MmtCreateTransport(
                                    s_id,
                                    pGroup.get(),
									pPerfmon.get(),
                                    CTimeDuration(10 * CTimeDuration::OneMilliSecond().Ticks()),
                                    CTimeDuration(100 * CTimeDuration::OneMilliSecond().Ticks())
                                    );
        }
        catch(const exception&)
        {
            fFailed = true;
        }
    } while(fFailed);
    
    pGroup.free();

    WaitForSingleObject(s_hEvent, INFINITE);

    WPP_CLEANUP();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mmt\test\st.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    st.cpp

Abstract:
    Simulation of St library

Author:
    Gil Shafriri (gilsh) 11-June-2000

--*/

#include <libpch.h>
#include <no.h>
#include <st.h>
#include <xstr.h>
#include <rwlock.h>
#include "st.tmh"

class CPgmWinsockConnection : public IConnection
{
public:
	CPgmWinsockConnection(
		):
			m_socket(NoCreatePgmConnection())
	{
	}			

	void Init(const SOCKADDR_IN& Addr, 	EXOVERLAPPED* pOverlapped)
	{
		NoConnect(m_socket, Addr, pOverlapped); 
	}


	virtual 
	void 
	ReceivePartialBuffer(
					VOID* pBuffer,                                     
					DWORD Size, 
					EXOVERLAPPED* pov
					)
	{
		NoReceivePartialBuffer(m_socket, pBuffer, Size, pov);
	}


 	virtual 
	void 
	Send(
		const WSABUF* Buffers,                                     
		DWORD nBuffers, 
		EXOVERLAPPED* pov
		)
	{
		NoSend(m_socket, Buffers, nBuffers,  pov);
	}


	virtual void Close()
	{
		m_socket.free();
	}


private:
	mutable CReadWriteLock m_CloseConnection;
	CSocketHandle m_socket;
};


class CPgmWinsock :public ISocketTransport
{

public:
	virtual void CreateConnection(
			const SOCKADDR_IN& Addr, 
			EXOVERLAPPED* pOverlapped
			)
	{
		m_pConnection = new  CPgmWinsockConnection();
		m_pConnection->Init(Addr, pOverlapped);
	}


	virtual R<IConnection> GetConnection()
	{
		return m_pConnection; 
	}


	bool IsPipelineSupported(void)
	{
		return true;
	}

	
	virtual
	bool
	GetHostByName(
    LPCWSTR host,
	std::vector<SOCKADDR_IN>* pAddr,
	bool fUseCache = true
    )
	{
		return NoGetHostByName(host, pAddr, fUseCache);		
	}

private:
	R<CPgmWinsockConnection> m_pConnection;
};



ISocketTransport* StCreatePgmWinsockTransport(void)
{
	return new CPgmWinsock();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mp\lib\attachments.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Attachments.h

Abstract:
    Header for classes related to MIME attachments that are part of MSMQ http protocol.


Author:
    Gil Shafriri(gilsh) 22-MAY-01

--*/
#ifndef ATTACHMENTS_H
#define ATTACHMENTS_H

#include <xstr.h>


//-------------------------------------------------------------------
//
// CAttachment 
//
//-------------------------------------------------------------------
class CAttachment
{
public:
    xstr_t m_id;
    xbuf_t<const VOID> m_data;
	DWORD m_offset;
};


//-------------------------------------------------------------------
//
// class CAttachmentsArray - holds attachments on sending side
//
//-------------------------------------------------------------------
typedef  std::vector<CAttachment>  AttachementsVector;
class CAttachmentsArray :private  AttachementsVector
{
public:
	using  AttachementsVector::push_back;
	using  AttachementsVector::size;
	using  AttachementsVector::operator[];
	
public:
	CAttachmentsArray()
	{
		AttachementsVector::reserve(xReservedAttachmentsSize);
	}


public:
	static const DWORD  xReservedAttachmentsSize = 4;
};


class CMessageProperties;

void PacketToAttachments(const CQmPacket& pkt, CAttachmentsArray* pAttachments);
void AttachmentsToProps(const CAttachmentsArray& Attachments, CMessageProperties* pMessageProperties);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mp\lib\envbody.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envbody.cpp

Abstract:
    Implementing  serialization\deserialization of the SRMP envelop body.


Author:
    Gil Shafriri(gilsh) 24-APRIL-01

--*/
#include <libpch.h>
#include <qmpkt.h>
#include "envcommon.h"
#include "envbody.h"

using namespace std;

class BodyContent
{
public:	
	explicit BodyContent(const CQmPacket& pkt):m_pkt(pkt){}
   	friend std::wostream& operator<<(std::wostream& wstr, const BodyContent& Body)
	{
		if(!Body.m_pkt.IsSoapIncluded() )
			return wstr;

		const WCHAR* pSoapBody = Body.m_pkt.GetPointerToSoapBody();
		if(pSoapBody == NULL)
			return wstr;

	
		ASSERT(Body.m_pkt.GetSoapBodyLengthInWCHARs() == wcslen(pSoapBody) +1);
		
		return 	wstr<<pSoapBody;
	}

private:
	const CQmPacket& m_pkt;
};



wostream& operator<<(wostream& wstr, const BodyElement& Body)
{
	wstr<<OpenTag(xSoapBody)
		<<BodyContent(Body.m_pkt)
		<<CloseTag(xSoapBody);

	return 	wstr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mp\lib\attachments.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    attachments.cpp

Abstract:
    Implements  creating attachments array from MSMQ packet


Author:
    Gil Shafriri(gilsh) 14-DEC-00

--*/

#include <libpch.h>
#include <mp.h>
#include <qmpkt.h>
#include <utf8.h>
#include "mpp.h"
#include "attachments.h"
#include "proptopkt.h"

#include "attachments.tmh"

using namespace std;

void PacketToAttachments(const CQmPacket& pkt, CAttachmentsArray* pAttachments)
{
	//
    // Body section
    //
    if (pkt.IsBodyInc())
    { 
        DWORD bodySize;
        const BYTE* pBody = pkt.GetPacketBody(&bodySize);
		CAttachment Attachment;
        Attachment.m_data =   xbuf_t<const VOID>(pBody, bodySize);
		Attachment.m_id =  xstr_t(xMimeBodyId, STRLEN(xMimeBodyId));
		pAttachments->push_back(Attachment);
    }

    //
    // Extension Section
    //
    if (pkt.GetMsgExtensionSize() != 0)
    {
        DWORD extensionSize = pkt.GetMsgExtensionSize();
        const BYTE* pExtension = pkt.GetMsgExtensionPtr();
		CAttachment Attachment;
		Attachment.m_data =   xbuf_t<const VOID>(pExtension, extensionSize);
		Attachment.m_id  = 	  xstr_t(xMimeExtensionId, STRLEN(xMimeExtensionId));
		pAttachments->push_back(Attachment);
    }

    //
    // Sender Certificate
    //
    DWORD certSize;
    const UCHAR* pCert = pkt.GetSenderCert(&certSize);
    if (certSize != 0)
    {
		CAttachment Attachment;
		Attachment.m_data =  xbuf_t<const VOID>(pCert, certSize);
		Attachment.m_id =  xstr_t(xMimeSenderCertificateId, STRLEN(xMimeSenderCertificateId));
		pAttachments->push_back(Attachment);
    }
}


static
xbuf_t<const VOID>
GetCertSid(
    CMessageProperties* mProp
    )
{

	AP<WCHAR> pProvider = mProp->providerName.ToStr();
		
	PSID pSid = AppGetCertSid(
							static_cast<const BYTE*>(mProp->senderCert.Buffer()),
							mProp->senderCert.Length(),
							mProp->fDefaultProvider,
							pProvider,
							mProp->providerType
							);

	mProp->pCleanSenderSid = pSid;

	ASSERT((pSid == NULL) || IsValidSid(pSid));

	if((pSid == NULL) || !IsValidSid(pSid))
	{
		return (xbuf_t<const VOID>(NULL, 0));
	}

	return(xbuf_t<const VOID>(pSid, GetLengthSid(pSid)));
}




void
AttachmentsToProps(
    const CAttachmentsArray& Attachments,
    CMessageProperties* mProp
    )
{
	for(DWORD i = 0; i< Attachments.size(); ++i)
    {
        if (Attachments[i].m_id.Length() == 0)
            continue;

        if ((Attachments[i].m_id.Length() >= STRLEN(xMimeBodyId)) &&
            (_strnicmp(Attachments[i].m_id.Buffer(), xMimeBodyId, STRLEN(xMimeBodyId)) == 0))
        {
            mProp->body = Attachments[i];
            continue;
        }

        if ((Attachments[i].m_id.Length() >= STRLEN(xMimeSenderCertificateId)) &&
            (_strnicmp(Attachments[i].m_id.Buffer(), xMimeSenderCertificateId, STRLEN(xMimeSenderCertificateId)) == 0))
        {
            mProp->senderCert = Attachments[i].m_data;

			//
			// Get senderSid, senderIdType according to the certificate
			//
			mProp->senderSid = GetCertSid(mProp);

			mProp->senderIdType = MQMSG_SENDERID_TYPE_NONE;
			if (mProp->senderSid.Length() != 0)
			{
			    mProp->senderIdType = MQMSG_SENDERID_TYPE_SID;
			}

            continue;
        }

        if ((Attachments[i].m_id.Length() >= STRLEN(xMimeExtensionId)) &&
            (_strnicmp(Attachments[i].m_id.Buffer(), xMimeExtensionId, STRLEN(xMimeExtensionId)) == 0))
        {
            mProp->extension = Attachments[i].m_data;
            continue;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mp\lib\envbody.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envbody.h

Abstract:
    Header for serialization\deserialization of the SRMP envelop body.


Author:
    Gil Shafriri(gilsh) 24-APRIL-01

--*/

#pragma once

#ifndef _MSMQ_envbody_H_
#define _MSMQ_envbody_H_

class CQmPacket;


class BodyElement
{
public:
	explicit BodyElement(const CQmPacket& pkt):m_pkt(pkt){}
   	friend std::wostream& operator<<(std::wostream& wstr, const BodyElement&);

private:
	const CQmPacket& m_pkt;
};







#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mp\lib\deserialize.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    deserialize.cpp

Abstract:
    Converts SRMP format to MSMQ packet

Author:
    Uri Habusha (urih) 25-May-00

Environment:													  
    Platform-independent

--*/

#include <libpch.h>
#include <xml.h>
#include <mp.h>
#include <mqwin64a.h>
#include <acdef.h>
#include <qmpkt.h>
#include "envelop.h"
#include "attachments.h"
#include "httpmime.h"
#include "proptopkt.h"

#include "deserialize.tmh"

using namespace std;

static
void
ParseEnvelop(
	  const xwcs_t& Envelop,
	  CMessageProperties& mProp
    )
{
	mProp.envelop = Envelop;

	CAutoXmlNode pXmlTree;
				 
	XmlParseDocument(Envelop , &pXmlTree);

	EnvelopToProps(*pXmlTree,  &mProp);
}



static
void
AdjustMessagePropertiesForLocalSend(
			const QUEUE_FORMAT* pDestQueue,
			CMessageProperties& messageProperty
			)
{
    ASSERT(pDestQueue != NULL);
    ASSERT(pDestQueue->GetType() == QUEUE_FORMAT_TYPE_PUBLIC  || 
		   pDestQueue->GetType() == QUEUE_FORMAT_TYPE_PRIVATE ||
		   pDestQueue->GetType() == QUEUE_FORMAT_TYPE_DIRECT
		   );

    if (pDestQueue->GetType() == QUEUE_FORMAT_TYPE_PRIVATE)
    {
        messageProperty.destQmId = (pDestQueue->PrivateID()).Lineage;
    }
}


static
void 
AdjustMessagePropertiesForMulticast(
			const QUEUE_FORMAT* pDestQueue,
			CMessageProperties& messageProperty
			)
{
	if (pDestQueue != NULL)
    {
        ASSERT(messageProperty.destQueue.GetType() == QUEUE_FORMAT_TYPE_MULTICAST);
        //
        // Use pDestQueue (provided destination queue) instead of the destination queue on the SRMP 
        // packet. For multicast, the SRMP packet contains the multicast 
        // address as a traget queue therefor while building the QM packet fill in the
        // target queue with the actual queue
        //
        ASSERT(pDestQueue->GetType() == QUEUE_FORMAT_TYPE_PUBLIC || pDestQueue->GetType() == QUEUE_FORMAT_TYPE_PRIVATE);

		messageProperty.destMulticastQueue.CreateFromQueueFormat(messageProperty.destQueue);
		messageProperty.destMqf.CreateFromMqf(&messageProperty.destMulticastQueue, 1);
        messageProperty.destQueue.CreateFromQueueFormat(*pDestQueue);

        //
        // Private queue is stored on the QM packet as a combination of destination QM ID and 
        // queue ID. As a result for private queue, the code retreive the destination QM 
        // from the queue format name.
        //
        if (pDestQueue->GetType() == QUEUE_FORMAT_TYPE_PRIVATE)
        {
            messageProperty.destQmId = (pDestQueue->PrivateID()).Lineage;
        }
    }
}



static
CACPacketPtrs
Deserialize(
    const xwcs_t& envelope,
    const CHttpReceivedBuffer& HttpReceivedBuffer,
    const QUEUE_FORMAT* pDestQueue,
	bool fLocalSend
    )
{
    CMessageProperties messageProperty;

	messageProperty.Rawdata = &HttpReceivedBuffer;


    //
    // Retrieve message properties from ennvelop
    //
    ParseEnvelop(envelope, messageProperty);
	

    //
    // Retrieve message properies from MIME sections
    //
    AttachmentsToProps(HttpReceivedBuffer.GetAttachments(), &messageProperty);


	if(fLocalSend)
	{
		AdjustMessagePropertiesForLocalSend(pDestQueue, messageProperty);
	}
	else
	{
		AdjustMessagePropertiesForMulticast(pDestQueue, messageProperty);
	}

	//
    // Convert the property to packet
    //
    CACPacketPtrs pktPtrs;
	MessagePropToPacket(messageProperty, &pktPtrs);
    
    return pktPtrs;
}



CQmPacket*
MpDeserialize(
    const char* httpHeader,
    DWORD bodySize,
    const BYTE* body,
    const QUEUE_FORMAT* pqf,
	bool fLocalSend
    )
/*++

Routine Description:
    convert SRMP network data to MSMQ packet

Arguments:
	httpHeader - Pointer to http header
	bodySize - Http body size.
	body - http body
	pqf - destination queue if null taken from the SRMP data.
	fLocalSend - spesify if to do special conversion in the created packet for local send.

Returned Value:
	Heap allocated MSMQ packet   

--*/

{
	MppAssertValid();


	basic_xstr_t<BYTE> TheBody(body, bodySize); 
    CHttpReceivedBuffer HttpReceivedBuffer(TheBody, httpHeader);
	
    wstring envelope = ParseHttpMime(
                                httpHeader,
                                bodySize,
                                body,
                                &HttpReceivedBuffer.GetAttachments()
                                );

    //
    // build the QmPacket
    //

	CACPacketPtrs  ACPacketPtrs;
	ACPacketPtrs = Deserialize(
                           xwcs_t(envelope.c_str(), envelope.size()),    
                           HttpReceivedBuffer,
                           pqf,
						   fLocalSend
                           );
  
    try
    {
        return new CQmPacket(ACPacketPtrs.pPacket, ACPacketPtrs.pDriverPacket);
    }
    catch (const std::bad_alloc&)
    {
        AppFreePacket(ACPacketPtrs);
        throw;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mp\lib\envcomreceipt.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envcomreceipt.h

Abstract:
    Header for Serialization and Deserialization of srmp envelop commitment receipt  element.

Author:
    Gil Shafriri(gilsh) 11-DEC-00

--*/

#pragma once

#ifndef _MSMQ_envcomreceipt_H_
#define _MSMQ_envcomreceipt_H_

class CQmPacket;
class XmlNode;
class CMessageProperties;
class CommitmentReceiptElement
{
public:
	explicit CommitmentReceiptElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend std::wostream& operator<<(std::wostream& wstr, const CommitmentReceiptElement& cReceipt);
	
private:
	const CQmPacket& m_pkt;
};

void CommitmentReceiptToProps(XmlNode& Node, CMessageProperties* pMessageProperties);





#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mp\lib\envcommon.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envcommon.h

Abstract:
    Header for common utilities for  serialization\deserialization of the  srmp envelop.


Author:
    Gil Shafriri(gilsh) 11-DEC-00

--*/

#pragma once

#ifndef _MSMQ_envcommon_H_
#define _MSMQ_envcommon_H_
#include <xstr.h>
struct QUEUE_FORMAT;
class CQmPacket;
class CFnQueueFormat;
class CMessageProperties;
class XmlNode;

class OpenTag
{
public:
	explicit OpenTag(
		const WCHAR* name,
		const WCHAR* attributes = L""):
		m_name(name),
		m_attributes(attributes)
		{};

	friend std::wostream& operator<<(std::wostream& wstr, const OpenTag& elm);

private:
	const WCHAR* m_name;
	const WCHAR* m_attributes;
};


class CloseTag
{
public:
	explicit CloseTag(const WCHAR* name):m_name(name){};
	friend std::wostream& operator<<(std::wostream& wstr, const CloseTag& elm );
	
private:
	const WCHAR* m_name;
};


class EmptyElement
{
public:
	explicit EmptyElement(const WCHAR* name):m_name(name){};
	friend std::wostream& operator<<(std::wostream& wstr, const EmptyElement& elm );
	
private:
	const WCHAR* m_name;
};




class QueueFormatUriContent
{
public:
	explicit QueueFormatUriContent(
		const QUEUE_FORMAT& QueueFormat
		):
		m_QueueFormat(QueueFormat)
		{
		}

	friend std::wostream& operator<<(std::wostream& wstr, const QueueFormatUriContent& queue);

private:
	const QUEUE_FORMAT& m_QueueFormat;	
};



class CurrentTimeContent
{
public:
	explicit CurrentTimeContent(){}
	friend std::wostream& operator<<(std::wostream& wstr,const CurrentTimeContent&);
};


class MessageIdContent
{
public:
	explicit MessageIdContent(const OBJECTID& oid):m_oid(oid){}
	friend std::wostream& operator<<(std::wostream& wstr, const MessageIdContent& mid);
	
private:
	const OBJECTID& m_oid;
};


class OriginalMessageIdentityElement
{
public:
	explicit OriginalMessageIdentityElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend std::wostream& operator<<(std::wostream& wstr, const OriginalMessageIdentityElement& Identity);

private:
	const CQmPacket& m_pkt;
};


class GuidElement
{
public:
	explicit GuidElement(const GUID& guid):m_guid(guid){}
	friend 	std::wostream& operator<<(std::wostream& wstr, const GuidElement& guid);

private:
	const GUID& m_guid;
};


class SendToElement
{
public:
	SendToElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend  std::wostream& operator<<(std::wostream& wstr, const SendToElement& SendTo);

private:
	const CQmPacket& m_pkt;
};



class Int64Value
{
public:
	explicit Int64Value(LONGLONG value):m_value(value){}
	friend std::wostream&  operator<<(std::wostream& wstr, const Int64Value& Int64);

private:
	LONGLONG m_value;	
};


//-------------------------------------------------------------------
//
// CXmlEncodeDecorator class for encoding stremable object into xml encoded format
//
//-------------------------------------------------------------------
template <class T> class CXmlEncodeDecorator
{
public:
	CXmlEncodeDecorator(const T& streamable);
	friend std::wostream&  operator<<(std::wostream& wstr,const CXmlEncodeDecorator<T>&);


private:
	const T& m_streamable;	
};


template <class T> inline  const CXmlEncodeDecorator<T>  XmlEncodeDecorator(const T& streamable)
{
	return 	CXmlEncodeDecorator<T>(streamable);
}


bool IsAckMsg(const CQmPacket& pkt);
void StringToGuid(LPCWSTR p, GUID* pGuid);
void UriToQueueFormat(const xwcs_t& uri, CFnQueueFormat& queueFormat);
bool BreakMsmqStreamId(const xwcs_t& NetworkStreamid, xwcs_t* pStreamid,LONGLONG* pSeqId);
void AdminQueueToProps(XmlNode& node, CMessageProperties* pProps);
void EmptyNodeToProps(XmlNode& , CMessageProperties* );


//
// SRMP key words
//
#define xmustUnderstandTrueValue L"1"
#define xmustUnderstandAttribute  L"mustUnderstand"
#define  xSoapmustUnderstandTrue  xSoapEnv L":" xmustUnderstandAttribute L"=\"" xmustUnderstandTrueValue L"\""
#define xEnvelope     L"Envelope"
#define xSoapEnv      L"se"
#define xHeader       L"Header"
#define xBody         L"Body"



static const WCHAR xProperties[] = L"properties";
static const WCHAR xStream[] =  L"Stream";
static const WCHAR xStreamReceipt[] = L"streamReceipt";
static const WCHAR xExpiresAt[] =  L"expiresAt";
static const WCHAR xDuration[] =  L"duration";
static const WCHAR xSentAt[] =     L"sentAt";
static const WCHAR xServices[] =  L"services";
static const WCHAR xDeliveryReceiptRequest[] = L"deliveryReceiptRequest";
static const WCHAR xDeliveryReceipt[] = L"deliveryReceipt";
static const WCHAR xCommitmentReceipt[] = L"commitmentReceipt";
static const WCHAR xreceivedAt[] = L"receivedAt";
static const WCHAR xDecidedAt[] = L"decidedAt";
static const WCHAR xDecision[] =   L"decision";
static const WCHAR xNegativeOnly[] = L"negativeOnly";
static const WCHAR xPositiveOnly[] = L"positiveOnly";
static const WCHAR xPositive[] = L"positive";
static const WCHAR xNegative[] =  L"negative";
static const WCHAR xCommitmentReceiptRequest[] = L"commitmentReceiptRequest";
static const WCHAR xSendTo[] = L"sendTo";
static const WCHAR xDurable[] = L"durable" ;
static const WCHAR xStreamId[] =  L"streamId";
static const WCHAR xCurrent[] =  L"current"; 
static const WCHAR xlastOrdinal[] = L"lastOrdinal" ;
static const WCHAR xPrevious[] = L"previous";
static const WCHAR xStart[] = L"start";
static const WCHAR xSendReceiptsTo[] = L"sendReceiptsTo";
static const WCHAR xSourceQmGuid[] = L"SourceQmGuid";
static const WCHAR xSignature[] = L"Signature";
static const WCHAR xInReplyTo[] = L"inReplyTo";
static const WCHAR xFilterDuplicates[] = L"filterDuplicates";
static const WCHAR xStreamReceiptRequest[] = L"streamReceiptRequest";
static const WCHAR xCommitmentCode[] = L"commitmentCode";
static const WCHAR xCommitmentDetail[] = L"xCommitmentDetail";
static const WCHAR xEnd[] = L"end";


static const WCHAR xSoapEnvelope[] = xSoapEnv L":" xEnvelope;
static const WCHAR xSoapHeader[] =  xSoapEnv L":" xHeader;
static const WCHAR xSoapBody[] = xSoapEnv L":" xBody;
static const WCHAR xSoapmustUnderstand[] = xSoapEnv L":" L"mustUnderstand";

//
// SMXP key words
//
static const WCHAR xPath[] =  L"path";
static const WCHAR xFixed[] = L"fixed";
static const WCHAR xFwd[] = L"fwd";
static const WCHAR xRev[] = L"rev";
static const WCHAR xVia[] = L"via";
static const WCHAR xFault[] = L"fault";
static const WCHAR xTo[] =  L"to";
static const WCHAR xAction[] =  L"action";
static const WCHAR xRelatesTo[] =  L"relatesTo";
static const WCHAR xId[] =  L"id";
static const WCHAR xFrom[] = L"from";

//
// MSMQ specific key words
//
static const WCHAR  xMsmq[] = L"Msmq";
static const WCHAR xClass[] = L"Class";
static const WCHAR xPriority[] = L"Priority";
static const WCHAR xProvider[] =  L"Provider";
static const WCHAR xType[] =  L"Type";
static const WCHAR xName[] =  L"Name";
static const WCHAR xEod[] =  L"Eod";
static const WCHAR xFirst[] =  L"First";
static const WCHAR xLast[] = L"Last";
static const WCHAR xConnectorId[] =  L"xConnectorId";
static const WCHAR xHashAlgorithm[] = L"HashAlgorithm";
static const WCHAR xBodyType[] = L"BodyType";
static const WCHAR xApp[] =  L"App";
static const WCHAR xConnectorType[] =  L"ConnectorType";
static const WCHAR xTrace[] =  L"Trace";
static const WCHAR xJournal[] =  L"Journal";
static const WCHAR xDeadLetter[] =  L"DeadLetter";
static const WCHAR xSendBy[] =  L"SendBy";
static const WCHAR xCorrelation[] =  L"Correlation";
static const WCHAR xDestinationMqf[] =  L"DestinationMqf";
static const WCHAR xAdminMqf[] =  L"AdminMqf";
static const WCHAR xResponseMqf[]= L"ResponseMqf";
static const WCHAR xReplyTo[] =  L"replyTo";
static const WCHAR xTTrq[] = L"TTrq";

//
// Msmq prefix for SMXP::Action
//
static const WCHAR xMsmqActionPrefix[] = L"MSMQ:";


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mp\lib\envcomreceiptreq.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envdelreceiptreq.h

Abstract:
    Header for Serialization and Deserialization of srmp envelop delivery receipt request element.

Author:
    Gil Shafriri(gilsh) 11-DEC-00

--*/

#pragma once

#ifndef _MSMQ_envdelreceiptreq_H_
#define _MSMQ_envdelreceiptreq_H_

class CQmPacket;
class XmlNode;
class CMessageProperties;
class CommitmentReceiptRequestElement
{
public:
	explicit CommitmentReceiptRequestElement(const CQmPacket& pkt):m_pkt(pkt){}
	bool IsIncluded() const; 
	friend std::wostream& operator<<(std::wostream& wstr, const CommitmentReceiptRequestElement& CommitmentReceiptRequest);
	
private:
	const CQmPacket& m_pkt;
};


void 
CommitmentReceiptRequestToProps(
	XmlNode& CommitmentReceiptRequest, 
	CMessageProperties* pMessageProperties
	);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mp\lib\envcomreceipt.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envcomreceipt.cpp

Abstract:
    Implements serialization\deserialization of the SRMP header  to\from the  srmp envelop.


Author:
    Gil Shafriri(gilsh) 11-DEC-00

--*/

#include <libpch.h>
#include <mqprops.h>
#include <qmpkt.h>
#include "envcomreceipt.h"
#include "envcommon.h"
#include "mpp.h"
#include "envparser.h"

#include "envcomreceipt.tmh"

using namespace std;

class DecidedAtElement
{
public:
	explicit  DecidedAtElement(){};
	friend wostream& operator<<(wostream& wstr, const DecidedAtElement&)
	{
		wstr<<OpenTag(xDecidedAt)
			<<CurrentTimeContent()
			<<CloseTag(xDecidedAt);

		return wstr;
	}
};

class DecisionElement
{
public:
	explicit DecisionElement (const CQmPacket& pkt):m_pkt(pkt){}
	friend wostream& operator<<(wostream& wstr, const DecisionElement& Decision)
	{
		const WCHAR* decision = MQCLASS_POS_RECEIVE(Decision.m_pkt.GetClass()) ? xPositive : xNegative;
		wstr<<OpenTag(xDecision)
			<<decision
			<<CloseTag(xDecision);

		return wstr;
	}

private:
	const CQmPacket& m_pkt;
};


wostream& operator<<(wostream& wstr, const CommitmentReceiptElement& cReceipt)
{
		if(!MQCLASS_RECEIVE(cReceipt.m_pkt.GetClass())) 
			return wstr;

		wstr<<OpenTag(xCommitmentReceipt)
			<<DecidedAtElement()
			<<DecisionElement(cReceipt.m_pkt)
			<<OriginalMessageIdentityElement(cReceipt.m_pkt)
			<<CloseTag(xCommitmentReceipt);

		return wstr;
}






void
CommitmentReceiptToProps(
	XmlNode& CommitmentReceipt, 
	CMessageProperties* pMessageProperties
	)
{
	CParseElement ParseElements[] =	{
										CParseElement(S_XWCS(xDecidedAt), EmptyNodeToProps, 1,1),
										CParseElement(S_XWCS(xDecision), EmptyNodeToProps, 1,1),
										CParseElement(S_XWCS(xId), EmptyNodeToProps,1, 1),
										CParseElement(S_XWCS(xCommitmentCode), EmptyNodeToProps,0, 1),
										CParseElement(S_XWCS(xCommitmentDetail), EmptyNodeToProps,0, 1)
								   	};	

	NodeToProps(CommitmentReceipt, ParseElements, TABLE_SIZE(ParseElements), pMessageProperties);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mp\lib\envcomreceiptreq.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envdelreceiptres.cpp

Abstract:
    Implements serialization\deserialization of the commitment receipt request to\from the  srmp envelop.


Author:
    Gil Shafriri(gilsh) 11-DEC-00

--*/

#include <libpch.h>
#include <qmpkt.h>
#include <proptopkt.h>
#include "mpp.h"
#include "envcomreceiptreq.h"
#include "envparser.h"
#include "envcommon.h"

#include "envcomreceiptreq.tmh"

using namespace std;

class NegativeOnlyElement
{
public:
	NegativeOnlyElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend  wostream& operator<<(wostream& wstr, const NegativeOnlyElement& NegativeOnly)
	{
		USHORT ackType = (const_cast<CQmPacket&>(NegativeOnly.m_pkt)).GetAckType();
		if ((ackType & MQMSG_ACKNOWLEDGMENT_NEG_RECEIVE) == 0)
			return wstr;
		
		return wstr<<EmptyElement(xNegativeOnly);
	}

private:
	const CQmPacket& m_pkt;
};
	


class PositiveOnlyElement
{
	public:
		PositiveOnlyElement(const CQmPacket& pkt):m_pkt(pkt){}
		friend  wostream& operator<<(wostream& wstr, const PositiveOnlyElement& PositiveOnly)
		{
			USHORT ackType = (const_cast<CQmPacket&>(PositiveOnly.m_pkt)).GetAckType();

			if ((ackType & MQMSG_ACKNOWLEDGMENT_POS_RECEIVE) == 0)
				return wstr; 		

			return wstr<<EmptyElement(xPositiveOnly);
		}

	private:
		const CQmPacket& m_pkt;
};



bool CommitmentReceiptRequestElement::IsIncluded() const 
{
	CQmPacket& 	pkt = const_cast<CQmPacket&>(m_pkt);
	USHORT ackType = pkt.GetAckType();

	if ((ackType & (MQMSG_ACKNOWLEDGMENT_POS_RECEIVE | MQMSG_ACKNOWLEDGMENT_NEG_RECEIVE)) == 0)
		return false;


	QUEUE_FORMAT adminQueue;
	pkt.GetAdminQueue(&adminQueue);

	if (adminQueue.GetType() == QUEUE_FORMAT_TYPE_UNKNOWN)
		return false;

	return true;
}



wostream& operator<<(wostream& wstr, const CommitmentReceiptRequestElement&  CommitmentReceiptRequest)
{
		if(!CommitmentReceiptRequest.IsIncluded())
			return wstr;


		const CQmPacket& pkt = CommitmentReceiptRequest.m_pkt;

		wstr<<OpenTag(xCommitmentReceiptRequest)
			<<PositiveOnlyElement(pkt)
			<<NegativeOnlyElement(pkt)
    		<<SendToElement(pkt)
			<<CloseTag(xCommitmentReceiptRequest);

		return 	wstr;
}




static void PositiveOnlyToProps(XmlNode& , CMessageProperties* pProps)
{
	pProps->acknowledgeType |= MQMSG_ACKNOWLEDGMENT_POS_RECEIVE;
}


static void NegativeOnlyToProps(XmlNode& , CMessageProperties* pProps)
{
	pProps->acknowledgeType |= MQMSG_ACKNOWLEDGMENT_NEG_RECEIVE;
}




static void SendToToProps(XmlNode& node, CMessageProperties* pProps)
{
	AdminQueueToProps(node, pProps);
}



void 
CommitmentReceiptRequestToProps(
	XmlNode& CommitmentReceiptRequest, 
	CMessageProperties* pMessageProperties
	)
/*++

Routine Description:
    Parse SRMP Commitment Receipt Request element into MSMQ properties.

Arguments:
	Properties - Commitment Receipt Request element in SRMP reperesenation (xml).
	pMessageProperties - Received the parsed properties.

Returned Value:
	None.   

--*/
{
		CParseElement ParseElements[] =	{
											CParseElement(S_XWCS(xPositiveOnly), PositiveOnlyToProps, 0 ,1),
											CParseElement(S_XWCS(xNegativeOnly), NegativeOnlyToProps, 0 ,1),
											CParseElement(S_XWCS(xSendBy), EmptyNodeToProps, 0 ,1),
											CParseElement(S_XWCS(xSendTo), SendToToProps, 0 ,1)
										};	

		NodeToProps(CommitmentReceiptRequest, ParseElements, TABLE_SIZE(ParseElements), pMessageProperties);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mp\lib\envcommon.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envcommon.cpp

Abstract:
    Implements common utilities for  serialization\deserialization of the  srmp envelop.


Author:
    Gil Shafriri(gilsh) 11-DEC-00

--*/
#include <libpch.h>
#include <fn.h>
#include <timeutl.h>
#include <mqtime.h>
#include <qmpkt.h>
#include <mp.h>
#include <xml.h>
#include <proptopkt.h>
#include "envcommon.h"
#include "mpp.h"

#include "envcommon.tmh"

using namespace std;

template <class T> 
CXmlEncodeDecorator<T>::CXmlEncodeDecorator(
	const T& streamable
	):
	m_streamable(streamable)
{
};



template <class T> 
wostream&  
operator<<(
	std::wostream& wstr,
	const CXmlEncodeDecorator<T>& XmlEncodeDecorator
	)
/*++

Routine Description:
    Serialize an object encoded according to xml rules.

Arguments:
	wtr - Stream to serialize the object into.
	XmlEncodeDecorator - xml encoding decorator that holds the object itself.


Returned Value:
	The input stream.

Note :
	The function serialize the given object into temporary stream and then
	xml Encode the data from the temporary stream into the supplied stream.
--*/
{

	wostringstream tmp;
	tmp<<XmlEncodeDecorator.m_streamable;
	wstr<<CXmlEncode(xwcs_t(tmp.str().c_str(), tmp.str().size()));
   	return wstr;
}

//
// Explicit instantiation of templates and template functions.
//
template class CXmlEncodeDecorator<CFnSerializeMqf>;
template std::wostream& operator<<(std::wostream& wstr,const CXmlEncodeDecorator<CFnSerializeMqf>&); 
template class CXmlEncodeDecorator<QueueFormatUriContent>;
template std::wostream& operator<<(std::wostream& wstr,const CXmlEncodeDecorator<QueueFormatUriContent>&); 




wostream& operator<<(wostream& wstr, const QueueFormatUriContent& queue)
{
		if(FnIsDirectHttpFormatName(&queue.m_QueueFormat))
		{
			wstr <<queue.m_QueueFormat.DirectID();
			return wstr;
		}
 		wstr<<FN_MSMQ_URI_PREFIX_TOKEN<<CFnSerializeQueueFormat(queue.m_QueueFormat);
		return wstr;
}




wostream& operator<<(wostream& wstr, const OpenTag& elm )
{
		const WCHAR* xSeperator =  (elm.m_attributes[0] ==  L'\0' ) ? L"" : L" ";

		wstr<<L"<" <<elm.m_name <<xSeperator<<elm.m_attributes <<L">";	
		return wstr;
}


wostream& operator<<(wostream& wstr, const CloseTag& elm )
{
	wstr<< L"</" <<elm.m_name <<L">";
	return wstr;
}


wostream& operator<<(wostream& wstr, const EmptyElement& elm )
{
	wstr<<L"<" <<elm.m_name <<L"/>";
	return wstr;
}





wostream& operator<<(wostream& wstr, const GuidElement& guild)
{
	WCHAR strGuid[GUID_STR_LENGTH + 1];

    const GUID* pGuid = &guild.m_guid;
    swprintf(strGuid, GUID_FORMAT, GUID_ELEMENTS(pGuid));

    return (wstr << strGuid);
}


wostream& operator<<(wostream& wstr,const CurrentTimeContent& )
{
	return wstr<<CIso8601Time(MqSysTime());
}


wostream& operator<<(wostream& wstr, const MessageIdContent& mid)
{
		wstr<<xUuidReferencePrefix
			<<mid.m_oid.Uniquifier
			<<xUuidReferenceSeperator
			<<GuidElement(mid.m_oid.Lineage);

		return wstr;
}


wostream& operator<<(wostream& wstr, const OriginalMessageIdentityElement& Identity)
{
		OBJECTID* messageId = (OBJECTID*)Identity.m_pkt.GetCorrelation();
		ASSERT(IsAckMsg(Identity.m_pkt));
		ASSERT(messageId != NULL);

		wstr<<OpenTag(xId)
			<<MessageIdContent(*messageId)
			<<CloseTag(xId);

		return wstr;
}


wostream&  operator<<(wostream& wstr, const Int64Value& Int64)
{
	WCHAR buff[64];
    _i64tow(Int64.m_value,buff,10 );
	
    return wstr << buff;
}


wostream& operator<<(wostream& wstr, const SendToElement& SendTo)
{
	QUEUE_FORMAT adminQueue;
	(const_cast<CQmPacket&>(SendTo.m_pkt)).GetAdminQueue(&adminQueue);
	ASSERT(adminQueue.GetType() != QUEUE_FORMAT_TYPE_UNKNOWN);

	wstr<<OpenTag(xSendTo)
		<<QueueFormatUriContent(adminQueue)
		<<CloseTag(xSendTo);

	return wstr;
}



//
// Check if gven packet is some kind of acknolagment (negative or positive)
//
bool IsAckMsg(const CQmPacket& pkt)
{
	
	USHORT Class = 	pkt.GetClass();
	bool fAckOrNormal = (MQCLASS_POS_RECEIVE(Class) ||  
						 MQCLASS_NEG_RECEIVE(Class) ||
						 MQCLASS_POS_ARRIVAL(Class) ||
						 MQCLASS_NEG_ARRIVAL(Class)
						);


	return fAckOrNormal && (Class != MQMSG_CLASS_NORMAL);
}

static
const 
xwcs_t
MSMQFormatNameFromUri(
				const xwcs_t& uri
				)
{
	ASSERT(FnIsMSMQUrl(uri));

	return 	xwcs_t( uri.Buffer() + FN_MSMQ_URI_PREFIX_TOKEN_LEN,
					uri.Length() -  FN_MSMQ_URI_PREFIX_TOKEN_LEN);
}



static
void
UriToQueueFormatInternal(
    const xwcs_t& uri,
    CFnQueueFormat& queueFormat
    )
{
    if(uri.Length() == 0)
        return;

	//
    // If http or https we convert it to direct format name
	//
	if(FnIsHttpHttpsUrl(uri))
	{
		queueFormat.CreateFromUrl(uri);
		return;
	}

	//
	// If msmq format name MSMQ:[MSMQ FORMAT NAME]
	//
	if(FnIsMSMQUrl(uri))
	{
		queueFormat.CreateFromFormatName(MSMQFormatNameFromUri(uri));
		return;
	}
    throw bad_srmp(L"Illegal queue path. Only HTTP/HTTPS/MSMQ is supported");
}


void
UriToQueueFormat(
    const xwcs_t& uri,
    CFnQueueFormat& queueFormat
    )
{
	CXmlDecode XmlDecode;
	XmlDecode.Decode(uri);
	
	UriToQueueFormatInternal(XmlDecode.get(), queueFormat);
}


bool
BreakMsmqStreamId(
			const xwcs_t& NetworkStreamid, 
			xwcs_t* pStreamid,
			LONGLONG* pSeqId
			)
/*++

Routine Description:
    Parse stream id that is MSMQ stream id of the format qmguid\\seqid.
	

Arguments:
    NetworkStreamid - stream id of the format qmguid\\seqid.
	pStreamid - receive the  qmguid part
	pSeqId - receives the  seqid part.

Returned Value:
    true if parsed ok - false if wrong format.

--*/
{
	const WCHAR* begin = NetworkStreamid.Buffer();
	const WCHAR* end = 	NetworkStreamid.Buffer() + NetworkStreamid.Length();
	const WCHAR* found = std::search(begin, end, xSlash, xSlash + STRLEN(xSlash) );
	if(found == end || found + STRLEN(xSlash) == end )
	{
		return false;
	}
	*pStreamid =  xwcs_t(begin, found - begin);
	*pSeqId =  _wtoi64(found + STRLEN(xSlash));	
	return true;
}


void AdminQueueToProps(XmlNode& node, CMessageProperties* pProps)
{
	if(node.m_values.empty())
	{
		TrERROR(Mp, "%ls", L"Illegal admin queue address"); 
		throw bad_srmp(L"");
	}

	xwcs_t AckToAddr = node.m_values.front().m_value;
	if(AckToAddr.Length() == 0 )
	{
		TrERROR(Mp, "%ls", L"Illegal admin queue address"); 
		throw bad_srmp(L"");
	}

    UriToQueueFormat(AckToAddr, pProps->adminQueue);
}





void
StringToGuid(
    LPCWSTR p, 
    GUID* pGuid
    )
{
    //
    //  N.B. scanf stores the results in an int, no matter what the field size
    //      is. Thus we store the result in tmp variabes.
    //
    UINT w2, w3, d[8];
    if(swscanf(
            p,
            GUID_FORMAT,
            &pGuid->Data1,
            &w2, &w3,                       //  Data2, Data3
            &d[0], &d[1], &d[2], &d[3],     //  Data4[0..3]
            &d[4], &d[5], &d[6], &d[7]      //  Data4[4..7]
            ) != 11)
    {
        throw bad_srmp(L"Illegal uuid format");
    }

    pGuid->Data2 = static_cast<WORD>(w2);
    pGuid->Data3 = static_cast<WORD>(w3);
    for(int i = 0; i < 8; i++)
    {
        pGuid->Data4[i] = static_cast<BYTE>(d[i]);
    }
}

void EmptyNodeToProps(XmlNode& , CMessageProperties* )
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mp\lib\envdelreceipt.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envdelreceipt.cpp

Abstract:
    Implements serialization\deserialization of the delivery receipt to\from the  srmp envelop.


Author:
    Gil Shafriri(gilsh) 11-DEC-00

--*/

#include <libpch.h>
#include <qmpkt.h>
#include "envdelreceipt.h"
#include "envcommon.h"
#include "mpp.h"
#include "envparser.h"

#include "envdelreceipt.tmh"

using namespace std;

class ReceivedAtElement
{
public:
	explicit  ReceivedAtElement(){};
	friend wostream& operator<<(wostream& wstr, const ReceivedAtElement&)
	{
		wstr <<OpenTag(xreceivedAt)<<CurrentTimeContent()<<CloseTag(xreceivedAt);
		return wstr;
	}
};


wostream& operator<<(wostream& wstr, const DeliveryReceiptElement& dReceipt)
{
		if(dReceipt.m_pkt.GetClass() != MQMSG_CLASS_ACK_REACH_QUEUE)
			return wstr;

		wstr<<OpenTag(xDeliveryReceipt)
			<<ReceivedAtElement()
			<<OriginalMessageIdentityElement(dReceipt.m_pkt)
			<<CloseTag(xDeliveryReceipt);

		return wstr;
}



void 
DeliveryReceiptToProps(
		XmlNode& DeliveryReceipt,
		CMessageProperties*  pMessageProperties
		)
/*++

Routine Description:
    Parse SRMP Delivery Receipt Request element into MSMQ properties.

Arguments:
	Properties - Delivery Receipt Request element in SRMP reperesenation (xml).
	pMessageProperties - Received the parsed properties.

Returned Value:
	None.   

--*/

{
	CParseElement ParseElements[] =	{
										CParseElement(S_XWCS(xreceivedAt), EmptyNodeToProps,1 ,1),
										CParseElement(S_XWCS(xId), EmptyNodeToProps,1 ,1),
									};	

	NodeToProps(DeliveryReceipt, ParseElements, TABLE_SIZE(ParseElements), pMessageProperties);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mp\lib\envdelreceipt.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envdelreceipt.h

Abstract:
    Header for Serialization and Deserialization of srmp envelop delivery receipt  element.

Author:
    Gil Shafriri(gilsh) 11-DEC-00

--*/

#pragma once

#ifndef _MSMQ_envdelreceipt_H_
#define _MSMQ_envdelreceipt_H_

class CQmPacket;
class XmlNode;
class CMessageProperties;
class DeliveryReceiptElement
{
public:
	explicit DeliveryReceiptElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend std::wostream& operator<<(std::wostream& wstr, const DeliveryReceiptElement& dReceipt);
	
private:
	const CQmPacket& m_pkt;
};

void DeliveryReceiptToProps(XmlNode& Node, CMessageProperties* pMessageProperties);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mp\lib\envdelreceiptreq.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envdelreceiptreq.h

Abstract:
    Header for Serialization and Deserialization of srmp envelop delivery receipt request element.

Author:
    Gil Shafriri(gilsh) 11-DEC-00

--*/

#pragma once

#ifndef _MSMQ_envdelreceiptreq_H_
#define _MSMQ_envdelreceiptres_H_

class CQmPacket;
class XmlNode;
class CMessageProperties;
class DeliveryReceiptRequestElement
{
public:
	explicit DeliveryReceiptRequestElement(const CQmPacket& pkt):m_pkt(pkt){}
	bool IsIncluded() const; 
	friend std::wostream& operator<<(std::wostream& wstr, const DeliveryReceiptRequestElement& dReceipt);
	
private:
	const CQmPacket& m_pkt;
};

void DeliveryReceiptRequestToProps(XmlNode& DeliveryReceiptRequest, CMessageProperties* pMessageProperties);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mp\lib\envelop.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envelop.h

Abstract:
    Header for serialization\deserialization of the SRMP envelop.


Author:
    Gil Shafriri(gilsh) 11-DEC-00

--*/

#pragma once

#ifndef _MSMQ_envelop_H_
#define _MSMQ_envelop_H_

class CQmPacket;
class CMessageProperties;
class XmlNode;
class EnvelopElement
{
public:
	explicit EnvelopElement(const CQmPacket& pkt);
	friend std::wostream& operator<<(std::wostream& wstr, const EnvelopElement& Envelop);

private:		
	const CQmPacket& m_pkt;
};
std::wstring GenerateEnvelope(const CQmPacket& pkt);
void EnvelopToProps(XmlNode& Envelop, CMessageProperties* pMessageProperties);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mp\lib\envelop.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envelop.cpp

Abstract:
    Implements serialization\deserialization of srmp envelop.

Author:
    Gil Shafriri(gilsh) 11-DEC-00

--*/

#include <libpch.h>
#include <qmpkt.h>
#include <proptopkt.h>
#include <xml.h>
#include "envelop.h"
#include "envheader.h"
#include "envcommon.h"
#include "mpp.h"
#include "envparser.h"
#include "envbody.h"
#include "envelop.tmh"

using namespace std;


static
void
ValidatePacket(
		const CQmPacket& pkt
		)
{
	ASSERT(!pkt.IsSrmpIncluded());
	ASSERT(!(pkt.IsEodIncluded() && pkt.IsEodAckIncluded()));
	ASSERT(!(pkt.IsOrdered() && pkt.IsEodAckIncluded()));
	ASSERT(!( IsAckMsg(pkt) && pkt.IsOrdered()));

	DBG_USED(pkt);
}

EnvelopElement::EnvelopElement(
				const CQmPacket& pkt
				):
				m_pkt(pkt)
{
	ValidatePacket(pkt);
}



wstring GenerateEnvelope(const CQmPacket& pkt)
{  
	wostringstream wstr(L"");
	wstr.exceptions(ios_base::badbit | ios_base::failbit);
	wstr<<EnvelopElement(pkt);
    return wstr.str();
}



wostream& operator<<(wostream& wstr, const EnvelopElement& Envelop)
/*++

Routine Description:
    Serialize SRMP envelop into stream
	

Arguments:
	wstr - Stream
	Envelop - Envelop stream manipulator. 

Returned Value:
    Stream after envelop was serialiased to it.

Note:
This function serializes QM packet into stream according to SRMP envelop format.

--*/
{
		const WCHAR* EnvelopAttributes = L"xmlns:" xSoapEnv L"=\"http://schemas.xmlsoap.org/soap/envelope/\" "
	                            		 L"xmlns=\"http://schemas.xmlsoap.org/srmp/\"";


		wstr<<OpenTag(xSoapEnvelope, EnvelopAttributes)
			<<HeaderElement(Envelop.m_pkt)
			<<BodyElement(Envelop.m_pkt)
			<<CloseTag(xSoapEnvelope);

		return wstr;
}







void EnvelopToProps(XmlNode& Envelop, CMessageProperties* pMessageProperties)
/*++

Routine Description:
    Parse envelop in SRMP reperesenation into MSMQ properties.

Arguments:
	Envelop - envelop in SRMP reperesenation (xml).
	pMessageProperties - Received the parsed properties.

Returned Value:
	None.   

--*/
{	
	CParseElement ParseElements[] =	{
										CParseElement(S_XWCS(xHeader),HeaderToProps, 1, 1),
										CParseElement(S_XWCS(xBody),  EmptyNodeToProps, 1,1)	
									};	

	NodeToProps(Envelop, ParseElements, TABLE_SIZE(ParseElements), pMessageProperties);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mp\lib\envendpoints.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envendpoints.h

Abstract:
    Header for serialization\deserialization of the smxp element to\from the  srmp envelop.


Author:
    Gil Shafriri(gilsh) 11-DEC-00

--*/

#pragma once

#ifndef _MSMQ_envendpoints_H_
#define _MSMQ_envendpoints_H_
class CQmPacket;
class XmlNode;
class CMessageProperties;
class SmXpPathElement
{
public:
	explicit SmXpPathElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend  std::wostream& operator<<(std::wostream& wstr, const SmXpPathElement& SmXpPath);

private:
	const CQmPacket& m_pkt;
};

void SmXpPathToProps(XmlNode& Node, CMessageProperties* pMessageProperties);





#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mp\lib\envdelreceiptreq.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envdelreceiptres.cpp

Abstract:
    Implements serialization\deserialization of the delivery receipt request to\from the  srmp envelop.


Author:
    Gil Shafriri(gilsh) 11-DEC-00

--*/

#include <libpch.h>
#include <qmpkt.h>
#include <proptopkt.h>
#include <xml.h>
#include <mp.h>
#include "mpp.h"
#include "envdelreceiptreq.h"
#include "envparser.h"
#include "envcommon.h"

#include "envdelreceiptreq.tmh"

using namespace std;

bool DeliveryReceiptRequestElement::IsIncluded() const 
{
	CQmPacket& 	pkt = const_cast<CQmPacket&>(m_pkt);
	USHORT ackType = pkt.GetAckType();

	if( (ackType & MQMSG_ACKNOWLEDGMENT_POS_ARRIVAL) == 0)
		return false;


	QUEUE_FORMAT adminQueue;
	pkt.GetAdminQueue(&adminQueue);

	if (adminQueue.GetType() == QUEUE_FORMAT_TYPE_UNKNOWN)
		return false;

	return true;
}

wostream& operator<<(wostream& wstr, const DeliveryReceiptRequestElement& DeliveryReceiptRequest)
{
		if(!DeliveryReceiptRequest.IsIncluded())
			return wstr; 

		const CQmPacket& pkt = DeliveryReceiptRequest.m_pkt;
		

		wstr<<OpenTag(xDeliveryReceiptRequest) 
			<<SendToElement(pkt)
	  		<<CloseTag(xDeliveryReceiptRequest); 

		return wstr;
}

static void SendToToProps(XmlNode& node, CMessageProperties* pProps)
{
		pProps->acknowledgeType |= MQMSG_ACKNOWLEDGMENT_POS_ARRIVAL;
		AdminQueueToProps(node, pProps);
}



 

void 
DeliveryReceiptRequestToProps(
	XmlNode& DeliveryReceipt, 
	CMessageProperties* pMessageProperties)
/*++

Routine Description:
    Parse SRMP Delivery Receipt element into MSMQ properties.

Arguments:
	DeliveryReceipt - Delivery Receipt Request element in SRMP reperesenation (xml).
	pMessageProperties - Received the parsed properties.

Returned Value:
	None.   

--*/
{
		CParseElement ParseElements[] =	{
											CParseElement(S_XWCS(xSendTo), SendToToProps, 1, 1),
											CParseElement(S_XWCS(xSendBy), EmptyNodeToProps, 0 ,1)
										};	

		NodeToProps(DeliveryReceipt, ParseElements, TABLE_SIZE(ParseElements), pMessageProperties);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mp\lib\envheader.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envelopheader.h

Abstract:
    Header for serialization\deserialization of the SRMP header to\from the  srmp envelop.


Author:
    Gil Shafriri(gilsh) 11-DEC-00

--*/

#pragma once

#ifndef _MSMQ_envheader_H_
#define _MSMQ_envheader_H_
class  XmlNode;
class  CMessageProperties;
class  CQmPacket;

class HeaderElement
{
public:
	explicit HeaderElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend std::wostream& operator<<(std::wostream& wstr, const HeaderElement& Header);

private:		
	const CQmPacket& m_pkt;
};

void HeaderToProps(XmlNode& Header, CMessageProperties* pMessageProperties);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mp\lib\envendpoints.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envendpoints.cpp

Abstract:
    Implements serialization\deserialization of the smxp element to\from the  srmp envelop.


Author:
    Gil Shafriri(gilsh) 11-DEC-00

--*/

#include <libpch.h>
#include <mqsymbls.h>
#include <mqformat.h>
#include <qmpkt.h>
#include <xml.h>
#include <mp.h>
#include <proptopkt.h>
#include "envendpoints.h"
#include "envcommon.h"
#include "mpp.h"
#include "envparser.h"

#include "envendpoints.tmh"

using namespace std;

class MessageIdentityElement
{
public:
	explicit MessageIdentityElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend wostream& operator<<(wostream& wstr, const MessageIdentityElement& MIdentity)
	{
		OBJECTID messageId;
		MIdentity.m_pkt.GetMessageId(&messageId);

		wstr<<OpenTag(xId)
			<<MessageIdContent(messageId)
			<<CloseTag(xId);

 		return wstr;
	}
private:
	const CQmPacket& m_pkt;
};



class ToElement
{
public:
	explicit ToElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend wostream& operator<<(wostream& wstr, const ToElement& To)	
	{
		QUEUE_FORMAT destQueueFormat;
		const_cast<CQmPacket&>(To.m_pkt).GetDestinationQueue(&destQueueFormat);
		
		wstr <<OpenTag(xTo)
			 <<XmlEncodeDecorator(QueueFormatUriContent(destQueueFormat))
			 <<CloseTag(xTo);

		return wstr;
  	}

private:
const CQmPacket& m_pkt;
};



class ActionElement
{
public:
	explicit ActionElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend wostream& operator<<(wostream& wstr, const ActionElement& Action)	
	{
		wstr<<OpenTag(xAction)
			<<ActionContent(Action.m_pkt.GetTitlePtr(), Action.m_pkt.GetTitleLength())
			<<CloseTag(xAction);

		return wstr;
	}


private:
	class ActionContent
	{
	public:
		explicit ActionContent(
					const WCHAR* pTitle, 
					DWORD TitleLen
					):
					m_pTitle(pTitle),
					m_TitleLen(TitleLen)
					{}

		friend wostream& operator<<(wostream& wstr, const ActionContent& Action)	
		{
            xwcs_t MsmqActionPrefix(xMsmqActionPrefix, wcslen(xMsmqActionPrefix));
            wstr<<CXmlEncode(MsmqActionPrefix);

			if (Action.m_TitleLen == 0)
            {
                return wstr;
            }

	   		ASSERT(Action.m_pTitle[Action.m_TitleLen - 1] == L'\0');
			xwcs_t 	wcsAction(Action.m_pTitle, Action.m_TitleLen - 1);
			return wstr<<CXmlEncode(wcsAction);
		}

	private:
	const WCHAR* m_pTitle;
	DWORD m_TitleLen;
	};


private:
	const CQmPacket& m_pkt;
};


class  RevElement
{
public:
	explicit RevElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend wostream& operator<<(wostream& wstr, const RevElement& Rev)	
	{
		QUEUE_FORMAT replyQueueFormat;
		const_cast<CQmPacket&>(Rev.m_pkt).GetResponseQueue(&replyQueueFormat);

		if (replyQueueFormat.GetType() == QUEUE_FORMAT_TYPE_UNKNOWN)
			return 	wstr;

		wstr<<OpenTag(xRev)
			<<ViaElement(replyQueueFormat)
			<<CloseTag(xRev);

		return wstr;
	}

private:
	class ViaElement
	{
	public:
		ViaElement(const QUEUE_FORMAT& QueueFormat):m_QueueFormat(QueueFormat){}
		friend wostream& operator<<(wostream& wstr, const ViaElement& Via)	
		{
			wstr<<OpenTag(xVia)
				<<QueueFormatUriContent(Via.m_QueueFormat)
				<<CloseTag(xVia);

			return wstr;
		}

	private:
		const QUEUE_FORMAT& m_QueueFormat;	
	};


private:
	const CQmPacket& m_pkt;
};




wostream& operator<<(wostream& wstr, const SmXpPathElement& SmXpPath)
{
		const WCHAR* xSmxpAttributes = L"xmlns=\"http://schemas.xmlsoap.org/rp/\" " xSoapmustUnderstandTrue;

		wstr<<OpenTag(xPath, xSmxpAttributes)
			<<ActionElement(SmXpPath.m_pkt)
    		<<ToElement(SmXpPath.m_pkt)
			<<RevElement(SmXpPath.m_pkt)
			<<MessageIdentityElement(SmXpPath.m_pkt)
			<<CloseTag(xPath);

		return wstr;
}


static void DestinationQueueToProps(XmlNode& node, CMessageProperties* pProps)
{
	if(node.m_values.empty())
	{
		TrERROR(Mp, "%ls", L"Illegal Destination queue value"); 
		throw bad_srmp(L"");
	}

	xwcs_t DestinationQueue = node.m_values.front().m_value;
	if(DestinationQueue.Length() == 0)
	{
		TrERROR(Mp, "%ls", L"Illegal Destination queue value"); 
		throw bad_srmp(L"");
	}
    UriToQueueFormat(DestinationQueue, pProps->destQueue);
}


static bool ExtractMSMQMessageId(const xwcs_t& Mid, CMessageProperties* pProps)
{
	DWORD nscan;
    int n = swscanf(
				Mid.Buffer(), 
                UUIDREFERENCE_PREFIX L"%d" UUIDREFERENCE_SEPERATOR L"%n",
                &pProps->messageId.Uniquifier, 
				&nscan
                );

    if (n != 1)
	{
     	return false;
	}

    StringToGuid(Mid.Buffer() + nscan, &pProps->messageId.Lineage);
	return true;
}


static void MessageIdentityToProps(XmlNode& node, CMessageProperties* pProps)
{
	if(node.m_values.empty())
	{
		TrERROR(Mp, "%ls", L"Illegal Message Identity"); 
		throw bad_srmp(L"");
	}

	xwcs_t Mid = node.m_values.front().m_value;
	if(Mid.Length() == 0)
	{
		TrERROR(Mp, "%ls", L"Illegal Message Identity"); 
		throw bad_srmp(L"");
	}

	//
	// first try to see if the message id is from MSMQ format uuid:index@guid.
	//
	bool fSuccess = ExtractMSMQMessageId(Mid, pProps);
	if(fSuccess)
		return;


	//
	// The message id format is not MSMQ message id format - set fixed messages id.
	//
	TrWARNING(Mp, "%ls",L"non MSMQ messages id format -  create new message id"); 

	
	const GUID xNonMSMQMessageIdGuid = {0x75d1aae4,0x8e23,0x400a,0x8c,0x33,0x99,0x64,0x8e,0x35,0xe7,0xb9};
	const ULONG xNonMSMQMessageIdIndex = 1;

	pProps->messageId.Uniquifier = xNonMSMQMessageIdIndex;
	pProps->messageId.Lineage = xNonMSMQMessageIdGuid;
}							 



static void ReplyQueueToProps(XmlNode& node, CMessageProperties* pProps)
{
	//
	//according to smxp spec via element can exists but be empty
	//
	if(node.m_values.empty())
	{
		return;
	}

	xwcs_t ReplyQueue = node.m_values.front().m_value;
	if(ReplyQueue.Length() == 0)
	{
		TrERROR(Mp, "%ls", L"Illegal Replay queue value"); 
		throw bad_srmp(L"");
	}

    UriToQueueFormat(ReplyQueue, pProps->responseQueue);
}


static void RevToProps(XmlNode& node, CMessageProperties* pProps)
{
	CParseElement ParseElements[] =	{
										CParseElement(S_XWCS(xVia), ReplyQueueToProps, 1,1),
									};	

	NodeToProps(node, ParseElements, TABLE_SIZE(ParseElements), pProps);
}


static void ActionToProps(XmlNode& node, CMessageProperties* pProp)
{
	if(node.m_values.empty())
	{
		return;
	}

    pProp->SmxpActionBuffer->Decode(node.m_content);

    xwcs_t SmxpActionBuffer = pProp->SmxpActionBuffer->get();

    //
    // Length of the SMXP::Action is too small to hold a message title
    //
    size_t SmxpActionLength = SmxpActionBuffer.Length();
    if (SmxpActionLength <= wcslen(xMsmqActionPrefix))
    {
        return;
    }

    //
    // The SMXP::Action does not contain the MSMQ: prefix
    //
    if (wcsncmp(SmxpActionBuffer.Buffer(), xMsmqActionPrefix, wcslen(xMsmqActionPrefix)) != 0)
    {
        return;
    }

    //
    // The message title is the SMXP::Action content without the MSMQ: prefix
    //
    xwcs_t title(
        SmxpActionBuffer.Buffer() + wcslen(xMsmqActionPrefix), 
        SmxpActionBuffer.Length() - wcslen(xMsmqActionPrefix)
        );

	pProp->title = title;
}


void SmXpPathToProps(XmlNode& SmXpPath, CMessageProperties* pMessageProperties)
/*++

Routine Description:
    Parse SRMP endpoints element into MSMQ properties.

Arguments:
	Endpoints - Endpoints element in SRMP reperesenation (xml).
	pMessageProperties - Received the parsed properties.

Returned Value:
	None.   

--*/
{
	CParseElement ParseElements[] =	{
										CParseElement(S_XWCS(xId), MessageIdentityToProps, 1,1),
										CParseElement(S_XWCS(xTo), DestinationQueueToProps, 1, 1),
										CParseElement(S_XWCS(xRev), RevToProps, 0,1),
										CParseElement(S_XWCS(xFrom),EmptyNodeToProps, 0 ,1),
										CParseElement(S_XWCS(xAction), ActionToProps, 1,1),
										CParseElement(S_XWCS(xRelatesTo), EmptyNodeToProps, 0,1),
										CParseElement(S_XWCS(xFixed), EmptyNodeToProps, 0,1),
										CParseElement(S_XWCS(xFwd), EmptyNodeToProps, 0,1),
										CParseElement(S_XWCS(xFault), EmptyNodeToProps, 0,1),
									};	

	NodeToProps(SmXpPath, ParseElements, TABLE_SIZE(ParseElements), pMessageProperties);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mp\lib\envheader.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envheader.cpp

Abstract:
    Implements serialization\deserialization of the SRMP header  to\from the  srmp envelop.


Author:
    Gil Shafriri(gilsh) 11-DEC-00

--*/

#include <libpch.h>
#include <xml.h>
#include "envheader.h"
#include "envendpoints.h"
#include "envservice.h"
#include "envstream.h"
#include "envprops.h"
#include "envstreamreceipt.h"
#include "envdelreceipt.h"
#include "envcomreceipt.h"
#include "envusrheader.h"
#include "envmsmq.h"
#include "envsec.h"
#include "envcommon.h"
#include "envparser.h"
#include "mpp.h"

#include "envheader.tmh"

using namespace std;

wostream& operator<<(wostream& wstr, const HeaderElement& Header)
{
		const CQmPacket& pkt = 	Header.m_pkt;

		wstr<<OpenTag(xSoapHeader)
			<<SmXpPathElement(pkt)
			<<PropertiesElement(pkt)
			<<ServiceElement(pkt)
			<<StreamElement(pkt)
			<<StreamReceiptElement(pkt)
			<<DeliveryReceiptElement(pkt)
			<<CommitmentReceiptElement(pkt)
			<<MsmqElement(pkt)
			<<SignatureElement(pkt)
			<<UserHeaderElement(pkt)
			<<CloseTag(xSoapHeader);

		return 	wstr;
}


static void ReOrderNodesList(XmlNode& node)
/*++

Routine Description:
    Reorder headers elements for parsing by putting msmq element first.
	It is important because parsing is different if it is not MSMQ packet.

Arguments:
	node - elements tree.

Returned Value:
	None.   

--*/
{
	
	for(List<XmlNode>::iterator it = node.m_nodes.begin(); it != node.m_nodes.end(); ++it)
	{
		if(it->m_tag == xMsmq)
		{
			node.m_nodes.remove(*it);
			node.m_nodes.push_front(*it);
			return;
		}
	}
}


void HeaderToProps(XmlNode& node, CMessageProperties* pProps)
/*++

Routine Description:
    Parse SRMP header element into MSMQ properties.

Arguments:
	Header - header element in SRMP reperesenation (xml).
	pMessageProperties - Received the parsed properties.

Returned Value:
	None.   

--*/
{


	CParseElement ParseElements[] =	{
										CParseElement(S_XWCS(xPath), SmXpPathToProps , 1, 1),
										CParseElement(S_XWCS(xProperties), PropertiesToProps, 1, 1),
										CParseElement(S_XWCS(xServices), ServiceToProps, 0, 1),
										CParseElement(S_XWCS(xStream), StreamToProps, 0, 1),
										CParseElement(S_XWCS(xStreamReceipt), StreamReceiptToProps, 0, 1),
										CParseElement(S_XWCS(xDeliveryReceipt), DeliveryReceiptToProps, 0, 1),
										CParseElement(S_XWCS(xCommitmentReceipt), CommitmentReceiptToProps, 0, 1),
										CParseElement(S_XWCS(xMsmq), MsmqToProps, 0, 1),
										CParseElement(S_XWCS(xSignature), SignatureToProps, 0 ,1)
									};	
	//
	// We need to have MSMQ element parsed first for correct parsing
	//
	ReOrderNodesList(node);  

	NodeToProps(node, ParseElements, TABLE_SIZE(ParseElements), pProps);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mp\lib\envmsmq.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envmsmq.h

Abstract:
    Header for serialization\deserialization of the MSMQ element to\from the  srmp envelop.


Author:
    Gil Shafriri(gilsh) 11-DEC-00

--*/

#pragma once

#ifndef _MSMQ_envmsmq_H_
#define _MSMQ_envmsmq_H_

class CQmPacket;
class XmlNode;
class CMessageProperties;
class MsmqElement
{
public:
	explicit MsmqElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend std::wostream& operator<<(std::wostream& wstr, const MsmqElement& Msmq);

private:		
	const CQmPacket& m_pkt;
};

void MsmqToProps(XmlNode& Node, CMessageProperties* pMessageProperties);





#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mp\lib\envprops.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envprops.h

Abstract:
    Header for serialization\deserialization of the properties element to\from the  srmp envelop.


Author:
    Gil Shafriri(gilsh) 11-DEC-00

--*/

#pragma once

#ifndef _MSMQ_envprops_H_
#define _MSMQ_envprops_H_

class CQmPacket;
class XmlNode;
class CMessageProperties;
class PropertiesElement
{
public:
	explicit PropertiesElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend  std::wostream& operator<<(std::wostream& wstr, const PropertiesElement& Properties);
	
private:
const CQmPacket& m_pkt;
};


void PropertiesToProps(XmlNode& Node , CMessageProperties* pMessageProperties);




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mp\lib\envparser.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envparser.h

Abstract:
    Header for parsing logic of SRMP envelop.

	The parsing logic is to iterate over all xml elements  and
	for each one of the to look for the spesific parsing routing in  ParseElements
	array (The look up is done by element name). If the element is found - the appropriate
	parsing routine is called. If the element is not found , it means that it is not supported,
	in that case it is ignored unless it has "mustunderstand" attribute. In that case parsing
	is aborted and bad_srmp exception is thrown.


Author:
    Gil Shafriri(gilsh) 11-DEC-00

--*/

#pragma once

#ifndef _MSMQ_envparser_H_
#define _MSMQ_envparser_H_
#include <xstr.h>


class CMessageProperties;
class Envelop;
class XmlNode;

typedef void (*ParseFunc)(XmlNode& Envelop, CMessageProperties* pMessageProperties); 


struct	CParseElement
{
	CParseElement(
		const xwcs_t& ElementName, 
		ParseFunc parseFunc,
		size_t MinOccurrence,
		size_t MaxOccurrence
		):
		m_ElementName(ElementName),
		m_ParseFunc(parseFunc),
		m_MinOccurrence(MinOccurrence),
		m_MaxOccurrence(MaxOccurrence),
		m_ActualOccurrence(0)
		{
		}


	bool operator==(const xwcs_t& ElementName) const
	{
		return ElementName == m_ElementName;
	}

	xwcs_t	m_ElementName;
	ParseFunc m_ParseFunc;
	size_t m_MinOccurrence;
	size_t m_MaxOccurrence;
	size_t m_ActualOccurrence;
};


void 
NodeToProps(
	XmlNode& Node, 
	CParseElement* ParseElements,
	size_t cbParseArraySize,
	CMessageProperties* pMessageProperties
	);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mp\lib\envprops.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envprops.cpp

Abstract:
    Implements serialization\deserialization of the properties element to\from the  srmp envelop.


Author:
    Gil Shafriri(gilsh) 11-DEC-00

--*/

#include <libpch.h>
#include <qmpkt.h>
#include <timeutl.h>
#include <xml.h>
#include <mp.h>
#include "envprops.h"
#include "envcommon.h"
#include "mpp.h"
#include "envparser.h"
#include "proptopkt.h"

#include "envprops.tmh"

using namespace std;

class  AbsoluteTimeToLiveElement
{
public:
	explicit AbsoluteTimeToLiveElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend  wostream& operator<<(wostream& wstr, const AbsoluteTimeToLiveElement& TimeToLive)
	{
		wstr<<OpenTag(xExpiresAt)
			<<AbsoluteTimeToLiveContent(TimeToLive.m_pkt)
			<<CloseTag(xExpiresAt);

		return wstr;
 	}

private:
	class AbsoluteTimeToLiveContent
	{
	public:
		explicit AbsoluteTimeToLiveContent (const CQmPacket& pkt):m_pkt(pkt){}
		friend  wostream& operator<<(wostream& wstr, const AbsoluteTimeToLiveContent& TimeToLiveContetnt)
		{
			DWORD  AbsoluteTimeToLive = TimeToLiveContetnt.GetExpirationTime();
			return wstr<<CIso8601Time(AbsoluteTimeToLive);
		}
 	

	private:
		DWORD GetExpirationTime() const 
		{
			DWORD AbsoluteTimeToLive = m_pkt.GetAbsoluteTimeToLive();
			return 	min(AbsoluteTimeToLive, LONG_MAX);
		}

	
	private:
		const CQmPacket& m_pkt;

	};


private:
const CQmPacket& m_pkt;
};




class  SentAtElement
{
public:
	explicit SentAtElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend  wostream& operator<<(wostream& wstr, const SentAtElement&  SentAt)
	{
		 wstr<<OpenTag(xSentAt)
			 <<CIso8601Time(SentAt.m_pkt.GetSentTime())
			 <<CloseTag(xSentAt);

		 return wstr; 
	}

private:
const CQmPacket& m_pkt;
};


std::wostream& operator<<(std::wostream& wstr, const PropertiesElement& Properties)
{
		const CQmPacket& pkt = Properties.m_pkt;

		wstr<<OpenTag(xProperties, xSoapmustUnderstandTrue)
			<<AbsoluteTimeToLiveElement(pkt)
			<<SentAtElement(pkt)
			<<CloseTag(xProperties);
		
		return wstr;
}


static void ExpirationToProps(XmlNode& node, CMessageProperties* pProps)
{
	if(node.m_values.empty())
	{
		TrERROR(Mp, "%ls", L"Illegal expiration time"); 
		throw bad_srmp(L"");
	}
	xwcs_t ExpiredAt = node.m_values.front().m_value;

   	SYSTEMTIME SysTime;
	UtlIso8601TimeToSystemTime(ExpiredAt, &SysTime);
	pProps->absoluteTimeToLive = min( numeric_cast<DWORD>(UtlSystemTimeToCrtTime(SysTime)), LONG_MAX);
}


static
DWORD
RelativeTimeToAbsoluteTime(
    DWORD RelativeTimeout
    )
{
  
    DWORD absoluteTimeout = MqSysTime() + RelativeTimeout;
    return (absoluteTimeout < RelativeTimeout) ?  INFINITE : absoluteTimeout;
}


static void DurationToProps(XmlNode& node, CMessageProperties* pProps)
{
	if(node.m_values.empty())
	{
		TrERROR(Mp, "%ls", L"Illegal duration time"); 
		throw bad_srmp(L"");
	}
	xwcs_t Duration = node.m_values.front().m_value;
	DWORD relativeTimeToLive = numeric_cast<DWORD>(UtlIso8601TimeDuration(Duration));
	pProps->absoluteTimeToLive  = RelativeTimeToAbsoluteTime(relativeTimeToLive);
}



static void SentAtElementToProps(XmlNode& node, CMessageProperties* pProps)
{
	if(node.m_values.empty())
	{
		TrERROR(Mp,"%ls", L"Illegal sent time"); 
		throw bad_srmp(L"");
	}
	xwcs_t SentTime = node.m_values.front().m_value;

    SYSTEMTIME SysTime;
    UtlIso8601TimeToSystemTime(SentTime, &SysTime);
	pProps->sentTime = numeric_cast<DWORD>(UtlSystemTimeToCrtTime(SysTime));
}


static void InReplyToToProps(XmlNode& , CMessageProperties* )
{
	//
	// Currently - this one is ignored
	//
}



void PropertiesToProps(XmlNode& Properties, CMessageProperties* pProps)
/*++

Routine Description:
    Parse SRMP endpoints element into MSMQ properties.

Arguments:
	Properties - Properties element in SRMP reperesenation (xml).
	pMessageProperties - Received the parsed properties.

Returned Value:
	None.   

--*/
{
	CParseElement ParseElements[] =	{
										CParseElement(S_XWCS(xExpiresAt), ExpirationToProps, 0 ,1),
										CParseElement(S_XWCS(xDuration), DurationToProps, 0 ,1),
										CParseElement(S_XWCS(xSentAt), SentAtElementToProps, 0 ,1),
										CParseElement(S_XWCS(xInReplyTo), InReplyToToProps, 0 ,1)
									};	

	NodeToProps(Properties, ParseElements, TABLE_SIZE(ParseElements), pProps);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mp\lib\envmsmq.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envmsmq.cpp

Abstract:
    Implements serialization\deserialization of the MSMQ element to\from the  srmp envelop.


Author:
    Gil Shafriri(gilsh) 11-DEC-00

--*/

#include <libpch.h>
#include <qmpkt.h>
#include <fn.h>
#include <xds.h>
#include <timeutl.h>
#include <mp.h>
#include "envmsmq.h"
#include "envcommon.h"
#include "mpp.h"
#include "envparser.h"
#include "proptopkt.h"

#include "envmsmq.tmh"

using namespace std;

class MsmqClassElement
{
public:
	explicit MsmqClassElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend wostream& operator<<(wostream& wstr, const MsmqClassElement&  MsmqClass)
	{
		wstr<<OpenTag(xClass)
			<<MsmqClass.m_pkt.GetClass()
			<<CloseTag(xClass);

		return wstr;
	}

private:		
	const CQmPacket& m_pkt;
};


class MsmqConnectorTypeElement
{
public:
	explicit MsmqConnectorTypeElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend wostream& operator<<(wostream& wstr, const MsmqConnectorTypeElement&  MsmqConnectorType)
	{
		const CQmPacket& pkt = MsmqConnectorType.m_pkt;

		if (!pkt.ConnectorTypeIsIncluded())
			return wstr;

		wstr<<OpenTag(xConnectorType)
			<<GuidElement(*pkt.GetConnectorType()) 
			<<CloseTag(xConnectorType);


		return wstr;
	}

private:		
	const CQmPacket& m_pkt;
};


class MsmqTraceElement
{
public:
	explicit MsmqTraceElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend wostream& operator<<(wostream& wstr, const MsmqTraceElement&  MsmqClass)
	{
		if ((MsmqClass.m_pkt.GetTrace() && MQMSG_SEND_ROUTE_TO_REPORT_QUEUE) == 0)
			return wstr;

		
		return wstr << EmptyElement(xTrace);
	}

private:		
	const CQmPacket& m_pkt;
};



class MsmqJournalElement
{
public:
	explicit MsmqJournalElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend wostream& operator<<(wostream& wstr, const MsmqJournalElement&  MsmqJournal)
	{
		if ((MsmqJournal.m_pkt.GetAuditingMode() & MQMSG_JOURNAL) == 0)
			return 	wstr;

		return wstr << EmptyElement(xJournal);
	}
private:		
	const CQmPacket& m_pkt;
};


class MsmqDeadLetterElement
{
public:
	explicit MsmqDeadLetterElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend wostream& operator<<(wostream& wstr, const MsmqDeadLetterElement&  MsmqDeadLetter)
	{
		if ((MsmqDeadLetter.m_pkt.GetAuditingMode() & MQMSG_DEADLETTER) == 0)
			return wstr;


		return wstr<<EmptyElement(xDeadLetter);
	}
private:		
	const CQmPacket& m_pkt;
};




class MsmqSourceQMGuidElement
{
public:
	explicit MsmqSourceQMGuidElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend wostream& operator<<(wostream& wstr, const MsmqSourceQMGuidElement& MsmqSourceQMGuid)
	{
		CQmPacket& pkt = const_cast<CQmPacket&>(MsmqSourceQMGuid.m_pkt); 

		wstr<<OpenTag(xSourceQmGuid)
			<<GuidElement(*pkt.GetSrcQMGuid())
			<<CloseTag(xSourceQmGuid);

		return wstr;
	}

private:		
	const CQmPacket& m_pkt;
};


	  

class MsmqResponseMqfElement
{
public:
	explicit MsmqResponseMqfElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend wostream& operator<<(wostream& wstr, const MsmqResponseMqfElement& MsmqResponseMqf)
	{
		const CQmPacket& pkt = MsmqResponseMqf.m_pkt;
		ULONG count = pkt.GetNumOfResponseMqfElements();
		if(count == 0)
			return wstr;

		AP<QUEUE_FORMAT> ResponseMqf = new QUEUE_FORMAT[count];
		bool fSuccess = pkt.GetResponseMqf(ResponseMqf.get(), count);
		ASSERT(fSuccess);
		DBG_USED(fSuccess);

		wstr<<OpenTag(xResponseMqf)
			<<XmlEncodeDecorator(CFnSerializeMqf(ResponseMqf.get(), count))
			<<CloseTag(xResponseMqf);

		return wstr;
	}

private:		
	const CQmPacket& m_pkt;
};


class MsmqAdminMqfElement
{
public:
	explicit MsmqAdminMqfElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend wostream& operator<<(wostream& wstr, const MsmqAdminMqfElement& MsmqAdminMqf)
	{
		const CQmPacket& pkt = MsmqAdminMqf.m_pkt;

		ULONG count = pkt.GetNumOfAdminMqfElements();
		if(count == 0)
			return wstr;

		AP<QUEUE_FORMAT> AdminMqf = new QUEUE_FORMAT[count];
		bool fSuccess = pkt.GetAdminMqf(AdminMqf.get(), count);
		ASSERT(fSuccess);
		DBG_USED(fSuccess);

		wstr<<OpenTag(xAdminMqf)
			<<XmlEncodeDecorator(CFnSerializeMqf(AdminMqf.get(), count))
			<<CloseTag(xAdminMqf);

		return wstr;
	}

private:		
	const CQmPacket& m_pkt;
};



class MsmqDestinationMqfElement
{
public:
	explicit MsmqDestinationMqfElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend wostream& operator<<(wostream& wstr, const MsmqDestinationMqfElement& MsmqDestinationMqf)
	{
		const CQmPacket& pkt = MsmqDestinationMqf.m_pkt;

		ULONG count = pkt.GetNumOfDestinationMqfElements();
		if(count == 0)
			return wstr;

		AP<QUEUE_FORMAT> DestinationMqf = new QUEUE_FORMAT[count];
		bool fSuccess = pkt.GetDestinationMqf(DestinationMqf.get(), count);
		ASSERT(fSuccess);
		DBG_USED(fSuccess);

		wstr<<OpenTag(xDestinationMqf)
			<<XmlEncodeDecorator(CFnSerializeMqf(DestinationMqf.get(), count))
			<<CloseTag(xDestinationMqf);


		return wstr;
	}

private:		
	const CQmPacket& m_pkt;
};



class MsmqCorrelationElement
{
public:
	explicit MsmqCorrelationElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend wostream& operator<<(wostream& wstr, const MsmqCorrelationElement&  MsmqCorrelation)
	{
		wstr <<OpenTag(xCorrelation)
			 <<MsmqCorrelationContent(MsmqCorrelation.m_pkt)
			 <<CloseTag(xCorrelation);

		return wstr;
	}

private:
	class MsmqCorrelationContent
	{
	public:
		explicit MsmqCorrelationContent(const CQmPacket& pkt):m_pkt(pkt){}
		friend wostream& operator<<(wostream& wstr, const MsmqCorrelationContent&  MsmqCorrelation)
		{
			DWORD temp;
			AP<WCHAR> pCorrelation = Octet2Base64W(MsmqCorrelation.m_pkt.GetCorrelation(), 
										PROPID_M_CORRELATIONID_SIZE, 
										&temp);

			return wstr<<pCorrelation.get();
		}
	private:
		const CQmPacket& m_pkt;
	};


private:
	const CQmPacket& m_pkt;
};



class MsmqSecurityElement
{
public:
	explicit MsmqSecurityElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend wostream& operator<<(wostream& wstr, const MsmqSecurityElement&  MsmqSecurity)
	{
		const CQmPacket& pkt = MsmqSecurity.m_pkt; 
		ASSERT(!pkt.IsEncrypted());

		if (!pkt.IsSecurInc())
			return wstr;

		//
		// Get sender certificate size. If the message isn't authenticated there is no meaning 
		// to send the provider information
		//
		USHORT signatureSize;
		pkt.GetSignature(&signatureSize);

		if(signatureSize == 0)
			return wstr;

		BOOL fDefaultProvider;
		LPCWSTR providerName = NULL;
		DWORD providerType = 0;

		pkt.GetProvInfo(&fDefaultProvider, &providerName, &providerType);
		if (fDefaultProvider)
			return wstr;
		 

		wstr<<OpenTag(xProvider)
			<<ProviderTypeElement(providerType)
			<<ProviderNameElement(providerName)
			<<CloseTag(xProvider);

		return wstr;
	}


private:
	class ProviderTypeElement
	{
	public:
		ProviderTypeElement(DWORD Type):m_Type(Type){}
		friend wostream& operator<<(wostream& wstr, const ProviderTypeElement&  ProviderType)
		{
			wstr<<OpenTag(xType)
				<<ProviderType.m_Type 
				<<CloseTag(xType);

			return wstr;
		}
		
	private:
		DWORD m_Type;
	};


	class ProviderNameElement
	{
	public:
		ProviderNameElement(LPCWSTR Name):m_Name(Name){}
		friend wostream& operator<<(wostream& wstr, const ProviderNameElement&  ProviderName)
		{
			wstr<<OpenTag(xName)
				<<ProviderName.m_Name 
				<<CloseTag(xName);

			return wstr;
		}
		
	private:
		LPCWSTR m_Name;
	};


private:
	const CQmPacket& m_pkt;
};


class MsmqEodElement
{
public:
	explicit MsmqEodElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend wostream& operator<<(wostream& wstr, const MsmqEodElement&  MsmqEod)
	{
		const CQmPacket& pkt = MsmqEod.m_pkt;
   
		if (! pkt.IsOrdered())
			return wstr;

		wstr<<OpenTag(xEod)
			<<ConnectorElement(pkt)
			<<FirstElement(pkt)
			<<LastElement(pkt)
			<<CloseTag(xEod);

		return wstr;
	}


private:
	class ConnectorElement
	{
	public:
		ConnectorElement(const CQmPacket& pkt):m_pkt(pkt){}
		friend wostream& operator<<(wostream& wstr, const ConnectorElement&  Connector)
		{
			const GUID* pConnector = Connector.m_pkt.GetConnectorQM();
			if(pConnector == NULL)
				return wstr;

			wstr<<OpenTag(xConnectorId)
				<<GuidElement(*pConnector)
				<<CloseTag(xConnectorId);

			return wstr;
		}

	private:
		const CQmPacket& m_pkt;
	};


	class FirstElement
	{
	public:
		FirstElement(const CQmPacket& pkt):m_pkt(pkt){}
		friend wostream& operator<<(wostream& wstr, const FirstElement&  First)
		{
			if(!First.m_pkt.IsFirstInXact())
				return 	wstr;

			return wstr << EmptyElement(xFirst);
		}

	private:
		const CQmPacket& m_pkt;
	};


	class LastElement
	{
	public:
		LastElement(const CQmPacket& pkt):m_pkt(pkt){}
		friend wostream& operator<<(wostream& wstr, const LastElement&  Last)
		{
			if(!Last.m_pkt.IsLastInXact())
				return 	wstr;

			return wstr << EmptyElement(xLast);
		}

	private:
		const CQmPacket& m_pkt;
	};


private:		
	const CQmPacket& m_pkt;
};



class  MsmqHashAlgorithmElement
{
public:
	explicit MsmqHashAlgorithmElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend wostream& operator<<(wostream& wstr, const MsmqHashAlgorithmElement&  MsmqHashAlgorithm)
	{
		 wstr<<OpenTag(xHashAlgorithm)
			 <<MsmqHashAlgorithm.m_pkt.GetHashAlg() 
			 <<CloseTag(xHashAlgorithm);

		 return  wstr;
	}

private:		
	const CQmPacket& m_pkt;
};


class MsmqBodyTypeElement
{
public:
	explicit MsmqBodyTypeElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend wostream& operator<<(wostream& wstr, const MsmqBodyTypeElement&  MsmqBodyType)
	{
		 wstr<<OpenTag(xBodyType) 
			 <<MsmqBodyType.m_pkt.GetBodyType() 
			 <<CloseTag(xBodyType);

		 return wstr;
	}

private:		
	const CQmPacket& m_pkt;
};


class MsmqAppElement
{
public:
	explicit MsmqAppElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend wostream& operator<<(wostream& wstr, const MsmqAppElement&  MsmqApp)
	{
		wstr<<OpenTag(xApp)
			<<MsmqApp.m_pkt.GetApplicationTag()
			<<CloseTag(xApp);

		 return wstr;
	}

private:		
	const CQmPacket& m_pkt;
};


class MsmqPriorityElement
{
public:
	explicit MsmqPriorityElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend wostream& operator<<(wostream& wstr, const MsmqPriorityElement&  MsmqPriority)
	{
		wstr<<OpenTag(xPriority)
			<<MsmqPriority.m_pkt.GetPriority() 
			<<CloseTag(xPriority);

		return wstr;
	}

private:		
	const CQmPacket& m_pkt;
};


class MsmqAbsoluteTimeToQueueElement
{
public:
	explicit MsmqAbsoluteTimeToQueueElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend wostream& operator<<(wostream& wstr, const MsmqAbsoluteTimeToQueueElement&  TimeToQueue)
	{
		wstr<<OpenTag(xTTrq)
			<<MsmqAbsoluteTimeToQueueContent(TimeToQueue.m_pkt) 
			<<CloseTag(xTTrq);

		return wstr;
	}

private:
	class  MsmqAbsoluteTimeToQueueContent
	{
	public:
		explicit MsmqAbsoluteTimeToQueueContent(const CQmPacket& pkt):m_pkt(pkt){}
		friend wostream& operator<<(wostream& wstr, const MsmqAbsoluteTimeToQueueContent&  TimeToQueueContent)
		{
			DWORD  AbsoluteTimeToQueue = min(TimeToQueueContent.m_pkt.GetAbsoluteTimeToQueue(), LONG_MAX);
			return wstr<<CIso8601Time(AbsoluteTimeToQueue);
		}


	private:
	const CQmPacket& m_pkt;
	};


private:
	const CQmPacket& m_pkt;
};




std::wostream& operator<<(std::wostream& wstr, const MsmqElement& Msmq)
{
		const CQmPacket& pkt = 	Msmq.m_pkt;

		wstr<<OpenTag(xMsmq , L"xmlns=\"msmq.namespace.xml\"")
			<<MsmqClassElement(pkt)
			<<MsmqPriorityElement(pkt)
			<<MsmqJournalElement(pkt)
			<<MsmqDeadLetterElement(pkt)
			<<MsmqCorrelationElement(pkt)
			<<MsmqTraceElement(pkt)
			<<MsmqConnectorTypeElement(pkt)
			<<MsmqAppElement(pkt)
			<<MsmqBodyTypeElement(pkt)
			<<MsmqHashAlgorithmElement(pkt)
			<<MsmqEodElement(pkt)
			<<MsmqSecurityElement(pkt)
			<<MsmqSourceQMGuidElement(pkt)
			<<MsmqDestinationMqfElement(pkt) 
			<<MsmqAdminMqfElement(pkt) 
			<<MsmqResponseMqfElement(pkt)
			<<MsmqAbsoluteTimeToQueueElement(pkt)
			<<CloseTag(xMsmq);

		return wstr;
}



static void MsmqClassToProps(XmlNode& node, CMessageProperties* pProps)
{
		if(node.m_values.empty())
		{
			TrERROR(Mp,"%ls", L"Illegal class value"); 
			throw bad_srmp(L"");
		}

		xwcs_t Class =  node.m_values.front().m_value;
		if(Class.Length() == 0)
		{
			TrERROR(Mp,"%ls", L"Illegal class value"); 
			throw bad_srmp(L"");
		}

		pProps->classValue = static_cast<USHORT>(_wtoi(Class.Buffer()));

  		if (! MQCLASS_IS_VALID(pProps->classValue))
		{
			TrERROR(Mp,"%ls", L"Illegal class value"); 
			throw bad_srmp(L"");
		}
}


static void MsmqPriorityToProps(XmlNode& node, CMessageProperties* pProp)
{
	if(node.m_values.empty())
	{
		TrERROR(Mp,"%ls", L"Illegal Priority value"); 
		throw bad_srmp(L"");
	}

	xwcs_t Priority =  node.m_values.front().m_value;
	if(Priority.Length() == 0)
	{
		TrERROR(Mp,"%ls", L"Illegal Priority value"); 
		throw bad_srmp(L"");
	}

    pProp->priority = static_cast<UCHAR>(_wtoi(Priority.Buffer()));
    if (pProp->priority > MQ_MAX_PRIORITY)
    {
		TrERROR(Mp,"%ls", L"Illegal Priority value"); 
		throw bad_srmp(L"");
	}

}


static void MsmqJournalToProps(XmlNode& , CMessageProperties* pProp)
{
	pProp->auditing |= MQMSG_JOURNAL;
}


static void MsmqDeadLetterToProps(XmlNode& , CMessageProperties* pProp)
{
	pProp->auditing  |= MQMSG_DEADLETTER;
}


static void MsmqCorrelationToProps(XmlNode& node, CMessageProperties* pProp)
{
	if(node.m_values.empty())
	{
		TrERROR(Mp,"%ls", L"Illegal Correlation value"); 
		throw bad_srmp(L"");
	}

	xwcs_t Correlation =  node.m_values.front().m_value;
	if(Correlation.Length() == 0)
	{
		TrERROR(Mp,"%ls", L"Illegal Correlation value"); 
		throw bad_srmp(L"");
	}

    DWORD temp;
    pProp->pCorrelation = Base642OctetW(Correlation.Buffer(), Correlation.Length(), &temp); 
    ASSERT(temp == PROPID_M_CORRELATIONID_SIZE);
}


static void MsmqTraceToProps(XmlNode& , CMessageProperties* pProp)
{
	pProp->fTrace = true;
}


static void MsmqConnectorTypeToProps(XmlNode& node, CMessageProperties* pProp)
{
	if(node.m_values.empty())
	{
		TrERROR(Mp,"%ls", L"Illegal ConnectorType value"); 
		throw bad_srmp(L"");
	}

	xwcs_t ConnectorType =  node.m_values.front().m_value;

	if(ConnectorType.Length() == 0)
	{
		TrERROR(Mp,"%ls", L"Illegal ConnectorType value"); 
		throw bad_srmp(L"");
	}

    StringToGuid(ConnectorType.Buffer(), &pProp->connectorType);
}


static void MsmqAppToProps(XmlNode& node, CMessageProperties* pProp)
{
	if(node.m_values.empty())
	{
		TrERROR(Mp,"%ls", L"Illegal App spesific value"); 
		throw bad_srmp(L"");
	}
	xwcs_t Appspesific =  node.m_values.front().m_value;

	if(Appspesific.Length() == 0)
	{
		TrERROR(Mp,"%ls", L"Illegal App spesific value"); 
		throw bad_srmp(L"");
	}
    pProp->applicationTag = _wtoi(Appspesific.Buffer());
}


static void MsmqBodyTypeToProps(XmlNode& node, CMessageProperties* pProp)
{
	if(node.m_values.empty())
	{
		TrERROR(Mp,"%ls",L"Illegal Body type value"); 
		throw bad_srmp(L"");
	}

	xwcs_t Bodytype  =  node.m_values.front().m_value;

	if(Bodytype.Length() == 0)
	{
		TrERROR(Mp,"%ls",L"Illegal Body type value"); 
		throw bad_srmp(L"");
	}

	pProp->bodyType = _wtoi(Bodytype.Buffer());
}



static void MsmqHashAlgorithmToProps(XmlNode& node, CMessageProperties* pProp)
{
	if(node.m_values.empty())
	{
		TrERROR(Mp,"%ls",L"Illegal Hash Algorith value"); 
		throw bad_srmp(L"");
	}

	xwcs_t HashAlgorith  =  node.m_values.front().m_value;

	if(HashAlgorith.Length() == 0)
	{
		TrERROR(Mp,"%ls",L"Illegal Hash Algorith value"); 
		throw bad_srmp(L"");
	}

    pProp->hashAlgorithm = _wtoi(HashAlgorith.Buffer());
}


static void MsmqEodFirstToProps(XmlNode& , CMessageProperties* pProp)
{
	 pProp->fFirst = true;
}


static void MsmqEodLastToProps(XmlNode& , CMessageProperties* pProp)
{
	pProp->fLast = true;
}


static void MsmqConnectorIdToProps(XmlNode& node, CMessageProperties* pProps)
{
	if(node.m_values.empty())
	{
		TrERROR(Mp,"%ls",L"Illegal connector id value"); 
		throw bad_srmp(L"");
	}

	xwcs_t connectorId  =  node.m_values.front().m_value;

	if(connectorId.Length() == 0)
	{
		TrERROR(Mp,"%ls",L"Illegal connector id value"); 
		throw bad_srmp(L"");
	}
	StringToGuid(connectorId.Buffer(), &pProps->connectorId);
}



static void MsmqEodToProps(XmlNode& node, CMessageProperties* pProps)
{
	CParseElement ParseElements[] =	{
										CParseElement(S_XWCS(xFirst), MsmqEodFirstToProps, 0,1),
										CParseElement(S_XWCS(xLast),MsmqEodLastToProps,0 ,1),
										CParseElement(S_XWCS(xConnectorId),MsmqConnectorIdToProps,0 ,1)
									};

	NodeToProps(node, ParseElements, TABLE_SIZE(ParseElements), pProps);
}

	

static void MsmqSecurityProviderTypeToProps(XmlNode& node, CMessageProperties* pProps)
{
	if(node.m_values.empty())
	{
		TrERROR(Mp,"%ls",L"Illegal security provider name value"); 
		throw bad_srmp(L"");
	}

	xwcs_t ProviderType = node.m_values.front().m_value;
	if(ProviderType.Length() == 0)
	{
		TrERROR(Mp,"%ls",L"Illegal security provider name value"); 
		throw bad_srmp(L"");
	}

	pProps->providerType = _wtoi(ProviderType.Buffer());
}


static void MsmqSecurityProviderNameToProps(XmlNode& node, CMessageProperties* pProps)
{
	if(node.m_values.empty())
	{
		TrERROR(Mp,"%ls",L"Illegal security provider name value"); 
		throw bad_srmp(L"");
	}

	xwcs_t ProviderName = node.m_values.front().m_value;
	if(ProviderName.Length() == 0)
	{
		TrERROR(Mp,"%ls",L"Illegal security provider name value"); 
		throw bad_srmp(L"");
	}

	pProps->providerName = ProviderName;
}


static void MsmqSecurityProviderToProps(XmlNode& node, CMessageProperties* pProps)
{
	pProps->fDefaultProvider = false;
	CParseElement ParseElements[] =	{
										CParseElement(S_XWCS(xType),MsmqSecurityProviderTypeToProps,1 ,1),
										CParseElement(S_XWCS(xName),MsmqSecurityProviderNameToProps,1 ,1)
									};

	NodeToProps(node, ParseElements, TABLE_SIZE(ParseElements), pProps);
}


static void MsmqSourceQMGuidToProps(XmlNode& node, CMessageProperties* pProps)
{
	if(node.m_values.empty())
	{
		TrERROR(Mp,"%ls", L"Illegal Source QM Guid value"); 
		throw bad_srmp(L"");
	}

	xwcs_t SourceQMGuid= node.m_values.front().m_value;
	if(SourceQMGuid.Length() == 0)
	{
		TrERROR(Mp,"%ls", L"Illegal Source QM Guid value"); 
		throw bad_srmp(L"");
	}

    StringToGuid(SourceQMGuid.Buffer(), &pProps->SourceQmGuid);
}


static void MsmqDestinationMqfToProps(XmlNode& node, CMessageProperties* pProps)
{
	if(node.m_values.empty())
	{
		TrERROR(Mp,"%ls", L"Illegal Destination mqf value"); 
		throw bad_srmp(L"");
	}

	xwcs_t DestinationMqf = node.m_values.front().m_value;
	if(DestinationMqf.Length() == 0)
	{
		TrERROR(Mp,"%ls", L"Illegal Destination mqf value"); 
		throw bad_srmp(L"");
	}

	CXmlDecode XmlDecode;
	XmlDecode.Decode(DestinationMqf);

	pProps->destMqf.CreateFromMqf(XmlDecode.get());		
}


static void MsmqAdminMqfToProps(XmlNode& node, CMessageProperties* pProps)
{
	if(node.m_values.empty())
	{
		TrERROR(Mp,"%ls", L"Illegal Admin mqf value"); 
		throw bad_srmp(L"");
	}

	xwcs_t AdminMqf = node.m_values.front().m_value;
	if(AdminMqf.Length() == 0)
	{
		TrERROR(Mp,"%ls", L"Illegal Admin mqf value"); 
		throw bad_srmp(L"");
	}

	CXmlDecode XmlDecode;
	XmlDecode.Decode(AdminMqf);


	pProps->adminMqf.CreateFromMqf(XmlDecode.get());		
}


static void MsmqResponseMqfElementToProps(XmlNode& node, CMessageProperties* pProps)
{
	if(node.m_values.empty())
	{
		TrERROR(Mp,"%ls", L"Illegal Response mqf value"); 
		throw bad_srmp(L"");
	}
	xwcs_t ResponseMqf = node.m_values.front().m_value;
	if(ResponseMqf.Length() == 0)
	{
		TrERROR(Mp,"%ls", L"Illegal Response mqf value"); 
		throw bad_srmp(L"");
	}

	CXmlDecode XmlDecode;
	XmlDecode.Decode(ResponseMqf);


	pProps->responseMqf.CreateFromMqf(XmlDecode.get());		
}

void MsmqTTrqProps(XmlNode& node, CMessageProperties* pMessageProperties)
{
	if(node.m_values.empty())
	{
		TrERROR(Mp,"%ls", L"Illegal trq value"); 
		throw bad_srmp(L"");
	}

	xwcs_t Trq = node.m_values.front().m_value;
	if(Trq.Length() == 0)
	{
		TrERROR(Mp,"%ls", L"Illegal trq value"); 
		throw bad_srmp(L"");
	}

	SYSTEMTIME SysTime;
	UtlIso8601TimeToSystemTime(Trq, &SysTime);
	pMessageProperties->absoluteTimeToQueue = min( numeric_cast<DWORD>(UtlSystemTimeToCrtTime(SysTime)), LONG_MAX);
}


					 

void MsmqToProps(XmlNode& Msmq, CMessageProperties* pMessageProperties)
/*++

Routine Description:
    Parse SRMP MSMQ element into MSMQ properties.

Arguments:
	Msmq - MSMQ element in SRMP reperesenation (xml).
	pMessageProperties - Received the parsed properties.

Returned Value:
	None.   

--*/
{
	pMessageProperties->fMSMQSectionIncluded = true;
	pMessageProperties->fDefaultProvider = true;


	 CParseElement ParseElements[] =	{
											CParseElement(S_XWCS(xClass), MsmqClassToProps, 1,1),
											CParseElement(S_XWCS(xPriority),MsmqPriorityToProps, 1,1),
											CParseElement(S_XWCS(xJournal), MsmqJournalToProps, 0,1),
											CParseElement(S_XWCS(xDeadLetter), MsmqDeadLetterToProps, 0,1),
											CParseElement(S_XWCS(xCorrelation), MsmqCorrelationToProps,0 ,1),
											CParseElement(S_XWCS(xTrace), MsmqTraceToProps,0 ,1),
											CParseElement(S_XWCS(xConnectorType), MsmqConnectorTypeToProps, 0, 1),
											CParseElement(S_XWCS(xApp), MsmqAppToProps,0 ,1),
											CParseElement(S_XWCS(xBodyType), MsmqBodyTypeToProps, 1, 1),
											CParseElement(S_XWCS(xHashAlgorithm), MsmqHashAlgorithmToProps,0 ,1),
											CParseElement(S_XWCS(xEod), MsmqEodToProps, 0, 1),
											CParseElement(S_XWCS(xProvider), MsmqSecurityProviderToProps, 0,1),
											CParseElement(S_XWCS(xSourceQmGuid), MsmqSourceQMGuidToProps,1, 1),
											CParseElement(S_XWCS(xDestinationMqf), MsmqDestinationMqfToProps, 0 ,1),
											CParseElement(S_XWCS(xAdminMqf), MsmqAdminMqfToProps, 0 ,1),
											CParseElement(S_XWCS(xResponseMqf), MsmqResponseMqfElementToProps,0 ,1),
											CParseElement(S_XWCS(xTTrq), MsmqTTrqProps, 1 ,1),
										};	

	NodeToProps(Msmq, ParseElements, TABLE_SIZE(ParseElements), pMessageProperties);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mp\lib\envsec.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envsec.h

Abstract:
    Header for serialization\deserialization of the signature  element to\from the  srmp envelop.

Author:
    Gil Shafriri(gilsh) 11-DEC-00

--*/

#pragma once

#ifndef _MSMQ_envsec_H_
#define _MSMQ_envsec_H_


class CQmPacket;
class XmlNode;
class CMessageProperties;
class SignatureElement
{
public:
	explicit SignatureElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend std::wostream& operator<<(std::wostream& wstr, const SignatureElement& Signature);
	
private:		
	const CQmPacket& m_pkt;
};


void SignatureToProps(XmlNode& Node, CMessageProperties* pMessageProperties);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mp\lib\envparser.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envparser.cpp

Abstract:
    Implements the parsing logic of SRMP envelop.


Author:
    Gil Shafriri(gilsh) 11-DEC-00

--*/
#include <libpch.h>
#include <xml.h>
#include <mp.h>
#include <envcommon.h>
#include "envparser.h"
#include "mpp.h"

#include "envparser.tmh"

static bool IsMustUnderstand(const XmlNode& Node)
{
	const xwcs_t* MustUnderstandValue = XmlGetAttributeValue(&Node, xmustUnderstandAttribute);
	return (MustUnderstandValue != NULL) && (*MustUnderstandValue == xmustUnderstandTrueValue);
}
			   


static void CheckNumberOfOccurrence(const CParseElement& ParseElement)
{
	if(ParseElement.m_ActualOccurrence > ParseElement.m_MaxOccurrence 
		|| ParseElement.m_ActualOccurrence  < ParseElement.m_MinOccurrence)
	{
			TrERROR(Mp, "number of Occurrence of element is illegal %.*ls", LOG_XWCS(ParseElement.m_ElementName));       
			throw bad_srmp(L"");
	}
}




void 
NodeToProps(
	XmlNode& Node, 
	CParseElement* ParseElements,
	size_t cbParseArraySize,
	CMessageProperties* pMessageProperties
	)
/*++

Routine Description:
    Parsing xml node and convert it to MSMQ properties.

Arguments:
	Envelop - envelop in SRMP reperesenation (xml).

	ParseElements - pointer to array of elements that are supported for this node.
					for each element ther is spesific parsing routine.

	cbParseArraySize - Number of elements in ParseElements.

	pMessageProperties - Received the parsed properties.

Returned Value:
	None.  
	
Note:
	The parsing logic is to iterate over all xml elements  and
	for each one of the to look for the spesific parsing routing in  ParseElements
	array (The look up is done by element name). If the element is found - the appropriate
	parsing routine is called. If the element is not found , it means that it is not supported,
	in that case it is ignored unless it has "mustunderstand" attribute. In that case parsing
	is aborted and bad_srmp exception is thrown.

--*/
{
	CParseElement* ParseElementsEnd = ParseElements +  cbParseArraySize;

	for(List<XmlNode>::iterator it = Node.m_nodes.begin(); it != Node.m_nodes.end(); ++it)
	{
		CParseElement* found =  std::find(
										ParseElements,
										ParseElementsEnd,
										it->m_tag
										);

		if(found !=  ParseElementsEnd)
		{
			found->m_ParseFunc(*it, pMessageProperties);
			++found->m_ActualOccurrence;
			continue;
		}

		if(IsMustUnderstand(*it))
		{
				TrERROR(Mp, "could not understand SRMP element %.*ls", LOG_XWCS(it->m_tag));       
				throw bad_srmp(L"");
		}
	}
	
	//
	// check the correct number of Occurrence in each element
	//
	std::for_each(ParseElements,  ParseElementsEnd, CheckNumberOfOccurrence);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mp\lib\envsec.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envsec.cpp

Abstract:
    Implements serialization and deserialization of the signature element of the  srmp envelop.

Author:
    Gil Shafriri(gilsh) 11-DEC-00

--*/

#include <libpch.h>
#include <qmpkt.h>
#include <xml.h>
#include <mp.h>
#include <proptopkt.h>
#include "mpp.h"
#include "envsec.h"
#include "envcommon.h"

#include "envsec.tmh"

using namespace std;

wostream& operator<<(wostream& wstr, const SignatureElement& Signature)
{
		USHORT signatureSize;
		const BYTE* pSignature = Signature.m_pkt.GetSignature(&signatureSize);
 		if (signatureSize == 0)
			return wstr;

		//
		// XMLDSIG is in utf8 format, convert it to unicode
		//
		wstring pSignatureW = UtlUtf8ToWcs(pSignature, signatureSize);

		wstr<<pSignatureW;
		return wstr;
}


void SignatureToProps(XmlNode& node, CMessageProperties* pProps)
{
	//
	// The signature on the received packet should be utf8 format.
	// the same format as the sending packet.
	//
	pProps->signature = UtlWcsToUtf8(node.m_element.Buffer(), node.m_element.Length());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mp\lib\envservice.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envelopheader.h

Abstract:
    Header for Serialization and Deserialization of srmp envelop service element

Author:
    Gil Shafriri(gilsh) 11-DEC-00

--*/

#pragma once

#ifndef _MSMQ_envservice_H_
#define _MSMQ_envservice_H_

class CQmPacket;
class XmlNode;
class CMessageProperties;
class ServiceElement
{
public:
	explicit ServiceElement(const CQmPacket& pkt):m_pkt(pkt){}
	bool IsIncluded() const;
	friend std::wostream& operator<<(std::wostream& wstr, const ServiceElement&  Service);
	
private:
	const CQmPacket& m_pkt;
};

void ServiceToProps(XmlNode& Node, CMessageProperties* pMessageProperties);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mp\lib\envservice.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envservice.cpp

Abstract:
    Implements serialization\deserialization of the signature  element to\from the  srmp envelop.


Author:
    Gil Shafriri(gilsh) 11-DEC-00

--*/

#include <libpch.h>
#include <qmpkt.h>
#include <proptopkt.h>
#include "envservice.h"
#include "envcommon.h"
#include "mpp.h"
#include "envparser.h"
#include "envdelreceiptreq.h"
#include "envcomreceiptreq.h"

#include "envservice.tmh"

using namespace std;


class DurableElement
{
public:
	explicit DurableElement(const CQmPacket& pkt):m_pkt(pkt){}
	bool IsIncluded() const 
	{
		return	const_cast<CQmPacket&>(m_pkt).IsRecoverable() == TRUE;
	}

	friend  wostream& operator<<(wostream& wstr, const DurableElement& Durable)
	{
		if (!Durable.IsIncluded())
			return wstr;

		wstr<<EmptyElement(xDurable);
		return wstr;
	}


private:
const CQmPacket& m_pkt;
};




bool ServiceElement::IsIncluded() const
{
	return 	DurableElement(m_pkt).IsIncluded() || 
			DeliveryReceiptRequestElement(m_pkt).IsIncluded()||
			CommitmentReceiptRequestElement(m_pkt).IsIncluded();

}


wostream& operator<<(std::wostream& wstr, const ServiceElement&  Service)
{
		if(!Service.IsIncluded())
			return 	wstr;

		const CQmPacket& pkt = Service.m_pkt;
		
		wstr<<OpenTag(xServices, xSoapmustUnderstandTrue)
			<<DurableElement(pkt)
			<<DeliveryReceiptRequestElement(pkt)
			<<CommitmentReceiptRequestElement(pkt)
			<<CloseTag(xServices);


		return wstr;
}



static void DurableToProps(XmlNode& , CMessageProperties* pProps)
{
    pProps->delivery = MQMSG_DELIVERY_RECOVERABLE;
}



void ServiceToProps(XmlNode& Service , CMessageProperties* pMessageProperties)
/*++

Routine Description:
    Parse SRMP Service element into MSMQ properties.

Arguments:
	Service - Service element in SRMP reperesenation (xml).
	pMessageProperties - Received the parsed properties.

Returned Value:
	None.   

--*/
{
	CParseElement ParseElements[] =	{
										CParseElement(S_XWCS(xDurable), DurableToProps, 0 ,1),
										CParseElement(S_XWCS(xDeliveryReceiptRequest), DeliveryReceiptRequestToProps, 0 ,1),
										CParseElement(S_XWCS(xFilterDuplicates), EmptyNodeToProps, 0 ,1),
										CParseElement(S_XWCS(xCommitmentReceiptRequest), CommitmentReceiptRequestToProps, 0 ,1)
									};	

	NodeToProps(Service, ParseElements, TABLE_SIZE(ParseElements), pMessageProperties);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mp\lib\envstream.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envstream.h

Abstract:
    Header for serialization\deserialization of the stream  element to\from the  srmp envelop.

Author:
    Gil Shafriri(gilsh) 11-DEC-00

--*/

#pragma once

#ifndef _MSMQ_stream_H_
#define _MSMQ_stream_H_

class CQmPacket;
class XmlNode;
class CMessageProperties;
class StreamElement
{
public:
	explicit StreamElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend std::wostream& operator<<(std::wostream& wstr, const StreamElement& Stream);

private:		
	const CQmPacket& m_pkt;
};
void StreamToProps(XmlNode& Node, CMessageProperties* pMessageProperties);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mp\lib\envstreamreceipt.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envstreamreceipt.h

Abstract:
    Header for serialization\deserialization of the stream receipt  element to\from the  srmp envelop.

Author:
    Gil Shafriri(gilsh) 11-DEC-00

--*/

#pragma once

#ifndef _MSMQ_streamreceipt_H_
#define _MSMQ_streamreceipt_H_

class CQmPacket;
class XmlNode;
class CMessageProperties;
class  StreamReceiptElement
{
public:
	explicit StreamReceiptElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend std::wostream& operator<<(std::wostream& wstr, const StreamReceiptElement& StreamReceipt);
	
private:		
	const CQmPacket& m_pkt;
};

void StreamReceiptToProps(XmlNode& Node , CMessageProperties* pMessageProperties);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mp\lib\envusrheader.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envbody.h

Abstract:
    Header for serialization of the user supplied header to the SRMP envelop.
	

Author:
    Gil Shafriri(gilsh) 24-APRIL-01

--*/

#pragma once

#ifndef _MSMQ_envusrheader_H_
#define _MSMQ_envusrheader_H_

class CQmPacket;


class UserHeaderElement
{
public:
	explicit UserHeaderElement(const CQmPacket& pkt):m_pkt(pkt){}
   	friend std::wostream& operator<<(std::wostream& wstr, const UserHeaderElement&);

private:
	const CQmPacket& m_pkt;
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mp\lib\envusrheader.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envbody.cpp

Abstract:
    Implementing  serialization of the user supplied header to the SRMP envelop


Author:
    Gil Shafriri(gilsh) 24-APRIL-01

--*/
#include <libpch.h>
#include <qmpkt.h>
#include "envcommon.h"
#include "envusrheader.h"

using namespace std;


std::wostream& operator<<(std::wostream& wstr, const UserHeaderElement& UserHeader)
{
	if(!UserHeader.m_pkt.IsSoapIncluded() )
		return wstr;

	const WCHAR* pUserHeader = UserHeader.m_pkt.GetPointerToSoapHeader();
	if(pUserHeader == NULL)
		return wstr;

	ASSERT(UserHeader.m_pkt.GetSoapHeaderLengthInWCHARs() == wcslen(pUserHeader) +1);

	return wstr<<pUserHeader;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mp\lib\httpmime.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    httpmime.h

Abstract:
    Header for parsing http request to it mime parts.


Author:
    Gil Shafriri(gilsh) 22-MARCH-01


--*/
#ifndef HTTP_MIME_H
#define HTTP_MIME_H
#include "attachments.h"


class CAttachmentsArray;


//-------------------------------------------------------------------
//
// class CHttpReceivedBuffer - holds http parts as received from the network
//
//-------------------------------------------------------------------
class  CHttpReceivedBuffer 
{
public:
		CHttpReceivedBuffer(
		const basic_xstr_t<BYTE>& Body, 
		const char* pHeader
		):
		m_Body(Body),
		m_pHeader(pHeader,strlen(pHeader))  
 		{
		}

public:
	const basic_xstr_t<BYTE> GetBody() const 
	{
		return m_Body;
	}
	
	const xstr_t GetHeader() const 
	{
		return m_pHeader;
	}

	const CAttachmentsArray& GetAttachments()const
	{
		return m_Attachments;
	}

	CAttachmentsArray& GetAttachments()
	{
		return m_Attachments;
	}


private:
	basic_xstr_t<BYTE> m_Body;
	xstr_t m_pHeader;
	CAttachmentsArray m_Attachments;
};


std::wstring 
ParseHttpMime(
	const char* pHttpHeader, 
	DWORD HttpBodySize, 
	const BYTE* pHttpBody, 
	CAttachmentsArray* pAttachments 
	);
  

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mp\lib\envstreamreceipt.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envstreamreceipt.cpp

Abstract:
    Implements serialization\deserialization of the stream receipt  element to\from the  srmp envelop.

Author:
    Gil Shafriri(gilsh) 11-DEC-00

--*/

#include <libpch.h>
#include <qmpkt.h>
#include <xml.h>
#include <proptopkt.h>
#include <mp.h>
#include "envstreamreceipt.h"
#include "envcommon.h"
#include "mpp.h"
#include "envparser.h"

#include "envstreamreceipt.tmh"

using namespace std;


class AckedStreamIdElement
{
public:
	AckedStreamIdElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend wostream& operator<<(wostream& wstr, const AckedStreamIdElement& AckedStreamId)
	{
		const CQmPacket& pkt = 	AckedStreamId.m_pkt;
		const WCHAR* pStreamid = reinterpret_cast<const WCHAR*>(pkt.GetPointerToEodAckStreamId()); 

		wstr<<OpenTag(xStreamId)
			<<pStreamid;
 		//
		// If the streamid was generated by MSMQ we should append to it the seqid
		//
		if(pkt.GetEodAckSeqId() != xNoneMSMQSeqId)
		{
			wstr<<xSlash<<Int64Value(pkt.GetEodAckSeqId());
		}

		wstr<<CloseTag(xStreamId);
		return wstr;
 	}


private:
	const CQmPacket& m_pkt;
};



class AckedStreamNumberElement
{
public:
	AckedStreamNumberElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend wostream& operator<<(wostream& wstr, const AckedStreamNumberElement& AckedStreamNumber)
	{
		wstr<<OpenTag(xlastOrdinal)
			<<Int64Value(AckedStreamNumber.m_pkt.GetEodAckSeqNum())
			<<CloseTag(xlastOrdinal);

		return wstr;
 	}

private:
	const CQmPacket& m_pkt;
};



wostream& operator<<(wostream& wstr, const StreamReceiptElement& StreamReceipt)
{
		const CQmPacket& pkt = 	StreamReceipt.m_pkt;
		
		if ( !pkt.IsEodAckIncluded() )
			return wstr;
			

		wstr<<OpenTag(xStreamReceipt)
			<<AckedStreamIdElement(pkt)		
			<<AckedStreamNumberElement(pkt)
	   		<<CloseTag(xStreamReceipt);

		return wstr;

}


static void AckedStreamIdToProps(XmlNode& node, CMessageProperties* pProps)
{
	if(node.m_values.empty())
	{
		TrERROR(Mp, "%ls", L"Illegal acked stream id"); 
		throw bad_srmp(L"");
	}

	const xwcs_t AckedStreamid = node.m_values.front().m_value;
 
	//
	// The stream id was sent by MSMQ so it of the format xxx\\seqid
	// we should extract the seqid from it.
	//
	bool fParsed = BreakMsmqStreamId(AckedStreamid, &pProps->EodAckStreamId, &pProps->EodAckSeqId);
	if(!fParsed)
	{
		TrERROR(Mp,"Wrong formatted  stream id '%.*ls' accepted in stream receipt element", LOG_XWCS(AckedStreamid));       
		throw bad_srmp(L"");
	}

}


static void AckedStreamNumberToProps(XmlNode& node, CMessageProperties* pProps)
{
	if(node.m_values.empty())
	{
		TrERROR(Mp, "%ls", L"Illegal acked stream sequence number"); 
		throw bad_srmp(L"");
	}

	const xwcs_t AckedSeqNumber = node.m_values.front().m_value;

	pProps->EodAckSeqNo = _wtoi64(AckedSeqNumber.Buffer());
	ASSERT(pProps->EodAckSeqNo  != 0);
}







void StreamReceiptToProps(
	 XmlNode& StreamReceipt, 
	CMessageProperties* pMessageProperties
	)
/*++

Routine Description:
    Parse SRMP Stream Receipt element into MSMQ properties.

Arguments:
	StreamReceipt - Stream Receipt element in SRMP reperesenation (xml).
	pMessageProperties - Received the parsed properties.

Returned Value:
	None.   

--*/
{
	CParseElement ParseElements[] =	{
										CParseElement(S_XWCS(xreceivedAt), EmptyNodeToProps,0 ,1),
										CParseElement(S_XWCS(xStreamId), AckedStreamIdToProps,1 ,1),
										CParseElement(S_XWCS(xlastOrdinal), AckedStreamNumberToProps, 1, 1),
										CParseElement(S_XWCS(xId), EmptyNodeToProps, 0, 1),
									};	

	NodeToProps(StreamReceipt, ParseElements, TABLE_SIZE(ParseElements), pMessageProperties);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mp\lib\envstream.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    envstream.cpp

Abstract:
    Implements serialization\deserialization of the stream  element to\from the  srmp envelop.

Author:
    Gil Shafriri(gilsh) 11-DEC-00

--*/

#include <libpch.h>
#include <qmpkt.h>
#include <fn.h>
#include <privque.h>
#include <qal.h>
#include <proptopkt.h>
#include <mp.h>
#include <xml.h>
#include "envstream.h"
#include "envcommon.h"
#include "mpp.h"
#include "envparser.h"

#include "envstream.tmh"

using namespace std;

extern void GetDnsNameOfLocalMachine(WCHAR ** ppwcsDnsName);


class MachineNameToOrderQueue
{
public:
	explicit MachineNameToOrderQueue(
		const WCHAR* MachineName,
		bool fHttps
		):
		m_MachineName(MachineName),
		m_fHttps(fHttps)
		{
		}

	friend wostream operator<<(wostream& wstr, const MachineNameToOrderQueue&  mToOrderQueue)
	{
		const WCHAR* Protocol = mToOrderQueue.m_fHttps ? FN_DIRECT_HTTPS_TOKEN : FN_DIRECT_HTTP_TOKEN;

		wstr<<Protocol 
		<<mToOrderQueue.m_MachineName
		<<L"/" 
		<<FN_MSMQ_HTTP_NAMESPACE_TOKEN 
		<<L"/" 
		<<FN_PRIVATE_$_TOKEN
		<<L"/"
		<<ORDERING_QUEUE_NAME;

		return wstr;
	}

private:
	const WCHAR* m_MachineName;
	bool m_fHttps;
};



class OrderAckQueueContent
{
public:
		static wstring GetHttpDnsOrderQueue()
		{
			return GetDnsOrderQueue(false);
		}

		static wstring GetHttpsDnsOrderQueue()
		{
			return GetDnsOrderQueue(true);
		}

		static wstring GetHttpNetbiosOrderQueue()
		{
			return GetNetbiosOrderQueue(false);			
		}

		static wstring GetHttpsNetbiosOrderQueue()
		{
			return GetNetbiosOrderQueue(true);			
		}

private:
		static wstring GetDnsOrderQueue(bool fHttps)
		{
			AP<WCHAR> 	LocalDnsName;
			GetDnsNameOfLocalMachine(&LocalDnsName);
			wostringstream 	DnsOrderQueue;
			DnsOrderQueue<<MachineNameToOrderQueue(LocalDnsName.get(), fHttps);
  			return 	DnsOrderQueue.str();
		}


		static wstring GetNetbiosOrderQueue(bool fHttps)
		{
			WCHAR LocalNetbiosName[MAX_COMPUTERNAME_LENGTH + 1];
			DWORD size = TABLE_SIZE(LocalNetbiosName);
			BOOL fSuccess = GetComputerName(LocalNetbiosName, &size);
			if(!fSuccess)
			{
				DWORD err = GetLastError();
				TrERROR(Mp, "GetComputerName failed with error %d ",err);
				throw bad_win32_error(err);
			}

			wostringstream 	NetbiosOrderQueue;
			NetbiosOrderQueue<<MachineNameToOrderQueue(LocalNetbiosName, fHttps);
			return NetbiosOrderQueue.str();
		}



private:	
	friend wostream& operator<<(wostream& wstr, const OrderAckQueueContent&)
	{

		typedef wstring (*OrderQueueFunc)(void);
		const OrderQueueFunc OrderQueueFuncList[] = {  
                                    OrderAckQueueContent::GetHttpDnsOrderQueue, 
								    OrderAckQueueContent::GetHttpsDnsOrderQueue,	
								    OrderAckQueueContent::GetHttpNetbiosOrderQueue,
								    OrderAckQueueContent::GetHttpsNetbiosOrderQueue
                                 };


        //
        // Try to find any possible alias to the order queue
        //
        for(int i = 0;i< TABLE_SIZE(OrderQueueFuncList); ++i)
        {
            wstring OrderQueue = OrderQueueFuncList[i]();
            AP<WCHAR> pLocalOrderQueueAlias;
		    bool fTranslated = QalGetMapping().GetAlias(
										OrderQueue.c_str(), 
										&pLocalOrderQueueAlias
				 						);

            if(fTranslated)
		    {
			    wstr<<pLocalOrderQueueAlias.get();
			    return wstr; 
		    }
        }

	    //
        // No alias found - the order queue is the default one full dns http format
        // http://dnsname/msmq/private$/order_queue$
        //
		return 	wstr<<OrderAckQueueContent::GetHttpDnsOrderQueue();
	}

};

 



class StartStreamElement
{
public:	
	explicit StartStreamElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend wostream& operator<<(wostream& wstr,const StartStreamElement& StartStream)
	{
		if(StartStream.m_pkt.GetPrevSeqN() != 0)
			return wstr;

		wstr<<OpenTag(xStart)
			<<SendReceiptsToElement()
			<<CloseTag(xStart);

		return wstr;
	}

private:
	class SendReceiptsToElement
	{
		friend wostream& operator<<(wostream& wstr,const SendReceiptsToElement& )
		{
			wstr<<OpenTag(xSendReceiptsTo)
				<<OrderAckQueueContent()
				<<CloseTag(xSendReceiptsTo);

			return 	wstr;
		}
	};

private:
	const CQmPacket& m_pkt;
};				  


class StreamIdElement
{
public:
	StreamIdElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend wostream& operator<<(wostream& wstr,const StreamIdElement& StreamId)
	{
		const CQmPacket& pkt = StreamId.m_pkt; 
  
		wstr<<OpenTag(xStreamId)
			<<StreamIdContent(pkt)
			<<CloseTag(xStreamId);


		return 	wstr;
	}

private:
	class  StreamIdContent
	{
	public:
		StreamIdContent(const CQmPacket& pkt):m_pkt(pkt){}
		friend wostream& operator<<(wostream& wstr, const StreamIdContent& StreamId)
		{
			const CQmPacket& pkt = StreamId.m_pkt; 

			wstr<<xUriReferencePrefix
				<<GuidElement(*pkt.GetSrcQMGuid())
				<<xSlash
				<<Int64Value(pkt.GetSeqID());
			
			return 	wstr;
		}
	
	
	private:
		const CQmPacket& m_pkt;
	};

	
private:
	const CQmPacket& m_pkt;
};


class SeqNumberElement
{
public:
	SeqNumberElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend wostream& operator<<(wostream& wstr,const SeqNumberElement& SeqNumber)
	{
		const CQmPacket& pkt = SeqNumber.m_pkt; 

  		wstr<<OpenTag(xCurrent)
			<<Int64Value(pkt.GetSeqN())
			<<CloseTag(xCurrent);

		return 	wstr;
	}

	
private:
	const CQmPacket& m_pkt;
};


class PrevSeqNumberElement
{
public:
	PrevSeqNumberElement(const CQmPacket& pkt):m_pkt(pkt){}
	friend wostream& operator<<(wostream& wstr,const PrevSeqNumberElement& PrevSeqNumber)
	{
		const CQmPacket& pkt = PrevSeqNumber.m_pkt; 

		wstr<<OpenTag(xPrevious)
			<<Int64Value(pkt.GetPrevSeqN())
			<<CloseTag(xPrevious);
  	
		return 	wstr;
	}

	
private:
	const CQmPacket& m_pkt;
};



std::wostream& operator<<(std::wostream& wstr, const StreamElement& Stream)
{
		CQmPacket& pkt = const_cast<CQmPacket&>(Stream.m_pkt); 

		if ( !pkt.IsOrdered() )
			return wstr;
					
		wstr<<OpenTag(xStream, xSoapmustUnderstandTrue)
			<<StreamIdElement(pkt)
			<<SeqNumberElement(pkt)
			<<PrevSeqNumberElement(pkt)	
			<<StartStreamElement(pkt)
			<<CloseTag(xStream);

		return 	wstr;
}



static
void
ParseMSMQStreamId(
			const xwcs_t& streamid, 
			CMessageProperties* pProp
			)
/*++

Routine Description:
    Parse stream id that is MSMQ stream id of the format qmguid\\seqid
	The qmguid will be use as the real stream id and seqid will also be extracted

Arguments:
    streamid - MSMQ stream id
	mProp - messages properties to fill.

Returned Value:
    None.

--*/
{
	bool fParsed = BreakMsmqStreamId(streamid, &pProp->EodStreamId, &pProp->EodSeqId);
	if(!fParsed)
	{
		TrERROR(Mp,"The MSMQ stream id '%.*ls' is not of the format QMGUID\\SEQID", LOG_XWCS(streamid));       
		throw bad_srmp(L"");
	}
}	


static void StreamIdToProps(XmlNode& node, CMessageProperties* pProps)
{
	if(node.m_values.empty())
	{
		TrERROR(Mp, "%ls", L"Illegal Stream id"); 
		throw bad_srmp(L"");
	}
	
	const xwcs_t StreamId = node.m_values.front().m_value;

	//
	// If we have MSMQ section so the stream id is of the format :
	// qmguid\\seqqenceid. We should treat the qm guid as the streamid
	// and also extract the seqid
	//
	if(pProps->fMSMQSectionIncluded)
	{
		ParseMSMQStreamId(StreamId, pProps);
	}
	else
	{
		pProps->EodStreamId = StreamId;
	}
}


static void SeqNumberToProps(XmlNode& node, CMessageProperties* pProps)
{
	if(node.m_values.empty())
	{
		TrERROR(Mp, "%ls", L"Illegal Sequence number"); 
		throw bad_srmp(L"");
	}
	const xwcs_t SecNumber = node.m_values.front().m_value;
   
	// 
	// ISSUE-2000/10/23-gilsh - MSMQ has only 32 bit for seqNo.
	// According to srmp it can be 64 bit value.
	//
	pProps->EodSeqNo = _wtoi(SecNumber.Buffer());
}
	   

static void PrevSeqNumberToProps(XmlNode& node, CMessageProperties* pProps)
{
	if(node.m_values.empty())
	{
		TrERROR(Mp, "%ls", L"Illegal Prev Sequence number"); 
		throw bad_srmp(L"");
	}

	const xwcs_t  SecPrevNumber = node.m_values.front().m_value;
	pProps->EodPrevSeqNo = _wtoi(SecPrevNumber.Buffer());
}


static void OrdeQueueAddressToProps(XmlNode& node, CMessageProperties* pProps)
{
	if(node.m_values.empty())
	{
		TrERROR(Mp, "%ls", L"Illegal order ack queue address"); 
		throw bad_srmp(L"");
	}

	const xwcs_t OrderQueue = node.m_values.front().m_value;

	if(OrderQueue.Length() == 0)
	{
		TrERROR(Mp, "%ls", L"Illegal order ack queue address"); 
		throw bad_srmp(L"");
	}
  
    pProps->OrderQueue = OrderQueue;
}





static void StreamExpiresAtToProps(XmlNode&, CMessageProperties* )
{
	//
	// Currently - this one is ignored
	//
}



static void StartStreamToProps(XmlNode& node, CMessageProperties* pProps)
{
	CParseElement ParseElements[] =	{
										CParseElement(S_XWCS(xSendReceiptsTo),OrdeQueueAddressToProps, 1,1),
										CParseElement(S_XWCS(xExpiresAt), StreamExpiresAtToProps, 0,1),
	   								};	

	NodeToProps(node, ParseElements, TABLE_SIZE(ParseElements), pProps);
}





void StreamToProps(
	XmlNode&  Stream, 
	CMessageProperties* pProps
	)
/*++

Routine Description:
    Parse SRMP Stream  element into MSMQ properties.

Arguments:
	Stream - Stream element in SRMP reperesenation (xml).
	pMessageProperties - Received the parsed properties.

Returned Value:
	None.   

--*/
{
	pProps->fEod = true;


	CParseElement ParseElements[] =	{
										CParseElement(S_XWCS(xStreamId),StreamIdToProps, 1,1),
										CParseElement(S_XWCS(xCurrent), SeqNumberToProps,1 ,1),
										CParseElement(S_XWCS(xPrevious), PrevSeqNumberToProps, 0 ,1),
										CParseElement(S_XWCS(xEnd), EmptyNodeToProps, 0, 1),
										CParseElement(S_XWCS(xStart), StartStreamToProps, 0, 1),
										CParseElement(S_XWCS(xStreamReceiptRequest), EmptyNodeToProps, 0, 1)
										
									};	

	NodeToProps(Stream, ParseElements, TABLE_SIZE(ParseElements), pProps);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mp\lib\mpdebug.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    MpDebug.cpp

Abstract:
    SRMP Serialization and Deserialization debugging

Author:
    Uri Habusha (urih) 28-May-00

Environment:
    Platform-independent, _DEBUG only

--*/

#include <libpch.h>
#include "Mp.h"
#include "Mpp.h"

#include "mpdebug.tmh"

#ifdef _DEBUG


//---------------------------------------------------------
//
// Validate SRMP Serialization and Deserialization state
//
void MppAssertValid(void)
{
    //
    // MpInitalize() has *not* been called. You should initialize the
    // SRMP Serialization and Deserialization library before using any of its funcionality.
    //
    ASSERT(MppIsInitialized());

    //
    // TODO:Add more SRMP Serialization and Deserialization validation code.
    //
}


//---------------------------------------------------------
//
// Initialization Control
//
static LONG s_fInitialized = FALSE;

void MppSetInitialized(void)
{
    LONG fMpAlreadyInitialized = InterlockedExchange(&s_fInitialized, TRUE);

    //
    // The SRMP Serialization and Deserialization library has *already* been initialized. You should
    // not initialize it more than once. This assertion would be violated
    // if two or more threads initalize it concurently.
    //
    ASSERT(!fMpAlreadyInitialized);
}


BOOL MppIsInitialized(void)
{
    return s_fInitialized;
}


//---------------------------------------------------------
//
// Tracing and Debug registration
//
const TraceIdEntry xTraceTable[] = {

    Mp,

    //
    // TODO: Add SRMP Serialization and Deserialization sub-component trace ID's to be used with TrXXXX.
    // For example, MpInit, as used in:
    // TrERROR(MpInit, "Error description", parameters)
    //
};

/*
const DebugEntry xDebugTable[] = {

    {
        "MpDumpState(queue path name)",
        "Dump SRMP Serialization and Deserialization State to debugger",
        DumpState
    ),

    //
    // TODO: Add SRMP Serialization and Deserialization debug & control functions to be invoked using
    // mqctrl.exe utility.
    //
};
*/

void MppRegisterComponent(void)
{
    TrRegisterComponent(xTraceTable, TABLE_SIZE(xTraceTable));
    //DfRegisterComponent(xDebugTable, TABLE_SIZE(xDebugTable));
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mp\lib\mpinit.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    MpInit.cpp

Abstract:
    SRMP Serialization and Deserialization initialization

Author:
    Uri Habusha (urih) 28-May-00

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include "Mp.h"
#include "Mpp.h"

#include "MpInit.tmh"


VOID
MpInitialize(
    VOID
    )
/*++

Routine Description:
    Initializes SRMP Serialization and Deserialization library

Arguments:
    None.

Returned Value:
    None.

--*/
{
    //
    // Validate that the SRMP Serialization and Deserialization library was not initalized yet.
    // You should call its initalization only once.
    //
    ASSERT(!MppIsInitialized());
    MppRegisterComponent();
    MppSetInitialized();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mp\lib\mpp.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Mpp.h

Abstract:
    SRMP Serialization and Deserialization private functions.

Author:
    Uri Habusha (urih) 28-May-00

--*/

#pragma once

#ifndef _MSMQ_Mpp_H_
#define _MSMQ_Mpp_H_
#include <xstr.h>

const TraceIdEntry Mp = L"SRMP";

const WCHAR xSlash[] =  L"\\";
#define UUIDREFERENCE_PREFIX     L"uuid:"
#define UUIDREFERENCE_SEPERATOR  L"@"
#define BOUNDARY_HYPHEN "--"

const WCHAR xUuidReferencePrefix[] = L"uuid:";
const DWORD xUuidReferencePrefixLen = STRLEN(xUuidReferencePrefix);
const WCHAR xUriReferencePrefix[] = L"uri:";

const WCHAR xUuidReferenceSeperator[] = L"@";
const WCHAR xUuidReferenceSeperatorChar = L'@';
const LONGLONG xNoneMSMQSeqId = _I64_MAX;




#ifdef _DEBUG

void MppAssertValid(void);
void MppSetInitialized(void);
BOOL MppIsInitialized(void);
void MppRegisterComponent(void);

#else // _DEBUG

#define MppAssertValid() ((void)0)
#define MppSetInitialized() ((void)0)
#define MppIsInitialized() TRUE
#define MppRegisterComponent() ((void)0)

#endif // _DEBUG





#endif // _MSMQ_Mpp_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mp\lib\proptopkt.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    proptopkt.cpp

Abstract:
    MessagePropToPacket implementation (proptopkt.h)

Author:
    Gil Shafriri(gilsh) 28-Nov-00

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include <mp.h>
#include <mqwin64a.h>
#include <mqsymbls.h>
#include <mqformat.h>
#include <acdef.h>


#include <mp.h>

#include "proptopkt.h"
#include "httpmime.h"
#include "proptopkt.tmh"



#ifdef _DEBUG
DWORD DiffPtr(const void* end, const void* start) 
{
	ptrdiff_t diff = (UCHAR*)end - (UCHAR*)start;
	return numeric_cast<DWORD>(diff);	
}
#endif

static DWORD CalculateBaseHeaderSectionSize()
{
	return  CBaseHeader::CalcSectionSize();
}


void*  
BuildBaseHeaderSection(
	const CMessageProperties& mProp,
	void* const pSection, 
	DWORD packetSize
	)
{ 
    #pragma PUSH_NEW
    #undef new

  
    CBaseHeader* pBase = new(pSection) CBaseHeader(packetSize);
    pBase->SetPriority(mProp.priority);
    pBase->SetTrace(mProp.fTrace);
	DWORD AbsoluteTimeToQueue = mProp.fMSMQSectionIncluded ? mProp.absoluteTimeToQueue : mProp.absoluteTimeToLive;
    pBase->SetAbsoluteTimeToQueue(AbsoluteTimeToQueue);

	void* pNextSection = pBase->GetNextSection();

	ASSERT(DiffPtr(pNextSection, pSection) == CalculateBaseHeaderSectionSize() );

	return pNextSection;

   	#pragma POP_NEW
}


static DWORD CalculateUserHeaderSectionSize(const CMessageProperties& mProp) 
{
	ASSERT(mProp.destQueue.GetType() != QUEUE_FORMAT_TYPE_UNKNOWN);
    const QUEUE_FORMAT* pAdminQueue = (mProp.adminQueue.GetType() != QUEUE_FORMAT_TYPE_UNKNOWN) ? &mProp.adminQueue : NULL;
    const QUEUE_FORMAT* pResponseQueue = (mProp.responseQueue.GetType() != QUEUE_FORMAT_TYPE_UNKNOWN) ? &mProp.responseQueue : NULL;

    return CUserHeader::CalcSectionSize(
                        &mProp.messageId.Lineage,
                        &mProp.destQmId,
                        (mProp.connectorType != GUID_NULL) ? &mProp.connectorType: NULL,
                        &mProp.destQueue,
                        pAdminQueue,
                        pResponseQueue
                        );
	
}


void*  
BuildUserHeaderSection(
	const CMessageProperties& mProp, 
	void* const pSection,
	CUserHeader** ppUser
	)
{
	#pragma PUSH_NEW
    #undef new


	const QUEUE_FORMAT* pAdminQueue = (mProp.adminQueue.GetType() != QUEUE_FORMAT_TYPE_UNKNOWN) ? &mProp.adminQueue : NULL;
    const QUEUE_FORMAT* pResponseQueue = (mProp.responseQueue.GetType() != QUEUE_FORMAT_TYPE_UNKNOWN) ? &mProp.responseQueue : NULL;

    CUserHeader* pUser = new (pSection) CUserHeader(
                                            &mProp.SourceQmGuid,
                                            &mProp.destQmId,
                                            &mProp.destQueue,
                                            pAdminQueue,
                                            pResponseQueue,
                                            mProp.messageId.Uniquifier
                                            );

	*ppUser =  pUser;
    if (mProp.connectorType != GUID_NULL)
    {
        pUser->SetConnectorType(&mProp.connectorType);
    }

	
	DWORD TimeToLiveDelta = mProp.fMSMQSectionIncluded ? mProp.absoluteTimeToLive - mProp.absoluteTimeToQueue : 0; 
    pUser->SetTimeToLiveDelta(TimeToLiveDelta);
    pUser->SetSentTime(mProp.sentTime);
    pUser->SetDelivery(mProp.delivery);
    pUser->SetAuditing(mProp.auditing);

	void* pNextSection = pUser->GetNextSection();
	ASSERT(DiffPtr(pNextSection, pSection) == CalculateUserHeaderSectionSize(mProp));

	return pNextSection;

	#pragma POP_NEW
}


static DWORD CalculateXactHeaderSectionSize(const CMessageProperties& mProp) 
{
	DWORD packetSize = 0;
	if (mProp.fEod)
	{
		packetSize = CXactHeader::CalcSectionSize(
								(void*)&mProp.EodSeqId, 
								mProp.connectorId == GUID_NULL ? NULL : &mProp.connectorId
								);
	}
	return packetSize;
}


void*  BuildXactHeaderSection(
			const CMessageProperties& mProp,
			void* const pSection, 
			CUserHeader* pUser
			)
{
	#pragma PUSH_NEW
    #undef new

	void* pNextSection =   pSection;

	if (mProp.fEod)
	{
		pUser->IncludeXact(TRUE);

		const GUID* pConnector = ((mProp.connectorId == GUID_NULL) ? NULL : &mProp.connectorId);
		CXactHeader* pXact = new (pSection) CXactHeader(pConnector);
		pXact->SetCancelFollowUp(TRUE);
		pXact->SetSeqID(mProp.EodSeqId);
		pXact->SetSeqN(mProp.EodSeqNo);
		pXact->SetPrevSeqN(mProp.EodPrevSeqNo);
		pXact->SetFirstInXact(mProp.fFirst);
		pXact->SetLastInXact(mProp.fLast);
		if (pConnector != NULL)
		{
			pXact->SetConnectorQM(pConnector);
		}

		pNextSection = pXact->GetNextSection();
	}

	ASSERT(DiffPtr(pNextSection, pSection) == CalculateXactHeaderSectionSize(mProp));
	return pNextSection;

	#pragma POP_NEW
}



static DWORD CalculateSecurityHeaderSectionSize(const CMessageProperties& mProp) 
{
	DWORD packetSize = 0;

	if ((mProp.signature.size() != 0) || (mProp.senderCert.Length() != 0))
	{
		DWORD ProviderInfoSize = 0;
		if (!mProp.fDefaultProvider)
		{
			ProviderInfoSize = (mProp.providerName.Length() + 1) * sizeof(WCHAR) + sizeof(ULONG);
		}

		packetSize = CSecurityHeader::CalcSectionSize(
											static_cast<USHORT>(mProp.senderSid.Length()),
											0, // Encrypted Key Size
											static_cast<USHORT>(mProp.signature.size()), 
											static_cast<USHORT>(mProp.senderCert.Length()),
											static_cast<USHORT>(ProviderInfoSize)
											);
	}
	return packetSize;
}


void*  
BuildSecurityHeaderSection(
	const CMessageProperties& mProp, 
	void* const	pSection, 
	CUserHeader* pUser
	)
{
	#pragma PUSH_NEW
    #undef new
	
	void* pNextSection = pSection;

    if ((mProp.signature.size() != 0) || (mProp.senderCert.Length() != 0))
    {
        pUser->IncludeSecurity(TRUE);

        CSecurityHeader* pSec = new (pSection) CSecurityHeader();
        

        pSec->SetSenderIDType(mProp.senderIdType);

		if (mProp.senderSid.Length() != 0)
        {
            pSec->SetSenderID(
                    reinterpret_cast<const BYTE*>(mProp.senderSid.Buffer()), 
                    static_cast<USHORT>(mProp.senderSid.Length())
                    );
        }

        if (mProp.signature.size() != 0)
        {
            pSec->SetSignature(
                    mProp.signature.data(), 
                    static_cast<USHORT>(mProp.signature.size())
                    );
        }

        if (mProp.senderCert.Length() != 0)
        {
            pSec->SetSenderCert(
                    static_cast<const BYTE*>(mProp.senderCert.Buffer()), 
                    mProp.senderCert.Length()
                    );
        }

        if ((mProp.signature.size() != 0) || (mProp.senderCert.Buffer() != NULL))
        {
            LPWSTR pProvider = static_cast<LPWSTR>(_alloca((mProp.providerName.Length() + 1) * sizeof(WCHAR)));
            mProp.providerName.CopyTo(pProvider);

            DWORD ProviderInfoSize = 0;
            if (!mProp.fDefaultProvider)
            {
                ProviderInfoSize = (mProp.providerName.Length() + 1) * sizeof(WCHAR) + sizeof(ULONG);
            }

            pSec->SetProvInfoEx(
                        static_cast<USHORT>(ProviderInfoSize),
                        mProp.fDefaultProvider, 
                        pProvider,
                        mProp.providerType
                        );
        }

        pNextSection = pSec->GetNextSection();
    }
	
	ASSERT(DiffPtr(pNextSection, pSection) == CalculateSecurityHeaderSectionSize(mProp));

	return pNextSection;

	#pragma POP_NEW
}


static DWORD CalculatePropertyHeaderSectionSize(const CMessageProperties& mProp) 
{
	return  CPropertyHeader::CalcSectionSize(
							mProp.title.Length() != 0 ? mProp.title.Length()+1 : 0,
							mProp.extension.Length(),
							0
							);


}


void*  BuildPropertyHeaderSection(const CMessageProperties& mProp, void* const pSection)
{
	#pragma PUSH_NEW
    #undef new

    CPropertyHeader* pProp = new (pSection) CPropertyHeader;
	pProp->SetClass(mProp.classValue);
    pProp->SetCorrelationID(mProp.pCorrelation.get());
    pProp->SetAckType(mProp.acknowledgeType);
    pProp->SetApplicationTag(mProp.applicationTag);
    pProp->SetBodyType(mProp.bodyType);
    pProp->SetHashAlg(mProp.hashAlgorithm);

    if(mProp.title.Length() != 0)
    {
        //
        //  NOTE: Setting the title to the message MUST occure before setting the body
        //

        //
        // Title should include String terminator. Since serialization throw the
        // string terminator, the deserialization should add it before setting 
        // the title;
        LPWSTR pTitle = static_cast<LPWSTR>(_alloca((mProp.title.Length() + 1) * sizeof(WCHAR)));
        mProp.title.CopyTo(pTitle);

        pProp->SetTitle(pTitle, mProp.title.Length() + 1);
    }

    if (mProp.extension.Length() != 0)
    {
        //
        //  NOTE: Setting the Message Extension to property section MUST occure
        //        before setting the body and after setting the title
        //
        pProp->SetMsgExtension(
            static_cast<const BYTE*>(mProp.extension.Buffer()), 
            mProp.extension.Length()
            );
    }

    
	void* pNextSection = pProp->GetNextSection();
	ASSERT(DiffPtr(pNextSection, pSection) == CalculatePropertyHeaderSectionSize(mProp));
 
	return 	pNextSection;

	#pragma POP_NEW
}


static DWORD CalculateMqfSectionSize(const CMessageProperties& mProp) 
{
	DWORD packetSize = 0;
	if(mProp.destMqf.GetCount() != 0 || mProp.adminMqf.GetCount()  != 0  || mProp.responseMqf.GetCount()  !=0)
	{
		packetSize += CDebugSection::CalcSectionSize(&mProp.DebugQueue);
		packetSize += CBaseMqfHeader::CalcSectionSize(mProp.destMqf.GetQueueFormats(), mProp.destMqf.GetCount());
		packetSize += CBaseMqfHeader::CalcSectionSize(mProp.adminMqf.GetQueueFormats(), mProp.adminMqf.GetCount());
		packetSize += CBaseMqfHeader::CalcSectionSize(mProp.responseMqf.GetQueueFormats(), mProp.responseMqf.GetCount());
		packetSize += CMqfSignatureHeader::CalcSectionSize(0);
	}
	return packetSize;
}

void*  
BuildMqfHeaderSection(
	const CMessageProperties& mProp, 
	void* const pSection, 
	CUserHeader* pUser, 
	CBaseHeader* pBase
	)
{
	#pragma PUSH_NEW
    #undef new
	void* pNextSection = pSection;

  	if(mProp.destMqf.GetCount() != 0 || mProp.adminMqf.GetCount()  != 0  || mProp.responseMqf.GetCount()  !=0)
	{
        //
        // Build DUMMY Debug header
        //
        pBase->IncludeDebug(TRUE);
	    CDebugSection * pDebug = new (pSection) CDebugSection(&mProp.DebugQueue);
        pNextSection = pDebug->GetNextSection();

        //
        // Build Destination MQF header
        //
        pUser->IncludeMqf(true);

        const USHORT x_DESTINATION_MQF_HEADER_ID = 100;
        CBaseMqfHeader * pDestinationMqf = new (pNextSection) CBaseMqfHeader(
                                                              mProp.destMqf.GetQueueFormats(),
                                                              mProp.destMqf.GetCount(),
                                                              x_DESTINATION_MQF_HEADER_ID
                                                              );
        pNextSection = pDestinationMqf->GetNextSection();

        //
        // Build Admin MQF header
        //
        const USHORT x_ADMIN_MQF_HEADER_ID = 200;
        CBaseMqfHeader * pAdminMqf = new (pNextSection) CBaseMqfHeader(
                                                        mProp.adminMqf.GetQueueFormats(),
                                                        mProp.adminMqf.GetCount(),
                                                        x_ADMIN_MQF_HEADER_ID
                                                        );
        pNextSection = pAdminMqf->GetNextSection();

        //
        // Build Response MQF header
        //
        const USHORT x_RESPONSE_MQF_HEADER_ID = 300;
        CBaseMqfHeader * pResponseMqf = new (pNextSection) CBaseMqfHeader(
														   mProp.responseMqf.GetQueueFormats(),
														   mProp.responseMqf.GetCount(),
														   x_RESPONSE_MQF_HEADER_ID
														   );
        pNextSection = pResponseMqf->GetNextSection();

		//
		// Build MQF Signature header
		//
		// Capture user buffer and size and probe the buffer
		//
		const USHORT x_MQF_SIGNATURE_HEADER_ID = 350;
		CMqfSignatureHeader * pMqfSignature = new (pNextSection) CMqfSignatureHeader(
			                                                     x_MQF_SIGNATURE_HEADER_ID,
			                                                     0,
																 NULL
																 );
		pNextSection = pMqfSignature->GetNextSection();
                              
	}

	ASSERT(DiffPtr(pNextSection, pSection) == CalculateMqfSectionSize(mProp));
   
	return 	pNextSection;

	#pragma POP_NEW
}


static DWORD CalculateSrmpEnvelopeHeaderSectionSize(const CMessageProperties& mProp) 
{

	return CSrmpEnvelopeHeader::CalcSectionSize(mProp.envelop.Length());
}


void*  
BuildSrmpEnvelopeHeaderSection(
	const CMessageProperties& mProp, 
	void* const pSection, 
	CUserHeader* pUser
	)
{
	#pragma PUSH_NEW
    #undef new

	pUser->IncludeSrmp(true);

	//
	// Envelop
	//
	const USHORT x_SRMP_ENVELOPE_ID = 400;
	CSrmpEnvelopeHeader* pSrmpEnvelopeHeader = new (pSection) CSrmpEnvelopeHeader(
	                                                          const_cast<WCHAR*>(mProp.envelop.Buffer()),
															  mProp.envelop.Length(),
															  x_SRMP_ENVELOPE_ID
															  );

	void* pNextSection  = pSrmpEnvelopeHeader->GetNextSection();

	ASSERT(DiffPtr(pNextSection, pSection) == CalculateSrmpEnvelopeHeaderSectionSize(mProp));
   
	return pNextSection;

	#pragma POP_NEW
}



static  DWORD  CalculateCompoundMessageHeaderSectionSize(const CMessageProperties& mProp) 
{
	return  CCompoundMessageHeader::CalcSectionSize(
											mProp.Rawdata->GetHeader().Length(),
											mProp.Rawdata->GetBody().Length() 
											);
}


void*  
BuildCompoundMessageHeaderSection(
	const CMessageProperties& mProp, 
	void* const pSection, 
	CUserHeader* pUser
	)
{
	#pragma PUSH_NEW
    #undef new

	pUser->IncludeSrmp(true);

	DWORD MsgBodyOffset = mProp.body.m_offset;
	DWORD MsgBodySize =   mProp.body.m_data.Length();

	const USHORT x_COMPOUND_MESSAGE_ID = 500;
	CCompoundMessageHeader* pCompoundMessageHeader = new (pSection) CCompoundMessageHeader(
		                                                         (UCHAR*)mProp.Rawdata->GetHeader().Buffer(),
																 mProp.Rawdata->GetHeader().Length(),
																 (UCHAR*)mProp.Rawdata->GetBody().Buffer(),
																 mProp.Rawdata->GetBody().Length(),
																 MsgBodySize,
																 MsgBodyOffset,
																 x_COMPOUND_MESSAGE_ID
																 );

	void* pNextSection = pCompoundMessageHeader->GetNextSection();
		
	ASSERT(DiffPtr(pNextSection, pSection) == CalculateCompoundMessageHeaderSectionSize(mProp));
   
	return pNextSection;

	#pragma POP_NEW
}



static DWORD CalculateEodHeaderSectionSize(const CMessageProperties& mProp) 
{
	DWORD packetSize = 0;
	if(mProp.EodStreamId.Length() != 0)
	{
		DWORD EodStreamIdLen = (mProp.EodStreamId.Length()+1 )*sizeof(WCHAR);
		DWORD OrderQueueLen = (DWORD)(mProp.OrderQueue.Length() ? (mProp.OrderQueue.Length()+1 )*sizeof(WCHAR) : 0);  
		packetSize += CEodHeader::CalcSectionSize(EodStreamIdLen, OrderQueueLen);
	}
	return packetSize;
}


void*  
BuildEodHeaderSection(
	const CMessageProperties& mProp, 
	void* const pSection, 
	CUserHeader* pUser
	)
{
	#pragma PUSH_NEW
    #undef new
	
	void* pNextSection = pSection;
	if(mProp.EodStreamId.Length() != NULL)
	{
		pUser->IncludeEod(true);
		const USHORT x_EOD_ID = 600;
		AP<WCHAR> pStreamid =  mProp.EodStreamId.ToStr();
		AP<WCHAR> pOrderQueue = mProp.OrderQueue.Length() ? mProp.OrderQueue.ToStr() : NULL;
		DWORD EodStreamIdLen = (mProp.EodStreamId.Length() + 1)*sizeof(WCHAR);
		DWORD OrderQueueLen = (DWORD)(pOrderQueue.get() ? (mProp.OrderQueue.Length() + 1)*sizeof(WCHAR) : 0); 

		
	    CEodHeader* pEodHeader = new (pSection) CEodHeader(
												   x_EOD_ID,	
                                                   EodStreamIdLen,
												   (UCHAR*)pStreamid.get(),
												   OrderQueueLen,
												   (UCHAR*)pOrderQueue.get()
												   );												   

		pNextSection = pEodHeader->GetNextSection();
	}

	ASSERT(DiffPtr(pNextSection, pSection) == CalculateEodHeaderSectionSize(mProp));

	return 	pNextSection;

	#pragma POP_NEW
}


static DWORD CalculateEodAckHeaderSectionSize(const CMessageProperties& mProp) 
{
	DWORD packetSize = 0;
	if(mProp.EodAckStreamId.Length() != 0)
	{
		DWORD EodAckStreamIdLen = (mProp.EodAckStreamId.Length() +1 )*sizeof(WCHAR);
		packetSize += CEodAckHeader::CalcSectionSize(EodAckStreamIdLen );
	}
	return packetSize;
}


void*  
BuildEodAckHeaderSection(
	const CMessageProperties& mProp, 
	void* const pSection, 
	CUserHeader* pUser
	)
{  
	#pragma PUSH_NEW
    #undef new

	void* pNextSection =  pSection;
	if(mProp.EodAckStreamId.Length() != NULL)
	{
		pUser->IncludeEodAck(true);
		const USHORT x_EOD_ACK_ID = 700;
		AP<WCHAR> pStreamid =  mProp.EodAckStreamId.ToStr();
	    CEodAckHeader* pEodAckHeader = new (pSection) CEodAckHeader(
												   x_EOD_ACK_ID,	
                                                   const_cast<LONGLONG*>(&mProp.EodAckSeqId),
												   const_cast<LONGLONG*>(&mProp.EodAckSeqNo),
											       (mProp.EodAckStreamId.Length()+1)*sizeof(WCHAR),
												   (UCHAR*)pStreamid.get()
												   );

		pNextSection = pEodAckHeader->GetNextSection();
	}

	ASSERT(DiffPtr(pNextSection, pSection) == CalculateEodAckHeaderSectionSize(mProp));


	return pNextSection; 

	#pragma POP_NEW
}

static
DWORD
CalculatePacketSize(
    const CMessageProperties& mProp
    )
{
	DWORD packetSize =0;
	packetSize +=  CalculateBaseHeaderSectionSize();
	packetSize +=  CalculateUserHeaderSectionSize(mProp);
	packetSize +=  CalculateXactHeaderSectionSize(mProp);
	packetSize +=  CalculateSecurityHeaderSectionSize(mProp);
	packetSize +=  CalculatePropertyHeaderSectionSize(mProp);
	packetSize +=  CalculateMqfSectionSize(mProp);
	packetSize +=  CalculateSrmpEnvelopeHeaderSectionSize(mProp);
	packetSize +=  CalculateCompoundMessageHeaderSectionSize(mProp);
	packetSize +=  CalculateEodHeaderSectionSize(mProp);
	packetSize +=  CalculateEodAckHeaderSectionSize(mProp);
  
	return packetSize;
}




static
void
BuildPacket(
    CBaseHeader* pBase,
    DWORD packetSize,
    const CMessageProperties& mProp
    )
{
	void* pNextSection = pBase;

	pNextSection = BuildBaseHeaderSection(mProp, pNextSection, packetSize);
	CUserHeader* pUser;
	pNextSection = BuildUserHeaderSection(mProp, pNextSection, &pUser);
	pNextSection = BuildXactHeaderSection(mProp, pNextSection, pUser);
	pNextSection = BuildSecurityHeaderSection(mProp, pNextSection, pUser);
	pNextSection = BuildPropertyHeaderSection(mProp, pNextSection);
	pNextSection = BuildMqfHeaderSection(mProp, pNextSection, pUser, pBase);
	pNextSection = BuildSrmpEnvelopeHeaderSection(mProp, pNextSection, pUser);
	pNextSection = BuildCompoundMessageHeaderSection(mProp, pNextSection, pUser);
	pNextSection = BuildEodHeaderSection(mProp, pNextSection, pUser);
	pNextSection = BuildEodAckHeaderSection(mProp, pNextSection, pUser );

	ASSERT(DiffPtr(pNextSection, pBase) == packetSize);
}


static void CheckProps(const CMessageProperties& props)
{
	if(props.fMSMQSectionIncluded && props.absoluteTimeToQueue > props.absoluteTimeToLive)
	{
		TrERROR(Mp," Time time to reach queue is grater then expiration time");
		throw bad_srmp(L"");
	}
}




void 
MessagePropToPacket(
	const CMessageProperties& messageProperty,
	CACPacketPtrs* pACPacketPtrs
	)
/*++

Routine Description:
    Create msmq packet from mesages properties.
	

Arguments:
    messageProperty - messages property.
	pACPacketPtrs - Receives the created packet.


Returned Value:
    None.
--*/
{
	CheckProps(messageProperty);


	//
    // Caculate MSMQ packet Size
    //
    DWORD pktSize = CalculatePacketSize(messageProperty);

    //
    // Aloocate memory for MSMQ packet
    //
    CACPacketPtrs pktPtrs;
    AppAllocatePacket(
             messageProperty.destQueue,
             messageProperty.delivery,
             pktSize,
             pktPtrs
             );

    //
    // Create MSMQ Packet
    //
    try
    {
        BuildPacket(pktPtrs.pPacket, pktSize, messageProperty);
    }
    catch (const exception&)
    {
        AppFreePacket(pktPtrs);
        throw;
    }
    
   	*pACPacketPtrs =   pktPtrs;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mp\lib\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Script1.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mp\lib\proptopkt.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    proptopkt.h

Abstract:
    declare MessagePropToPacket function that converts message property structure to qm packet.

Author:
    Gil Shafriri (gilsh) 28-Nov-00

--*/

#pragma once

#ifndef _MSMQ_proptopkt_H_
#define _MSMQ_proptopkt_H_

#include <fn.h>
#include <qmpkt.h>
#include <xmlencode.h>
#include "mpp.h"
#include "attachments.h"
#include <utf8.h>
class CHttpReceivedBuffer;

class CMessageProperties 
{
public:
    CMessageProperties()
    {
        memset(this, 0, sizeof(CMessageProperties));
		destQmId = GUID_NULL;
        delivery = MQMSG_DELIVERY_EXPRESS;
        absoluteTimeToLive = INFINITE;
		absoluteTimeToQueue = INFINITE;
        acknowledgeType = DEFAULT_M_ACKNOWLEDGE;
        classValue = MQMSG_CLASS_NORMAL;
        priority = DEFAULT_M_PRIORITY;
        auditing = MQMSG_JOURNAL_NONE;
		EodSeqId = xNoneMSMQSeqId;
		fMSMQSectionIncluded = false;
        SmxpActionBuffer = new CXmlDecode();
	}

public:
    CFnQueueFormat destQueue;
    CFnQueueFormat adminQueue;
    CFnQueueFormat responseQueue;
	CFnQueueFormat destMulticastQueue;
	CFnMqf 	destMqf;
	CFnMqf 	adminMqf;
	CFnMqf 	responseMqf;
	GUID destQmId;

	QUEUE_FORMAT DebugQueue;

    OBJECTID messageId;

    DWORD absoluteTimeToLive;
	DWORD absoluteTimeToQueue;
    DWORD sentTime;
    

    UCHAR delivery;
    bool fTrace;
	bool fMSMQSectionIncluded;

    UCHAR acknowledgeType;
    USHORT classValue;
    DWORD applicationTag;

    UCHAR auditing;
    UCHAR priority;
    GUID  connectorType;
	GUID  SourceQmGuid;

    bool fEod;
    
	xwcs_t EodStreamId;
	LONGLONG EodSeqId;
    DWORD EodSeqNo;
    DWORD EodPrevSeqNo;

	xwcs_t	 EodAckStreamId;
	LONGLONG EodAckSeqId;
	LONGLONG EodAckSeqNo;

    bool fFirst;
    bool fLast;
    GUID connectorId;
    xwcs_t OrderQueue;

	xwcs_t envelop;
	const CHttpReceivedBuffer* Rawdata;

    AP<BYTE> pCorrelation; 
    DWORD bodyType;

    P<CXmlDecode> SmxpActionBuffer;
    xwcs_t title;
    utf8_str signature;
	
    xbuf_t<const VOID> extension;
    CAttachment body;
    xbuf_t<const VOID> senderCert;
	P<VOID> pCleanSenderSid;

    xbuf_t<const VOID> senderSid;
	USHORT senderIdType;

    bool fDefaultProvider;
    xwcs_t providerName;
    DWORD providerType;
    DWORD hashAlgorithm;
	
private:
	CMessageProperties(const CMessageProperties&);
	CMessageProperties& operator=(const CMessageProperties&);
}; 

class CACPacketPtrs; 
void MessagePropToPacket(const CMessageProperties&, CACPacketPtrs* pACPacketPtrs);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mp\lib\httpmime.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    httpmime.cpp

Abstract:
     Imlementing  parsing http request to it's mime parts (httpmime.h)
  
Author:
    Gil Shafriri(gilsh) 22-MARCH-01

--*/
#include <libpch.h>
#include <xstr.h>
#include <mp.h>
#include <utf8.h>
#include "httpmime.h"
#include "attachments.h"
#include "mpp.h"

#include "httpmime.tmh"

using namespace std;

const char xContentType[] = "Content-Type:";
const char xContentLength[] = "Content-Length:";
const char xContentId[] = "Content-Id:";
const char xEndOfHttpHeaderRequest[] = "\r\n\r\n";
const char xMimeContentTypeValue[] = "multipart/related";
const char xEnvelopeContentTypeValue[] = "text/xml";


inline LPCSTR removeLeadingSpace(LPCSTR p, LPCSTR pEnd)
{
    for(; ((pEnd > p) && iswspace(*p)); ++p)
    {
        NULL;
    }

    return p;
}


inline LPCSTR removeTralingSpace(LPCSTR p, LPCSTR pEnd)
{
    for(; ((pEnd >= p) && iswspace(*pEnd)); --pEnd)
    {
        NULL;
    }

    return pEnd;
}

static
const BYTE*
ParseBoundaryLineDelimeter(
    const BYTE* pBoundary,
    xstr_t boundary
    )
{
	

    //
    // The boundary delimiter line is then defined as a line
    // consisting entirely of two hyphen characters ("-", decimal value 45)
    // followed by the boundary parameter value from the Content-Type header
    // field, optional linear whitespace, and a terminating CRLF.
    //

    LPCSTR p = reinterpret_cast<LPCSTR>(pBoundary);
    //
    // Check exisiting of two hyphen characters
    //
    if(strncmp(p, BOUNDARY_HYPHEN, STRLEN(BOUNDARY_HYPHEN)) != 0)
	{	
		TrERROR(Mp, "wrong mime format");
        throw bad_request();
	}

    p += STRLEN(BOUNDARY_HYPHEN);

    //
    // Check exisiting of boundary parameter value
    //
    if(strncmp(p, boundary.Buffer(), boundary.Length()) != 0)
	{
		TrERROR(Mp, "no mime boundary found");
        throw bad_request();
	}
    p += boundary.Length();
    p = removeLeadingSpace(p, p + strlen(p));

    return reinterpret_cast<const BYTE*>(p);
}



static DWORD FindEndOfHeader(LPCSTR p, DWORD length)
{
    LPCSTR pEnd = p + length;
    LPCSTR pEndOfHeader = search(
                            p, 
                            pEnd, 
                            xEndOfHttpHeaderRequest, 
                            xEndOfHttpHeaderRequest + STRLEN(xEndOfHttpHeaderRequest)
                            );
    
    if((pEndOfHeader == pEnd) || ((pEndOfHeader + STRLEN(xEndOfHttpHeaderRequest)) == pEnd))
    {
		TrERROR(Mp, "could not find end of header");
        throw bad_request();	
    }

    pEndOfHeader += STRLEN(xEndOfHttpHeaderRequest);
    return numeric_cast<DWORD>((pEndOfHeader - p)); 
}



static xstr_t FindHeaderField(LPCSTR p, DWORD length, LPCSTR fieldName)
{
	const char xFieldSeperator[] = "\r\n";


    //
    // HTTP header must terminate with '\r\n\r\n'. We already parse
    // the header and find it as a legal HTTP header.
    //
    ASSERT(length >= 4);

    LPCSTR pEnd = p + length;
    
    p = search (p, pEnd, fieldName, fieldName + strlen(fieldName));	
    if((p == pEnd) || ((p + strlen(fieldName)) == pEnd))
    {
		TrERROR(Mp, "could not find header field");
        throw bad_request();	
    }
    
    p += strlen(fieldName);
    p = removeLeadingSpace(p, pEnd);

    LPCSTR pEndOfField = search (p, pEnd, xFieldSeperator, xFieldSeperator + strlen(xFieldSeperator));	
    if((pEndOfField == pEnd) || ((pEndOfField + strlen(fieldName)) == pEnd))
    {
		TrERROR(Mp, "could not find field seperator");
        throw bad_request();	
    }
    
    pEndOfField = removeTralingSpace(p, pEndOfField);

    return xstr_t(p, (pEndOfField - p + 1));
}




static xstr_t FindBoundarySeperator(xstr_t contentType)
{
    LPCSTR p = contentType.Buffer();
    LPCSTR pEnd = p + contentType.Length();

    //
    // looking for boundary attribute
    //
	const char xBoundary[] = "boundary=";

    p = search (p, pEnd, xBoundary, xBoundary + STRLEN(xBoundary));	
    if((p == pEnd) || ((p + STRLEN(xBoundary)) == pEnd))
    {
		TrERROR(Mp, "no seperator boundery found!!");
        throw bad_request();	
    }
    
    p += STRLEN(xBoundary);
    p = removeLeadingSpace(p, pEnd);

    //
    // mime attribute value can be enclosed by '"' or not
    //
    if (*p =='"')
        ++p;

    //
    // looking for end of boundary attribute. It can be '\r\n' or ';'
    //
    LPCSTR ptemp = strchr(p, ';');
    if ((ptemp != NULL) && (pEnd > ptemp))
    {
        pEnd = --ptemp;
    }
    
    pEnd = removeTralingSpace(p, pEnd);

    if (*pEnd =='"')
        --pEnd;

    return xstr_t(p, (pEnd - p + 1));
}


static
const BYTE*
GetSection(
    const BYTE* pSection,
    size_t sectionLength,
    CAttachmentsArray* pAttachments	,
	const BYTE* pHttpBody,
	const BYTE* pEndHttpBody 
    )
{
	
	ASSERT(pHttpBody <= pSection); 


    const char* pHeader = reinterpret_cast<const char*>(pSection);

    //
    // Find the end of Envelope header
    //
    DWORD headerSize = FindEndOfHeader(pHeader, numeric_cast<DWORD>(sectionLength));

    //
    // Find Content-Id value;
    //
	CAttachment attachment;
    attachment.m_id = FindHeaderField(pHeader, headerSize, xContentId);


    //
    // Get section size
    //
    xstr_t contentLengthField = FindHeaderField(pHeader, headerSize, xContentLength);
    ASSERT(contentLengthField.Length() != 0);
    DWORD size = atoi(contentLengthField.Buffer());


	const BYTE* pNextSection = 	pSection + headerSize + size;
	//
	// check overflow
	//
	if(pNextSection >= pEndHttpBody)
	{
		TrERROR(Mp, "Request over flow!");
		throw bad_request();	
	}

	const BYTE* pAttachmentData = pSection  + headerSize;
        attachment.m_data = xbuf_t<const VOID>((pAttachmentData), size);
	attachment.m_offset	= numeric_cast<DWORD>(pAttachmentData - pHttpBody);

	pAttachments->push_back(attachment);

    return pNextSection;
}



static
wstring
GetAttachments(
    const BYTE* pHttpBody,
    DWORD HttpBodySize,
    CAttachmentsArray* pAttachments,
    xstr_t boundary
    )
{
	const BYTE* p = pHttpBody;
    const BYTE* pEndHttpBody = p + HttpBodySize;
    const char* pAttachmentHeader = reinterpret_cast<const char*>(p);

    //
    // Find the end of Envelope header
    //
    DWORD headerSize = FindEndOfHeader(pAttachmentHeader, HttpBodySize);
    xstr_t contentLength = FindHeaderField(pAttachmentHeader, headerSize, xContentLength);

    DWORD envelopeSize = atoi(contentLength.Buffer());

    //
	// check overflow
	//
	const BYTE* pStartEnv =  p + headerSize;
	const BYTE* pEndEnv =  pStartEnv + envelopeSize;
	if(pEndEnv >= pEndHttpBody)
	{
		TrERROR(Mp, "Request over flow!");
		throw bad_request();	
	}
   
    wstring envelope = UtlUtf8ToWcs(pStartEnv, envelopeSize);
 
   
    p = pEndEnv;

	//
	// Loop over the mime parts that are seperated by boundary seperator
	//
    for(;;)
    {
	
		//
        // After each section should appear Multipart boundary seperator
        //
        p = ParseBoundaryLineDelimeter(p, boundary);
		if(p == pEndHttpBody)
			break;


		//
		// "--" at the end of the boundary is a mark  for the last mime part
		//
		bool fEnd =  UtlIsStartSec(
				(char*)p,
				(char*)pEndHttpBody,
				BOUNDARY_HYPHEN,
				BOUNDARY_HYPHEN + STRLEN(BOUNDARY_HYPHEN)
				);

		if(fEnd)
			break;

		ASSERT(pEndHttpBody > p);

        p = GetSection(
			p, 
			(pEndHttpBody - p), 
			pAttachments, 
			pHttpBody,
			pEndHttpBody
			);
      
    }

    return envelope; 
}


wstring
ParseHttpMime(
    const char* pHttpHeader,
    DWORD HttpBodySize,
    const BYTE* pHttpBody,
    CAttachmentsArray* pAttachments
    )
{
    //
    // Get Content-Type
    //
    xstr_t contentType = FindHeaderField(pHttpHeader, strlen(pHttpHeader), xContentType);

    if (contentType == xEnvelopeContentTypeValue)
    {
        //
        // Simple message. The message doesn't contain external reference
        //
       return  UtlUtf8ToWcs(pHttpBody, HttpBodySize);
    }

    if ((contentType.Length() >= STRLEN(xMimeContentTypeValue)) &&
        (_strnicmp(contentType.Buffer(), xMimeContentTypeValue,STRLEN(xMimeContentTypeValue)) == 0))
    {
        return GetAttachments(
			pHttpBody, 
			HttpBodySize, 
			pAttachments, 
			FindBoundarySeperator(contentType));
    }

    TrERROR(Mp, "Bad HTTP request. Unsupported Content-Type field");
    throw bad_request();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mp\lib\serialize.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    convMsmq.cpp

Abstract:
    Converts MSMQ packet to SRMP packet

Author:
    Uri Habusha (urih) 25-May-00

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include <mp.h>
#include <qmpkt.h>
#include "mpp.h"
#include "envcommon.h"
#include "envelop.h"

#include "serialize.tmh"

using namespace std;


R<CSrmpRequestBuffers>
MpSerialize(
    const CQmPacket& pkt,
	LPCWSTR targethost,
	LPCWSTR uri
	)
{
	MppAssertValid();
	ASSERT(targethost != NULL);
	ASSERT(uri != NULL);
	return new CSrmpRequestBuffers(pkt, targethost, uri);	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\msm\lib\msminit.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    MsmInit.cpp

Abstract:
    Multicast Session Manager initialization

Author:
    Shai Kariv (shaik) 05-Sep-00

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include "Msm.h"
#include "Msmp.h"

#include "msminit.tmh"

VOID
MsmInitialize(
    VOID
    )
/*++

Routine Description:
    Initializes Multicast Session Manager library

Arguments:
    None.

Returned Value:
    None.

--*/
{
    //
    // Validate that the Multicast Session Manager library was not initalized yet.
    // You should call its initalization only once.
    //
    ASSERT(!MsmpIsInitialized());
    MsmpRegisterComponent();

    //
    // retrieve configuartion parameters from the registry
    //
    MsmpInitConfiguration();

    MsmpSetInitialized();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mp\test\packet.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    packet.cpp

Abstract:
    generates valid MSMQ packet

Author:
    Uri Habusha (urih) 25-May-00

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include <mqwin64a.h>
#include <xstr.h>
#include <fn.h>
#include "ph.h"

#include "packet.tmh"

using namespace std;


const WCHAR xTitle[] = L"<This mess<=age was #; generated for <<&\">> testing purpose only";
const UCHAR xExtension[] = "extension data";
const UCHAR xBody[] = "aaaaa bbbbb ccccc dddddd eeeee fffff gggggg kkkkkkkk lllllllllllll";
const UCHAR xCorelationId[PROPID_M_CORRELATIONID_SIZE] = "set correclation Id";
const DWORD xDeltaInqueue = 200000;

class CProperties 
{
public:
    CProperties(void) 
    {
        memset(this, 0, sizeof(CProperties));

        delivery = MQMSG_DELIVERY_EXPRESS;
        absoluteTimeToQueue = LONG_MAX;
        acknowledgeType = DEFAULT_M_ACKNOWLEDGE;
        classValue = MQMSG_CLASS_NORMAL;
        priority = DEFAULT_M_PRIORITY;
        auditing = MQMSG_JOURNAL_NONE;
    }

public:
    GUID sourceId;
    GUID destId;

    P<QUEUE_FORMAT> pDestQueue;
    P<QUEUE_FORMAT> pAdminQueue;
    P<QUEUE_FORMAT> pResponseQueue;
	CFnMqf destMqf;
	CFnMqf adminMqf;
	CFnMqf responseMqf;
	QUEUE_FORMAT DebugQueue;

    OBJECTID messageId;

    DWORD absoluteTimeToQueue;
    long sentTime;

    UCHAR delivery;
    bool fTrace;

    UCHAR acknowledgeType;
    USHORT classValue;
    DWORD applicationTag;

    UCHAR auditing;
    UCHAR priority;
    GUID connectorType;

    bool fEod;
	LONGLONG EodAckseqId;
	LONGLONG EodAckseqNo;
	const WCHAR* EodAckStreamId;


    LONGLONG seqId;
    DWORD seqNo;
    DWORD prevSeqNo;
    bool fFirst;
    bool fLast;
    GUID connectorId;

    DWORD titleLength;
    LPCWSTR pTitle;

    DWORD extensionSize;
    const BYTE* pExtension;
	
    DWORD bodySize;
    DWORD bodyType;
    const BYTE* pBody;

    UCHAR correlation[PROPID_M_CORRELATIONID_SIZE]; 

    DWORD senderCertSize;
    const BYTE* pSenderCert;

    DWORD signatureSize;
    const BYTE* pSignature;

    bool fDefaultProvider;
    LPCWSTR providerName;
    DWORD providerType;

}; 


const WCHAR xDestQueue[] = L"http://www.foo.com\\q1";
const WCHAR xAdminQueue[] = L"http://www.foo.com\\q2";

static
QUEUE_FORMAT*
GenerateQueueFormat(
    bool fDestQueue
    )
{
    if (fDestQueue)
    {
        return new QUEUE_FORMAT(const_cast<LPWSTR>(xDestQueue));
    }

    QUEUE_FORMAT_TYPE type = static_cast<QUEUE_FORMAT_TYPE>(rand() % static_cast<int>(QUEUE_FORMAT_TYPE_DIRECT + 1));
    

    switch (type)
    {
        case QUEUE_FORMAT_TYPE_PUBLIC:
        {
            GUID id;
            UuidCreate(&id);
        
            return new QUEUE_FORMAT(id);
        }

        case QUEUE_FORMAT_TYPE_PRIVATE:
        {
            GUID id;
            UuidCreate(&id);
        
            return new QUEUE_FORMAT(id, rand());
        }

        case QUEUE_FORMAT_TYPE_DIRECT:
        {
            return new QUEUE_FORMAT(const_cast<LPWSTR>(xAdminQueue));
        }
    }

    return NULL;
}


static
DWORD
CalculatePacketSize(
    CProperties& mProp
    )
{
    DWORD packetSize;
    
    packetSize  = CBaseHeader::CalcSectionSize();

    ASSERT(mProp.pDestQueue->GetType() != QUEUE_FORMAT_TYPE_UNKNOWN);

    packetSize += CUserHeader::CalcSectionSize(
                        &mProp.sourceId,
                        &mProp.destId,
                        (mProp.connectorType != GUID_NULL) ? &mProp.connectorType: NULL,
                        mProp.pDestQueue,
                        mProp.pAdminQueue,
                        mProp.pResponseQueue
                        );

    if (mProp.fEod)
    {
        packetSize += CXactHeader::CalcSectionSize(
										&mProp.seqId, 
										mProp.connectorId == GUID_NULL ? NULL : &mProp.connectorId
										);
    }

    if ((mProp.pSignature != NULL) || mProp.pSenderCert != NULL)
    {
        DWORD ProviderInfoSize = 0;
        if (!mProp.fDefaultProvider)
        {
            ProviderInfoSize = (wcslen(mProp.providerName) + 1) * sizeof(WCHAR) + sizeof(ULONG);
        }

        packetSize += CSecurityHeader::CalcSectionSize(
                                            0, // Sender ID size
                                            0, // Encrypted Key Size
                                            static_cast<USHORT>(mProp.signatureSize), 
                                            static_cast<USHORT>(mProp.senderCertSize),
                                            static_cast<USHORT>(ProviderInfoSize)
                                            );
    }

    packetSize += CPropertyHeader::CalcSectionSize(
                        mProp.titleLength,
                        mProp.extensionSize,
                        mProp.bodySize
                        );


	if(mProp.EodAckStreamId != NULL)
	{
		packetSize += CEodAckHeader::CalcSectionSize((wcslen(mProp.EodAckStreamId) +1) *sizeof(WCHAR));		
	}

	if(mProp.destMqf.GetCount() != 0 || mProp.adminMqf.GetCount()  != 0  || mProp.responseMqf.GetCount()  !=0)
	{
		packetSize += CDebugSection::CalcSectionSize(&mProp.DebugQueue);
		packetSize += CBaseMqfHeader::CalcSectionSize(mProp.destMqf.GetQueueFormats(), mProp.destMqf.GetCount());
		packetSize += CBaseMqfHeader::CalcSectionSize(mProp.adminMqf.GetQueueFormats(), mProp.adminMqf.GetCount());
		packetSize += CBaseMqfHeader::CalcSectionSize(mProp.responseMqf.GetQueueFormats(), mProp.responseMqf.GetCount());
		packetSize += CMqfSignatureHeader::CalcSectionSize(0);
	}
	
    return packetSize;
}


static
void
BuildPacket(
    CBaseHeader* pBase,
    DWORD packetSize,
    CProperties& mProp
    )
{
    PVOID pSection = pBase;

    #pragma PUSH_NEW
    #undef new

    //
    //  Build the basic header
    //
    pBase = new(pSection) CBaseHeader(packetSize);
    pBase->SetPriority(mProp.priority);
    pBase->SetTrace(mProp.fTrace);
    pBase->SetAbsoluteTimeToQueue(mProp.absoluteTimeToQueue);

    pSection = pBase->GetNextSection();

    //
    // Build user header
    //

    CUserHeader* pUser = new (pSection) CUserHeader(
                                            &mProp.messageId.Lineage,
                                            &GUID_NULL,
                                            mProp.pDestQueue,
                                            mProp.pAdminQueue,
                                            mProp.pResponseQueue,
                                            mProp.messageId.Uniquifier
                                            );

    if (mProp.connectorType != GUID_NULL)
    {
        pUser->SetConnectorType(&mProp.connectorType);
    }

    pUser->SetTimeToLiveDelta(xDeltaInqueue);
    pUser->SetSentTime(mProp.sentTime);
    pUser->SetDelivery(mProp.delivery);
    pUser->SetAuditing(mProp.auditing);

    pSection = pUser->GetNextSection();

    //
    // Build the xact header.
    //

    if (mProp.fEod)
    {
        pUser->IncludeXact(TRUE);

        const GUID* pConnector = ((mProp.connectorId == GUID_NULL) ? NULL : &mProp.connectorId);
        CXactHeader* pXact = new (pSection) CXactHeader(pConnector);

        pXact->SetSeqID(mProp.seqId);
        pXact->SetSeqN(mProp.seqNo);
        pXact->SetPrevSeqN(mProp.prevSeqNo);
        pXact->SetFirstInXact(mProp.fFirst);
        pXact->SetLastInXact(mProp.fLast);
        if (pConnector != NULL)
        {
            pXact->SetConnectorQM(pConnector);
        }

        pSection = pXact->GetNextSection();
    }

    //
    // Build the security header.
    //
    if ((mProp.pSignature != NULL) || mProp.pSenderCert != NULL)
    {
        pUser->IncludeSecurity(TRUE);

        CSecurityHeader* pSec = new (pSection) CSecurityHeader();
        

        if (mProp.pSignature != NULL)
        {
            pSec->SetAuthenticated(TRUE);
            pSec->SetSignature(mProp.pSignature, static_cast<USHORT>(mProp.signatureSize));
        }

        if (mProp.pSenderCert != NULL)
        {
            pSec->SetSenderCert(mProp.pSenderCert, mProp.senderCertSize);
        }

        if (mProp.pSignature != NULL)
        {
            DWORD ProviderInfoSize = 0;
            if (!mProp.fDefaultProvider)
            {
                ProviderInfoSize = (wcslen(mProp.providerName) + 1) * sizeof(WCHAR) + sizeof(ULONG);
            }

            pSec->SetProvInfoEx(
                        static_cast<USHORT>(ProviderInfoSize),
                        mProp.fDefaultProvider, 
                        mProp.providerName,
                        mProp.providerType
                        );
        }

        pSection = pSec->GetNextSection();
    }


    // Build Message Property
    //
    CPropertyHeader* pProp = new (pSection) CPropertyHeader;

    pProp->SetClass(mProp.classValue);
    pProp->SetCorrelationID(mProp.correlation);
    pProp->SetAckType(mProp.acknowledgeType);
    pProp->SetApplicationTag(mProp.applicationTag);
    pProp->SetBodyType(mProp.bodyType);

    if(mProp.titleLength != 0)
    {
        //
        //  NOTE: Setting the title to the message MUST occure before setting the body
        //
        pProp->SetTitle(mProp.pTitle, mProp.titleLength);
    }

    if (mProp.extensionSize != 0)
    {
        //
        //  NOTE: Setting the Message Extension to property section MUST occure
        //        before setting the body and after setting the title
        //
        pProp->SetMsgExtension(mProp.pExtension, mProp.extensionSize);
    }

    if(mProp.bodySize != 0)
    {
        pProp->SetBody(mProp.pBody, mProp.bodySize, mProp.bodySize);
    }

	pSection = pProp->GetNextSection();


	//
	// mqf  + debug headers
	//
	if(mProp.destMqf.GetCount() != 0 || mProp.adminMqf.GetCount()  != 0  || mProp.responseMqf.GetCount()  !=0)
	{
		 //
        // Build DUMMY Debug header
        //
        pBase->IncludeDebug(TRUE);
	    CDebugSection * pDebug = new (pSection) CDebugSection(&mProp.DebugQueue);
        pSection = pDebug->GetNextSection();

        //
        // Build Destination MQF header
        //
        pUser->IncludeMqf(true);

        const USHORT x_DESTINATION_MQF_HEADER_ID = 100;
        CBaseMqfHeader * pDestinationMqf = new (pSection) CBaseMqfHeader(
                                                              mProp.destMqf.GetQueueFormats(),
                                                              mProp.destMqf.GetCount(),
                                                              x_DESTINATION_MQF_HEADER_ID
                                                              );
        pSection = pDestinationMqf->GetNextSection();

        //
        // Build Admin MQF header
        //
        const USHORT x_ADMIN_MQF_HEADER_ID = 200;
        CBaseMqfHeader * pAdminMqf = new (pSection) CBaseMqfHeader(
                                                        mProp.adminMqf.GetQueueFormats(),
                                                        mProp.adminMqf.GetCount(),
                                                        x_ADMIN_MQF_HEADER_ID
                                                        );
        pSection = pAdminMqf->GetNextSection();

        //
        // Build Response MQF header
        //
        const USHORT x_RESPONSE_MQF_HEADER_ID = 300;
        CBaseMqfHeader * pResponseMqf = new (pSection) CBaseMqfHeader(
														   mProp.responseMqf.GetQueueFormats(),
														   mProp.responseMqf.GetCount(),
														   x_RESPONSE_MQF_HEADER_ID
														   );
        pSection = pResponseMqf->GetNextSection();

		//
		// Build MQF Signature header
		//
		//
		const USHORT x_MQF_SIGNATURE_HEADER_ID = 350;
		CMqfSignatureHeader * pMqfSignature = new (pSection) CMqfSignatureHeader(
			                                                     x_MQF_SIGNATURE_HEADER_ID,
			                                                     0,
																 NULL
																 );
		pSection = pMqfSignature->GetNextSection();
                       

	}

	
	//
	// Build EOD ack section
	//
	if (mProp.EodAckStreamId != NULL)
    {
       	pUser->IncludeEodAck(TRUE);
		const USHORT x_EOD_ACK_ID = 700;
	    UCHAR* pStreamid = (UCHAR*)mProp.EodAckStreamId;
		DWORD  StreamidLen = (wcslen(mProp.EodAckStreamId) +1) * sizeof(WCHAR); 
		CEodAckHeader* EodAckHeader = new (pSection) CEodAckHeader(
												   x_EOD_ACK_ID,	
                                                   &mProp.EodAckseqId,
												   &mProp.EodAckseqNo,
												   StreamidLen,
												   pStreamid
												   );


	   pSection  = EodAckHeader->GetNextSection();
	   										
   }

   #pragma POP_NEW

}


UCHAR ackType[] = {
    MQMSG_ACKNOWLEDGMENT_NONE,
    MQMSG_ACKNOWLEDGMENT_POS_ARRIVAL,
    MQMSG_ACKNOWLEDGMENT_POS_RECEIVE,
    MQMSG_ACKNOWLEDGMENT_NEG_RECEIVE
};

UCHAR auditingType[] = {
    MQMSG_JOURNAL_NONE,
    MQMSG_DEADLETTER,
    MQMSG_JOURNAL,
    MQMSG_JOURNAL | MQMSG_DEADLETTER,
}; 

static
void
GenerateMqf(
	CFnMqf* pmqf
	)
{
	if( (rand() % 2) == 0)
		return;

	const WCHAR* Mqf[] = {L"direct=http://msmq\\gilsh10\\private$\\t,direct=http://msmq\\gilsh10\\private$\\t2",
						  L"direct=os:gilsh10\\private$\\<>t,direct=os:gilsh10\\private$\\t2",
						  L"direct=https://gilsh10\\msmq\\private$\\t>,direct=os:gilsh10\\private$\\t2"
						};
							
	size_t index = 	rand()%TABLE_SIZE(Mqf);
	pmqf->CreateFromMqf(Mqf[index]);		
}


static
VOID
SetMessageProperties(
    CProperties& mProp
    )
{
    UuidCreate(&mProp.sourceId);
    mProp.destId = GUID_NULL;

    mProp.pDestQueue = GenerateQueueFormat(true);
    mProp.pResponseQueue = GenerateQueueFormat(false);
	GenerateMqf(&mProp.destMqf);
	GenerateMqf(&mProp.adminMqf);
	GenerateMqf(&mProp.responseMqf);

   

    mProp.messageId.Lineage = mProp.sourceId;
    mProp.messageId.Uniquifier = rand();

    mProp.absoluteTimeToQueue = ((rand() % 3) == 0) ? rand() : LONG_MAX - xDeltaInqueue; 
	if(mProp.absoluteTimeToQueue > 	 LONG_MAX - xDeltaInqueue)
	{
		mProp.absoluteTimeToQueue = LONG_MAX - xDeltaInqueue;
	}
	

    time_t sentTime;
    time(&sentTime);
    mProp.sentTime = LOW_DWORD(sentTime);

    mProp.delivery = (UCHAR)(((rand() % 2) == 0) ? MQMSG_DELIVERY_EXPRESS : MQMSG_DELIVERY_RECOVERABLE);
    mProp.fTrace = ((rand() % 4) == 0);

    mProp.acknowledgeType = ackType[rand() % TABLE_SIZE(ackType)];
    if (mProp.acknowledgeType != MQMSG_ACKNOWLEDGMENT_NONE)
    {
        mProp.pAdminQueue = GenerateQueueFormat(false);
    }


    mProp.classValue = MQMSG_CLASS_NORMAL;
    mProp.applicationTag = rand();

    mProp.auditing = auditingType[rand() % TABLE_SIZE(auditingType)];
    mProp.priority = 3;
    UuidCreate(&mProp.connectorType);

    mProp.fEod = ((rand() %3) == 0);
    if (mProp.fEod)
    {
        mProp.delivery = MQMSG_DELIVERY_RECOVERABLE;

        mProp.seqId = rand();
        mProp.seqNo = rand();
        mProp.prevSeqNo = mProp.seqNo - 1;
        mProp.fFirst = ((rand() % 2) == 0);
        mProp.fLast = ((rand() % 2) == 0);
        if ((rand() % 2) == 0)
        {
            UuidCreate(&mProp.connectorId);
        }
        else
        {  
            mProp.connectorId = GUID_NULL;
        }
    }
	else
	{
		if((rand() %2) == 0)
		{
			mProp.EodAckseqId = 0x12345678;
			mProp.EodAckseqNo  = 22;
			mProp.EodAckStreamId = L"acked stream id";
			mProp.classValue = MQMSG_CLASS_ORDER_ACK;
		}
	}

    mProp.titleLength = STRLEN(xTitle) + 1;
    mProp.pTitle = xTitle;

    mProp.extensionSize = STRLEN(xExtension);
    mProp.pExtension = xExtension;

	
	mProp.bodyType = rand();
	mProp.bodySize = STRLEN(xBody);
	mProp.pBody =  xBody;
	
	

    for (DWORD i = 0; i < PROPID_M_CORRELATIONID_SIZE; ++i)
    {
        mProp.correlation[i] = static_cast<UCHAR>(i); 
    }

    mProp.senderCertSize = 0;
    mProp.pSenderCert = NULL;

    mProp.signatureSize = 0;
    mProp.pSignature = NULL;

    mProp.fDefaultProvider = true;
}


CBaseHeader* CreatePacket(void)
{
    CProperties mProp;

    SetMessageProperties(mProp);

    DWORD packetSize = CalculatePacketSize(mProp);

    PUCHAR pkt = new UCHAR[packetSize];

    BuildPacket(reinterpret_cast<CBaseHeader*>(pkt), packetSize, mProp);
	
    return reinterpret_cast<CBaseHeader*>(pkt);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\msm\lib\msmlisten.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    MsmListen.cpp

Abstract:
    Multicast Listener implementation

Author:
    Shai Kariv (shaik) 05-Sep-00

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include <winsock.h>
#include <Mswsock.h>
#include <WsRm.h>
#include <Cm.h>
#include "MsmListen.h"
#include "MsmReceive.h"
#include "Msmp.h"

#include "msmlisten.tmh"

static void MsmpDumpPGMReceiverStats(const SOCKET s);
static CTimeDuration s_AcceptRetryTimeout( 10 * 1000 * CTimeDuration::OneMilliSecond().Ticks() );
static CTimeDuration s_ReceiverCleanupTimeout( 120 * 1000 * CTimeDuration::OneMilliSecond().Ticks() );

void MsmpInitConfiguration(void)
{
    CmQueryValue(
        RegEntry(NULL, L"MulticastAcceptRetryTimeout", 10 * 1000),   // 10 seconds
        &s_AcceptRetryTimeout
        );
                      
    CmQueryValue(
        RegEntry(NULL, L"MulticastReceiversCleanupTimeout", 120 * 1000),  // 2 minutes 
        &s_ReceiverCleanupTimeout
        );
}


CMulticastListener::CMulticastListener(
    MULTICAST_ID id
    ):
    m_MulticastId(id),
    m_ov(AcceptSucceeded, AcceptFailed),
    m_retryAcceptTimer(TimeToRetryAccept),
	m_cleanupTimer(TimeToCleanupUnusedReceiever),
	m_fCleanupScheduled(FALSE)
/*++

Routine Description:
    Bind to multicast group. Schedule async accept on the socket.

Arguments:
    id - The multicast group IP address and port.

Returned Value:
    None.

--*/
{
    TrTRACE(Msm, "Create multicast listener for %d:%d", id.m_address, id.m_port);

    DWORD flags = WSA_FLAG_MULTIPOINT_C_LEAF | WSA_FLAG_MULTIPOINT_D_LEAF | WSA_FLAG_OVERLAPPED;
    *&m_ListenSocket = WSASocket(AF_INET, SOCK_RDM, IPPROTO_RM, NULL, 0, flags);
    if (m_ListenSocket == INVALID_SOCKET)
    {
        DWORD ec = WSAGetLastError();

        TrERROR(Msm, "Failed to create PGM listen socket, error %d", ec);
        throw bad_win32_error(ec);
    }

    SOCKADDR_IN address;
    address.sin_family = AF_INET;
    address.sin_port   = htons(numeric_cast<u_short>(m_MulticastId.m_port));
    address.sin_addr.s_addr = m_MulticastId.m_address;

    int rc;
    rc = bind(m_ListenSocket, (SOCKADDR *)&address, sizeof(address));
    if (rc == SOCKET_ERROR)
    {
        DWORD ec = WSAGetLastError();

        TrERROR(Msm, "Failed to bind to PGM socket, error %d", ec);
        throw bad_win32_error(ec);
    }

    rc = listen(m_ListenSocket, 1);
    if (rc == SOCKET_ERROR)
    {
        DWORD ec = WSAGetLastError();

        TrERROR(Msm, "Failed to listen to PGM socket, error %d", ec);
        throw  bad_win32_error(ec);
    }

    ExAttachHandle(reinterpret_cast<HANDLE>(*&m_ListenSocket));

    //
    // Begin aynchronous accept, to insure failure overcome
    //
    AddRef();
    ExSetTimer(&m_retryAcceptTimer, CTimeDuration(0));
} 


void
CMulticastListener::IssueAccept(
    void
    )
/*++

Routine Description:
    Issue async accept request.

Arguments:
    None.

Returned Value:
    None.

--*/
{
    DWORD flags = WSA_FLAG_MULTIPOINT_C_LEAF | WSA_FLAG_MULTIPOINT_D_LEAF | WSA_FLAG_OVERLAPPED;
    *&m_ReceiveSocket = WSASocket(AF_INET, SOCK_RDM, IPPROTO_RM, NULL, 0, flags);
    if (m_ReceiveSocket == INVALID_SOCKET)
    {
        DWORD rc = WSAGetLastError();

        TrERROR(Msm, "Failed to create PGM receive socket, error %d", rc);
        throw bad_win32_error(rc);
    }

    //
    // Get the CS so no one will close the listner while we try to accept
    //
    CS lock(m_cs);

    //
    // Increment ref count on this object.
    // The completion routines decrement the ref count.
    //
    R<CMulticastListener> ref = SafeAddRef(this);
    
    DWORD BytesReceived;
    BOOL f = AcceptEx(
                m_ListenSocket, 
                m_ReceiveSocket, 
                m_AcceptExBuffer, 
                0, 
                40, 
                40, 
                &BytesReceived, 
                &m_ov
                );

    DWORD rc = WSAGetLastError();
    if (!f && rc != ERROR_IO_PENDING)
    {
        TrERROR(Msm, "Failed to issue AcceptEx on socket, error %d", rc);
        throw bad_win32_error(rc);
    }

    //
    // All went well. Completion routines will complete the work.
    //
    ref.detach();
} 



void
CMulticastListener::AcceptSucceeded(
    void
    )
{
	SOCKADDR* localSockAddr;
	SOCKADDR* remoteSockAddr;
	int localSockaddrLength, remoteSockaddrLength; 
	GetAcceptExSockaddrs(
		m_AcceptExBuffer,
		0,
		40, 
		40,
		&localSockAddr,
		&localSockaddrLength,
		&remoteSockAddr,
		&remoteSockaddrLength
		);


	WCHAR storeRemoteAddr[256] = L"";
	LPSTR remoteAddr = inet_ntoa((reinterpret_cast<sockaddr_in*>(remoteSockAddr))->sin_addr);
	if (remoteAddr != NULL)
	{
		_snwprintf(storeRemoteAddr, TABLE_SIZE(storeRemoteAddr), L"%hs", remoteAddr);
	}

    //
    // Get the receive socket to local variable.
    // The member receive socket is detached so that we can reissue async accept.
    //
    CSocketHandle socket(m_ReceiveSocket.detach());

    try
    {
        IssueAccept();
    }
    catch (const bad_win32_error& )
    {
        AddRef();
        ExSetTimer(&m_retryAcceptTimer, s_AcceptRetryTimeout);
    }  

    //
    // Pass responsibility on Auto socket to the receiver. Don't call detach.
    //
    CreateReceiver(socket, storeRemoteAddr);
}


void 
WINAPI 
CMulticastListener::AcceptSucceeded(
    EXOVERLAPPED* pov
    )
{
    ASSERT(SUCCEEDED(pov->GetStatus()));
    R<CMulticastListener> pms = CONTAINING_RECORD(pov, CMulticastListener, m_ov);

    pms->AcceptSucceeded();

} 


void
CMulticastListener::AcceptFailed(
    void
    )
{
    
    MsmpDumpPGMReceiverStats(m_ListenSocket);
    //
    // Failed to issue an accept. secudel accept retry
    //
    AddRef();
    ExSetTimer(&m_retryAcceptTimer, s_AcceptRetryTimeout);
} 


void 
WINAPI 
CMulticastListener::AcceptFailed(
    EXOVERLAPPED* pov
    )
{
    ASSERT(FAILED(pov->GetStatus()));
    TrERROR(Msm, "Accept failed, error %d", pov->GetStatus());

    R<CMulticastListener> pms = CONTAINING_RECORD(pov, CMulticastListener, m_ov);

    pms->AcceptFailed();

}


void 
CMulticastListener::RetryAccept(
    void
    )
{
    //
    // Check listner validity. If the listener already closed, don't try to issue a new accept.
    //
    CS lock(m_cs);
    if (m_ListenSocket == INVALID_SOCKET)
        return;

    try
    {
        IssueAccept();
    }
    catch (const bad_win32_error& )
    {
        AddRef();
        ExSetTimer(&m_retryAcceptTimer, s_AcceptRetryTimeout);
    }
}


void 
WINAPI 
CMulticastListener::TimeToRetryAccept(
    CTimer* pTimer
    )
{
    R<CMulticastListener> pms = CONTAINING_RECORD(pTimer, CMulticastListener, m_retryAcceptTimer);
    pms->RetryAccept();
}


void 
CMulticastListener::CleanupUnusedReceiver(
	void
	)
/*++

Routine Description:
    Cleanup unused receivers.  The routine scans the receivers and checkes if it was used in 
	the last cleanup interval. If the receiver was in ideal state, the routine shutdown the 
	receiver and remove it from the active receiver list 

Arguments:
    None.

Returned Value:
    None.

Note:
	The routine rearm the cleanup timer if still has an active receivers.
--*/
{
	//
	// Get the critical secction, so no other thread will chnage the receiver list
	// while the routine scans the list
	//
	CS lock(m_cs);

    //
    // Check listner validity. If the listener already closed exit
    //
    if (m_ListenSocket == INVALID_SOCKET)
        return;

	//
	// Scan the receiver list
	//
	ReceiversList::iterator it = m_Receivers.begin(); 
    while(it != m_Receivers.end())
	{
		R<CMulticastReceiver> pReceiver = *it;
		
		if(pReceiver->IsUsed())
        { 
			//
			// Mark the receiver as unused. 
			//
			pReceiver->SetIsUsed(false);

            ++it;
            continue;
        }

        //
		// The receiver isn't used. Shut it down and remove the receiver from the list
		//
        TrTRACE(Msm, "Shutdown unused receiver. pr = 0x%p", pReceiver.get());

		pReceiver->Shutdown();
		it = m_Receivers.erase(it);
	}

	//
	// If not exist an active receiver, clear the flag that indicates if 
	// cleanup was scheduled or not
	//
	if (m_Receivers.empty())
	{
		InterlockedExchange(&m_fCleanupScheduled, FALSE);
		return;
	}

	//
	// still has an active receivers, rearm the cleanup timer
	//
	AddRef();
	ExSetTimer(&m_cleanupTimer, s_ReceiverCleanupTimeout);
}


void 
WINAPI 
CMulticastListener::TimeToCleanupUnusedReceiever(
    CTimer* pTimer
    )
{
    R<CMulticastListener> pms = CONTAINING_RECORD(pTimer, CMulticastListener, m_cleanupTimer);

    TrTRACE(Msm, "Call cleanup unused receiever on listener 0x%p", pms.get()); 
    pms->CleanupUnusedReceiver();
}


void
CMulticastListener::CreateReceiver(
    CSocketHandle& socket,
	LPCWSTR remoteAddr
    )
/*++

Routine Description:
    Create a new receiver object and start receive.

Arguments:
    None.

Returned Value:
    None.

--*/
{
    R<CMulticastReceiver> pReceiver = new CMulticastReceiver(socket, m_MulticastId, remoteAddr);

    try
    {
		CS lock(m_cs);
        m_Receivers.push_back(pReceiver);
    }
    catch (const bad_alloc&)
    {
        TrERROR(Msm, "Failed to insert to list of receivers");
        pReceiver->Shutdown();

        throw;
    }

	if (InterlockedExchange(&m_fCleanupScheduled, TRUE) == FALSE)
	{
		AddRef();
		ExSetTimer(&m_cleanupTimer, s_ReceiverCleanupTimeout);
	}
} 


void
CMulticastListener::Close(
    void
    ) 
    throw()
/*++

Routine Description:

    Stop listen on the multicast group address. Close all receivers.

Arguments:

    None.

Returned Value:

    None.

--*/
{
    CS lock(m_cs);

    if (m_ListenSocket == INVALID_SOCKET)
    {
        //
        // The receiver already closed
        //
        ASSERT(m_Receivers.empty());

        return;
    }

    //
    // Try to cancel the accept retry. If succeeded decrement the reference count
    //
    if (ExCancelTimer(&m_retryAcceptTimer))
    {
        Release();
    }

	//
	// Try to cancel cleanup timer
	//
	if (ExCancelTimer(&m_cleanupTimer))
    {
        Release();
    }

    MsmpDumpPGMReceiverStats(m_ListenSocket);
    
    //
    // Stop listening
    //
    closesocket(m_ListenSocket.detach());

    //
    // Close receivers
    //
    ReceiversList::iterator it;
    for (it = m_Receivers.begin(); it != m_Receivers.end(); )
    {
        (*it)->Shutdown();
		it = m_Receivers.erase(it); 
    }
}







void MsmpDumpPGMReceiverStats(const SOCKET s) 
/*++

Routine Description:

	Get statistic information from the PGM sockets.

Arguments:

    socket - PGM socket.

Returned Value:

    None.

--*/
{
	if(!WPP_LEVEL_COMPID_ENABLED(rsTrace, Msm))
    {
		return;
	}
		
	RM_RECEIVER_STATS	RmReceiverStats;
	INT BufferLength = sizeof(RM_RECEIVER_STATS);
	memset(&RmReceiverStats,0,BufferLength);
	ULONG ret = getsockopt( s, IPPROTO_RM, RM_RECEIVER_STATISTICS,(char *)&RmReceiverStats,&BufferLength);
	if ( ERROR_SUCCESS != ret )
	{
		TrERROR(Msm, "GetReceiverStats: Failed to retrieve receiver stats! error = %d",WSAGetLastError());
		return;
	}
	TrTRACE(Msm,"NumODataPacketsReceived = <%I64d>",RmReceiverStats.NumODataPacketsReceived);
	TrTRACE(Msm,"NumRDataPacketsReceived = <%I64d>",RmReceiverStats.NumRDataPacketsReceived);
	TrTRACE(Msm,"NumDuplicateDataPackets = <%I64d>",RmReceiverStats.NumDuplicateDataPackets);
	TrTRACE(Msm,"DataBytesReceived       = <%I64d>",RmReceiverStats.DataBytesReceived);
	TrTRACE(Msm,"TotalBytesReceived      = <%I64d>",RmReceiverStats.TotalBytesReceived);
	TrTRACE(Msm,"RateKBitsPerSecOverall  = <%I64d>",RmReceiverStats.RateKBitsPerSecOverall);
	TrTRACE(Msm,"RateKBitsPerSecLast     = <%I64d>",RmReceiverStats.RateKBitsPerSecLast);
	TrTRACE(Msm,"TrailingEdgeSeqId       = <%I64d>",RmReceiverStats.TrailingEdgeSeqId);
	TrTRACE(Msm,"LeadingEdgeSeqId        = <%I64d>",RmReceiverStats.LeadingEdgeSeqId);
	TrTRACE(Msm,"AverageSequencesInWindow= <%I64d>",RmReceiverStats.AverageSequencesInWindow);
	TrTRACE(Msm,"MinSequencesInWindow    = <%I64d>",RmReceiverStats.MinSequencesInWindow);
	TrTRACE(Msm,"MaxSequencesInWindow    = <%I64d>",RmReceiverStats.MaxSequencesInWindow);
	TrTRACE(Msm,"FirstNakSequenceNumber  = <%I64d>",RmReceiverStats.FirstNakSequenceNumber);
	TrTRACE(Msm,"NumPendingNaks          = <%I64d>",RmReceiverStats.NumPendingNaks);
	TrTRACE(Msm,"NumOutstandingNaks      = <%I64d>",RmReceiverStats.NumOutstandingNaks);
	TrTRACE(Msm,"NumDataPacketsBuffered  = <%I64d>",RmReceiverStats.NumDataPacketsBuffered);
	TrTRACE(Msm,"TotalSelectiveNaksSent  = <%I64d>",RmReceiverStats.TotalSelectiveNaksSent);
	TrTRACE(Msm,"TotalParityNaksSent     = <%I64d>",RmReceiverStats.TotalParityNaksSent);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\msm\lib\msmdebug.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    MsmDebug.cpp

Abstract:
    Multicast Session Manager debugging

Author:
    Shai Kariv (shaik) 05-Sep-00

Environment:
    Platform-independent, _DEBUG only

--*/

#include <libpch.h>
#include "Msm.h"
#include "Msmp.h"

#include "msmdebug.tmh"

#ifdef _DEBUG


//---------------------------------------------------------
//
// Validate Multicast Session Manager state
//
void MsmpAssertValid(void)
{
    //
    // MsmInitalize() has *not* been called. You should initialize the
    // Multicast Session Manager library before using any of its funcionality.
    //
    ASSERT(MsmpIsInitialized());

    //
    // TODO:Add more Multicast Session Manager validation code.
    //
}


//---------------------------------------------------------
//
// Initialization Control
//
static LONG s_fInitialized = FALSE;

void MsmpSetInitialized(void)
{
    LONG fMsmAlreadyInitialized = InterlockedExchange(&s_fInitialized, TRUE);

    //
    // The Multicast Session Manager library has *already* been initialized. You should
    // not initialize it more than once. This assertion would be violated
    // if two or more threads initalize it concurently.
    //
    ASSERT(!fMsmAlreadyInitialized);
}


BOOL MsmpIsInitialized(void)
{
    return s_fInitialized;
}


//---------------------------------------------------------
//
// Tracing and Debug registration
//
const TraceIdEntry xTraceTable[] = {

    Msm,

    //
    // TODO: Add Multicast Session Manager sub-component trace ID's to be used with TrXXXX.
    // For example, MsmInit, as used in:
    // TrERROR(MsmInit, "Error description", parameters)
    //
};

/*
const DebugEntry xDebugTable[] = {

    {
        "MsmDumpState(queue path name)",
        "Dump Multicast Session Manager State to debugger",
        DumpState
    ),

    //
    // TODO: Add Multicast Session Manager debug & control functions to be invoked using
    // mqctrl.exe utility.
    //
};
*/

void MsmpRegisterComponent(void)
{
    TrRegisterComponent(xTraceTable, TABLE_SIZE(xTraceTable));
    //DfRegisterComponent(xDebugTable, TABLE_SIZE(xDebugTable));
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\msm\lib\msmbind.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    MsmBind.cpp

Abstract:
    Multicast Session Manager bind queue to multicast address implementation.

Author:
    Shai Kariv (shaik) 10-Sep-00

Environment:
    Platform-independent.

--*/

#include <libpch.h>
#include <mqwin64a.h>
#include <mqsymbls.h>
#include <qformat.h>
#include <mqformat.h>
#include "Msm.h"
#include "Msmp.h"
#include "MsmListen.h"
#include "MsmMap.h"

#include "msmbind.tmh"

using namespace std;

//
// Critcal section uses to synchronize bind and unbind operation
// 
static CCriticalSection s_csBindUnbind(CCriticalSection::xAllocateSpinCount);

static
void
MsmpCreateListener(
    const QUEUE_FORMAT& QueueFormat,
    MULTICAST_ID        MulticastId
    )
/*++

Routine Description:
    Bind queue to multicast group.
    It is expected that the queue is not currently bound to any group.

Arguments:
    QueueFormat - Identifies the queue.
    MulticastId - Identifies the multicast group (address and port).

Returned Value:
    None.

--*/
{
    //
    // Create a multicast listener object to listen on the address
    //
    R<CMulticastListener> pListener = new CMulticastListener(MulticastId);
    
    //
    // Add the <queue, listener> pair to the mapping database
    //
    try
    {
        MsmpMapAdd(QueueFormat, MulticastId, pListener);
    }
    catch (const exception&)
    {
        pListener->Close();
        throw;
    }

}


void
MsmBind(
    const QUEUE_FORMAT& QueueFormat,
    MULTICAST_ID        MulticastId
    )
/*++

Routine Description:

    Bind or rebind a queue to the specified multicast group.

Arguments:

    QueueFormat - Identifier of the queue.

    MulticastId - Identifier of the multicast group (address and port).

Returned Value:

    None. Throws exception.

--*/
{
    MsmpAssertValid();

    ASSERT((
        "Only private and public queues format names expected!", 
        QueueFormat.GetType() == QUEUE_FORMAT_TYPE_PRIVATE || QueueFormat.GetType() == QUEUE_FORMAT_TYPE_PUBLIC
        ));

    //
    // Ensure that no other thread tries to bind or unbind at the smae time. It can
    // cause database inconsistency.
    //
    CS lock(s_csBindUnbind);

    //
    // Look for previous binding of the queue. If the queue already bind to same
    // address no further acction is required. Otherwise before binding to the new 
    // address the code unbind to previous address 
    //
    MULTICASTID_VALUES bindedIds = MsmpMapGetBoundMulticastId(QueueFormat);
    if (!bindedIds.empty())
    {
        ASSERT(("Queue can't be bounded to more than one multicast address", (bindedIds.size() == 1)));

        MULTICAST_ID bindId = *(bindedIds.begin());
        if (MulticastId.m_address == bindId.m_address &&
            MulticastId.m_port == bindId.m_port)
        {
            //
            // Already bound to the specified multicast group. No-op.
            //
            return;
        }

        //
        // Unbind the queue. 
        //
        MsmUnbind(QueueFormat);
    }

    WCHAR strQueueFormat[256];
    DWORD temp;

    MQpQueueFormatToFormatName(&QueueFormat, strQueueFormat, TABLE_SIZE(strQueueFormat), &temp, FALSE);
    TrTRACE(Msm, "Bind queue %ls to multicast id %d:%d", strQueueFormat, MulticastId.m_address, MulticastId.m_port);

    //
    // Look for existing listenr for multicast address
    //
    R<CMulticastListener> pListener = MsmpMapGetListener(MulticastId);

    //
    // Listener already exist. Only add the queue format to the map
    //
    if (pListener.get() != NULL)
    {
        MsmpMapAdd(QueueFormat, MulticastId, pListener);
        return;
    }

    //
    // A new listener is required
    //
    MsmpCreateListener(QueueFormat, MulticastId);
} 


VOID
MsmUnbind(
    const QUEUE_FORMAT& QueueFormat
    )
    throw()
/*++

Routine Description:

    Unbind queue from the multicast group it is currently bound to.

Arguments:

    QueueFormat - Identies the queue.

Returned Value:

    None.

--*/
{
    MsmpAssertValid();

    ASSERT((
        "Only private and public queues format names expected!", 
        QueueFormat.GetType() == QUEUE_FORMAT_TYPE_PRIVATE || QueueFormat.GetType() == QUEUE_FORMAT_TYPE_PUBLIC
        ));

    //
    // Ensure that no other thread tries to bind or unbind at the smae time. It can
    // cause database inconsistency.
    //
    CS lock(s_csBindUnbind);

    #ifdef _DEBUG
        WCHAR strQueueFormat[256];
        DWORD temp;

        MQpQueueFormatToFormatName(&QueueFormat, strQueueFormat, TABLE_SIZE(strQueueFormat), &temp, FALSE);
        TrTRACE(Msm, "UnBind queue %ls to assigned multicast address", strQueueFormat);
    #endif

    //
    // Remove the <queue, listener> pair from mapping database
    //
    MsmpMapRemove(QueueFormat);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\msmq\src\lib\mp\lib\srmpreqbuffer.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    srmpreqbuffer.cpp

Abstract:
    Implements CSrmpRequestBuffers (mp.h) that creates SRMP request buffer ready
	to send from msmq packet.

Author:
    Gil Shafriri(gilsh) 28-Nov-00

Environment:
    Platform-independent

--*/

#include <libpch.h>
#include <mp.h>
#include <mc.h>
#include <bufutl.h>
#include <utf8.h>
#include <qmpkt.h>
#include <fntoken.h>
#include <fn.h>
#include <mpp.h>
#include "envelop.h"
#include "attachments.h"

#include "srmpreqbuffer.tmh"


#define BOUNDARY_VALUE "MSMQ - SOAP boundary, %d"
const char xEnvelopeContentType[] = "text/xml";
const char xApplicationContentType[] = "application/octet-stream";
const char xMultipartContentType[] = "multipart/related";
const char xHttpHeaderTerminater[] = "\r\n\r\n";



static const xstr_t FindHttpHeader(const char* pStartHeader,DWORD size)
{
	const char* pEndHeader = std::search(
								 pStartHeader,
								 pStartHeader + size,
								 xHttpHeaderTerminater,
								 xHttpHeaderTerminater + STRLEN(xHttpHeaderTerminater)
								 );

   ASSERT(pEndHeader !=   pStartHeader + size);
   pEndHeader +=   STRLEN(xHttpHeaderTerminater);
   return xstr_t(pStartHeader, pEndHeader - pStartHeader);
}



static bool FilterHeaderField(const xstr_t& HeaderField)
/*++

Routine Description:
    return true if http header field needs to be filtered out from the new http header.
  
Arguments:
    
  
Returned Value:
   true if header field should be filtered out.

--*/
{
		static const char* HttpHeadersToFilter[] = {"Host:"};
		for(int i = 0; i< TABLE_SIZE(HttpHeadersToFilter); ++i)
		{
		   	bool fFound = UtlIsStartSec(
									HeaderField.Buffer(),
				                    HeaderField.Buffer() + HeaderField.Length(),
									HttpHeadersToFilter[i],
									HttpHeadersToFilter[i] + strlen(HttpHeadersToFilter[i]),
									UtlCharNocaseCmp<char>()
									);

		    if(fFound)
				return true;

		}
		return false;
}


static 
void 
EscapeAppend(
	CPreAllocatedResizeBuffer<utf8_char>& ResultBuffer, 
	const utf8_char* uri,
	size_t cbUri
	)

/*++

Routine Description:
    Convert the given utf-8 array of bytes to url encoding so IIS
	could handle it. Reserved on not allowed  caracters needs to be escape by prefixing them with % follow
	by their caracter code. 
  
Arguments:
	UriBuffer - buffer to append escaping result to.
	uri - utf8 bytes to escape if needed.
    cbUri - length in bytes of the buffer utf8 points to.

  
Returned Value:
   None

Note:
Currently only the spaces treated as special caracters.

--*/

{
	const char hex[] = "0123456789ABCDEF";

    for(size_t i =0 ; i<cbUri; ++i)
    {
		if(uri[i] == ' ' || (uri[i] & 0x80) || !isalnum(uri[i]))
        {
            ResultBuffer.append(utf8_char('%'));
            ResultBuffer.append(utf8_char(hex[uri[i]>>4]));
            ResultBuffer.append(utf8_char(hex[uri[i] & 0x0F]));
			continue;
        }
	
        ResultBuffer.append(utf8_char(uri[i]));
    }
	
}


/*++

Routine Description:
    Convert the given unicode host to utf-8 format escaping caracters if needed so IIS
	could handle it. Reserved or illegal  caracters escape by prefixing them with % follow
	by their caracter code. 
  
Arguments:
	EscapeUriBuffer - buffer to append conversion result to.
	host - host name to encode
  
Returned Value:
   None

Note:
Currently only the spaces treated as special caracters.

--*/
static void EncodeHost(CPreAllocatedResizeBuffer<utf8_char>& HostBuffer, LPCWSTR host)
{
	for(;*host != L'\0';++host)
	{
		utf8_char utf8[4];
		size_t len = UtlWcToUtf8(*host, utf8, TABLE_SIZE(utf8));
		ASSERT (len <= TABLE_SIZE(utf8));
		if(*host == L'.')
		{
			HostBuffer.append(utf8, len); 
		}
		else
		{
			EscapeAppend(HostBuffer, utf8, len);
		}
	}

	HostBuffer.append('\0'); 
}



/*++

Routine Description:
    Convert the given unicode uri to utf-8 format escaping caracter if needed so IIS
	could handle it. Reserved and illegal caracters escaped by prefixing them with % follow
	by their caracter code. 
  
Arguments:
	EscapeUriBuffer - buffer to append conversion result to.
	uri - Uri to adjust    
  
Returned Value:
   None

Note:
Currently only the spaces treated as special caracters.

--*/
static void EncodeUri(CPreAllocatedResizeBuffer<utf8_char>& UriBuffer, LPCWSTR uri)
{
	//
	// We should find the start of the local path because we don't translate
	// special caracters befor it.
	//
	LPCWSTR pPath = FnFindResourcePath(uri);
	ASSERT(pPath != NULL);
	ASSERT(pPath >=  uri);
 	
	for(bool fAfterHostPart = false; *uri != L'\0'; ++uri)
	{
		utf8_char utf8[4];
		size_t len = UtlWcToUtf8(*uri, utf8, TABLE_SIZE(utf8));
		ASSERT (len <= TABLE_SIZE(utf8));
	
		//
		// We dont escape the L"http://"  part
		//
		if(uri < pPath)
		{
			UriBuffer.append(utf8 ,len);
			continue;
		}


		//
		// We dont escape L'/' because it has special meaning of sperating the url parts
		//
		if(*uri == L'/') 
		{
			fAfterHostPart = true;
			UriBuffer.append(utf8 ,len);
			continue;
		}

	
		//
		// We don't escape L':' and L'.' if we are not after the host part
		// because it may have special meaning (host:port or www.microsoft.com) 
		//
		if( (*uri == L':' || *uri == L'.') && 	!fAfterHostPart)
		{
			UriBuffer.append(utf8 ,len);
			continue;
		}

		//
		// On all other cases - we escape the utf8 caracters if needed.
		//
		EscapeAppend(UriBuffer, utf8, len);
			
	}

	UriBuffer.append('\0'); 
}




CSrmpRequestBuffers::CSrmpRequestBuffers(
							const  CQmPacket& pkt,
							LPCWSTR host, 
							LPCWSTR uri
							):
							m_pkt(pkt),
							m_HttpRequestData(512)		
{


   EncodeUri(*m_uri.get(), uri);
   EncodeHost(*m_targethost.get(), host);

	//
	// If we have to forward existing messages(SFD) we have to do diferenet logic
	// then creating new SRMP  messages
	//
	if(pkt.IsSrmpIncluded())
	{
		SFDSerializeMessage();
		return;
	}

	//
	// create new SRMP message - because we are the source machine
	//
    SourceSerializeMessage();
}


/*++
Routine Description:
    return the number of winsock buffer available for send

  
Arguments:
None    
  
Returned Value:
The number of winsock buffer available for send

--*/
size_t CSrmpRequestBuffers::GetNumberOfBuffers() const
{
	return m_buffers.size();
}


/*++
Routine Description:
    Return pointer to array of send buffers
  
Arguments:
None    
  
Returned Value:
Pointer to array of send buffers
--*/
const WSABUF* CSrmpRequestBuffers::GetSendBuffers() const
{
	return m_buffers.begin();
}


std::wstring CSrmpRequestBuffers::GetEnvelop() const
{
	return UtlUtf8ToWcs(m_envelope);
}


/*++
Routine Description:
    Return the total data in bytes to send over the network.
  
Arguments:
None    
  
Returned Value:
Total data in bytes to send over the network.
--*/
size_t CSrmpRequestBuffers::GetSendDataLength() const
{
	size_t sum = 0;
	for(std::vector<WSABUF>::const_iterator it = m_buffers.begin(); it != m_buffers.end();++it)
	{
		sum += it->len;		
	}
	return sum;
}


/*++
Routine Description:
    Return pointer to serialized network data. This function will be used
	by local http send that needs to save on the packet the "Compound" message property.
  
Arguments:
None    
  
Returned Value:
Pointer to serialized network data.

Note:
The caller is responsible to call delete[] on the returned pointer.
--*/
BYTE*  CSrmpRequestBuffers::SerializeSendData() const
{
	size_t SendDataLength =  GetSendDataLength();
	AP<BYTE>  SendData = new BYTE[SendDataLength];
	BYTE* ptr = SendData.get(); 
	for(std::vector<WSABUF>::const_iterator it = m_buffers.begin(); it != m_buffers.end();++it)
	{
		memcpy(ptr, it->buf, it->len);
		ptr += it->len;
	}
	ASSERT(numeric_cast<size_t>((ptr -  SendData.get())) == SendDataLength);

	return 	SendData.detach();
}


const char* CSrmpRequestBuffers::GetHttpHeader() const
/*++
Routine Description:
    Return pointer http header from the send buffers
  
Arguments:
None    
  
Returned Value:
	pointer http header from the send buffers


Note:
The pointer is owned by  CSrmpRequestBuffers object - caller should not free it
--*/
{
	std::vector<WSABUF>::const_iterator it = m_buffers.begin();
	ASSERT(it !=   m_buffers.end());
	return it->buf;
}



size_t CSrmpRequestBuffers::GetHttpBodyLength() const
{
	return GetSendDataLength() -   GetHttpHeaderLength();
}


size_t CSrmpRequestBuffers::GetHttpHeaderLength() const
{
	std::vector<WSABUF>::const_iterator it = m_buffers.begin();
	ASSERT(it !=   m_buffers.end());
	return it->len;
}


BYTE*  CSrmpRequestBuffers::SerializeHttpBody() const
/*++
Routine Description:
    Return pointer to serialized http body data.
	
	  
Arguments:
None    
  
Returned Value:
pointer to serialized http body data.


Note:
The caller is responsible to call delete[] on the returned pointer.
--*/

{
	size_t BodyLength =  GetHttpBodyLength();
	AP<BYTE>  HttpBody = new BYTE[BodyLength + (2 * sizeof(BYTE))];
	BYTE* ptr = HttpBody.get(); 
	std::vector<WSABUF>::const_iterator it = m_buffers.begin();
	ASSERT(it != m_buffers.end());

	//
	// We have to skip the http header in order to get to the http body
	//
	it++;

	//
	// Serialize http body blocks
	//
	for(;it != m_buffers.end();++it)
	{
		memcpy(ptr, it->buf, it->len);
		ptr += it->len;
	}
	ASSERT(numeric_cast<size_t>((ptr -  HttpBody.get())) == BodyLength);

	//
	// Pad with two null termination for unicode parsing functions that ovperates on the body
	// for example swscanf.
	//
    HttpBody[BodyLength] = '\0';
    HttpBody[BodyLength + 1] = '\0';

	return 	HttpBody.detach();
}




void CSrmpRequestBuffers::CreateHttpRequestHeaders(const CAttachmentsArray& attachments)
{
	if (attachments.size() != 0)
    {
        //
        // Message refering to external payload. Create MIME header
        //
        CreateMultipartHeaders(attachments);
		return;
    }

    //
    // Simple message, that doesn't contains external reference
    //
    CreateSimpleHttpHeader();
}



DWORD
CSrmpRequestBuffers::GenerateEnvelopeAttachmentHeader(
    DWORD dataSize,
    DWORD boundaryId
    )
{
	size_t n = UtlSprintfAppend(
				&m_HttpRequestData,
                BOUNDARY_HYPHEN BOUNDARY_VALUE "\r\n"
                "Content-Type: %s; charset=UTF-8\r\n"
                "Content-Length: %d\r\n"
                "\r\n",
                boundaryId,
                xEnvelopeContentType,
                dataSize
                );

    return numeric_cast<DWORD>(n);
}


DWORD
CSrmpRequestBuffers::GenerateMultipartAttachmentHeader(
	DWORD dataSize,
    const xstr_t& contentId,
    DWORD boundaryId
    )
{
    const GUID* pGuid = &McGetMachineID();
    size_t n = UtlSprintfAppend(
				&m_HttpRequestData,
                BOUNDARY_HYPHEN BOUNDARY_VALUE "\r\n"
                "Content-Type: %s\r\n"
                "Content-Length: %d\r\n"
                "Content-Id: " MIME_ID_FMT_A "\r\n"
                "\r\n",
                boundaryId,
                xApplicationContentType,
                dataSize,
                contentId.Length(), contentId.Buffer(),
                GUID_ELEMENTS(pGuid)
                );

    return numeric_cast<DWORD>(n);
}



void CSrmpRequestBuffers::CreateMultipartHeaders(const CAttachmentsArray& attachments)
{
	DWORD boundaryId = rand();
	ASSERT(m_buffers.size() == 0);

    DWORD totalSize = 0;
    DWORD envLen = numeric_cast<DWORD>(m_envelope.size());


	//
	// http header - is the first buffer to send. set with null values - we don't know yet it's size
	//
	WSABUF buffer;
	buffer.buf = NULL;
	buffer.len =  0;
	m_buffers.push_back(buffer);


	//
	// On each data item we format into m_HttpRequestData we need to set NULL
	// in the coresponding sends buffer (wsabuf[bufIndex].buf) . This because the 
	// pointer to data is not known untill ends of formatting (because of possible memory realocation).
	// The NULL indicates that we should set this pointer to the real data
	// by the function 	SetBufferPointers , called at the end of formatting.
	//
    DWORD headerSize = GenerateEnvelopeAttachmentHeader(envLen, boundaryId);

	//
	// envelop header
	//
	buffer.buf = NULL;
	buffer.len =  headerSize;
	totalSize += buffer.len;
	m_buffers.push_back(buffer);

   
	//
	// Envelop body
	//
    buffer.buf = (LPSTR)m_envelope.c_str();
    buffer.len = envLen;
    totalSize += buffer.len;
	m_buffers.push_back(buffer);


	//
	// Attachments
	//
    for (DWORD i = 0; i < attachments.size(); ++i)
    {
        if (attachments[i].m_id.Length() == 0)
            break;

        headerSize = GenerateMultipartAttachmentHeader(
							    attachments[i].m_data.Length(),
                                attachments[i].m_id,
                                boundaryId
                                );
		//
		// Attachment headers
		//
        buffer.buf = NULL;
        buffer.len = headerSize;
        totalSize +=  buffer.len;
		m_buffers.push_back(buffer);
      

		//
		// Attachement  body
		//
        buffer.buf = (LPSTR)(attachments[i].m_data.Buffer());
        buffer.len = attachments[i].m_data.Length();
        totalSize +=  buffer.len;
		m_buffers.push_back(buffer);
    
    }

    //
    // Add boundry seperator in the end of the request
    //
    size_t n = UtlSprintfAppend(
							&m_HttpRequestData,
							BOUNDARY_HYPHEN BOUNDARY_VALUE BOUNDARY_HYPHEN "\r\n", 
							boundaryId
							);


	buffer.buf = NULL;
    buffer.len = numeric_cast<DWORD>(n);
    totalSize += buffer.len;
    m_buffers.push_back(buffer);


    //
    // Create HTTP header
    //

    headerSize = numeric_cast<DWORD>(
						UtlSprintfAppend(
						&m_HttpRequestData,
                        "POST %s HTTP/1.1\r\n"
                        "Host: %s\r\n"
                        "Content-Type: %s; boundary=\"" BOUNDARY_VALUE "\"; type=text/xml\r\n"
                        "Content-Length: %d\r\n"
						"SOAPAction: \"MSMQMessage\"\r\n"
                        "Proxy-Accept: NonInteractiveClient\r\n"
                        "\r\n",
                        m_uri.begin(),
                        m_targethost.begin(),
                        xMultipartContentType,
                        boundaryId,
                        totalSize
                        ));

    //
	// Fix the size of the http header
	//
    m_buffers[0].len = headerSize;

   	//
	//Now we need to fix set the send buffers to the formatted data.
	//Only at the end of the formatting we can do so - because the formatted buffers
	//can be realocated so pointer  are invalid untill the formating ends. 
	//
	SetBufferPointers();

}



void CSrmpRequestBuffers::CreateSimpleHttpHeader()
{
	ASSERT(m_buffers.size() == 0);

	DWORD envLen = numeric_cast<DWORD>(m_envelope.size());


    DWORD headerSize = numeric_cast<DWORD>(
							UtlSprintfAppend(
							&m_HttpRequestData,
                            "POST %s HTTP/1.1\r\n"	 
                            "Host: %s\r\n"
                            "Content-Type: %s\r\n"
                            "Content-Length: %d\r\n"
							"SOAPAction: \"MSMQMessage\"\r\n" 
                            "Proxy-Accept: NonInteractiveClient\r\n"
                            "\r\n",
                            m_uri.begin(),
                            m_targethost.begin(),
                            xEnvelopeContentType,
                            envLen
                            ));


    WSABUF  buffer;
	buffer.buf = NULL;
	buffer.len = headerSize;
	m_buffers.push_back(buffer);


	buffer.buf =  (LPSTR)m_envelope.c_str();
	buffer.len =  envLen;
	m_buffers.push_back(buffer);


	SetBufferPointers();
}


void CSrmpRequestBuffers::SetBufferPointers()
/*++

Routine Description:
    Set pointers in the sends buffers to the data.
	Only buffers that  has NULL data pointer needs to be set.
  
Arguments:
  None
  
Returned Value:
   None

--*/
{
	ASSERT(m_buffers.size() != 0);

	size_t pos = 0;
	for(DWORD i = 1; i<m_buffers.size(); ++i)
	{
		ASSERT(pos <= m_HttpRequestData.size());
		if(m_buffers[i].buf  == NULL)
		{
			m_buffers[i].buf =	const_cast<char*>(m_HttpRequestData.begin() + pos);
			pos += m_buffers[i].len;
		}
	}
	ASSERT(m_buffers[0].buf == NULL);
	m_buffers[0].buf = const_cast<char*>(m_HttpRequestData.begin() + pos);
	pos += 	m_buffers[0].len;
	ASSERT(pos == m_HttpRequestData.size());
}



void CSrmpRequestBuffers::SourceSerializeMessage()
{
	CAttachmentsArray attachments;
	PacketToAttachments(m_pkt, &attachments);

	m_envelope =  UtlWcsToUtf8(GenerateEnvelope(m_pkt));
     
	CreateHttpRequestHeaders(attachments);
}


static void CheckRequestLine(const xstr_t& RequestLine)
{
	const char xPost[] = "POST";
	ASSERT(UtlIsStartSec(
					RequestLine.Buffer(),
					RequestLine.Buffer() + RequestLine.Length(),
					xPost,
					xPost + STRLEN(xPost),
					UtlCharNocaseCmp<char>()
					));

	DBG_USED(RequestLine);
	DBG_USED(xPost);
}



void CSrmpRequestBuffers::CreateSFDHeader(const xstr_t& OrgHeader)
/*++

Routine Description:
      create http header based on the original http header.
	  In general , Hdears fileds are copied from the original header except
	  few field must be removed from the new header - for exmaple the Host:
	  field.
	  
Arguments:
    OrgHeader - original header.
	  
Returned Value:
   None

--*/
{
	ASSERT(m_HttpRequestData.size() == 0);

	
	UtlSprintfAppend(
				&m_HttpRequestData,
				"POST %s HTTP/1.1\r\n"
                "Host: %s\r\n",
				m_uri.begin(),
                m_targethost.begin()
				);

    CStrToken StrToken ( 
					OrgHeader,
					"\r\n"
					);
	//
	// Loop over all the fields in the original header and check if to
	// include them in the new header or not. The first line is the post
	// method and is not included anyway
	//
	for(CStrToken::iterator it = StrToken.begin(); it != StrToken.end(); ++it)
	{
		if(it == StrToken.begin())
		{
			CheckRequestLine(*it);
			continue;
		}

		if(!FilterHeaderField(*it))
		{
			UtlSprintfAppend(
				&m_HttpRequestData,
                "%.*s\r\n",
				it->Length(),
				it->Buffer()
				);
	
		}
	}

	//
	// set the created header on the send buffer
	//
	WSABUF buffer;
	buffer.buf = m_HttpRequestData.begin();
	buffer.len = numeric_cast<DWORD>(m_HttpRequestData.size());
	m_buffers.push_back(buffer);
}




void CSrmpRequestBuffers::SFDSerializeMessage()
/*++

Routine Description:
    Serialize messages in an SFD. In SFD we should deliver
	the original messages just with some changes to the http header
  
Arguments:
   
Returned Value:
   None

--*/
{
	//
	// Get the priginal messages and find where http header ends
	//
	const char* pOrgHeaderStart =  (char*)m_pkt.GetPointerToCompoundMessage();
	DWORD OrgMessageSize = m_pkt.GetCompoundMessageSizeInBytes();
	
	//
	// Create the new http header based on the or